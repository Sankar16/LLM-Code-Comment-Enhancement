[
    {
        "raw_code": "def find_all(req)\n        result = super\n        if system_plugins.include?(req.name)\n          result.delete_if do |spec|\n            spec.is_a?(Gem::Resolver::InstalledSpecification)\n          end",
        "comment": "Allow InstallerSet to find matching specs, then filter for preferred sources",
        "label": "Why",
        "id": "8910"
    },
    {
        "raw_code": "def bigint_index_name(int_column_index_name)\n          # First 20 digits of the hash is chosen to make sure it fits the 63 chars limit\n          digest = Digest::SHA256.hexdigest(int_column_index_name).first(20)\n          \"bigint_idx_#{digest}\"\n        end",
        "comment": "default 'index_name' method is not used because this method can be reused while swapping/dropping the indexes",
        "label": "Why",
        "id": "3136"
    },
    {
        "raw_code": "def signed_id(expires_in: nil, expires_at: nil, purpose: nil)\n      raise ArgumentError, \"Cannot get a signed_id for a new record\" if new_record?\n\n      self.class.signed_id_verifier.generate id, expires_in: expires_in, expires_at: expires_at, purpose: self.class.combine_signed_id_purposes(purpose)\n    end",
        "comment": "Returns a signed id that's generated using a preconfigured +ActiveSupport::MessageVerifier+ instance.  This signed id is tamper proof, so it's safe to send in an email or otherwise share with the outside world. However, as with any message signed with a +ActiveSupport::MessageVerifier+, {the signed id is not encrypted}[link:classes/ActiveSupport/MessageVerifier.html#class-ActiveSupport::MessageVerifier-label-Signing+is+not+encryption]. It's just encoded and protected against tampering.  This means that the ID can be decoded by anyone; however, if tampered with (so to point to a different ID), the cryptographic signature will no longer match, and the signed id will be considered invalid and return nil when passed to +find_signed+ (or raise with +find_signed!+).  It can furthermore be set to expire (the default is not to expire), and scoped down with a specific purpose. If the expiration date has been exceeded before +find_signed+ is called, the id won't find the designated record. If a purpose is set, this too must match.  If you accidentally let a signed id out in the wild that you wish to retract sooner than its expiration date (or maybe you forgot to set an expiration date while meaning to!), you can use the purpose to essentially version the signed_id, like so:  user.signed_id purpose: :v2  And you then change your +find_signed+ calls to require this new purpose. Any old signed ids that were not created with the purpose will no longer find the record.",
        "label": "Why",
        "id": "12699"
    },
    {
        "raw_code": "def self.unset(jid)\n      with_redis do |redis|\n        redis.del(key_for(jid))\n      end",
        "comment": "Stops the tracking of the given job.  jid - The Sidekiq job ID to remove.",
        "label": "Why",
        "id": "1468"
    },
    {
        "raw_code": "def on_gvasgn(node)\n          return unless (name = node.name)\n          return unless forbidden_name?(name)\n\n          register_forbidden_name(node)\n        end",
        "comment": "Only forbidden names are checked for global variable assignment",
        "label": "Why",
        "id": "10339"
    },
    {
        "raw_code": "def each_associated(parent_record, associated)\n          associated = associated.to_h\n\n          compose_associated_id!(parent_record, associated)\n\n          return if already_imported?(associated) || importer_class::SUPPORTED_EVENTS.exclude?(associated[:event])\n\n          cache_event(parent_record, associated)\n\n          increment_object_counter(associated[:event])\n\n          pull_request = parent_record.is_a? MergeRequest\n          associated[:issue] = { number: parent_record.iid, pull_request: pull_request }\n          yield(associated)\n\n          mark_as_imported(associated)\n        end",
        "comment": "In single endpoint there is no issue info to which associated related To make it possible to identify issue in separated worker we need to patch Sawyer instances here with issue number",
        "label": "Why",
        "id": "2208"
    },
    {
        "raw_code": "def circuit_breaker_options\n      {\n        sleep_window: 24.hours,\n        time_window: 10.minutes,\n        volume_threshold: 5\n      }\n    end",
        "comment": "Disable CodeNavigation feature for 24 hours after several timeouts caused by a slow SQL query",
        "label": "Why",
        "id": "1437"
    },
    {
        "raw_code": "def sort_by_attribute(method)\n      case method.to_s\n      when 'storage_size_desc' then sorted_by_storage_size_desc\n      when 'storage_size_asc' then sorted_by_storage_size_asc\n      when 'repository_size_desc' then sorted_by_repository_size_desc\n      when 'repository_size_asc' then sorted_by_repository_size_asc\n      when 'snippets_size_desc'then sorted_by_snippets_size_desc\n      when 'snippets_size_asc'then sorted_by_snippets_size_asc\n      when 'build_artifacts_size_desc' then sorted_by_build_artifacts_size_desc\n      when 'build_artifacts_size_asc'then sorted_by_build_artifacts_size_asc\n      when 'lfs_objects_size_desc'then sorted_by_lfs_objects_size_desc\n      when 'lfs_objects_size_asc' then sorted_by_lfs_objects_size_asc\n      when 'packages_size_desc' then sorted_by_packages_size_desc\n      when 'packages_size_asc' then sorted_by_packages_size_asc\n      when 'wiki_size_desc' then sorted_by_wiki_size_desc\n      when 'wiki_size_asc'then sorted_by_wiki_size_asc\n      when 'container_registry_size_desc' then sorted_by_container_registry_size_desc\n      when 'container_registry_size_asc' then sorted_by_container_registry_size_asc\n      when 'latest_activity_desc' then sorted_by_updated_desc\n      when 'latest_activity_asc' then sorted_by_updated_asc\n      when 'path_desc'then sorted_by_path_desc\n      when 'path_asc' then sorted_by_path_asc\n      when 'full_path_desc'then sorted_by_full_path_desc\n      when 'full_path_asc' then sorted_by_full_path_asc\n      when 'stars_desc' then sorted_by_stars_desc\n      when 'stars_asc' then sorted_by_stars_asc\n      else\n        order_by(method)\n      end",
        "comment": "rubocop:disable Metrics/CyclomaticComplexity -- stick to existing implementation for sort params:",
        "label": "Why",
        "id": "6727"
    },
    {
        "raw_code": "def calculate_reactive_cache(query_class_name, *args)\n      return unless prometheus_client\n\n      data = Object.const_get(query_class_name, false).new(prometheus_client).query(*args)\n      {\n        success: true,\n        data: data,\n        last_update: Time.current.utc\n      }\n    rescue Gitlab::PrometheusClient::Error => e\n      { success: false, result: e.message }\n    end",
        "comment": "Cache metrics for specific environment",
        "label": "Why",
        "id": "7318"
    },
    {
        "raw_code": "def all_queuing_entries\n      ::Ci::PendingBuild.where(build_id: id)\n    end",
        "comment": " We can have only one queuing entry or running build tracking entry, because there is a unique index on `build_id` in each table, but we need a relation to remove these entries more efficiently in a single statement without actually loading data. ",
        "label": "Why",
        "id": "7540"
    },
    {
        "raw_code": "def init_mentioned_in(record_class, iid)\n            db_id = fetch_mentioned_in_db_id(record_class, iid)\n            return if db_id.nil?\n\n            record = record_class.new(id: db_id, iid: iid)\n            record.project = project\n            record.namespace = project.project_namespace if record.respond_to?(:namespace)\n            record.readonly!\n            record\n          end",
        "comment": "record_class - Issue/MergeRequest",
        "label": "Why",
        "id": "2233"
    },
    {
        "raw_code": "def stub_application_setting_enum(setting, value)\n    stub_application_setting(setting.to_sym => value)\n\n    ApplicationSetting.send(setting.pluralize.to_sym).each_key do |key|\n      stub_application_setting(\"#{setting}_#{key}\".to_sym => key == value)\n    end",
        "comment": "For enums with `_prefix: true`, this allows us to stub the application setting properly",
        "label": "Why",
        "id": "8381"
    },
    {
        "raw_code": "def raw_state # :nodoc:\n        synchronize do\n          threads = @sleeping.keys | @sharing.keys | @waiting.keys\n          threads |= [@exclusive_thread] if @exclusive_thread\n\n          data = {}\n\n          threads.each do |thread|\n            purpose, compatible = @waiting[thread]\n\n            data[thread] = {\n              thread: thread,\n              sharing: @sharing[thread],\n              exclusive: @exclusive_thread == thread,\n              purpose: purpose,\n              compatible: compatible,\n              waiting: !!@waiting[thread],\n              sleeper: @sleeping[thread],\n            }\n          end",
        "comment": "We track Thread objects, instead of just using counters, because we need exclusive locks to be reentrant, and we need to be able to upgrade share locks to exclusive.",
        "label": "Why",
        "id": "14058"
    },
    {
        "raw_code": "def unique_internal(scope, username, email_pattern, &block)\n      if @organization_id && organization_users_internal_enabled? # rubocop:disable Style/IfUnlessModifier -- exceeds line length\n        scope = scope.where(organization_id: @organization_id)\n      end",
        "comment": "NOTE: This method is patched in spec/spec_helper.rb to allow use of exclusive lease in RSpec's :before_all scope to keep the specs DRY.",
        "label": "Why",
        "id": "3675"
    },
    {
        "raw_code": "def unexpected(error, severity: :warning, context: {}, source: DEFAULT_SOURCE)\n      error = RuntimeError.new(error) if error.is_a?(String)\n\n      if @debug_mode\n        ensure_backtrace(error)\n        raise UnexpectedError, \"#{error.class.name}: #{error.message}\", error.backtrace, cause: error\n      else\n        report(error, handled: true, severity: severity, context: context, source: source)\n      end",
        "comment": "Either report the given error when in production, or raise it when in development or test.  When called in production, after the error is reported, this method will return nil and execution will continue.  When called in development, the original error is wrapped in a different error class to ensure it's not being rescued higher in the stack and will be surfaced to the developer.  This method is intended for reporting violated assertions about preconditions, or similar cases that can and should be gracefully handled in production, but that aren't supposed to happen.  The error can be either an exception instance or a String.  example:  def edit if published? Rails.error.unexpected(\"[BUG] Attempting to edit a published article, that shouldn't be possible\") return false end # ... end ",
        "label": "Why",
        "id": "13841"
    },
    {
        "raw_code": "def self.omnibus_config_filepath\n            unless ENV.key?(OMNIBUS_CONFIG_ENV)\n              raise ::Gitlab::Backup::Cli::Error, \"#{OMNIBUS_CONFIG_ENV} is not defined\"\n            end",
        "comment": "@return [Pathname|Nillable]",
        "label": "Why",
        "id": "1103"
    },
    {
        "raw_code": "def acts_like_time?\n      true\n    end",
        "comment": "So that +self+ <tt>acts_like?(:time)</tt>.",
        "label": "Why",
        "id": "13993"
    },
    {
        "raw_code": "def usage_activity_by_stage_release(time_period)\n        time_frame = metric_time_period(time_period)\n        {\n          deployments: distinct_count(::Deployment.where(time_period), :user_id),\n          failed_deployments: distinct_count(::Deployment.failed.where(time_period), :user_id),\n          releases: distinct_count(::Release.where(time_period), :author_id),\n          successful_deployments: distinct_count(::Deployment.success.where(time_period), :user_id),\n          releases_with_milestones: add_metric('CountUsersAssociatingMilestonesToReleasesMetric', time_frame: time_frame)\n        }\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord Omitted because no user, creator or author associated: `environments`, `feature_flags`, `in_review_folder`, `pages_domains` rubocop: disable CodeReuse/ActiveRecord",
        "label": "Why",
        "id": "1738"
    },
    {
        "raw_code": "def test_exists_with_order_and_distinct\n    assert_equal true, Topic.order(:id).distinct.exists?\n  end",
        "comment": "Ensure +exists?+ runs without an error by excluding distinct value. See https://github.com/rails/rails/pull/26981.",
        "label": "Why",
        "id": "13510"
    },
    {
        "raw_code": "def quiet\n      return if @done\n\n      @done = true\n      @managers.each(&:quiet)\n      @poller.terminate\n      fire_event(:quiet, reverse: true)\n    end",
        "comment": "Stops this instance from processing any more jobs,",
        "label": "Why",
        "id": "5087"
    },
    {
        "raw_code": "def create_target_branch\n        @project.repository.create_branch(@merge_request.target_branch, @merge_request.target_branch_sha)\n      rescue StandardError => err\n        ::Import::Framework::Logger.warn(\n          message: 'Import warning: Failed to create target branch',\n          target_branch: @merge_request.target_branch,\n          diff_head_sha: @diff_head_sha,\n          merge_request_iid: @merge_request.iid,\n          error: err.message\n        )\n      end",
        "comment": "Ignore failures during target branch creation so we still create the merge request itself.",
        "label": "Why",
        "id": "2816"
    },
    {
        "raw_code": "def create\n          validate_required_fields!\n\n          response = @client.post_xml(build, path: '/createItem', params: { name: name })\n\n          check_network_error(response)\n          response.body\n        end",
        "comment": "Saves the Job in Jenkins",
        "label": "Why",
        "id": "4328"
    },
    {
        "raw_code": "def snippet\n    snippet_klass.inc_relations_for_view.find_by(snippet_find_params)\n  end",
        "comment": "rubocop:disable CodeReuse/ActiveRecord",
        "label": "Why",
        "id": "6529"
    },
    {
        "raw_code": "def id\n      \"#{project.id}-#{current_user.id}\"\n    end",
        "comment": "Required for ReactiveCaching, it is also used in `reactive_cache_worker_finder`",
        "label": "Why",
        "id": "5766"
    },
    {
        "raw_code": "def limit(limit)\n        chars(@wrapped_string.truncate_bytes(limit, omission: nil))\n      end",
        "comment": "Limits the byte size of the string to a number of bytes without breaking characters. Usable when the storage for a string is limited for some reason.  '\u3053\u3093\u306b\u3061\u306f'.mb_chars.limit(7).to_s # => \"\u3053\u3093\"",
        "label": "Why",
        "id": "14497"
    },
    {
        "raw_code": "def remove(klass)\n        entries.delete_if { |entry| entry.klass == klass }\n      end",
        "comment": "Remove all middleware matching the given Class @param klass [Class]",
        "label": "Why",
        "id": "5199"
    },
    {
        "raw_code": "def load_method(klass_name, method_name)\n    file = method_file klass_name, method_name\n\n    obj = marshal_load(file)\n    obj.store = self\n    obj.parent ||= find_class_or_module(klass_name) || load_class(klass_name)\n    obj\n  rescue Errno::ENOENT => e\n    error = MissingFileError.new(self, file, klass_name + method_name)\n    error.set_backtrace e.backtrace\n    raise error\n  end",
        "comment": " Loads ri data for +method_name+ in +klass_name+",
        "label": "Why",
        "id": "15876"
    },
    {
        "raw_code": "def spec_glob_pattern(pattern)\n          unless pattern.is_a?(String) && pattern.end_with?(\"_spec.rb\")\n            raise ArgumentError, \"Scenario #{self.class.name} defines pattern that is not matching only spec files\"\n          end",
        "comment": "Glob pattern limiting which specs scenario can run  @param pattern [String] @return [String]",
        "label": "Why",
        "id": "4247"
    },
    {
        "raw_code": "def create_enum(...) # :nodoc:\n      end",
        "comment": "This is meant to be implemented by the adapters that support custom enum types",
        "label": "Why",
        "id": "12911"
    },
    {
        "raw_code": "def patch_addPadding(patches)\n    padding_length = patch_margin\n    null_padding = (1..padding_length).map{ |x| x.chr(Encoding::UTF_8) }.join\n  \n    # Bump all the patches forward.\n    patches.each do |patch|\n      patch.start1 += padding_length\n      patch.start2 += padding_length\n    end",
        "comment": "Add some padding on text start and end so that edges can match something. Intended to be called only from within patch_apply.",
        "label": "Why",
        "id": "5077"
    },
    {
        "raw_code": "def create_first_commit_using_db_data(snippet)\n      return if snippet_actions.empty?\n\n      attrs = commit_attrs(snippet, INITIAL_COMMIT_MSG)\n      actions = [{ file_path: snippet.file_name, content: snippet.content }]\n\n      snippet.snippet_repository.multi_files_action(current_user, actions, **attrs)\n    end",
        "comment": "If the user provides `snippet_actions` and the repository does not exist, we need to commit first the snippet info stored in the database.  Mostly because the content inside `snippet_actions` would assume that the file is already in the repository.",
        "label": "Why",
        "id": "5674"
    },
    {
        "raw_code": "def rouge_formatter(lexer)\n        Formatters::HTMLLegacy.new(css_class: \"highlight #{lexer.tag}\")\n      end",
        "comment": "override this method for custom formatting behavior",
        "label": "Why",
        "id": "3741"
    },
    {
        "raw_code": "def test_do_methods_in_c\n    content = <<-EOF\nVALUE blah(VALUE klass, VALUE year) {\n}\n\nvoid Init_Blah(void) {\n  cDate = rb_define_class(\"Date\", rb_cObject);\n\n  rb_define_method(cDate, \"blah\", blah, 1); /* in blah.c */\n}\n    EOF\n\n    klass = nil\n\n    _, err = verbose_capture_output do\n      klass = util_get_class content, 'cDate'\n    end",
        "comment": "HACK parsing warning instead of setting up in file",
        "label": "Why",
        "id": "16852"
    },
    {
        "raw_code": "def detect_race_on_record(log_fields: {})\n    # Ensure attributes is always an array before we log\n    log_fields[:attributes] = Array(log_fields[:attributes])\n\n    Gitlab::AppLogger.info(\n      message: 'Acquiring lease for project statistics update',\n      model: self.class.name,\n      model_id: id,\n      **parent_log_fields,\n      **log_fields,\n      **Gitlab::ApplicationContext.current\n    )\n\n    in_lock(database_lock_key, retries: 0) do\n      yield\n    end",
        "comment": "This method uses a lease to monitor access to the model row. This is needed to detect concurrent attempts to increment columns, which could result in a race condition.  As the purpose is to detect and warn concurrent attempts, it falls back to direct update on the row if it fails to obtain the lease.  It does not guarantee that there will not be any concurrent updates.",
        "label": "Why",
        "id": "7243"
    },
    {
        "raw_code": "def post_move_cleanup\n          # The update is only done here for testing purposes, these attributes will be removed upon original work item\n          # cleanup.\n          work_item.update(start_date: nil, due_date: nil)\n          work_item.dates_source&.destroy\n        end",
        "comment": "NOTE: This method is for cleanup simulation and testing purposes, it is not actually called within the application yet.  In the product, the post move cleanup of widget data is going to be implemented later.",
        "label": "Why",
        "id": "6026"
    },
    {
        "raw_code": "def POST\n      fetch_header(\"action_dispatch.request.request_parameters\") do\n        encoding_template = Request::Utils::CustomParamEncoder.action_encoding_template(self, path_parameters[:controller], path_parameters[:action])\n\n        param_list = nil\n        pr = parse_formatted_parameters(params_parsers) do\n          if param_list = request_parameters_list\n            ActionDispatch::ParamBuilder.from_pairs(param_list, encoding_template: encoding_template)\n          else\n            # We're not using a version of Rack that provides raw form\n            # pairs; we must use its hash (and thus post-process it below).\n            fallback_request_parameters\n          end",
        "comment": "Override Rack's POST method to support indifferent access.",
        "label": "Why",
        "id": "11469"
    },
    {
        "raw_code": "def separators_match\n        NamespaceMapper.map_match\n      end",
        "comment": "@return [Regexp] the regexp match of all separators",
        "label": "Why",
        "id": "601"
    },
    {
        "raw_code": "def create_virtual_table(*) # :nodoc:\n      end",
        "comment": "This is meant to be implemented by the adapters that support virtual tables",
        "label": "Why",
        "id": "12916"
    },
    {
        "raw_code": "def post_move_cleanup\n          IssueLink.for_source(work_item).each_batch(of: BATCH_SIZE, column: :target_id) do |links_batch|\n            links_batch.delete_all\n          end",
        "comment": "NOTE: No need to override this in EE for legacy ::Epic::RelatedEpicLink records, because ::Epic::RelatedEpicLink records are built to contain `issue_link_id` FK with ON DELETE CASCADE, which would delete ::Epic::RelatedEpicLink when corresponding IssueLink records for a given Epic Work Item are deleted in this method.",
        "label": "Why",
        "id": "6031"
    },
    {
        "raw_code": "def db_key_base_keys\n    @db_key_base_keys ||= Array(Gitlab::Application.credentials.db_key_base).tap do |keys|\n      raise(MultipleDbKeyBaseError, \"Defining multiple `db_key_base` keys isn't supported yet.\") if keys.size > 1\n    end",
        "comment": "This should be used for :per_attribute_iv_and_salt mode. There is no need to truncate the key because the encryptor will use the salt to generate a hash of the password: https://github.com/attr-encrypted/encryptor/blob/c3a62c4a9e74686dd95e0548f9dc2a361fdc95d1/lib/encryptor.rb#L77",
        "label": "Why",
        "id": "1260"
    },
    {
        "raw_code": "def drop_table_if_exists(table_name)\n    Gitlab::Database.database_base_models.each_value do |model|\n      model.connection.execute(\"DROP TABLE IF EXISTS #{table_name}\")\n    end",
        "comment": "To drop the test tables that have been created in the test migrations",
        "label": "Why",
        "id": "8240"
    },
    {
        "raw_code": "def delete_entry(key, **options)\n          rescue_error_with(false) { @data.with { |c| c.delete(key) } }\n        end",
        "comment": "Delete an entry from the cache.",
        "label": "Why",
        "id": "14035"
    },
    {
        "raw_code": "def perform\n        each_sub_batch do |sub_batch|\n          sub_batch\n            .where.not(auto_canceled_by_id: nil)\n            .where('ci_pipelines.auto_canceled_by_id = canceling_pipelines.id')\n            .update_all('auto_canceled_by_partition_id = canceling_pipelines.partition_id FROM ci_pipelines as canceling_pipelines')\n        end",
        "comment": "rubocop:disable Layout/LineLength -- Improve readability",
        "label": "Why",
        "id": "3274"
    },
    {
        "raw_code": "def processed\n    process unless processed?\n    variant.processed if variant?\n    self\n  end",
        "comment": "Processes the preview if it has not been processed yet. Returns the receiving +ActiveStorage::Preview+ instance for convenience:  blob.preview(resize_to_limit: [100, 100]).processed.url  Processing a preview generates an image from its blob and attaches the preview image to the blob. Because the preview image is stored with the blob, it is only generated once.",
        "label": "Why",
        "id": "13630"
    },
    {
        "raw_code": "def available_action?(action_name)\n      _find_action_name(action_name)\n    end",
        "comment": "Returns true if a method for the action is available and can be dispatched, false otherwise.  Notice that `action_methods.include?(\"foo\")` may return false and `available_action?(\"foo\")` returns true because this method considers actions that are also available through other means, for example, implicit render ones.  #### Parameters *   `action_name` - The name of an action to be tested ",
        "label": "Why",
        "id": "11184"
    },
    {
        "raw_code": "def fields_for(record_name, record_object = nil, fields_options = nil, &block)\n        fields_options, record_object = record_object, nil if fields_options.nil? && record_object.is_a?(Hash) && record_object.extractable_options?\n        fields_options ||= {}\n        fields_options[:builder] ||= options[:builder]\n        fields_options[:namespace] = options[:namespace]\n        fields_options[:parent_builder] = self\n\n        case record_name\n        when String, Symbol\n          if nested_attributes_association?(record_name)\n            return fields_for_with_nested_attributes(record_name, record_object, fields_options, block)\n          end",
        "comment": "Creates a scope around a specific model object like #form_with, but doesn't create the form tags themselves. This makes +fields_for+ suitable for specifying additional model objects in the same form.  Although the usage and purpose of +fields_for+ is similar to #form_with's, its method signature is slightly different. Like #form_with, it yields a FormBuilder object associated with a particular model object to a block, and within the block allows methods to be called on the builder to generate fields associated with the model object. Fields may reflect a model object in two ways - how they are named (hence how submitted values appear within the +params+ hash in the controller) and what default values are shown when the form fields are first displayed. In order for both of these features to be specified independently, both an object name (represented by either a symbol or string) and the object itself can be passed to the method separately -  <%= form_with model: @person do |person_form| %> First name: <%= person_form.text_field :first_name %> Last name : <%= person_form.text_field :last_name %>  <%= fields_for :permission, @person.permission do |permission_fields| %> Admin?  : <%= permission_fields.checkbox :admin %> <% end %>  <%= person_form.submit %> <% end %>  In this case, the checkbox field will be represented by an HTML +input+ tag with the +name+ attribute <tt>permission[admin]</tt>, and the submitted value will appear in the controller as <tt>params[:permission][:admin]</tt>. If <tt>@person.permission</tt> is an existing record with an attribute +admin+, the initial state of the checkbox when first displayed will reflect the value of <tt>@person.permission.admin</tt>.  Often this can be simplified by passing just the name of the model object to +fields_for+ -  <%= fields_for :permission do |permission_fields| %> Admin?: <%= permission_fields.checkbox :admin %> <% end %>  ...in which case, if <tt>:permission</tt> also happens to be the name of an instance variable <tt>@permission</tt>, the initial state of the input field will reflect the value of that variable's attribute <tt>@permission.admin</tt>.  Alternatively, you can pass just the model object itself (if the first argument isn't a string or symbol +fields_for+ will realize that the name has been omitted) -  <%= fields_for @person.permission do |permission_fields| %> Admin?: <%= permission_fields.checkbox :admin %> <% end %>  and +fields_for+ will derive the required name of the field from the _class_ of the model object, e.g. if <tt>@person.permission</tt>, is of class +Permission+, the field will still be named <tt>permission[admin]</tt>.  Note: This also works for the methods in FormOptionsHelper and DateHelper that are designed to work with an object as base, like FormOptionsHelper#collection_select and DateHelper#datetime_select.  +fields_for+ tries to be smart about parameters, but it can be confused if both name and value parameters are provided and the provided value has the shape of an option Hash. To remove the ambiguity, explicitly pass an option Hash, even if empty.  <%= form_with model: @person do |person_form| %> ... <%= fields_for :permission, @person.permission, {} do |permission_fields| %> Admin?: <%= checkbox_tag permission_fields.field_name(:admin), @person.permission[:admin] %> <% end %> ... <% end %>  === Nested Attributes Examples  When the object belonging to the current scope has a nested attribute writer for a certain attribute, +fields_for+ will yield a new scope for that attribute. This allows you to create forms that set or change the attributes of a parent object and its associations in one go.  Nested attribute writers are normal setter methods named after an association. The most common way of defining these writers is either with +accepts_nested_attributes_for+ in a model definition or by defining a method with the proper name. For example: the attribute writer for the association <tt>:address</tt> is called <tt>address_attributes=</tt>.  Whether a one-to-one or one-to-many style form builder will be yielded depends on whether the normal reader method returns a _single_ object or an _array_ of objects.  ==== One-to-one  Consider a Person class which returns a _single_ Address from the <tt>address</tt> reader method and responds to the <tt>address_attributes=</tt> writer method:  class Person def address @address end  def address_attributes=(attributes) # Process the attributes hash end end  This model can now be used with a nested +fields_for+, like so:  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :address do |address_fields| %> Street  : <%= address_fields.text_field :street %> Zip code: <%= address_fields.text_field :zip_code %> <% end %> ... <% end %>  When address is already an association on a Person you can use +accepts_nested_attributes_for+ to define the writer method for you:  class Person < ActiveRecord::Base has_one :address accepts_nested_attributes_for :address end  If you want to destroy the associated model through the form, you have to enable it first using the <tt>:allow_destroy</tt> option for +accepts_nested_attributes_for+:  class Person < ActiveRecord::Base has_one :address accepts_nested_attributes_for :address, allow_destroy: true end  Now, when you use a form element with the <tt>_destroy</tt> parameter, with a value that evaluates to +true+, you will destroy the associated model (e.g. 1, '1', true, or 'true'):  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :address do |address_fields| %> ... Delete: <%= address_fields.checkbox :_destroy %> <% end %> ... <% end %>  ==== One-to-many  Consider a Person class which returns an _array_ of Project instances from the <tt>projects</tt> reader method and responds to the <tt>projects_attributes=</tt> writer method:  class Person def projects [@project1, @project2] end  def projects_attributes=(attributes) # Process the attributes hash end end  Note that the <tt>projects_attributes=</tt> writer method is in fact required for +fields_for+ to correctly identify <tt>:projects</tt> as a collection, and the correct indices to be set in the form markup.  When projects is already an association on Person you can use +accepts_nested_attributes_for+ to define the writer method for you:  class Person < ActiveRecord::Base has_many :projects accepts_nested_attributes_for :projects end  This model can now be used with a nested +fields_for+. The block given to the nested +fields_for+ call will be repeated for each instance in the collection:  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects do |project_fields| %> <% if project_fields.object.active? %> Name: <%= project_fields.text_field :name %> <% end %> <% end %> ... <% end %>  It's also possible to specify the instance to be used:  <%= form_with model: @person do |person_form| %> ... <% @person.projects.each do |project| %> <% if project.active? %> <%= person_form.fields_for :projects, project do |project_fields| %> Name: <%= project_fields.text_field :name %> <% end %> <% end %> <% end %> ... <% end %>  Or a collection to be used:  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects, @active_projects do |project_fields| %> Name: <%= project_fields.text_field :name %> <% end %> ... <% end %>  If you want to destroy any of the associated models through the form, you have to enable it first using the <tt>:allow_destroy</tt> option for +accepts_nested_attributes_for+:  class Person < ActiveRecord::Base has_many :projects accepts_nested_attributes_for :projects, allow_destroy: true end  This will allow you to specify which models to destroy in the attributes hash by adding a form element for the <tt>_destroy</tt> parameter with a value that evaluates to +true+ (e.g. 1, '1', true, or 'true'):  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects do |project_fields| %> Delete: <%= project_fields.checkbox :_destroy %> <% end %> ... <% end %>  When a collection is used you might want to know the index of each object in the array. For this purpose, the <tt>index</tt> method is available in the FormBuilder object.  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects do |project_fields| %> Project #<%= project_fields.index %> ... <% end %> ... <% end %>  Note that +fields_for+ will automatically generate a hidden field to store the ID of the record. There are circumstances where this hidden field is not needed and you can pass <tt>include_id: false</tt> to prevent +fields_for+ from rendering it automatically.",
        "label": "Why",
        "id": "11889"
    },
    {
        "raw_code": "def parse(source, path = nil)\n        ProcessedSource.new(source, target_ruby_version, path, parser_engine: parser_engine)\n      end",
        "comment": "There should be very limited reasons for a Cop to do it's own parsing",
        "label": "Why",
        "id": "10263"
    },
    {
        "raw_code": "def pluralisation_rule\n          Gitlab::I18n::Pluralization\n        end",
        "comment": "FastGettext allows to set the rule via `FastGettext.pluralisation_rule=` which is on thread-level.  Because we are patching FastGettext at boot time per thread values won't work so we have to override the method implementation.  `FastGettext.pluralisation_rule=` has now no effect.",
        "label": "Why",
        "id": "2955"
    },
    {
        "raw_code": "def attribute_before_type_cast(attr_name)\n          @attributes[attr_name].value_before_type_cast\n        end",
        "comment": "Dispatch target for <tt>*_before_type_cast</tt> attribute methods.",
        "label": "Why",
        "id": "12831"
    },
    {
        "raw_code": "def encode(value, options = nil)\n        if options.nil? || options.empty?\n          Encoding.encode_without_options(value)\n        elsif options == { escape: false }.freeze\n          Encoding.encode_without_escape(value)\n        else\n          Encoding.json_encoder.new(options).encode(value)\n        end",
        "comment": "Dumps objects in JSON (JavaScript Object Notation). See http://www.json.org for more info.  ActiveSupport::JSON.encode({ team: 'rails', players: '36' }) # => \"{\\\"team\\\":\\\"rails\\\",\\\"players\\\":\\\"36\\\"}\"  By default, it generates JSON that is safe to include in JavaScript, as it escapes U+2028 (Line Separator) and U+2029 (Paragraph Separator):  ActiveSupport::JSON.encode({ key: \"\\u2028\" }) # => \"{\\\"key\\\":\\\"\\\\u2028\\\"}\"  By default, it also generates JSON that is safe to include in HTML, as it escapes <tt><</tt>, <tt>></tt>, and <tt>&</tt>:  ActiveSupport::JSON.encode({ key: \"<>&\" }) # => \"{\\\"key\\\":\\\"\\\\u003c\\\\u003e\\\\u0026\\\"}\"  This behavior can be changed with the +escape_html_entities+ option, or the global escape_html_entities_in_json configuration option.  ActiveSupport::JSON.encode({ key: \"<>&\" }, escape_html_entities: false) # => \"{\\\"key\\\":\\\"<>&\\\"}\"  For performance reasons, you can set the +escape+ option to false, which will skip all escaping:  ActiveSupport::JSON.encode({ key: \"\\u2028<>&\" }, escape: false) # => \"{\\\"key\\\":\\\"\\u2028<>&\\\"}\"",
        "label": "Why",
        "id": "14484"
    },
    {
        "raw_code": "def target_scope\n          scope = super\n          reflection.chain.drop(1).each do |reflection|\n            relation = reflection.klass.scope_for_association\n            scope.merge!(\n              relation.except(:select, :create_with, :includes, :preload, :eager_load, :joins, :left_outer_joins)\n            )\n          end",
        "comment": "We merge in these scopes for two reasons:  1. To get the default_scope conditions for any of the other reflections in the chain 2. To get the type conditions for any STI models in the chain",
        "label": "Why",
        "id": "12817"
    },
    {
        "raw_code": "def find_signed!(signed_id, purpose: nil, on_rotation: nil)\n        options = { on_rotation: on_rotation }.compact\n        if id = signed_id_verifier.verify(signed_id, purpose: combine_signed_id_purposes(purpose), **options)\n          find(id)\n        end",
        "comment": "Works like find_signed, but will raise an ActiveSupport::MessageVerifier::InvalidSignature exception if the +signed_id+ has either expired, has a purpose mismatch, is for another record, or has been tampered with. It will also raise an ActiveRecord::RecordNotFound exception if the valid signed id can't find a record.  ==== Examples  User.find_signed! \"bad data\" # => ActiveSupport::MessageVerifier::InvalidSignature  signed_id = User.first.signed_id User.first.destroy User.find_signed! signed_id # => ActiveRecord::RecordNotFound",
        "label": "Why",
        "id": "12696"
    },
    {
        "raw_code": "def in_build_trace_lock(&block)\n      build.trace.lock do |_, lease| # rubocop:disable CodeReuse/ActiveRecord\n        build.run_on_status_commit { lease.cancel }\n\n        yield\n      end",
        "comment": " This method is releasing an exclusive lock on a build trace the moment we conclude that build status has been written and the build state update has been committed to the database.  Because a build state machine schedules a bunch of workers to run after build status transition to complete, we do not want to keep the lease until all the workers are scheduled because it opens a possibility of race conditions happening.  Instead of keeping the lease until the transition is fully done and workers are scheduled, we immediately release the lock after the database commit happens. ",
        "label": "Why",
        "id": "5790"
    },
    {
        "raw_code": "def unsubscribe_from_channel # :nodoc:\n        @unsubscribed = true\n        run_callbacks :unsubscribe do\n          unsubscribed\n        end",
        "comment": "Called by the cable connection when it's cut, so the channel has a chance to cleanup with callbacks. This method is not intended to be called directly by the user. Instead, override the #unsubscribed callback.",
        "label": "Why",
        "id": "11037"
    },
    {
        "raw_code": "def improved_delete_batched_background_migration(job_class_name, table_name, column_name, job_arguments)\n    Gitlab::Database::QueryAnalyzers::RestrictAllowedSchemas.require_dml_mode!\n\n    Gitlab::Database::BackgroundMigration::BatchedMigration.reset_column_information\n\n    batched_migration = Gitlab::Database::BackgroundMigration::BatchedMigration\n      .for_configuration(\n        gitlab_schema_from_context, job_class_name, table_name, column_name, job_arguments,\n        include_compatible: true\n      ).take\n\n    return unless batched_migration\n\n    batched_migration.batched_jobs.each_batch(of: 100) { |b| b.delete_all }\n\n    batched_migration.delete\n  end",
        "comment": "For context on why `delete_batched_background_migration` is overloaded: https://gitlab.com/gitlab-org/gitlab/-/issues/434089#note_2696645957",
        "label": "Why",
        "id": "4899"
    },
    {
        "raw_code": "def verify(message, **options)\n      catch_and_raise :invalid_message_format, as: InvalidSignature do\n        catch_and_raise :invalid_message_serialization do\n          catch_and_raise :invalid_message_content, as: InvalidSignature do\n            read_message(message, **options)\n          end",
        "comment": "Decodes the signed message using the +MessageVerifier+'s secret.  verifier = ActiveSupport::MessageVerifier.new(\"secret\") signed_message = verifier.generate(\"signed message\")  verifier.verify(signed_message) # => \"signed message\"  Raises +InvalidSignature+ if the message was not signed with the same secret or was not Base64-encoded.  other_verifier = ActiveSupport::MessageVerifier.new(\"different_secret\") other_verifier.verify(signed_message) # => ActiveSupport::MessageVerifier::InvalidSignature  ==== Options  [+:purpose+] The purpose that the message was generated with. If the purpose does not match, +verify+ will raise ActiveSupport::MessageVerifier::InvalidSignature.  message = verifier.generate(\"hello\", purpose: \"greeting\") verifier.verify(message, purpose: \"greeting\") # => \"hello\" verifier.verify(message, purpose: \"chatting\") # => raises InvalidSignature verifier.verify(message)                      # => raises InvalidSignature  message = verifier.generate(\"bye\") verifier.verify(message)                      # => \"bye\" verifier.verify(message, purpose: \"greeting\") # => raises InvalidSignature ",
        "label": "Why",
        "id": "13911"
    },
    {
        "raw_code": "def self.powerup_command(path, args, opts)\n        Dir.mktmpdir(\"vagrant\") do |dpath|\n          all_args = [path] + args.flatten.map{ |a|\n            a.gsub(/^['\"](.+)['\"]$/, \"\\\\1\")\n          }\n          arg_list = \"\\\"\" + all_args.join(\"\\\" \\\"\") + \"\\\"\"\n          stdout = File.join(dpath, \"stdout.txt\")\n          stderr = File.join(dpath, \"stderr.txt\")\n\n          script = \"& #{arg_list} ; exit $LASTEXITCODE;\"\n          script_content = Base64.strict_encode64(script.encode(\"UTF-16LE\", \"UTF-8\"))\n\n          # Wrap so we can redirect output to read later\n          wrapper = \"$p = Start-Process -FilePath powershell -ArgumentList @('-NoLogo', '-NoProfile', \" \\\n            \"'-NonInteractive', '-ExecutionPolicy', 'Bypass', '-EncodedCommand', '#{script_content}') \" \\\n            \"-PassThru -WindowStyle Hidden -Wait -RedirectStandardOutput '#{stdout}' -RedirectStandardError '#{stderr}'; \" \\\n            \"if($p){ exit $p.ExitCode; }else{ exit 1 }\"\n          wrapper_content = Base64.strict_encode64(wrapper.encode(\"UTF-16LE\", \"UTF-8\"))\n\n          powerup = \"$p = Start-Process -FilePath powershell -ArgumentList @('-NoLogo', '-NoProfile', \" \\\n            \"'-NonInteractive', '-ExecutionPolicy', 'Bypass', '-EncodedCommand', '#{wrapper_content}') \" \\\n            \"-PassThru -WindowStyle Hidden -Wait -Verb RunAs; if($p){ exit $p.ExitCode; }else{ exit 1 }\"\n\n          cmd = [\n            executable,\n            \"-NoLogo\",\n            \"-NoProfile\",\n            \"-NonInteractive\",\n            \"-ExecutionPolicy\", \"Bypass\",\n            \"-Command\", powerup\n          ]\n\n          result = Subprocess.execute(*cmd.push(opts))\n          r_stdout = result.stdout\n          if File.exist?(stdout)\n            r_stdout += File.read(stdout)\n          end",
        "comment": "Powerup the given command to perform privileged operations.  @param [String] path @param [Array<String>] args @return [Array<String>]",
        "label": "Why",
        "id": "9276"
    },
    {
        "raw_code": "def skip_job_regex\n      \"/#{[*DEFAULT_SKIPPED_JOBS, *STABLE_BASE_JOBS, *skippable_jobs].join('|')}/\"\n    end",
        "comment": "Skipped job regex based on existing container tags in the registry  @return [String]",
        "label": "Why",
        "id": "5266"
    },
    {
        "raw_code": "def require_gem(name)\n      require name\n      true\n    rescue LoadError\n      warn(\"You don't have #{name} installed. Add it to your Gemfile and run `bundle install`\")\n      false\n    end",
        "comment": "rubocop:enable Metrics/MethodLength, Metrics/AbcSize",
        "label": "Why",
        "id": "10060"
    },
    {
        "raw_code": "def process_action(...)\n        send_action(...)\n      end",
        "comment": "Call the action. Override this in a subclass to modify the behavior around processing an action. This, and not #process, is the intended way to override action dispatching.  Notice that the first argument is the method to be dispatched which is **not** necessarily the same as the action name.",
        "label": "Why",
        "id": "11188"
    },
    {
        "raw_code": "def tests(klass)\n            self.generator_class = klass\n          end",
        "comment": "Sets which generator should be tested:  tests AppGenerator",
        "label": "Why",
        "id": "14799"
    },
    {
        "raw_code": "def attributes\n          attrs = super\n          html_fields = cached_markdown_fields.html_fields\n          whitelisted = cached_markdown_fields.html_fields_whitelisted\n          exclude_fields = html_fields - whitelisted\n\n          attrs.except!(*exclude_fields)\n          attrs.delete('cached_markdown_version') if whitelisted.empty?\n\n          attrs\n        end",
        "comment": "Always exclude _html fields from attributes (including serialization). They contain unredacted HTML, which would be a security issue",
        "label": "Why",
        "id": "1766"
    },
    {
        "raw_code": "def fast_download_project_job_artifacts_path(project, job, params = {})\n      expose_fast_artifacts_path(project, job, :download, params)\n    end",
        "comment": "Rails path generators are slow because they need to do large regex comparisons against the arguments. We can speed this up 10x by generating the strings directly. /*namespace_id/:project_id/-/jobs/:job_id/artifacts/download(.:format)",
        "label": "Why",
        "id": "7848"
    },
    {
        "raw_code": "def determine_full_path\n        determine_parent_group_paths(sandbox, path)\n      end",
        "comment": "Determine the path up to the root group.  This is equivalent to the full_path API attribute. We can't use the full_path attribute because it depends on the group being fabricated first, and we use this method to help _check_ if the group exists.  @param [QA::Resource::GroupBase] sandbox the immediate parent group of this group @param [String] path the path name of this group (the leaf, not the full path) @return [String]",
        "label": "Why",
        "id": "4176"
    },
    {
        "raw_code": "def refresh_user_cache\n    return unless user\n\n    Users::KeysCountService.new(user).refresh_cache\n  end",
        "comment": "rubocop: disable CodeReuse/ServiceClass",
        "label": "Why",
        "id": "6858"
    },
    {
        "raw_code": "def downgrade_scopes!\n    auth_type = params.delete('gl_auth_type')\n    return unless auth_type == 'login'\n\n    ensure_read_user_scope!\n\n    params['scope'] = Gitlab::Auth::READ_USER_SCOPE.to_s if application_has_read_user_scope?\n  end",
        "comment": "limit scopes when signing in with GitLab",
        "label": "Why",
        "id": "6496"
    },
    {
        "raw_code": "def down; end\nend",
        "comment": "NOP because these sequences were never used, and re-adding them causes the columns to be altered to use them as default values.",
        "label": "Why",
        "id": "4869"
    },
    {
        "raw_code": "def manage_ghes_password\n        ENV.fetch('OCTOKIT_MANAGE_GHES_PASSWORD', nil)\n      end",
        "comment": "Default GHES Manage API password from ENV @return [String]",
        "label": "Why",
        "id": "14886"
    },
    {
        "raw_code": "def verified(message, **options)\n      catch_and_ignore :invalid_message_format do\n        catch_and_raise :invalid_message_serialization do\n          catch_and_ignore :invalid_message_content do\n            read_message(message, **options)\n          end",
        "comment": "Decodes the signed message using the +MessageVerifier+'s secret.  verifier = ActiveSupport::MessageVerifier.new(\"secret\")  signed_message = verifier.generate(\"signed message\") verifier.verified(signed_message) # => \"signed message\"  Returns +nil+ if the message was not signed with the same secret.  other_verifier = ActiveSupport::MessageVerifier.new(\"different_secret\") other_verifier.verified(signed_message) # => nil  Returns +nil+ if the message is not Base64-encoded.  invalid_message = \"f--46a0120593880c733a53b6dad75b42ddc1c8996d\" verifier.verified(invalid_message) # => nil  Raises any error raised while decoding the signed message.  incompatible_message = \"test--dad7b06c94abba8d46a15fafaef56c327665d5ff\" verifier.verified(incompatible_message) # => TypeError: incompatible marshal file format  ==== Options  [+:purpose+] The purpose that the message was generated with. If the purpose does not match, +verified+ will return +nil+.  message = verifier.generate(\"hello\", purpose: \"greeting\") verifier.verified(message, purpose: \"greeting\") # => \"hello\" verifier.verified(message, purpose: \"chatting\") # => nil verifier.verified(message)                      # => nil  message = verifier.generate(\"bye\") verifier.verified(message)                      # => \"bye\" verifier.verified(message, purpose: \"greeting\") # => nil ",
        "label": "Why",
        "id": "13910"
    },
    {
        "raw_code": "def name\n            @name ||= adapter.name\n          end",
        "comment": "Foreign key name should include the schema, as the same name could be used across different schemas  @example public.foreign_key_name",
        "label": "Why",
        "id": "1176"
    },
    {
        "raw_code": "def env_config\n      @app_env_config ||= super.merge(\n          \"action_dispatch.parameter_filter\" => filter_parameters,\n          \"action_dispatch.redirect_filter\" => config.filter_redirect,\n          \"action_dispatch.secret_key_base\" => secret_key_base,\n          \"action_dispatch.show_exceptions\" => config.action_dispatch.show_exceptions,\n          \"action_dispatch.show_detailed_exceptions\" => config.consider_all_requests_local,\n          \"action_dispatch.log_rescued_responses\" => config.action_dispatch.log_rescued_responses,\n          \"action_dispatch.debug_exception_log_level\" => ActiveSupport::Logger.const_get(config.action_dispatch.debug_exception_log_level.to_s.upcase),\n          \"action_dispatch.logger\" => Rails.logger,\n          \"action_dispatch.backtrace_cleaner\" => Rails.backtrace_cleaner,\n          \"action_dispatch.key_generator\" => key_generator,\n          \"action_dispatch.http_auth_salt\" => config.action_dispatch.http_auth_salt,\n          \"action_dispatch.signed_cookie_salt\" => config.action_dispatch.signed_cookie_salt,\n          \"action_dispatch.encrypted_cookie_salt\" => config.action_dispatch.encrypted_cookie_salt,\n          \"action_dispatch.encrypted_signed_cookie_salt\" => config.action_dispatch.encrypted_signed_cookie_salt,\n          \"action_dispatch.authenticated_encrypted_cookie_salt\" => config.action_dispatch.authenticated_encrypted_cookie_salt,\n          \"action_dispatch.use_authenticated_cookie_encryption\" => config.action_dispatch.use_authenticated_cookie_encryption,\n          \"action_dispatch.encrypted_cookie_cipher\" => config.action_dispatch.encrypted_cookie_cipher,\n          \"action_dispatch.signed_cookie_digest\" => config.action_dispatch.signed_cookie_digest,\n          \"action_dispatch.cookies_serializer\" => config.action_dispatch.cookies_serializer,\n          \"action_dispatch.cookies_digest\" => config.action_dispatch.cookies_digest,\n          \"action_dispatch.cookies_rotations\" => config.action_dispatch.cookies_rotations,\n          \"action_dispatch.cookies_same_site_protection\" => coerce_same_site_protection(config.action_dispatch.cookies_same_site_protection),\n          \"action_dispatch.use_cookies_with_metadata\" => config.action_dispatch.use_cookies_with_metadata,\n          \"action_dispatch.content_security_policy\" => config.content_security_policy,\n          \"action_dispatch.content_security_policy_report_only\" => config.content_security_policy_report_only,\n          \"action_dispatch.content_security_policy_nonce_generator\" => config.content_security_policy_nonce_generator,\n          \"action_dispatch.content_security_policy_nonce_directives\" => config.content_security_policy_nonce_directives,\n          \"action_dispatch.permissions_policy\" => config.permissions_policy,\n        )\n    end",
        "comment": "Stores some of the \\Rails initial environment parameters which will be used by middlewares and engines to configure themselves.",
        "label": "Why",
        "id": "14635"
    },
    {
        "raw_code": "def expose_url(path)\n        url_options = Gitlab::Application.routes.default_url_options\n        protocol, host, port, script_name = url_options.values_at(:protocol, :host, :port, :script_name)\n\n        # Using a blank component at the beginning of the join we ensure\n        # that the resulted path will start with '/'. If the resulted path\n        # does not start with '/', URI::Generic#new will fail\n        path_with_script_name = File.join('', [script_name, path].select(&:present?))\n\n        URI::Generic.new(protocol, nil, host, port, nil, path_with_script_name, nil, nil, nil, URI::RFC3986_PARSER, true).to_s\n      end",
        "comment": "This function should only be used to expose an API path or URL. It should not be used with Rails See https://gitlab.com/gitlab-org/gitlab/-/merge_requests/183415#note_2387443102",
        "label": "Why",
        "id": "3847"
    },
    {
        "raw_code": "def simple_sanitize(str)\n    str\n  end",
        "comment": "Override simple_sanitize for our testing purposes",
        "label": "Why",
        "id": "8538"
    },
    {
        "raw_code": "def load_class_data(klass_name)\n    file = class_file klass_name\n\n    marshal_load(file)\n  rescue Errno::ENOENT => e\n    error = MissingFileError.new(self, file, klass_name)\n    error.set_backtrace e.backtrace\n    raise error\n  end",
        "comment": " Loads ri data for +klass_name+",
        "label": "Why",
        "id": "15875"
    },
    {
        "raw_code": "def error_mark\n          colorize(TTY::Spinner::CROSS, error_color)\n        end",
        "comment": "Error mark  @return [String]",
        "label": "Why",
        "id": "4058"
    },
    {
        "raw_code": "def tokenize\n        raise NotImplementedError, \"#{self.class} does not support tokenization\"\n      end",
        "comment": "This method should be implemented to tokenize given source @abstract @return [Array] a list/tree of lexical tokens",
        "label": "Why",
        "id": "283"
    },
    {
        "raw_code": "def complete?\n        start_sha.present? && head_sha.present?\n      end",
        "comment": "There is only one case in which we will have `start_sha` and `head_sha`, but not `base_sha`, which is when a diff is generated between an orphaned branch and another branch, which means there _is_ no base, but we're still able to highlight it, and to create diff notes, which are the primary things `DiffRefs` are used for. `DiffRefs` are \"complete\" when they have `start_sha` and `head_sha`, because `base_sha` can always be derived from this, to return an actual sha, or `nil`. We have `base_sha` directly available on `DiffRefs` because it's faster# than having to look it up in the repo every time.",
        "label": "Why",
        "id": "2696"
    },
    {
        "raw_code": "def some_method\n          puts 'foo'                                                        # 03\n        end",
        "comment": "rubocop:disable Metrics/MethodLength with a comment why",
        "label": "Why",
        "id": "10756"
    },
    {
        "raw_code": "def set_commits_for_rendering(commits, commits_count: nil)\n    @total_commit_count = commits_count || commits.size\n    limited, @hidden_commit_count = limited_commits(commits, @total_commit_count)\n    prepare_commits_for_rendering(limited)\n  end",
        "comment": "This is used as a helper method in a controller. rubocop: disable Gitlab/ModuleWithInstanceVariables",
        "label": "Why",
        "id": "6527"
    },
    {
        "raw_code": "def after_create_default_branch\n    Projects::ProtectDefaultBranchService.new(self).execute\n  end",
        "comment": "rubocop: disable CodeReuse/ServiceClass",
        "label": "Why",
        "id": "6758"
    },
    {
        "raw_code": "def filtered_path\n        @filtered_path ||= query_string.empty? ? path : \"#{path}?#{filtered_query_string}\"\n      end",
        "comment": "Reconstructs a path with all sensitive GET parameters replaced.",
        "label": "Why",
        "id": "11423"
    },
    {
        "raw_code": "def up; end\n\n  def down; end\nend",
        "comment": "Introduced in 17.11 and no-op in 18.0. No-op because we decided not pursue this migration. See: https://gitlab.com/groups/gitlab-org/-/epics/16522#note_2492640881",
        "label": "Why",
        "id": "4882"
    },
    {
        "raw_code": "def up\n    add_concurrent_index :projects, [:id, :namespace_id], name: INDEX_NAME\n  end",
        "comment": "rubocop:disable Migration/PreventIndexCreation -- This is part of an experiment to see if it improves certain queries See https://gitlab.com/gitlab-org/gitlab/-/issues/466236",
        "label": "Why",
        "id": "4962"
    },
    {
        "raw_code": "def distinct_count_user_auth_by_provider(time_period)\n        counts = auth_providers_except_ldap.index_with do |provider|\n          distinct_count(\n            ::AuthenticationEvent.success.for_provider(provider).where(time_period), :user_id)\n        end",
        "comment": "rubocop:disable CodeReuse/ActiveRecord",
        "label": "Why",
        "id": "1746"
    },
    {
        "raw_code": "def marshal_load(array)\n    initialize array[1], nil, RDoc::Comment.from_document(array[5])\n\n    @full_name     = array[2]\n    @visibility    = array[3] || :public\n    @is_alias_for  = array[4]\n    #                      5 handled above\n    #                      6 handled below\n    @parent_name   = array[7]\n    @parent_class  = array[8]\n    @section_title = array[9]\n\n    @file = RDoc::TopLevel.new array[6]\n  end",
        "comment": " Loads this Constant from +array+.  For a loaded Constant the following methods will return cached values:  * #full_name * #parent_name",
        "label": "Why",
        "id": "16812"
    },
    {
        "raw_code": "def run_parallel(blocks, task_wait_time: 20.seconds, max_concurrency: Concurrent.processor_count - 1)\n    thread_pool = Concurrent::FixedThreadPool.new(\n      [2, max_concurrency].max, { max_queue: blocks.size }\n    )\n    opts = { executor: thread_pool }\n\n    error = Concurrent::MVar.new\n\n    blocks.map { |block| Concurrent::Future.execute(opts, &block) }.each do |future|\n      future.wait(task_wait_time)\n\n      if future.complete?\n        error.put(future.reason) if future.reason && error.empty?\n      else\n        future.cancel\n        error.put(Cancelled.new) if error.empty?\n      end",
        "comment": "To test for contention, we may need to run some actions in parallel. This helper takes an array of blocks and schedules them all on different threads in a fixed-size thread pool.  @param [Array[Proc]] blocks @param [Integer] task_wait_time: time to wait for each task (upper bound on reasonable task execution time) @param [Integer] max_concurrency: maximum number of tasks to run at once ",
        "label": "Why",
        "id": "8478"
    },
    {
        "raw_code": "def sanitize_json_data\n            return unless json_data.gsub!(/(?<!\\\\)(?:\\\\\\\\)*\\\\u0000/, '\\\\\\\\\\u0000')\n\n            report.add_warning('Parsing', 'Report artifact contained unicode null characters which are escaped during the ingestion.')\n          end",
        "comment": "PostgreSQL can not save texts with unicode null character that's why we are escaping that character.",
        "label": "Why",
        "id": "2540"
    },
    {
        "raw_code": "def bar\n            do_something\n          end",
        "comment": "rubocop:disable Metrics/ClassLength",
        "label": "Why",
        "id": "10955"
    },
    {
        "raw_code": "def ability_found?(policy, ability)\n        # NilPolicy has no abilities. Ignore it.\n        return true if policy.is_a?(DeclarativePolicy::NilPolicy)\n\n        # Search in current policy first\n        return true if policy.class.ability_map.map.key?(ability)\n\n        # Search recursively in all delegations otherwise.\n        # This is potentially slow.\n        # Stolen from:\n        # https://gitlab.com/gitlab-org/ruby/gems/declarative-policy/-/blob/d691e/lib/declarative_policy/base.rb#L360-369\n        policy.class.delegations.any? do |_, block|\n          new_subject = policy.instance_eval(&block)\n          new_policy = policy.policy_for(new_subject)\n\n          ability_found?(new_policy, ability)\n        end",
        "comment": "Use Policy#has_ability? instead after it has been accepted and released. See https://gitlab.com/gitlab-org/ruby/gems/declarative-policy/-/issues/25",
        "label": "Why",
        "id": "8302"
    },
    {
        "raw_code": "def push(item)\n      normed = normalize_item(item)\n      payload = middleware.invoke(item[\"class\"], normed, normed[\"queue\"], @redis_pool) do\n        normed\n      end",
        "comment": " The main method used to push a job to Redis.  Accepts a number of options:  queue - the named queue to use, default 'default' class - the job class to call, required args - an array of simple arguments to the perform method, must be JSON-serializable at - timestamp to schedule the job (optional), must be Numeric (e.g. Time.now.to_f) retry - whether to retry this job if it fails, default true or an integer number of retries retry_for - relative amount of time to retry this job if it fails, default nil backtrace - whether to save any error backtrace, default false  If class is set to the class name, the jobs' options will be based on Sidekiq's default job options. Otherwise, they will be based on the job class's options.  Any options valid for a job class's sidekiq_options are also available here.  All keys must be strings, not symbols.  NB: because we are serializing to JSON, all symbols in 'args' will be converted to strings.  Note that +backtrace: true+ can take quite a bit of space in Redis; a large volume of failing jobs can start Redis swapping if you aren't careful.  Returns a unique Job ID.  If middleware stops the job, nil will be returned instead.  Example: push('queue' => 'my_queue', 'class' => MyJob, 'args' => ['foo', 1, :bat => 'bar']) ",
        "label": "Why",
        "id": "5093"
    },
    {
        "raw_code": "def execute(sql)\n    connection.execute(sql)\n  end",
        "comment": "Needed by track_record_deletions",
        "label": "Why",
        "id": "8242"
    },
    {
        "raw_code": "def prompt_for_metric_type\n        return :event_metric if @selected_event_paths.any?\n\n        new_page!(on_step: 'Type', steps: STEPS)\n\n        cli.select(\"Which best describes what the metric should track?\", **select_opts) do |menu|\n          menu.enum \".\"\n\n          menu.choice 'Single event    -- count occurrences of a specific event or user interaction',\n            :event_metric\n          menu.choice 'Multiple events -- count occurrences of several separate events or interactions',\n            :aggregate_metric\n          menu.choice 'Database        -- record value of a particular field or count of database rows',\n            :database_metric\n        end",
        "comment": "----- Prompts -----------------------------",
        "label": "Why",
        "id": "5317"
    },
    {
        "raw_code": "def clean_working_queues!\n      Sidekiq.logger.info('Cleaning working queues')\n\n      Sidekiq.redis do |conn|\n        conn.scan(match: \"#{WORKING_QUEUE_PREFIX}:queue:*\", count: SCAN_COUNT) do |key|\n          original_queue, identity = extract_queue_and_identity(key)\n\n          next if original_queue.nil? || identity.nil?\n\n          clean_working_queue!(original_queue, key) if self.class.worker_dead?(identity, conn)\n        end",
        "comment": "Detect \"old\" jobs and requeue them because the worker they were assigned to probably failed miserably.",
        "label": "Why",
        "id": "5039"
    },
    {
        "raw_code": "def delete_project_with_http_info(id, opts = {})\n      if @api_client.config.debugging\n        @api_client.config.logger.debug 'Calling API: ProjectsApi.delete_project ...'\n      end",
        "comment": "Deletes all project related data. Mostly for testing purposes and later for production to clean updeleted projects. @param id [Integer] ID of the project @param [Hash] opts the optional parameters @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers",
        "label": "Why",
        "id": "1011"
    },
    {
        "raw_code": "def remove_possible_method(method)\n    if method_defined?(method) || private_method_defined?(method)\n      undef_method(method)\n    end",
        "comment": "Removes the named method, if it exists.",
        "label": "Why",
        "id": "14281"
    },
    {
        "raw_code": "def self.forwarded_ports(machine)\n        return nil if machine.state.id != :running\n\n        {}.tap do |result|\n          machine.provider.driver.read_forwarded_ports.each do |_, _, h, g|\n            result[h] = g\n          end",
        "comment": "Reads the forwarded ports that currently exist on the machine itself. This raises an exception if the machine isn't running.  This also may not match up with configured forwarded ports, because Vagrant auto port collision fixing may have taken place.  @return [Hash<Integer, Integer>] Host => Guest port mappings.",
        "label": "Why",
        "id": "9549"
    },
    {
        "raw_code": "def enforce_two_factor_authentication_on_group(group)\n        Flow::Login.while_signed_in(as: owner_user) do\n          group.visit!\n\n          Page::Group::Menu.perform(&:go_to_general_settings)\n          Page::Group::Settings::General.perform(&:set_require_2fa_enabled)\n\n          QA::Support::Retrier.retry_on_exception(reload_page: page) do\n            expect(page).to have_text(two_fa_expected_text)\n          end",
        "comment": "We are intentionally using the UI to enforce 2FA to exercise the flow with UI. Any future tests should use the API for this purpose.",
        "label": "Why",
        "id": "4373"
    },
    {
        "raw_code": "def in_operator_query_builder_params(array_data)\n    case filter\n    when ALL\n      in_operator_params(array_data: array_data)\n    when PUSH\n      # Here we need to add an order hint column to force the correct index usage.\n      # Without the order hint, the following conditions will use the `index_events_on_author_id_and_id`\n      # index which is not as efficient as the `index_events_for_followed_users` index.\n      # > target_type IS NULL AND action = 5 AND author_id = X ORDER BY id DESC\n      #\n      # The order hint adds an extra order by column which doesn't affect the result but forces the planner\n      # to use the correct index:\n      # > target_type IS NULL AND action = 5 AND author_id = X ORDER BY target_type DESC, id DESC\n      in_operator_params(\n        array_data: array_data,\n        scope: Event.where(target_type: nil).pushed_action,\n        order_hint_column: :target_type\n      )\n    when MERGED\n      in_operator_params(\n        array_data: array_data,\n        scope: Event.where(target_type: MergeRequest.to_s).merged_action\n      )\n    when COMMENTS\n      in_operator_params(\n        array_data: array_data,\n        scope: Event.commented_action,\n        in_column: :target_type,\n        in_values: [Note, *Note.descendants].map(&:name) # To make the query efficient we need to list all Note classes\n      )\n    when TEAM\n      in_operator_params(\n        array_data: array_data,\n        # TODO: Remove nil filter once backfill is complete https://gitlab.com/gitlab-org/gitlab/-/issues/565789\n        scope: Event.where(target_type: [nil, Event::TARGET_TYPES[:project].name]),\n        order_hint_column: :target_type,\n        in_column: :action,\n        in_values: Event.actions.values_at(*Event::TEAM_ACTIONS)\n      )\n    when ISSUE\n      in_operator_params(\n        array_data: array_data,\n        scope: Event.for_issue,\n        in_column: :action,\n        in_values: Event.actions.values_at(*Event::ISSUE_ACTIONS)\n      )\n    when WIKI\n      in_operator_params(\n        array_data: array_data,\n        scope: Event.for_wiki_page,\n        in_column: :action,\n        in_values: Event.actions.values_at(*Event::WIKI_ACTIONS)\n      )\n    when DESIGNS\n      in_operator_params(\n        array_data: array_data,\n        scope: Event.for_design,\n        in_column: :action,\n        in_values: Event.actions.values_at(*Event::DESIGN_ACTIONS)\n      )\n    else\n      in_operator_params(array_data: array_data)\n    end",
        "comment": "This method build specialized in-operator optimized queries based on different filter parameters. All queries will benefit from the index covering the following columns: * author_id target_type action id * project_id target_type action id * group_id target_type action id  More context: https://docs.gitlab.com/ee/development/database/efficient_in_operator_queries.html#the-inoperatoroptimization-module",
        "label": "Why",
        "id": "1329"
    },
    {
        "raw_code": "def starts_with_default_separator_match\n      @@starts_with_default_separator_match ||= /\\A#{default_separator}/\n    end",
        "comment": "@return [Regexp] the regexp match of the default separator",
        "label": "Why",
        "id": "121"
    },
    {
        "raw_code": "def open_issues_count(current_user = nil)\n    Groups::OpenIssuesCountService.new(self, current_user).count\n  end",
        "comment": "rubocop: disable CodeReuse/ServiceClass",
        "label": "Why",
        "id": "7025"
    },
    {
        "raw_code": "def singular_name # :doc:\n          file_name\n        end",
        "comment": "FIXME: We are avoiding to use alias because a bug on thor that make this method public and add it to the task list.",
        "label": "Why",
        "id": "14780"
    },
    {
        "raw_code": "def error(msg)\n    msg = make_message msg\n\n    abort msg\n  end",
        "comment": " Aborts with +msg+",
        "label": "Why",
        "id": "16068"
    },
    {
        "raw_code": "def with_pool_transaction_isolation_level(isolation_level, &block)\n        if current_transaction.open?\n          raise ActiveRecord::TransactionIsolationError, \"cannot set default isolation level while transaction is open\"\n        end",
        "comment": "Makes all transactions the current pool use the isolation level initiated within the block.",
        "label": "Why",
        "id": "12717"
    },
    {
        "raw_code": "def unregister(symbol)\n        symbol = symbol.downcase\n        if mime = Mime[symbol]\n          SET.delete_if { |v| v.eql?(mime) }\n          LOOKUP.delete_if { |_, v| v.eql?(mime) }\n          EXTENSION_LOOKUP.delete_if { |_, v| v.eql?(mime) }\n        end",
        "comment": "This method is opposite of register method.  To unregister a MIME type:  Mime::Type.unregister(:mobile)",
        "label": "Why",
        "id": "11440"
    },
    {
        "raw_code": "def wal_diff(location1, location2)\n          read_write do |connection|\n            lsn1 = connection.quote(location1)\n            lsn2 = connection.quote(location2)\n\n            query = <<-SQL.squish\n            SELECT pg_wal_lsn_diff(#{lsn1}, #{lsn2})\n              AS result\n            SQL\n\n            row = connection.select_all(query).first\n            row['result'] if row\n          end",
        "comment": "rubocop:enable Database/MultipleDatabases",
        "label": "Why",
        "id": "3101"
    },
    {
        "raw_code": "def restrict_frameworks\n      remove_from_config('require \"rails/all\"')\n      remove_from_config('require_relative \"boot\"')\n      remove_from_env_config(\"development\", \"config.active_storage.*\")\n      frameworks = <<~RUBY\n        require \"rails\"\n        require \"active_model/railtie\"\n        require \"active_job/railtie\"\n        require \"active_record/railtie\"\n        require \"action_controller/railtie\"\n        require \"action_mailer/railtie\"\n        require \"action_view/railtie\"\n        require \"rails/test_unit/railtie\"\n      RUBY\n      environment = File.read(\"#{app_path}/config/application.rb\")\n      File.open(\"#{app_path}/config/application.rb\", \"w\") { |f| f.puts frameworks + \"\\n\" + environment }\n    end",
        "comment": "Restrict frameworks to load in order to avoid engine frameworks affect tests.",
        "label": "Why",
        "id": "14828"
    },
    {
        "raw_code": "def test_javascript_include_tag\n    assert_dom_equal \"<script src='/foo.js'></script>\",  javascript_include_tag(\"/foo\")\n    assert_dom_equal \"<script src='/foo'></script>\",     javascript_include_tag(\"/foo\", extname: false)\n    assert_dom_equal \"<script src='/foo.bar'></script>\", javascript_include_tag(\"/foo\", extname: \".bar\")\n  end",
        "comment": "Setting the :extname option will control what extension (if any) is appended to the URL for assets",
        "label": "Why",
        "id": "12098"
    },
    {
        "raw_code": "def check_for_spam?(*)\n    return false if system? || !spammable_attribute_changed? || confidential?\n    return false if noteable.try(:confidential?) == true || noteable.try(:public?) == false\n    return false if noteable.try(:group)&.public? == false || project&.public? == false\n\n    true\n  end",
        "comment": "Override method defined in Spammable Wildcard argument because user: argument is not used",
        "label": "Why",
        "id": "6938"
    },
    {
        "raw_code": "def as_json(*_args)\n      options.as_json\n    end",
        "comment": "Allow #to_json serialization",
        "label": "Why",
        "id": "1618"
    },
    {
        "raw_code": "def container_registry_tag_regex\n      @container_registry_tag_regex ||= /\\w[\\w.-]{0,127}/\n    end",
        "comment": " We do not use regexp anchors here because these are not allowed when used as a routing constraint. ",
        "label": "Why",
        "id": "1393"
    },
    {
        "raw_code": "def behavior=(behavior)\n        @behavior = Array(behavior).map { |b| DEFAULT_BEHAVIORS[b] || arity_coerce(b) }\n      end",
        "comment": "Sets the behavior to the specified value. Can be a single value, array, or an object that responds to +call+.  Available behaviors:  [+:raise+]   Raise ActiveSupport::DeprecationException. [+:stderr+]  Log all deprecation warnings to <tt>$stderr</tt>. [+:log+]     Log all deprecation warnings to +Rails.logger+. [+:notify+]  Use ActiveSupport::Notifications to notify +deprecation.rails+. [+:report+]  Use ActiveSupport::ErrorReporter to report deprecations. [+:silence+] Do nothing.  Setting behaviors only affects deprecations that happen after boot time. Deprecation warnings raised by gems are not affected by this setting because they happen before \\Rails boots up.  deprecator = ActiveSupport::Deprecation.new deprecator.behavior = :stderr deprecator.behavior = [:stderr, :log] deprecator.behavior = MyCustomHandler deprecator.behavior = ->(message, callstack, deprecation_horizon, gem_name) { # custom stuff }  If you are using \\Rails, you can set <tt>config.active_support.report_deprecations = false</tt> to disable all deprecation behaviors. This is similar to the +:silence+ option but more performant.",
        "label": "Why",
        "id": "14426"
    },
    {
        "raw_code": "def sanitize_description(body)\n        body&.gsub(created_by_pattern, \"\")\n      end",
        "comment": "Remove created by prefix from descripion  @param [String] body @return [String]",
        "label": "Why",
        "id": "4416"
    },
    {
        "raw_code": "def issues_enabled=(value)\n    write_feature_attribute_boolean(:issues_access_level, value)\n  end",
        "comment": "TODO: remove in API v5, replaced by *_access_level",
        "label": "Why",
        "id": "7308"
    },
    {
        "raw_code": "def self.purge(options = {})\n    return unless ENV[\"FASTLY_DOMAINS\"].present? && ENV[\"FASTLY_API_KEY\"].present?\n\n    connection = make_connection\n\n    ENV[\"FASTLY_DOMAINS\"].split(\",\").each do |domain|\n      url = \"https://#{domain}/#{options[:path]}\"\n      trace(\"gemcutter.fastly.purge\", resource: url,\n            tags: { \"gemcutter.fastly.domain\" => domain, \"gemcutter.fastly.path\" => options[:path], \"gemcutter.fastly.soft\" => options[:soft] }) do\n        headers = options[:soft] ? { \"Fastly-Soft-Purge\" => \"1\" } : {}\n        headers[\"Fastly-Key\"] = ENV[\"FASTLY_API_KEY\"]\n\n        json = connection.get(url, nil, headers) do |req|\n          req.http_method = :purge\n        end",
        "comment": "These are not kwargs because delayed_job doesn't correctly support kwargs in Fastly.delay.purge See: https://github.com/collectiveidea/delayed_job/issues/1134",
        "label": "Why",
        "id": "10013"
    },
    {
        "raw_code": "def allowlist\n        ALLOWLIST\n      end",
        "comment": "This completely overrides the BaseSanitizationFilter allowlist. We don't want to support math, spans, etc. Bare minimum markdown",
        "label": "Why",
        "id": "3450"
    },
    {
        "raw_code": "def json_escape(s)\n      result = s.to_s.dup\n      result.gsub!(\">\", '\\u003e')\n      result.gsub!(\"<\", '\\u003c')\n      result.gsub!(\"&\", '\\u0026')\n      result.gsub!(\"\\u2028\", '\\u2028')\n      result.gsub!(\"\\u2029\", '\\u2029')\n      s.html_safe? ? result.html_safe : result\n    end",
        "comment": "A utility method for escaping HTML entities in JSON strings. Specifically, the &, > and < characters are replaced with their equivalent unicode escaped form - \\u0026, \\u003e, and \\u003c. The Unicode sequences \\u2028 and \\u2029 are also escaped as they are treated as newline characters in some JavaScript engines. These sequences have identical meaning as the original characters inside the context of a JSON string, so assuming the input is a valid and well-formed JSON value, the output will have equivalent meaning when parsed:  json = JSON.generate({ name: \"</script><script>alert('PWNED!!!')</script>\"}) # => \"{\\\"name\\\":\\\"</script><script>alert('PWNED!!!')</script>\\\"}\"  json_escape(json) # => \"{\\\"name\\\":\\\"\\\\u003C/script\\\\u003E\\\\u003Cscript\\\\u003Ealert('PWNED!!!')\\\\u003C/script\\\\u003E\\\"}\"  JSON.parse(json) == JSON.parse(json_escape(json)) # => true  The intended use case for this method is to escape JSON strings before including them inside a script tag to avoid XSS vulnerability:  <script> var currentUser = <%= raw json_escape(current_user.to_json) %>; </script>  It is necessary to +raw+ the result of +json_escape+, so that quotation marks don't get converted to <tt>&quot;</tt> entities. +json_escape+ doesn't automatically flag the result as HTML safe, since the raw value is unsafe to use inside HTML attributes.  If your JSON is being used downstream for insertion into the DOM, be aware of whether or not it is being inserted via <tt>html()</tt>. Most jQuery plugins do this. If that is the case, be sure to +html_escape+ or +sanitize+ any user-generated content returned by your JSON.  If you need to output JSON elsewhere in your HTML, you can just do something like this, as any unsafe characters (including quotation marks) will be automatically escaped for you:  <div data-user-info=\"<%= current_user.to_json %>\">...</div>  WARNING: this helper only works with valid JSON. Using this on non-JSON values will open up serious XSS vulnerabilities. For example, if you replace the +current_user.to_json+ in the example above with user input instead, the browser will happily <tt>eval()</tt> that string as JavaScript.  The escaping performed in this method is identical to those performed in the Active Support JSON encoder when +ActiveSupport.escape_html_entities_in_json+ is set to true. Because this transformation is idempotent, this helper can be applied even if +ActiveSupport.escape_html_entities_in_json+ is already true.  Therefore, when you are unsure if +ActiveSupport.escape_html_entities_in_json+ is enabled, or if you are unsure where your JSON string originated from, it is recommended that you always apply this helper (other libraries, such as the JSON gem, do not provide this kind of protection by default; also some gems might override +to_json+ to bypass Active Support's encoder).",
        "label": "Why",
        "id": "14218"
    },
    {
        "raw_code": "def no_result_unsuccessful?\n        results.none?(&:unsuccessful?)\n      end",
        "comment": "This name may seem like a double-negative, but it is meaningful because #success? is _not_ the inverse of #unsuccessful?",
        "label": "Why",
        "id": "5586"
    },
    {
        "raw_code": "def commits_count\n          return unless ref\n\n          @commits_count ||= gitaly_commit_client.commit_count(ref, after: @options[:from], before: @options[:to])\n        end",
        "comment": "Don't use the `Gitlab::Git::Repository#log` method, because it enforces a limit. Since we need a commit count, we _can't_ enforce a limit, so the easiest way forward is to replicate the relevant portions of the `log` function here.",
        "label": "Why",
        "id": "2564"
    },
    {
        "raw_code": "def fields_for(record_name, record_object = nil, options = {}, &block)\n        options = { model: record_object, allow_method_names_outside_object: false, skip_default_ids: false }.merge!(options)\n\n        fields(record_name, **options, &block)\n      end",
        "comment": "Creates a scope around a specific model object like #form_with, but doesn't create the form tags themselves. This makes +fields_for+ suitable for specifying additional model objects in the same form.  Although the usage and purpose of +fields_for+ is similar to #form_with's, its method signature is slightly different. Like #form_with, it yields a FormBuilder object associated with a particular model object to a block, and within the block allows methods to be called on the builder to generate fields associated with the model object. Fields may reflect a model object in two ways - how they are named (hence how submitted values appear within the +params+ hash in the controller) and what default values are shown when the form fields are first displayed. In order for both of these features to be specified independently, both an object name (represented by either a symbol or string) and the object itself can be passed to the method separately -  <%= form_with model: @person do |person_form| %> First name: <%= person_form.text_field :first_name %> Last name : <%= person_form.text_field :last_name %>  <%= fields_for :permission, @person.permission do |permission_fields| %> Admin?  : <%= permission_fields.checkbox :admin %> <% end %>  <%= person_form.submit %> <% end %>  In this case, the checkbox field will be represented by an HTML +input+ tag with the +name+ attribute <tt>permission[admin]</tt>, and the submitted value will appear in the controller as <tt>params[:permission][:admin]</tt>. If <tt>@person.permission</tt> is an existing record with an attribute +admin+, the initial state of the checkbox when first displayed will reflect the value of <tt>@person.permission.admin</tt>.  Often this can be simplified by passing just the name of the model object to +fields_for+ -  <%= fields_for :permission do |permission_fields| %> Admin?: <%= permission_fields.checkbox :admin %> <% end %>  ...in which case, if <tt>:permission</tt> also happens to be the name of an instance variable <tt>@permission</tt>, the initial state of the input field will reflect the value of that variable's attribute <tt>@permission.admin</tt>.  Alternatively, you can pass just the model object itself (if the first argument isn't a string or symbol +fields_for+ will realize that the name has been omitted) -  <%= fields_for @person.permission do |permission_fields| %> Admin?: <%= permission_fields.checkbox :admin %> <% end %>  and +fields_for+ will derive the required name of the field from the _class_ of the model object, e.g. if <tt>@person.permission</tt>, is of class +Permission+, the field will still be named <tt>permission[admin]</tt>.  Note: This also works for the methods in FormOptionsHelper and DateHelper that are designed to work with an object as base, like FormOptionsHelper#collection_select and DateHelper#datetime_select.  === Nested Attributes Examples  When the object belonging to the current scope has a nested attribute writer for a certain attribute, +fields_for+ will yield a new scope for that attribute. This allows you to create forms that set or change the attributes of a parent object and its associations in one go.  Nested attribute writers are normal setter methods named after an association. The most common way of defining these writers is either with +accepts_nested_attributes_for+ in a model definition or by defining a method with the proper name. For example: the attribute writer for the association <tt>:address</tt> is called <tt>address_attributes=</tt>.  Whether a one-to-one or one-to-many style form builder will be yielded depends on whether the normal reader method returns a _single_ object or an _array_ of objects.  ==== One-to-one  Consider a Person class which returns a _single_ Address from the <tt>address</tt> reader method and responds to the <tt>address_attributes=</tt> writer method:  class Person def address @address end  def address_attributes=(attributes) # Process the attributes hash end end  This model can now be used with a nested fields_for, like so:  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :address do |address_fields| %> Street  : <%= address_fields.text_field :street %> Zip code: <%= address_fields.text_field :zip_code %> <% end %> ... <% end %>  When address is already an association on a Person you can use +accepts_nested_attributes_for+ to define the writer method for you:  class Person < ActiveRecord::Base has_one :address accepts_nested_attributes_for :address end  If you want to destroy the associated model through the form, you have to enable it first using the <tt>:allow_destroy</tt> option for +accepts_nested_attributes_for+:  class Person < ActiveRecord::Base has_one :address accepts_nested_attributes_for :address, allow_destroy: true end  Now, when you use a form element with the <tt>_destroy</tt> parameter, with a value that evaluates to +true+, you will destroy the associated model (e.g. 1, '1', true, or 'true'):  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :address do |address_fields| %> ... Delete: <%= address_fields.checkbox :_destroy %> <% end %> ... <% end %>  ==== One-to-many  Consider a Person class which returns an _array_ of Project instances from the <tt>projects</tt> reader method and responds to the <tt>projects_attributes=</tt> writer method:  class Person def projects [@project1, @project2] end  def projects_attributes=(attributes) # Process the attributes hash end end  Note that the <tt>projects_attributes=</tt> writer method is in fact required for +fields_for+ to correctly identify <tt>:projects</tt> as a collection, and the correct indices to be set in the form markup.  When projects is already an association on Person you can use +accepts_nested_attributes_for+ to define the writer method for you:  class Person < ActiveRecord::Base has_many :projects accepts_nested_attributes_for :projects end  This model can now be used with a nested fields_for. The block given to the nested +fields_for+ call will be repeated for each instance in the collection:  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects do |project_fields| %> <% if project_fields.object.active? %> Name: <%= project_fields.text_field :name %> <% end %> <% end %> ... <% end %>  It's also possible to specify the instance to be used:  <%= form_with model: @person do |person_form| %> ... <% @person.projects.each do |project| %> <% if project.active? %> <%= person_form.fields_for :projects, project do |project_fields| %> Name: <%= project_fields.text_field :name %> <% end %> <% end %> <% end %> ... <% end %>  Or a collection to be used:  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects, @active_projects do |project_fields| %> Name: <%= project_fields.text_field :name %> <% end %> ... <% end %>  If you want to destroy any of the associated models through the form, you have to enable it first using the <tt>:allow_destroy</tt> option for +accepts_nested_attributes_for+:  class Person < ActiveRecord::Base has_many :projects accepts_nested_attributes_for :projects, allow_destroy: true end  This will allow you to specify which models to destroy in the attributes hash by adding a form element for the <tt>_destroy</tt> parameter with a value that evaluates to +true+ (e.g. 1, '1', true, or 'true'):  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects do |project_fields| %> Delete: <%= project_fields.checkbox :_destroy %> <% end %> ... <% end %>  When a collection is used you might want to know the index of each object in the array. For this purpose, the <tt>index</tt> method is available in the FormBuilder object.  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects do |project_fields| %> Project #<%= project_fields.index %> ... <% end %> ... <% end %>  Note that +fields_for+ will automatically generate a hidden field to store the ID of the record if it responds to <tt>persisted?</tt>. There are circumstances where this hidden field is not needed and you can pass <tt>include_id: false</tt> to prevent +fields_for+ from rendering it automatically.",
        "label": "Why",
        "id": "11864"
    },
    {
        "raw_code": "def split_main_and_subcommand(argv)\n          # Initialize return variables\n          main_args   = nil\n          sub_command = nil\n          sub_args    = []\n\n          # We split the arguments into two: One set containing any\n          # flags before a word, and then the rest. The rest are what\n          # get actually sent on to the subcommand.\n          argv.each_index do |i|\n            if !argv[i].start_with?(\"-\")\n              # We found the beginning of the sub command. Split the\n              # args up.\n              main_args   = argv[0, i]\n              sub_command = argv[i]\n              sub_args    = argv[i + 1, argv.length - i + 1]\n\n              # Break so we don't find the next non flag and shift our\n              # main args.\n              break\n            end",
        "comment": "This method will split the argv given into three parts: the flags to this command, the subcommand, and the flags to the subcommand. For example:  -v status -h -v  The above would yield 3 parts:  [\"-v\"] \"status\" [\"-h\", \"-v\"]  These parts are useful because the first is a list of arguments given to the current command, the second is a subcommand, and the third are the commands given to the subcommand.  @return [Array] The three parts.",
        "label": "Why",
        "id": "9089"
    },
    {
        "raw_code": "def project\n        note.project\n      end",
        "comment": "NOTE: may be nil, in the case of a PersonalSnippet  (this is okay because NotificationRecipient is written to handle nil projects)",
        "label": "Why",
        "id": "6059"
    },
    {
        "raw_code": "def enqueue_jobs_that_needs_to_be_run_only_once_per_hierarchy(member, unassign_issuables)\n      return if recursive_call?\n\n      enqueue_cleanup_jobs_once_per_hierarchy(member, unassign_issuables)\n    end",
        "comment": "These actions need to be executed only once per hierarchy because the underlying services apply these actions to the entire hierarchy anyway, so there is no need to execute them recursively.",
        "label": "Why",
        "id": "6112"
    },
    {
        "raw_code": "def class_attribute(*attrs, instance_accessor: true,\n    instance_reader: instance_accessor, instance_writer: instance_accessor, instance_predicate: true, default: nil\n  )\n    class_methods, methods = [], []\n    attrs.each do |name|\n      unless name.is_a?(Symbol) || name.is_a?(String)\n        raise TypeError, \"#{name.inspect} is not a symbol nor a string\"\n      end",
        "comment": "Declare a class-level attribute whose value is inheritable by subclasses. Subclasses can change their own value and it will not impact parent class.  ==== Options  * <tt>:instance_reader</tt> - Sets the instance reader method (defaults to true). * <tt>:instance_writer</tt> - Sets the instance writer method (defaults to true). * <tt>:instance_accessor</tt> - Sets both instance methods (defaults to true). * <tt>:instance_predicate</tt> - Sets a predicate method (defaults to true). * <tt>:default</tt> - Sets a default value for the attribute (defaults to nil).  ==== Examples  class Base class_attribute :setting end  class Subclass < Base end  Base.setting = true Subclass.setting            # => true Subclass.setting = false Subclass.setting            # => false Base.setting                # => true  In the above case as long as Subclass does not assign a value to setting by performing <tt>Subclass.setting = _something_</tt>, <tt>Subclass.setting</tt> would read value assigned to parent class. Once Subclass assigns a value then the value assigned by Subclass would be returned.  This matches normal Ruby method inheritance: think of writing an attribute on a subclass as overriding the reader method. However, you need to be aware when using +class_attribute+ with mutable structures as +Array+ or +Hash+. In such cases, you don't want to do changes in place. Instead use setters:  Base.setting = [] Base.setting                # => [] Subclass.setting            # => []  # Appending in child changes both parent and child because it is the same object: Subclass.setting << :foo Base.setting               # => [:foo] Subclass.setting           # => [:foo]  # Use setters to not propagate changes: Base.setting = [] Subclass.setting += [:foo] Base.setting               # => [] Subclass.setting           # => [:foo]  For convenience, an instance predicate method is defined as well. To skip it, pass <tt>instance_predicate: false</tt>.  Subclass.setting?       # => false  Instances may overwrite the class value in the same way:  Base.setting = true object = Base.new object.setting          # => true object.setting = false object.setting          # => false Base.setting            # => true  To opt out of the instance reader method, pass <tt>instance_reader: false</tt>.  object.setting          # => NoMethodError object.setting?         # => NoMethodError  To opt out of the instance writer method, pass <tt>instance_writer: false</tt>.  object.setting = false  # => NoMethodError  To opt out of both instance methods, pass <tt>instance_accessor: false</tt>.  To set a default value for the attribute, pass <tt>default:</tt>, like so:  class_attribute :settings, default: {}",
        "label": "Why",
        "id": "14108"
    },
    {
        "raw_code": "def licensed_ai_features_available?\n    false\n  end",
        "comment": "Overridden for EE",
        "label": "Why",
        "id": "6776"
    },
    {
        "raw_code": "def camelize(str)\n        str.split('_').collect(&:capitalize).join\n      end",
        "comment": "We don't want to use active_support for this method, so we're making it ourselves",
        "label": "Why",
        "id": "8102"
    },
    {
        "raw_code": "def get(session, path, options = {})\n      json_response session.get(path, options)\n    end",
        "comment": "Should be used in a session manually",
        "label": "Why",
        "id": "3512"
    },
    {
        "raw_code": "def reset!\n      redis_cmd do |redis|\n        redis.del(key)\n      end",
        "comment": "Reset the reference counter  @private Used internally by SRE and debugging purpose @return [Boolean] whether reset was a success",
        "label": "Why",
        "id": "1695"
    },
    {
        "raw_code": "def to_sentry_error_event\n    Gitlab::ErrorTracking::ErrorEvent.new(\n      issue_id: error_id,\n      date_received: occurred_at,\n      stack_trace_entries: stacktrace\n    )\n  end",
        "comment": "For compatibility with sentry integration",
        "label": "Why",
        "id": "7627"
    },
    {
        "raw_code": "def test_selector(rspec_test_mapping_path = nil)\n        Tooling::PredictiveTests::TestSelector.new(\n          changed_files: changed_files,\n          rspec_test_mapping_path: rspec_test_mapping_path,\n          logger: logger,\n          rspec_mappings_limit_percentage: nil # always return all tests in the mapping,\n        )\n      end",
        "comment": "Predictive spec list selector  @param strategy [Symbol] @return [TestSelector]",
        "label": "Why",
        "id": "8126"
    },
    {
        "raw_code": "def markdown_reference_pattern\n      @markdown_reference_pattern ||=\n        %r{\n          #{reference_pattern}\n          (#{reference_postfix}|#{reference_postfix_escaped})\n        }x\n    end",
        "comment": "Pattern used to extract `namespace/project>` project references from text. '>' or its escaped form ('&gt;') are checked for because '>' is sometimes escaped when the reference comes from an external source.",
        "label": "Why",
        "id": "6729"
    },
    {
        "raw_code": "def root_ancestor\n        strong_memoize(:root_ancestor) do\n          if parent_loaded_and_present?\n            parent.root_ancestor\n          elsif parent_id_present_and_traversal_ids_empty?\n            # Parent is in the database, so find our root ancestor using our parent's traversal_ids.\n            parent = Namespace.where(id: parent_id).select(:traversal_ids)\n            Namespace.from(\"(#{parent.to_sql}) AS parent_namespace, namespaces\")\n                     .find_by('namespaces.id = parent_namespace.traversal_ids[1]')\n          elsif parent_id.nil?\n            # There is no parent, so we are the root ancestor.\n            self\n          else\n            Namespace.find_by(id: traversal_ids.first)\n          end",
        "comment": "Return the top most ancestor of this namespace. This method aims to minimize the number of queries by trying to re-use data that has already been loaded.",
        "label": "Why",
        "id": "7184"
    },
    {
        "raw_code": "def self.create_channel(storage)\n      @channels ||= {}\n      @channels[storage] ||= GRPC::ClientStub.setup_channel(\n        nil, stub_address(storage), stub_creds(storage), channel_args\n      )\n    end",
        "comment": "Cache gRPC servers by storage. All the client stubs in the same process can share the underlying connection to the same host thanks to HTTP2 framing protocol that gRPC is built on top. This method is not thread-safe. It is intended to be a part of `stub`, method behind a mutex protection.",
        "label": "Why",
        "id": "1364"
    },
    {
        "raw_code": "def last_chunk_context\n      @last_chunk_context.to_s.truncate(LAST_CHUNK_CONTEXT_CHAR_LIMIT).force_encoding('utf-8').scrub\n    end",
        "comment": "Before logging, we truncate the context to a reasonable length and scrub any non-printable characters.",
        "label": "Why",
        "id": "5870"
    },
    {
        "raw_code": "def allow_failure_criteria_attributes\n            return {} if rules_attributes[:allow_failure].nil?\n            return {} unless @seed_attributes.dig(:options, :allow_failure_criteria)\n\n            { options: { allow_failure_criteria: nil } }\n          end",
        "comment": "If a job uses `allow_failure:exit_codes` and `rules:allow_failure` we need to prevent the exit codes from being persisted because they would break the behavior defined by `rules:allow_failure`.",
        "label": "Why",
        "id": "2521"
    },
    {
        "raw_code": "def approve\n        api_post_to(api_approve_path, {})\n      end",
        "comment": "Approve merge request  Due to internal implementation of api client, project needs to have setting 'Prevent approval by merge request creator' set to false since we use same user that created merge request which is set through approval configuration  @return [void]",
        "label": "Why",
        "id": "4167"
    },
    {
        "raw_code": "def initialize(\n        config,\n        project: nil, pipeline: nil, sha: nil, ref: nil, user: nil, parent_pipeline: nil, source: nil,\n        pipeline_config: nil, logger: nil, inject_edge_stages: true, pipeline_policy_context: nil, inputs: {}\n      )\n        @logger = logger || ::Gitlab::Ci::Pipeline::Logger.new(project: project)\n        @source_ref_path = pipeline&.source_ref_path\n        @project = project\n        @inject_edge_stages = inject_edge_stages\n        @pipeline_policy_context = pipeline_policy_context\n\n        @context = self.logger.instrument(:config_build_context, once: true) do\n          pipeline ||= ::Ci::Pipeline.new(project: project, sha: sha, ref: ref, user: user, source: source)\n\n          build_context(project: project, pipeline: pipeline, sha: sha, user: user, parent_pipeline: parent_pipeline, pipeline_config: pipeline_config, pipeline_policy_context: pipeline_policy_context)\n        end",
        "comment": "rubocop: disable Metrics/ParameterLists",
        "label": "Why",
        "id": "2459"
    },
    {
        "raw_code": "def execute\n        scope = Ci::JobArtifact.select(:id).for_project(project_id).order(:id)\n        file_type_values = Ci::JobArtifact.erasable_file_types.map { |file_type| [Ci::JobArtifact.file_types[file_type]] }\n        from_sql = Arel::Nodes::Grouping.new(Arel::Nodes::ValuesList.new(file_type_values)).as('file_types (file_type)').to_sql\n        array_scope = Ci::JobArtifact.from(from_sql).select(:file_type)\n        array_mapping_scope = ->(file_type_expression) { Ci::JobArtifact.where(Ci::JobArtifact.arel_table[:file_type].eq(file_type_expression)) }\n\n        Gitlab::Pagination::Keyset::Iterator\n          .new(scope: scope, in_operator_optimization_options: { array_scope: array_scope, array_mapping_scope: array_mapping_scope })\n          .each_batch(of: BATCH_SIZE) do |batch|\n          ids = batch.to_a.map(&:id)\n          Ci::JobArtifact.unlocked.where(id: ids).update_all(locked: Ci::JobArtifact.lockeds[:unlocked], expire_at: expiry_time)\n        end",
        "comment": "rubocop:disable CodeReuse/ActiveRecord",
        "label": "Why",
        "id": "5811"
    },
    {
        "raw_code": "def list_invalid_properties\n      invalid_properties = Array.new\n      invalid_properties\n    end",
        "comment": "Show invalid properties with the reasons. Usually used together with valid? @return Array for valid properties with the reasons",
        "label": "Why",
        "id": "849"
    },
    {
        "raw_code": "def add_tag(tag_data, factory_method = nil)\n        tag, title = *tag_data.split(':')\n        title ||= tag.capitalize\n        Tags::Library.define_tag(title, tag.to_sym, factory_method)\n        Tags::Library.visible_tags |= [tag.to_sym]\n      end",
        "comment": "@since 0.6.0",
        "label": "Why",
        "id": "541"
    },
    {
        "raw_code": "def profile_if_needed\n      return yield unless @options[:profile]\n\n      return STATUS_ERROR unless require_gem('stackprof')\n\n      with_memory = @options[:memory]\n      if with_memory\n        return STATUS_ERROR unless require_gem('memory_profiler')\n\n        MemoryProfiler.start\n      end",
        "comment": "rubocop:disable Metrics/MethodLength, Metrics/AbcSize",
        "label": "Why",
        "id": "10059"
    },
    {
        "raw_code": "def act_upon_results\n        return unless threshold_exceeded?\n\n        error = ThresholdExceededError.new(error_message)\n\n        raise(error) if raise_error?\n      end",
        "comment": "Sends a notification based on the number of executed SQL queries.",
        "label": "Why",
        "id": "2111"
    },
    {
        "raw_code": "def process(_node)\n            raise NotImplementedError, \"#{self.class.name} must implement #process\"\n          end",
        "comment": "@abstract Implement #process in subclass to transform query nodes",
        "label": "Why",
        "id": "1144"
    },
    {
        "raw_code": "def delete_resources(\n        resources, delayed_verification = false, permanent = @permanently_delete,\n        skip_verification = @skip_verification, **options\n      )\n        logger.info(\"Deleting #{resources.length} #{@type}s...\\n\")\n\n        unverified_deletions = []\n        results = []\n\n        resources.each do |resource|\n          path = resource_path(resource)\n          resource[:type] = @type\n\n          logger.info(\"Deleting #{@type} #{path}...\")\n\n          result = delete_resource(resource, delayed_verification, permanent, skip_verification, **options)\n\n          if result.is_a?(Array)\n            results.append(result)\n          else\n            unverified_deletions << result\n          end",
        "comment": "Deletes a list of resources  @param [Array<Hash>] resources List of resources to delete @param [Boolean] delayed_verifications Wait until the end of the script to verify deletions @param [Boolean] permanent Permanently delete resources instead of marking for deletion @param [Boolean] skip_verification Skip verification of deletion for time constraint purposes @param [Hash] API call options @return [Array<String, Hash>] results",
        "label": "Why",
        "id": "4757"
    },
    {
        "raw_code": "def high\n            @high ||= {\n              gitlab: {\n                webservice: {\n                  workerProcesses: 4,\n                  minReplicas: 1,\n                  # See https://docs.gitlab.com/charts/charts/gitlab/webservice/#memory-requestslimits\n                  resources: resources(3, \"5Gi\", 3, \"7Gi\"),\n                  hpa: cpu_utilization\n                },\n                sidekiq: {\n                  concurrency: 30,\n                  minReplicas: 1,\n                  resources: resources(\"1200m\", \"2Gi\"),\n                  hpa: cpu_utilization\n                },\n                kas: {\n                  minReplicas: 1,\n                  resources: resources(\"60m\", \"96Mi\"),\n                  hpa: cpu_utilization\n                },\n                # TODO: if limits are defined, git operations start failing in e2e tests, investigate potential cause\n                # https://gitlab.com/gitlab-org/quality/quality-engineering/team-tasks/-/issues/3699\n                \"gitlab-shell\": {\n                  minReplicas: 2,\n                  resources: resources(\"60m\", \"32Mi\", no_limits: true),\n                  hpa: cpu_utilization\n                },\n                gitaly: {\n                  resources: resources(\"400m\", \"384Mi\")\n                },\n                # Toolbox create peak load during startup but then consumes very little\n                # Set high limit value but don't request full amount to avoid unnecessary lock\n                toolbox: {\n                  resources: resources(\"50m\", \"128Mi\", no_limits: true)\n                }\n              },\n              registry: {\n                resources: resources(\"50m\", \"128Mi\"),\n                hpa: {\n                  minReplicas: 1,\n                  **cpu_utilization\n                }\n              },\n              minio: {\n                resources: resources(\"50m\", \"32Mi\")\n              },\n              \"nginx-ingress\": {\n                controller: {\n                  resources: resources(\"30m\", \"256Mi\")\n                }\n              },\n              postgresql: {\n                primary: {\n                  resources: resources(\"600m\", \"1536Mi\")\n                }\n              },\n              redis: {\n                master: {\n                  resources: resources(\"100m\", \"16Mi\")\n                }\n              }\n            }\n          end",
        "comment": "High resource preset optimized for running e2e tests in parallel  @return [Hash]",
        "label": "Why",
        "id": "4013"
    },
    {
        "raw_code": "def invalidate_project_counter_caches\n    Projects::OpenMergeRequestsCountService.new(target_project).delete_cache\n  end",
        "comment": "rubocop: disable CodeReuse/ServiceClass",
        "label": "Why",
        "id": "6997"
    },
    {
        "raw_code": "def inspect\n        JSON.pretty_generate(comparable)\n      end",
        "comment": "Override inspect for a better rspec failure diff output  @return [String]",
        "label": "Why",
        "id": "4136"
    },
    {
        "raw_code": "def batched_migrations_last_id(for_database)\n            runner = nil\n            base_dir = background_migrations_dir(for_database)\n\n            Gitlab::Database::EachDatabase.each_connection(only: for_database) do |connection|\n              runner = Gitlab::Database::Migrations::BatchedMigrationLastId\n                         .new(connection, base_dir)\n            end",
        "comment": "rubocop:enable Database/MultipleDatabases",
        "label": "Why",
        "id": "3150"
    },
    {
        "raw_code": "def write_config_files(macos_version, kernel_version, arch)\n    clang_config_file_dir.mkpath\n\n    arches = Set.new([:arm64, :x86_64, :aarch64])\n    arches << arch\n\n    sysroot = if macos_version.blank? || (MacOS.version > macos_version && MacOS::CLT.separate_header_package?)\n      \"#{MacOS::CLT::PKG_PATH}/SDKs/MacOSX.sdk\"\n    elsif macos_version >= \"10.14\"\n      \"#{MacOS::CLT::PKG_PATH}/SDKs/MacOSX#{macos_version}.sdk\"\n    else\n      \"/\"\n    end",
        "comment": "We use the extra layer of indirection in `arch` because the FormulaAudit/OnSystemConditionals doesn't want to let us use `Hardware::CPU.arch` outside of `install` or `post_install` blocks.",
        "label": "Why",
        "id": "15"
    },
    {
        "raw_code": "def label_events(auto_paginate: false, attempts: 0)\n        events(\"label\", auto_paginate: auto_paginate, attempts: attempts)\n      end",
        "comment": "Issue label events  @param [Boolean] auto_paginate @param [Integer] attempts @return [Array<Hash>]",
        "label": "Why",
        "id": "4203"
    },
    {
        "raw_code": "def process_wiki_notes_with_ctes(ctes)\n        # Check if there are project wikis to update\n        check_project_wikis = <<~SQL\n          WITH\n            #{ctes},\n            wiki_notes AS (\n              SELECT * FROM filtered_relation\n              WHERE noteable_type = 'WikiPage::Meta'\n            )\n          SELECT EXISTS(\n            SELECT 1\n            FROM wiki_notes\n            JOIN wiki_page_meta ON wiki_notes.noteable_id = wiki_page_meta.id\n            WHERE wiki_page_meta.project_id IS NOT NULL\n            LIMIT 1\n          )\n        SQL\n\n        if connection.select_value(check_project_wikis)\n          # Handle project wikis\n          update_sql = <<~SQL\n            WITH\n              #{ctes},\n              relation_by_type AS (\n                SELECT * FROM filtered_relation\n                WHERE noteable_type = 'WikiPage::Meta'\n              )\n            UPDATE notes\n            SET namespace_id = projects.project_namespace_id\n            FROM relation_by_type\n            JOIN wiki_page_meta ON relation_by_type.noteable_id = wiki_page_meta.id\n            JOIN projects ON wiki_page_meta.project_id = projects.id\n            WHERE notes.id = relation_by_type.id\n              AND wiki_page_meta.project_id IS NOT NULL\n          SQL\n          connection.execute(update_sql)\n        end",
        "comment": "rubocop:disable Metrics/MethodLength -- Complex SQL queries are more readable as a single method",
        "label": "Why",
        "id": "3289"
    },
    {
        "raw_code": "def headers\n        @headers ||= {\n          \"PRIVATE-TOKEN\" => api_token,\n          \"Content-Type\" => \"application/json\"\n        }\n      end",
        "comment": "Default request headers  @return [Hash]",
        "label": "Why",
        "id": "8109"
    },
    {
        "raw_code": "def by_deployments(items)\n    env = params[:environment]\n    before = parse_datetime(params[:deployed_before])\n    after = parse_datetime(params[:deployed_after])\n    id = params[:deployment_id]\n\n    return items if !env && !before && !after && !id\n\n    # Each filter depends on the same JOIN+WHERE. To prevent this JOIN+WHERE\n    # from being duplicated for every filter, we only produce it once. The\n    # filter methods in turn expect the JOIN+WHERE to already be present.\n    #\n    # This approach ensures that query performance doesn't degrade as the number\n    # of deployment related filters increases.\n    deploys = DeploymentMergeRequest.join_deployments_for_merge_requests\n    deploys = deploys.by_deployment_id(id) if id\n    deploys = deploys.deployed_to(env) if env\n    deploys = deploys.deployed_before(before) if before\n    deploys = deploys.deployed_after(after) if after\n\n    items.where_exists(deploys)\n  end",
        "comment": "rubocop: enable CodeReuse/Finder",
        "label": "Why",
        "id": "7887"
    },
    {
        "raw_code": "def self.desensitize(string)\n        string = string.to_s.dup\n        sensitive_strings.each do |remove|\n          string.gsub!(/(\\W|^)#{Regexp.escape(remove)}(\\W|$)/, \"\\\\1#{REPLACEMENT_TEXT}\\\\2\")\n        end",
        "comment": "Remove sensitive information from string  @param [String] string @return [String]",
        "label": "Why",
        "id": "9225"
    },
    {
        "raw_code": "def public_port\n          @public_port ||= if host_network?\n                             server_port\n                           elsif docker_network?\n                             DEFAULT_SERVER_PORT\n                           else\n                             fetch_published_port(DEFAULT_SERVER_PORT)\n                           end",
        "comment": "Server port  When running in contained docker network, return internal port because service is accessed using hostname:port  @return [Integer]",
        "label": "Why",
        "id": "4230"
    },
    {
        "raw_code": "def require_ssh_key?\n    count = Users::KeysCountService.new(self).count\n\n    count == 0 && Gitlab::ProtocolAccess.allowed?('ssh')\n  end",
        "comment": "rubocop: disable CodeReuse/ServiceClass",
        "label": "Why",
        "id": "7079"
    },
    {
        "raw_code": "def scope_for(relation, owner = nil)\n            if scope.arity == 1 && owner.nil? && options.key?(:partition_foreign_key)\n              relation = relation.instance_exec(NO_OWNER, &scope)\n              if relation_includes_partition_id_condition?(relation)\n                relation.rewhere(relation.table[:partition_id].not_eq(nil))\n              else\n                relation\n              end",
        "comment": "We override the method to allow eager loading of partitioned records  For eager loading the owner is always nil and we supply a benign object that allows the scope to be evaluated with a query like `where partition_id between 1 and 100000` and transforms it into `where partition_id is not null` to ensure that no partition is left out by the query. This is safe because `partition_id` columns are defined as `not null` ",
        "label": "Why",
        "id": "1173"
    },
    {
        "raw_code": "def <=>(other)\n      return unless other.is_a? VersionInfo\n      return unless valid? && other.valid?\n\n      if other.major < @major\n        1\n      elsif @major < other.major\n        -1\n      elsif other.minor < @minor\n        1\n      elsif @minor < other.minor\n        -1\n      elsif other.patch < @patch\n        1\n      elsif @patch < other.patch\n        -1\n      elsif @suffix_s.empty? && other.suffix.present?\n        1\n      elsif other.suffix.empty? && @suffix_s.present?\n        -1\n      else\n        suffix <=> other.suffix\n      end",
        "comment": "rubocop:disable Metrics/CyclomaticComplexity rubocop:disable Metrics/PerceivedComplexity",
        "label": "Why",
        "id": "1227"
    },
    {
        "raw_code": "def param_error_message(parent, key, value, supposed_values)\n      \"#{Rainbow('').reset}\" \\\n        \"Property #{Rainbow(key).yellow} of #{Rainbow(parent).yellow} cop \" \\\n        \"is supposed to be #{supposed_values} and #{Rainbow(value).yellow} is not.\"\n    end",
        "comment": "FIXME: Handling colors in exception messages like this is ugly.",
        "label": "Why",
        "id": "10051"
    },
    {
        "raw_code": "def do_nothing(markup_item)\n  end",
        "comment": " Does nothing to +markup_item+ because it doesn't have any user-built content",
        "label": "Why",
        "id": "16259"
    },
    {
        "raw_code": "def users\n      groups = group.self_and_hierarchy_intersecting_with_user_groups(current_user)\n      members = GroupMember.where(group: groups).non_invite\n\n      users = super\n\n      users.where(id: members.select(:user_id))\n    end",
        "comment": "rubocop:disable CodeReuse/ActiveRecord",
        "label": "Why",
        "id": "1655"
    },
    {
        "raw_code": "def open_issues_count(current_user = nil)\n    return Projects::OpenIssuesCountService.new(self, current_user).count unless current_user.nil?\n\n    BatchLoader.for(self).batch do |projects, loader|\n      issues_count_per_project = ::Projects::BatchOpenIssuesCountService.new(projects).refresh_cache_and_retrieve_data\n\n      issues_count_per_project.each do |project, count|\n        loader.call(project, count)\n      end",
        "comment": "rubocop: disable CodeReuse/ServiceClass",
        "label": "Why",
        "id": "6755"
    },
    {
        "raw_code": "def report_name\n        \"#{ENV['CI_JOB_NAME_SLUG'] || 'local'}-knapsack-report.json\"\n      end",
        "comment": "Knapsack report file name  @return [String]",
        "label": "Why",
        "id": "4543"
    },
    {
        "raw_code": "def remove_partitioned_foreign_key(source, target = nil, column: nil, name: nil, reverse_lock_order: false)\n          assert_not_in_transaction_block(scope: ERROR_SCOPE)\n\n          # Determine the foreign key name if not provided\n          name = concurrent_partitioned_foreign_key_name(source, column) if name.nil? && column.present?\n\n          raise ArgumentError, 'Either name or column must be specified' if name.nil?\n\n          # Remove foreign key from the partitioned table first\n          # This is important because PostgreSQL doesn't allow dropping inherited constraints\n          # from partitions while they still exist on the parent table\n          with_lock_retries do\n            remove_foreign_key_if_exists(source, target, name: name, reverse_lock_order: reverse_lock_order)\n          end",
        "comment": "Removes a foreign key from a partitioned table and all its partitions.  This method handles the removal of foreign keys from partitioned tables properly. Unlike the regular remove_foreign_key method, this method removes the foreign key from the partitioned table first, then from each partition individually. This is necessary because PostgreSQL doesn't allow dropping inherited constraints from partitions while they still exist on the parent table.  source - The source (partitioned) table containing the foreign key. target - The target table the key points to (optional if using name parameter). column - The name of the column with the foreign key (optional if using name parameter). name - The name of the foreign key constraint (optional if using column parameter). reverse_lock_order - Flag that controls whether we should attempt to acquire locks in the reverse order of the ALTER TABLE. This can be useful in situations where the foreign key removal could deadlock with another process.  Example:  remove_partitioned_foreign_key :users, :projects, column: :project_id remove_partitioned_foreign_key :users, name: 'fk_rails_123456' ",
        "label": "Why",
        "id": "3046"
    },
    {
        "raw_code": "def can_read_reference?(user, ref_project, node)\n        raise NotImplementedError\n      end",
        "comment": "When a feature is disabled or visible only for team members we should not allow team members see reference comments. Override this method on subclasses to check if user can read resource",
        "label": "Why",
        "id": "3435"
    },
    {
        "raw_code": "def drop_enum(...) # :nodoc:\n      end",
        "comment": "This is meant to be implemented by the adapters that support custom enum types",
        "label": "Why",
        "id": "12912"
    },
    {
        "raw_code": "def update_columns(attributes)\n      raise ActiveRecordError, \"cannot update a new record\" if new_record?\n      raise ActiveRecordError, \"cannot update a destroyed record\" if destroyed?\n      _raise_readonly_record_error if readonly?\n\n      attributes = attributes.transform_keys do |key|\n        name = key.to_s\n        name = self.class.attribute_aliases[name] || name\n        verify_readonly_attribute(name) || name\n      end",
        "comment": "Updates the attributes directly in the database issuing an UPDATE SQL statement and sets them in the receiver:  user.update_columns(last_request_at: Time.current)  This is the fastest way to update attributes because it goes straight to the database, but take into account that in consequence the regular update procedures are totally bypassed. In particular:  * \\Validations are skipped. * \\Callbacks are skipped. * +updated_at+/+updated_on+ are updated if the +touch+ option is set to +true+. * However, attributes are serialized with the same rules as ActiveRecord::Relation#update_all  This method raises an ActiveRecord::ActiveRecordError when called on new objects, or when at least one of the attributes is marked as readonly.  ==== Parameters  * <tt>:touch</tt> option - Touch the timestamp columns when updating. * If attribute names are passed, they are updated along with +updated_at+/+updated_on+ attributes.  ==== Examples  # Update a single attribute. user.update_columns(last_request_at: Time.current)  # Update with touch option. user.update_columns(last_request_at: Time.current, touch: true)",
        "label": "Why",
        "id": "12571"
    },
    {
        "raw_code": "def bytes_to_string(bytes)\n          # We want to locate the size that will return the\n          # smallest whole value number\n          BYTES_CONVERSION_MAP.sort { |a, b|\n            b.last <=> a.last\n          }.each do |suffix, size|\n            val = bytes.to_f / size\n            next if val < 1\n            val = sprintf(\"%.2f\", val)\n            val.slice!(-1, 1) while val.end_with?(\"0\")\n            val.slice!(-1, 1) if val.end_with?(\".\")\n            return \"#{val}#{suffix}\"\n          end",
        "comment": "Convert bytes to a user friendly string representation  @param [Numeric] bytes Number of bytes to represent @return [String] user friendly output",
        "label": "Why",
        "id": "9145"
    },
    {
        "raw_code": "def refresh_authorized_projects(source: nil)\n    Users::RefreshAuthorizedProjectsService.new(self, source: source).execute\n  end",
        "comment": "rubocop: disable CodeReuse/ServiceClass",
        "label": "Why",
        "id": "7075"
    },
    {
        "raw_code": "def fallback_diff_refs\n    real_refs = diff_refs\n    return real_refs if real_refs\n\n    likely_base_commit_sha = (first_commit&.parent || first_commit)&.sha\n\n    Gitlab::Diff::DiffRefs.new(\n      base_sha: likely_base_commit_sha,\n      start_sha: safe_start_commit_sha,\n      head_sha: head_commit_sha\n    )\n  end",
        "comment": "MRs created before 8.4 don't store their true diff refs (start and base), but we need to get a commit SHA for the \"View file @ ...\" link by a file, so we use an approximation of the diff refs if we can't get the actual one.  These will not be the actual diff refs if the target branch was merged into the source branch after the merge request was created, but it is good enough for the specific purpose of linking to a commit.  It is not good enough for highlighting diffs, so we can't simply pass these as `diff_refs.`",
        "label": "Why",
        "id": "6867"
    },
    {
        "raw_code": "def execution_message(text = '', &block)\n          @execution_message = block || text\n        end",
        "comment": "Allows to provide a message about quick action execution result, success or failure. This message is shown after quick action execution and after saving the note.  Example:  execution_message do |arguments| \"Added labels #{arguments.join(' ')}\" end command :command_key do |arguments| # Awesome code block end  Note: The execution_message won't be executed unless the condition block returns true. execution_message block is executed always after the command block has run, for this reason if the condition block doesn't return true after the command block has run you need to set the @execution_message variable inside the command block instead as shown in the following example.  Example using instance variable:  command :command_key do |arguments| # Awesome code block @execution_message[:command_key] = 'command_key executed successfully' end ",
        "label": "Why",
        "id": "2945"
    },
    {
        "raw_code": "def write(key, value, _options = nil)\n        store.write(key, value)\n      end",
        "comment": "This method accept an options hash to be compatible with ActiveSupport::Cache::Store#write method. The options are not passed to the underlying cache implementation because RequestStore#write accepts only a key, and value params.",
        "label": "Why",
        "id": "1243"
    },
    {
        "raw_code": "def find_oauth_access_token; end\n\n          def find_personal_access_token_from_conan_jwt\n            token = decode_oauth_token_from_jwt\n\n            return unless token\n\n            token.access_token_id\n          end\n\n          def find_deploy_token_from_conan_jwt\n            token = decode_oauth_token_from_jwt\n\n            return unless token\n\n            deploy_token = DeployToken.active.find_by_token(token.access_token_id.to_s)\n            # note: uesr_id is not a user record id, but is the attribute set on ConanToken\n            return if token.user_id != deploy_token&.username\n\n            deploy_token\n          end\n\n          def find_job_from_conan_jwt\n            token = decode_oauth_token_from_jwt\n\n            return unless token\n\n            ::Ci::AuthJobFinder.new(token: token.access_token_id.to_s).execute\n          end\n\n          def decode_oauth_token_from_jwt\n            jwt = Doorkeeper::OAuth::Token.from_bearer_authorization(current_request)\n\n            return unless jwt\n\n            token = ::Gitlab::ConanToken.decode(jwt)\n\n            return unless token && token.access_token_id && token.user_id\n\n            token\n          end\n\n          def package_scope\n            params[:id].present? ? :project : :instance\n          end\n\n          def search_project\n            project\n          end\n        end",
        "comment": "We need to override this one because it looks into Bearer authorization header",
        "label": "Why",
        "id": "3851"
    },
    {
        "raw_code": "def non_housekeeper_changes(\n        source_project_id:,\n        source_branch:,\n        target_branch:,\n        target_project_id:\n      )\n        existing_merge_request = get_existing_merge_request(\n          source_project_id: source_project_id,\n          source_branch: source_branch,\n          target_branch: target_branch,\n          target_project_id: target_project_id\n        )\n\n        return [] if existing_merge_request.nil?\n\n        merge_request_notes = get_merge_request_notes(\n          target_project_id: target_project_id,\n          iid: existing_merge_request['iid']\n        )\n\n        changes = Set.new\n\n        merge_request_notes.each do |note|\n          next false unless note[\"system\"]\n          next false if note[\"author\"][\"id\"] == current_user_id\n\n          match = match_system_note(note['body'])\n          changes << match if match\n        end",
        "comment": "This looks at the system notes of the merge request to detect if it has been updated by anyone other than the current housekeeper user. If it has then it assumes that they did this for a reason and we can skip updating this detail of the merge request. Otherwise we assume we should generate it again using the latest output.",
        "label": "Why",
        "id": "1247"
    },
    {
        "raw_code": "def serializable_hash(options = nil)\n      options = options.try(:dup) || {}\n      options[:except] = Array(options[:except]).dup\n\n      options[:except].concat self.class.attributes_exempt_from_serializable_hash\n\n      options[:except].concat self.class.sensitive_attributes\n\n      super(options)\n    end",
        "comment": "Override serializable_hash to exclude sensitive attributes by default  In general, prefer NOT to use serializable_hash / to_json / as_json in favor of serializers / entities instead which has an allowlist of attributes",
        "label": "Why",
        "id": "7416"
    },
    {
        "raw_code": "def clear_progress\n      return unless show_progress\n      io.write(\"\\e[?25h\\e[2K\")\n      @progress_msg = nil\n    end",
        "comment": "Clears the progress indicator in the TTY display. @return [void] @since 0.8.2",
        "label": "Why",
        "id": "142"
    },
    {
        "raw_code": "def attribute_will_change!(attr_name)\n        mutations_from_database.force_change(attr_name.to_s)\n      end",
        "comment": "Dispatch target for <tt>*_will_change!</tt> attribute methods.",
        "label": "Why",
        "id": "12211"
    },
    {
        "raw_code": "def options_from_collection_for_select(collection, value_method, text_method, selected = nil)\n        options = collection.map do |element|\n          [value_for_collection(element, text_method), value_for_collection(element, value_method), option_html_attributes(element)]\n        end",
        "comment": "Returns a string of option tags that have been compiled by iterating over the +collection+ and assigning the result of a call to the +value_method+ as the option value and the +text_method+ as the option text.  options_from_collection_for_select(@people, 'id', 'name') # => <option value=\"#{person.id}\">#{person.name}</option>  This is more often than not used inside a #select_tag like this example:  select_tag 'person', options_from_collection_for_select(@people, 'id', 'name')  If +selected+ is specified as a value or array of values, the element(s) returning a match on +value_method+ will be selected option tag(s).  If +selected+ is specified as a Proc, those members of the collection that return true for the anonymous function are the selected values.  +selected+ can also be a hash, specifying both <tt>:selected</tt> and/or <tt>:disabled</tt> values as required.  Be sure to specify the same class as the +value_method+ when specifying selected or disabled options. Failure to do this will produce undesired results. Example: options_from_collection_for_select(@people, 'id', 'name', '1') Will not select a person with the id of 1 because 1 (an Integer) is not the same as '1' (a string) options_from_collection_for_select(@people, 'id', 'name', 1) should produce the desired results.",
        "label": "Why",
        "id": "11904"
    },
    {
        "raw_code": "def disable_referential_integrity\n        yield\n      end",
        "comment": "REFERENTIAL INTEGRITY ==================================== Override to turn off referential integrity while executing <tt>&block</tt>.",
        "label": "Why",
        "id": "12922"
    },
    {
        "raw_code": "def wait_for_latest_pipeline_to_finish(project:, wait: 240)\n        Runtime::Logger.info(\"Waiting for #{project.name}'s latest pipeline to finish...\")\n        Support::Waiter.wait_until(message: 'Wait for latest pipeline to run', max_duration: wait) do\n          pipeline = project.latest_pipeline\n          pipeline[:started_at].present? && pipeline[:finished_at].present?\n        end",
        "comment": "To wait for pipeline to complete regardless of status ",
        "label": "Why",
        "id": "4252"
    },
    {
        "raw_code": "def write(name, value, options = nil)\n        options = merged_options(options)\n        key = normalize_key(name, options)\n\n        instrument(:write, key, options) do\n          entry = Entry.new(value, **options, version: normalize_version(name, options))\n          write_entry(key, entry, **options)\n        end",
        "comment": "Writes the value to the cache with the key. The value must be supported by the +coder+'s +dump+ and +load+ methods.  Returns +true+ if the write succeeded, +nil+ if there was an error talking to the cache backend, or +false+ if the write failed for another reason.  By default, cache entries larger than 1kB are compressed. Compression allows more data to be stored in the same memory footprint, leading to fewer cache evictions and higher hit rates.  ==== Options  * <tt>compress: false</tt> - Disables compression of the cache entry.  * +:compress_threshold+ - The compression threshold, specified in bytes. \\Cache entries larger than this threshold will be compressed. Defaults to +1.kilobyte+.  * +:expires_in+ - Sets a relative expiration time for the cache entry, specified in seconds. +:expire_in+ and +:expired_in+ are aliases for +:expires_in+.  cache = ActiveSupport::Cache::MemoryStore.new(expires_in: 5.minutes) cache.write(key, value, expires_in: 1.minute) # Set a lower value for one entry  * +:expires_at+ - Sets an absolute expiration time for the cache entry.  cache = ActiveSupport::Cache::MemoryStore.new cache.write(key, value, expires_at: Time.now.at_end_of_hour)  * +:version+ - Specifies a version for the cache entry. When reading from the cache, if the cached version does not match the requested version, the read will be treated as a cache miss. This feature is used to support recyclable cache keys.  * +:unless_exist+ - Prevents overwriting an existing cache entry.  Other options will be handled by the specific cache store implementation.",
        "label": "Why",
        "id": "13740"
    },
    {
        "raw_code": "def new_access_token\n      find_by_testid('created-access-token-field').value\n    end",
        "comment": "Keep when we migrate the legacy UI to use initSharedAccessTokenApp",
        "label": "Why",
        "id": "8517"
    },
    {
        "raw_code": "def initialize(name, client)\n          @name = name\n          @client = client\n        end",
        "comment": "Prefer Jenkins::Client#jobs and Jenkins::Client.create_job over this constructor  @param name [String] the name of the job @param client [Jenkins::Client] the jenkins client",
        "label": "Why",
        "id": "4327"
    },
    {
        "raw_code": "def merge_request_iid\n        env('CI_MERGE_REQUEST_IID') || env('TOP_UPSTREAM_MERGE_REQUEST_IID')\n      end",
        "comment": "Merge request iid  @return [String]",
        "label": "Why",
        "id": "4568"
    },
    {
        "raw_code": "def change\n    add_column :merge_request_diff_commits, :merge_request_commits_metadata_id, :bigint, null: true\n  end",
        "comment": "rubocop:disable Migration/PreventAddingColumns -- this column is required as we will be querying data from `merge_request_commits_metadata` table using this column",
        "label": "Why",
        "id": "4984"
    },
    {
        "raw_code": "def quote(value)\n        case value\n        when String, Symbol, ActiveSupport::Multibyte::Chars\n          \"'#{quote_string(value.to_s)}'\"\n        when true       then quoted_true\n        when false      then quoted_false\n        when nil        then \"NULL\"\n        # BigDecimals need to be put in a non-normalized form and quoted.\n        when BigDecimal then value.to_s(\"F\")\n        when Numeric then value.to_s\n        when Type::Binary::Data then quoted_binary(value)\n        when Type::Time::Value then \"'#{quoted_time(value)}'\"\n        when Date, Time then \"'#{quoted_date(value)}'\"\n        when Class      then \"'#{value}'\"\n        else\n          raise TypeError, \"can't quote #{value.class.name}\"\n        end",
        "comment": "Quotes the column value to help prevent {SQL injection attacks}[https://en.wikipedia.org/wiki/SQL_injection].",
        "label": "Why",
        "id": "13089"
    },
    {
        "raw_code": "def lookup_cast_type(sql_type) # :nodoc:\n          super(query_value(\"SELECT #{quote(sql_type)}::regtype::oid\", \"SCHEMA\").to_i)\n        end",
        "comment": "TODO: Make this method private after we release 8.1.",
        "label": "Why",
        "id": "13222"
    },
    {
        "raw_code": "def halt\n          raise BaseError, _key: :unsupported_halt\n        end",
        "comment": "Halt the machine. This method should gracefully shut down the operating system. This method will cause `vagrant halt` and associated commands to _block_, meaning that if the machine doesn't halt in a reasonable amount of time, this method should just return.  If when this method returns, the machine's state isn't \"powered_off,\" Vagrant will proceed to forcefully shut the machine down.",
        "label": "Why",
        "id": "9015"
    },
    {
        "raw_code": "def fast_auto_devops_stages\n    auto_devops_template = YAML.safe_load(File.read('lib/gitlab/ci/templates/Auto-DevOps.gitlab-ci.yml'))\n    auto_devops_template['stages']\n  end",
        "comment": "stubbing this method allows this spec file to use fast_spec_helper",
        "label": "Why",
        "id": "8249"
    },
    {
        "raw_code": "def owner_class_attribute_default; end\n\n    event :block do\n      transition active: :blocked\n      transition deactivated: :blocked\n      transition ldap_blocked: :blocked\n      transition blocked_pending_approval: :blocked\n    end",
        "comment": "state_machine uses this method at class loading time to fetch the default value for the `state` column but in doing so it also evaluates all other columns default values which could trigger the recursive generation of ApplicationSetting records. We're setting it to `nil` here because we don't have a database default for the `state` column. ",
        "label": "Why",
        "id": "7047"
    },
    {
        "raw_code": "def eql_with_coercion(other)\n    # if other is an ActiveSupport::TimeWithZone, coerce a Time instance from it so we can do eql? comparison\n    other = other.comparable_time if other.respond_to?(:comparable_time)\n    eql_without_coercion(other)\n  end",
        "comment": "Layers additional behavior on Time#eql? so that ActiveSupport::TimeWithZone instances can be eql? to an equivalent Time",
        "label": "Why",
        "id": "14408"
    },
    {
        "raw_code": "def javascript_include_tag(*sources)\n    options = { defer: true }.merge(sources.extract_options!)\n    options[:nonce] = true\n    super(*sources, **options)\n  end",
        "comment": "Override the default ActionView `javascript_include_tag` helper to support page specific deferred loading. PLEASE NOTE: `defer` is also critical so that we don't run JavaScript entrypoints before the DOM is ready. Please see https://gitlab.com/groups/gitlab-org/-/epics/4538#note_432159769. The helper also makes sure the `nonce` attribute is included in every script when the content security policy is enabled.",
        "label": "Why",
        "id": "7779"
    },
    {
        "raw_code": "def write_config_files(macos_version, kernel_version, arch)\n    clang_config_file_dir.mkpath\n\n    arches = Set.new([:arm64, :x86_64, :aarch64])\n    arches << arch\n\n    sysroot = if macos_version.blank? || (MacOS.version > macos_version && MacOS::CLT.separate_header_package?)\n      \"#{MacOS::CLT::PKG_PATH}/SDKs/MacOSX.sdk\"\n    elsif macos_version >= \"10.14\"\n      \"#{MacOS::CLT::PKG_PATH}/SDKs/MacOSX#{macos_version}.sdk\"\n    else\n      \"/\"\n    end",
        "comment": "We use the extra layer of indirection in `arch` because the FormulaAudit/OnSystemConditionals doesn't want to let us use `Hardware::CPU.arch` outside of `install` or `post_install` blocks.",
        "label": "Why",
        "id": "14"
    },
    {
        "raw_code": "def test_mysql_not_null_defaults_non_strict\n      using_strict(false) do\n        with_mysql_not_null_table do |klass|\n          record = klass.new\n          assert_nil record.non_null_integer\n          assert_nil record.non_null_string\n          assert_nil record.non_null_text\n          assert_nil record.non_null_blob\n\n          record.save!\n          record.reload\n\n          assert_equal 0,  record.non_null_integer\n          assert_equal \"\", record.non_null_string\n          assert_equal \"\", record.non_null_text\n          assert_equal \"\", record.non_null_blob\n        end",
        "comment": "Strict mode controls how MySQL handles invalid or missing values in data-change statements such as INSERT or UPDATE. A value can be invalid for several reasons. For example, it might have the wrong data type for the column, or it might be out of range. A value is missing when a new row to be inserted does not contain a value for a non-NULL column that has no explicit DEFAULT clause in its definition. (For a NULL column, NULL is inserted if the value is missing.)  If strict mode is not in effect, MySQL inserts adjusted values for invalid or missing values and produces warnings. In strict mode, you can produce this behavior by using INSERT IGNORE or UPDATE IGNORE.  https://dev.mysql.com/doc/refman/en/sql-mode.html#sql-mode-strict",
        "label": "Why",
        "id": "13506"
    },
    {
        "raw_code": "def support_pin_data\n    strong_memoize(:support_pin_data) do\n      Users::SupportPin::RetrieveService.new(self).execute\n    end",
        "comment": "rubocop: disable CodeReuse/ServiceClass",
        "label": "Why",
        "id": "7107"
    },
    {
        "raw_code": "def self.failure_reasons\n        {\n          unknown_failure: nil,\n          script_failure: 1,\n          api_failure: 2,\n          stuck_or_timeout_failure: 3,\n          runner_system_failure: 4,\n          missing_dependency_failure: 5,\n          runner_unsupported: 6,\n          stale_schedule: 7,\n          job_execution_timeout: 8,\n          archived_failure: 9,\n          unmet_prerequisites: 10,\n          scheduler_failure: 11,\n          data_integrity_failure: 12,\n          forward_deployment_failure: 13, # Deprecated in favor of failed_outdated_deployment_job.\n          user_blocked: 14,\n          project_deleted: 15,\n          ci_quota_exceeded: 16,\n          pipeline_loop_detected: 17,\n          no_matching_runner: 18,\n          trace_size_exceeded: 19,\n          builds_disabled: 20,\n          environment_creation_failure: 21,\n          deployment_rejected: 22,\n          failed_outdated_deployment_job: 23,\n          runner_provisioning_timeout: 24,\n          protected_environment_failure: 1_000,\n          insufficient_bridge_permissions: 1_001,\n          downstream_bridge_project_not_found: 1_002,\n          invalid_bridge_trigger: 1_003,\n          upstream_bridge_project_not_found: 1_004,\n          insufficient_upstream_permissions: 1_005,\n          bridge_pipeline_is_child_pipeline: 1_006, # not used anymore, but cannot be deleted because of old data\n          downstream_pipeline_creation_failed: 1_007,\n          secrets_provider_not_found: 1_008,\n          reached_max_descendant_pipelines_depth: 1_009,\n          ip_restriction_failure: 1_010,\n          reached_max_pipeline_hierarchy_size: 1_011,\n          reached_downstream_pipeline_trigger_rate_limit: 1_012\n        }\n      end",
        "comment": "Returns the Hash to use for creating the `failure_reason` enum for `CommitStatus`.",
        "label": "Why",
        "id": "7426"
    },
    {
        "raw_code": "def rhs_range_to_remove(term)\n          source = @processed_source.buffer.source\n\n          pos = term.source_range.begin_pos\n          pos -= 1 until source[pos, 3].start_with?(*OPERATORS)\n\n          range_with_surrounding_space(\n            range: term.source_range.with(begin_pos: pos - 1),\n            side: :right,\n            newlines: false\n          )\n        end",
        "comment": "If the redundant `defined?` node is the RHS of an `and` node, the term as well as the preceding `&&`/`and` operator will be removed.",
        "label": "Why",
        "id": "10561"
    },
    {
        "raw_code": "def rescued_exceptions(resbody)\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `rescued_exceptions` is deprecated. Use `ResbodyNode#exceptions` instead.\n        WARNING\n\n        rescue_group, = *resbody\n        if rescue_group\n          rescue_group.values\n        else\n          []\n        end",
        "comment": "@deprecated Use ResbodyNode#exceptions instead",
        "label": "Why",
        "id": "10437"
    },
    {
        "raw_code": "def find_for_database_authentication(warden_conditions)\n      conditions = warden_conditions.dup\n      if login = conditions.delete(:login)\n        where(conditions).find_by(\"lower(username) = :value OR lower(email) = :value\", value: login.downcase.strip)\n      else\n        find_by(conditions)\n      end",
        "comment": "Devise method overridden to allow sign in with email or username",
        "label": "Why",
        "id": "7053"
    },
    {
        "raw_code": "def forks_count\n    BatchLoader.for(self).batch do |projects, loader|\n      fork_count_per_project = ::Projects::BatchForksCountService.new(projects).refresh_cache_and_retrieve_data\n\n      fork_count_per_project.each do |project, count|\n        loader.call(project, count)\n      end",
        "comment": "rubocop: disable CodeReuse/ServiceClass",
        "label": "Why",
        "id": "6762"
    },
    {
        "raw_code": "def permit(*filters)\n      permit_filters(filters, on_unpermitted: self.class.action_on_unpermitted_parameters, explicit_arrays: false)\n    end",
        "comment": "Returns a new `ActionController::Parameters` instance that includes only the given `filters` and sets the `permitted` attribute for the object to `true`. This is useful for limiting which attributes should be allowed for mass updating.  params = ActionController::Parameters.new(name: \"Francesco\", age: 22, role: \"admin\") permitted = params.permit(:name, :age) permitted.permitted?      # => true permitted.has_key?(:name) # => true permitted.has_key?(:age)  # => true permitted.has_key?(:role) # => false  Only permitted scalars pass the filter. For example, given  params.permit(:name)  `:name` passes if it is a key of `params` whose associated value is of type `String`, `Symbol`, `NilClass`, `Numeric`, `TrueClass`, `FalseClass`, `Date`, `Time`, `DateTime`, `StringIO`, `IO`, ActionDispatch::Http::UploadedFile or `Rack::Test::UploadedFile`. Otherwise, the key `:name` is filtered out.  You may declare that the parameter should be an array of permitted scalars by mapping it to an empty array:  params = ActionController::Parameters.new(tags: [\"rails\", \"parameters\"]) params.permit(tags: [])  Sometimes it is not possible or convenient to declare the valid keys of a hash parameter or its internal structure. Just map to an empty hash:  params.permit(preferences: {})  Be careful because this opens the door to arbitrary input. In this case, `permit` ensures values in the returned structure are permitted scalars and filters out anything else.  You can also use `permit` on nested parameters:  params = ActionController::Parameters.new({ person: { name: \"Francesco\", age:  22, pets: [{ name: \"Purplish\", category: \"dogs\" }] } })  permitted = params.permit(person: [ :name, { pets: :name } ]) permitted.permitted?                    # => true permitted[:person][:name]               # => \"Francesco\" permitted[:person][:age]                # => nil permitted[:person][:pets][0][:name]     # => \"Purplish\" permitted[:person][:pets][0][:category] # => nil  This has the added benefit of rejecting user-modified inputs that send a string when a hash is expected.  When followed by `require`, you can both filter and require parameters following the typical pattern of a Rails form. The `expect` method was made specifically for this use case and is the recommended way to require and permit parameters.  permitted = params.expect(person: [:name, :age])  When using `permit` and `require` separately, pay careful attention to the order of the method calls.  params = ActionController::Parameters.new(person: { name: \"Martin\", age: 40, role: \"admin\" }) permitted = params.permit(person: [:name, :age]).require(:person) # correct  When require is used first, it is possible for users of your application to trigger a NoMethodError when the user, for example, sends a string for :person.  params = ActionController::Parameters.new(person: \"tampered\") permitted = params.require(:person).permit(:name, :age) # not recommended # => NoMethodError: undefined method `permit' for an instance of String  Note that if you use `permit` in a key that points to a hash, it won't allow all the hash. You also need to specify which attributes inside the hash should be permitted.  params = ActionController::Parameters.new({ person: { contact: { email: \"none@test.com\", phone: \"555-1234\" } } })  params.permit(person: :contact).require(:person) # => ActionController::ParameterMissing: param is missing or the value is empty or invalid: person  params.permit(person: { contact: :phone }).require(:person) # => #<ActionController::Parameters {\"contact\"=>#<ActionController::Parameters {\"phone\"=>\"555-1234\"} permitted: true>} permitted: true>  params.permit(person: { contact: [ :email, :phone ] }).require(:person) # => #<ActionController::Parameters {\"contact\"=>#<ActionController::Parameters {\"email\"=>\"none@test.com\", \"phone\"=>\"555-1234\"} permitted: true>} permitted: true>  If your parameters specify multiple parameters indexed by a number, you can permit each set of parameters under the numeric key to be the same using the same syntax as permitting a single item.  params = ActionController::Parameters.new({ person: { '0': { email: \"none@test.com\", phone: \"555-1234\" }, '1': { email: \"nothing@test.com\", phone: \"555-6789\" }, } }) params.permit(person: [:email]).to_h # => {\"person\"=>{\"0\"=>{\"email\"=>\"none@test.com\"}, \"1\"=>{\"email\"=>\"nothing@test.com\"}}}  If you want to specify what keys you want from each numeric key, you can instead specify each one individually  params = ActionController::Parameters.new({ person: { '0': { email: \"none@test.com\", phone: \"555-1234\" }, '1': { email: \"nothing@test.com\", phone: \"555-6789\" }, } }) params.permit(person: { '0': [:email], '1': [:phone]}).to_h # => {\"person\"=>{\"0\"=>{\"email\"=>\"none@test.com\"}, \"1\"=>{\"phone\"=>\"555-6789\"}}}",
        "label": "Why",
        "id": "11363"
    },
    {
        "raw_code": "def add_members(sources, invitees, access_level, **args)\n        return [] unless invitees.present?\n\n        sources = Array.wrap(sources) if sources.is_a?(ApplicationRecord) # For single source\n\n        Gitlab::Database::QueryAnalyzers::PreventCrossDatabaseModification.temporary_ignore_tables_in_transaction(\n          %w[users user_preferences user_details emails identities], url: 'https://gitlab.com/gitlab-org/gitlab/-/issues/424276'\n        ) do\n          Member.transaction do\n            sources.flat_map do |source|\n              # If this user is attempting to manage Owner members and doesn't have permission, do not allow\n              current_user = args[:current_user]\n              next [] if managing_owners?(current_user, access_level) && cannot_manage_owners?(source, current_user)\n\n              emails, users, existing_members, users_by_emails = parse_users_list(source, invitees)\n\n              common_arguments = {\n                source: source,\n                access_level: access_level,\n                existing_members: existing_members,\n                users_by_emails: users_by_emails\n              }.merge(parsed_args(args))\n\n              build_members(emails, users, common_arguments)\n            end",
        "comment": "Add members to sources with passed access option  access can be an integer representing a access code or symbol like :maintainer representing role  Ex. add_members( sources, user_ids, Member::MAINTAINER )  add_members( sources, user_ids, :maintainer )  @param sources [Group, Project, Array<Group>, Array<Project>, Group::ActiveRecord_Relation, Project::ActiveRecord_Relation] - Can't be an array of source ids because we don't know the type of source. @return Array<Member>",
        "label": "Why",
        "id": "6109"
    },
    {
        "raw_code": "def service_url_for_direct_upload(expires_in: ActiveStorage.service_urls_expire_in)\n    service.url_for_direct_upload key, expires_in: expires_in, content_type: content_type, content_length: byte_size, checksum: checksum, custom_metadata: custom_metadata\n  end",
        "comment": "Returns a URL that can be used to directly upload a file for this blob on the service. This URL is intended to be short-lived for security and only generated on-demand by the client-side JavaScript responsible for doing the uploading.",
        "label": "Why",
        "id": "13614"
    },
    {
        "raw_code": "def self.batch_size\n      BATCH_SIZE\n    end",
        "comment": "allows easier stubbing in specs",
        "label": "Why",
        "id": "6382"
    },
    {
        "raw_code": "def cleanup\n        # dont run cleanup more than once per minute\n        return 0 unless redis { |conn| conn.set(\"process_cleanup\", \"1\", \"NX\", \"EX\", \"60\") }\n\n        count = 0\n        redis do |conn|\n          procs = conn.sscan(\"processes\").to_a\n          heartbeats = conn.pipelined { |pipeline|\n            procs.each do |key|\n              pipeline.hget(key, \"info\")\n            end",
        "comment": "A copy of Sidekiq::ProcessSet#cleanup because server should never depend on sidekiq/api.",
        "label": "Why",
        "id": "5172"
    },
    {
        "raw_code": "def real_column\n        column + 1\n      end",
        "comment": "@api private  Internally we use column number that start at 0, but when outputting column numbers, we want them to start at 1. One reason is that editors, such as Emacs, expect this.",
        "label": "Why",
        "id": "10244"
    },
    {
        "raw_code": "def specs_from_graphql_base_types\n        @specs_from_graphql_base_types ||= Tooling::Mappings::GraphqlBaseTypeMappings.new(changed_files).execute\n      end",
        "comment": "Add specs based on potential changes to the GraphQL base types  @return [void]",
        "label": "Why",
        "id": "8138"
    },
    {
        "raw_code": "def raise_on_type_mismatch!(record)\n          unless record.is_a?(reflection.klass)\n            fresh_class = reflection.class_name.safe_constantize\n            unless fresh_class && record.is_a?(fresh_class)\n              message = \"#{reflection.class_name}(##{reflection.klass.object_id}) expected, \"\\\n                \"got #{record.inspect} which is an instance of #{record.class}(##{record.class.object_id})\"\n              raise ActiveRecord::AssociationTypeMismatch, message\n            end",
        "comment": "Raises ActiveRecord::AssociationTypeMismatch unless +record+ is of the kind of the class of the associated objects. Meant to be used as a safety check when you are about to assign an associated record.",
        "label": "Why",
        "id": "12760"
    },
    {
        "raw_code": "def create_noop(reason: nil)\n          noop_yml = noop_pipeline_yml(reason || \"no-op run, nothing will be executed!\")\n\n          (FUNCTIONAL_E2E_PIPELINE_TYPES + NON_FUNCTIONAL_PIPELINE_TYPES).each do |type|\n            # omnibus pipeline trigger defined an input and if it isn't present in no-op pipeline, it will fail\n            # see trigger job definition 'e2e:test-on-omnibus-ee' in '.gitlab/ci/qa.gitlab-ci.yml'\n            yml = if type == :test_on_omnibus\n                    <<~YML\n                      spec:\n                        inputs:\n                          pipeline-type:\n                            type: string\n                            default: external\n                      ---\n                      #{noop_yml}\n                    YML\n                  else\n                    noop_yml\n                  end",
        "comment": "Create noop pipeline definitions for each supported pipeline type  @return [void]",
        "label": "Why",
        "id": "4771"
    },
    {
        "raw_code": "def has_named_route?(name)\n          @set.named_routes.key?(name)\n        end",
        "comment": "Query if the following named route was already defined.",
        "label": "Why",
        "id": "11562"
    },
    {
        "raw_code": "def subscribe(*)\n      nil\n    end",
        "comment": "We override graphql-ruby's default `subscribe` since it returns :no_response instead, which leads to empty hashes rendered out to the caller which has caused problems in the client.  Eventually, we should move to an approach where the caller receives a response here upon subscribing, but we don't need this currently because Vue components also perform an initial fetch query. See https://gitlab.com/gitlab-org/gitlab/-/issues/402614",
        "label": "Why",
        "id": "6165"
    },
    {
        "raw_code": "def retry_failed(current_user)\n      Ci::RetryPipelineService.new(project, current_user)\n        .execute(self)\n    end",
        "comment": "rubocop: disable CodeReuse/ServiceClass",
        "label": "Why",
        "id": "7558"
    },
    {
        "raw_code": "def filter_by_name(build_relation)\n      build_name_relation = Ci::BuildName\n        .where(project_id: project.id)\n        .pg_full_text_search_in_model(limited_name_search_terms)\n\n      build_relation.where(\"(id, partition_id) IN (?)\", build_name_relation.select(:build_id, :partition_id))\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord -- Need specialized queries for database optimizations",
        "label": "Why",
        "id": "8014"
    },
    {
        "raw_code": "def update_assignees_relation\n    if pending_assignees_population?\n      transaction do\n        merge_request_assignees.create!(user_id: deprecated_assignee_id, merge_request_id: id)\n        update_column(:assignee_id, nil)\n      end",
        "comment": "If there's an assignee_id and no relation, it means the background migration at #26496 didn't reach this merge request yet. This code should be removed in the clean-up phase of the background migration (#59457).",
        "label": "Why",
        "id": "7395"
    },
    {
        "raw_code": "def external_dependency_checksum\n          @external_dependency_checksum ||= checksum_filenames('{,ee/}spec/migrations/**/*_spec.rb')\n        end",
        "comment": "Used by RuboCop to invalidate its cache if specs change.",
        "label": "Why",
        "id": "3912"
    },
    {
        "raw_code": "def rename_enum_value(type_name, **options)\n        unless database_version >= 10_00_00 # >= 10.0\n          raise ArgumentError, \"Renaming enum values is only supported in PostgreSQL 10 or later\"\n        end",
        "comment": "Rename enum value on an existing enum type.",
        "label": "Why",
        "id": "12974"
    },
    {
        "raw_code": "def test_build_and_create_should_not_happen_within_scope\n    car = cars(:honda)\n    scope = car.foo_bulbs.where_values_hash\n\n    bulb = car.foo_bulbs.build\n    assert_not_equal scope, bulb.scope_after_initialize.where_values_hash\n\n    bulb = car.foo_bulbs.create\n    assert_not_equal scope, bulb.scope_after_initialize.where_values_hash\n\n    bulb = car.foo_bulbs.create!\n    assert_not_equal scope, bulb.scope_after_initialize.where_values_hash\n  end",
        "comment": "When creating objects on the association, we must not do it within a scope (even though it would be convenient), because this would cause that scope to be applied to any callbacks etc.",
        "label": "Why",
        "id": "13548"
    },
    {
        "raw_code": "def snippets_enabled=(value)\n    write_feature_attribute_boolean(:snippets_access_level, value)\n  end",
        "comment": "TODO: remove in API v5, replaced by *_access_level",
        "label": "Why",
        "id": "7309"
    },
    {
        "raw_code": "def usage_activity_by_stage_plan(time_period)\n        time_frame = metric_time_period(time_period)\n        {\n          issues: add_metric('CountUsersCreatingIssuesMetric', time_frame: time_frame),\n          notes: distinct_count(::Note.where(time_period), :author_id),\n          projects: distinct_count(::Project.where(time_period), :creator_id),\n          todos: distinct_count(::Todo.where(time_period), :author_id),\n          service_desk_enabled_projects: distinct_count_service_desk_enabled_projects(time_period),\n          service_desk_issues: count(::Issue.service_desk.where(time_period)),\n          projects_jira_active: distinct_count(::Project.with_active_integration(::Integrations::Jira).where(time_period), :creator_id),\n          projects_jira_dvcs_server_active: distinct_count(::Project.with_active_integration(::Integrations::Jira).with_jira_dvcs_server.where(time_period), :creator_id)\n        }\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord Omitted because no user, creator or author associated: `boards`, `labels`, `milestones`, `uploads` Omitted because too expensive: `epics_deepest_relationship_level` rubocop: disable CodeReuse/ActiveRecord",
        "label": "Why",
        "id": "1737"
    },
    {
        "raw_code": "def self.dangling_sources\n        sources.slice(\n          :webide,\n          :parent_pipeline,\n          :ondemand_dast_scan,\n          :ondemand_dast_validation,\n          :security_orchestration_policy,\n          :container_registry_push,\n          :duo_workflow,\n          :pipeline_execution_policy_schedule\n        )\n      end",
        "comment": "Dangling sources are those events that generate pipelines for which we don't want to directly affect the ref CI status. - when a webide pipeline fails it does not change the ref CI status to failed - when a child pipeline (from parent_pipeline source) fails it affects its parent pipeline. It's up to the parent to affect the ref CI status - when an ondemand_dast_scan pipeline runs it is for testing purpose and should not affect the ref CI status. - when an ondemand_dast_validation pipeline runs it is for validating a DAST site profile and should not affect the ref CI status. - when a container_registry_push pipeline runs it is for security testing purpose and should not affect the ref CI status.",
        "label": "Why",
        "id": "7430"
    },
    {
        "raw_code": "def transform(collection:, node:, user:)\n            raise NotImplementedError, \"#{name} must implement .transform\"\n          end",
        "comment": "@abstract Implement .transform in subclass to handle query transformation",
        "label": "Why",
        "id": "1145"
    },
    {
        "raw_code": "def too_late_for_very_large_table?\n          return false unless Gitlab.com_except_jh? # rubocop:disable Gitlab/AvoidGitlabInstanceChecks -- Not related to SaaS offerings\n\n          !Date.today.saturday?\n        end",
        "comment": "The reindexing process takes place during the weekends and starting a reindexing action on a large table late on Sunday could span during Monday. We don't want this because it prevents vacuum from running.",
        "label": "Why",
        "id": "3122"
    },
    {
        "raw_code": "def __subject__\n          @subject\n        end",
        "comment": "Presenters should always access the subject through an explicit getter defined with `presents ..., as:`, the `__subject__` method is only intended for internal use.",
        "label": "Why",
        "id": "1840"
    },
    {
        "raw_code": "def to_work_item_global_id\n    ::Gitlab::GlobalId.as_global_id(id, model_name: WorkItem.name)\n  end",
        "comment": "we want to have subscriptions working on work items only, legacy issues do not support graphql subscriptions, yet so we need sometimes GID of an issue instance to be represented as WorkItem GID. E.g. notes subscriptions.",
        "label": "Why",
        "id": "6817"
    },
    {
        "raw_code": "def T(*path)\n          Engine.template(*path)\n        end",
        "comment": "rubocop:disable Style/MethodName Alias for creating {Engine.template}.",
        "label": "Why",
        "id": "360"
    },
    {
        "raw_code": "def GET\n        if get_header(RACK_REQUEST_QUERY_STRING) == query_string\n          get_header(RACK_REQUEST_QUERY_HASH)\n        else\n          query_hash = parse_query(query_string, '&') # only allow ampersand here\n          set_header(RACK_REQUEST_QUERY_STRING, query_string)\n          set_header(RACK_REQUEST_QUERY_HASH, query_hash)\n        end",
        "comment": "rubocop: disable Naming/MethodName",
        "label": "Why",
        "id": "1270"
    },
    {
        "raw_code": "def set_open_transactions_baseline\n      @open_transactions_baseline = connection.open_transactions\n    end",
        "comment": "These methods that access @open_transactions_baseline are not thread-safe. These are fine though because we only call these in RSpec's main thread. If we decide to run specs multi-threaded, we would need to use something like ThreadGroup to keep track of this value",
        "label": "Why",
        "id": "7387"
    },
    {
        "raw_code": "def list_invalid_properties\n      invalid_properties = Array.new\n      invalid_properties\n    end",
        "comment": "Show invalid properties with the reasons. Usually used together with valid? @return Array for valid properties with the reasons",
        "label": "Why",
        "id": "936"
    },
    {
        "raw_code": "def normalize_for_sast_reports(reports, builds)\n      return reports unless reports.delete(:sast)\n\n      reports.tap do |r|\n        build_names = builds.map(&:name)\n\n        r.push(:sast_iac) if build_names.delete('kics-iac-sast')\n\n        # When using adavanced sast, sast should also show in the report names\n        r.push(:sast, :sast_advanced) if build_names.delete('gitlab-advanced-sast')\n\n        r.push(:sast) if build_names.any? { |name| name.include? '-sast' }\n      end.uniq\n    end",
        "comment": "Because :sast_iac and :sast_advanced reports belong to a report with a name of 'sast', we have to do extra checking to determine which reports have been included",
        "label": "Why",
        "id": "7424"
    },
    {
        "raw_code": "def assign_time_frame\n      time_frame.single? ? time_frame.value.first : time_frame.value\n    end",
        "comment": "Maintain current functionality of string time_frame for backward compatibility TODO: Remove once we can deduplicate and merge metric files",
        "label": "Why",
        "id": "5307"
    },
    {
        "raw_code": "def restore_index_names\n    RENAMED_PARTITION_INDEX_MAP.each do |renamed_index|\n      next unless index_name_exists?(TABLE_NAME, renamed_index[:old_name])\n\n      rename_index(TABLE_NAME, renamed_index[:old_name], renamed_index[:new_name])\n    end",
        "comment": "PostgreSQL is generating different names than what we already have when we create a partition. So we have to rename these indexes to restore original names for previous migrations that depends on the names.",
        "label": "Why",
        "id": "4846"
    },
    {
        "raw_code": "def merge_request_build_failed(merge_request)\n    merge_request.merge_participants.each do |user|\n      create_build_failed_todo(merge_request, user)\n    end",
        "comment": "When a build fails on the HEAD of a merge request we should:  * create a todo for each merge participant ",
        "label": "Why",
        "id": "5439"
    },
    {
        "raw_code": "def update_merge_request(merge_request, current_user, skip_users = [])\n    update_issuable(merge_request, current_user, skip_users)\n  end",
        "comment": "When update a merge request we should:  * create a todo for each mentioned user on merge request ",
        "label": "Why",
        "id": "5436"
    },
    {
        "raw_code": "def self.base_name # :doc:\n          @base_name ||= if base = name.to_s.split(\"::\").first\n            base.underscore\n          end",
        "comment": "Sets the base_name taking into account the current class namespace.",
        "label": "Why",
        "id": "14770"
    },
    {
        "raw_code": "def stringify_keys # :nodoc:\n      dup\n    end",
        "comment": "This is required by ActiveModel attribute assignment, so that user can pass `Parameters` to a mass assignment methods in a model. It should not matter as we are using `HashWithIndifferentAccess` internally.",
        "label": "Why",
        "id": "11395"
    },
    {
        "raw_code": "def execute\n      return [] if branch_names.blank?\n\n      source_branches = project.source_of_merge_requests.open_and_closed\n        .from_source_branches(branch_names).pluck(:source_branch)\n\n      target_branches = project.merge_requests.opened\n        .by_target_branch(branch_names).distinct.pluck(:target_branch)\n\n      source_branches.concat(target_branches).to_set\n    end",
        "comment": "Skip moving this logic into models since it's too specific rubocop: disable CodeReuse/ActiveRecord",
        "label": "Why",
        "id": "5564"
    },
    {
        "raw_code": "def settings_value(target)\n      case target\n      when 'puma' then ::Settings.monitoring.web_exporter\n      when 'sidekiq' then ::Settings.monitoring.sidekiq_exporter\n      else ensure_valid_target!(target)\n      end",
        "comment": "We need to use `.` (dot) notation to access the updates we did in `config/initializers/1_settings.rb` For that reason, avoid using `[]` (\"optional/dynamic settings notation\") to resolve it dynamically. Refer to https://gitlab.com/gitlab-org/gitlab/-/issues/386865",
        "label": "Why",
        "id": "8086"
    },
    {
        "raw_code": "def improved_delete_batched_background_migration(job_class_name, table_name, column_name, job_arguments)\n    Gitlab::Database::QueryAnalyzers::RestrictAllowedSchemas.require_dml_mode!\n\n    Gitlab::Database::BackgroundMigration::BatchedMigration.reset_column_information\n\n    batched_migration = Gitlab::Database::BackgroundMigration::BatchedMigration\n      .for_configuration(\n        gitlab_schema_from_context, job_class_name, table_name, column_name, job_arguments,\n        include_compatible: true\n      ).take\n\n    return unless batched_migration\n\n    batched_migration.batched_jobs.each_batch(of: 100) { |b| b.delete_all }\n\n    batched_migration.delete\n  end",
        "comment": "For context on why `delete_batched_background_migration` is overloaded: https://gitlab.com/gitlab-org/gitlab/-/issues/434089#note_2696645957",
        "label": "Why",
        "id": "4881"
    },
    {
        "raw_code": "def read_attribute_for_validation(key)\n          return file_url if key == :file_url\n\n          params[key]\n        end",
        "comment": "Make the validated params/methods accessible",
        "label": "Why",
        "id": "6099"
    },
    {
        "raw_code": "def rename_enum_value(...) # :nodoc:\n      end",
        "comment": "This is meant to be implemented by the adapters that support custom enum types",
        "label": "Why",
        "id": "12915"
    },
    {
        "raw_code": "def unregister(plugin)\n          if @registered.include?(plugin)\n            @logger.info(\"Unregistered: #{plugin.name}\")\n            @registered.delete(plugin)\n          end",
        "comment": "This unregisters a plugin so that its components will no longer be used. Note that this should only be used for testing purposes.",
        "label": "Why",
        "id": "9084"
    },
    {
        "raw_code": "def to_lsp_diagnostic(config)\n        highlighted = @offense.highlighted_area\n\n        LanguageServer::Protocol::Interface::Diagnostic.new(\n          message: message,\n          source: 'RuboCop',\n          code: @offense.cop_name,\n          code_description: code_description(config),\n          severity: severity,\n          range: LanguageServer::Protocol::Interface::Range.new(\n            start: LanguageServer::Protocol::Interface::Position.new(\n              line: @offense.line - 1,\n              character: to_position_character(highlighted.begin_pos)\n            ),\n            end: LanguageServer::Protocol::Interface::Position.new(\n              line: @offense.line - 1,\n              character: to_position_character(highlighted.end_pos)\n            )\n          ),\n          data: {\n            correctable: correctable?,\n            code_actions: to_lsp_code_actions\n          }\n        )\n      end",
        "comment": "rubocop:disable Metrics/AbcSize, Metrics/MethodLength",
        "label": "Why",
        "id": "10200"
    },
    {
        "raw_code": "def where(*args)\n      if args.empty?\n        WhereChain.new(spawn)\n      elsif args.length == 1 && args.first.blank?\n        self\n      else\n        spawn.where!(*args)\n      end",
        "comment": "Returns a new relation, which is the result of filtering the current relation according to the conditions in the arguments.  #where accepts conditions in one of several formats. In the examples below, the resulting SQL is given as an illustration; the actual query generated may be different depending on the database adapter.  === \\String  A single string, without additional arguments, is passed to the query constructor as an SQL fragment, and used in the where clause of the query.  Client.where(\"orders_count = '2'\") # SELECT * from clients where orders_count = '2';  Note that building your own string from user input may expose your application to injection attacks if not done properly. As an alternative, it is recommended to use one of the following methods.  === \\Array  If an array is passed, then the first element of the array is treated as a template, and the remaining elements are inserted into the template to generate the condition. Active Record takes care of building the query to avoid injection attacks, and will convert from the ruby type to the database type where needed. Elements are inserted into the string in the order in which they appear.  User.where([\"name = ? and email = ?\", \"Joe\", \"joe@example.com\"]) # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';  Alternatively, you can use named placeholders in the template, and pass a hash as the second element of the array. The names in the template are replaced with the corresponding values from the hash.  User.where([\"name = :name and email = :email\", { name: \"Joe\", email: \"joe@example.com\" }]) # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';  This can make for more readable code in complex queries.  Lastly, you can use sprintf-style % escapes in the template. This works slightly differently than the previous methods; you are responsible for ensuring that the values in the template are properly quoted. The values are passed to the connector for quoting, but the caller is responsible for ensuring they are enclosed in quotes in the resulting SQL. After quoting, the values are inserted using the same escapes as the Ruby core method +Kernel::sprintf+.  User.where([\"name = '%s' and email = '%s'\", \"Joe\", \"joe@example.com\"]) # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';  If #where is called with multiple arguments, these are treated as if they were passed as the elements of a single array.  User.where(\"name = :name and email = :email\", { name: \"Joe\", email: \"joe@example.com\" }) # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';  When using strings to specify conditions, you can use any operator available from the database. While this provides the most flexibility, you can also unintentionally introduce dependencies on the underlying database. If your code is intended for general consumption, test with multiple database backends.  === \\Hash  #where will also accept a hash condition, in which the keys are fields and the values are values to be searched for.  Fields can be symbols or strings. Values can be single values, arrays, or ranges.  User.where(name: \"Joe\", email: \"joe@example.com\") # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com'  User.where(name: [\"Alice\", \"Bob\"]) # SELECT * FROM users WHERE name IN ('Alice', 'Bob')  User.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight) # SELECT * FROM users WHERE (created_at BETWEEN '2012-06-09 07:00:00.000000' AND '2012-06-10 07:00:00.000000')  In the case of a belongs_to relationship, an association key can be used to specify the model if an ActiveRecord object is used as the value.  author = Author.find(1)  # The following queries will be equivalent: Post.where(author: author) Post.where(author_id: author)  This also works with polymorphic belongs_to relationships:  treasure = Treasure.create(name: 'gold coins') treasure.price_estimates << PriceEstimate.create(price: 125)  # The following queries will be equivalent: PriceEstimate.where(estimate_of: treasure) PriceEstimate.where(estimate_of_type: 'Treasure', estimate_of_id: treasure)  Hash conditions may also be specified in a tuple-like syntax. Hash keys may be an array of columns with an array of tuples as values.  Article.where([:author_id, :id] => [[15, 1], [15, 2]]) # SELECT * FROM articles WHERE author_id = 15 AND id = 1 OR author_id = 15 AND id = 2  === Joins  If the relation is the result of a join, you may create a condition which uses any of the tables in the join. For string and array conditions, use the table name in the condition.  User.joins(:posts).where(\"posts.created_at < ?\", Time.now)  For hash conditions, you can either use the table name in the key, or use a sub-hash.  User.joins(:posts).where(\"posts.published\" => true) User.joins(:posts).where(posts: { published: true })  === No Argument  If no argument is passed, #where returns a new instance of WhereChain, that can be chained with WhereChain#not, WhereChain#missing, or WhereChain#associated.  Chaining with WhereChain#not:  User.where.not(name: \"Jon\") # SELECT * FROM users WHERE name != 'Jon'  Chaining with WhereChain#associated:  Post.where.associated(:author) # SELECT \"posts\".* FROM \"posts\" # INNER JOIN \"authors\" ON \"authors\".\"id\" = \"posts\".\"author_id\" # WHERE \"authors\".\"id\" IS NOT NULL  Chaining with WhereChain#missing:  Post.where.missing(:author) # SELECT \"posts\".* FROM \"posts\" # LEFT OUTER JOIN \"authors\" ON \"authors\".\"id\" = \"posts\".\"author_id\" # WHERE \"authors\".\"id\" IS NULL  === Blank Condition  If the condition is any blank-ish object, then #where is a no-op and returns the current relation.",
        "label": "Why",
        "id": "13412"
    },
    {
        "raw_code": "def build_subselect(key, o)\n          stmt             = Nodes::SelectStatement.new\n          core             = stmt.cores.first\n          core.froms       = o.relation\n          core.wheres      = o.wheres\n          core.projections = [key]\n          core.groups      = o.groups unless o.groups.empty?\n          core.havings     = o.havings unless o.havings.empty?\n          stmt.limit       = o.limit\n          stmt.offset      = o.offset\n          stmt.orders      = o.orders\n          stmt\n        end",
        "comment": "FIXME: we should probably have a 2-pass visitor for this",
        "label": "Why",
        "id": "13487"
    },
    {
        "raw_code": "def use_replicas_for_read_queries\n          previous_flag = @use_replicas_for_read_queries\n          @use_replicas_for_read_queries = true\n          yield\n        ensure\n          @use_replicas_for_read_queries = previous_flag\n        end",
        "comment": "Indicates that the read SQL statements from anywhere inside this blocks should use a replica, regardless of the current primary stickiness or whether a write query is already performed in the current session. This interface is reserved mostly for performance purpose. This is a good tool to push expensive queries, which can tolerate the replica lags, to the replicas.  Write and ambiguous queries inside this block are still handled by the primary.",
        "label": "Why",
        "id": "3084"
    },
    {
        "raw_code": "def respond_to_missing?(sym, include_priv)\n      time.respond_to?(sym, include_priv)\n    end",
        "comment": "Ensure proxy class responds to all methods that underlying time instance responds to.",
        "label": "Why",
        "id": "13997"
    },
    {
        "raw_code": "def fix_basic_object_inheritance\n    basic = classes_hash['BasicObject']\n    return unless basic\n    basic.superclass = nil\n  end",
        "comment": " Fixes the erroneous <tt>BasicObject < Object</tt> in 1.9.  Because we assumed all classes without a stated superclass inherit from Object, we have the above wrong inheritance.  We fix BasicObject right away if we are running in a Ruby version >= 1.9.",
        "label": "Why",
        "id": "15869"
    },
    {
        "raw_code": "def code\n    path\n  end",
        "comment": "For compatibility with old code",
        "label": "Why",
        "id": "6745"
    },
    {
        "raw_code": "def update_diff_discussion_positions(old_diff_refs:, new_diff_refs:, current_user: nil)\n    return unless has_complete_diff_refs?\n    return if new_diff_refs == old_diff_refs\n\n    active_diff_discussions = self.notes.new_diff_notes.discussions.select do |discussion|\n      discussion.active?(old_diff_refs)\n    end",
        "comment": "rubocop: disable CodeReuse/ServiceClass",
        "label": "Why",
        "id": "6995"
    },
    {
        "raw_code": "def drop_schema(schema_name, **options)\n          execute \"DROP SCHEMA#{' IF EXISTS' if options[:if_exists]} #{quote_schema_name(schema_name)} CASCADE\"\n        end",
        "comment": "Drops the schema for the given schema name.",
        "label": "Why",
        "id": "13248"
    },
    {
        "raw_code": "def name\n            @name ||= adapter.name\n          end",
        "comment": "Sequence should include the schema, as the same name could be used across different schemas  @example public.sequence_name",
        "label": "Why",
        "id": "1177"
    },
    {
        "raw_code": "def reference_pattern(*)\n      @reference_pattern ||= jira_issue_match_regex\n    end",
        "comment": "{PROJECT-KEY}-{NUMBER} Examples: JIRA-1, PROJECT-1",
        "label": "Why",
        "id": "7640"
    },
    {
        "raw_code": "def test_to_param\n        assert_respond_to model, :to_param\n        def_method(model, :to_key) { [1] }\n        def_method(model, :persisted?) { false }\n        assert model.to_param.nil?, \"to_param should return nil when `persisted?` returns false\"\n      end",
        "comment": "Passes if the object's model responds to <tt>to_param</tt> and if calling this method returns +nil+ when the object is not persisted. Fails otherwise.  <tt>to_param</tt> is used to represent the object's key in URLs. Implementers can decide to either raise an exception or provide a default in case the record uses a composite primary key. There are no tests for this behavior in lint because it doesn't make sense to force any of the possible implementation strategies on the implementer.",
        "label": "Why",
        "id": "12242"
    },
    {
        "raw_code": "def highlight_map(*)\n      {}\n    end",
        "comment": "highlighting is only performed by Elasticsearch backed results",
        "label": "Why",
        "id": "1590"
    },
    {
        "raw_code": "def default(type: :search)\n      render(::Layouts::EmptyResultComponent.new(\n        type: type\n      ))\n    end",
        "comment": "@param type select {{ Layouts::EmptyResultComponent::TYPE_OPTIONS }}",
        "label": "Why",
        "id": "8189"
    },
    {
        "raw_code": "def with_error_handling\n        response = yield\n\n        return response if response.success?\n\n        raise ::BulkImports::NetworkError.new(\"Unsuccessful response #{response.code} from #{response.request.path.path}. Body: #{response.parsed_response}\", response: response)\n      rescue *Gitlab::HTTP::HTTP_ERRORS => e\n        raise ::BulkImports::NetworkError, e\n      end",
        "comment": "@raise [BulkImports::NetworkError] when unsuccessful",
        "label": "Why",
        "id": "3610"
    },
    {
        "raw_code": "def stop_with_actions!\n    return unless available?\n\n    if stop_actions.any? || auto_stop_setting_always?\n      stop!\n    end",
        "comment": "TODO: move this method and dependencies into Environments::StopService",
        "label": "Why",
        "id": "7035"
    },
    {
        "raw_code": "def delete(index)\n        index = self.index(index) unless index.is_a?(Integer)\n        stack.delete_at(index)\n      end",
        "comment": "Deletes the given middleware object or index",
        "label": "Why",
        "id": "9307"
    },
    {
        "raw_code": "def find_by_id(container_id)\n      container_class.find_by_id(container_id)&.wiki\n    end",
        "comment": "This is needed to support repository lookup through Gitlab::GlRepository::Identifier",
        "label": "Why",
        "id": "6907"
    },
    {
        "raw_code": "def destroy_target(target)\n    todo_user_ids = target.todos.distinct_user_ids\n\n    yield target\n\n    Users::UpdateTodoCountCacheService.new(todo_user_ids).execute if todo_user_ids.present?\n  end",
        "comment": "When we destroy a todo target we should:  * refresh the todos count cache for all users with todos on the target  This needs to yield back to the caller to destroy the target, because it collects the todo users before the todos themselves are deleted, then updates the todo counts for those users. ",
        "label": "Why",
        "id": "5432"
    },
    {
        "raw_code": "def unused\n          payload.dig(:mocks, :unused)\n        end",
        "comment": "Fetch unused mock definitions  @return [Array]",
        "label": "Why",
        "id": "4352"
    },
    {
        "raw_code": "def enqueue_stats_job(request_id)\n        return unless Feature.enabled?(:performance_bar_stats, type: :ops)\n\n        cache_existed = @client.exists?(GitlabPerformanceBarStatsWorker::STATS_KEY)\n        @client.sadd?(GitlabPerformanceBarStatsWorker::STATS_KEY, request_id)\n\n        return if cache_existed\n\n        # stats key should be periodically processed and deleted by\n        # GitlabPerformanceBarStatsWorker but if it doesn't happen for\n        # some reason, we set expiration for the stats key to avoid\n        # keeping millions of request ids which would be already expired\n        # anyway\n        @client.expire(\n          GitlabPerformanceBarStatsWorker::STATS_KEY,\n          GitlabPerformanceBarStatsWorker::STATS_KEY_EXPIRE\n        )\n      end",
        "comment": "schedules a job which parses peek profile data and adds them to a structured log rubocop:disable Gitlab/ModuleWithInstanceVariables rubocop:disable CodeReuse/ActiveRecord -- needed because of `.exists?` method usage (which is actually not AR method)",
        "label": "Why",
        "id": "2679"
    },
    {
        "raw_code": "def has_root_container_repository_tags?\n    return false unless Gitlab.config.registry.enabled\n\n    ContainerRepository.build_root_repository(self).has_tags?\n  end",
        "comment": " This method is here because of support for legacy container repository which has exactly the same path like project does, but which might not be persisted in `container_repositories` table. ",
        "label": "Why",
        "id": "6780"
    },
    {
        "raw_code": "def unlocked_save\n      @index_file.open(\"w\") do |f|\n        f.write(JSON.dump({\n          \"version\"  => 1,\n          \"machines\" => @machines,\n        }))\n      end",
        "comment": "Saves the index.",
        "label": "Why",
        "id": "8765"
    },
    {
        "raw_code": "def initialize(xml, disallowed_types = nil)\n      return unless xml.present?\n\n      if xml.size > MAX_XML_SIZE\n        raise ArgumentError, format(_(\"The XML file must be less than %{max_size} MB.\"),\n          max_size: MAX_XML_SIZE / 1.megabyte)\n      end",
        "comment": "Override the default Nokogiri parser in to allow parsing huge XML files",
        "label": "Why",
        "id": "1750"
    },
    {
        "raw_code": "def self.disconnect_all!\n    ConnectionAdapters::PoolConfig.disconnect_all!\n  end",
        "comment": "Explicitly closes all database connections in all pools.",
        "label": "Why",
        "id": "12342"
    },
    {
        "raw_code": "def merge_target_lists(persisted, memory)\n          return persisted if memory.empty?\n\n          persisted.map! do |record|\n            if mem_record = memory.delete(record)\n\n              ((record.attribute_names & mem_record.attribute_names) - mem_record.changed_attribute_names_to_save - mem_record.class._attr_readonly).each do |name|\n                mem_record._write_attribute(name, record[name])\n              end",
        "comment": "We have some records loaded from the database (persisted) and some that are in-memory (memory). The same record may be represented in the persisted array and in the memory array.  So the task of this method is to merge them according to the following rules:  * The final array must not have duplicates * The order of the persisted array is to be preserved * Any changes made to attributes on objects in the memory array are to be preserved * Otherwise, attributes should have the value found in the database",
        "label": "Why",
        "id": "12778"
    },
    {
        "raw_code": "def self.primary_key\n    :id\n  end",
        "comment": "Needed for reactive caching",
        "label": "Why",
        "id": "6790"
    },
    {
        "raw_code": "def destroy_orphaned_ci_job_artifacts!\n      orphaned_job_artifacts = ::Ci::JobArtifact.for_project(project)\n      return if orphaned_job_artifacts.none?\n\n      service = orphaned_job_artifacts.begin_fast_destroy\n      orphaned_job_artifacts.finalize_fast_destroy(service)\n\n      Gitlab::AppLogger.info(\n        class: self.class.name,\n        project_id: project.id,\n        message: 'Orphaned CI job artifacts deleted'\n      )\n    end",
        "comment": "This method will delete all orphaned CI Job artifacts for the project, which are job artifacts whose jobs do not exist anymore. The reason these artifacts might still exist is because of https://gitlab.com/gitlab-org/gitlab/-/issues/508672. TODO: remove this method after we have a working & valid FK.",
        "label": "Why",
        "id": "5916"
    },
    {
        "raw_code": "def validate_description_length?\n      return false unless description_changed?\n\n      previous_description = changes_to_save['description'].first\n      # previous_description will be nil for new records\n      return true if previous_description.blank?\n\n      previous_description.bytesize <= DESCRIPTION_LENGTH_MAX\n    end",
        "comment": "we will need to switch this validation off for record backfilling process to avoid breaking validations for some of existing records which were created before we introduced a length restriction",
        "label": "Why",
        "id": "7659"
    },
    {
        "raw_code": "def expectation_args\n              if operator.include?('truthy') || operator.include?('falsey') || operator.include?('empty')\n                operator\n              elsif operator == 'include' && expected.is_a?(Array)\n                [operator, *expected]\n              else\n                [operator, expected]\n              end",
        "comment": "Expectation args  @return [String, Array]",
        "label": "Why",
        "id": "4590"
    },
    {
        "raw_code": "def initialize(\n      title:, link:, active_routes:, item_id: nil, container_html_options: {}, sprite_icon: nil,\n      sprite_icon_html_options: {}, has_pill: false, pill_count_dynamic: false, pill_count: nil,\n      pill_count_field: nil, super_sidebar_parent: nil, avatar: nil, entity_id: nil\n    )\n      @title = title\n      @link = link\n      @active_routes = active_routes\n      @item_id = item_id\n      @container_html_options = { aria: { label: title } }.merge(container_html_options)\n      @sprite_icon = sprite_icon\n      @sprite_icon_html_options = sprite_icon_html_options\n      @avatar = avatar\n      @entity_id = entity_id\n      @has_pill = has_pill\n      @pill_count = pill_count\n      @pill_count_field = pill_count_field\n      @pill_count_dynamic = pill_count_dynamic\n      @super_sidebar_parent = super_sidebar_parent\n    end",
        "comment": "rubocop: disable Metrics/ParameterLists",
        "label": "Why",
        "id": "3684"
    },
    {
        "raw_code": "def default_paths?\n        paths == Runner::DEFAULT_TEST_PATH_ARGS\n      end",
        "comment": "Specific spec paths are default paths containing all specs  @return [Boolean]",
        "label": "Why",
        "id": "4360"
    },
    {
        "raw_code": "def manage_ghes_username\n        ENV.fetch('OCTOKIT_MANAGE_GHES_USERNAME', nil)\n      end",
        "comment": "Default GHES Manage API username from ENV @return [String]",
        "label": "Why",
        "id": "14885"
    },
    {
        "raw_code": "def reload_diff(current_user = nil)\n    return unless open?\n\n    MergeRequests::ReloadDiffsService.new(self, current_user).execute\n  end",
        "comment": "rubocop: disable CodeReuse/ServiceClass",
        "label": "Why",
        "id": "6974"
    },
    {
        "raw_code": "def reject_unauthorized_connection\n        logger.error \"An unauthorized connection attempt was rejected\"\n        raise UnauthorizedError\n      end",
        "comment": "Closes the WebSocket connection if it is open and returns an \"unauthorized\" reason.",
        "label": "Why",
        "id": "11067"
    },
    {
        "raw_code": "def delete(record)\n        Gitlab::Cache::Import::Caching.del(events_cache_key(record))\n      end",
        "comment": "Deletes the cache  @param record [ActiveRecord::Model] Model that responds to :iid",
        "label": "Why",
        "id": "2141"
    },
    {
        "raw_code": "def available_features_for_issue_types\n      {\n        assignee: %w[issue incident],\n        confidentiality: %w[issue incident objective key_result task],\n        time_tracking: %w[issue incident],\n        move_and_clone: %w[issue incident]\n      }.with_indifferent_access\n    end",
        "comment": "EE only features are listed on EE::IssueAvailableFeatures",
        "label": "Why",
        "id": "7323"
    },
    {
        "raw_code": "def direct(name, options = {}, &block)\n          unless @scope.root?\n            raise RuntimeError, \"The direct method can't be used inside a routes scope block\"\n          end",
        "comment": "Define custom URL helpers that will be added to the application's routes. This allows you to override and/or replace the default behavior of routing helpers, e.g:  direct :homepage do \"https://rubyonrails.org\" end  direct :commentable do |model| [ model, anchor: model.dom_id ] end  direct :main do { controller: \"pages\", action: \"index\", subdomain: \"www\" } end  The return value from the block passed to `direct` must be a valid set of arguments for `url_for` which will actually build the URL string. This can be one of the following:  *   A string, which is treated as a generated URL *   A hash, e.g. `{ controller: \"pages\", action: \"index\" }` *   An array, which is passed to `polymorphic_url` *   An Active Model instance *   An Active Model class   NOTE: Other URL helpers can be called in the block but be careful not to invoke your custom URL helper again otherwise it will result in a stack overflow error.  You can also specify default options that will be passed through to your URL helper definition, e.g:  direct :browse, page: 1, size: 10 do |options| [ :products, options.merge(params.permit(:page, :size).to_h.symbolize_keys) ] end  In this instance the `params` object comes from the context in which the block is executed, e.g. generating a URL inside a controller action or a view. If the block is executed where there isn't a `params` object such as this:  Rails.application.routes.url_helpers.browse_path  then it will raise a `NameError`. Because of this you need to be aware of the context in which you will use your custom URL helper when defining it.  NOTE: The `direct` method can't be used inside of a scope block such as `namespace` or `scope` and will raise an error if it detects that it is.",
        "label": "Why",
        "id": "11586"
    },
    {
        "raw_code": "def by_approvals(items)\n    MergeRequests::ByApprovalsFinder\n      .new(params[:approved_by_usernames], params[:approved_by_ids])\n      .execute(items)\n  end",
        "comment": "Filter by merge requests that had been approved by specific users rubocop: disable CodeReuse/Finder",
        "label": "Why",
        "id": "7886"
    },
    {
        "raw_code": "def render_error\n      if too_large?\n        :too_large\n      elsif collapsed?\n        :collapsed\n      end",
        "comment": "This method is used on the server side to check whether we can attempt to render the blob at all. Human-readable error messages are found in the `BlobHelper#blob_render_error_reason` helper.  This method does not and should not load the entire blob contents into memory, and should not be overridden to do so in order to validate the format of the blob.  Prefer to implement a client-side viewer, where the JS component loads the binary from `blob_raw_path` and does its own format validation and error rendering, especially for potentially large binary formats.",
        "label": "Why",
        "id": "7635"
    },
    {
        "raw_code": "def self.has_any_job_definition?\n      left_joins(:job_definition_instance).limit(1).pick(:job_id).present?\n    end",
        "comment": "TODO: remove this method with FF `read_from_new_ci_destinations`",
        "label": "Why",
        "id": "7533"
    },
    {
        "raw_code": "def print_list\n        Registry.load_all\n        run_verifier(Registry.all).\n          sort_by {|item| [item.file || '', item.line || 0] }.each do |item|\n          log.puts \"#{item.file}:#{item.line}: #{item.path}\"\n        end",
        "comment": "Prints a list of all objects @return [void] @since 0.5.5",
        "label": "Why",
        "id": "533"
    },
    {
        "raw_code": "def from_periods(periods)\n          process_duration(process_periods(periods))\n        end",
        "comment": "periods should be sorted by `first`",
        "label": "Why",
        "id": "2504"
    },
    {
        "raw_code": "def post(session, path, options = {})\n      json_response session.post(path, options)\n    end",
        "comment": "Should be used in a session manually",
        "label": "Why",
        "id": "3513"
    },
    {
        "raw_code": "def authorize_create_snippet!\n    render_404 unless can?(current_user, :create_snippet, project)\n  end",
        "comment": "This overrides the default snippet create authorization because ProjectSnippets are checked against the project rather than the user",
        "label": "Why",
        "id": "6642"
    },
    {
        "raw_code": "def load_solution_file(opts={})\n      return if !opts[:local] && !opts[:global]\n      return if opts[:local] && opts[:global]\n      return if opts[:local] && environment_data_path.nil?\n      solution_path = (environment_data_path || Vagrant.user_data_path) + \"bundler\"\n      solution_path += opts[:local] ? \"local.sol\" : \"global.sol\"\n      SolutionFile.new(\n        plugin_file: opts[:local] || opts[:global],\n        solution_file: solution_path\n      )\n    end",
        "comment": "Use the given options to create a solution file instance for use during initialization. When a Vagrant environment is in use, solution files will be stored within the environment's data directory. This is because the solution for loading global plugins is dependent on any solution generated for local plugins. When no Vagrant environment is in use (running Vagrant without a Vagrantfile), the Vagrant user data path will be used for solution storage since only the global plugins will be used.  @param [Hash] opts Options passed to #init! @return [SolutionFile]",
        "label": "Why",
        "id": "8896"
    },
    {
        "raw_code": "def test_key_transformation_max_filename_size\n    key = \"#{'A' * ActiveSupport::Cache::FileStore::FILENAME_MAX_SIZE}B\"\n    path = @cache.send(:normalize_key, key, {})\n    assert path.split(\"/\").all? { |dir_name| dir_name.size <= ActiveSupport::Cache::FileStore::FILENAME_MAX_SIZE }\n    assert_equal \"B\", File.basename(path)\n  end",
        "comment": "Because file systems have a maximum filename size, filenames > max size should be split in to directories If filename is 'AAAAB', where max size is 4, the returned path should be AAAA/B",
        "label": "Why",
        "id": "14606"
    },
    {
        "raw_code": "def ssh_key_expires_field_description\n    s_('Profiles|Optional but recommended. If set, key becomes invalid on the specified date.')\n  end",
        "comment": "Overridden in EE::ProfilesHelper#ssh_key_expires_field_description",
        "label": "Why",
        "id": "7806"
    },
    {
        "raw_code": "def test_has_many_through_has_and_belongs_to_many_with_has_many_source_reflection\n    greetings, more = comments(:greetings), comments(:more_greetings)\n\n    assert_equal [greetings, more], categories(:technology).post_comments.order(\"comments.id\")\n  end",
        "comment": "has_many through Source: has_many Through: has_and_belongs_to_many",
        "label": "Why",
        "id": "13558"
    },
    {
        "raw_code": "def avatar_url(size: nil, scale: 2, **args)\n    GravatarService.new.execute(email, size, scale, username: username)\n  end",
        "comment": "rubocop: disable CodeReuse/ServiceClass",
        "label": "Why",
        "id": "7084"
    },
    {
        "raw_code": "def storage\n        store.store\n      end",
        "comment": "Access to the backing storage of the request store. This returns an object with `[]` and `[]=` methods that does not discard values.  This can be useful if storage is needed for a delimited purpose, and the forgetful nature of the null store is undesirable.",
        "label": "Why",
        "id": "1242"
    },
    {
        "raw_code": "def permitted_standalone_query_params\n      params.permit(:query, :operationName, :remove_deprecated, :group, :project, variables: {})\n    end",
        "comment": "Overrides GraphqlController#permitted_params to permit project and group params",
        "label": "Why",
        "id": "6485"
    },
    {
        "raw_code": "def remove_columns(table_name, *column_names, type: nil, **options)\n        if column_names.empty?\n          raise ArgumentError.new(\"You must specify at least one column name. Example: remove_columns(:people, :first_name)\")\n        end",
        "comment": "Removes the given columns from the table definition.  remove_columns(:suppliers, :qualification, :experience)  +type+ and other column options can be passed to make migration reversible.  remove_columns(:suppliers, :qualification, :experience, type: :string, null: false)",
        "label": "Why",
        "id": "13149"
    },
    {
        "raw_code": "def required?\n        !spec.key?(:default)\n      end",
        "comment": "An input specification without a default value is required. For example: ```yaml spec: inputs: website: ```",
        "label": "Why",
        "id": "3577"
    },
    {
        "raw_code": "def request_code(delivery_method)\n        @env.ui.warn(\"Requesting 2FA code via #{delivery_method.upcase}...\")\n\n        Vagrant::Util::CredentialScrubber.sensitive(password)\n        with_error_handling do\n          r = client.authentication_request_2fa_code(\n            username: username_or_email, password: password, delivery_method: delivery_method)\n\n          two_factor = r[:two_factor]\n          obfuscated_destination = two_factor[:obfuscated_destination]\n\n          @env.ui.success(\"2FA code sent to #{obfuscated_destination}.\")\n        end",
        "comment": "Requests a 2FA code @param [String] delivery_method",
        "label": "Why",
        "id": "9778"
    },
    {
        "raw_code": "def up\n    add_column :p_ci_builds, :scoped_user_id, :bigint, if_not_exists: true\n    add_column :p_ci_builds, :timeout, :integer, if_not_exists: true\n    add_column :p_ci_builds, :timeout_source, :integer, limit: 2, if_not_exists: true\n    add_column :p_ci_builds, :exit_code, :integer, limit: 2, if_not_exists: true\n    add_column :p_ci_builds, :debug_trace_enabled, :boolean, if_not_exists: true\n  end",
        "comment": "rubocop:disable Migration/PreventAddingColumns -- adding them to new table will add overhead",
        "label": "Why",
        "id": "4997"
    },
    {
        "raw_code": "def self.with_cross_database_modification_prevented(&blk)\n          self.with_suppressed(false, &blk)\n        end",
        "comment": "This method will prevent cross database modifications within the block if it was allowed previously",
        "label": "Why",
        "id": "3181"
    },
    {
        "raw_code": "def max_retries\n        MAX_RETRIES + (@invalid_signature_error && @invalid_path_error ? 1 : 0)\n      end",
        "comment": "In the case where the snippet file_name is invalid and also the snippet author has invalid commit info, we need to increase the number of retries by 1, because we will receive two errors from Gitaly and, in the third one, we will commit successfully.",
        "label": "Why",
        "id": "3286"
    },
    {
        "raw_code": "def new_email_address_added(user, email)\n    return unless user.can?(:receive_notifications)\n\n    mailer.new_email_address_added_email(user, email).deliver_later\n  end",
        "comment": "Notify a user when a new email address is added to the their account",
        "label": "Why",
        "id": "5465"
    },
    {
        "raw_code": "def find_catalog_component(component_name)\n        # Multiple versions of a project can have the same sha, so we return the latest one.\n        version = project.catalog_resource_versions.by_sha(sha).latest\n        return unless version\n\n        version.components.template.find_by_name(component_name)\n      end",
        "comment": "TODO: This may retrieve the wrong component object if a simple and a complex component have the same name for the given catalog resource version. We should complete https://gitlab.com/gitlab-org/gitlab/-/issues/450737 to ensure unique component names.",
        "label": "Why",
        "id": "7592"
    },
    {
        "raw_code": "def delete_resources( # rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity -- TODO: Break up this method\n        resources_hash,\n        delayed_verification = false,\n        permanent = @permanently_delete,\n        skip_verification = false)\n        unverified_deletions = []\n        results = []\n\n        resources_hash.each do |(key, value)|\n          type = key.split('::').last.downcase\n\n          value.each do |resource_hash|\n            next if resource_not_found?(resource_hash['api_path'])\n\n            resource = get_resource(resource_hash['api_path'])\n            next unless resource\n\n            resource_info = resource_info(resource_hash, key)\n            logger.info(\"Processing #{resource_info}...\")\n\n            resource[:api_path] = resource_hash['api_path']\n            resource[:type] = type\n\n            # When deleting immediately, only skip resources whose parents are already marked for deletion\n            next if permanent && group_or_project?(resource) && parent_marked_for_deletion?(resource)\n            # When soft-deleting, skip resources already marked for deletion either by parent or self\n            next if !permanent && group_or_project?(resource) && already_marked_for_deletion?(resource)\n            # Skip sandboxes already marked for deletion as these cannot be immediately deleted\n            next if resource[:type] == 'sandbox' && self_deletion_scheduled?(resource)\n\n            result = if personal_resource?(key)\n                       delete_personal_resource(resource, delayed_verification, permanent, skip_verification)\n                     elsif type == 'user'\n                       delete_resource(resource, true, permanent, skip_verification)\n                     elsif permanent && group_or_project?(resource) && self_deletion_scheduled?(resource)\n                       delete_permanently(resource)\n                     else\n                       delete_resource(resource, delayed_verification, permanent, skip_verification)\n                     end",
        "comment": "Deletes resources from a structured hash organized by resource type  @param [Hash<String, Array<Hash>>] resources_hash Hash where keys are resource class names @param [Boolean] delayed_verification Wait until the end of the script to verify deletions. Defaults to false @param [Boolean] permanent Permanently delete resources instead of marking for deletion. Defaults to true @param [Boolean] skip_verification Skip verification of deletion for time constraint purposes. Defaults to false @return [Array<Array<String, Hash>>] Array of deletion results",
        "label": "Why",
        "id": "4666"
    },
    {
        "raw_code": "def validate_published_by_is_release_author\n          return if published_by == release.author\n\n          errors.add(:published_by, 'must be the same as the release author')\n        end",
        "comment": "We require the published_by to be the same as the release author because creating a release and publishing a version must be done in a single session via CLI tools.",
        "label": "Why",
        "id": "7598"
    },
    {
        "raw_code": "def to_hash(hash = {})\n        node_hash = {}\n\n        # Insert node hash into parent hash correctly.\n        case hash[name]\n        when Array then hash[name] << node_hash\n        when Hash  then hash[name] = [hash[name], node_hash]\n        when nil   then hash[name] = node_hash\n        end",
        "comment": "Convert XML document to hash.  hash:: Hash to merge the converted element into.",
        "label": "Why",
        "id": "14589"
    },
    {
        "raw_code": "def self.build(obj)\n      case obj\n      when Hash\n        new(obj.transform_values { |value| build(value) })\n      when Array\n        obj.map { |value| build(value) }\n      else\n        obj\n      end",
        "comment": "Recursively build GitlabSettings::Options",
        "label": "Why",
        "id": "3519"
    },
    {
        "raw_code": "def set_status(new_status)\n      retry_optimistic_lock(self, name: 'ci_stage_set_status') do\n        case new_status\n        when 'created' then nil\n        when 'waiting_for_resource' then request_resource\n        when 'preparing' then prepare\n        when 'waiting_for_callback' then wait_for_callback\n        when 'pending' then enqueue\n        when 'running' then run\n        when 'success' then succeed\n        when 'failed' then drop\n        when 'canceling' then start_cancel\n        when 'canceled' then cancel\n        when 'manual' then block\n        when 'scheduled' then delay\n        when 'skipped', nil then skip\n        else\n          raise Ci::HasStatus::UnknownStatusError, \"Unknown status `#{new_status}`\"\n        end",
        "comment": "rubocop: disable Metrics/CyclomaticComplexity -- breaking apart hurts readability, consider refactoring issue #439268",
        "label": "Why",
        "id": "7519"
    },
    {
        "raw_code": "def restore_removed_locked_labels(new_label_ids)\n        return new_label_ids unless issuable.supports_lock_on_merge?\n        return new_label_ids unless issuable.label_ids.present?\n\n        removed_label_ids = issuable.label_ids - new_label_ids\n        removed_locked_label_ids = available_labels_service.filter_locked_label_ids(removed_label_ids)\n\n        new_label_ids + removed_locked_label_ids\n      end",
        "comment": "Restore any locked labels that the user is attempting to remove",
        "label": "Why",
        "id": "5963"
    },
    {
        "raw_code": "def use_consolidated_settings?\n    return false unless settings.dig('object_store', 'enabled')\n\n    connection = settings.dig('object_store', 'connection')\n\n    return false unless connection.present?\n\n    WORKHORSE_ACCELERATED_TYPES.each do |store|\n      section = settings.try(store)\n\n      next unless section\n      next unless section.dig('object_store', 'enabled')\n\n      section_connection = section.dig('object_store', 'connection')\n\n      # We can use consolidated settings if the main object store\n      # connection matches the section-specific connection. This makes\n      # it possible to automatically use consolidated settings as new\n      # settings (such as ci_secure_files) get promoted to a supported\n      # type. Omnibus defaults to an empty hash for the\n      # section-specific connection.\n      return false if section_connection.present? && section_connection.to_h != connection.to_h\n    end",
        "comment": "We only can use the common object storage settings if: 1. The common settings are defined 2. The legacy settings are not defined",
        "label": "Why",
        "id": "1266"
    },
    {
        "raw_code": "def host\n        asset_host = ActionController::Base.asset_host\n        if asset_host.nil? || asset_host == Gitlab.config.gitlab.base_url\n          nil\n        else\n          Gitlab.config.gitlab.base_url\n        end",
        "comment": "we only want to create full urls when there's a different asset_host configured.",
        "label": "Why",
        "id": "1600"
    },
    {
        "raw_code": "def hash; to_s.hash end\n\n      # @return [Boolean] whether another LibraryVersion is equal to this one\n      def eql?(other)\n        other.is_a?(LibraryVersion) && other.name == name &&\n          other.version == version && other.yardoc_file == yardoc_file\n      end\n      alias == eql?\n      alias equal? eql?\n\n      # @return [Boolean] whether the library has been completely processed\n      #   and is ready to be served\n      def ready?\n        return false if yardoc_file.nil?\n        serializer.complete?\n      end\n\n      # @note You should not directly override this method. Instead, implement\n      #   +load_yardoc_from_SOURCENAME+ when implementing loading for a specific\n      #   source type. See the {LibraryVersion} documentation for \"Implementing\n      #   a Custom Library Source\"\n      #\n      # Prepares a library to be displayed by the server. This callback is\n      # performed before each request on a library to ensure that it is loaded\n      # and ready to be viewed. If any steps need to be performed prior to loading,\n      # they are performed through this method (though they should be implemented\n      # through the +load_yardoc_from_SOURCE+ method).\n      #\n      # @raise [LibraryNotPreparedError] if the library is not ready to be\n      #   displayed. Usually when raising this error, you would simultaneously\n      #   begin preparing the library for subsequent requests, although this\n      #   is not necessary.\n      def prepare!\n        return if ready?\n        meth = \"load_yardoc_from_#{source}\"\n        send(meth) if respond_to?(meth, true)\n      end\n\n      # @return [Gem::Specification] a gemspec object for a given library. Used\n      #   for :gem source types.\n      # @return [nil] if there is no installed gem for the library\n      def gemspec\n        ver = version ? \"= #{version}\" : \">= 0\"\n        YARD::GemIndex.find_all_by_name(name, ver).last\n      end\n\n      protected\n\n      @@chdir_mutex = Mutex.new\n\n      # Called when a library of source type \"disk\" is to be prepared. In this\n      # case, the {#yardoc_file} should already be set, but the library may not\n      # be prepared. Run preparation if not done.\n      #\n      # @raise [LibraryNotPreparedError] if the yardoc file has not been\n      #   prepared.\n      def load_yardoc_from_disk\n        return if ready?\n\n        @@chdir_mutex.synchronize do\n          Dir.chdir(source_path_for_disk) do\n            Thread.new do\n              CLI::Yardoc.run('--no-stats', '-n', '-b', yardoc_file)\n            end\n          end",
        "comment": "@return [Fixnum] used for Hash mapping.",
        "label": "Why",
        "id": "643"
    },
    {
        "raw_code": "def get_attribute(name)\n          get_class_attribute(name)\n        end",
        "comment": "get_class_attribute and set_class_attribute are protected, hence those methods are for testing purpose",
        "label": "Why",
        "id": "8226"
    },
    {
        "raw_code": "def initialize(organization: nil)\n      case organization\n      when ::Organizations::Organization\n        @organization = organization\n        @organization_id = organization.id\n      else\n        @organization_id = organization\n      end",
        "comment": "rubocop:disable CodeReuse/ActiveRecord -- Need to instantiate a record here",
        "label": "Why",
        "id": "3673"
    },
    {
        "raw_code": "def initialize_conversion_of_integer_to_bigint(table, columns, primary_key: :id) # rubocop:disable Lint/UnusedMethodArgument -- for backward compatibility, don't remove primary_key\n        Gitlab::Database::Migrations::Conversions::BigintConverter\n          .new(self, table, columns)\n          .init\n      end",
        "comment": "Initializes the conversion of a set of integer columns to bigint  It can be used for converting both a Primary Key and any Foreign Keys that may reference it or any other integer column that we may want to upgrade (e.g. columns that store IDs, but are not set as FKs).  - For primary keys and Foreign Keys (or other columns) defined as NOT NULL, the new bigint column is added with a hardcoded NOT NULL DEFAULT 0 which allows us to skip a very costly verification step once we are ready to switch it. This is crucial for Primary Key conversions, because setting a column as the PK converts even check constraints to NOT NULL constraints and forces an inline re-verification of the whole table. - It sets up a trigger to keep the two columns in sync.  Note: this helper is intended to be used in a regular (pre-deployment) migration.  This helper is part 1 of a multi-step migration process: 1. initialize_conversion_of_integer_to_bigint to create the new columns and database trigger 2. backfill_conversion_of_integer_to_bigint to copy historic data using background migrations 3. remaining steps TBD, see #288005  table - The name of the database table containing the column columns - The name, or array of names, of the column(s) that we want to convert to bigint. primary_key - The name of the primary key column (most often :id)",
        "label": "Why",
        "id": "2993"
    },
    {
        "raw_code": "def deny_visibility_level(model, denied_visibility_level = nil)\n    denied_visibility_level ||= model.visibility_level\n\n    level_name = Gitlab::VisibilityLevel.level_name(denied_visibility_level).downcase\n\n    model.errors.add(:visibility_level, \"#{level_name} has been restricted by your GitLab administrator\")\n  end",
        "comment": "Add an error to the specified model for restricted visibility levels",
        "label": "Why",
        "id": "5708"
    },
    {
        "raw_code": "def test_has_many_through_belongs_to_with_has_many_through_source_reflection\n    welcome_general, thinking_general = taggings(:welcome_general), taggings(:thinking_general)\n\n    assert_equal [welcome_general, thinking_general],\n                 categorizations(:david_welcome_general).post_taggings.order(\"taggings.id\")\n  end",
        "comment": "has_many through Source: has_many through Through: belongs_to",
        "label": "Why",
        "id": "13561"
    },
    {
        "raw_code": "def new_review(review)\n    recipients = NotificationRecipients::BuildService.build_new_review_recipients(review)\n    deliver_options = new_review_deliver_options(review)\n\n    recipients.each do |recipient|\n      mailer\n        .new_review_email(recipient.user.id, review.id)\n        .deliver_later(deliver_options)\n    end",
        "comment": "Notify users on new review in system",
        "label": "Why",
        "id": "5480"
    },
    {
        "raw_code": "def estimate_batch_distinct_count(relation, column = nil, *args, **kwargs)\n        Gitlab::Usage::Metrics::Query.for(:estimate_batch_distinct_count, relation, column)\n      end",
        "comment": "For estimated distinct count use exact query instead of hll buckets query, because it can't be used to obtain estimations without supplementary ruby code present in Gitlab::Database::PostgresHll::BatchDistinctCounter",
        "label": "Why",
        "id": "1359"
    },
    {
        "raw_code": "def sentry_dsn\n        env_sentry_dsn || database_sentry_dsn\n      end",
        "comment": "Some configuration attributes like `dsn`, and `environment` can be configured both via `ENV` and `Application Settings`. The reason being is while GitLab.com uses application_settings in Geo installations, we can't override values in the primary database. Setting this value in application_settings would propagate the value to all Geo nodes, which doesn't solve that particular problem.",
        "label": "Why",
        "id": "1408"
    },
    {
        "raw_code": "def exists?(klass)\n        any? { |entry| entry.klass == klass }\n      end",
        "comment": "@return [Boolean] if the given class is already in the chain",
        "label": "Why",
        "id": "5204"
    },
    {
        "raw_code": "def self.disable!(issue_url, new_threshold: 200)\n      raise ArgumentError, 'new_threshold cannot exceed 2_000' unless new_threshold < 2_000\n\n      unless issue_url.start_with?('https://')\n        raise(\n          ArgumentError,\n          'You must provide a valid issue URL in order to allow a block of code'\n        )\n      end",
        "comment": "Allows the current request to execute a higher number of SQL queries.  This method should _only_ be used when there's a corresponding issue to reduce the number of queries.  The issue URL is only meant to push developers into creating an issue instead of blindly disabling for offending blocks of code.  The new_threshold is so that we don't allow unlimited number of SQL queries while the issue is being fixed.",
        "label": "Why",
        "id": "1389"
    },
    {
        "raw_code": "def initialize(work_item:, target_namespace:, target_work_item_type:, current_user: nil, params: {}, overwritten_params: {})\n          @work_item = work_item\n          @target_namespace = target_namespace\n          @target_work_item_type = target_work_item_type\n          @current_user = current_user\n          @params = params\n          @operation = params.delete(:operation)\n\n          @create_params = {\n            id: nil,\n            iid: nil,\n            created_at: work_item.created_at,\n            updated_at: work_item.updated_at,\n            updated_by_id: work_item.updated_by_id,\n            state_id: work_item.state_id,\n            closed_at: work_item.closed_at,\n            closed_by_id: work_item.closed_by_id,\n            duplicated_to_id: work_item.duplicated_to_id,\n            moved_to_id: work_item.moved_to_id,\n            promoted_to_epic_id: work_item.promoted_to_epic_id,\n            upvotes_count: work_item.upvotes_count,\n            blocking_issues_count: work_item.blocking_issues_count,\n            work_item_type: target_work_item_type,\n            project_id: project&.id,\n            namespace_id: target_namespace.id,\n            title: work_item.title,\n            author_id: work_item.author_id,\n            relative_position: relative_position,\n            confidential: work_item.confidential,\n            cached_markdown_version: work_item.cached_markdown_version,\n            lock_version: work_item.lock_version,\n            service_desk_reply_to: service_desk_reply_to,\n            imported_from: :none\n          }.merge(overwritten_params)\n        end",
        "comment": "rubocop:disable Layout/LineLength -- Keyword arguments are making the line a bit longer",
        "label": "Why",
        "id": "6021"
    },
    {
        "raw_code": "def try_to_queue_for_background_connection(checkout_timeout)\n          return unless @maintaining > 0\n\n          synchronize do\n            return unless @maintaining > @available.num_waiting\n\n            # We are guaranteed the \"maintaining\" thread will return its promised\n            # connection within one maintenance-unit of time. Thus we can safely\n            # do a blocking wait with (functionally) no timeout.\n            @available.poll(100)\n          end",
        "comment": "-- If new connections are already being established in the background, and there are fewer threads already waiting than the number of upcoming connections, we can just get in queue and wait to be handed a connection. This avoids us overshooting the required connection count by starting a new connection ourselves, and is likely to be faster too (because at least some of the time it takes to establish a new connection must have already passed).  If background connections are available, this method will block and return a connection. If no background connections are available, it will immediately return +nil+.",
        "label": "Why",
        "id": "13044"
    },
    {
        "raw_code": "def try_obtain_lease_for_project(id)\n      # Use a 24-hour timeout because on servers/projects where 'git fsck' is\n      # super slow we definitely do not want to run it twice in parallel.\n      Gitlab::ExclusiveLease.new(\n        \"project_repository_check:#{id}\",\n        timeout: 24.hours\n      ).try_obtain\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6369"
    },
    {
        "raw_code": "def ml_model_candidate_uri\n            path = api_v4_projects_packages_ml_models_files___path___path(\n              id: object.project.id, model_version_id: \"#{CANDIDATE_PREFIX}#{object.iid}\", path: '', file_name: ''\n            )\n\n            path.delete_suffix('(/path/)')\n          end",
        "comment": "Example: http://127.0.0.1:3000/api/v4/projects/20/packages/ml_models/1/files/",
        "label": "What",
        "id": "3814"
    },
    {
        "raw_code": "def member\n      @member ||= Member.find_by(id: @member_id)\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6254"
    },
    {
        "raw_code": "def merge_request(type_iid)\n      return project.merge_requests.build if type_iid.nil?\n\n      MergeRequestsFinder.new(current_user, project_id: project.id).find_by(iid: type_iid) || project.merge_requests.build\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6126"
    },
    {
        "raw_code": "def define_note_vars\n    @noteable = @commit\n    @note = @project.build_commit_note(commit)\n\n    @new_diff_note_attrs = {\n      noteable_type: 'Commit',\n      commit_id: @commit.id\n    }\n\n    @grouped_diff_discussions = commit.grouped_diff_discussions\n    @discussions = commit.discussions\n\n    if merge_request_iid = params[:merge_request_iid]\n      @merge_request = MergeRequestsFinder.new(current_user, project_id: @project.id).find_by(iid: merge_request_iid)\n\n      if @merge_request\n        @new_diff_note_attrs.merge!(\n          noteable_type: 'MergeRequest',\n          noteable_id: @merge_request.id\n        )\n\n        merge_request_commit_notes = @merge_request.notes.where(commit_id: @commit.id).inc_relations_for_view\n        merge_request_commit_diff_discussions = merge_request_commit_notes.grouped_diff_discussions(@commit.diff_refs)\n        @grouped_diff_discussions.merge!(merge_request_commit_diff_discussions) do |line_code, left, right|\n          left + right\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6621"
    },
    {
        "raw_code": "def investigate_partial(cops, processed_source, offset:, original:)\n        commissioner = Commissioner.new(cops, self.class.forces_for(cops), @options)\n        commissioner.investigate(processed_source, offset: offset, original: original)\n      end",
        "comment": "@return [Commissioner::InvestigationReport]",
        "label": "What",
        "id": "10302"
    },
    {
        "raw_code": "def object_store=(value)\n      @object_store = value || Store::LOCAL\n      model[store_serialization_column] = @object_store if sync_model_object_store? && persist_object_store?\n      @storage = storage_for(object_store)\n    end",
        "comment": "rubocop:disable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "8043"
    },
    {
        "raw_code": "def _Strike\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = begin;  strike? ; end\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Strike = &{ strike? } \"~~\" !@Whitespace @StartList:a (!\"~~\" Inline:b { a << b })+ \"~~\" { strike a.join }",
        "label": "What",
        "id": "15760"
    },
    {
        "raw_code": "def count_service\n      ::Projects::OpenIssuesCountService\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5889"
    },
    {
        "raw_code": "def run_post_installation_setup\n            # To be implemented by subclasses\n          end",
        "comment": "Run post-installation setup  @return [void]",
        "label": "What",
        "id": "3940"
    },
    {
        "raw_code": "def render_xml_hello\n    @name = \"David\"\n    render template: \"test/hello\"\n  end",
        "comment": "This test is testing 3 things: render :file in AV      :ported: render :template in AC  :ported: setting content type",
        "label": "What",
        "id": "12043"
    },
    {
        "raw_code": "def any_projects?(projects)\n    return projects.any? if projects.is_a?(Array)\n\n    if projects.limit_value\n      projects.to_a.any?\n    else\n      projects.except(:offset).any?\n    end",
        "comment": "Returns true if any projects are present.  If the relation has a LIMIT applied we'll cast the relation to an Array since repeated any? checks would otherwise result in multiple COUNT queries being executed.  If no limit is applied we'll just issue a COUNT since the result set could be too large to load into memory.",
        "label": "What",
        "id": "7813"
    },
    {
        "raw_code": "def with_indifferent_access\n      to_hash.with_indifferent_access\n    end",
        "comment": "For backward compatibility, like: https://gitlab.com/gitlab-org/gitlab/-/blob/adf67e90428670aaa955731f3bdeafb8b3a874cd/lib/gitlab/database/health_status/indicators/patroni_apdex.rb#L58",
        "label": "What",
        "id": "3521"
    },
    {
        "raw_code": "def comment_mr_branch_presence_changed(merge_request)\n      presence = @push.branch_added? ? :add : :delete\n\n      SystemNoteService.change_branch_presence(\n        merge_request, merge_request.project, @current_user,\n        :source, @push.branch_name, presence)\n    end",
        "comment": "Add comment about branches being deleted or added to merge requests",
        "label": "What",
        "id": "5551"
    },
    {
        "raw_code": "def host_port_mapping(port)\n            yml = YAML.safe_load(File.read(kind_config_file_name))\n\n            yml[\"nodes\"].first[\"extraPortMappings\"].find { |mapping| mapping[\"hostPort\"] == port }[\"containerPort\"]\n          end",
        "comment": "Get configured port mapping  @param [Integer] port @return [Integer]",
        "label": "What",
        "id": "4041"
    },
    {
        "raw_code": "def validates_with(*args, &block)\n        options = args.extract_options!\n        options[:class] = self\n\n        args.each do |klass|\n          validator = klass.new(options.dup, &block)\n\n          if validator.respond_to?(:attributes) && !validator.attributes.empty?\n            validator.attributes.each do |attribute|\n              _validators[attribute.to_sym] << validator\n            end",
        "comment": "Passes the record off to the class or classes specified and allows them to add errors based on more complex conditions.  class Person include ActiveModel::Validations validates_with MyValidator end  class MyValidator < ActiveModel::Validator def validate(record) if some_complex_logic record.errors.add :base, 'This record is invalid' end end  private def some_complex_logic # ... end end  You may also pass it multiple classes, like so:  class Person include ActiveModel::Validations validates_with MyValidator, MyOtherValidator, on: :create end  There is no default error message for +validates_with+. You must manually add errors to the record's errors collection in the validator class.  To implement the validate method, you must have a +record+ parameter defined, which is the record to be validated.  Configuration options: * <tt>:on</tt> - Specifies the contexts where this validation is active. Runs in all validation contexts by default +nil+. You can pass a symbol or an array of symbols. (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt> or <tt>on: [:create, :custom_validation_context]</tt>) * <tt>:if</tt> - Specifies a method, proc, or string to call to determine if the validation should occur (e.g. <tt>if: :allow_validation</tt>, or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method, proc, or string should return or evaluate to a +true+ or +false+ value. * <tt>:unless</tt> - Specifies a method, proc, or string to call to determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>, or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The method, proc, or string should return or evaluate to a +true+ or +false+ value. * <tt>:strict</tt> - Specifies whether validation should be strict. See <tt>ActiveModel::Validations#validates!</tt> for more information.  If you pass any additional configuration options, they will be passed to the class and available as +options+:  class Person include ActiveModel::Validations validates_with MyValidator, my_custom_key: 'my custom value' end  class MyValidator < ActiveModel::Validator def validate(record) options[:my_custom_key] # => \"my custom value\" end end",
        "label": "What",
        "id": "12321"
    },
    {
        "raw_code": "def deep_merge!(other, &block)\n      merge!(other) do |key, this_val, other_val|\n        if this_val.is_a?(DeepMergeable) && this_val.deep_merge?(other_val)\n          this_val.deep_merge(other_val, &block)\n        elsif block_given?\n          block.call(key, this_val, other_val)\n        else\n          other_val\n        end",
        "comment": "Same as #deep_merge, but modifies +self+.",
        "label": "What",
        "id": "13799"
    },
    {
        "raw_code": "def load_paginated_collection(batch_page, batch_size, diff_options)\n          batch_page ||= DEFAULT_BATCH_PAGE\n          batch_size ||= DEFAULT_BATCH_SIZE\n\n          paths = diff_options&.fetch(:paths, nil)\n\n          paginated_collection = relation.offset(batch_page).limit([batch_size.to_i, DEFAULT_BATCH_SIZE].min)\n          paginated_collection = paginated_collection.by_paths(paths) if paths\n\n          paginated_collection\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2719"
    },
    {
        "raw_code": "def repository_workflow_runs(repo, options = {})\n        paginate \"#{Repository.path repo}/actions/runs\", options do |data, last_response|\n          data.workflow_runs.concat last_response.data.workflow_runs\n        end",
        "comment": "List all workflow runs for a repository  @param repo [Integer, String, Repository, Hash] A GitHub repository @option options [String] :actor Optional filtering by the login of a user @option options [String] :branch Optional filtering by a branch @option options [String] :event Optional filtering by the event type (e.g. push, pull_request, issue) @option options [String] :status Optional filtering by a status or conclusion (e.g. success, completed...)  @return [Sawyer::Resource] the total count and an array of workflows @see https://developer.github.com/v3/actions/workflow-runs/#list-repository-workflow-runs",
        "label": "What",
        "id": "15115"
    },
    {
        "raw_code": "def initialize(\n      title: nil,\n      description: nil,\n      icon: nil,\n      href: nil,\n      link_options: {},\n      **html_options\n    )\n      @title = title\n      @description = description\n      @icon = icon.to_s\n      @href = href\n      @html_options = html_options\n      @link_options = link_options\n    end",
        "comment": "@param [String] title @param [String] description @param [String] icon @param [String] href @param [Hash] html_options @param [Hash] link_options",
        "label": "What",
        "id": "5381"
    },
    {
        "raw_code": "def site_packages\n    HOMEBREW_PREFIX/\"lib/python#{version.major_minor}/site-packages\"\n  end",
        "comment": "The HOMEBREW_PREFIX location of site-packages.",
        "label": "What",
        "id": "39"
    },
    {
        "raw_code": "def _Enumerator\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _NonindentSpace()\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Enumerator = @NonindentSpace [0-9]+ \".\" @Spacechar+",
        "label": "What",
        "id": "15620"
    },
    {
        "raw_code": "def _normalize_args(action = nil, options = {})\n        options = super(action, options)\n        case action\n        when NilClass\n        when Hash\n          options = action\n        when String, Symbol\n          action = action.to_s\n          key = action.include?(?/) ? :template : :action\n          options[key] = action\n        else\n          if action.respond_to?(:permitted?) && action.permitted?\n            options = action\n          elsif action.respond_to?(:render_in)\n            options[:renderable] = action\n          else\n            options[:partial] = action\n          end",
        "comment": "Normalize args by converting render \"foo\" to render action: \"foo\" and render \"foo/bar\" to render template: \"foo/bar\".",
        "label": "What",
        "id": "11749"
    },
    {
        "raw_code": "def report_uri(uri)\n      @directives[\"report-uri\"] = [uri]\n    end",
        "comment": "Enable the [report-uri](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-uri) directive. Violation reports will be sent to the specified URI:  policy.report_uri \"/csp-violation-report-endpoint\" ",
        "label": "What",
        "id": "11416"
    },
    {
        "raw_code": "def set_current_limit!(value)\n          with_redis do |r|\n            r.set(current_limit_key, value.to_i, ex: TTL)\n          end",
        "comment": "Updates the current limit value in Redis @param value [Integer] The new limit value to set",
        "label": "What",
        "id": "2771"
    },
    {
        "raw_code": "def before_delete\n    expire_exists_cache\n    expire_all_method_caches\n    expire_branch_cache if exists?\n    expire_content_cache\n\n    repository_event(:remove_repository)\n  end",
        "comment": "Runs code just before a repository is deleted.",
        "label": "What",
        "id": "7136"
    },
    {
        "raw_code": "def self.populate!\n    return unless table_exists?\n\n    # The GitLab config does not change for the lifecycle of the process\n    in_config = Gitlab.config.repositories.storages.keys.map(&:to_s)\n    in_db = all.pluck(:name)\n\n    # This may race with other processes creating shards at the same time, but\n    # `by_name` will handle that correctly\n    missing = in_config - in_db\n    missing.map { |name| by_name(name) }\n  end",
        "comment": "Store shard names from the configuration file in the database. This is not a list of active shards - we just want to assign an immutable, unique ID to every shard name for easy indexing / referencing.",
        "label": "What",
        "id": "6861"
    },
    {
        "raw_code": "def add_table_specific_allows(type, schema_allows)\n        result = schema_allows\n        all_table_allows(type).each do |schema_from, tables|\n          # Preserve the meaning of `nil` as defined in convert_array_to_hash as a nil value means that we allow all\n          # tables\n          next if result.key?(schema_from) && result[schema_from].nil?\n\n          # Now we add the table to the specific_tables list because this table specifies it is allowed in this schema\n          result[schema_from] ||= { specific_tables: Set.new }\n          result[schema_from][:specific_tables] += tables\n        end",
        "comment": "This method loops over all the `db/docs` files for every table and injects any allow_cross_joins/allow_cross_transactions/allow_cross_foreign_keys into the specific_tables lists for the current schema.",
        "label": "What",
        "id": "3011"
    },
    {
        "raw_code": "def self.from_api_response(collaborator, _additional_data = {})\n          new(\n            id: collaborator[:id],\n            login: collaborator[:login],\n            role_name: collaborator[:role_name]\n          )\n        end",
        "comment": "Builds a user from a GitHub API response.  collaborator - An instance of `Hash` containing the user & role details.",
        "label": "What",
        "id": "2249"
    },
    {
        "raw_code": "def admin_username\n          @admin_username ||= admin_variable_with_default(\n            \"username\",\n            ADMIN_USERNAME_VARIABLE_NAME,\n            DEFAULT_ADMIN_USERNAME\n          )\n        end",
        "comment": "Admin user username  @return [String]",
        "label": "What",
        "id": "4493"
    },
    {
        "raw_code": "def quote_column_name(column_name)\n          raise NotImplementedError\n        end",
        "comment": "Quotes the column name. Must be implemented by subclasses",
        "label": "What",
        "id": "13087"
    },
    {
        "raw_code": "def resource_web_url(resource)\n        super\n      rescue ResourceURLMissingError\n        # this particular resource does not expose a web_url property\n      end",
        "comment": "Resource web url  @param [Hash] resource @return [String]",
        "label": "What",
        "id": "4146"
    },
    {
        "raw_code": "def get_container_id(name)\n          compose_execute(\"ps\", \"-q\", name).chomp\n        end",
        "comment": "Lookup the ID for the container with the given name  @param [String] name Name of container @return [String] Container ID",
        "label": "What",
        "id": "9504"
    },
    {
        "raw_code": "def load_box(org, box_name, access_token)\n          account = VagrantCloud::Account.new(\n            custom_server: api_server_url,\n            access_token: access_token\n          )\n          box = account.organization(name: org).boxes.detect { |b| b.name == box_name }\n          return box if box\n          account.organization(name: org).add_box(box_name)\n        end",
        "comment": "Load the requested box  @param [String] org Organization name for box @param [String] box_name Name of the box @param [String] access_token User access token @return [VagrantCloud::Box]",
        "label": "What",
        "id": "9764"
    },
    {
        "raw_code": "def settings\n      {}\n    end",
        "comment": "This makes it compatible with Mail's `#deliver!` method https://github.com/mikel/mail/blob/22a7afc23f253319965bf9228a0a430eec94e06d/lib/mail/message.rb#L271",
        "label": "What",
        "id": "1193"
    },
    {
        "raw_code": "def make_defs(*symbols)\n      symbols.map do |s|\n        s = \"self.#{s}\" if mock_handler_opts[:scope] == :class\n        \"def #{s}; end\"\n      end.join(\"\\n\")\n    end",
        "comment": "Generate method definition. @param symbols [Symbol] method names @return [String] method definition code",
        "label": "What",
        "id": "764"
    },
    {
        "raw_code": "def test_parse_top_level_statements_constant_nodoc_integration\n    content = <<-CONTENT\nclass A\n  C = A # :nodoc:\nend",
        "comment": "This tests parse_comment",
        "label": "What",
        "id": "16859"
    },
    {
        "raw_code": "def acts_like_time?\n    true\n  end",
        "comment": "Duck-types as a Time-like class. See Object#acts_like?.",
        "label": "What",
        "id": "14385"
    },
    {
        "raw_code": "def exec(name, command)\n          cmd = [\"docker\", \"exec\", name, *command]\n          execute_shell(cmd)\n        rescue StandardError => e\n          raise Error, \"Failed to execute command in container: #{e.message}\"\n        end",
        "comment": "Execute command in Docker container  @param [String] name @param [Array<String>] command @return [String]",
        "label": "What",
        "id": "3931"
    },
    {
        "raw_code": "def find_uploads(paths, path, value)\n    case value\n    when Rack::Test::UploadedFile\n      paths << path\n    when Hash\n      value.each do |k, v|\n        find_uploads(paths, path + [k], v)\n      end",
        "comment": "Depth first search for UploadedFile values",
        "label": "What",
        "id": "8400"
    },
    {
        "raw_code": "def active_session_device_type_icon(active_session)\n    icon_name =\n      case active_session.device_type\n      when 'smartphone', 'feature phone', 'phablet'\n        'mobile'\n      when 'tablet'\n        'tablet'\n      when 'tv', 'smart display', 'camera', 'portable media player', 'console'\n        'media'\n      when 'car browser'\n        'car'\n      else\n        'monitor-o'\n      end",
        "comment": "Maps a device type as defined in `ActiveSession` to an svg icon name and outputs the icon html.  see `DeviceDetector::Device::DEVICE_NAMES` about the available device types",
        "label": "What",
        "id": "7781"
    },
    {
        "raw_code": "def write_line(env, columns, h, to_rjust_keys)\n        str = h.keys.map { |k|\n          if to_rjust_keys.include?(k)\n            h[k].rjust(columns[k][:width])\n          else\n            h[k].ljust(columns[k][:width])\n          end",
        "comment": "Write a line of content for a table  @param [Vagrant::Environment] env Current Vagrant environment @param [Array<Hash>] columns List of columns in Hash format with `:label` and `:width` keys @param [Hash] h Values to print in row @param [Array<String>] to_rjust_keys List of columns to right justify @return [nil]",
        "label": "What",
        "id": "9755"
    },
    {
        "raw_code": "def initialize(alert, current_user)\n          @alert = alert\n          @current_user = current_user\n        end",
        "comment": "@param alert [AlertManagement::Alert] @param current_user [User]",
        "label": "What",
        "id": "5684"
    },
    {
        "raw_code": "def changed_attribute_by_name(current_set, new_set)\n    current = new = 0\n    current_set.each do |name|\n      current |= @attributes.bitmap_for(name)\n    end",
        "comment": " Used by the tests to change attributes by name from +current_set+ to +new_set+",
        "label": "What",
        "id": "16224"
    },
    {
        "raw_code": "def by_full_paths(items)\n    params[:full_paths].present? ? items.where_full_path_in(params[:full_paths], preload_routes: false) : items\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7924"
    },
    {
        "raw_code": "def request_pull_request_review(repo, number, reviewers = {}, options = {})\n        # TODO(5.0): remove deprecated behavior\n        if reviewers.is_a?(Array)\n          octokit_warn(\n            'Deprecated: Octokit::Client#request_pull_request_review ' \\\n            \"no longer takes a separate :reviewers argument.\\n\" \\\n            'Please update your call to pass :reviewers and :team_reviewers as part of the options hash.'\n          )\n          options = options.merge(reviewers: reviewers)\n        else\n          options = options.merge(reviewers)\n        end",
        "comment": "Create a review request  @param repo [Integer, String, Hash, Repository] A GitHub repository @param number [Integer] Number ID of the pull request @param reviewers [Hash] :reviewers [Array<String>] An array of user logins @param options [Hash] :team_reviewers [Array<String>] An array of team slugs @see https://developer.github.com/v3/pulls/review_requests/#request-reviewers-for-a-pull-request  @example @client.request_pull_request_review('octokit/octokit.rb', 2, reviewers: ['soudy'])  @return [Sawyer::Resource>] Hash respresenting the pull request",
        "label": "What",
        "id": "15007"
    },
    {
        "raw_code": "def eager_resolve(resolver_class, **opts)\n    sync(resolve(resolver_class, **opts))\n  end",
        "comment": "Eagerly run a loader's named resolver (syncs any lazy values returned by resolve)",
        "label": "What",
        "id": "8393"
    },
    {
        "raw_code": "def ignore_git_errors(&block)\n    yield\n  rescue Gitlab::Git::CommandError => e\n    Gitlab::GitLogger.warn(class: self.class.name, container_id: container.id, disk_path: disk_path, message: e.to_s)\n  end",
        "comment": "If we get a Gitaly error, the repository may be corrupted. We can ignore these errors since we're going to trash the repositories anyway.",
        "label": "What",
        "id": "6012"
    },
    {
        "raw_code": "def schedule_backup_job(repository, always_create:)\n      json_job = {\n        storage_name: repository.storage,\n        relative_path: repository.relative_path,\n        gl_project_path: repository.gl_project_path,\n        always_create: always_create\n      }.to_json\n\n      @input_stream.puts(json_job)\n    end",
        "comment": "Schedule a new backup job through a non-blocking JSON based pipe protocol  @see https://gitlab.com/gitlab-org/gitaly/-/blob/master/doc/gitaly-backup.md",
        "label": "What",
        "id": "3621"
    },
    {
        "raw_code": "def down_migrate_to_jsonb_setting(setting_name:, jsonb_column_name:)\n          if setting_name.blank? || jsonb_column_name.nil?\n            raise ArgumentError, 'setting_name and jsonb_column_name are required'\n          end",
        "comment": "Reverts a JSONB application setting to its default state during a migration rollback. This method removes the specified setting from the JSONB column.  @param setting_name [Symbol, String] The name of the application setting to remove from the JSONB column @param jsonb_column_name [Symbol, String] The name of the application setting JSONB column to update @return [Integer] The number of affected rows for UPDATE statement",
        "label": "What",
        "id": "3135"
    },
    {
        "raw_code": "def execute(*params)\n    group = Group.find_by(*params)\n\n    if can?(@current_user, :read_group, group)\n      group\n    else\n      nil\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7899"
    },
    {
        "raw_code": "def verify_milestones_import\n        logger.info(\"== Verifying milestones import ==\")\n        expect(gl_milestones).to include(*gh_milestones)\n      end",
        "comment": "Verify milestones import  @return [void]",
        "label": "What",
        "id": "4399"
    },
    {
        "raw_code": "def self.load_autoload_plugins\n      options[:autoload_plugins].each {|name| load_plugin(name) }\n    end",
        "comment": "Load plugins set in :autoload_plugins",
        "label": "What",
        "id": "154"
    },
    {
        "raw_code": "def project_pool\n        @project_pool ||= project_tar_paths.split(\";\").filter_map do |f|\n          path = Pathname.new(f)\n          next logger.warn(\"#{f} is not a valid path!\") && nil unless path.exist?\n\n          path\n        end",
        "comment": "Pool of project tar files  @return [Array<Pathname>]",
        "label": "What",
        "id": "4689"
    },
    {
        "raw_code": "def workhorse_passthrough_route?\n          # Calling route_hash may be expensive. Only do it if we think there's a possible match\n          return false unless request.post? &&\n            request_path.end_with?('.git/git-upload-pack')\n\n          ALLOWLISTED_GIT_READ_ONLY_ROUTES[route_hash[:controller]]&.include?(\n            route_hash[:action]\n          )\n        end",
        "comment": "URL for requests passed through gitlab-workhorse to rails-web https://gitlab.com/gitlab-org/gitlab-workhorse/-/merge_requests/12",
        "label": "What",
        "id": "2043"
    },
    {
        "raw_code": "def patch(*path_or_actions, as: DEFAULT, to: nil, controller: nil, action: nil, on: nil, defaults: nil, constraints: nil, anchor: nil, format: nil, path: nil, internal: nil, **mapping, &block)\n          if path_or_actions.grep(Hash).any? && (deprecated_options = path_or_actions.extract_options!)\n            as = assign_deprecated_option(deprecated_options, :as, :patch) if deprecated_options.key?(:as)\n            to ||= assign_deprecated_option(deprecated_options, :to, :patch)\n            controller ||= assign_deprecated_option(deprecated_options, :controller, :patch)\n            action ||= assign_deprecated_option(deprecated_options, :action, :patch)\n            on ||= assign_deprecated_option(deprecated_options, :on, :patch)\n            defaults ||= assign_deprecated_option(deprecated_options, :defaults, :patch)\n            constraints ||= assign_deprecated_option(deprecated_options, :constraints, :patch)\n            anchor = assign_deprecated_option(deprecated_options, :anchor, :patch) if deprecated_options.key?(:anchor)\n            format = assign_deprecated_option(deprecated_options, :format, :patch) if deprecated_options.key?(:format)\n            path ||= assign_deprecated_option(deprecated_options, :path, :patch)\n            internal ||= assign_deprecated_option(deprecated_options, :internal, :patch)\n            assign_deprecated_options(deprecated_options, mapping, :patch)\n          end",
        "comment": "Define a route that only recognizes HTTP PATCH. For supported arguments, see [match](rdoc-ref:Base#match)  patch 'bacon', to: 'food#bacon'",
        "label": "What",
        "id": "11565"
    },
    {
        "raw_code": "def strip_links(html)\n        self.class.link_sanitizer.sanitize(html)\n      end",
        "comment": "Strips all link tags from +html+ leaving just the link text.  strip_links('<a href=\"http://www.rubyonrails.org\">Ruby on Rails</a>') # => Ruby on Rails  strip_links('Please e-mail me at <a href=\"mailto:me@email.com\">me@email.com</a>.') # => Please e-mail me at me@email.com.  strip_links('Blog: <a href=\"http://www.myblog.com/\" class=\"nav\" target=\\\"_blank\\\">Visit</a>.') # => Blog: Visit.  strip_links('<<a href=\"https://example.org\">malformed & link</a>') # => &lt;malformed &amp; link",
        "label": "What",
        "id": "11965"
    },
    {
        "raw_code": "def started(target_files); end\n\n      # @api public\n      #\n      # Invoked at the beginning of inspecting each files.\n      #\n      # @param file [String]\n      #   the file path\n      #\n      # @param options [Hash]\n      #   file specific information, currently this is always empty.\n      #\n      # @return [void]\n      def file_started(file, options); end\n\n      # @api public\n      #\n      # Invoked at the end of inspecting each files.\n      #\n      # @param file [String]\n      #   the file path\n      #\n      # @param offenses [Array(RuboCop::Cop::Offense)]\n      #   all detected offenses for the file\n      #\n      # @return [void]\n      #\n      # @see RuboCop::Cop::Offense\n      def file_finished(file, offenses); end\n\n      # @api public\n      #\n      # Invoked after all files are inspected or interrupted by user.\n      #\n      # @param inspected_files [Array(String)]\n      #   the inspected file paths.\n      #   This would be same as `target_files` passed to `#started`\n      #   unless RuboCop is interrupted by user.\n      #\n      # @return [void]\n      def finished(inspected_files); end\n    end\n  end\nend",
        "comment": "@api public  Invoked once before any files are inspected.  @param target_files [Array(String)] all target file paths to be inspected  @return [void]",
        "label": "What",
        "id": "10192"
    },
    {
        "raw_code": "def unfreeze\n          @children = nil\n        end",
        "comment": "@group Managing node state Resets node state in tree",
        "label": "What",
        "id": "326"
    },
    {
        "raw_code": "def validates_inclusion_of(*attr_names)\n        validates_with InclusionValidator, _merge_attributes(attr_names)\n      end",
        "comment": "Validates whether the value of the specified attribute is available in a particular enumerable object.  class Person < ActiveRecord::Base validates_inclusion_of :role, in: %w( admin contributor ) validates_inclusion_of :age, in: 0..99 validates_inclusion_of :format, in: %w( jpg gif png ), message: \"extension %{value} is not included in the list\" validates_inclusion_of :states, in: ->(person) { STATES[person.country] } validates_inclusion_of :karma, in: :available_karmas end  Configuration options: * <tt>:in</tt> - An enumerable object of available items. This can be supplied as a proc, lambda, or symbol which returns an enumerable. If the enumerable is a numerical, time, or datetime range the test is performed with <tt>Range#cover?</tt>, otherwise with <tt>include?</tt>. When using a proc or lambda the instance under validation is passed as an argument. * <tt>:within</tt> - A synonym(or alias) for <tt>:in</tt> * <tt>:message</tt> - Specifies a custom error message (default is: \"is not included in the list\").  There is also a list of default options supported by every validator: +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+. See ActiveModel::Validations::ClassMethods#validates for more information.",
        "label": "What",
        "id": "12314"
    },
    {
        "raw_code": "def m(*args) end\n      eof\n    end",
        "comment": "Method comments @overload m(x, y) Overload docstring @param [String] x parameter x @param [Boolean] y parameter y @overload m(x, y, z) @param [String] x parameter x @param [Boolean] y parameter y @param [Boolean] z parameter z",
        "label": "What",
        "id": "790"
    },
    {
        "raw_code": "def ssh_key_expired(ssh_keys)\n    ssh_keys = Array(ssh_keys)\n\n    # Resolve any pending \"expiring soon\" todos for these keys\n    expiring_key_todos = ::Todo.pending_for_expiring_ssh_keys(ssh_keys.map(&:id))\n    expiring_key_todos.batch_update(state: :done, resolved_by_action: :system_done)\n\n    create_ssh_key_todos(ssh_keys, ::Todo::SSH_KEY_EXPIRED)\n  end",
        "comment": "When a SSH key expired we should:  * resolve any corresponding \"expiring soon\" todo * create a todo for the user owning that SSH key ",
        "label": "What",
        "id": "5447"
    },
    {
        "raw_code": "def subscribe_users(group_label, label_ids)\n      # users can be subscribed to multiple labels that will be merged into the group one\n      # we want to keep only one subscription / user\n      ids_to_update = Subscription.where(subscribable_id: label_ids, subscribable_type: 'Label')\n        .group(:user_id)\n        .pluck('MAX(id)')\n      Subscription.where(id: ids_to_update).update_all(subscribable_id: group_label.id)\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6048"
    },
    {
        "raw_code": "def deploy_version\n        ENV['DEPLOY_VERSION']\n      end",
        "comment": "Get the version of GitLab currently being tested against @return String Version @example > Env.deploy_version #=> 13.3.4-ee.0",
        "label": "What",
        "id": "4464"
    },
    {
        "raw_code": "def params=(value)\n      @_params = value.is_a?(Hash) ? Parameters.new(value) : value\n    end",
        "comment": "Assigns the given `value` to the `params` hash. If `value` is a Hash, this will create an ActionController::Parameters object that has been instantiated with the given `value` hash.",
        "label": "What",
        "id": "11403"
    },
    {
        "raw_code": "def setup_environment!\n        ENV[\"KNAPSACK_TEST_DIR\"] = \"qa/specs/features\"\n        ENV[\"KNAPSACK_REPORT_PATH\"] = FALLBACK_REPORT\n\n        if ENV[\"KNAPSACK_TEST_FILE_PATTERN\"]\n          logger.warn(<<~MSG)\n            KNAPSACK_TEST_FILE_PATTERN variable is set and is overriding automatically generated test pattern '#{test_pattern}'!\n            To ensure correct test distribution, please remove KNAPSACK_TEST_FILE_PATTERN variable and pass specific test folders as command line arguments instead.\n          MSG\n        else\n          logger.debug(\"Setting knapsack test pattern to '#{test_pattern}'\")\n          ENV[\"KNAPSACK_TEST_FILE_PATTERN\"] = test_pattern\n        end",
        "comment": "Set knapsack environment variables  @return [void]",
        "label": "What",
        "id": "4538"
    },
    {
        "raw_code": "def reset!\n        logger = @logger\n        instance_variables.each(&method(:remove_instance_variable))\n        @logger = logger\n        @enabled = false\n      end",
        "comment": "@private Reset the cached values for platform. This is not considered a public API and should only be used for testing.",
        "label": "What",
        "id": "9244"
    },
    {
        "raw_code": "def edit; end\n\n  def update\n    result = ::Projects::UpdateService.new(@project, current_user, project_params).execute\n\n    if result[:status] == :success\n      unless Gitlab::Utils.to_boolean(project_params['runner_registration_enabled'])\n        Ci::Runners::ResetRegistrationTokenService.new(@project, current_user).execute\n      end\n\n      redirect_to [:admin, @project],\n        notice: format(_(\"Project '%{project_name}' was successfully updated.\"), project_name: @project.name)\n    else\n      render \"edit\"\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6469"
    },
    {
        "raw_code": "def resume\n        execute(:resume_vm, VmId: vm_id)\n      end",
        "comment": "Resume the VM from suspension  @return [nil]",
        "label": "What",
        "id": "9674"
    },
    {
        "raw_code": "def draft_match(table)\n    table[:title].matches('Draft - %')\n      .or(table[:title].matches('Draft:%'))\n      .or(table[:title].matches('[Draft]%'))\n      .or(table[:title].matches('(Draft)%'))\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7885"
    },
    {
        "raw_code": "def content_for?(key)\n      content_blocks[key.to_sym].any?\n    end",
        "comment": "Check if a block of content with the given key was defined. For example:  <% content_for :head do %> <script type=\"text/javascript\" src=\"/foo.js\"></script> <% end %>  <% if content_for? :head %> <span>content \"head\" was defined.</span> <% end %>",
        "label": "What",
        "id": "8650"
    },
    {
        "raw_code": "def persist(ids_to_cache)\n      ids_to_cache.each_slice(PERSIST_SLICE_SIZE) do |slice|\n        Namespaces::Descendants.upsert_all(slice.map { |id| { namespace_id: id, outdated_at: Time.current } })\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6326"
    },
    {
        "raw_code": "def foreign_key_exists?(from_table, to_table = nil, **options)\n        foreign_key_for(from_table, to_table: to_table, **options).present?\n      end",
        "comment": "Checks to see if a foreign key exists on a table for a given foreign key definition.  # Checks to see if a foreign key exists. foreign_key_exists?(:accounts, :branches)  # Checks to see if a foreign key on a specified column exists. foreign_key_exists?(:accounts, column: :owner_id)  # Checks to see if a foreign key with a custom name exists. foreign_key_exists?(:accounts, name: \"special_fk_name\") ",
        "label": "What",
        "id": "13166"
    },
    {
        "raw_code": "def index_by\n    if block_given?\n      result = {}\n      each { |elem| result[yield(elem)] = elem }\n      result\n    else\n      to_enum(:index_by) { size if respond_to?(:size) }\n    end",
        "comment": "Convert an enumerable to a hash, using the block result as the key and the element as the value.  people.index_by(&:login) # => { \"nextangle\" => <Person ...>, \"chade-\" => <Person ...>, ...}  people.index_by { |person| \"#{person.first_name} #{person.last_name}\" } # => { \"Chade- Fowlersburg-e\" => <Person ...>, \"David Heinemeier Hansson\" => <Person ...>, ...}",
        "label": "What",
        "id": "14067"
    },
    {
        "raw_code": "def execute(issue_event)\n            raise NotImplementedError\n          end",
        "comment": "issue_event - An instance of `Gitlab::GithubImport::Representation::IssueEvent`.",
        "label": "What",
        "id": "2236"
    },
    {
        "raw_code": "def development_tool_module\n    {\n      jiraDevelopmentTool: {\n        actions: actions,\n        key: 'gitlab-development-tool',\n        application: { value: Atlassian::JiraConnect.display_name },\n        name: { value: Atlassian::JiraConnect.display_name },\n        url: HOME_URL,\n        logoUrl: logo_url,\n        capabilities: %w[branch commit pull_request]\n      }\n    }\n  end",
        "comment": "See https://developer.atlassian.com/cloud/jira/software/modules/development-tool/",
        "label": "What",
        "id": "6650"
    },
    {
        "raw_code": "def external_file\n    @blob = @entry.blob\n  end",
        "comment": "External files are redirected to Gitlab Pages and might have unsecure content To warn the user about the possible unsecure content, we show a warning page before redirecting the user.",
        "label": "What",
        "id": "6594"
    },
    {
        "raw_code": "def generator(args = default_arguments, options = {}, config = {})\n          @generator ||= generator_class.new(args, options, config.reverse_merge(destination_root: destination_root))\n        end",
        "comment": "Instantiate the generator.",
        "label": "What",
        "id": "14803"
    },
    {
        "raw_code": "def dump_stats(io, format: STATS_DEFAULT_FORMAT)\n        verify_format!(format)\n\n        format_settings = STATS_FORMATS[format]\n\n        with_malloc_stats_print do |stats_print|\n          write_stats(stats_print, io, format_settings)\n        end",
        "comment": "Streams jemalloc stats to the given IO object.",
        "label": "What",
        "id": "1880"
    },
    {
        "raw_code": "def ldap_password\n          ENV[\"GITLAB_LDAP_PASSWORD\"]\n        end",
        "comment": "LDAP user password  @return [String]",
        "label": "What",
        "id": "4500"
    },
    {
        "raw_code": "def detail_args_for(options) # :doc:\n        return @details, details_key if options.empty? # most common path.\n        user_details = @details.merge(options)\n\n        if @cache\n          details_key = DetailsKey.details_cache_key(user_details)\n        else\n          details_key = nil\n        end",
        "comment": "Compute details hash and key according to user options (e.g. passed from #render).",
        "label": "What",
        "id": "11734"
    },
    {
        "raw_code": "def _Source\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n\n        _save2 = self.pos\n        while true # sequence\n          _tmp = match_string(\"<\")\n          unless _tmp\n            self.pos = _save2\n            break\n          end",
        "comment": "Source = (\"<\" < SourceContents > \">\" | < SourceContents >) { text }",
        "label": "What",
        "id": "15768"
    },
    {
        "raw_code": "def compress_source_zip(path)\n        require \"zip\"\n        zipfile = Tempfile.create([\"vagrant\", \".zip\"])\n        zipfile.close\n        if File.file?(path)\n          source_items = [path]\n        else\n          source_items = Dir.glob(File.join(path, \"**\", \"**\", \"*\"))\n        end",
        "comment": "Compress path using zip into temporary file  @param [String] path Path to compress @return [String] path to compressed file",
        "label": "What",
        "id": "9806"
    },
    {
        "raw_code": "def parse_data\n        pairs = []\n        comment = '#'\n\n        each_line do |line|\n          next if line.start_with?(comment) || line.empty?\n\n          pattern, attrs = line.split(/\\s+/, 2)\n\n          parsed = attrs ? parse_attributes(attrs) : {}\n\n          absolute_pattern = pattern.starts_with?('/') ? pattern : File.join('**/', pattern)\n\n          pairs << [absolute_pattern, parsed]\n        end",
        "comment": "Parses the Git attributes file contents.",
        "label": "What",
        "id": "2584"
    },
    {
        "raw_code": "def a; end\n          # (see #a)\n          def b; end\n        end\n      eof\n\n      object = YARD::Registry.at('A#b')\n      expect(object.docstring).to eq 'Docstring'\n      expect(object.tags.map(&:tag_name)).to eq ['return']\n\n      YARD::Registry.clear\n    end",
        "comment": "Docstring @return [Boolean]",
        "label": "What",
        "id": "759"
    },
    {
        "raw_code": "def self.upload_tmp_file(comm, content, remote_path=nil)\n          if remote_path.nil?\n            remote_path = \"/tmp/vagrant-network-entry-#{Time.now.to_i}\"\n          end",
        "comment": "Simple helper to upload content to guest temporary file  @param [Vagrant::Plugin::Communicator] comm @param [String] content @return [String] remote path",
        "label": "What",
        "id": "9842"
    },
    {
        "raw_code": "def collect_tokens\n    @token_stream = []\n  end",
        "comment": " Starts collecting tokens",
        "label": "What",
        "id": "15976"
    },
    {
        "raw_code": "def m\n        end",
        "comment": "calculates value",
        "label": "What",
        "id": "10791"
    },
    {
        "raw_code": "def import(_client, project)\n          waiter = Importer::LfsObjectsImporter\n            .new(project, nil)\n            .execute\n\n          AdvanceStageWorker.perform_async(\n            project.id,\n            { waiter.key => waiter.jobs_remaining },\n            'finish'\n          )\n        end",
        "comment": "project - An instance of Project.",
        "label": "What",
        "id": "6317"
    },
    {
        "raw_code": "def list_service\n      IssueLinks::ListService.new(issue, current_user)\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6602"
    },
    {
        "raw_code": "def define_attribute_methods # :nodoc:\n        return false if @attribute_methods_generated\n        # Use a mutex; we don't want two threads simultaneously trying to define\n        # attribute methods.\n        GeneratedAttributeMethods::LOCK.synchronize do\n          return false if @attribute_methods_generated\n\n          superclass.define_attribute_methods unless base_class?\n\n          unless abstract_class?\n            load_schema\n            super(attribute_names)\n            alias_attribute :id_value, :id if _has_attribute?(\"id\") && !_has_attribute?(\"id_value\")\n          end",
        "comment": "Generates all the attribute related methods for columns in the database accessors, mutators and query methods.",
        "label": "What",
        "id": "12358"
    },
    {
        "raw_code": "def self.verify!(request)\n          return false unless Gitlab::CurrentSettings.slack_app_signing_secret\n\n          timestamp, signature = request.headers.values_at(\n            VERIFICATION_TIMESTAMP_HEADER,\n            VERIFICATION_SIGNATURE_HEADER\n          )\n\n          return false if timestamp.nil? || signature.nil?\n          return false if Time.current.to_i - timestamp.to_i >= VERIFICATION_TIMESTAMP_EXPIRY\n\n          request.body.rewind\n\n          basestring = [\n            VERIFICATION_VERSION,\n            timestamp,\n            request.body.read\n          ].join(VERIFICATION_DELIMITER)\n\n          hmac_digest = OpenSSL::HMAC.hexdigest(\n            VERIFICATION_HMAC_ALGORITHM,\n            Gitlab::CurrentSettings.slack_app_signing_secret,\n            basestring\n          )\n\n          # Signature will look like: 'v0=a2114d57b48eac39b9ad189dd8316235a7b4a8d21a10bd27519666489c69b503'\n          ActiveSupport::SecurityUtils.secure_compare(\n            signature,\n            \"#{VERIFICATION_VERSION}=#{hmac_digest}\"\n          )\n        end",
        "comment": "Verify the request by comparing the given request signature in the header with a signature value that we compute according to the steps in: https://api.slack.com/authentication/verifying-requests-from-slack.",
        "label": "What",
        "id": "3825"
    },
    {
        "raw_code": "def target_files_in_dir(base_dir = Dir.pwd)\n      # Support Windows: Backslashes from command-line -> forward slashes\n      base_dir = base_dir.gsub(File::ALT_SEPARATOR, File::SEPARATOR) if File::ALT_SEPARATOR\n      all_files = find_files(base_dir, File::FNM_DOTMATCH)\n      base_dir_config = @config_store.for(base_dir)\n\n      target_files = if hidden_path?(base_dir)\n                       all_files.select { |file| ruby_file?(file) }\n                     else\n                       all_files.select { |file| to_inspect?(file, base_dir_config) }\n                     end",
        "comment": "Finds all Ruby source files under the current or other supplied directory. A Ruby source file is defined as a file with the `.rb` extension or a file with no extension that has a ruby shebang line as its first line. It is possible to specify includes and excludes using the config file, so you can include other Ruby files like Rakefiles and gemspecs. @param base_dir Root directory under which to search for ruby source files @return [Array] Array of filenames",
        "label": "What",
        "id": "10150"
    },
    {
        "raw_code": "def file_name\n    return unless @file\n\n    @file.absolute_name\n  end",
        "comment": " File name where this CodeObject was found.  See also RDoc::Context#in_files",
        "label": "What",
        "id": "15917"
    },
    {
        "raw_code": "def milestone\n    @noteable = @milestone ||= @project.milestones.find_by!(iid: params[:id])\n  end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6607"
    },
    {
        "raw_code": "def contains_knn?(node)\n          node.children.any? { |child| child.type == :knn }\n        end",
        "comment": "Checks if node contains a KNN query  @param node [ActiveContext::Query] The query node to check @return [Boolean] true if any child is a KNN query",
        "label": "What",
        "id": "1136"
    },
    {
        "raw_code": "def headers\n      @headers ||= Http::Headers.new(self)\n    end",
        "comment": "Provides access to the request's HTTP headers, for example:  request.headers[\"Content-Type\"] # => \"text/plain\"",
        "label": "What",
        "id": "11453"
    },
    {
        "raw_code": "def accept_document(document)\n    document.parts.each do |item|\n      case item\n      when RDoc::Markup::Document then # HACK\n        accept_document item\n      else\n        item.accept self\n      end",
        "comment": " Adds +document+ to the output",
        "label": "What",
        "id": "16272"
    },
    {
        "raw_code": "def branch_exists?(branch_name)\n      !!downstream_client.branch(downstream_project_path, branch_name)\n    rescue Gitlab::Error::ResponseError\n      false\n    end",
        "comment": "Branch existence check  @param branch_name [String] @return [Boolean]",
        "label": "What",
        "id": "5267"
    },
    {
        "raw_code": "def shard\n        @pool.shard\n      end",
        "comment": "The shard (e.g. +:default+) for the current connection. In a non-sharded application, +:default+ is returned.",
        "label": "What",
        "id": "12872"
    },
    {
        "raw_code": "def approve_mr\n        logger.info(\"  approving merge request\")\n        # due to async nature of mr creation, approval is being reset because it happens before commit creation\n        sleep(wait_before_approve)\n        api_request(:post, \"merge_requests/#{mr_iid}/approve\", {}, token_header(approver_access_token))\n      end",
        "comment": "Approve created merge request  @return [void]",
        "label": "What",
        "id": "4714"
    },
    {
        "raw_code": "def next_token\n      raise NotImplementedError, \"#{self.class}\\#next_token is not defined\"\n    end",
        "comment": "The method to fetch next token. If you use #do_parse method, you must implement #next_token.  The format of return value is [TOKEN_SYMBOL, VALUE]. +token-symbol+ is represented by Ruby's symbol by default, e.g. :IDENT for 'IDENT'.  \";\" (String) for ';'.  The final symbol (End of file) must be false.",
        "label": "What",
        "id": "16495"
    },
    {
        "raw_code": "def build_request(http_method, path, opts = {})\n      url = build_request_url(path, opts)\n      http_method = http_method.to_sym.downcase\n\n      header_params = @default_headers.merge(opts[:header_params] || {})\n      query_params = opts[:query_params] || {}\n      form_params = opts[:form_params] || {}\n      follow_location = opts[:follow_location] || true\n\n      update_params_for_auth! header_params, query_params, opts[:auth_names]\n\n      # set ssl_verifyhosts option based on @config.verify_ssl_host (true/false)\n      _verify_ssl_host = @config.verify_ssl_host ? 2 : 0\n\n      req_opts = {\n        :method => http_method,\n        :headers => header_params,\n        :params => query_params,\n        :params_encoding => @config.params_encoding,\n        :timeout => @config.timeout,\n        :ssl_verifypeer => @config.verify_ssl,\n        :ssl_verifyhost => _verify_ssl_host,\n        :sslcert => @config.cert_file,\n        :sslkey => @config.key_file,\n        :verbose => @config.debugging,\n        :followlocation => follow_location\n      }\n\n      # set custom cert, if provided\n      req_opts[:cainfo] = @config.ssl_ca_cert if @config.ssl_ca_cert\n\n      if [:post, :patch, :put, :delete].include?(http_method)\n        req_body = build_request_body(header_params, form_params, opts[:body])\n        req_opts.update :body => req_body\n        if @config.debugging\n          @config.logger.debug \"HTTP request body param ~BEGIN~\\n#{req_body}\\n~END~\\n\"\n        end",
        "comment": "Builds the HTTP request  @param [String] http_method HTTP method/verb (e.g. POST) @param [String] path URL path (e.g. /account/new) @option opts [Hash] :header_params Header parameters @option opts [Hash] :query_params Query parameters @option opts [Hash] :form_params Query parameters @option opts [Object] :body HTTP body (JSON/XML) @return [Typhoeus::Request] A Typhoeus Request",
        "label": "What",
        "id": "830"
    },
    {
        "raw_code": "def initialize(content, content_type)\n          if !MIME::Types.include?(content_type)\n            MIME::Types.add(MIME::Type.new(\"content-type\" => content_type))\n          end",
        "comment": "@param [String] entity content @param [String] type of the entity content",
        "label": "What",
        "id": "9151"
    },
    {
        "raw_code": "def by_visibility_level(items)\n    params[:visibility_level].present? ? items.where(visibility_level: params[:visibility_level]) : items\n  end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7953"
    },
    {
        "raw_code": "def retrieve_single_public_singleton_method(fp_module_or_class)\n        fp_class_singleton_methods = fp_module_or_class.singleton_methods(false)\n        public_singleton_methods = fp_class_singleton_methods - public_singleton_methods_to_ignore\n\n        # Note: Intentionally using Array#[] instead of Array#first here, because there appears to be a bug\n        #       in the type declaration, that doesn't indicate that #first should have `implicitly-returns-nil`\n        #       behavior. See https://github.com/ruby/rbs/pull/1226, this probably needs to be fixed for #first too.\n        #       Until then, we use #[] to avoid type inspection warnings in RubyMine.\n        return public_singleton_methods[0] if public_singleton_methods.size == 1\n\n        fp_doc_link =\n          \"https://gitlab.com/gitlab-org/gitlab/-/blob/master/ee/lib/remote_development/README.md#functional-patterns\"\n\n        rop_doc_link =\n          \"https://gitlab.com/gitlab-org/gitlab/-/blob/master/ee/lib/remote_development/README.md#railway-oriented-programming-and-the-result-class\"\n\n        if public_singleton_methods.size > 1\n          err_msg =\n            \"Railway Oriented Programming (ROP) pattern violation in class `#{fp_module_or_class}`. \" \\\n              \"Expected exactly one (1) public entry point singleton/class method to be present \" \\\n              \"in a class which is used with the ROP pattern, but \" \\\n              \"#{public_singleton_methods.size} \" \\\n              \"public singleton methods were found: #{public_singleton_methods.sort.join(', ')}. \" \\\n              \"You can make the non-entry-point method(s) private via `private_class_method :method_name`. \" \\\n              \"See #{fp_doc_link} and #{rop_doc_link} for more information.\"\n          raise(ArgumentError, err_msg)\n        end",
        "comment": "@param [Class] fp_module_or_class @raise [RuntimeError] @return [Symbol]",
        "label": "What",
        "id": "2397"
    },
    {
        "raw_code": "def rerequest_check_suite(repo, id, options = {})\n        post \"#{Repository.path repo}/check-suites/#{id}/rerequest\", options\n        true\n      end",
        "comment": "Rerequest check suite  @param repo [Integer, String, Hash, Repository] A GitHub repository @param id [Integer] The ID of the check suite @return [Boolean] True if successful, raises an error otherwise @see https://developer.github.com/v3/checks/suites/#rerequest-check-suite",
        "label": "What",
        "id": "15273"
    },
    {
        "raw_code": "def define_url_helper(mod, name, helper, url_strategy)\n            mod.define_method(name) do |*args|\n              last = args.last\n              options = \\\n                case last\n                when Hash\n                  args.pop\n                when ActionController::Parameters\n                  args.pop.to_h\n                end",
        "comment": "Create a URL helper allowing ordered parameters to be associated with corresponding dynamic segments, so you can do:  foo_url(bar, baz, bang)  Instead of:  foo_url(bar: bar, baz: baz, bang: bang)  Also allow options hash, so you can do:  foo_url(bar, baz, bang, sort_by: 'baz') ",
        "label": "What",
        "id": "11595"
    },
    {
        "raw_code": "def id_for_github_id(id)\n        gitlab_id =\n          if project.github_enterprise_import?\n            nil\n          else\n            query_id_for_github_id(id)\n          end",
        "comment": "If importing from github.com, queries and caches the GitLab user ID for a GitHub user ID, if one was found.  When importing from Github Enterprise, do not query user by Github ID since we only have users' Github ID from github.com.",
        "label": "What",
        "id": "2152"
    },
    {
        "raw_code": "def cannot_access_private_profile?\n    source.is_a?(User) && !Ability.allowed?(current_user, :read_user_profile, source)\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7936"
    },
    {
        "raw_code": "def glob(pattern)\n        Dir.glob(pattern, File::FNM_DOTMATCH).sort.reject do |file|\n          IGNORED_FILES.include?(File.basename(file))\n        end",
        "comment": "Get the list of files that match the given pattern. @return [Array<String>]",
        "label": "What",
        "id": "9386"
    },
    {
        "raw_code": "def self.random\n      \"RANDOM()\"\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "1452"
    },
    {
        "raw_code": "def initialize(project)\n      @project = project\n\n      @default_branch_protection = Gitlab::Access::DefaultBranchProtection.new(\n        project.namespace.default_branch_protection_settings\n      )\n    end",
        "comment": "@param [Project] project",
        "label": "What",
        "id": "5898"
    },
    {
        "raw_code": "def can_read_reference?(user, ref_project, node)\n        true\n      end",
        "comment": "we extract only external issue trackers references here, we don't extract cross-project references, so we don't need to do anything here.",
        "label": "What",
        "id": "3419"
    },
    {
        "raw_code": "def layout(name = :layout, &block)\n        template name, &block\n      end",
        "comment": "Define the layout template. The block must return the template source.",
        "label": "What",
        "id": "8602"
    },
    {
        "raw_code": "def team(team_id, options = {})\n        get \"teams/#{team_id}\", options\n      end",
        "comment": "Get team  Requires authenticated organization member.  @param team_id [Integer] Team id. @return [Sawyer::Resource] Hash representing team. @see https://developer.github.com/v3/orgs/teams/#get-team @example @client.team(100000)",
        "label": "What",
        "id": "15431"
    },
    {
        "raw_code": "def configure\n        yield self\n      end",
        "comment": "Forward compatibility with 8.0",
        "label": "What",
        "id": "5158"
    },
    {
        "raw_code": "def test_has_many_through_has_many_with_has_many_through_habtm_source_reflection\n    greetings, more = comments(:greetings), comments(:more_greetings)\n\n    assert_equal [greetings, more], authors(:bob).category_post_comments.order(\"comments.id\")\n  end",
        "comment": "has_many through Source: has_many through a habtm Through: has_many through",
        "label": "What",
        "id": "13559"
    },
    {
        "raw_code": "def cloudflare_response?(response)\n        return false unless response\n\n        response.headers[:server] == \"cloudflare\" || response.code == 403\n      end",
        "comment": "Check if headless request got blocked by cloudflare  @param response [RestClient::Response] @return [Boolean]",
        "label": "What",
        "id": "4697"
    },
    {
        "raw_code": "def export(mapping_files_glob, bucket: DEFAULT_BUCKET, file_name: DEFAULT_FILE_NAME)\n          mapping_files = Dir.glob(mapping_files_glob)\n          return logger.warn(\"No files matched pattern, skipping coverage mapping upload\") if mapping_files.empty?\n\n          unless ENV[\"QA_RUN_TYPE\"].present?\n            return logger.warn(\"QA_RUN_TYPE variable is not set, skipping coverage mapping upload\")\n          end",
        "comment": "Export code path mappings to GCP  @param [String] mapping_files_glob - glob pattern for mapping files @param [String] bucket - custom bucket name (optional) @param [String] file_name - custom file name (optional) @return [void]",
        "label": "What",
        "id": "4820"
    },
    {
        "raw_code": "def verified_request?\n        Gitlab::RequestForgeryProtection.verified?(current_request.env)\n      end",
        "comment": "Check if the request is GET/HEAD, or if CSRF token is valid.",
        "label": "What",
        "id": "2340"
    },
    {
        "raw_code": "def file=(location)\n    @file = case location\n            when RDoc::TopLevel then\n              location.relative_name\n            else\n              location\n            end",
        "comment": " The file this Document was created from.",
        "label": "What",
        "id": "16425"
    },
    {
        "raw_code": "def find_external_alias_named(name)\n    case name\n    when /\\A#/ then\n      find_external_alias name[1..-1], false\n    when /\\A::/ then\n      find_external_alias name[2..-1], true\n    else\n      @external_aliases.find { |a| a.name == name }\n    end",
        "comment": " Finds an external alias with +name+ in this context",
        "label": "What",
        "id": "16668"
    },
    {
        "raw_code": "def run_install\n          values = configuration.values.deep_merge({ environment: env_values })\n          total_attempts = retry_attempts + 1\n\n          Helpers::Spinner.spin(\"creating docker container\") do\n            total_attempts.times do |attempt|\n              log(\"Pulling docker image: #{values[:image]}\", :info)\n              docker_client.pull_image(values[:image])\n\n              begin\n                docker_client.run_container(\n                  name: name,\n                  image: values[:image],\n                  environment: values[:environment],\n                  ports: values[:ports],\n                  volumes: values[:volumes] || {},\n                  restart: values[:restart],\n                  additional_options: [\"--shm-size\", \"256m\"]\n                )\n                break\n              rescue Gitlab::Orchestrator::Docker::Error => e\n                if attempt >= retry_attempts\n                  handle_install_failure(e)\n                else\n                  log(\"Installation failed, retrying...\", :warn)\n                  log(\"Error: #{e}\", :warn)\n                end",
        "comment": "Run Docker container creation  @return [void]",
        "label": "What",
        "id": "3936"
    },
    {
        "raw_code": "def can_filter_when_operated_on?(identifier)\n          supports_operations?(identifier) && filter_options.difference([identifier]).any?\n        end",
        "comment": "Whether there are any filtering options other than the selected uniqueness constraint",
        "label": "What",
        "id": "5360"
    },
    {
        "raw_code": "def add_specs(*gem_specs)\n    gem_specs.each do |spec|\n      add_spec spec\n    end",
        "comment": " Add gem specifications to the source index.",
        "label": "What",
        "id": "269"
    },
    {
        "raw_code": "def to_s\n          output_string = \"\"\n          headers.each do |k, v|\n            output_string += \"#{k}: #{v}\\n\"\n          end",
        "comment": "Output MimeEntity as a string  @return [String] mime data",
        "label": "What",
        "id": "9150"
    },
    {
        "raw_code": "def namespace=(obj)\n        if @namespace\n          @namespace.children.delete(self)\n          Registry.delete(self)\n        end",
        "comment": "Sets the namespace the object is defined in.  @param [NamespaceObject, :root, nil] obj the new namespace (:root for {Registry.root}). If obj is nil, the object is unregistered from the Registry.",
        "label": "What",
        "id": "584"
    },
    {
        "raw_code": "def execute(error, handled:, severity:, context:, source:)\n          @stack.inject(context) { |c, middleware| middleware.call(error, context: c, handled:, severity:, source:) }\n        end",
        "comment": "Run all middlewares in the stack",
        "label": "What",
        "id": "13849"
    },
    {
        "raw_code": "def hook_test_service(hook, _)\n          TestHooks::ProjectService.new(hook, current_user, params[:trigger])\n        end",
        "comment": "EE::API::Hooks::TriggerTest overrides this helper",
        "label": "What",
        "id": "3824"
    },
    {
        "raw_code": "def self.ci_sources\n        sources.except(*dangling_sources.keys)\n      end",
        "comment": "CI sources are those pipeline events that affect the CI status of the ref they run for. By definition it excludes dangling pipelines.",
        "label": "What",
        "id": "7432"
    },
    {
        "raw_code": "def exit_code=(value); end\n\n  # For AiAction\n  def to_ability_name\n    'build'\n  end\n\n  def test_suite_name\n    nil\n  end\n\n  # For AiAction\n  def resource_parent\n    project\n  end\n\n  private\n\n  def unrecoverable_failure?\n    script_failure? || missing_dependency_failure? || archived_failure? || scheduler_failure? || data_integrity_failure?\n  end\nend",
        "comment": "Handled only by ci_build",
        "label": "What",
        "id": "6698"
    },
    {
        "raw_code": "def self.from_json_hash(raw_hash)\n          hash = Representation.symbolize_hash(raw_hash)\n\n          hash[:author] &&= Representation::User.from_json_hash(hash[:author])\n          hash[:submitted_at] = Time.parse(hash[:submitted_at]).in_time_zone if hash[:submitted_at].present?\n\n          new(hash)\n        end",
        "comment": "Builds a new note using a Hash that was built from a JSON payload.",
        "label": "What",
        "id": "2242"
    },
    {
        "raw_code": "def base_and_ancestors_cte(stop_id = nil, hierarchy_order = nil)\n      cte = SQL::RecursiveCTE.new(:base_and_ancestors)\n\n      base_query = ancestors_base.except(:order)\n      base_query = base_query.select(\"1 as #{DEPTH_COLUMN}\", \"ARRAY[#{objects_table.name}.id] AS tree_path\", \"false AS tree_cycle\", base_query.default_select_columns) if hierarchy_order\n\n      cte << base_query\n\n      # Recursively get all the ancestors of the base set.\n      parent_query = unscoped_model\n        .from(from_tables(cte))\n        .where(ancestor_conditions(cte))\n        .except(:order)\n\n      if hierarchy_order\n        quoted_objects_table_name = model.connection.quote_table_name(objects_table.name)\n\n        parent_query = parent_query.select(\n          cte.table[DEPTH_COLUMN] + 1,\n          \"tree_path || #{quoted_objects_table_name}.id\",\n          \"#{quoted_objects_table_name}.id = ANY(tree_path)\",\n          parent_query.default_select_columns\n        ).where(cte.table[:tree_cycle].eq(false))\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "1429"
    },
    {
        "raw_code": "def self.extract_sentry_external_url(url)\n      url&.sub('api/0/projects/', '')\n    end",
        "comment": "http://HOST/api/0/projects/ORG/PROJECT -> http://HOST/ORG/PROJECT",
        "label": "What",
        "id": "7622"
    },
    {
        "raw_code": "def default_endpoint_uri\n        @default_endpoint_uri ||= import_uri.dup.tap do |uri|\n          path = uri.path.gsub(%r{/$}, '')\n          path += '.git' unless path.ends_with?('.git')\n          uri.path = path + LFS_BATCH_API_ENDPOINT\n        end",
        "comment": "The import url must end with '.git' here we ensure it is",
        "label": "What",
        "id": "5944"
    },
    {
        "raw_code": "def default(content = \"Example content\", style: :notice, closeable: false)\n    render AlertComponent.new(style:, closeable:) do\n      content\n    end",
        "comment": "@param content text \"content\" @param style select \"style\", { choices: [notice, alert, error, success, primary, neutral] } @param closeable toggle \"closeable\"",
        "label": "What",
        "id": "10022"
    },
    {
        "raw_code": "def expect_data_attributes(node, negate: false)\n    # ensure assertions work for Capybara::Node::Simple inputs\n    node = node.native if node.respond_to?(:native)\n\n    check_negated_chain_methods_for_node! if negate\n    check_chain_methods_for_node!\n    check_negated_events_limit_for_node! if negate\n    check_events_limit_for_node!\n\n    expect_data_attribute(node, 'tracking', @event_names.first)\n    expect_data_attribute(node, 'label', @additional_properties.try(:[], :label))\n    expect_data_attribute(node, 'property', @additional_properties.try(:[], :property))\n    expect_data_attribute(node, 'value', @additional_properties.try(:[], :value))\n    expect_data_attribute(node, 'tracking-load', @on_load)\n\n    true\n  rescue RSpec::Expectations::ExpectationNotMetError => e\n    @failure_message = e.message\n    false\n  end",
        "comment": "All `node` inputs should be compatible with the have_css matcher https://www.rubydoc.info/gems/capybara/Capybara/RSpecMatchers#have_css-instance_method",
        "label": "What",
        "id": "8345"
    },
    {
        "raw_code": "def from_derived_table(derived_pipelines_table, refs_values_table)\n      pipelines\n        .unscoped\n        .from([\n          refs_values_table,\n          derived_pipelines_table.arel.lateral.as(Ci::Pipeline.table_name)\n        ])\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "8006"
    },
    {
        "raw_code": "def foo\n          end",
        "comment": "{keyword} A",
        "label": "What",
        "id": "10974"
    },
    {
        "raw_code": "def all_pods(output: \"json\")\n          run_in_namespace(\"get\", \"pods\", args: [\"--output\", output])\n        end",
        "comment": "Get all pods in namespace  @param [String] output --output type @return [String]",
        "label": "What",
        "id": "3974"
    },
    {
        "raw_code": "def api_get\n        process_api_response(\n          api_post_to(\n            api_get_path,\n            <<~GQL\n                query {\n                  issue(id: \"gid://gitlab/Issue/#{issue.id}\") {\n                    designCollection {\n                      design(filename: \"#{filename}\") {\n                        id\n                        fullPath\n                        image\n                        filename\n                      }\n                    }\n                  }\n                }\n            GQL\n          )\n        )\n      end",
        "comment": "Fetch design  @return [Hash]",
        "label": "What",
        "id": "4123"
    },
    {
        "raw_code": "def day_name(number)\n          if day_format_lambda = @options[:day_format]\n            day_format_lambda.call(number)\n          elsif @options[:use_two_digit_numbers]\n            \"%02d\" % number\n          else\n            number\n          end",
        "comment": "Looks up day names by number.  day_name(1) # => 1  If the <tt>use_two_digit_numbers: true</tt> option is passed to DateTimeSelector:  day_name(1) # => \"01\"  If the <tt>day_format: ->(day) { day.ordinalize }</tt> option is passed to DateTimeSelector:  day_name(1) # => \"1st\"",
        "label": "What",
        "id": "11843"
    },
    {
        "raw_code": "def backtrace(exc, level_meth = :error)\n      return unless show_backtraces\n      send(level_meth, \"#{exc.class.class_name}: #{exc.message}\")\n      send(level_meth, \"Stack trace:\" +\n        exc.backtrace[0..5].map {|x| \"\\n\\t#{x}\" }.join + \"\\n\")\n    end",
        "comment": "Prints the backtrace +exc+ to the logger as error data.  @param [Array<String>] exc the backtrace list @param [Symbol] level_meth the level to log backtrace at @return [void]",
        "label": "What",
        "id": "145"
    },
    {
        "raw_code": "def _reduce_111(val, _values, result)\n      result = inline val[0]\n\n    result\nend",
        "comment": "reduce 110 omitted",
        "label": "What",
        "id": "16554"
    },
    {
        "raw_code": "def update(*other_hashes, &block)\n      if other_hashes.size == 1\n        update_with_single_argument(other_hashes.first, block)\n      else\n        other_hashes.each do |other_hash|\n          update_with_single_argument(other_hash, block)\n        end",
        "comment": "Updates the receiver in-place, merging in the hashes passed as arguments:  hash_1 = ActiveSupport::HashWithIndifferentAccess.new hash_1[:key] = 'value'  hash_2 = ActiveSupport::HashWithIndifferentAccess.new hash_2[:key] = 'New Value!'  hash_1.update(hash_2) # => {\"key\"=>\"New Value!\"}  hash = ActiveSupport::HashWithIndifferentAccess.new hash.update({ \"a\" => 1 }, { \"b\" => 2 }) # => { \"a\" => 1, \"b\" => 2 }  The arguments can be either an +ActiveSupport::HashWithIndifferentAccess+ or a regular +Hash+. In either case the merge respects the semantics of indifferent access.  If the argument is a regular hash with keys +:key+ and <tt>\"key\"</tt> only one of the values end up in the receiver, but which one is unspecified.  When given a block, the value for duplicated keys will be determined by the result of invoking the block with the duplicated key, the value in the receiver, and the value in +other_hash+. The rules for duplicated keys follow the semantics of indifferent access:  hash_1[:key] = 10 hash_2['key'] = 12 hash_1.update(hash_2) { |key, old, new| old + new } # => {\"key\"=>22}",
        "label": "What",
        "id": "13876"
    },
    {
        "raw_code": "def get(url, options = {})\n      request :get, url, parse_query_and_convenience_headers(options)\n    end",
        "comment": "Make a HTTP GET request  @param url [String] The path, relative to {#api_endpoint} @param options [Hash] Query and header params for request @return [Sawyer::Resource]",
        "label": "What",
        "id": "14902"
    },
    {
        "raw_code": "def find_vagrantfile(search_path, filenames=nil)\n      filenames ||= [\"Vagrantfile\", \"vagrantfile\"]\n      filenames.each do |vagrantfile|\n        current_path = search_path.join(vagrantfile)\n        return current_path if current_path.file?\n      end",
        "comment": "Finds the Vagrantfile in the given directory.  @param [Pathname] path Path to search in. @return [Pathname]",
        "label": "What",
        "id": "8879"
    },
    {
        "raw_code": "def knapsack_report\n        return @knapsack_report if @knapsack_report\n        return @knapsack_report = {} unless test_runtime_report_file && File.exist?(test_runtime_report_file)\n\n        @knapsack_report = JSON.parse(File.read(test_runtime_report_file)) # rubocop:disable Gitlab/Json -- not in Rails environment\n      rescue JSON::ParserError, Errno::ENOENT, Errno::EACCES => e\n        logger.error(\"Failed to parse knapsack report #{e.message}\")\n        logger.error(e.backtrace.select { |entry| entry.include?(project_root) }) if e.backtrace\n        @knapsack_report = {}\n      end",
        "comment": "Knapsack report from CI environment which maps specs to runtime Used to create project test runtime metric for predictive rspec tests  @return [Hash]",
        "label": "What",
        "id": "8134"
    },
    {
        "raw_code": "def access_token_revoked(user, token_name, source = nil)\n    return unless user.can?(:receive_notifications)\n\n    mailer.access_token_revoked_email(user, token_name, source).deliver_later\n  end",
        "comment": "Notify the user when one of their personal access tokens is revoked",
        "label": "What",
        "id": "5458"
    },
    {
        "raw_code": "def print_y_axis(values, request, limit, effective_width, graph_max)\n          scale = graph_max.to_f / GRAPH_HEIGHT\n          request_row = request ? (request / scale).ceil : 0\n          limit_row = limit ? (limit / scale).ceil : 0\n\n          # Print graph from top to bottom\n          GRAPH_HEIGHT.downto(1) do |row|\n            threshold = row * scale\n            print format(\"%6.0f \", threshold)\n            print \"\u2502\"\n\n            # Sample values to fit effective width\n            sample_size = [values.length, effective_width].min\n            step = values.length.to_f / sample_size\n\n            sample_size.times do |i|\n              index = (i * step).to_i\n              value = values[index][:val]\n\n              if !value.zero? && value >= threshold\n                # Use different characters based on proximity to limit\n                if limit && value > limit * 0.9\n                  print \"\u2588\"  # High usage (>90% of limit)\n                elsif limit && value > limit * 0.7\n                  print \"\u2593\"  # Medium usage (>70% of limit)\n                else\n                  print \"\u2592\"  # Normal usage\n                end",
        "comment": "Print Y axis and metrics  @param values [Array<Hash>] @param request [Integer] @param limit [Integer] @param effective_width [Integer] @param graph_max [Integer] @return [void]",
        "label": "What",
        "id": "3951"
    },
    {
        "raw_code": "def finder_options\n    params[:state] = default_state if params[:state].blank?\n\n    options = {\n      scope: params[:scope],\n      state: params[:state],\n      confidential: Gitlab::Utils.to_boolean(params[:confidential]),\n      sort: set_sort_order\n    }\n\n    # Used by view to highlight active option\n    @sort = options[:sort]\n\n    # When a user looks for an exact iid, we do not filter by search but only by iid\n    if params[:search] =~ /^#(?<iid>\\d+)\\z/\n      options[:iids] = Regexp.last_match[:iid]\n      params[:search] = nil\n    end",
        "comment": "rubocop:disable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "6510"
    },
    {
        "raw_code": "def test_url_for_with_no_side_effects\n    draw do\n      get \"/projects/status(.:format)\"\n    end",
        "comment": "tests the use of dup in url_for",
        "label": "What",
        "id": "11673"
    },
    {
        "raw_code": "def check!(expiry = duplicate_key_ttl)\n          my_cookie = Cookie.new(\n            jid: jid,\n            existing_wal_locations: job_wal_locations\n          )\n\n          # Signal to any server middleware for the same idempotency_key that\n          # there is at least one client middleware performing deduplication checks.\n          #\n          # The server middleware can determine if there is a duplicate job using the signaling key\n          # instead of reading the cookie key. Using a single key, the server can atomically read and delete it.\n          # This prevents a data race between the server and client in trying to read/write the key.\n          #\n          # There are 2 cases for deleting this key:\n          # 1. Server middleware's until_executed strategy atomically reads and delete it. Reschedules if key exists.\n          # 2. Client deletes key if job is not deduplicated.\n          set_signaling_key(expiry)\n\n          # There are 3 possible scenarios. In order of decreasing likelihood:\n          # 1. SET NX succeeds.\n          # 2. SET NX fails, GET succeeds.\n          # 3. SET NX fails, the key expires and GET fails. In this case we must retry.\n          actual_cookie = {}\n          while actual_cookie.empty?\n            write_succeeded = my_cookie.write(cookie_key, expiry)\n            actual_cookie = write_succeeded ? my_cookie.cookie : get_cookie\n          end",
        "comment": "This method will return the jid that was set in redis",
        "label": "What",
        "id": "2764"
    },
    {
        "raw_code": "def _TitleSingle\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"'\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "TitleSingle = \"'\" (!(\"'\" @Sp (\")\" | @Newline)) .)* \"'\"",
        "label": "What",
        "id": "15771"
    },
    {
        "raw_code": "def run_pre_installation_setup; end\n\n          # Run post-installation setup\n          #\n          # @return [void]\n          def run_post_installation_setup\n            wait_for_gitlab_ready\n          end\n\n          # Docker container configuration values\n          #\n          # @return [Hash]\n          def values\n            {\n              image: image,\n              environment: {\n                GITLAB_OMNIBUS_CONFIG: omnibus_config,\n                GITLAB_ROOT_PASSWORD: admin_password\n              },\n              ports: {\n                \"#{host_http_port}:80\" => nil\n              },\n              restart: \"always\"\n            }\n          end\n\n          # Gitlab url\n          #\n          # @return [String]\n          def gitlab_url\n            @gitlab_url ||= URI(\"http://#{gitlab_domain}:#{host_http_port}\").to_s\n          end\n\n          private\n\n          attr_reader :image, :admin_password, :host_http_port\n\n          # Wait for GitLab to be ready\n          #\n          # @return [void]\n          def wait_for_gitlab_ready\n            Helpers::Spinner.spin(\"Waiting for GitLab to be ready. This may take a while...\") do\n              gitlab_ready = false\n\n              30.times do\n                begin\n                  response = Net::HTTP.get_response(URI(\"#{gitlab_url}/users/sign_in\"))\n                  if response.code == \"200\"\n                    log(\"GitLab is ready! \ud83d\ude80\", :success)\n                    gitlab_ready = true\n                    break\n                  end\n                rescue StandardError => e\n                  log(\"GitLab is not ready yet. Reason: #{e.message}\", :debug)\n                end",
        "comment": "Run pre-installation setup  @return [void]",
        "label": "What",
        "id": "3943"
    },
    {
        "raw_code": "def up\n    prepare_partitioned_async_index(TABLE_NAME, COLUMN_NAMES_1, name: INDEX_NAME_1)\n    prepare_partitioned_async_index(TABLE_NAME, COLUMN_NAMES_2, name: INDEX_NAME_2)\n  end",
        "comment": "TODO: Index to be created synchronously in https://gitlab.com/gitlab-org/gitlab/-/issues/514158",
        "label": "What",
        "id": "4949"
    },
    {
        "raw_code": "def handle_closing_issue!(issue, current_user)\n      issue.close(current_user)\n    end",
        "comment": "overriden in EE",
        "label": "What",
        "id": "5726"
    },
    {
        "raw_code": "def image_safe_for_scaling?\n      extension_match?(SAFE_IMAGE_FOR_SCALING_EXT)\n    end",
        "comment": "For the time being, we restrict image scaling requests to the most popular and safest formats only, which are JPGs and PNGs. See https://gitlab.com/gitlab-org/gitlab/-/issues/237848 for more info.",
        "label": "What",
        "id": "1637"
    },
    {
        "raw_code": "def get_user_ip_address(user_id)\n        raise \"Only admin can get user's ip address\" unless admin?\n\n        parse_body(api_get_from(\"/users/#{user_id}\"))[:last_sign_in_ip]\n      end",
        "comment": "Get users last sign in ip address  @param user_id [Integer] @return [String]",
        "label": "What",
        "id": "4185"
    },
    {
        "raw_code": "def perform\n      # Do small batched updates because these updates will be slow and locking\n      Project.select(:id).find_in_batches(batch_size: 100) do |batch|\n        Project.where(id: batch.map(&:id)).update_all(\n          last_repository_check_failed: nil,\n          last_repository_check_at: nil\n        )\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6370"
    },
    {
        "raw_code": "def _StartList\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = get_byte\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "StartList = &. { [] }",
        "label": "What",
        "id": "15816"
    },
    {
        "raw_code": "def build(deployment, status, status_changed_at)\n        # Deployments will not have a deployable when created using the API.\n        deployable_url =\n          if deployment.deployable.instance_of?(::Ci::Build)\n            Gitlab::UrlBuilder.build(deployment.deployable)\n          end",
        "comment": "NOTE: Time-sensitive attributes should be explicitly passed as argument instead of reading from database.",
        "label": "What",
        "id": "1781"
    },
    {
        "raw_code": "def request_url(path, **opts)\n        Runtime::API::Request.new(api_client, path, **opts).url\n      end",
        "comment": "Get api request url  @param [String] path @return [String]",
        "label": "What",
        "id": "4120"
    },
    {
        "raw_code": "def self.load_yaml\n    begin\n      gem 'psych'\n    rescue NameError => e # --disable-gems\n      raise unless e.name == :gem\n    rescue Gem::LoadError\n    end",
        "comment": " Loads the best available YAML library.",
        "label": "What",
        "id": "15500"
    },
    {
        "raw_code": "def update\n    respond_to do |format|\n      if @book.update(book_params)\n        format.html { redirect_to @book, notice: 'Book was successfully updated.' } # aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n        format.json { render :show, status: :ok, location: @book }\n      else\n        format.html { render :edit }\n        format.json { render json: @book.errors, status: :unprocessable_entity }\n      end",
        "comment": "PATCH/PUT /books/1 PATCH/PUT /books/1.json",
        "label": "What",
        "id": "10749"
    },
    {
        "raw_code": "def class_document(name, found, klasses, includes, extends)\n    also_in = []\n\n    out = RDoc::Markup::Document.new\n\n    add_class out, name, klasses\n\n    add_includes out, includes\n    add_extends  out, extends\n\n    found.each do |store, klass|\n      render_class out, store, klass, also_in\n    end",
        "comment": " Builds a RDoc::Markup::Document from +found+, +klasess+ and +includes+",
        "label": "What",
        "id": "16587"
    },
    {
        "raw_code": "def report_progress(progress, total, show_parts=true)\n        if total && total > 0\n          percent = (progress.to_f / total.to_f) * 100\n          line    = \"Progress: #{percent.to_i}%\"\n          line   << \" (#{progress} / #{total})\" if show_parts\n        else\n          line    = \"Progress: #{progress}\"\n        end",
        "comment": "This is used to output progress reports to the UI. Send this method progress/total and it will output it to the UI. Send `clear_line` to clear the line to show a continuous progress meter.",
        "label": "What",
        "id": "8806"
    },
    {
        "raw_code": "def run_pre_deployment_setup\n            create_initial_root_password\n            create_pre_receive_hook\n          end",
        "comment": "Run pre-deployment setup  @return [void]",
        "label": "What",
        "id": "4021"
    },
    {
        "raw_code": "def tags(repo, options = {})\n        paginate \"#{Repository.path repo}/tags\", options\n      end",
        "comment": "List tags  Requires authenticated client for private repos.  @param repo [Integer, String, Hash, Repository] A GitHub repository. @return [Array<Sawyer::Resource>] Array of hashes representing tags. @see https://developer.github.com/v3/repos/#list-tags @example Octokit.tags('octokit/octokit.rb') @example @client.tags('octokit/octokit.rb')",
        "label": "What",
        "id": "15158"
    },
    {
        "raw_code": "def manage_ghes_endpoint=(value)\n      reset_agent\n      @manage_ghes_endpoint = value\n    end",
        "comment": "Set Manage GHES API endpoint  @param value [String] Manage GHES API endpoint",
        "label": "What",
        "id": "14899"
    },
    {
        "raw_code": "def commit_comment_reactions(repo, id, options = {})\n        get \"#{Repository.path repo}/comments/#{id}/reactions\", options\n      end",
        "comment": "List reactions for a commit comment  @param repo [Integer, String, Hash, Repository] A GitHub repository @param id [Integer] The id of the commit comment @see https://developer.github.com/v3/reactions/#list-reactions-for-a-commit-comment  @example @client.commit_comment_reactions(\"octokit/octokit.rb\", 1)  @return [Array<Sawyer::Resource>] Array of Hashes representing the reactions.",
        "label": "What",
        "id": "15402"
    },
    {
        "raw_code": "def self.darwin_major_version(machine)\n          output = \"\"\n          machine.communicate.sudo(\"sysctl kern.osrelease\") do |_, data|\n            output = data\n          end",
        "comment": "Get the darwin major version  @param [Machine] @return [int] major version of drawin (nil if version is not detected)",
        "label": "What",
        "id": "9833"
    },
    {
        "raw_code": "def highlighted_area\n        Parser::Source::Range.new(source_line, column, column + column_length)\n      end",
        "comment": "@api public  @return [Parser::Source::Range] the range of the code that is highlighted",
        "label": "What",
        "id": "10234"
    },
    {
        "raw_code": "def resolve(sort:, **filters)\n      return unless packages_available?\n\n      params = filters.merge(SORT_TO_PARAMS_MAP.fetch(sort))\n      params[:preload_pipelines] = false\n\n      ::Packages::PackagesFinder.new(object, params).execute\n    end",
        "comment": "The GraphQL type is defined in the extended class",
        "label": "What",
        "id": "6172"
    },
    {
        "raw_code": "def _HtmlBlockH2\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenH2)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockH2 = HtmlBlockOpenH2 (HtmlBlockH2 | !HtmlBlockCloseH2 .)* HtmlBlockCloseH2",
        "label": "What",
        "id": "15655"
    },
    {
        "raw_code": "def debug_msg *msg\n    return unless $DEBUG_RDOC\n    $stderr.puts(*msg)\n  end",
        "comment": " Output progress information if debugging is enabled",
        "label": "What",
        "id": "16454"
    },
    {
        "raw_code": "def graph_width\n          return @graph_width if @graph_width\n          return @graph_width = [[max_width, MIN_GRAPH_WIDTH].max, MAX_GRAPH_WIDTH].min if max_width.positive?\n\n          begin\n            width = IO.console.winsize[1]\n          rescue NoMethodError\n            width = DEFAULT_GRAPH_WIDTH\n          end",
        "comment": "Graph width based on terminal size or specified max width  @return [Integer]",
        "label": "What",
        "id": "3948"
    },
    {
        "raw_code": "def default(\n      icon: :group,\n      href: \"gitlab.com\",\n      description: \"Groups are the best way to manage projects and members\",\n      title: \"Create a group\")\n      render Onboarding::ActionCardComponent.new(\n        title: title,\n        description: description,\n        icon: icon,\n        href: href\n      )\n    end",
        "comment": "Action card ---  @param icon select [~, star-o, issue-closed, group] @param href url @param description text @param title text",
        "label": "What",
        "id": "8186"
    },
    {
        "raw_code": "def self.available?\n            ENV.key?(OMNIBUS_CONFIG_ENV) && omnibus_config_filepath.exist?\n          end",
        "comment": "Is the tool running in an Omnibus installation?  @return [Boolean]",
        "label": "What",
        "id": "1102"
    },
    {
        "raw_code": "def report_exception?(exception)\n      return true unless exception.respond_to?(:status)\n\n      exception.status == 500\n    end",
        "comment": "We could get a Grape or a standard Ruby exception. We should only report anything that is clearly an error.",
        "label": "What",
        "id": "3799"
    },
    {
        "raw_code": "def dir\n          Pathname.new(File.join(cache_path, project_dir_cache_key)).tap do |d|\n            d.mkpath unless d.exist?\n          end",
        "comment": "rubocop:enable Metrics/AbcSize",
        "label": "What",
        "id": "10727"
    },
    {
        "raw_code": "def hash\n      id = self.id\n\n      if self.class.composite_primary_key? ? primary_key_values_present? : id\n        self.class.hash ^ id.hash\n      else\n        super\n      end",
        "comment": "Delegates to id in order to allow two records of the same type and id to work with something like: [ Person.find(1), Person.find(2), Person.find(3) ] & [ Person.find(1), Person.find(4) ] # => [ Person.find(1) ]",
        "label": "What",
        "id": "12430"
    },
    {
        "raw_code": "def load_all\n        thread_local_store.load_all\n        self\n      end",
        "comment": "Forces all objects cached on disk into memory  @example Loads all objects from disk Registry.load Registry.all.count #=> 0 Registry.load_all Registry.all.count #=> 17 @return [Registry] the registry object (for chaining) @since 0.5.1",
        "label": "What",
        "id": "62"
    },
    {
        "raw_code": "def reverse_merge!(other_hash)\n    replace(reverse_merge(other_hash))\n  end",
        "comment": "Destructive +reverse_merge+.",
        "label": "What",
        "id": "14245"
    },
    {
        "raw_code": "def request_store_cache\n      raise NotImplementedError\n    end",
        "comment": "RequestStore-backed RepositoryCache to be used. Should be overridden by the including class",
        "label": "What",
        "id": "1704"
    },
    {
        "raw_code": "def key_params\n    params.require(:user_id, :id)\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6463"
    },
    {
        "raw_code": "def wait_for_login_page_to_load\n        return validate_readiness_via_ui! if Runtime::Env.running_on_live_env?\n\n        response = fetch_sign_in_page\n        return validate_readiness_via_ui! if cloudflare_response?(response)\n\n        debug(\"Checking for required elements via api\")\n        Support::Retrier.retry_on_exception(max_attempts: wait, sleep_interval: 1, log: false) do\n          # re-use initial response from cloudflare check\n          response ||= fetch_sign_in_page\n          validate_readiness_via_api!(response)\n        ensure\n          response = nil\n        end",
        "comment": "Check if sign_in page loads with all required elements  @return [void]",
        "label": "What",
        "id": "4696"
    },
    {
        "raw_code": "def ready?\n        @globalized && @localized\n      end",
        "comment": "@return [Boolean] local and global plugins are loaded",
        "label": "What",
        "id": "8954"
    },
    {
        "raw_code": "def pull_request_review(repo, number, review, options = {})\n        get \"#{Repository.path repo}/pulls/#{number}/reviews/#{review}\", options\n      end",
        "comment": "Get a single review  @param repo [Integer, String, Hash, Repository] A GitHub repository @param number [Integer] Number ID of the pull request @param review [Integer] The id of the review @see https://developer.github.com/v3/pulls/reviews/#get-a-single-review  @example @client.pull_request_review('octokit/octokit.rb', 825, 6505518)  @return [Sawyer::Resource] Hash representing the review",
        "label": "What",
        "id": "15000"
    },
    {
        "raw_code": "def current_personal_access_token\n        api_client.personal_access_token\n      end",
        "comment": "Return personal access token currently used by user resource for all api operations  @return [String]",
        "label": "What",
        "id": "4192"
    },
    {
        "raw_code": "def unregister(sig_callback)\n          @@mutex.synchronize do\n            registered.delete(sig_callback)\n\n            # Remove the signal trap if no more registered callbacks exist\n            Signal.trap(\"INT\", \"DEFAULT\") if registered.empty?\n          end",
        "comment": "Unregisters a SIGINT handler.",
        "label": "What",
        "id": "9284"
    },
    {
        "raw_code": "def missing_partitions\n            desired_partitions - current_partitions\n          end",
        "comment": "Check the currently existing partitions and determine which ones are missing",
        "label": "What",
        "id": "3214"
    },
    {
        "raw_code": "def dispatch!\n      # Avoid passing frozen string in force_encoding\n      @params.merge!(@request.params).each do |key, val|\n        next unless val.respond_to?(:force_encoding)\n\n        val = val.dup if val.frozen?\n        @params[key] = force_encoding(val)\n      end",
        "comment": "Dispatch a request with error handling.",
        "label": "What",
        "id": "8590"
    },
    {
        "raw_code": "def generate\n      return if @spec.default_gem?\n      return unless @generate_yri || @generate_yard\n\n      setup\n\n      install_yri if @generate_yri && (@force || !File.exist?(@yri_dir))\n\n      install_yard if @generate_yard && (@force || !File.exist?(@yard_dir))\n    end",
        "comment": " Generates YARD and yri data",
        "label": "What",
        "id": "254"
    },
    {
        "raw_code": "def updated?\n        !ignore? && !removed? && mtime != File.mtime(path)\n      end",
        "comment": "Indicates whether or not the file being watched has been modified.",
        "label": "What",
        "id": "8629"
    },
    {
        "raw_code": "def end_of_line_comment(line) # rubocop:disable Naming/PredicateMethod\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `end_of_line_comment` is deprecated. Use `processed_source.line_with_comment?` instead.\n        WARNING\n\n        processed_source.line_with_comment?(line)\n      end",
        "comment": "@deprecated Use processed_source.line_with_comment?(line)",
        "label": "What",
        "id": "10429"
    },
    {
        "raw_code": "def find_unique(all_hash)\n    unique = []\n\n    all_hash.each_pair do |full_name, cm|\n      unique << cm if full_name == cm.full_name\n    end",
        "comment": " Finds unique classes/modules defined in +all_hash+, and returns them as an array. Performs the alias updates in +all_hash+: see ::complete. -- TODO  aliases should be registered by Context#add_module_alias",
        "label": "What",
        "id": "15868"
    },
    {
        "raw_code": "def store=(store)\n    super\n\n    @attributes .each do |attr|  attr.store  = store end\n    @constants  .each do |const| const.store = store end\n    @includes   .each do |incl|  incl.store  = store end\n    @extends    .each do |ext|   ext.store   = store end\n    @method_list.each do |meth|  meth.store  = store end\n  end",
        "comment": " Sets the store for this class or module and its contained code objects.",
        "label": "What",
        "id": "16762"
    },
    {
        "raw_code": "def execute_incident_hooks(issue, issue_data)\n      issue_data[:object_kind] = 'incident'\n      issue_data[:event_type] = 'incident'\n      issue.namespace.execute_integrations(issue_data, :incident_hooks)\n    end",
        "comment": "We can remove this code after proposal in https://gitlab.com/gitlab-org/gitlab/-/issues/367550#proposal is updated.",
        "label": "What",
        "id": "5735"
    },
    {
        "raw_code": "def since(time = ::Time.current)\n      sum(1, time)\n    end",
        "comment": "Calculates a new Time or Date that is as far in the future as this Duration represents.",
        "label": "What",
        "id": "13827"
    },
    {
        "raw_code": "def to_h\n        ok? ? { ok: value } : { err: value }\n      end",
        "comment": "`to_h` supports destructuring of a result object, for example: `result => { ok: }; puts ok`  @return [Hash]",
        "label": "What",
        "id": "2385"
    },
    {
        "raw_code": "def link_include_file(file)\n        unless file.is_a?(CodeObjects::ExtraFileObject)\n          file = CodeObjects::ExtraFileObject.new(file)\n        end",
        "comment": "(see BaseHelper#link_include_file)",
        "label": "What",
        "id": "404"
    },
    {
        "raw_code": "def on_def(begin_line, *)\n        @begins_to_ends[begin_line] = lineno\n      end",
        "comment": "method test e.g. `def test_some_description` This event's first argument gets the `ident` node containing the method name, which we have overridden to return the line number of the ident instead.",
        "label": "What",
        "id": "14823"
    },
    {
        "raw_code": "def flipper\n      if stub?\n        @flipper ||= Flipper.new(Flipper::Adapters::Memory.new)\n      else\n        super\n      end",
        "comment": "Replace #flipper method with the optional stubbed/unstubbed version.",
        "label": "What",
        "id": "8461"
    },
    {
        "raw_code": "def initialize(\n      author:, scope:, target:, message:,\n      created_at: DateTime.current, additional_details: {}, ip_address: nil, target_details: nil)\n      raise MissingAttributeError, \"author\" if author.blank?\n      raise MissingAttributeError, \"target\" if target.blank?\n      raise MissingAttributeError, \"message\" if message.blank?\n\n      validate_scope!(scope)\n\n      @author = build_author(author)\n      @scope = scope\n      @target = build_target(target)\n      @ip_address = ip_address || build_ip_address\n      @message = build_message(message)\n      @created_at = created_at\n      @additional_details = additional_details\n      @target_details = target_details\n    end",
        "comment": "@raise [MissingAttributeError] when required attributes are blank  @return [BuildService]",
        "label": "What",
        "id": "5645"
    },
    {
        "raw_code": "def bad_request?\n      status == 400\n    end",
        "comment": "whether or not the status is set to 400",
        "label": "What",
        "id": "8570"
    },
    {
        "raw_code": "def find_coverage_reports\n    unless has_coverage_reports?\n      return { status: :error, status_reason: 'This merge request does not have coverage reports' }\n    end",
        "comment": "TODO: this method and compare_test_reports use the same result type, which is handled by the controller's #reports_response. we should minimize mistakes by isolating the common parts. issue: https://gitlab.com/gitlab-org/gitlab/issues/34224",
        "label": "What",
        "id": "6989"
    },
    {
        "raw_code": "def add_visibility_verifier\n        vis_expr = \"#{visibilities.uniq.inspect}.include?(object.visibility)\"\n        options.verifier.add_expressions(vis_expr)\n      end",
        "comment": "Adds verifier rule for visibilities @return [void] @since 0.5.6",
        "label": "What",
        "id": "537"
    },
    {
        "raw_code": "def cop_header(cop)\n    content = +\"\\n\"\n    content << \"[##{to_anchor(cop.cop_name)}]\\n\"\n    content << \"== #{cop.cop_name}\\n\"\n    content << \"\\n\"\n    content\n  end",
        "comment": "rubocop:enable Metrics/MethodLength",
        "label": "What",
        "id": "10143"
    },
    {
        "raw_code": "def remove!(*patterns)\n    patterns.each do |pattern|\n      gsub! pattern, \"\"\n    end",
        "comment": "Alters the string by removing all occurrences of the patterns. str = \"foo bar test\" str.remove!(\" test\", /bar/)         # => \"foo \" str                                 # => \"foo \"",
        "label": "What",
        "id": "14356"
    },
    {
        "raw_code": "def get(path, **options)\n      options[:env] ||= {}\n      options[:env][\"action_dispatch.key_generator\"] ||= Generator\n      options[:env][\"action_dispatch.cookies_rotations\"] = Rotations\n      options[:env][\"action_dispatch.signed_cookie_salt\"] = SIGNED_COOKIE_SALT\n      super(path, **options)\n    end",
        "comment": "Overwrite get to send SessionSecret in env hash",
        "label": "What",
        "id": "11663"
    },
    {
        "raw_code": "def custom_action\n        :new_note\n      end",
        "comment": "A new review is a batch of new notes therefore new_note subscribers should also receive incoming new reviews",
        "label": "What",
        "id": "6069"
    },
    {
        "raw_code": "def initialize(organization:, current_user:)\n      @organization = organization\n      @current_user = current_user\n    end",
        "comment": "@param organization [Organizations::Organization] @param current_user [User]",
        "label": "What",
        "id": "7968"
    },
    {
        "raw_code": "def configured?\n      raise NotImplementedError\n    end",
        "comment": "This is a light-weight check if a prometheus client is properly configured.",
        "label": "What",
        "id": "7316"
    },
    {
        "raw_code": "def install_sharding_key_assignment_trigger(**args)\n        Gitlab::Database::Triggers::AssignDesiredShardingKey.new(**args.merge(connection: connection)).create\n      end",
        "comment": "Installs a trigger in a table that assigns a sharding key from an associated table.  table: The table to install the trigger in. sharding_key: The column to be assigned on `table`. parent_table: The associated table with the sharding key to be copied. parent_sharding_key: The sharding key on the parent table that will be copied to `sharding_key` on `table`. foreign_key: The column used to fetch the relevant record from `parent_table`.",
        "label": "What",
        "id": "2985"
    },
    {
        "raw_code": "def get_rdp_info(machine)\n        rdp_info = {}\n        if machine.provider.capability?(:rdp_info)\n          rdp_info = machine.provider.capability(:rdp_info)\n          rdp_info ||= {}\n        end",
        "comment": "Generate RDP information for machine  @param [Vagrant::Machine] machine Guest machine @return [Hash, nil]",
        "label": "What",
        "id": "9791"
    },
    {
        "raw_code": "def add_suggestion(filename:, regex:, replacement: nil, comment_text: nil, exclude: nil, once_per_file: false)\n        added_lines = added_lines_matching(filename, regex)\n\n        return if added_lines.empty?\n\n        file_lines = project_helper.file_lines(filename)\n\n        added_lines.each_with_object([]) do |added_line, processed_line_numbers|\n          break if once_per_file && processed_line_numbers.any?\n\n          line_number = find_line_number(file_lines, added_line.delete_prefix('+'),\n            exclude_indexes: processed_line_numbers)\n\n          next unless line_number\n          next if !exclude.nil? && added_line.include?(exclude)\n\n          processed_line_numbers << line_number\n\n          if replacement\n            suggestion_text = file_lines[line_number]\n            suggestion_text = suggestion_text.gsub(regex, replacement)\n          end",
        "comment": "For file lines matching `regex` adds suggestion `replacement` with `comment_text` added.",
        "label": "What",
        "id": "8169"
    },
    {
        "raw_code": "def accessible_projects\n    params.projects\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7909"
    },
    {
        "raw_code": "def _reduce_2(val, _values, result)\n result.append val[1]\n    result\nend",
        "comment": "State transition tables end ##### reduce 0 omitted reduce 1 omitted",
        "label": "What",
        "id": "16543"
    },
    {
        "raw_code": "def array_aggregated_column\n            Arel::Nodes::NamedFunction.new('ARRAY_AGG', [column_expression]).as(array_aggregated_column_name)\n          end",
        "comment": "Generates: SELECT ARRAY_AGG(...) AS issues_name_array",
        "label": "What",
        "id": "2017"
    },
    {
        "raw_code": "def initialize(name, module_name, method_name, transaction)\n        @module_name = module_name\n        @method_name = method_name\n        @transaction = transaction\n        @name = name\n        @labels = { module: @module_name, method: @method_name }\n        @real_time = 0.0\n        @cpu_time = 0.0\n        @call_count = 0\n      end",
        "comment": "name - The full name of the method (including namespace) such as `User#sign_in`. ",
        "label": "What",
        "id": "2292"
    },
    {
        "raw_code": "def remote_object_exists?(object)\n        raise NotImplementedError\n      end",
        "comment": "Be sure to perform a hard check of the remote object (don't just check DB value)",
        "label": "What",
        "id": "2290"
    },
    {
        "raw_code": "def each_page(method, representation_type, *args)\n      options =\n        if args.last.is_a?(Hash)\n          args.last\n        else\n          {}\n        end",
        "comment": "Fetches data from the Bitbucket API and yields a Page object for every page of data, without loading all of them into memory.  method - The method name used for getting the data. representation_type - The representation type name used to wrap the result args - Arguments to pass to the method.",
        "label": "What",
        "id": "3360"
    },
    {
        "raw_code": "def net_set_mac(mac_addr)\n        execute(:set_network_mac, VmId: vm_id, Mac: mac_addr)\n      end",
        "comment": "Set the VM adapter MAC address  @param [String] mac_addr MAC address @return [nil]",
        "label": "What",
        "id": "9680"
    },
    {
        "raw_code": "def initialize(source)\n            @source = source\n            @config = nil\n\n            load!\n          end",
        "comment": "@param [String|Pathname] source",
        "label": "What",
        "id": "1089"
    },
    {
        "raw_code": "def parse_release(unreleased)\n    unreleased\n      .lines\n      .map(&:chomp)\n      .reject(&:empty?)\n      .slice_before(HEADER)\n      .to_h do |header, *entries|\n        [HEADER.match(header)[1], entries]\n      end",
        "comment": "@return [Hash<type, Array<String>]]",
        "label": "What",
        "id": "10734"
    },
    {
        "raw_code": "def create_member_method?(klass, member, type = :read)\n    return true if (klass.tags(:attr) + klass.tags(:attr_reader) + klass.tags(:attr_writer)).empty?\n    return true if member_tag_for_member(klass, member, type)\n    return !member_tag_for_member(klass, member, :write) if type == :read\n    !member_tag_for_member(klass, member, :read)\n  end",
        "comment": "Determines whether to create an attribute method based on the class's tags.  @param [ClassObject] klass the class whose tags we're searching @param [String] member the name of the struct member we need @param [Symbol] type (:read) reader method, or writer method? @return [Boolean] should the attribute be created?",
        "label": "What",
        "id": "199"
    },
    {
        "raw_code": "def ensure_root_container_repository!\n        ::ContainerRegistry::Path.new(@project.full_path).tap do |path|\n          break if path.has_repository?\n\n          ::ContainerRepository.build_from_path(path).tap do |repository|\n            repository.save! if repository.has_tags?\n          end",
        "comment": " Container repository object for root project path.  Needed to maintain a backwards compatibility. ",
        "label": "What",
        "id": "6647"
    },
    {
        "raw_code": "def constant_prefix(node)\n          if node.each_ancestor(:class, :module).any?\n            '::'\n          else\n            ''\n          end",
        "comment": "@private @param [RuboCop::AST::Node] node @return [String]",
        "label": "What",
        "id": "10514"
    },
    {
        "raw_code": "def pipelined_both(command_name, *args, **kwargs, &block)\n        result_default = send_command(default_store, command_name, *args, **kwargs, &block)\n\n        begin\n          result_non_default = send_command(non_default_store, command_name, *args, **kwargs, &block)\n        rescue StandardError => e\n          log_error(e, command_name, multi_store_error_message: FAILED_TO_RUN_PIPELINE)\n        end",
        "comment": "Run the entire pipeline on both stores. We assume that `&block` is idempotent.",
        "label": "What",
        "id": "1904"
    },
    {
        "raw_code": "def possible_class_hierarchy_check?(lhs, rhs, method)\n          CLASS_COMPARISON_METHODS.include?(method) &&\n            (camel_case_constant?(lhs) || (rhs.size == 1 && camel_case_constant?(rhs.first)))\n        end",
        "comment": "When comparing classes, `!(Integer < Numeric)` is not the same as `Integer > Numeric`.",
        "label": "What",
        "id": "10557"
    },
    {
        "raw_code": "def batch_clean(start_id: nil, stop_id: nil, dry_run: true, sleep_time: nil, uploader: nil, since: nil)\n        relation = Upload.where('lower(path) like ? or lower(path) like ? or lower(path) like ?',\n          '%.jpg', '%.jpeg', '%.tiff')\n        relation = relation.where(uploader: uploader) if uploader\n        relation = relation.where('created_at > ?', since) if since\n\n        logger.info \"running in dry run mode, no images will be rewritten\" if dry_run\n\n        find_params = {\n          start: start_id.present? ? start_id.to_i : nil,\n          finish: stop_id.present? ? stop_id.to_i : Upload.last&.id,\n          batch_size: 1000\n        }\n\n        relation.find_each(**find_params) do |upload|\n          clean(upload.retrieve_uploader, dry_run: dry_run)\n          sleep sleep_time if sleep_time\n        rescue StandardError => err\n          logger.error \"failed to sanitize #{upload_ref(upload)}: #{err.message}\"\n          logger.debug err.backtrace.join(\"\\n \")\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2420"
    },
    {
        "raw_code": "def a_star?(target)\n              Node.locate_descendant(target, :a_star)\n            end",
        "comment": "True when `SELECT *`",
        "label": "What",
        "id": "3192"
    },
    {
        "raw_code": "def attached?; method_object ? true : false end\n\n      # Overrides {Base#path} so the macro path is \".macro.MACRONAME\"\n      def path; '.macro.' + name.to_s end\n\n      # Overrides the separator to be '.'\n      def sep; '.' end\n\n      # Expands the macro using\n      # @param [Array<String>] call_params a list of tokens that are passed\n      #   to the method call\n      # @param [String] full_source the full method call (not including the block)\n      # @param [String] block_source the source passed in the block of the method\n      #   call, if there is a block.\n      # @example Expanding a Macro\n      #   macro.expand(%w(property foo bar), 'property :foo, :bar', '') #=>\n      #     \"...macro data interpolating this line of code...\"\n      # @see expand\n      def expand(call_params = [], full_source = '', block_source = '')\n        self.class.expand(macro_data, call_params, full_source, block_source)\n      end\n    end\n  end\nend",
        "comment": "@return [Boolean] whether this macro is attached to a method",
        "label": "What",
        "id": "615"
    },
    {
        "raw_code": "def docker_image_with_digest(docker_image)\n      image, tag = docker_image.split(\":\")\n\n      logger.info(\"Fetching digest for image '#{docker_image}'\")\n      auth_url = \"https://auth.docker.io/token?service=registry.docker.io&scope=repository:library/#{image}:pull\"\n      auth_response = HTTParty.get(auth_url)\n      raise \"Failed to get auth token\" unless auth_response.success?\n\n      token = JSON.parse(auth_response.body)['token']\n      manifest_url = \"https://registry.hub.docker.com/v2/library/#{image}/manifests/#{tag}\"\n      response = HTTParty.head(manifest_url, headers: {\n        'Authorization' => \"Bearer #{token}\",\n        'Accept' => 'application/vnd.docker.distribution.manifest.v2+json'\n      })\n      raise \"Failed to fetch image '#{docker_image}' digest\" unless response.success?\n\n      digest = response.headers['docker-content-digest'] || raise(\"Failed to get image digest\")\n      \"#{image}:#{tag}@#{digest}\"\n    end",
        "comment": "rubocop:disable Gitlab/HTTParty -- CI script Fetch Docker image with digest from DockerHub  @param docker_image [String] @return [String]",
        "label": "What",
        "id": "5278"
    },
    {
        "raw_code": "def permitted_to_skip_email_otp_in_grace_period?(user)\n    Feature.enabled?(:email_based_mfa, user) &&\n      !user.two_factor_enabled? &&\n      trusted_ip_address?(user) &&\n      !treat_as_locked?(user) &&\n      in_email_otp_grace_period?(user)\n  end",
        "comment": "Used by frontend to decide if we should render the \"skip for now\" button",
        "label": "What",
        "id": "7763"
    },
    {
        "raw_code": "def disable(machine, folders, opts)\n        folders.each do |_, data|\n          clean_folder_configuration(data)\n        end",
        "comment": "Nothing to do here but ensure folder options are scrubbed",
        "label": "What",
        "id": "9422"
    },
    {
        "raw_code": "def self.default_timezone=(default_timezone)\n    unless %i(local utc).include?(default_timezone)\n      raise ArgumentError, \"default_timezone must be either :utc (default) or :local.\"\n    end",
        "comment": "Determines whether to use Time.utc (using :utc) or Time.local (using :local) when pulling dates and times from the database. This is set to :utc by default.",
        "label": "What",
        "id": "12339"
    },
    {
        "raw_code": "def update_source_import(repo, options = {})\n        patch \"#{Repository.path repo}/import\", options\n      end",
        "comment": "Update source import with authentication or project choice Restart source import if no options are passed  @param repo [Integer, String, Hash, Repository] A GitHub repository. @return [Sawyer::Resource] Hash representing the repository import @see https://developer.github.com/v3/migration/source_imports/#update-existing-import @option options [String] :vcs_username If authentication is required, the username to provide to vcs_url. @option options [String] :vcs_password If authentication is required, the password to provide to vcs_url. @option options [String] To update project choice, please refer to the project_choice array from the progress return hash for the exact attributes. https://developer.github.com/v3/migration/source_imports/#update-existing-import  @example @client.update_source_import(\"octokit/octokit.rb\", { :vcs_username\" => \"octocat\", :vcs_password  => \"secret\" })",
        "label": "What",
        "id": "15276"
    },
    {
        "raw_code": "def routable_payload(job)\n          {\n            c: Gitlab.config.cell.id,\n            o: job.project.organization_id,\n            u: job.user_id,\n            p: job.project_id,\n            g: job.project.group&.id\n          }.compact_blank.transform_values { |id| id.to_s(36) }\n        end",
        "comment": "Creating routing information for routable tokens https://handbook.gitlab.com/handbook/engineering/architecture/design-documents/cells/routable_tokens/",
        "label": "What",
        "id": "3583"
    },
    {
        "raw_code": "def enqueue_catalog_resource_sync_event_worker\n    run_after_commit do\n      ::Ci::Catalog::Resources::SyncEvent.enqueue_worker\n    end",
        "comment": "Catalog resource SyncEvents are created by PG triggers",
        "label": "What",
        "id": "6782"
    },
    {
        "raw_code": "def link_to(...)\n    ApplicationController.helpers.link_to(...)\n  end",
        "comment": "Avoid including ActionView::Helpers::UrlHelper",
        "label": "What",
        "id": "5408"
    },
    {
        "raw_code": "def blob(repo, blob_sha, options = {})\n        get \"#{Repository.path repo}/git/blobs/#{blob_sha}\", options\n      end",
        "comment": "Get a single blob, fetching its content and encoding  @param repo [Integer, String, Hash, Repository] A GitHub repository @param blob_sha [String] The SHA of the blob to fetch @return [Sawyer::Resource] A hash representing the fetched blob @see https://developer.github.com/v3/git/blobs/#get-a-blob @example Fetch a blob and inspect its contents blob = Octokit.blob(\"octocat/Hello-World\", \"827efc6d56897b048c772eb4087f854f46256132\") blob.encoding # => \"utf-8\" blob.content # => \"Foo bar baz\" @example Fetch a base64-encoded blob and inspect its contents require \"base64\" blob = Octokit.blob(\"octocat/Hello-World\", \"827efc6d56897b048c772eb4087f854f46256132\") blob.encoding # => \"base64\" blob.content # => \"Rm9vIGJhciBiYXo=\" Base64.decode64(blob.content) # => \"Foo bar baz\"",
        "label": "What",
        "id": "15110"
    },
    {
        "raw_code": "def list_events(project_id, fingerprint, opts = {})\n      data, _status_code, _headers = list_events_with_http_info(project_id, fingerprint, opts)\n      data\n    end",
        "comment": "Get information about the events related to the error @param project_id [Integer] ID of the project where the error was created @param fingerprint [Integer] ID of the error within the project @param [Hash] opts the optional parameters @option opts [String] :sort  (default to 'occurred_at_asc') @option opts [String] :cursor Base64 encoded information for pagination @option opts [Integer] :limit Number of entries to return (default to 20) @return [Array<ErrorEvent>]",
        "label": "What",
        "id": "1004"
    },
    {
        "raw_code": "def _HtmlBlockCloseH6\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseH6 = \"<\" Spnl \"/\" (\"h6\" | \"H6\") Spnl \">\"",
        "label": "What",
        "id": "15666"
    },
    {
        "raw_code": "def up\n    prepare_async_index :vulnerability_occurrence_pipelines, :project_id, name: INDEX_NAME\n  end",
        "comment": "-- Legacy migration",
        "label": "What",
        "id": "4893"
    },
    {
        "raw_code": "def build(event)\n        [\n          timestamps_data,\n          event_data(event),\n          group_data,\n          event_specific_group_data(event)\n        ].reduce(:merge)\n      end",
        "comment": "Sample data { :created_at=>\"2021-01-20T09:40:12Z\", :updated_at=>\"2021-01-20T09:40:12Z\", :event_name=>\"group_rename\", :name=>\"group1\", :path=>\"group1\", :full_path=>\"group1\", :group_id=>1, :old_path=>\"old-path\", :old_full_path=>\"old-path\" }",
        "label": "What",
        "id": "2413"
    },
    {
        "raw_code": "def _HtmlBlockCloseDd\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseDd = \"<\" Spnl \"/\" (\"dd\" | \"DD\") Spnl \">\"",
        "label": "What",
        "id": "15693"
    },
    {
        "raw_code": "def validate_provisioner_flags!(options, argv)\n        if options[:provision_types].nil?\n          return\n        end",
        "comment": "This validates the provisioner flags and raises an exception if there are invalid ones.",
        "label": "What",
        "id": "9793"
    },
    {
        "raw_code": "def metrics_event\n          raise NotImplementedError\n        end",
        "comment": "Each handler should use it's own metric event.  Otherwise there is a possibility that within the same Sidekiq process, that same event with different metrics_params will cause Prometheus to throw an error",
        "label": "What",
        "id": "3254"
    },
    {
        "raw_code": "def command_name\n          @command_name ||= if command = name.to_s.split(\"::\").last\n            command.chomp!(\"Command\")\n            command.underscore\n          end",
        "comment": "Return command name without namespaces.  Rails::Command::TestCommand.command_name # => 'test'",
        "label": "What",
        "id": "14710"
    },
    {
        "raw_code": "def method\n              end",
        "comment": "{bom}class Test",
        "label": "What",
        "id": "10773"
    },
    {
        "raw_code": "def arel_in_nodes\n      where_clause_arel_nodes\n        .select { |arel_node| in_predicate?(arel_node) }\n        .select { |arel_node| model_column_names.include?(arel_node.left.name) }\n    end",
        "comment": "Actively filter any nodes that don't belong to the primary queried table to prevent sql type resolution issues Context: https://gitlab.com/gitlab-org/gitlab/-/issues/370271#note_1151019824",
        "label": "What",
        "id": "3588"
    },
    {
        "raw_code": "def delete(key)\n        Rails.cache.delete(key)\n      end",
        "comment": "Hook for EE",
        "label": "What",
        "id": "1489"
    },
    {
        "raw_code": "def set_version_info(version, options={})\n          version.description = options[:version_description] if options.key?(:version_description)\n          version\n        end",
        "comment": "Set any version related attributes that were provided  @param [VagrantCloud::Box::Version] version Vagrant Cloud box version @param [Hash] options @option options [String] :version_description Description for this version @return [VagrantCloud::Box::Version]",
        "label": "What",
        "id": "9760"
    },
    {
        "raw_code": "def _ListLoose\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _StartList()\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ListLoose = @StartList:a (ListItem:b @BlankLine* { a << b })+ { a }",
        "label": "What",
        "id": "15615"
    },
    {
        "raw_code": "def to_s\n          self.class.to_s\n        end",
        "comment": "A default to_s implementation.",
        "label": "What",
        "id": "9125"
    },
    {
        "raw_code": "def attribute_previously_changed?(attr_name, **options)\n      mutations_before_last_save.changed?(attr_name.to_s, **options)\n    end",
        "comment": "Dispatch target for {*_previously_changed?}[rdoc-ref:#*_previously_changed?] attribute methods.",
        "label": "What",
        "id": "12202"
    },
    {
        "raw_code": "def create_record\n        association = project.public_send(project_association) # rubocop:disable GitlabSecurity/PublicSend\n\n        association.find_or_create_by!(find_condition) do |record|\n          record.attributes = attributes\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord -- Existing legacy code",
        "label": "What",
        "id": "1774"
    },
    {
        "raw_code": "def branch(repo, branch, options = {})\n        get \"#{Repository.path repo}/branches/#{CGI.escape(branch)}\", options\n      end",
        "comment": "Get a single branch from a repository  @param repo [Integer, String, Hash, Repository] A GitHub repository. @param branch [String] Branch name @return [Sawyer::Resource] The branch requested, if it exists @see https://developer.github.com/v3/repos/#get-branch @example Get branch 'master` from octokit/octokit.rb Octokit.branch(\"octokit/octokit.rb\", \"master\")",
        "label": "What",
        "id": "15160"
    },
    {
        "raw_code": "def store_package(package)\n    read_and_store_entries(package)\n    store_spec package.spec\n  end",
        "comment": " Store version content @param [Gem::Package] package",
        "label": "What",
        "id": "9996"
    },
    {
        "raw_code": "def user_readable_project_ids\n        project_ids = (available_project_keys + available_public_keys)\n          .flat_map { |deploy_key| deploy_key.deploy_keys_projects.map(&:project_id) }\n          .compact\n          .uniq\n\n        current_user.authorized_projects(Gitlab::Access::GUEST).id_in(project_ids).pluck(:id)\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5421"
    },
    {
        "raw_code": "def capture(*, **, &block)\n        value = nil\n        @output_buffer ||= ActionView::OutputBuffer.new\n        buffer = @output_buffer.capture { value = yield(*, **) }\n\n        string = if @output_buffer.equal?(value)\n          buffer\n        else\n          buffer.presence || value\n        end",
        "comment": "The capture method extracts part of a template as a string object. You can then use this object anywhere in your templates, layout, or helpers.  The capture method can be used in \\ERB templates...  <% @greeting = capture do %> Welcome to my shiny new web page!  The date and time is <%= Time.now %> <% end %>  ...and Builder (RXML) templates.  @timestamp = capture do \"The current timestamp is #{Time.now}.\" end  You can then use that variable anywhere else. For example:  <html> <head><title><%= @greeting %></title></head> <body> <b><%= @greeting %></b> </body> </html>  The return of capture is the string generated by the block. For Example:  @greeting # => \"Welcome to my shiny new web page! The date and time is 2018-09-06 11:09:16 -0500\" ",
        "label": "What",
        "id": "11817"
    },
    {
        "raw_code": "def eql?(o)\n      self == o\n    end",
        "comment": "@see the `==` method @param [Object] Object to be compared",
        "label": "What",
        "id": "957"
    },
    {
        "raw_code": "def temp_path\n    spec_path.join('..', 'tmp').expand_path\n  end",
        "comment": "Temporary folder basepath inside project @return [Pathname]",
        "label": "What",
        "id": "1113"
    },
    {
        "raw_code": "def db_key_base_keys_truncated\n    db_key_base_keys.map do |key| # rubocop:disable Rails/Pluck -- No Rails context\n      key[0..31]\n    end",
        "comment": "Don't use this in new code, use db_key_base_keys_32_bytes instead!",
        "label": "What",
        "id": "1258"
    },
    {
        "raw_code": "def method1\n            end",
        "comment": "{keyword} A",
        "label": "What",
        "id": "10978"
    },
    {
        "raw_code": "def optionally_run_in_admin_mode(user)\n          raise NonSidekiqEnvironmentError unless Gitlab::Runtime.sidekiq?\n\n          return yield unless Gitlab::CurrentSettings.admin_mode && user.can_access_admin_area?\n\n          bypass_session!(user.id) do\n            with_current_admin(user) do\n              yield\n            end",
        "comment": "Execute the given block with admin privileges if the user is an admin and admin mode is enabled. Otherwise, execute the block with regular user permissions.",
        "label": "What",
        "id": "2326"
    },
    {
        "raw_code": "def uninstall_plugin(name, **opts)\n        if @system_file\n          if !@user_file.has_plugin?(name) && @system_file.has_plugin?(name)\n            raise Errors::PluginUninstallSystem,\n              name: name\n          end",
        "comment": "Uninstalls the plugin with the given name.  @param [String] name",
        "label": "What",
        "id": "8957"
    },
    {
        "raw_code": "def columns_changing_default(*columns)\n      self.columns_with_changing_default = columns.map(&:to_s)\n    end",
        "comment": "Indicate that one or more columns will have their database default change.  By indicating those columns here, this helper prevents a case where explicitly writing the old database default will be mutated to the new database default.",
        "label": "What",
        "id": "7343"
    },
    {
        "raw_code": "def a; end\n          end",
        "comment": "@overload a",
        "label": "What",
        "id": "795"
    },
    {
        "raw_code": "def blank?\n    false\n  end",
        "comment": "+true+ is not blank:  true.blank? # => false  @return [false]",
        "label": "What",
        "id": "14305"
    },
    {
        "raw_code": "def self.driven_by(driver, using: :chrome, screen_size: [1400, 1400], options: {}, &capabilities)\n      driver_options = { using: using, screen_size: screen_size, options: options }\n\n      self.driver = SystemTesting::Driver.new(driver, **driver_options, &capabilities)\n    end",
        "comment": "System Test configuration options  The default settings are Selenium, using Chrome, with a screen size of 1400x1400.  Examples:  driven_by :cuprite  driven_by :selenium, screen_size: [800, 800]  driven_by :selenium, using: :chrome  driven_by :selenium, using: :headless_chrome  driven_by :selenium, using: :firefox  driven_by :selenium, using: :headless_firefox",
        "label": "What",
        "id": "11404"
    },
    {
        "raw_code": "def project_column(id, options = {})\n        get \"projects/columns/#{id}\", options\n      end",
        "comment": "Get a project column by ID  @param id [Integer] Project column id @return [Sawyer::Resource] Project column @see https://developer.github.com/v3/projects/columns/#get-a-project-column @example Octokit.project_column(30294)",
        "label": "What",
        "id": "15322"
    },
    {
        "raw_code": "def container_html_options\n        {\n          aria: { label: title }\n        }.merge(extra_container_html_options)\n      end",
        "comment": "The attributes returned from this method will be applied to helper methods like `link_to` or the div containing the container.",
        "label": "What",
        "id": "3689"
    },
    {
        "raw_code": "def ensure_single_socket!\n          addresses = Gitlab.config.repositories.storages.map { |_, storage| storage[:gitaly_address] }.uniq\n\n          raise ArgumentError, \"Your gitlab.yml contains more than one gitaly_address.\" if addresses.length > 1\n\n          address = addresses.first\n\n          if URI(address).scheme != 'unix'\n            raise ArgumentError, \"Automatic config.toml generation only supports 'unix:' addresses.\"\n          end",
        "comment": "We cannot create config.toml files for all possible Gitaly configurations. For instance, if Gitaly is running on another machine then it makes no sense to write a config.toml file on the current machine. This method validates that we have the most common and simplest case: when we have exactly one Gitaly process and we are sure it is running locally because it uses a Unix socket.",
        "label": "What",
        "id": "1720"
    },
    {
        "raw_code": "def failure\n          send_response(\n            text: message_text(\"<#{build_url}|Sorry, the build failed!>\"),\n            response_type: RESPONSE_TYPE\n          )\n        end",
        "comment": "Sends the output for a build that failed.",
        "label": "What",
        "id": "2444"
    },
    {
        "raw_code": "def discard_inserted_comments(comments, last_note)\n        last_note_attrs = nil\n\n        cut_off_index = comments.find_index do |raw|\n          comment           = CommentFormatter.new(project, raw.to_h)\n          comment_attrs     = comment.attributes\n          last_note_attrs ||= last_note.slice(*comment_attrs.keys)\n\n          comment_attrs.with_indifferent_access == last_note_attrs\n        end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "1773"
    },
    {
        "raw_code": "def api_runners_path\n        \"#{api_get_path}/runners\"\n      end",
        "comment": "API path to GET runners See https://docs.gitlab.com/ee/api/runners.html#list-groups-runners  @return [String]",
        "label": "What",
        "id": "4159"
    },
    {
        "raw_code": "def issue(repo, number, options = {})\n        get \"#{Repository.path repo}/issues/#{number}\", options\n      end",
        "comment": "Get a single issue from a repository  @param repo [Integer, String, Repository, Hash] A GitHub repository @param number [Integer] Number ID of the issue @return [Sawyer::Resource] The issue you requested, if it exists @see https://developer.github.com/v3/issues/#get-a-single-issue @example Get issue #25 from octokit/octokit.rb Octokit.issue(\"octokit/octokit.rb\", \"25\")",
        "label": "What",
        "id": "15246"
    },
    {
        "raw_code": "def orphan?\n          return true if full_path.nil? || upload_path.nil?\n\n          # It's possible to reduce to one query, but `where_full_path_in` is complex\n          !Upload.exists?(path: upload_path, model_id: project_id, model_type: 'Project', uploader: 'FileUploader')\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2727"
    },
    {
        "raw_code": "def outdated_runner_versions\n        Ci::RunnerVersion.potentially_outdated\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5834"
    },
    {
        "raw_code": "def legacy_search_repositories(q, options = {})\n        get(\"legacy/repos/search/#{q}\", options)['repositories']\n      end",
        "comment": "Legacy repository search  @see https://developer.github.com/v3/search/#search-repositories @param q [String] Search keyword @return [Array<Sawyer::Resource>] List of repositories found",
        "label": "What",
        "id": "15034"
    },
    {
        "raw_code": "def add_model_headers(object)\n    # Use replacement so we don't strip the module.\n    prefix = \"X-GitLab-#{object.class.name.gsub(/::/, '-')}\"\n\n    headers[\"#{prefix}-ID\"] = object.id\n    headers[\"#{prefix}-IID\"] = object.iid if object.respond_to?(:iid)\n    headers[\"#{prefix}-State\"] = object.state if object.respond_to?(:state)\n  end",
        "comment": "This method applies threading headers to the email to identify the instance we are discussing.  All model instances must have `#id`, and may implement `#iid`.",
        "label": "What",
        "id": "6252"
    },
    {
        "raw_code": "def create_partitioned_table(name)\n    options = 'PARTITION BY LIST (model_type)'\n\n    # Table name should by provided by `partition_table_by_list`, but when using variable some\n    # Rubocop rules fail to handle this, so we use the name that would be generated instead.\n    create_table :uploads_9ba88c4165, primary_key: PARTITIONED_TABLE_PK, options: options do |t|\n      t.bigint :id, null: false\n      t.bigint :size, null: false\n      t.bigint :model_id, null: false\n      t.references :uploaded_by_user, index: false, foreign_key: { to_table: :users, on_delete: :nullify }\n      t.bigint :organization_id\n      t.bigint :namespace_id\n      t.bigint :project_id\n      t.timestamp :created_at\n      t.integer :store, null: false, default: 1\n      t.integer :version, default: 1\n      t.text :path, null: false, limit: 511\n      t.text :checksum, limit: 64\n      t.text :model_type\n      t.text :uploader, null: false\n      t.text :mount_point\n      t.text :secret\n\n      t.index :checksum, name: \"index_#{name}_on_checksum\"\n      t.index [:model_id, :model_type, :uploader, :created_at], name: \"index_#{name}_on_model_uploader_created_at\"\n      t.index :store, name: \"index_#{name}_on_store\"\n      t.index :uploaded_by_user_id, name: \"index_#{name}_on_uploaded_by_user_id\"\n      t.index [:uploader, :path], name: \"index_#{name}_on_uploader_and_path\"\n      t.index :organization_id, name: \"index_#{name}_on_organization_id\"\n      t.index :namespace_id, name: \"index_#{name}_on_namespace_id\"\n      t.index :project_id, name: \"index_#{name}_on_project_id\"\n    end",
        "comment": "rubocop:disable Migration/Datetime -- Creating a copy of existing table rubocop:disable Migration/AddLimitToTextColumns -- Creating a copy of existing table rubocop:disable Migration/EnsureFactoryForTable -- Creating a copy of existing table",
        "label": "What",
        "id": "5001"
    },
    {
        "raw_code": "def expand_on_ancestors(validators)\n          delegator_class.ancestors.each do |ancestor|\n            next if delegator_class == ancestor # ancestor includes itself\n\n            validator_ancestor = validators[ancestor]\n\n            next unless validator_ancestor\n\n            add_allowlist(validator_ancestor.allowed_method_names)\n          end",
        "comment": "This will make sure allowlist we put into ancestors are all included",
        "label": "What",
        "id": "1871"
    },
    {
        "raw_code": "def show\n      render :index\n    end",
        "comment": "The show action renders index to allow frontend routing to work on page refresh",
        "label": "What",
        "id": "6583"
    },
    {
        "raw_code": "def readable_inspect\n    to_fs(:rfc822)\n  end",
        "comment": "Overrides the default inspect method with a human readable one, e.g., \"Mon, 21 Feb 2005 14:30:00 +0000\".",
        "label": "What",
        "id": "14204"
    },
    {
        "raw_code": "def else_source(else_branch, arithmetic_operation) # rubocop:disable Metrics/AbcSize\n          if arithmetic_operation\n            \"#{else_branch.first_argument.source})\"\n          elsif branches_have_method?(else_branch.parent)\n            else_source_if_has_method(else_branch)\n          elsif require_parentheses?(else_branch)\n            \"(#{else_branch.source})\"\n          elsif without_argument_parentheses_method?(else_branch)\n            \"#{else_branch.method_name}(#{else_branch.arguments.map(&:source).join(', ')})\"\n          elsif branches_have_assignment?(else_branch.parent)\n            else_source_if_has_assignment(else_branch)\n          else\n            else_branch.source\n          end",
        "comment": "rubocop:enable Metrics/AbcSize",
        "label": "What",
        "id": "10613"
    },
    {
        "raw_code": "def enqueue_batch_exports\n      batch_number = 0\n\n      resolved_relation.in_batches(of: batch_size) do |batch|\n        batch_number += 1\n\n        batch_id = find_or_create_batch(batch_number).id\n        ids = batch.pluck(batch.model.primary_key)\n\n        Gitlab::Cache::Import::Caching.set_add(self.class.cache_key(export.id, batch_id), ids, timeout: CACHE_DURATION)\n\n        RelationBatchExportWorker.perform_async(user.id, batch_id)\n      end",
        "comment": "rubocop:disable Cop/InBatches rubocop:disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5867"
    },
    {
        "raw_code": "def initialize(\n      heading, description: nil, id: nil, testid: nil, expanded: nil, button_options: {},\n      css_class: nil)\n      @heading = heading\n      @description = description\n      @id = id\n      @testid = testid\n      @expanded = expanded\n      @button_options = button_options\n      @css_class = css_class\n    end",
        "comment": "@param [String] heading @param [String] description @param [String] id @param [String] testid @param [Boolean] expanded @param [Hash] button_options",
        "label": "What",
        "id": "5382"
    },
    {
        "raw_code": "def parse(data)\n      if data.respond_to?(:read)\n        data = data.read\n      end",
        "comment": "Parse an XML Document string or IO into a simple hash using Java's jdom. data:: XML Document string or IO to parse",
        "label": "What",
        "id": "14580"
    },
    {
        "raw_code": "def self.make_hash_validatable_by_json_schemer(hash)\n        hash\n          .deep_stringify_keys\n          .transform_values { |v| v.is_a?(Symbol) ? v.to_s : v }\n      end",
        "comment": "@param [Hash] hash @return [Hash]",
        "label": "What",
        "id": "3573"
    },
    {
        "raw_code": "def delete(action, **args)\n        process(action, method: \"DELETE\", **args)\n      end",
        "comment": "Simulate a DELETE request with the given parameters and set/volley the response. See `get` for more details.",
        "label": "What",
        "id": "11245"
    },
    {
        "raw_code": "def tags(values)\n        tags = values.slice('name', 'file_path', 'status', 'smoke',\n          'quarantined', 'job_name', 'merge_request', 'run_type', 'stage',\n          'product_group', 'feature_category', 'testcase', 'exception_class')\n\n        # custom_test_metrics\n        tags['import_repo'] = values['import_repo']\n        tags['import_type'] = values['import_type']\n\n        tags\n      end",
        "comment": "Produces a tags Hash  @param [String] values record's values to get the data from @return [Hash]",
        "label": "What",
        "id": "4657"
    },
    {
        "raw_code": "def definition\n    @definition.to_h\n  end",
        "comment": "We can use this method later to apply some sanity checks but for now, returning a Hash without any check is enough.",
        "label": "What",
        "id": "1309"
    },
    {
        "raw_code": "def convert_method_to_overload(meth)\n        # use first overload tag if it has a return type and method itself does not\n        if !meth.tag(:return) && meth.tags(:overload).size == 1 && meth.tag(:overload).tag(:return)\n          return meth.tag(:overload)\n        end",
        "comment": "Converts a {CodeObjects::MethodObject} into an overload object @since 0.5.3",
        "label": "What",
        "id": "421"
    },
    {
        "raw_code": "def schedule_sync_event_worker\n    run_after_commit do\n      Namespaces::SyncEvent.enqueue_worker\n    end",
        "comment": "SyncEvents are created by PG triggers (with the function `insert_namespaces_sync_event`)",
        "label": "What",
        "id": "6695"
    },
    {
        "raw_code": "def handle_legacy_mode!(data)\n        raise parser_error if INVALID_LEGACY_TYPES.any? { |type| data.is_a?(type) }\n      end",
        "comment": "If legacy mode is enabled, we need to raise an error depending on the values provided in the string. This will be deprecated.  @param data [Boolean, String, Array, Hash, Object] @return [Boolean, String, Array, Hash, Object] @raise [JSON::ParserError]",
        "label": "What",
        "id": "1648"
    },
    {
        "raw_code": "def argument_list_size_differs?(def_args, super_args, super_node)\n          # If the def node has a block argument and the super node has an explicit block,\n          # the number of arguments is the same, so ignore the def node block arg.\n          def_args_size = def_args.size\n          def_args_size -= 1 if def_args.any?(&:blockarg_type?) && block_sends_to_super?(super_node)\n\n          def_args_size != super_args.size\n        end",
        "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10553"
    },
    {
        "raw_code": "def before_validation(*args, &block)\n          options = args.extract_options!\n\n          set_options_for_callback(options)\n\n          set_callback(:validation, :before, *args, options, &block)\n        end",
        "comment": "Defines a callback that will get called right before validation.  class Person include ActiveModel::Validations include ActiveModel::Validations::Callbacks  attr_accessor :name  validates_length_of :name, maximum: 6  before_validation :remove_whitespaces  private def remove_whitespaces name.strip! end end  person = Person.new person.name = '  bob  ' person.valid? # => true person.name   # => \"bob\"",
        "label": "What",
        "id": "12306"
    },
    {
        "raw_code": "def self.from_json_hash(raw_hash)\n          new(Representation.symbolize_hash(raw_hash))\n        end",
        "comment": "Builds a new lfs_object using a Hash that was built from a JSON payload.",
        "label": "What",
        "id": "2266"
    },
    {
        "raw_code": "def use(middleware)\n          unless middleware.respond_to?(:call)\n            raise ArgumentError, \"Error context middleware must respond to #call\"\n          end",
        "comment": "Add a middleware to the error context stack.",
        "label": "What",
        "id": "13848"
    },
    {
        "raw_code": "def add_ci_job_link(example)\n          return unless Runtime::Env.running_in_ci?\n\n          example.add_link(name: \"Job(#{Runtime::Env.ci_job_name})\", url: Runtime::Env.ci_job_url)\n        rescue StandardError => e\n          log(:error, \"Failed to add ci job link for example '#{example.description}', error: #{e}\")\n        end",
        "comment": "Add ci job link  @param [RSpec::Core::Example] example @return [void]",
        "label": "What",
        "id": "4599"
    },
    {
        "raw_code": "def in_use?(index)\n      results = []\n      index.each do |entry|\n        box_data = entry.extra_data[\"box\"]\n        next if !box_data\n\n        # If all the data matches, record it\n        if box_data[\"name\"] == self.name &&\n          box_data[\"provider\"] == self.provider.to_s &&\n          box_data[\"architecture\"] == self.architecture &&\n          box_data[\"version\"] == self.version.to_s\n          results << entry\n        end",
        "comment": "Checks if this box is in use according to the given machine index and returns the entries that appear to be using the box.  The entries returned, if any, are not tested for validity with {MachineIndex::Entry#valid?}, so the caller should do that if the caller cares.  @param [MachineIndex] index @return [Array<MachineIndex::Entry>]",
        "label": "What",
        "id": "8723"
    },
    {
        "raw_code": "def find(...)\n    raise_not_found_unless_authorized execute.reorder(nil).find(...)\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7997"
    },
    {
        "raw_code": "def labels_as_hash(target)\n      super(target, group_id: group.id, only_group_labels: true, include_ancestor_groups: true, archived: false)\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5545"
    },
    {
        "raw_code": "def handle_event(event)\n      merge_request_id = event.data[:merge_request_id]\n      merge_request = MergeRequest.find_by_id(merge_request_id)\n\n      unless merge_request\n        logger.info(structured_payload(message: 'Merge request not found.', merge_request_id: merge_request_id))\n        return\n      end",
        "comment": "The difference with this worker and AutoMergeProcessWorker is that this will handle the execution from the event store code",
        "label": "What",
        "id": "6330"
    },
    {
        "raw_code": "def _HtmlBlockLi\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenLi)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockLi = HtmlBlockOpenLi (HtmlBlockLi | !HtmlBlockCloseLi .)* HtmlBlockCloseLi",
        "label": "What",
        "id": "15703"
    },
    {
        "raw_code": "def store_entries(entries)\n    path_checksums = {}\n    entries.each do |entry|\n      path_checksums[entry.path] = entry.sha256 if entry.sha256.present?\n      store_entry entry\n    end",
        "comment": "Writing version contents is done in one pass, collecting all the checksums and paths and writing them to the .sha256 checksums file at the end. All files in the gem  must be enumerated so no checksums are missing from the .sha256 file stored at the end. @param [Enumerable<RubygemContents::Entry>] entries",
        "label": "What",
        "id": "9997"
    },
    {
        "raw_code": "def devise_mail(record, action, opts = {}, &block)\n    validate_single_recipient_in_opts!(opts)\n    super\n  end",
        "comment": "Override devise_mail so that all emails, not just those redefined here, can only be sent to a single to: address.",
        "label": "What",
        "id": "6253"
    },
    {
        "raw_code": "def handle_changes(issuable, options); end\n\n  # override if needed\n  def handle_task_changes(issuable); end\n\n  # override if needed\n  def execute_hooks(issuable, action = 'open', params = {}); end\n\n  def update_project_counter_caches?(issuable)\n    issuable.state_id_changed?\n  end\n\n  def parent\n    project\n  end\n\n  def update_timestamp?(issuable)\n    issuable.changes.keys != [\"relative_position\"]\n  end\n\n  def allowed_create_params(params)\n    params.except(:observability_links)\n  end\n\n  def allowed_update_params(params)\n    params\n  end\n\n  def update_issuable_sla(issuable)\n    return unless issuable_sla = issuable.issuable_sla\n\n    issuable_sla.update(issuable_closed: issuable.closed?)\n  end\n\n  def filter_contact_params(issuable)\n    return if params.slice(:add_contacts, :remove_contacts).empty?\n    return if can?(current_user, :set_issue_crm_contacts, issuable)\n\n    params.extract!(:add_contacts, :remove_contacts)\n  end\nend\n\nIssuableBaseService.prepend_mod_with('IssuableBaseService')",
        "comment": "override if needed",
        "label": "What",
        "id": "5495"
    },
    {
        "raw_code": "def lease_timeout\n        DEFAULT_LEASE_TIMEOUT\n      end",
        "comment": "used by ExclusiveLeaseGuard",
        "label": "What",
        "id": "5745"
    },
    {
        "raw_code": "def group_milestones_applied_to_issues\n      Milestone.joins(:issues)\n        .where(\n          issues: { project_id: project.id },\n          group_id: old_group.self_and_ancestors\n        )\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6136"
    },
    {
        "raw_code": "def access_token_create_response\n            # Returns '201 CREATED' on successful creation of a new access token.\n            strong_memoize(:access_token_create_response) do\n              post(\n                url: url('/login'),\n                body: {\n                  client_id: ::Gitlab.config.forti_token_cloud.client_id,\n                  client_secret: ::Gitlab.config.forti_token_cloud.client_secret\n                }.to_json\n              )\n            end",
        "comment": "TODO: Cache the access token: https://gitlab.com/gitlab-org/gitlab/-/issues/292437",
        "label": "What",
        "id": "2358"
    },
    {
        "raw_code": "def self.log_level\n    ENV.fetch(\"VAGRANT_LOG\", \"fatal\").downcase\n  end",
        "comment": "The current log level for Vagrant  @return [String]",
        "label": "What",
        "id": "8823"
    },
    {
        "raw_code": "def trackers_data\n        @trackers_data ||= JiraTrackerData\n          .where(deployment_type: 'unknown')\n          .where(batch_column => start_id..end_id)\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3276"
    },
    {
        "raw_code": "def gcs_client\n        Fog::Google::Storage.new(\n          google_project: ENV['QA_METRICS_GCS_PROJECT_ID'] || raise('Missing QA_METRICS_GCS_PROJECT_ID env variable'),\n          **gcs_credentials)\n      end",
        "comment": "GCS Client  @return [Fog::Google::StorageJSON]",
        "label": "What",
        "id": "4528"
    },
    {
        "raw_code": "def access_token_about_to_expire(user, token_names, params = {})\n    return unless user.can?(:receive_notifications)\n\n    log_info(\"Notifying User about expiring tokens\", user)\n\n    mailer.access_token_about_to_expire_email(user, token_names, params).deliver_later\n  end",
        "comment": "Notify the owner of the personal access token, when it is about to expire And mark the token with about_to_expire_delivered",
        "label": "What",
        "id": "5456"
    },
    {
        "raw_code": "def fetch_registry_repositories(project_id)\n          response = get(Runtime::API::Request.new(api_client,\n            \"/projects/#{project_id}/registry/repositories\").url)\n\n          unless success?(response&.code)\n            logger.warn(\"Failed to fetch registry repositories for project #{project_id}: #{response&.code}\")\n            return []\n          end",
        "comment": "Fetches all registry repositories for a project  @param [String] project_id Project ID @return [Array<Hash>] Array of repository objects",
        "label": "What",
        "id": "4762"
    },
    {
        "raw_code": "def limit(value)\n      spawn.limit!(value)\n    end",
        "comment": "Specifies a limit for the number of records to retrieve.  User.limit(10) # generated SQL has 'LIMIT 10'  User.limit(10).limit(20) # generated SQL has 'LIMIT 20'",
        "label": "What",
        "id": "13419"
    },
    {
        "raw_code": "def finalize_fast_destroy(items_to_remove)\n      items_to_remove.each do |store_class, keys|\n        store_class.new.delete_keys_async(keys)\n      end",
        "comment": " FastDestroyAll concerns",
        "label": "What",
        "id": "6800"
    },
    {
        "raw_code": "def perform; end\n    end",
        "comment": "@return [Void]",
        "label": "What",
        "id": "3262"
    },
    {
        "raw_code": "def change\n    create_table :vulnerability_export_parts do |t|\n      t.references :vulnerability_export, foreign_key: { on_delete: :cascade }, null: false, index: true\n      t.bigint :start_id, null: false\n      t.bigint :end_id, null: false\n      t.references :organization, foreign_key: { on_delete: :cascade }, null: false, default: 1\n      t.integer :file_store\n      t.text :file, limit: 255\n\n      t.timestamps_with_timezone null: false\n    end",
        "comment": "rubocop:disable Migration/EnsureFactoryForTable -- False Positive",
        "label": "What",
        "id": "4996"
    },
    {
        "raw_code": "def run\n    if @list_doc_dirs then\n      puts @doc_dirs\n    elsif @list then\n      list_known_classes @names\n    elsif @server then\n      start_server\n    elsif @interactive or @names.empty? then\n      interactive\n    else\n      display_names @names\n    end",
        "comment": " Looks up and displays ri data according to the options given.",
        "label": "What",
        "id": "16619"
    },
    {
        "raw_code": "def _HtmlBlockCloseH3\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseH3 = \"<\" Spnl \"/\" (\"h3\" | \"H3\") Spnl \">\"",
        "label": "What",
        "id": "15657"
    },
    {
        "raw_code": "def meow_at_3am?\n              rand < 0.8\n            end",
        "comment": "Here we go back an indentation level again. This is a violation of the indented_internal_methods style, but it's not for this cop to report. Layout/IndentationWidth will handle it.",
        "label": "What",
        "id": "10822"
    },
    {
        "raw_code": "def up\n    prepare_async_index TABLE_NAME, GROUP_LEVEL_COLUMNS, name: GROUP_LEVEL_INDEX, where: 'archived = false'\n    prepare_async_index TABLE_NAME, PROJECT_LEVEL_COLUMNS, name: PROJECT_LEVEL_INDEX,\n      order: { vulnerability_id: :desc }\n  end",
        "comment": "Index created synchronously in https://gitlab.com/gitlab-org/gitlab/-/merge_requests/167603",
        "label": "What",
        "id": "4892"
    },
    {
        "raw_code": "def close_pull_request(repo, number, options = {})\n        options.merge! state: 'closed'\n        update_pull_request(repo, number, options)\n      end",
        "comment": "Close a pull request  @param repo [Integer, String, Hash, Repository] A GitHub repository. @param number [Integer] Number of pull request to update. @return [Sawyer::Resource] Hash representing updated pull request. @see https://developer.github.com/v3/pulls/#update-a-pull-request @example @client.close_pull_request('octokit/octokit.rb', 67)",
        "label": "What",
        "id": "15089"
    },
    {
        "raw_code": "def delete_app_authorization(access_token, options = {})\n        options[:access_token] = access_token\n\n        key    = options.delete(:client_id)     || client_id\n        secret = options.delete(:client_secret) || client_secret\n\n        begin\n          as_app(key, secret) do |app_client|\n            app_client.delete \"applications/#{client_id}/grant\", options\n            app_client.last_response.status == 204\n          end",
        "comment": "Delete an app authorization  OAuth application owners can revoke a grant for their OAuth application and a specific user.  @param access_token [String] 40 character GitHub OAuth access token  @return [Boolean] Result @see https://developer.github.com/v3/apps/oauth_applications/#delete-an-app-token  @example client = Octokit::Client.new(:client_id => 'abcdefg12345', :client_secret => 'secret') client.delete_app_authorization('deadbeef1234567890deadbeef987654321')",
        "label": "What",
        "id": "15296"
    },
    {
        "raw_code": "def check(pairs, delim, msg)\n          pairs.each do |pair|\n            if pair.delimiter == delim\n              location = pair.source_range.begin.join(pair.loc.operator)\n              add_offense(location, message: msg) do |corrector|\n                autocorrect(corrector, pair)\n\n                opposite_style_detected\n              end",
        "comment": "rubocop:enable Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "10592"
    },
    {
        "raw_code": "def accept_list_item_end(list_item)\n  end",
        "comment": " Finishes consumption of +list_item+",
        "label": "What",
        "id": "16403"
    },
    {
        "raw_code": "def find_by_email\n          return unless auth_hash.has_attribute?(:email)\n\n          ::User.find_by(email: auth_hash.email.downcase)\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2364"
    },
    {
        "raw_code": "def fragment_cache_key(value = nil, &key)\n          self.fragment_cache_keys += [key || -> { value }]\n        end",
        "comment": "Allows you to specify controller-wide key prefixes for cache fragments. Pass either a constant `value`, or a block which computes a value each time a cache key is generated.  For example, you may want to prefix all fragment cache keys with a global version identifier, so you can easily invalidate all caches.  class ApplicationController fragment_cache_key \"v1\" end  When it's time to invalidate all fragments, simply change the string constant. Or, progressively roll out the cache invalidation using a computed value:  class ApplicationController fragment_cache_key do @account.id.odd? ? \"v1\" : \"v2\" end end",
        "label": "What",
        "id": "11213"
    },
    {
        "raw_code": "def bar\n            do_something # - note\n          end",
        "comment": "rubocop:disable Metrics",
        "label": "What",
        "id": "10962"
    },
    {
        "raw_code": "def source_object(id)\n      source_model.find_by(source_sort_key => id)\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6128"
    },
    {
        "raw_code": "def self.new(cop_or_classes, config, options = {})\n        # Support v0 api:\n        if cop_or_classes.first.is_a?(Class)\n          warn Rainbow(<<~WARNING).yellow, uplevel: 1\n            `Team.new` with cop classes is deprecated. Use `Team.mobilize` instead.\n          WARNING\n          return mobilize(cop_or_classes, config, options)\n        end",
        "comment": "@return [Team]",
        "label": "What",
        "id": "10295"
    },
    {
        "raw_code": "def to_s\n      to_rendered_html_with_layout\n    end",
        "comment": "Safely transforms Content into an HTML String.  content = ActionText::Content.new(content: \"<h1>Funny times!</h1>\") content.to_s # => \"<h1>Funny times!</h1>\"  content = ActionText::Content.new(\"<div onclick='action()'>safe<script>unsafe</script></div>\") content.to_s # => \"<div>safeunsafe</div>\"",
        "label": "What",
        "id": "11697"
    },
    {
        "raw_code": "def find_or_create_milestone(milestone)\n      params = milestone.attributes.slice('title', 'description', 'start_date', 'due_date', 'state')\n\n      FindOrCreateService.new(project, current_user, params).execute\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6138"
    },
    {
        "raw_code": "def pull_images(*images)\n        @machine.communicate.tap do |comm|\n          images.each do |image|\n            @machine.ui.info(I18n.t(\"vagrant.container_pulling_single\", name: image))\n            comm.sudo(\"#{@container_command} pull #{image}\") do |type, data|\n              handle_comm(type, data)\n            end",
        "comment": "Pull image given a list of images  @param [String] - Image name",
        "label": "What",
        "id": "9919"
    },
    {
        "raw_code": "def create_deployment(repo, ref, options = {})\n        options[:ref] = ref\n        post(\"#{Repository.path repo}/deployments\", options)\n      end",
        "comment": "Create a deployment for a ref  @param repo [Integer, String, Repository, Hash] A GitHub repository @param ref [String] The ref to deploy @option options [String] :task Used by the deployment system to allow different execution paths. Defaults to \"deploy\". @option options [String] :payload Meta info about the deployment @option options [Boolean] :auto_merge Optional parameter to merge the default branch into the requested deployment branch if necessary. Default: true @option options [Array<String>] :required_contexts Optional array of status contexts verified against commit status checks. @option options [String] :environment Optional name for the target deployment environment (e.g., production, staging, qa). Default: \"production\" @option options [String] :description Optional short description. @return [Sawyer::Resource] A deployment @see https://developer.github.com/v3/repos/deployments/#create-a-deployment",
        "label": "What",
        "id": "15385"
    },
    {
        "raw_code": "def delete(object)\n        thread_local_store.delete(object.path)\n      end",
        "comment": "Deletes an object from the registry @param [CodeObjects::Base] object the object to remove @return [void]",
        "label": "What",
        "id": "66"
    },
    {
        "raw_code": "def supports_canceling?\n      cancel_gracefully?\n    end",
        "comment": "A Ci::Bridge may transition to `canceling` as a result of strategy: :depend but only a Ci::Build will transition to `canceling`` via `.cancel`",
        "label": "What",
        "id": "7534"
    },
    {
        "raw_code": "def refresh_method_caches(types)\n    return if types.empty?\n\n    to_refresh = []\n\n    types.each do |type|\n      methods = METHOD_CACHES_FOR_FILE_TYPES[type.to_sym]\n\n      to_refresh.concat(Array(methods)) if methods\n    end",
        "comment": "Refreshes the method caches of this repository.  types - An Array of file types (e.g. `:readme`) used to refresh extra caches.",
        "label": "What",
        "id": "7132"
    },
    {
        "raw_code": "def test; end\n          end",
        "comment": "{access_modifier} {'^' * access_modifier.size} Remove a blank line after `#{access_modifier}`.",
        "label": "What",
        "id": "10847"
    },
    {
        "raw_code": "def start_migration(org, repositories, options = {})\n        options[:repositories] = repositories\n        post \"#{Organization.path(org)}/migrations\", options\n      end",
        "comment": "Initiates the generation of a migration archive.  Requires authenticated organization owner.  @param org [String, Integer] Organization GitHub login or id. @param repositories [Array<String>] :repositories Repositories for the organization. @option options [Boolean, optional] :lock_repositories Indicates whether repositories should be locked during migration @return [Sawyer::Resource] Hash representing the new migration. @example @client.start_migration('github', ['github/dotfiles']) @see https://docs.github.com/en/rest/reference/migrations#start-an-organization-migration",
        "label": "What",
        "id": "15457"
    },
    {
        "raw_code": "def gen_sub_directories\n    @outputdir.mkpath\n  end",
        "comment": " Create the directories the generated docs will live in if they don't already exist.",
        "label": "What",
        "id": "16455"
    },
    {
        "raw_code": "def opts\n        @ui.opts\n      end",
        "comment": "Return the parent's opts.  @return [Hash]",
        "label": "What",
        "id": "8809"
    },
    {
        "raw_code": "def all_objects\n        @all_objects ||= run_verifier Registry.all\n      end",
        "comment": "@return [Array<CodeObjects::Base>] all the parsed objects in the registry, removing any objects that are not visible (private, protected) depending on the arguments passed to the command.",
        "label": "What",
        "id": "517"
    },
    {
        "raw_code": "def link_url(url, title = nil, params = nil) # rubocop:disable Lint/UnusedMethodArgument\n      url\n    end",
        "comment": "Links to a URL  @param [String] url the URL to link to @param [String] title the optional title to display the link as @param [Hash] params optional parameters for the link @return [String] the linked URL",
        "label": "What",
        "id": "432"
    },
    {
        "raw_code": "def capability(*args)\n      super\n    rescue Errors::CapabilityNotFound => e\n      raise Errors::GuestCapabilityNotFound,\n        cap: e.extra_data[:cap],\n        guest: name\n    rescue Errors::CapabilityInvalid => e\n      raise Errors::GuestCapabilityInvalid,\n        cap: e.extra_data[:cap],\n        guest: name\n    end",
        "comment": "See {CapabilityHost#capability}",
        "label": "What",
        "id": "8845"
    },
    {
        "raw_code": "def merge_keys(hash, prefix: nil, connector: '.')\n        result = {}\n        pairs =\n          if prefix\n            base_prefix = \"#{prefix}#{connector}\"\n            hash.map { |key, value| [\"#{base_prefix}#{key}\", value] }\n          else\n            hash.to_a\n          end",
        "comment": "Transforms a Hash into an inline Hash by merging its nested keys.  Input  { 'root_param' => 'Root', 12 => 'number', symbol: 'symbol', nested_param: { key: 'Value' }, 'very' => { 'deep' => { 'nested' => { 12 => 'Deep nested value' } } } }   Result  { 'root_param' => 'Root', 12 => 'number', symbol: symbol, 'nested_param.key' => 'Value', 'very.deep.nested.12' => 'Deep nested value' } ",
        "label": "What",
        "id": "1846"
    },
    {
        "raw_code": "def available_work_item_types\n      WorkItems::Type.all.reject { |wit| wit.base_type == :epic }\n        .index_by(&:name).with_indifferent_access.transform_keys(&:strip).transform_keys(&:downcase)\n    end",
        "comment": "todo: This should be updated once we can determine available work item types based on namespace, see https://gitlab.com/gitlab-org/gitlab/-/issues/524828",
        "label": "What",
        "id": "6013"
    },
    {
        "raw_code": "def standardize_hash(hash)\n      hash.to_h { |k, v| [k.to_s, v.to_s] }\n    end",
        "comment": "Take a hash and convert both keys and values to strings, for insertion into Redis.  @param hash [Hash] @return [Hash] the stringified hash",
        "label": "What",
        "id": "1536"
    },
    {
        "raw_code": "def issues(confidential_only: false, issue_types: nil)\n      finder_params = { group_id: group.id, state: 'opened' }\n      finder_params[:confidential] = true if confidential_only.present?\n      finder_params[:issue_types] = issue_types if issue_types.present?\n      finder_params[:include_descendants] = true\n\n      relation = WorkItems::WorkItemsFinder.new(current_user, finder_params).execute\n\n      relation = relation.gfm_autocomplete_search(params[:search]).limit(SEARCH_LIMIT) if params[:search]\n\n      relation\n        .preload(project: :namespace)\n        .with_work_item_type\n        .select(:iid, :title, :project_id, :namespace_id, 'work_item_types.icon_name')\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5542"
    },
    {
        "raw_code": "def verify!\n      run_unpack(options.backup_id)\n      read_backup_information\n\n      preconditions = Backup::Restore::Preconditions.new(\n        backup_information: backup_information,\n        logger: logger\n      )\n\n      preconditions.validate_backup_version!\n    ensure\n      cleanup\n    end",
        "comment": "Verify whether a backup is compatible with current GitLab's version",
        "label": "What",
        "id": "3628"
    },
    {
        "raw_code": "def run_background_process\n            pid = Process.fork\n\n            if pid\n              Helpers::Spinner.spin(\"creating background process\") do\n                log(\" Saved process pid #{pid} to #{Helpers::Utils.metrics_pid_file}\")\n              end",
        "comment": "Daemonize metrics collector process  @return [void]",
        "label": "What",
        "id": "3989"
    },
    {
        "raw_code": "def authorize_group_creation!\n        authorize! :create_group\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3756"
    },
    {
        "raw_code": "def instance\n          @instance ||= new\n        end",
        "comment": "@!attribute instance @return [Library] the main Library instance object.",
        "label": "What",
        "id": "236"
    },
    {
        "raw_code": "def _HtmlBlockDir\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenDir)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockDir = HtmlBlockOpenDir (HtmlBlockDir | !HtmlBlockCloseDir .)* HtmlBlockCloseDir",
        "label": "What",
        "id": "15637"
    },
    {
        "raw_code": "def up\n    prepare_async_index :resource_label_events, :namespace_id, name: INDEX_NAME # rubocop:disable Migration/PreventIndexCreation -- Sharding key is an exception\n  end",
        "comment": "TODO: Index to be created synchronously in https://gitlab.com/gitlab-org/gitlab/-/merge_requests/197676",
        "label": "What",
        "id": "4889"
    },
    {
        "raw_code": "def suppress(*exception_classes)\n    yield\n  rescue *exception_classes\n  end",
        "comment": "Blocks and ignores any exception passed as argument if raised within the block.  suppress(ZeroDivisionError) do 1/0 puts 'This code is NOT reached' end  puts 'This code gets executed and nothing related to ZeroDivisionError was seen'",
        "label": "What",
        "id": "14257"
    },
    {
        "raw_code": "def register!\n          return if running?\n\n          command = %W[docker run -d --network #{network} --name #{name}]\n          # when host network is used, published ports are discarded and service in container runs as if on host\n          # make sure random open ports are fetched and configured for smocker server\n          command.push(\"-e\", \"SMOCKER_MOCK_SERVER_LISTEN_PORT=#{host_network? ? server_port : DEFAULT_SERVER_PORT}\")\n          command.push(\"-e\", \"SMOCKER_CONFIG_LISTEN_PORT=#{host_network? ? config_port : DEFAULT_CONFIG_PORT}\")\n          command.push(\"--publish-all\") unless host_network?\n          command.push(image)\n\n          shell command.join(\" \")\n        end",
        "comment": "Start smocker container  @return [void]",
        "label": "What",
        "id": "4229"
    },
    {
        "raw_code": "def self.create_tmp_path(machine, opts)\n          template = \"vagrant-XXXXXX\"\n          cmd = [\"mktemp\"]\n          if opts[:type] == :directory\n            cmd << \"-d\"\n          end",
        "comment": "Create a temporary file or directory on the guest  @param [Vagrant::Machine] machine Vagrant guest machine @param [Hash] opts Path options @return [String] path to temporary file or directory",
        "label": "What",
        "id": "9823"
    },
    {
        "raw_code": "def asciidoc?(filename)\n      ASCIIDOC_EXTENSIONS.include?(extension(filename))\n    end",
        "comment": "Public: Determines if the given filename has AsciiDoc extension.  filename - Filename string to check  Returns boolean",
        "label": "What",
        "id": "1357"
    },
    {
        "raw_code": "def ref_update_mr?\n      ENV[\"CI_MERGE_REQUEST_TARGET_BRANCH_NAME\"]&.match?(%r{renovate-e2e/cng\\S+digest})\n    end",
        "comment": "Pipeline is part of MR that updates cng-mirror ref  @return [Boolean]",
        "label": "What",
        "id": "5265"
    },
    {
        "raw_code": "def composed_of(part_id, options = {})\n          options.assert_valid_keys(:class_name, :mapping, :allow_nil, :constructor, :converter)\n\n          unless self < Aggregations\n            include Aggregations\n          end",
        "comment": "Adds reader and writer methods for manipulating a value object: <tt>composed_of :address</tt> adds <tt>address</tt> and <tt>address=(new_address)</tt> methods.  Options are: * <tt>:class_name</tt> - Specifies the class name of the association. Use it only if that name can't be inferred from the part id. So <tt>composed_of :address</tt> will by default be linked to the Address class, but if the real class name is +CompanyAddress+, you'll have to specify it with this option. * <tt>:mapping</tt> - Specifies the mapping of entity attributes to attributes of the value object. Each mapping is represented as a key-value pair where the key is the name of the entity attribute and the value is the name of the attribute in the value object. The order in which mappings are defined determines the order in which attributes are sent to the value class constructor. The mapping can be written as a hash or as an array of pairs. * <tt>:allow_nil</tt> - Specifies that the value object will not be instantiated when all mapped attributes are +nil+. Setting the value object to +nil+ has the effect of writing +nil+ to all mapped attributes. This defaults to +false+. * <tt>:constructor</tt> - A symbol specifying the name of the constructor method or a Proc that is called to initialize the value object. The constructor is passed all of the mapped attributes, in the order that they are defined in the <tt>:mapping option</tt>, as arguments and uses them to instantiate a <tt>:class_name</tt> object. The default is <tt>:new</tt>. * <tt>:converter</tt> - A symbol specifying the name of a class method of <tt>:class_name</tt> or a Proc that is called when a new value is assigned to the value object. The converter is passed the single value that is used in the assignment and is only called if the new value is not an instance of <tt>:class_name</tt>. If <tt>:allow_nil</tt> is set to true, the converter can return +nil+ to skip the assignment.  Option examples: composed_of :temperature, mapping: { reading: :celsius } composed_of :balance, class_name: \"Money\", mapping: { balance: :amount } composed_of :address, mapping: { address_street: :street, address_city: :city } composed_of :address, mapping: [ %w(address_street street), %w(address_city city) ] composed_of :gps_location composed_of :gps_location, allow_nil: true composed_of :ip_address, class_name: 'IPAddr', mapping: { ip: :to_i }, constructor: Proc.new { |ip| IPAddr.new(ip, Socket::AF_INET) }, converter: Proc.new { |ip| ip.is_a?(Integer) ? IPAddr.new(ip, Socket::AF_INET) : IPAddr.new(ip.to_s) } ",
        "label": "What",
        "id": "12346"
    },
    {
        "raw_code": "def public_singleton_methods_to_ignore\n        # Singleton methods added by other libraries that we need to ignore.\n        Module.singleton_methods(false) +\n          Class.singleton_methods(false) +\n          [:_] # NOTE: `_` (from GettextI18nRails) is ignored because we mock it globally in fast_spec_helper\n      end",
        "comment": "@return [Array<Symbol>]",
        "label": "What",
        "id": "2398"
    },
    {
        "raw_code": "def self.reset\n    @post_processors = []\n    @registered = {}\n  end",
        "comment": " Clears all registered directives and post-processors",
        "label": "What",
        "id": "16366"
    },
    {
        "raw_code": "def build_merge_request\n    params[:merge_request] ||= ActionController::Parameters.new(source_project: @project)\n    new_params = merge_request_params.merge(diff_options: diff_options)\n\n    # Gitaly N+1 issue: https://gitlab.com/gitlab-org/gitlab-foss/issues/58096\n    Gitlab::GitalyClient.allow_n_plus_1_calls do\n      @merge_request = ::MergeRequests::BuildService\n        .new(project: project, current_user: current_user, params: new_params)\n        .execute\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6632"
    },
    {
        "raw_code": "def quote_table_name(name) # :nodoc:\n            QUOTED_TABLE_NAMES[name] ||= Utils.extract_schema_qualified_name(name.to_s).quoted.freeze\n          end",
        "comment": "Checks the following cases:  - table_name - \"table.name\" - schema_name.table_name - schema_name.\"table.name\" - \"schema.name\".table_name - \"schema.name\".\"table.name\"",
        "label": "What",
        "id": "13215"
    },
    {
        "raw_code": "def self.delivering_email(message)\n          unless Gitlab::CurrentSettings.html_emails_enabled\n            message.parts.delete_if do |part|\n              part.content_type.start_with?('text/html')\n            end",
        "comment": " Remove HTML part if HTML emails are disabled. ",
        "label": "What",
        "id": "3257"
    },
    {
        "raw_code": "def self.existing_shares\n          shares = get_smbshares || get_netshares\n          if shares.nil?\n            raise SyncedFolderSMB::Errors::SMBListFailed\n          end",
        "comment": "Generate a list of existing local smb shares  @return [Hash]",
        "label": "What",
        "id": "9731"
    },
    {
        "raw_code": "def fetch_version\n    versions_data.fetch('gitlab', nil)\n  end",
        "comment": "Get the version from the VERSIONS environment variable All components use the same version, so we can just get the version of gitlab",
        "label": "What",
        "id": "5372"
    },
    {
        "raw_code": "def create_temporary_workdir!\n          # Ensure base directory exists\n          # KYLE - does this need to exist? Maybe for tests?\n          FileUtils.mkdir_p(context.backup_basedir)\n\n          Pathname(Dir.mktmpdir('restore', context.backup_basedir))\n        end",
        "comment": "@return [Pathname] temporary directory",
        "label": "What",
        "id": "1040"
    },
    {
        "raw_code": "def collect\n          created_at_arel = ::Ci::Pipeline.arel_table['created_at']\n          pipelines_by_interval = project.all_pipelines\n            .where(created_at_arel.gteq(@from))\n            .where(created_at_arel.lteq(@to))\n            .group(\"date_trunc('#{interval}', #{::Ci::Pipeline.table_name}.created_at)\")\n\n          count_by_status = totals_by_status(pipelines_by_interval)\n          totals_count =\n            pipelines_by_interval\n              .count(:created_at)\n              .transform_keys { |date| date.strftime(@format) }\n\n          current = @from\n          while current <= @to\n            label = current.strftime(@format)\n            @labels       << label\n            @totals[:all] << (totals_count[label] || 0)\n            @selected_statuses.each do |status|\n              @totals[status] << (count_by_status.dig(status, label) || 0)\n            end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2450"
    },
    {
        "raw_code": "def recursive_traversal_ids(node)\n        node_id = Integer(node.id)\n        ancestor_ids = if node.parent_id\n                         node\n                           .becomes(Namespace)\n                           .recursive_self_and_ancestor_ids\n                           .reverse\n                           .join(',')\n                       else\n                         node_id\n                       end",
        "comment": "Determine traversal_ids for the node and it's descendants using recursive methods. Generate a collection of [id, traversal_ids] rows.  Note that the traversal_ids represent a calculated traversal path for the namespace and not the value stored within the traversal_ids attribute. rubocop:disable Cop/AvoidBecomes -- Normalize STI queries",
        "label": "What",
        "id": "7616"
    },
    {
        "raw_code": "def find_tracked_paths(file_paths)\n        file_paths.select do |file_path|\n          file_tracked_in_the_db?(file_path)\n        end",
        "comment": "@param file_paths [Array<String>] an array of remote file paths @return [Array<String>] a subset of the input paths that are tracked in the DB",
        "label": "What",
        "id": "2730"
    },
    {
        "raw_code": "def autocorrect(corrector, offense_range:, send_node:)\n          corrector.replace(\n            offense_range,\n            add_safe_navigation_operator(offense_range: offense_range, send_node: send_node)\n          )\n\n          corrector.wrap(send_node, '(', ')') if require_parentheses?(send_node)\n        end",
        "comment": "@param [RuboCop::Cop::Corrector] corrector @param [Parser::Source::Range] offense_range @param [RuboCop::AST::SendNode] send_node",
        "label": "What",
        "id": "10693"
    },
    {
        "raw_code": "def fetch_remote(url, refmap:, ssh_auth:, forced:, no_tags:, timeout:, prune: true, http_authorization_header: \"\", resolved_address: \"\")\n        request = Gitaly::FetchRemoteRequest.new(\n          repository: @gitaly_repo,\n          force: forced,\n          no_tags: no_tags,\n          timeout: timeout,\n          no_prune: !prune,\n          remote_params: Gitaly::Remote.new(\n            url: url,\n            mirror_refmaps: Array.wrap(refmap).map(&:to_s),\n            http_authorization_header: http_authorization_header,\n            resolved_address: resolved_address\n          )\n        )\n\n        if ssh_auth&.ssh_mirror_url?\n          if ssh_auth.ssh_key_auth? && ssh_auth.ssh_private_key.present?\n            request.ssh_key = ssh_auth.ssh_private_key\n          end",
        "comment": "rubocop: disable Metrics/ParameterLists The `remote` parameter is going away soonish anyway, at which point the Rubocop warning can be enabled again.",
        "label": "What",
        "id": "1791"
    },
    {
        "raw_code": "def has_imported_project?(\n            gh_project_name,\n            wait: QA::Support::WaitForRequests::DEFAULT_MAX_WAIT_TIME,\n            allow_partial_import: false\n          )\n            within_element('project-import-row', source_project: gh_project_name, skip_finished_loading_check: true) do\n              wait_until(\n                max_duration: wait,\n                sleep_interval: 5,\n                reload: false,\n                skip_finished_loading_check_on_refresh: true\n              ) do\n                status_selector = 'import-status-indicator'\n\n                next has_element?(status_selector, text: \"Complete\", wait: 1) unless allow_partial_import\n\n                [\"Partially completed\", \"Complete\"].any? do |status|\n                  has_element?(status_selector, text: status, wait: 1)\n                end",
        "comment": "Check if import page has a successfully imported project  @param [String] source_project_name @param [Integer] wait @return [Boolean]",
        "label": "What",
        "id": "4272"
    },
    {
        "raw_code": "def save_tags\n      super unless Thread.current[BULK_INSERT_TAG_THREAD_KEY]\n    end",
        "comment": "overrides save_tags from acts-as-taggable",
        "label": "What",
        "id": "7436"
    },
    {
        "raw_code": "def current_page?(options = nil, check_parameters: false, method: :get, **options_as_kwargs)\n        unless request\n          raise \"You cannot use helpers that need to determine the current \" \\\n                \"page unless your view context provides a Request object \" \\\n                \"in a #request method\"\n        end",
        "comment": "True if the current request URI was generated by the given +options+.  ==== Examples Let's say we're in the <tt>http://www.example.com/shop/checkout?order=desc&page=1</tt> action.  current_page?(action: 'process') # => false  current_page?(action: 'checkout') # => true  current_page?(controller: 'library', action: 'checkout') # => false  current_page?(controller: 'shop', action: 'checkout') # => true  current_page?(controller: 'shop', action: 'checkout', order: 'asc') # => false  current_page?(controller: 'shop', action: 'checkout', order: 'desc', page: '1') # => true  current_page?(controller: 'shop', action: 'checkout', order: 'desc', page: '2') # => false  current_page?('http://www.example.com/shop/checkout') # => true  current_page?('http://www.example.com/shop/checkout', check_parameters: true) # => false  current_page?('/shop/checkout') # => true  current_page?('http://www.example.com/shop/checkout?order=desc&page=1') # => true  Different actions may share the same URL path but have a different HTTP method. Let's say we sent a POST to <tt>http://www.example.com/products</tt> and rendered a validation error.  current_page?(controller: 'product', action: 'index') # => false  current_page?(controller: 'product', action: 'create') # => false  current_page?(controller: 'product', action: 'create', method: :post) # => true  current_page?(controller: 'product', action: 'index', method: [:get, :post]) # => true  We can also pass in the symbol arguments instead of strings. ",
        "label": "What",
        "id": "11995"
    },
    {
        "raw_code": "def run_verifier(list)\n        options.verifier ? options.verifier.run(list) : list\n      end",
        "comment": "(see Templates::Helpers::BaseHelper#run_verifier)",
        "label": "What",
        "id": "540"
    },
    {
        "raw_code": "def top_paths(repo, options = {})\n        get \"#{Repository.path repo}/traffic/popular/paths\", options\n      end",
        "comment": "Get the top 10 popular contents over the last 14 days  @param repo [Integer, String, Repository, Hash] A GitHub repository @return [Array<Sawyer::Resource>] List of popular contents @see https://developer.github.com/v3/repos/traffic/#list-paths @example @client.top_paths('octokit/octokit.rb')",
        "label": "What",
        "id": "15068"
    },
    {
        "raw_code": "def delete_project(id, options = {})\n        boolean_from_response :delete, \"projects/#{id}\", options\n      end",
        "comment": "Delete a project  Requires authenticated client  @param id [Integer] Project id @return [Boolean] Result of deletion @see https://developer.github.com/v3/projects/#delete-a-project @example @client.delete_project(123942)",
        "label": "What",
        "id": "15319"
    },
    {
        "raw_code": "def with_tracker(tracker)\n      with_entity(tracker.entity)\n      @tracker = tracker\n      self\n    end",
        "comment": "Extract key information from a provided tracker and its entity and include it in log entries created from this logger instance. @param tracker [BulkImports::Tracker]",
        "label": "What",
        "id": "3602"
    },
    {
        "raw_code": "def fetch_qa_user_id(qa_username)\n        user_response = get Runtime::API::Request.new(api_client, \"/users\", username: qa_username).url\n\n        unless user_response.code == HTTP_STATUS_OK\n          logger.error(\"Request for #{qa_username} returned (#{user_response.code}): `#{user_response}` \")\n          exit 1 if fatal_response?(user_response.code)\n          return\n        end",
        "comment": "Fetches the user ID of the given username  @param [String] qa_username @return [Integer]",
        "label": "What",
        "id": "4758"
    },
    {
        "raw_code": "def manage_ghes_username=(value)\n      reset_agent\n      @manage_ghes_username = value\n    end",
        "comment": "Set Manage GHES API username  @param value [String] Manage GHES API username",
        "label": "What",
        "id": "14900"
    },
    {
        "raw_code": "def pull_request_commits(repo, number, options = {})\n        paginate \"#{Repository.path repo}/pulls/#{number}/commits\", options\n      end",
        "comment": "List commits on a pull request  @see https://developer.github.com/v3/pulls/#list-commits-on-a-pull-request @param repo [Integer, String, Hash, Repository] A GitHub repository @param number [Integer] Number of pull request @return [Array<Sawyer::Resource>] List of commits",
        "label": "What",
        "id": "15090"
    },
    {
        "raw_code": "def stop\n      deadline = ::Process.clock_gettime(::Process::CLOCK_MONOTONIC) + @config[:timeout]\n\n      quiet\n      stoppers = @managers.map do |mgr|\n        Thread.new do\n          mgr.stop(deadline)\n        end",
        "comment": "Shuts down this Sidekiq instance. Waits up to the deadline for all jobs to complete.",
        "label": "What",
        "id": "5088"
    },
    {
        "raw_code": "def host_with_port(address = Runtime::Scenario.gitlab_address, with_default_port: true)\n          uri = address.is_a?(URI) ? address : URI.parse(address)\n          port = !with_default_port && [80, 443].include?(uri.port) ? \"\" : \":#{uri.port}\"\n\n          \"#{uri.host}#{port}#{uri.path}\"\n        end",
        "comment": "Get gitlab host with port and path  @param [<String, URI>] address @param [Boolean] with_default_port keep default port 80 or 443 @return [String]",
        "label": "What",
        "id": "4574"
    },
    {
        "raw_code": "def relate_issuables(referenced_issuable)\n      link = link_class.find_or_initialize_by(source: issuable, target: referenced_issuable)\n\n      set_link_type(link)\n\n      if link.changed? && link.save\n        new_links << link\n        create_notes(link)\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6132"
    },
    {
        "raw_code": "def refresh_access_token(code, app_id = client_id, app_secret = client_secret, options = {})\n        options = options.merge({\n                                  refresh_token: code,\n                                  client_id: app_id,\n                                  client_secret: app_secret,\n                                  grant_type: 'refresh_token',\n                                  headers: {\n                                    content_type: 'application/json',\n                                    accept: 'application/json'\n                                  }\n                                })\n\n        post \"#{web_endpoint}login/oauth/access_token\", options\n      end",
        "comment": "Refresh a user's access token with a refresh token.  Applications can refresh an access token without requiring a user to re-authorize using refresh access token.  @param code [String] 40 character GitHub OAuth refresh access token  @return [Sawyer::Resource] @see https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/refreshing-user-access-tokens#refreshing-a-user-access-token-with-a-refresh-token  @example client = Octokit::Client.new(:client_id => 'abcdefg12345', :client_secret => 'secret') client.refresh_access_token('40-character-refresh-token')",
        "label": "What",
        "id": "15468"
    },
    {
        "raw_code": "def scrollable(**options, &)\n    options[:class] = \"#{options[:class]} lg:max-h-96 lg:overflow-y-auto \" \\\n                      \"-mx-4 -mb-6 md:-mx-10 md:-mb-10 \" \\\n                      \"border-t border-neutral-200 dark:border-neutral-800\"\n    div(**options) do\n      div(class: \"px-4 pt-6 md:px-10 md:pt-10\", &)\n    end",
        "comment": "removes padding inside the \"content\" area of the card so scroll bar and overflaw appear correctly adds a border to the top of the scrollable area to explain the content being hidden on scroll",
        "label": "What",
        "id": "10009"
    },
    {
        "raw_code": "def _Plain\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_Inlines)\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Plain = Inlines:a { paragraph a }",
        "label": "What",
        "id": "15596"
    },
    {
        "raw_code": "def count_service\n      ::Projects::OpenMergeRequestsCountService\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5908"
    },
    {
        "raw_code": "def up\n    create_table :vulnerability_severity_overrides do |t|\n      t.references :vulnerability, index: true, null: false, foreign_key: { on_delete: :cascade }\n      t.references :author, index: true\n      t.timestamps_with_timezone null: false\n      t.bigint :project_id, index: true, null: false\n      t.column :original_severity, :smallint, null: false\n      t.column :new_severity, :smallint, null: false\n    end",
        "comment": "rubocop:disable Migration/EnsureFactoryForTable -- False positive",
        "label": "What",
        "id": "5024"
    },
    {
        "raw_code": "def ==(o)\n      return true if self.equal?(o)\n      self.class == o.class &&\n          fingerprint == o.fingerprint &&\n          project_id == o.project_id &&\n          payload == o.payload &&\n          name == o.name &&\n          description == o.description &&\n          actor == o.actor &&\n          environment == o.environment &&\n          platform == o.platform\n    end",
        "comment": "Checks equality by comparing each attribute. @param [Object] Object to be compared",
        "label": "What",
        "id": "921"
    },
    {
        "raw_code": "def display_page(name)\n    store_name, page_name = name.split ':', 2\n\n    store = @stores.find { |s| s.source == store_name }\n\n    return display_page_list store if page_name.empty?\n\n    pages = store.cache[:pages]\n\n    unless pages.include? page_name then\n      found_names = pages.select do |n|\n        n =~ /#{Regexp.escape page_name}\\.[^.]+$/\n      end",
        "comment": " Outputs formatted RI data for page +name+.",
        "label": "What",
        "id": "16598"
    },
    {
        "raw_code": "def push_force_frontend_feature_flag(name, enabled)\n      raise ArgumentError, 'enabled flag must be a Boolean' unless enabled.in?([true, false])\n\n      push_to_gon_attributes(:features, name, enabled)\n    end",
        "comment": "Exposes the state of a feature flag to the frontend code. Can be used for more complex feature flag checks.  name - The name of the feature flag, e.g. `my_feature`. enabled - Boolean to be pushed directly to the frontend. Should be fetched by checking a feature flag.",
        "label": "What",
        "id": "1574"
    },
    {
        "raw_code": "def self.read_config_file\n      if File.file?(CONFIG_FILE)\n        require 'yaml'\n        if YAML.respond_to?(:safe_load_file)\n          YAML.safe_load_file(CONFIG_FILE, permitted_classes: [SymbolHash, Symbol])\n        else\n          YAML.load_file(CONFIG_FILE)\n        end",
        "comment": "Loads the YAML configuration file into memory @return [Hash] the contents of the YAML file from disk @see CONFIG_FILE",
        "label": "What",
        "id": "160"
    },
    {
        "raw_code": "def upload_example_runtimes(glob)\n        raise \"QA_RUN_TYPE must be set for custom report\" unless run_type\n\n        reports = Pathname.glob(glob).select { |file| file.extname == \".json\" }\n        raise \"Glob '#{glob}' did not contain any valid report files!\" if reports.empty?\n\n        logger.info(\"Processing '#{reports.size}' report files\")\n        report = example_runtimes(reports).sort.to_h\n\n        file = \"#{EXAMPLE_RUNTIMES_PATH}/#{run_type}.json\"\n        logger.info(\"Uploading example runtime report '#{file}'\")\n        client.put_object(BUCKET, file, JSON.pretty_generate(report))\n      end",
        "comment": "Create and upload custom report based on data from JsonFormatter report files  @param glob [String] @return [void]",
        "label": "What",
        "id": "4534"
    },
    {
        "raw_code": "def documentation_url\n      data[:documentation_url] if data.is_a? Hash\n    end",
        "comment": "Documentation URL returned by the API for some errors  @return [String]",
        "label": "What",
        "id": "14856"
    },
    {
        "raw_code": "def up\n    # these tables are currently unused, there should be no data in them\n    # truncating for unexpected cases (local dev, failed migrations, etc)\n    truncate_tables! 'system_access_group_microsoft_graph_access_tokens', 'system_access_group_microsoft_applications'\n\n    remove_index :system_access_group_microsoft_applications,\n      name: 'index_system_access_group_microsoft_applications_on_group_id'\n\n    add_index :system_access_group_microsoft_applications, :group_id, unique: true\n  end",
        "comment": "rubocop:disable Migration/AddIndex, Migration/RemoveIndex -- these are on empty tables",
        "label": "What",
        "id": "4988"
    },
    {
        "raw_code": "def quote_string(string)\n        with_raw_connection(allow_retry: true, materialize_transactions: false) do |connection|\n          connection.escape(string)\n        end",
        "comment": "-- QUOTING ================================================== ++ Quotes strings for use in SQL input.",
        "label": "What",
        "id": "12959"
    },
    {
        "raw_code": "def css_class_attribute(type, html_options_class, options) # :nodoc:\n          css_class = \\\n            case options\n            when Hash\n              options[type.to_sym]\n            else\n              type\n            end",
        "comment": "Builds the CSS class value for the select element.  css_class_attribute(:year, 'date optional', { year: 'my-year' }) => \"date optional my-year\"",
        "label": "What",
        "id": "11851"
    },
    {
        "raw_code": "def managed_prometheus?\n      false\n    end",
        "comment": "Overridden in app/models/clusters/applications/prometheus.rb",
        "label": "What",
        "id": "7315"
    },
    {
        "raw_code": "def save_fabrication(type, time)\n          return unless Thread.current.key?(type)\n          return unless top_level_fabrication?\n\n          Thread.current[type] += time\n        end",
        "comment": "Save fabrication time if it's first in fabrication stack  @param [Symbol] type @param [Symbol] time @return [void]",
        "label": "What",
        "id": "4561"
    },
    {
        "raw_code": "def commits\n        strong_memoize(:commits) do\n          newrevs = @changes.filter_map do |change|\n            newrev = change[:newrev]\n\n            next if blank_rev?(newrev)\n\n            newrev\n          end",
        "comment": "All commits which have been newly introduced via any of the given changes. This set may also contain commits which are not referenced by any of the new revisions.",
        "label": "What",
        "id": "2071"
    },
    {
        "raw_code": "def delete_impersonation_token(login, options = {})\n        boolean_from_response :delete, \"admin/users/#{login}/authorizations\", options\n      end",
        "comment": "Deletes an impersonation OAuth token.  @param login [String] The user whose token should be deleted. @see https://developer.github.com/enterprise/v3/enterprise-admin/users/#delete-an-impersonation-oauth-token @example @admin_client.delete_impersonation_token('foobar')",
        "label": "What",
        "id": "14965"
    },
    {
        "raw_code": "def merge_request_iid\n    ENV.fetch('CI_MERGE_REQUEST_IID', nil)\n  end",
        "comment": "Take the merge request ID from the CI_MERGE_REQUEST_IID predefined variable.",
        "label": "What",
        "id": "5290"
    },
    {
        "raw_code": "def rdoc_task_description\n    'Build RDoc HTML files'\n  end",
        "comment": " Task description for the rdoc task or its renamed equivalent",
        "label": "What",
        "id": "15524"
    },
    {
        "raw_code": "def swap_partitioned_foreign_keys(table_name, old_foreign_key, new_foreign_key)\n          partitioned_table = find_partitioned_table(table_name)\n          partitioned_table.postgres_partitions.order(:name).each do |partition|\n            swap_foreign_keys(partition.identifier, old_foreign_key, new_foreign_key)\n          end",
        "comment": "Swap the foreign key names for partitioned table and its partitions.  Example:  swap_partitioned_foreign_keys :users, 'existing_partitioned_fk_name_1', 'existing_partitioned_fk_name_2'",
        "label": "What",
        "id": "3045"
    },
    {
        "raw_code": "def reversed_order\n          self.class.build(column_definitions.map(&:reverse))\n        end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2008"
    },
    {
        "raw_code": "def fail_message(negate: false)\n              \"#{e}:\\n\\nexpected #{negate ? 'not ' : ''}to #{description}\\n\\n\" \\\n                \"last attempt was: #{@result.nil? ? 'nil' : actual_formatted}\\n\\n\" \\\n                \"Diff:#{diff}\"\n            end",
        "comment": "Custom failure message  @param [Boolean] negate @return [String]",
        "label": "What",
        "id": "4592"
    },
    {
        "raw_code": "def _Ticks5\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"`````\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Ticks5 = \"`````\" !\"`\"",
        "label": "What",
        "id": "15789"
    },
    {
        "raw_code": "def light\n      render(Pajamas::SpinnerComponent.new(color: :light))\n    end",
        "comment": "Use a light spinner on dark backgrounds.  @display bg_dark true",
        "label": "What",
        "id": "8202"
    },
    {
        "raw_code": "def delete(*path_or_actions, as: DEFAULT, to: nil, controller: nil, action: nil, on: nil, defaults: nil, constraints: nil, anchor: nil, format: nil, path: nil, internal: nil, **mapping, &block)\n          if path_or_actions.grep(Hash).any? && (deprecated_options = path_or_actions.extract_options!)\n            as = assign_deprecated_option(deprecated_options, :as, :delete) if deprecated_options.key?(:as)\n            to ||= assign_deprecated_option(deprecated_options, :to, :delete)\n            controller ||= assign_deprecated_option(deprecated_options, :controller, :delete)\n            action ||= assign_deprecated_option(deprecated_options, :action, :delete)\n            on ||= assign_deprecated_option(deprecated_options, :on, :delete)\n            defaults ||= assign_deprecated_option(deprecated_options, :defaults, :delete)\n            constraints ||= assign_deprecated_option(deprecated_options, :constraints, :delete)\n            anchor = assign_deprecated_option(deprecated_options, :anchor, :delete) if deprecated_options.key?(:anchor)\n            format = assign_deprecated_option(deprecated_options, :format, :delete) if deprecated_options.key?(:format)\n            path ||= assign_deprecated_option(deprecated_options, :path, :delete)\n            internal ||= assign_deprecated_option(deprecated_options, :internal, :delete)\n            assign_deprecated_options(deprecated_options, mapping, :delete)\n          end",
        "comment": "Define a route that only recognizes HTTP DELETE. For supported arguments, see [match](rdoc-ref:Base#match)  delete 'broccoli', to: 'food#broccoli'",
        "label": "What",
        "id": "11567"
    },
    {
        "raw_code": "def build(\n        project:, user:, ref:, oldrev: nil, newrev: nil,\n        commits: [], commits_count: nil, message: nil, push_options: {},\n        with_changed_files: true\n      )\n        commits = Array(commits)\n\n        # Total commits count\n        commits_count ||= commits.size\n\n        # Get latest 20 commits ASC\n        commits_limited = commits.last(20)\n\n        # For performance purposes maximum 20 latest commits\n        # will be passed as post receive hook data.\n        # n+1: https://gitlab.com/gitlab-org/gitlab-foss/issues/38259\n        commit_attrs = Gitlab::GitalyClient.allow_n_plus_1_calls do\n          commits_limited.map do |commit|\n            commit.hook_attrs(with_changed_files: with_changed_files)\n          end",
        "comment": "Produce a hash of post-receive data  data = { before: String, after: String, ref: String, ref_protected: Boolean, user_id: String, user_name: String, user_username: String, user_email: String project_id: Fixnum, project: { id: Fixnum, name: String, description: String, web_url: String, avatar_url: String, git_ssh_url: String, git_http_url: String, namespace: String, visibility_level: Fixnum, path_with_namespace: String, default_branch: String } repository: { name: String, url: String, description: String, homepage: String, }, commits: Array, total_commits_count: Fixnum, push_options: Hash }  rubocop:disable Metrics/ParameterLists",
        "label": "What",
        "id": "1782"
    },
    {
        "raw_code": "def up\n    prepare_async_index :software_license_policies, :approval_policy_rule_id, name: INDEX_NAME\n  end",
        "comment": "TODO: Index to be created synchronously as part of https://gitlab.com/gitlab-org/gitlab/-/merge_requests/155256",
        "label": "What",
        "id": "4912"
    },
    {
        "raw_code": "def ==(other)\n        other.is_a?(self.class) &&\n          name == other.name &&\n          time_framed? == other.time_framed? &&\n          filter == other.filter &&\n          unique_identifier_name == other.unique_identifier_name &&\n          operator == other.operator\n      end",
        "comment": "Implementing `==` to make sure that `a == b` is true if and only if `a` and `b` have equal properties Checks equality by comparing each attribute. @param [Object] Object to be compared",
        "label": "What",
        "id": "1977"
    },
    {
        "raw_code": "def remove_whitespace_in_branches(corrector, branch, condition, column)\n          branch.each_node do |child|\n            next if child.source_range.nil?\n            next if child.parent.dstr_type?\n\n            white_space = white_space_range(child, column)\n            corrector.remove(white_space) if white_space.source.strip.empty?\n          end",
        "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "10541"
    },
    {
        "raw_code": "def uuid_v7(extra_timestamp_bits: 0) # rubocop:disable Metrics/AbcSize -- Ported as is\n      case (extra_timestamp_bits = Integer(extra_timestamp_bits))\n      when 0 # min timestamp precision\n        ms = Process.clock_gettime(Process::CLOCK_REALTIME, :millisecond)\n        rand = SecureRandom.random_bytes(10)\n        rand.setbyte(0, (rand.getbyte(0) & 0x0f) | 0x70) # version\n        rand.setbyte(2, (rand.getbyte(2) & 0x3f) | 0x80) # variant\n        format(\"%08x-%04x-%s\", (ms & 0x0000_ffff_ffff_0000) >> 16, (ms & 0x0000_0000_0000_ffff),\n          rand.unpack(\"H4H4H12\").join(\"-\"))\n\n      when 12 # max timestamp precision\n        ms, ns = Process.clock_gettime(Process::CLOCK_REALTIME, :nanosecond)\n                   .divmod(1_000_000)\n        extra_bits = ns * 4096 / 1_000_000\n        rand = SecureRandom.random_bytes(8)\n        rand.setbyte(0, (rand.getbyte(0) & 0x3f) | 0x80) # variant\n        format(\"%08x-%04x-7%03x-%s\", (ms & 0x0000_ffff_ffff_0000) >> 16, (ms & 0x0000_0000_0000_ffff), extra_bits,\n          rand.unpack(\"H4H12\").join(\"-\"))\n\n      when (0..12) # the generic version is slower than the special cases above\n        rand_a, rand_b1, rand_b2, rand_b3 = SecureRandom.random_bytes(10).unpack(\"nnnN\")\n        rand_mask_bits = 12 - extra_timestamp_bits\n        ms, ns = Process.clock_gettime(Process::CLOCK_REALTIME, :nanosecond)\n                   .divmod(1_000_000)\n        format(\"%08x-%04x-%04x-%04x-%04x%08x\",\n          (ms & 0x0000_ffff_ffff_0000) >> 16, (ms & 0x0000_0000_0000_ffff), 0x7000 |\n            ((ns * (1 << extra_timestamp_bits) / 1_000_000) << rand_mask_bits) |\n            (rand_a & ((1 << rand_mask_bits) - 1)), 0x8000 | (rand_b1 & 0x3fff), rand_b2, rand_b3)\n\n      else\n        raise ArgumentError, \"extra_timestamp_bits must be in 0..12, got: #{extra_timestamp_bits}\"\n      end",
        "comment": "Generate a random v7 UUID (Universally Unique IDentifier). Ported from ruby 3.3.0's https://github.com/ruby/securerandom/commit/34ed1a2ec35dc8f00ff69665b373cef7484c937f TODO remove when we support min ruby 3.3.0",
        "label": "What",
        "id": "1226"
    },
    {
        "raw_code": "def flush_after_commit_queue(merge_request)\n  # To prevent idle in transaction timeouts, defer the creation of the\n  # NewMergeRequestWorker in a real Sidekiq job.\n  Sidekiq::Testing.disable! do\n    Gitlab::ExclusiveLease.skipping_transaction_check do\n      # Seed-Fu runs this entire fixture in a transaction, so the `after_commit`\n      # hook won't run until after the fixture is loaded. That is too late\n      # since the Sidekiq::Testing block has already exited. Force clearing\n      # the `after_commit` queue to ensure the job is run now.\n      merge_request.send(:_run_after_commit_queue)\n    end",
        "comment": "Normally merge requests build their diffs in an async job via NewMergeRequestWorker, but this method will force the after_create actions to happen inline.",
        "label": "What",
        "id": "4835"
    },
    {
        "raw_code": "def beginning_of_day\n    in_time_zone\n  end",
        "comment": "Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)",
        "label": "What",
        "id": "14120"
    },
    {
        "raw_code": "def help\n          '<p>Use this service to send notifications about events in ' \\\n            'GitLab projects to your Microsoft Teams channels. ' \\\n            '<a href=\"https://docs.gitlab.com/ee/user/project/integrations/microsoft_teams.html\" target=\"_blank\" ' \\\n            'rel=\"noopener noreferrer\">How do I configure this integration?</a></p>'\n        end",
        "comment": "rubocop:disable Gitlab/DocumentationLinks/HardcodedUrl -- legacy use",
        "label": "What",
        "id": "7487"
    },
    {
        "raw_code": "def user_issues(options = {})\n        paginate 'user/issues', options\n      end",
        "comment": "List all issues across owned and member repositories for the authenticated user  @param options [Sawyer::Resource] A customizable set of options. @option options [String] :filter (assigned) State: <tt>assigned</tt>, <tt>created</tt>, <tt>mentioned</tt>, <tt>subscribed</tt> or <tt>closed</tt>. @option options [String] :state (open) State: <tt>open</tt>, <tt>closed</tt>, or <tt>all</tt>. @option options [Array<String>] :labels List of Label names. Example: <tt>['bug', 'ui', '@high']</tt>. @option options [String] :sort (created) Sort: <tt>created</tt>, <tt>updated</tt>, or <tt>comments</tt>. @option options [String] :direction (desc) Direction: <tt>asc</tt> or <tt>desc</tt>. @option options [Integer] :page (1) Page number. @option options [String] :since Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ @return [Array<Sawyer::Resource>] A list of issues for a repository. @see https://developer.github.com/v3/issues/#list-issues @example List issues for the authenticated user across owned and member repositories @client = Octokit::Client.new(:login => 'foo', :password => 'bar') @client.user_issues",
        "label": "What",
        "id": "15243"
    },
    {
        "raw_code": "def self.find_pod_spec(desired_config_array)\n                desired_config_array => [\n                  *_,\n                  {\n                    kind: \"Deployment\",\n                    spec: {\n                      template: {\n                        spec: pod_spec\n                      }\n                    }\n                  },\n                  *_\n                ]\n\n                pod_spec\n              end",
        "comment": "@param [Array<Hash>] desired_config_array @return [Hash]",
        "label": "What",
        "id": "3339"
    },
    {
        "raw_code": "def subclass_from_attributes(attrs)\n          attrs = attrs.to_h if attrs.respond_to?(:permitted?)\n          if attrs.is_a?(Hash)\n            subclass_name = attrs[inheritance_column] || attrs[inheritance_column.to_sym]\n\n            if subclass_name.present?\n              find_sti_class(subclass_name)\n            end",
        "comment": "Detect the subclass from the inheritance column of attrs. If the inheritance column value is not self or a valid subclass, raises ActiveRecord::SubclassNotFound",
        "label": "What",
        "id": "12477"
    },
    {
        "raw_code": "def scripts_folder\n    HOMEBREW_PREFIX/\"share/pypy#{abi_version}\"\n  end",
        "comment": "Where setuptools will install executable scripts",
        "label": "What",
        "id": "35"
    },
    {
        "raw_code": "def complete_diff_path\n      nil\n    end",
        "comment": "When overridden this method should return a path to view the complete diffs in the UI.",
        "label": "What",
        "id": "6580"
    },
    {
        "raw_code": "def write_options\n          InfluxDB2::WriteOptions.new(\n            write_type: InfluxDB2::WriteType::BATCHING,\n            batch_size: 100,\n            max_retries: 3\n          )\n        end",
        "comment": "Write options for influxdb  @return [InfluxDB::WriteOptions]",
        "label": "What",
        "id": "4794"
    },
    {
        "raw_code": "def ssl_verify_mode\n        # 0 is OpenSSL::SSL::VERIFY_NONE\n        # 1 is OpenSSL::SSL::SSL_VERIFY_PEER\n        # the standard default for SSL is SSL_VERIFY_PEER which requires a server certificate check on the client\n        ENV.fetch('OCTOKIT_SSL_VERIFY_MODE', 1).to_i\n      end",
        "comment": "Default SSL verify mode from ENV @return [Integer]",
        "label": "What",
        "id": "14894"
    },
    {
        "raw_code": "def api_post_body\n        {\n          link_url: link_url,\n          image_url: image_url\n        }\n      end",
        "comment": "Params for label creation  @return [Hash]",
        "label": "What",
        "id": "4198"
    },
    {
        "raw_code": "def existing_labels\n          @existing_labels ||= project.labels.pluck(:title).to_set\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2191"
    },
    {
        "raw_code": "def test_generate_message_accepted_with_default_message\n    assert_equal \"must be accepted\", @person.errors.generate_message(:title, :accepted)\n  end",
        "comment": "validates_acceptance_of: generate_message(attr_name, :accepted, message: custom_message)",
        "label": "What",
        "id": "12329"
    },
    {
        "raw_code": "def down\n    unprepare_async_index :merge_request_diff_commits, :merge_request_commits_metadata_id, name: INDEX_NAME\n  end",
        "comment": "rubocop:enable Migration/PreventIndexCreation",
        "label": "What",
        "id": "4960"
    },
    {
        "raw_code": "def is_alias?\n      return false unless namespace.is_a?(NamespaceObject)\n      namespace.aliases.key? self\n    end",
        "comment": "Tests if the object is defined as an alias of another method @return [Boolean] whether the object is an alias",
        "label": "What",
        "id": "556"
    },
    {
        "raw_code": "def expected_checksum(_object)\n        raise NotImplementedError\n      end",
        "comment": "The checksum we expect the object to have",
        "label": "What",
        "id": "2288"
    },
    {
        "raw_code": "def management_console_endpoint=(value)\n      reset_agent\n      @management_console_endpoint = value\n    end",
        "comment": "Set Enterprise Management Console endpoint  @param value [String] Management console endpoint",
        "label": "What",
        "id": "14838"
    },
    {
        "raw_code": "def source_import_large_files(repo, options = {})\n        get \"#{Repository.path repo}/import/large_files\", options\n      end",
        "comment": "List source import large files  @param repo [Integer, String, Hash, Repository] A GitHub repository. @param options [Hash] @option options [Integer] :page Page of paginated results @return [Array<Sawyer::Resource>] Array of hashes representing files over 100MB. @see https://developer.github.com/v3/migration/source_imports/#get-large-files  @example @client.source_import_large_files(\"octokit/octokit.rb\")",
        "label": "What",
        "id": "15280"
    },
    {
        "raw_code": "def default(factory: :oidc_rubygem_trusted_publisher, environment: nil, repository_name: \"rubygem2\", workflow_filename: \"push_gem.yml\")\n    github_action = FactoryBot.build(:oidc_trusted_publisher_github_action, environment:, repository_name:, workflow_filename:)\n    trusted_publisher = FactoryBot.build(factory, trusted_publisher: github_action)\n    render Wrapper.new(form_object: trusted_publisher)\n  end",
        "comment": "@param factory select \"factory for the containing trusted publisher\" { choices: [oidc_rubygem_trusted_publisher, oidc_pending_trusted_publisher] }",
        "label": "What",
        "id": "10041"
    },
    {
        "raw_code": "def to_hash\n            serializer = Gitlab::Backup::Cli::Metadata::Serializer\n\n            METADATA_SCHEMA.each_with_object({}) do |(attribute_name, type), output|\n              # fetch attribute value dynamically\n              # rubocop:disable GitlabSecurity/PublicSend - we cant use read_attribute here, methods are already limited\n              value = public_send(attribute_name)\n              # rubocop:enable GitlabSecurity/PublicSend\n              serialized_value = serializer.serialize_value(type: type, value: value)\n\n              output[attribute_name] = serialized_value\n            end",
        "comment": "Expose the information that will be part of the Metadata JSON file",
        "label": "What",
        "id": "1084"
    },
    {
        "raw_code": "def truncate(truncate_to, options = {})\n    return dup unless length > truncate_to\n\n    omission = options[:omission] || \"...\"\n    length_with_room_for_omission = truncate_to - omission.length\n    stop = \\\n      if options[:separator]\n        rindex(options[:separator], length_with_room_for_omission) || length_with_room_for_omission\n      else\n        length_with_room_for_omission\n      end",
        "comment": "Truncates a given +text+ to length <tt>truncate_to</tt> if +text+ is longer than <tt>truncate_to</tt>:  'Once upon a time in a world far far away'.truncate(27) # => \"Once upon a time in a wo...\"  Pass a string or regexp <tt>:separator</tt> to truncate +text+ at a natural break:  'Once upon a time in a world far far away'.truncate(27, separator: ' ') # => \"Once upon a time in a...\"  'Once upon a time in a world far far away'.truncate(27, separator: /\\s/) # => \"Once upon a time in a...\"  The last characters will be replaced with the <tt>:omission</tt> string (defaults to \"...\"). The total length will not exceed <tt>truncate_to</tt> unless both +text+ and <tt>:omission</tt> are longer than <tt>truncate_to</tt>:  'And they found that many people were sleeping better.'.truncate(25, omission: '... (continued)') # => \"And they f... (continued)\"  'And they found that many people were sleeping better.'.truncate(4, omission: '... (continued)') # => \"... (continued)\"",
        "label": "What",
        "id": "14357"
    },
    {
        "raw_code": "def organization_invitations(org, options = {})\n        get \"#{Organization.path org}/invitations\", options\n      end",
        "comment": "List pending organization invitations  Requires authenticated organization member.  @param org [String, Integer] Organization GitHub login or id. @return [Array<Sawyer::Resource>] Array of hashes representing invitations. @see https://developer.github.com/v3/orgs/members/#list-pending-organization-invitations  @example @client.organization_invitations('github')",
        "label": "What",
        "id": "15425"
    },
    {
        "raw_code": "def class_methods\n    @cache[:class_methods]\n  end",
        "comment": " Class methods cache accessor.  Maps a class to an Array of its class methods (not full name).",
        "label": "What",
        "id": "15855"
    },
    {
        "raw_code": "def test_stats(stats_type, record)\n        {\n          name: stats_type,\n          time: record.values['_time'],\n          tags: tags(record.values),\n          fields: fields(record.values)\n        }\n      end",
        "comment": "Produces a test_stats Hash  @param [String] stats_type of data @param [String] record to get the data from @return [Hash]",
        "label": "What",
        "id": "4655"
    },
    {
        "raw_code": "def javascripts\n  %w(js/jquery.js js/app.js)\nend",
        "comment": "@return [Array<String>] core javascript files for layout @since 0.7.0",
        "label": "What",
        "id": "734"
    },
    {
        "raw_code": "def <<(str)\n        @mu.synchronize do\n          while i = str.index(\"\\n\")\n            @callback.call((@buffer + str[0, i+1]).rstrip)\n            @buffer.clear\n            str = str[i+1, str.length].to_s\n          end",
        "comment": "Add string data to output  @param [String] str String of data to output @return [self]",
        "label": "What",
        "id": "9294"
    },
    {
        "raw_code": "def shell_cmd(opts)\n        case opts[:shell].to_s\n        when \"cmd\"\n          \"cmd.exe /c '#{opts[:command]}'\"\n        else\n          opts[:command]\n        end",
        "comment": "Wrap the shell if required. By default we are using powershell which requires no modification. If cmd is defined as shell, add prefix to start within cmd.exe",
        "label": "What",
        "id": "9393"
    },
    {
        "raw_code": "def can_query?\n      prometheus_client.present?\n    end",
        "comment": "This is a heavy-weight check if a prometheus is properly configured and accessible from GitLab. This actually sends a request to an external service and often it could take a long time, Please consider using `configured?` instead if the process is running on Puma threads.",
        "label": "What",
        "id": "7317"
    },
    {
        "raw_code": "def set_resource_fields\n    return unless set_blocked_pending_approval?\n\n    resource.state = User::BLOCKED_PENDING_APPROVAL_STATE\n  end",
        "comment": "overridden by EE module",
        "label": "What",
        "id": "6406"
    },
    {
        "raw_code": "def do_classes_and_modules\n    do_boot_defclass if @file_name == \"class.c\"\n\n    @content.scan(\n      %r(\n        (?<open>\\s*\\(\\s*) {0}\n        (?<close>\\s*\\)\\s*) {0}\n        (?<name>\\s*\"(?<class_name>\\w+)\") {0}\n        (?<parent>\\s*(?:\n          (?<parent_name>[\\w\\*\\s\\(\\)\\.\\->]+) |\n          rb_path2class\\s*\\(\\s*\"(?<path>[\\w:]+)\"\\s*\\)\n        )) {0}\n        (?<under>\\w+) {0}\n\n        (?<var_name>[\\w\\.]+)\\s* =\n        \\s*rb_(?:\n          define_(?:\n            class(?: # rb_define_class(name, parent_name)\n              \\(\\s*\n                \\g<name>,\n                \\g<parent>\n              \\s*\\)\n            |\n              _under\\g<open> # rb_define_class_under(under, name, parent_name...)\n                \\g<under>,\n                \\g<name>,\n                \\g<parent>\n              \\g<close>\n            )\n          |\n            (?<module>)\n            module(?: # rb_define_module(name)\n              \\g<open>\n                \\g<name>\n              \\g<close>\n            |\n              _under\\g<open> # rb_define_module_under(under, name)\n                \\g<under>,\n                \\g<name>\n              \\g<close>\n            )\n          )\n      |\n        (?<attributes>(?:\\s*\"\\w+\",)*\\s*NULL\\s*) {0}\n        struct_define(?:\n          \\g<open> # rb_struct_define(name, ...)\n            \\g<name>,\n        |\n          _under\\g<open> # rb_struct_define_under(under, name, ...)\n            \\g<under>,\n            \\g<name>,\n        |\n          _without_accessor(?:\n            \\g<open> # rb_struct_define_without_accessor(name, parent_name, ...)\n          |\n            _under\\g<open> # rb_struct_define_without_accessor_under(under, name, parent_name, ...)\n              \\g<under>,\n          )\n            \\g<name>,\n            \\g<parent>,\n            \\s*\\w+,        # Allocation function\n        )\n          \\g<attributes>\n        \\g<close>\n      |\n        singleton_class\\g<open> # rb_singleton_class(target_class_name)\n          (?<target_class_name>\\w+)\n        \\g<close>\n        )\n      )mx\n    ) do\n      if target_class_name = $~[:target_class_name]\n        # rb_singleton_class(target_class_name)\n        handle_singleton $~[:var_name], target_class_name\n        next\n      end",
        "comment": " Scans #content for rb_define_class, boot_defclass, rb_define_class_under and rb_singleton_class",
        "label": "What",
        "id": "16144"
    },
    {
        "raw_code": "def by_negated_label(issuables)\n      return issuables unless label_names_from_not_params.present?\n\n      issuables_without_selected_labels(issuables, label_names_from_not_params)\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7978"
    },
    {
        "raw_code": "def convert(content)\n    @markup.convert content, self\n  end",
        "comment": " Marks up +content+",
        "label": "What",
        "id": "16277"
    },
    {
        "raw_code": "def get\n    @current_token = @tokens.shift\n    p :get => @current_token if @debug\n    @current_token\n  end",
        "comment": " Pulls the next token from the stream.",
        "label": "What",
        "id": "16310"
    },
    {
        "raw_code": "def self.version?(*requirements)\n    req = Gem::Requirement.new(*requirements)\n    req.satisfied_by?(Gem::Version.new(VERSION))\n  end",
        "comment": "This checks if Vagrant is installed in a specific version.  Example:  Vagrant.version?(\">= 2.1.0\") ",
        "label": "What",
        "id": "8717"
    },
    {
        "raw_code": "def notice=(message)\n        self[:notice] = message\n      end",
        "comment": "Convenience accessor for `flash.now[:notice]=`.",
        "label": "What",
        "id": "11523"
    },
    {
        "raw_code": "def branches(repo, options = {})\n        paginate \"#{Repository.path repo}/branches\", options\n      end",
        "comment": "List branches  Requires authenticated client for private repos.  @param repo [Integer, String, Hash, Repository] A GitHub repository. @return [Array<Sawyer::Resource>] Array of hashes representing branches. @see https://developer.github.com/v3/repos/#list-branches @example Octokit.branches('octokit/octokit.rb') @example @client.branches('octokit/octokit.rb')",
        "label": "What",
        "id": "15159"
    },
    {
        "raw_code": "def handle_exiting_options\n      return unless Options::EXITING_OPTIONS.any? { |o| @options.key? o }\n\n      run_command(:version) if @options[:version] || @options[:verbose_version]\n      run_command(:show_cops) if @options[:show_cops]\n      run_command(:show_docs_url) if @options[:show_docs_url]\n      run_command(:lsp) if @options[:lsp]\n      raise Finished\n    end",
        "comment": "rubocop:disable Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "10061"
    },
    {
        "raw_code": "def initialize(project)\n        @project = project\n      end",
        "comment": "project - An instance of `Project`",
        "label": "What",
        "id": "1821"
    },
    {
        "raw_code": "def api_get(path)\n        response = get(\"#{api_url}/#{path}\", { headers: { \"PRIVATE-TOKEN\" => access_token } })\n        raise \"Failed to fetch pipeline jobs: '#{response.body}'\" unless response.code == API::HTTP_STATUS_OK\n\n        parse_body(response)\n      end",
        "comment": "Api get request  @param [String] path @param [Hash] payload @return [Hash, Array]",
        "label": "What",
        "id": "4526"
    },
    {
        "raw_code": "def import!(gh_project_name, target_group_path, project_name)\n            within_element('project-import-row', source_project: gh_project_name) do\n              click_element('target-namespace-dropdown')\n              click_element(\"listbox-item-#{target_group_path}\", wait: 10)\n              fill_element('project-path-field', project_name)\n\n              retry_until do\n                click_element('import-button')\n                # Make sure import started before waiting for completion\n                has_no_element?('import-status-indicator', text: \"Not started\", wait: 1)\n              end",
        "comment": "Import project  @param [String] source_project_name @param [String] target_group_path @return [void]",
        "label": "What",
        "id": "4270"
    },
    {
        "raw_code": "def parent_name\n    @parent ? @parent.full_name : '(unknown)'\n  end",
        "comment": " Name of our parent",
        "label": "What",
        "id": "15924"
    },
    {
        "raw_code": "def fetch_repository_tags(project_id, repository_id)\n          response = get(Runtime::API::Request.new(api_client,\n            \"/projects/#{project_id}/registry/repositories/#{repository_id}/tags\").url)\n\n          unless success?(response&.code)\n            logger.warn(\"Failed to fetch tags for repository #{repository_id}: #{response&.code}\")\n            return []\n          end",
        "comment": "Fetches all tags for a specific repository  @param [String] project_id Project ID @param [Integer] repository_id Repository ID @return [Array<Hash>] Array of tag objects",
        "label": "What",
        "id": "4764"
    },
    {
        "raw_code": "def reassigned_merge_request_email(\n      recipient_id,\n      merge_request_id,\n      previous_assignee_ids,\n      updated_by_user_id,\n      reason = nil\n    )\n      setup_merge_request_mail(merge_request_id, recipient_id)\n\n      previous_assignees = []\n      previous_assignees = User.where(id: previous_assignee_ids) if previous_assignee_ids.any?\n      @added_assignees = @merge_request.assignees.map(&:name) - previous_assignees.map(&:name)\n      @removed_assignees = previous_assignees.map(&:name) - @merge_request.assignees.map(&:name)\n\n      mail_answer_thread(@merge_request, merge_request_thread_options(updated_by_user_id, reason))\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6257"
    },
    {
        "raw_code": "def deprecators\n      @deprecators ||= ActiveSupport::Deprecation::Deprecators.new.tap do |deprecators|\n        deprecators[:railties] = Rails.deprecator\n      end",
        "comment": "A managed collection of deprecators (ActiveSupport::Deprecation::Deprecators). The collection's configuration methods affect all deprecators in the collection. Additionally, the collection's +silence+ method silences all deprecators in the collection for the duration of a given block.",
        "label": "What",
        "id": "14633"
    },
    {
        "raw_code": "def migrate_files_to_database!\n    return unless stored_externally?\n    return if files_count == 0\n\n    rows = convert_external_diffs_to_database\n\n    transaction do\n      MergeRequestDiffFile.where(merge_request_diff_id: id).delete_all\n      ApplicationRecord.legacy_bulk_insert('merge_request_diff_files', rows) # rubocop:disable Gitlab/BulkInsert\n      update!(stored_externally: false)\n    end",
        "comment": "Transactionally migrate the current merge_request_diff_files entries from external storage, back to the database. This is the rollback operation for +migrate_files_to_external_storage!+  If this diff isn't in external storage, the method is a no-op.",
        "label": "What",
        "id": "6871"
    },
    {
        "raw_code": "def share_folders(machine, folders, transient)\n        defs = []\n        warn_user_symlink = false\n\n        folders.each do |id, data|\n          hostpath = data[:hostpath]\n          if !data[:hostpath_exact]\n            hostpath = Vagrant::Util::Platform.cygwin_windows_path(hostpath)\n          end",
        "comment": "share_folders sets up the shared folder definitions on the VirtualBox VM.  The transient parameter determines if we're FORCING transient or not. If this is false, then any shared folders will be shared as non-transient unless they've specifically asked for transient.",
        "label": "What",
        "id": "9548"
    },
    {
        "raw_code": "def docs_path\n    ENV['CI_PROJECT_PATH'] == 'gitlab-org/gitlab-runner' ? 'docs/' : 'doc/'\n  end",
        "comment": "Location of docs files in the project",
        "label": "What",
        "id": "5285"
    },
    {
        "raw_code": "def self.write_multiple(mapping, key_prefix: nil, timeout: TIMEOUT)\n          with_redis do |redis|\n            Gitlab::Instrumentation::RedisClusterValidator.allow_cross_slot_commands do\n              redis.pipelined do |pipeline|\n                mapping.each do |raw_key, value|\n                  key = cache_key_for(\"#{key_prefix}#{raw_key}\")\n\n                  validate_redis_value!(value)\n\n                  pipeline.set(key, value, ex: timeout)\n                end",
        "comment": "Sets multiple keys to given values.  mapping - A Hash mapping the cache keys to their values. key_prefix - prefix inserted before each key timeout - The time after which the cache key should expire.",
        "label": "What",
        "id": "1949"
    },
    {
        "raw_code": "def schedule\n          if should_defer_schedule?\n            defer_job!\n            return\n          end",
        "comment": "This will continue the middleware chain if the job should be scheduled It will return false if the job needs to be cancelled",
        "label": "What",
        "id": "2773"
    },
    {
        "raw_code": "def invalid?(context = nil)\n      !valid?(context)\n    end",
        "comment": "Performs the opposite of <tt>valid?</tt>. Returns +true+ if errors were added, +false+ otherwise.  class Person include ActiveModel::Validations  attr_accessor :name validates_presence_of :name end  person = Person.new person.name = '' person.invalid? # => true person.name = 'david' person.invalid? # => false  Context can optionally be supplied to define which callbacks to test against (the context is defined on the validations using <tt>:on</tt>).  class Person include ActiveModel::Validations  attr_accessor :name validates_presence_of :name, on: :new end  person = Person.new person.invalid?       # => false person.invalid?(:new) # => true",
        "label": "What",
        "id": "12273"
    },
    {
        "raw_code": "def ancestors\n    if String === superclass then\n      super << superclass\n    elsif superclass then\n      ancestors = super\n      ancestors << superclass\n      ancestors.concat superclass.ancestors\n    else\n      super\n    end",
        "comment": " The ancestors of this class including modules.  Unlike Module#ancestors, this class is not included in the result.  The result will contain both RDoc::ClassModules and Strings.",
        "label": "What",
        "id": "16710"
    },
    {
        "raw_code": "def fork_gist(gist, options = {})\n        post \"gists/#{Gist.new(gist)}/forks\", options\n      end",
        "comment": "Fork a gist  @param gist [String] Gist ID @return [Sawyer::Resource] Data for the new gist @see https://developer.github.com/v3/gists/#fork-a-gist",
        "label": "What",
        "id": "15188"
    },
    {
        "raw_code": "def move_to_cache\n      false\n    end",
        "comment": "Override `GitlabUploader` and always return false, otherwise local `LfsObject` files would be deleted. https://github.com/carrierwaveuploader/carrierwave/blob/f84672a/lib/carrierwave/uploader/cache.rb#L131-L135",
        "label": "What",
        "id": "8074"
    },
    {
        "raw_code": "def initialize(\n      current_user, group, params = { exclude_subgroups: false,\n                                      exact_name: false,\n                                      order_by: 'created_at',\n                                      sort: 'asc',\n                                      packages_class: ::Packages::Package }\n    )\n      @current_user = current_user\n      @group = group\n      @params = params\n    end",
        "comment": "TODO: Remove `packages_class` with the rollout of the FF packages_refactor_group_packages_finder https://gitlab.com/gitlab-org/gitlab/-/issues/568923",
        "label": "What",
        "id": "8002"
    },
    {
        "raw_code": "def fast_keep_project_job_artifacts_path(project, job)\n      expose_fast_artifacts_path(project, job, :keep)\n    end",
        "comment": "/*namespace_id/:project_id/-/jobs/:job_id/artifacts/keep(.:format)",
        "label": "What",
        "id": "7849"
    },
    {
        "raw_code": "def parse_host(host)\n        if host.include?(\":\")\n          split = host.split(\":\", 2)\n          [split[0], split[1].to_i]\n        else\n          [host, default_port]\n        end",
        "comment": "Parse the host into it's url and port parts. @return [Array]",
        "label": "What",
        "id": "9389"
    },
    {
        "raw_code": "def check_constraint(*args, **options)\n        @base.add_check_constraint(name, *args, **options)\n      end",
        "comment": "Adds a check constraint.  t.check_constraint(\"price > 0\", name: \"price_check\")  See {connection.add_check_constraint}[rdoc-ref:SchemaStatements#add_check_constraint]",
        "label": "What",
        "id": "13122"
    },
    {
        "raw_code": "def self.eager_load_namespaces # :nodoc:\n        @@eager_load_namespaces ||= []\n      end",
        "comment": "Expose the eager_load_namespaces at \"module\" level for convenience.",
        "label": "What",
        "id": "14807"
    },
    {
        "raw_code": "def data\n      strong_memoize(:data) do\n        case trigger\n        when 'push_events'\n          push_events_data\n        when 'tag_push_events'\n          tag_push_events_data\n        when 'note_events'\n          note_events_data\n        when 'issues_events', 'confidential_issues_events'\n          issues_events_data\n        when 'merge_requests_events'\n          merge_requests_events_data\n        when 'job_events'\n          job_events_data\n        when 'pipeline_events'\n          pipeline_events_data\n        when 'wiki_page_events'\n          wiki_page_events_data\n        when 'releases_events'\n          releases_events_data\n        when 'milestone_events'\n          milestone_events_data\n        when 'emoji_events'\n          emoji_events_data\n        when 'resource_access_token_events'\n          access_tokens_events_data\n        when 'project_events'\n          project_events_data\n        when 'vulnerability_events'\n          vulnerability_events_data\n        end",
        "comment": "rubocop:disable Metrics/CyclomaticComplexity -- despite a high count, this isn't that complex",
        "label": "What",
        "id": "5692"
    },
    {
        "raw_code": "def update_design_user_mentions_namespace_id!(sub_batch_ids)\n        sql = <<~SQL\n          UPDATE design_user_mentions\n          SET namespace_id = design_management_designs.namespace_id\n          FROM design_management_designs\n          WHERE design_management_designs.id = design_user_mentions.design_id\n          AND design_user_mentions.design_id IN (#{sub_batch_ids.to_sql})\n        SQL\n\n        ApplicationRecord.connection.execute(sql)\n      end",
        "comment": "Sets the namespace_id on design_user_mentions to the corresponding design_management_designs's namespace_id",
        "label": "What",
        "id": "3273"
    },
    {
        "raw_code": "def test_kernel_method_names_to_xml\n    hash     = { throw: { ball: \"red\" } }\n    expected = \"<person><throw><ball>red</ball></throw></person>\"\n\n    assert_nothing_raised do\n      assert_equal expected, hash.to_xml(@xml_options)\n    end",
        "comment": "The XML builder seems to fail miserably when trying to tag something with the same name as a Kernel method (throw, test, loop, select ...)",
        "label": "What",
        "id": "14611"
    },
    {
        "raw_code": "def stats_for_attributes\n        objs = all_objects.select {|m| m.type == :method && m.is_attribute? }\n        objs.uniq! {|m| m.name.to_s.gsub(/=$/, '') }\n        undoc = objs.select {|m| m.docstring.blank? }\n        @undoc_list |= undoc if @undoc_list\n        output \"Attributes\", objs.size, undoc.size\n      end",
        "comment": "Statistics for attributes",
        "label": "What",
        "id": "522"
    },
    {
        "raw_code": "def docstring(docstring = nil)\n          @docstring = docstring unless docstring.nil?\n\n          @docstring\n        end",
        "comment": "Documentation describing metric in metrics endpoint '/-/metrics'",
        "label": "What",
        "id": "2312"
    },
    {
        "raw_code": "def create_database(name, options = {})\n        if options[:collation]\n          execute \"CREATE DATABASE #{quote_table_name(name)} DEFAULT COLLATE #{quote_table_name(options[:collation])}\"\n        elsif options[:charset]\n          execute \"CREATE DATABASE #{quote_table_name(name)} DEFAULT CHARACTER SET #{quote_table_name(options[:charset])}\"\n        elsif row_format_dynamic_by_default?\n          execute \"CREATE DATABASE #{quote_table_name(name)} DEFAULT CHARACTER SET `utf8mb4`\"\n        else\n          raise \"Configure a supported :charset and ensure innodb_large_prefix is enabled to support indexes on varchar(255) string columns.\"\n        end",
        "comment": "Create a new MySQL database with optional <tt>:charset</tt> and <tt>:collation</tt>. Charset defaults to utf8mb4.  Example: create_database 'charset_test', charset: 'latin1', collation: 'latin1_bin' create_database 'matt_development' create_database 'matt_development', charset: :big5",
        "label": "What",
        "id": "12950"
    },
    {
        "raw_code": "def attempt_to_unstick_mrs_without_merge_jid(merge_requests)\n      return if merge_requests.empty?\n\n      merge_requests_to_reopen = []\n      merge_request_ids_to_mark_as_merged = []\n\n      merge_requests.each do |merge_request|\n        next unless Feature.enabled?(:unstick_locked_mrs_without_merge_jid, merge_request.project)\n        next unless should_unstick?(merge_request)\n\n        # Reset merge request record to ensure we get updated record state before\n        # we check attributes. It is possible that after we queried the MRs, they\n        # got merged or unlocked and marked as such successfully. If so, skip MR.\n        next unless merge_request.reset.locked?\n\n        # Set MR to be marked as merged if one of the following is true:\n        # - it already has merged_commit_sha in the DB\n        # - it alreeady has merge_commit_sha in the DB\n        # - it has no diffs where source and target branches are compared\n        #\n        # This means the MR changes were already merged.\n        #\n        # We read the value of the column from the DB instead of MergeRequest#merged_commit_sha\n        # as that method can return nil when MR is still not merged.\n        #\n        # We also check the `merge_commit_sha` if present as there are older MRs that do not have\n        # `merged_commit_sha` set on merge.\n        #\n        # When both attributes aren't set, we check if the MR still has diffs to see\n        # if the MR changes are already merged or not.\n        if merge_request.read_attribute(:merged_commit_sha).present? ||\n            merge_request.merge_commit_sha.present? ||\n            (merge_request.source_and_target_branches_exist? && !merge_request.has_diffs?)\n          merge_request_ids_to_mark_as_merged << merge_request.id\n        else\n          # Set MR to be unlocked since it's stuck and maybe not merged yet.\n          merge_requests_to_reopen << merge_request\n        end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5573"
    },
    {
        "raw_code": "def remove_index(table_name, column_name = nil, **options)\n        return if options[:if_exists] && !index_exists?(table_name, column_name, **options)\n\n        index_name = index_name_for_remove(table_name, column_name, options)\n\n        execute \"DROP INDEX #{quote_column_name(index_name)} ON #{quote_table_name(table_name)}\"\n      end",
        "comment": "Removes the given index from the table.  Removes the index on +branch_id+ in the +accounts+ table if exactly one such index exists.  remove_index :accounts, :branch_id  Removes the index on +branch_id+ in the +accounts+ table if exactly one such index exists.  remove_index :accounts, column: :branch_id  Removes the index on +branch_id+ and +party_id+ in the +accounts+ table if exactly one such index exists.  remove_index :accounts, column: [:branch_id, :party_id]  Removes the index named +by_branch_party+ in the +accounts+ table.  remove_index :accounts, name: :by_branch_party  Removes the index on +branch_id+ named +by_branch_party+ in the +accounts+ table.  remove_index :accounts, :branch_id, name: :by_branch_party  Checks if the index exists before trying to remove it. Will silently ignore indexes that don't exist.  remove_index :accounts, if_exists: true  Removes the index named +by_branch_party+ in the +accounts+ table +concurrently+.  remove_index :accounts, name: :by_branch_party, algorithm: :concurrently  Note: only supported by PostgreSQL.  Concurrently removing an index is not supported in a transaction.  For more information see the {\"Transactional Migrations\" section}[rdoc-ref:Migration].",
        "label": "What",
        "id": "13158"
    },
    {
        "raw_code": "def config_fallback\n          Cache\n        end",
        "comment": "The data we store on RateLimiting used to be stored on Cache.",
        "label": "What",
        "id": "1917"
    },
    {
        "raw_code": "def group_labels_applied_to_issues\n      @labels_applied_to_issues ||= Label.joins(:issues)\n        .joins(\"INNER JOIN namespaces on namespaces.id = labels.group_id AND namespaces.type = 'Group'\")\n        .where(issues: { project_id: project.id }).without_order\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6041"
    },
    {
        "raw_code": "def check_constraint_exists?(table_name, **options)\n        if !options.key?(:name) && !options.key?(:expression)\n          raise ArgumentError, \"At least one of :name or :expression must be supplied\"\n        end",
        "comment": "Checks to see if a check constraint exists on a table for a given check constraint definition.  check_constraint_exists?(:products, name: \"price_check\") ",
        "label": "What",
        "id": "13170"
    },
    {
        "raw_code": "def extract_project_id(resource)\n          # Try different ways to get project ID\n          project_id = resource[:id] ||\n            resource['id'] ||\n            resource[:api_path]&.match(%r{/projects/(\\d+)})&.[](1) ||\n            resource['api_path']&.match(%r{/projects/(\\d+)})&.[](1)\n\n          unless project_id\n            logger.error(\"Could not extract project ID from resource: #{resource}\")\n            return\n          end",
        "comment": "Extracts project ID from resource  @param [Hash] resource Project resource @return [String, nil] Project ID or nil if not found",
        "label": "What",
        "id": "4761"
    },
    {
        "raw_code": "def in_operator_array_params(scope:, array_data:, in_column: nil, in_values: nil)\n    array_scope_ids = array_data[:scope_ids]\n    array_scope_model = array_data[:scope_model]\n    array_mapping_column = array_data[:mapping_column]\n\n    # Adding non-existent record to generate valid SQL if array_scope_ids is empty\n    array_scope_ids << 0 if array_scope_ids.empty?\n\n    if in_column\n      # Builds Cartesian product of the in_values and the array_scope_ids (in this case: user_ids).\n      # The process is described here: https://docs.gitlab.com/ee/development/database/efficient_in_operator_queries.html#multiple-in-queries\n      # VALUES ((array_scope_ids[0], in_values[0]), (array_scope_ids[1], in_values[0]) ...)\n      cartesian = array_scope_ids.product(in_values)\n      column_list = Arel::Nodes::ValuesList.new(cartesian)\n\n      as = \"array_ids(id, #{Event.connection.quote_column_name(in_column)})\"\n      from = Arel::Nodes::Grouping.new(column_list).as(as)\n      {\n        array_scope: array_scope_model.select(:id, in_column).from(from),\n        array_mapping_scope: ->(primary_id_expression, in_column_expression) do\n          Event\n            .merge(scope)\n            .where(Event.arel_table[array_mapping_column].eq(primary_id_expression))\n            .where(Event.arel_table[in_column].eq(in_column_expression))\n        end",
        "comment": "This method builds the array_ parameters without in_column parameter: uses one IN filter: author_id with in_column: two IN filters: author_id, (target_type OR action) @param array_data [Hash] Must contain the scope_ids, scope_model, mapping_column keys",
        "label": "What",
        "id": "1330"
    },
    {
        "raw_code": "def validate_limited_broadcast_address(addrs_info)\n          blocked_ips = [\"255.255.255.255\"]\n\n          return if (blocked_ips & addrs_info.map(&:ip_address)).empty?\n\n          raise BlockedUrlError, \"Requests to the limited broadcast address are not allowed\"\n        end",
        "comment": "Raises a BlockedUrlError if any IP in `addrs_info` is the limited broadcast address. https://datatracker.ietf.org/doc/html/rfc919#section-7",
        "label": "What",
        "id": "1204"
    },
    {
        "raw_code": "def push_test_metrics\n          push_test_metrics_to_influxdb\n          push_test_metrics_to_gcs\n        end",
        "comment": "Upload test execution metrics  @return [void]",
        "label": "What",
        "id": "4619"
    },
    {
        "raw_code": "def import_group(source_group_name, target_group_name)\n          finished_loading?\n\n          filter_group(source_group_name)\n\n          within_element('import-item', source_group: source_group_name) do\n            click_element('target-namespace-dropdown')\n            click_element(\"listbox-item-#{target_group_name}\")\n\n            retry_until(message: \"Triggering import\") do\n              click_element('import-group-button')\n              # Make sure import started before waiting for completion\n              has_no_element?('import-status-indicator', text: \"Not started\", wait: 1)\n            end",
        "comment": "Import source group in to target group  @param [String] source_group_name @param [String] target_group_name @return [void]",
        "label": "What",
        "id": "4290"
    },
    {
        "raw_code": "def metadata(required_fields = [:issue_count, :total_issue_weight])\n      fields = metadata_fields(required_fields)\n      keys = fields.keys\n      columns = fields.values_at(*keys)\n\n      results = item_model\n        .where(id: collection_ids)\n        .pluck(*columns)\n        .flatten\n\n      Hash[keys.zip(results)]\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5647"
    },
    {
        "raw_code": "def extract_project_path(path)\n          return if path.start_with?('/') # invalid project full path.\n\n          index = path.rindex('/') # find index of last `/` in the path\n          return unless index\n\n          path[0..index - 1]\n        end",
        "comment": "Given a path like \"my-org/sub-group/the-project/the-component\" we expect that the last `/` is the separator between the project full path and the component name.",
        "label": "What",
        "id": "2476"
    },
    {
        "raw_code": "def destroy\n    @message.destroy\n    redirect_to messages_url, notice: 'Message was successfully destroyed.'\n  end",
        "comment": "DELETE /messages/1",
        "label": "What",
        "id": "11708"
    },
    {
        "raw_code": "def execute\n        logger.info(\"Running metrics export for test type: #{test_type}\")\n\n        case test_type\n        when :backend\n          export_rspec_metrics\n        when :frontend\n          export_jest_metrics\n        end",
        "comment": "Execute metrics export  @return [Boolean]",
        "label": "What",
        "id": "8112"
    },
    {
        "raw_code": "def rich_textarea(method, options = {})\n      @template.rich_textarea(@object_name, method, objectify_options(options))\n    end",
        "comment": "Wraps ActionView::Helpers::FormHelper#rich_textarea for form builders:  <%= form_with model: @message do |f| %> <%= f.rich_textarea :content %> <% end %>  Please refer to the documentation of the base helper for details.",
        "label": "What",
        "id": "11680"
    },
    {
        "raw_code": "def token_header(token = gitlab_access_token)\n        { headers: { \"PRIVATE-TOKEN\" => token } }\n      end",
        "comment": "Api request private token header  @return [Hash]",
        "label": "What",
        "id": "4710"
    },
    {
        "raw_code": "def route_missing\n      raise NotFound unless @app\n\n      forward\n    end",
        "comment": "No matching route was found or all routes passed. The default implementation is to forward the request downstream when running as middleware (@app is non-nil); when no downstream app is set, raise a NotFound exception. Subclasses can override this method to perform custom route miss logic.",
        "label": "What",
        "id": "8587"
    },
    {
        "raw_code": "def find_consistent_parts(grouped_operands)\n          csend_in_and, csend_in_or, send_in_and, send_in_or = most_left_indices(grouped_operands)\n\n          return if csend_in_and && csend_in_or && csend_in_and < csend_in_or\n\n          if csend_in_and\n            ['.', (send_in_and ? [send_in_and, csend_in_and].min : csend_in_and) + 1]\n          elsif send_in_or && csend_in_or\n            send_in_or < csend_in_or ? ['.', send_in_or + 1] : ['&.', csend_in_or + 1]\n          elsif send_in_and && csend_in_or && send_in_and < csend_in_or\n            ['.', csend_in_or]\n          end",
        "comment": "rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10654"
    },
    {
        "raw_code": "def parse_method_parameters(method)\n    res = parse_method_or_yield_parameters method\n\n    res = \"(#{res})\" unless res =~ /\\A\\(/\n    method.params = res unless method.params\n\n    return if  method.block_params\n\n    skip_tkspace_without_nl\n    read_documentation_modifiers method, RDoc::METHOD_MODIFIERS\n  end",
        "comment": " Capture the method's parameters. Along the way, look for a comment containing:  # yields: ....  and add this as the block_params for the method",
        "label": "What",
        "id": "16107"
    },
    {
        "raw_code": "def enqueue_and_track_last!(project_ids)\n        return if project_ids.empty?\n\n        with_redis do |redis|\n          redis.pipelined do |pipeline|\n            pipeline.rpush(QUEUE_KEY, project_ids)\n            pipeline.set(LAST_QUEUED_KEY, project_ids.last, ex: REDIS_EXPIRATION_TIME)\n          end",
        "comment": " Add new work to the queue and keep track of last item.  existing[1, 2, 3] << new[4, 5, 6] ==> [1, 2, 3, 4, 5, 6] last: 6",
        "label": "What",
        "id": "3582"
    },
    {
        "raw_code": "def update_project_column(id, name, options = {})\n        options[:name] = name\n        patch \"projects/columns/#{id}\", options\n      end",
        "comment": "Update a project column  Requires authenticated client  @param id [Integer] Project column id @param name [String] New column name @return [Sawyer::Resource] Updated column @see https://developer.github.com/v3/projects/columns/#update-a-project-column @example @client.update_project_column(30294, \"new column name\")",
        "label": "What",
        "id": "15323"
    },
    {
        "raw_code": "def read_mac_address\n        execute(:get_network_mac, VmId: vm_id)\n      end",
        "comment": "Get the MAC address of the VM  @return [Hash<mac>]",
        "label": "What",
        "id": "9673"
    },
    {
        "raw_code": "def self.build_metadata(user:, marketplace_home_url:)\n        return metadata_disabled(:no_user) unless user\n\n        unless ::WebIde::ExtensionMarketplace.feature_enabled_from_application_settings?\n          return metadata_disabled(:instance_disabled)\n        end",
        "comment": "@param [User, nil] user @param [Boolean, nil] flag_enabled @return [Hash]",
        "label": "What",
        "id": "3566"
    },
    {
        "raw_code": "def local(*args)\n      time = Time.utc(*args)\n      ActiveSupport::TimeWithZone.new(nil, self, time)\n    end",
        "comment": "\\Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from given values.  Time.zone = 'Hawaii'                    # => \"Hawaii\" Time.zone.local(2007, 2, 1, 15, 30, 45) # => Thu, 01 Feb 2007 15:30:45 HST -10:00",
        "label": "What",
        "id": "14568"
    },
    {
        "raw_code": "def metrics_event\n          :receive_email_create_issue\n        end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3248"
    },
    {
        "raw_code": "def base_pipeline_variables\n          @base_pipeline_variables ||= begin\n            ruby_version = File.read(File.join(project_root, \".ruby-version\")).strip\n\n            {\n              \"RUBY_VERSION\" => ENV[\"RUBY_VERSION\"] || ruby_version,\n              \"GITLAB_SEMVER_VERSION\" => File.read(File.join(project_root, \"VERSION\")),\n              \"FEATURE_FLAGS\" => env[\"QA_FEATURE_FLAGS\"]\n            }.compact\n          end",
        "comment": "Base variables included in all pipeline types  @return [Hash]",
        "label": "What",
        "id": "4780"
    },
    {
        "raw_code": "def self.decompress_zip(machine, compressed_file, destination, opts={})\n          comm = machine.communicate\n          extract_dir = create_tmp_path(machine, type: :directory)\n          cmds = []\n          if opts[:type] == :directory\n            cmds << \"mkdir -p '#{destination}'\"\n          else\n            cmds << \"mkdir -p '#{File.dirname(destination)}'\"\n          end",
        "comment": "Decompress zip file on guest to given location  @param [Vagrant::Machine] machine Vagrant guest machine @param [String] compressed_file Path to compressed file on guest @param [String] destination Path for decompressed files on guest",
        "label": "What",
        "id": "9821"
    },
    {
        "raw_code": "def values\n            {}\n          end",
        "comment": "Configuration specific values  @return [Hash]",
        "label": "What",
        "id": "3941"
    },
    {
        "raw_code": "def name_prefix\n    @singleton ? '::' : '#'\n  end",
        "comment": " '::' for a class method/attribute, '#' for an instance method.",
        "label": "What",
        "id": "16827"
    },
    {
        "raw_code": "def index_user(user)\n        queue_index user\n      end",
        "comment": "Queue a User or Organization to be indexed  @param user [String] A GitHub Enterprise user or organization @return [Sawyer:Resource] Result of the queuing containing `:message`",
        "label": "What",
        "id": "14949"
    },
    {
        "raw_code": "def labels\n    respond_to do |format|\n      format.html { redirect_to milestone_redirect_path }\n      format.json do\n        milestone_labels = @milestone.issue_labels_visible_by_user(current_user)\n\n        render json: tabs_json(\"shared/milestones/_labels_tab\", {\n          labels: milestone_labels.map do |label|\n            label.present(issuable_subject: @milestone.resource_parent)\n          end",
        "comment": "rubocop:disable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "6564"
    },
    {
        "raw_code": "def regroup!(*args) # :nodoc:\n      self.group_values = args\n      self\n    end",
        "comment": "Same as #regroup but operates on relation in-place instead of copying.",
        "label": "What",
        "id": "13403"
    },
    {
        "raw_code": "def self.all\n      Sidekiq.redis { |c| c.sscan(\"queues\").to_a }.sort.map { |q| Sidekiq::Queue.new(q) }\n    end",
        "comment": " Fetch all known queues within Redis.  @return [Array<Sidekiq::Queue>]",
        "label": "What",
        "id": "5110"
    },
    {
        "raw_code": "def build_column_arrays_query\n            q = Arel::SelectManager.new\n              .project(array_scope_columns.array_aggregated_columns + order_by_columns.array_aggregated_columns)\n              .from(array_cte)\n              .join(Arel.sql(\"LEFT JOIN LATERAL (#{initial_keyset_query.to_sql}) #{table_name} ON TRUE\"))\n\n            order_by_columns.each { |c| q.where(c.column_expression.not_eq(nil)) unless c.column.nullable? }\n\n            q.as('array_scope_lateral_query')\n          end",
        "comment": "This query finds the first cursor values for each item in the array CTE.  array_cte:  |project_id| |----------| |         1| |         2| |         3| |         4|  For each project_id, find the first issues row by respecting the created_at, id order.  The `array_mapping_scope` parameter defines how the `array_scope` and the `scope` can be combined.  scope = Issue.where({}) # empty scope array_mapping_scope = Issue.where(project_id: X)  scope.merge(array_mapping_scope) # Issue.where(project_id: X)  X will be replaced with a value from the `array_cte` temporary table.  |created_at|id| |----------|--| |2020-01-15| 2| |2020-01-07| 3| |2020-01-07| 4| |2020-01-10| 5|",
        "label": "What",
        "id": "2019"
    },
    {
        "raw_code": "def flipper_id\n        \"Repository:#{@relative_path}\"\n      end",
        "comment": "Support Feature Flag Repository actor",
        "label": "What",
        "id": "2611"
    },
    {
        "raw_code": "def number_to_currency(number, options = {})\n      NumberToCurrencyConverter.convert(number, options)\n    end",
        "comment": "Formats a +number+ into a currency string.  number_to_currency(1234567890.50)  # => \"$1,234,567,890.50\" number_to_currency(1234567890.506) # => \"$1,234,567,890.51\" number_to_currency(\"12x34\")        # => \"$12x34\"  number_to_currency(1234567890.50, unit: \"&pound;\", separator: \",\", delimiter: \"\") # => \"&pound;1234567890,50\"  The currency unit and number formatting of the current locale will be used unless otherwise specified via options. No currency conversion is performed. If the user is given a way to change their locale, they will also be able to change the relative value of the currency displayed with this helper. If your application will ever support multiple locales, you may want to specify a constant +:locale+ option or consider using a library capable of currency conversion.  ==== Options  [+:locale+] The locale to use for formatting. Defaults to the current locale.  number_to_currency(1234567890.506, locale: :fr) # => \"1 234 567 890,51 \u20ac\"  [+:precision+] The level of precision. Defaults to 2.  number_to_currency(1234567890.123, precision: 3) # => \"$1,234,567,890.123\" number_to_currency(0.456789, precision: 0)       # => \"$0\"  [+:round_mode+] Specifies how rounding is performed. See +BigDecimal.mode+. Defaults to +:default+.  number_to_currency(1234567890.01, precision: 0, round_mode: :up) # => \"$1,234,567,891\"  [+:unit+] The denomination of the currency. Defaults to <tt>\"$\"</tt>.  [+:separator+] The decimal separator. Defaults to <tt>\".\"</tt>.  [+:delimiter+] The thousands delimiter. Defaults to <tt>\",\"</tt>.  [+:format+] The format for non-negative numbers. <tt>%u</tt> represents the currency, and <tt>%n</tt> represents the number. Defaults to <tt>\"%u%n\"</tt>.  number_to_currency(1234567890.50, format: \"%n %u\") # => \"1,234,567,890.50 $\"  [+:negative_format+] The format for negative numbers. <tt>%u</tt> and <tt>%n</tt> behave the same as in +:format+, but <tt>%n</tt> represents the absolute value of the number. Defaults to the value of +:format+ prepended with <tt>-</tt>.  number_to_currency(-1234567890.50, negative_format: \"(%u%n)\") # => \"($1,234,567,890.50)\"  [+:strip_insignificant_zeros+] Whether to remove insignificant zeros after the decimal separator. Defaults to false.  number_to_currency(1234567890.50, strip_insignificant_zeros: true) # => \"$1,234,567,890.5\" ",
        "label": "What",
        "id": "13918"
    },
    {
        "raw_code": "def reject_path_params_param\n    params.delete(:path_params)\n  end",
        "comment": "Fix for https://github.com/kaminari/kaminari/pull/1123, remove after this is merged and in use.",
        "label": "What",
        "id": "9958"
    },
    {
        "raw_code": "def request_http_digest_authentication(realm = \"Application\", message = nil)\n          HttpAuthentication::Digest.authentication_request(self, realm, message)\n        end",
        "comment": "Render an HTTP header requesting the client to send a Digest for authentication.",
        "label": "What",
        "id": "11273"
    },
    {
        "raw_code": "def self.fetch_direct_connection_details(token)\n          response = Support::API.post(\n            \"#{Runtime::Scenario.gitlab_address}/api/v4/code_suggestions/direct_access\",\n            nil,\n            headers: { Authorization: \"Bearer #{token}\", 'Content-Type': 'application/json' }\n          )\n          raise \"Unexpected status code #{response.code}\" unless response.code == Support::API::HTTP_STATUS_CREATED\n\n          direct_connection_details = Support::API.parse_body(response)\n\n          raise \"direct_connection[:base_url] should not be nil\" if direct_connection_details[:base_url].nil?\n          raise \"direct_connection[:token] should not be nil\" if direct_connection_details[:token].nil?\n          raise \"direct_connection[:headers] should not be nil\" if direct_connection_details[:headers].nil?\n\n          direct_connection_details\n        end",
        "comment": "https://docs.gitlab.com/ee/api/code_suggestions.html#fetch-direct-connection-information",
        "label": "What",
        "id": "4211"
    },
    {
        "raw_code": "def changed?(old_value, new_value, _new_value_before_type_cast)\n            !old_value.eql?(new_value) || !old_value.nil? && old_value.prefix != new_value.prefix\n          end",
        "comment": "TODO: Remove when IPAddr#== compares IPAddr#prefix. See https://github.com/ruby/ipaddr/issues/21",
        "label": "What",
        "id": "13277"
    },
    {
        "raw_code": "def size\n    exists? ? raw_repository.size : 0.0\n  end",
        "comment": "The size of this repository in megabytes.",
        "label": "What",
        "id": "7149"
    },
    {
        "raw_code": "def create_sql(from_id, to_id)\n        <<~SQL\n          WITH created_records AS MATERIALIZED (\n            INSERT INTO services (project_id, #{DEFAULTS.keys.map { |key| %(\"#{key}\") }.join(',')}, created_at, updated_at)\n            #{select_insert_values_sql(from_id, to_id)}\n            RETURNING *\n          )\n          SELECT COUNT(*) as number_of_created_records\n          FROM created_records\n        SQL\n      end",
        "comment": "there is no uniq constraint on project_id and type pair, which prevents us from using ON CONFLICT",
        "label": "What",
        "id": "3260"
    },
    {
        "raw_code": "def create_namespace\n          log(\"Creating namespace '#{namespace}'\", :info)\n          puts kubeclient.create_namespace\n        rescue Kubectl::Client::Error => e\n          return log(\"namespace already exists, skipping\", :warn) if e.message.include?(\"already exists\")\n\n          raise(e)\n        end",
        "comment": "Create namespace  @return [void]",
        "label": "What",
        "id": "4007"
    },
    {
        "raw_code": "def archive_link(repo, options = {})\n        repo_ref = ERB::Util.url_encode(options.delete(:ref))\n        format = (options.delete :format) || 'tarball'\n        url = \"#{Repository.path repo}/#{format}/#{repo_ref}\"\n\n        response = client_without_redirects.head(url, options)\n        response.headers['Location']\n      end",
        "comment": "This method will provide a URL to download a tarball or zipball archive for a repository.  @param repo [Integer, String, Repository, Hash] A GitHub repository. @option options format [String] Either tarball (default) or zipball. @option options [String] :ref Optional valid Git reference, defaults to master. @return [String] Location of the download @see https://developer.github.com/v3/repos/contents/#get-archive-link @example Get archive link for octokit/octokit.rb Octokit.archive_link(\"octokit/octokit.rb\")",
        "label": "What",
        "id": "15201"
    },
    {
        "raw_code": "def locked_for_writing?(file = nil)\n      Serializers::YardocSerializer.new(file || @file).locked_for_writing?\n    end",
        "comment": "(see Serializers::YardocSerializer#locked_for_writing?) @param file [String] if supplied, the path to the database",
        "label": "What",
        "id": "101"
    },
    {
        "raw_code": "def find_all(name, prefix = nil, partial = false, details = {}, key = nil, locals = [])\n      _find_all(name, prefix, partial, details, key, locals)\n    end",
        "comment": "Normalizes the arguments and passes it on to find_templates.",
        "label": "What",
        "id": "12020"
    },
    {
        "raw_code": "def method_missing(meth, *args, &block)\n        if meth.to_s =~ /=$/\n          self[meth.to_s[0..-2]] = args.first\n        elsif instance_variable_get(\"@#{meth}\")\n          self[meth]\n        else\n          super\n        end",
        "comment": "@overload dynamic_attr_name @return the value of attribute named by the method attribute name @raise [NoMethodError] if no method or custom attribute exists by the attribute name @see #[] @overload dynamic_attr_name=(value) @param value a value to set @return +value+ @see #[]=",
        "label": "What",
        "id": "574"
    },
    {
        "raw_code": "def stargazers(repo, options = {})\n        paginate \"#{Repository.path repo}/stargazers\", options\n      end",
        "comment": "List stargazers of a repo  Requires authenticated client for private repos.  @param repo [Integer, String, Hash, Repository] A GitHub repository. @return [Array<Sawyer::Resource>] Array of hashes representing users. @see https://developer.github.com/v3/activity/starring/#list-stargazers @example Octokit.stargazers('octokit/octokit.rb') @example @client.stargazers('octokit/octokit.rb')",
        "label": "What",
        "id": "15154"
    },
    {
        "raw_code": "def releases(repo, options = {})\n        paginate \"#{Repository.path repo}/releases\", options\n      end",
        "comment": "List releases for a repository  @param repo [Integer, String, Repository, Hash] A GitHub repository @return [Array<Sawyer::Resource>] A list of releases @see https://developer.github.com/v3/repos/releases/#list-releases-for-a-repository",
        "label": "What",
        "id": "15202"
    },
    {
        "raw_code": "def run_pre_installation_setup\n            # To be implemented by subclasses\n          end",
        "comment": "Run pre-installation setup  @return [void]",
        "label": "What",
        "id": "3939"
    },
    {
        "raw_code": "def up; end\n\n  def down; end\nend",
        "comment": "re-enqueued via https://gitlab.com/gitlab-org/gitlab/-/merge_requests/197199",
        "label": "What",
        "id": "4955"
    },
    {
        "raw_code": "def find_by_uid_and_provider(uid, provider)\n            identity = ::Identity.with_extern_uid(provider, uid).take\n\n            return unless identity\n            raise IdentityWithUntrustedExternUidError unless identity.trusted_extern_uid?\n\n            identity.user\n          end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2363"
    },
    {
        "raw_code": "def search_context\n    strong_memoize(:search_context) do\n      next super if defined?(super)\n\n      Gitlab::SearchContext::Builder.new(controller.view_context).build!\n    end",
        "comment": "This helper ensures there is always a default `Gitlab::SearchContext` available to all controller that use the application layout.",
        "label": "What",
        "id": "7791"
    },
    {
        "raw_code": "def delete(key)\n      raise NotImplementedError\n    end",
        "comment": "Delete the file at the +key+.",
        "label": "What",
        "id": "13675"
    },
    {
        "raw_code": "def _HtmlBlockFieldset\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenFieldset)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockFieldset = HtmlBlockOpenFieldset (HtmlBlockFieldset | !HtmlBlockCloseFieldset .)* HtmlBlockCloseFieldset",
        "label": "What",
        "id": "15646"
    },
    {
        "raw_code": "def original_expression_of(node)\n          first = node.to_a.first\n          if first.is_a?(::Integer)\n            \"$#{first}\"\n          else\n            first.to_s\n          end",
        "comment": "@private @param [RuboCop::AST::Node] node @return [String]",
        "label": "What",
        "id": "10511"
    },
    {
        "raw_code": "def write_gem(body, spec_contents)\n    gem_path = \"gems/#{@version.gem_file_name}\"\n    gem_contents = body.string\n\n    spec_path = \"quick/Marshal.4.8/#{@version.full_name}.gemspec.rz\"\n\n    # do all processing _before_ we upload anything to S3, so we lower the chances of orphaned files\n    RubygemFs.instance.store(gem_path, gem_contents, checksum_sha256: version.sha256,\n                             metadata: {\n                               \"gem\" => version.rubygem.name, \"version\" => version.number, \"platform\" => version.platform,\n                               \"surrogate-key\" => \"gem/#{version.rubygem.name}\", \"sha256\" => version.sha256\n                             })\n    RubygemFs.instance.store(spec_path, spec_contents, checksum_sha256: version.spec_sha256)\n\n    Fastly.purge(path: gem_path)\n    Fastly.purge(path: spec_path)\n  end",
        "comment": "we validate that the version full_name == spec.original_name",
        "label": "What",
        "id": "9985"
    },
    {
        "raw_code": "def initialize(\n      title: nil, variant: :info, dismissible: true, show_icon: true,\n      alert_options: {}, close_button_options: {})\n      @title = title.presence\n      @variant = filter_attribute(variant&.to_sym, VARIANT_ICONS.keys, default: :info)\n      @dismissible = dismissible\n      @show_icon = show_icon\n      @alert_options = alert_options\n      @close_button_options = close_button_options\n    end",
        "comment": "@param [String] title @param [Symbol] variant @param [Boolean] dismissible @param [Boolean] show_icon @param [Hash] alert_options @param [Hash] close_button_options",
        "label": "What",
        "id": "5396"
    },
    {
        "raw_code": "def run_container(\n          name:, image:, environment: {}, ports: {}, volumes: {}, restart: \"always\",\n          additional_options: [])\n          cmd = [\"docker\", \"run\", \"-d\", \"--name\", name]\n\n          environment&.each do |key, value|\n            cmd.push(\"-e\", \"#{key}=#{value}\")\n          end",
        "comment": "Run Docker container  @param [String] name @param [String] image @param [Hash] environment @param [Hash] ports @param [Hash] volumes @param [String] restart @param [Array<String>] additional_options @return [String]",
        "label": "What",
        "id": "3930"
    },
    {
        "raw_code": "def initialize(settings, log_enabled:, log_file:, gc_requests: false, **options)\n          super(**options)\n\n          @settings = settings\n          @gc_requests = gc_requests\n\n          # log_enabled does not exist for all exporters\n          log_sink = log_enabled ? File.join(Rails.root, 'log', log_file) : File::NULL\n          @logger = WEBrick::Log.new(log_sink)\n          @logger.time_format = \"[%Y-%m-%dT%H:%M:%S.%L%z]\"\n        end",
        "comment": "@param settings [Hash] SettingsLogic hash containing the `*_exporter` config @param log_enabled [Boolean] whether to log HTTP requests @param log_file [String] path to where the server log should be located @param gc_requests [Boolean] whether to run a major GC after each scraper request",
        "label": "What",
        "id": "2318"
    },
    {
        "raw_code": "def self.bar\n          end",
        "comment": "== visibility",
        "label": "What",
        "id": "768"
    },
    {
        "raw_code": "def set_file_path_error(error)\n        @invalid_path_error ||= error.is_a?(SnippetRepository::InvalidPathError)\n      end",
        "comment": "We sometimes receive invalid path errors from Gitaly if the Snippet filename cannot be parsed into a valid git path. In this situation, we need to parameterize the file name of the Snippet so that the migration can succeed, to achieve that, we'll identify in migration retries that the path is invalid",
        "label": "What",
        "id": "3284"
    },
    {
        "raw_code": "def apply_default_formatter\n      # This must be done after the options have already been processed,\n      # because they can affect how ConfigStore behaves\n      @options[:formatters] ||= begin\n        if @options[:auto_gen_config]\n          formatter = 'autogenconf'\n        else\n          cfg = @config_store.for_pwd.for_all_cops\n          formatter = cfg['DefaultFormatter'] || 'progress'\n        end",
        "comment": "rubocop:enable Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "10062"
    },
    {
        "raw_code": "def find_public_version(number, platform = nil)\n    if platform\n      public_versions.find_by(number:, platform:)\n    else\n      public_versions.find_by(number:)\n    end",
        "comment": "NB: this intentionally does not default the platform to ruby. Without platform, finds the most recent version by (position, created_at) ignoring platform.",
        "label": "What",
        "id": "9986"
    },
    {
        "raw_code": "def repository_invitations(repo, options = {})\n        paginate \"#{Repository.path repo}/invitations\", options\n      end",
        "comment": "List all invitations for a repository  Requires authenticated client  @param repo [Integer, String, Repository, Hash] A GitHub repository @return [Array<Sawyer::Resource>] A list of invitations @see https://developer.github.com/v3/repos/invitations/#list-invitations-for-a-repository",
        "label": "What",
        "id": "15396"
    },
    {
        "raw_code": "def expand_name(name)\n    klass, selector, method = parse_name name\n\n    return [selector, method].join if klass.empty?\n\n    case selector\n    when ':' then\n      [find_store(klass),   selector, method]\n    else\n      [expand_class(klass), selector, method]\n    end.join\n  end",
        "comment": " Expands the class portion of +name+ into a fully-qualified class.  See #expand_class.",
        "label": "What",
        "id": "16601"
    },
    {
        "raw_code": "def test_clear_also_clears_local_cache\n    key = SecureRandom.uuid\n    cache = lookup_store(raw: true)\n    stub_called = false\n\n    client(cache).stub(:flush_all, -> { stub_called = true; client.delete(\"#{@namespace}:#{key}\") }) do\n      cache.with_local_cache do\n        cache.write(key, SecureRandom.alphanumeric)\n        cache.clear\n        assert_nil cache.read(key)\n      end",
        "comment": "Overrides test from LocalCacheBehavior in order to stub out the cache clear and replace it with a delete.",
        "label": "What",
        "id": "14608"
    },
    {
        "raw_code": "def require_namespace_project_creation_permission\n    if Gitlab::ImportSources.template?(@project.import_type)\n      render_404 unless can?(current_user, :create_projects, project.namespace)\n    else\n      unless can?(current_user, :admin_project, @project) || can?(current_user, :import_projects, @project.namespace)\n        render_404\n      end",
        "comment": "Project creation by template uses a different permission model to regular imports https://gitlab.com/gitlab-org/gitlab/-/issues/414046#note_1945586449.",
        "label": "What",
        "id": "6616"
    },
    {
        "raw_code": "def inspect_container(cid)\n        JSON.parse(execute('docker', 'inspect', cid)).first\n      end",
        "comment": "Inspect the provided container  @param [String] cid ID or name of container @return [Hash]",
        "label": "What",
        "id": "9483"
    },
    {
        "raw_code": "def any_outstanding_lfk_records?(parent)\n    Gitlab::Database::SharedModel.using_connection(parent.connection) do\n      Gitlab::Database::LooseForeignKeys.definitions_by_table.each_key do |table|\n        fully_qualified_table_name = \"#{parent.connection.current_schema}.#{table}\"\n        return true if LooseForeignKeys::DeletedRecord.load_batch_for_table(fully_qualified_table_name, 1000).any?\n      end",
        "comment": "- Debug code to be removed. rubocop:disable Cop/AvoidReturnFromBlocks -- Intentional Short Circuit",
        "label": "What",
        "id": "8312"
    },
    {
        "raw_code": "def delete_dependabot_secret(repo, name)\n        boolean_from_response :delete, \"#{Repository.path repo}/dependabot/secrets/#{name}\"\n      end",
        "comment": "Delete a secret  @param repo [Integer, String, Hash, Repository] A GitHub repository @param name [String] Name of secret @see https://docs.github.com/en/rest/dependabot/repository-secrets?apiVersion=2022-11-28#delete-a-repository-secret",
        "label": "What",
        "id": "14993"
    },
    {
        "raw_code": "def _HtmlBlockH1\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenH1)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockH1 = HtmlBlockOpenH1 (HtmlBlockH1 | !HtmlBlockCloseH1 .)* HtmlBlockCloseH1",
        "label": "What",
        "id": "15652"
    },
    {
        "raw_code": "def self.set_service_account(desired_config_array:, service_account_name:)\n                find_pod_spec(desired_config_array)[:serviceAccountName] = service_account_name\n\n                nil\n              end",
        "comment": "@param [Array<Hash>] desired_config_array @param [String] service_account_name @return [void]",
        "label": "What",
        "id": "3338"
    },
    {
        "raw_code": "def default_form_builder(builder)\n        self._default_form_builder = builder\n      end",
        "comment": "Set the form builder to be used as the default for all forms in the views rendered by this controller and its subclasses.  #### Parameters *   `builder` - Default form builder. Accepts a subclass of ActionView::Helpers::FormBuilder",
        "label": "What",
        "id": "11221"
    },
    {
        "raw_code": "def _Indent\n    _tmp = scan(/\\G(?-mix:\\t|    )/)\n    set_failed_rule :_Indent unless _tmp\n    return _tmp\n  end",
        "comment": "Indent = /\\t|    /",
        "label": "What",
        "id": "15813"
    },
    {
        "raw_code": "def sign_in_url\n        @sign_in_url ||= \"#{Support::GitlabAddress.address_with_port(with_default_port: false)}/users/sign_in\"\n      end",
        "comment": "Sign in page url  @return [String]",
        "label": "What",
        "id": "4693"
    },
    {
        "raw_code": "def each_node\n          return to_enum(__method__) unless block_given?\n\n          doc.xpath(query).each do |node|\n            yield node\n          end",
        "comment": "Iterates over all <a> and text() nodes in a document.  Nodes are skipped whenever their ancestor is one of the nodes returned by `ignore_ancestor_query`. Link tags are not processed if they have a \"gfm\" class or the \"href\" attribute is empty.",
        "label": "What",
        "id": "3490"
    },
    {
        "raw_code": "def build(event)\n        [\n          event_data(event),\n          timestamps_data,\n          key_data,\n          user_data\n        ].reduce(:merge)\n      end",
        "comment": "Sample data { event_name: \"key_create\", created_at: \"2021-04-19T06:13:24Z\", updated_at: \"2021-04-19T06:13:24Z\", key: \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQClDn/5BaESHlSb3NxQtiUc0BXgK6lsqdAUIdS3lwZ2gbACDhtoLYnc+qhZ4b8gWzE+2A8RmkvLe98T7noRoW4DAYs67NSqMs/kXd2ESPNV8qqv0u7tCxPz+c7DaYp2oC/avlxVQ2AeULZLCEwalYZ7irde0EZMeTwNIRu5s88gOw== dummy@gitlab.com\", id: 1, username: \"johndoe\" }",
        "label": "What",
        "id": "2415"
    },
    {
        "raw_code": "def test_stats(example)\n          # do not save failures from initial non retry run, as they will be retried and become flaky or failed\n          return if retry_failed_specs? && (!rspec_retried? && example.execution_result.status == :failed)\n\n          {\n            name: 'test-stats',\n            time: time,\n            tags: tags(example),\n            fields: fields(example)\n          }\n        rescue StandardError => e\n          log(:error, \"Failed to transform example '#{example.id}', error: #{e}\")\n          nil\n        end",
        "comment": "Transform example to influxdb compatible metrics data https://github.com/influxdata/influxdb-client-ruby#data-format  @param [RSpec::Core::Example] example @return [Hash]",
        "label": "What",
        "id": "4629"
    },
    {
        "raw_code": "def self.accept?(blob)\n      false\n    end",
        "comment": "Implement this method in a concrete subclass. Have it return true when given a blob from which the previewer can generate an image.",
        "label": "What",
        "id": "13662"
    },
    {
        "raw_code": "def execute\n        return error('User cannot copy design collection to issue') unless user_can_copy?\n        return error('Target design collection must first be queued') unless target_design_collection.copy_in_progress?\n        return error('Design collection has no designs') if designs.empty?\n        return error('Target design collection already has designs') unless target_design_collection.empty?\n\n        with_temporary_branch do\n          copy_commits!\n\n          ApplicationRecord.transaction do\n            design_ids = copy_designs!\n            version_ids = copy_versions!\n            copy_actions!(design_ids, version_ids)\n            link_lfs_files!\n            copy_notes!(design_ids)\n            finalize!\n          end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6081"
    },
    {
        "raw_code": "def advance(options)\n    unless options[:weeks].nil?\n      options[:weeks], partial_weeks = options[:weeks].divmod(1)\n      options[:days] = options.fetch(:days, 0) + 7 * partial_weeks\n    end",
        "comment": "Uses Date to provide precise Time calculations for years, months, and days. The +options+ parameter takes a hash with any of these keys: <tt>:years</tt>, <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>, <tt>:hours</tt>, <tt>:minutes</tt>, <tt>:seconds</tt>.  Just like Date#advance, increments are applied in order of time units from largest to smallest. This order can affect the result around the end of a month.",
        "label": "What",
        "id": "14186"
    },
    {
        "raw_code": "def execute\n            Bundler.with_original_env do\n              @result = Shell::Command.new(*rake_command, chdir: chdir).capture\n            end",
        "comment": "Execute the rake task and return its execution result status  @return [self]",
        "label": "What",
        "id": "1057"
    },
    {
        "raw_code": "def agreement\n      strong_memoize(:agreement) do\n        next nil if @user.nil? || @subject.nil?\n\n        @user.term_agreements.find_by(term: @subject)\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6271"
    },
    {
        "raw_code": "def has_imported_group?(source_group_name, wait: QA::Support::WaitForRequests::DEFAULT_MAX_WAIT_TIME)\n          within_element('import-item', source_group: source_group_name) do\n            has_element?('import-status-indicator', text: \"Complete\", wait: wait)\n          end",
        "comment": "Check if import page has a successfully imported group  @param [String] source_group_name @param [Integer] wait @return [Boolean]",
        "label": "What",
        "id": "4291"
    },
    {
        "raw_code": "def find_correct_path(upload_path)\n        upload = Upload.find_by(uploader: 'FileUploader', path: upload_path)\n        return unless upload && upload.local? && upload.model\n\n        upload.absolute_path\n      rescue StandardError => e\n        logger.error e.message\n\n        # absolute_path depends on a lot of code. If it doesn't work, then it\n        # it doesn't matter if the upload file is in the right place. Treat it\n        # as uncorrectable.\n        # I.e. the project record might be missing, which raises an exception.\n        nil\n      end",
        "comment": "Accepts a path in the form of \"#{hex_secret}/#{filename}\" rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2724"
    },
    {
        "raw_code": "def data_source_exists?(name)\n        query_values(data_source_sql(name), \"SCHEMA\").any? if name.present?\n      rescue NotImplementedError\n        data_sources.include?(name.to_s)\n      end",
        "comment": "Checks to see if the data source +name+ exists on the database.  data_source_exists?(:ebooks) ",
        "label": "What",
        "id": "13129"
    },
    {
        "raw_code": "def create_commit_comment_reaction(repo, id, reaction, options = {})\n        options = options.merge(content: reaction)\n        post \"#{Repository.path repo}/comments/#{id}/reactions\", options\n      end",
        "comment": "Create a reaction for a commit comment  @param repo [Integer, String, Hash, Repository] A GitHub repository @param id [Integer] The id of the commit comment @param reaction [String] The Reaction @see https://developer.github.com/v3/reactions/#create-reaction-for-a-commit-comment @see https://developer.github.com/v3/reactions/#reaction-types  @example @client.create_commit_comment_reactions(\"octokit/octokit.rb\", 1)  @return [<Sawyer::Resource>] Hash representing the reaction",
        "label": "What",
        "id": "15403"
    },
    {
        "raw_code": "def print_error(msg)\n          puts Rainbow(msg).red\n          exit 1 # rubocop:disable Rails/Exit -- used only in rake tasks\n        end",
        "comment": "rubocop:disable Rails/Output -- We do want to write to stdout",
        "label": "What",
        "id": "3216"
    },
    {
        "raw_code": "def reviews\n        parse_body(api_get_from(api_reviewers_path))\n      end",
        "comment": "Get merge request reviews  @return [Array<Hash>]",
        "label": "What",
        "id": "4165"
    },
    {
        "raw_code": "def on_block_pass(node)\n          kv_each_with_block_pass(node.parent) do |target, method|\n            register_kv_with_block_pass_offense(node, target, method)\n          end",
        "comment": "rubocop:enable Metrics/AbcSize",
        "label": "What",
        "id": "10518"
    },
    {
        "raw_code": "def self.post_processors\n    @post_processors\n  end",
        "comment": " Registered post-processors",
        "label": "What",
        "id": "16363"
    },
    {
        "raw_code": "def tag_ref?\n            return true if full_git_ref_name_unavailable?\n\n            Gitlab::Git.tag_ref?(origin_ref).present?\n          end",
        "comment": "Verifies that origin_ref is a fully qualified tag reference (refs/tags/<tag-name>)  Fallbacks to `true` for backward compatibility reasons if origin_ref is a short ref",
        "label": "What",
        "id": "2511"
    },
    {
        "raw_code": "def stub_connection(identifiers = {})\n          @connection = ConnectionStub.new(identifiers)\n        end",
        "comment": "Set up test connection with the specified identifiers:  class ApplicationCable < ActionCable::Connection::Base identified_by :user, :token end  stub_connection(user: users[:john], token: 'my-secret-token')",
        "label": "What",
        "id": "11056"
    },
    {
        "raw_code": "def serialize(value)\n        arg = if value.present?\n                Base64.decode64(value)\n              else\n                nil\n              end",
        "comment": "Casts a SHA256 in a proper binary format. which is 32 bytes long",
        "label": "What",
        "id": "2967"
    },
    {
        "raw_code": "def valid?\n        super && strategy.valid?\n      end",
        "comment": "Cascade the validation to strategy",
        "label": "What",
        "id": "6097"
    },
    {
        "raw_code": "def find_or_create_by(attributes, &block)\n          find_by(attributes) || create(attributes, &block)\n        end",
        "comment": "Adds patch for ActiveRecord `find_or_create_by`/`find_or_create_by!` methods so as to prevent it from opening subtransactions. Rails commit: https://github.com/rails/rails/commit/023a3eb3c046091a5d52027393a6d29d0576da01 Issue: https://gitlab.com/gitlab-org/gitlab/-/issues/439567",
        "label": "What",
        "id": "1172"
    },
    {
        "raw_code": "def add_comment(body:, confidential: false)\n        api_post_to(api_comments_path, body: body, confidential: confidential)\n      end",
        "comment": "Create a new comment  @param [String] body @param [Boolean] confidential @return [Hash]",
        "label": "What",
        "id": "4202"
    },
    {
        "raw_code": "def html_syntax_highlight_ruby(source)\n          if Parser::SourceParser.parser_type == :ruby\n            html_syntax_highlight_ruby_ripper(source)\n          else\n            html_syntax_highlight_ruby_legacy(source)\n          end",
        "comment": "Highlights Ruby source @param [String] source the Ruby source code @return [String] the highlighted Ruby source",
        "label": "What",
        "id": "456"
    },
    {
        "raw_code": "def predefined_ci_server_variables\n    Gitlab::Ci::Variables::Collection.new\n      .append(key: 'CI', value: 'true')\n      .append(key: 'GITLAB_CI', value: 'true')\n      .append(key: 'CI_SERVER_FQDN', value: Gitlab.config.gitlab.server_fqdn)\n      .append(key: 'CI_SERVER_URL', value: Gitlab.config.gitlab.url)\n      .append(key: 'CI_SERVER_HOST', value: Gitlab.config.gitlab.host)\n      .append(key: 'CI_SERVER_PORT', value: Gitlab.config.gitlab.port.to_s)\n      .append(key: 'CI_SERVER_PROTOCOL', value: Gitlab.config.gitlab.protocol)\n      .append(key: 'CI_SERVER_SHELL_SSH_HOST', value: Gitlab.config.gitlab_shell.ssh_host.to_s)\n      .append(key: 'CI_SERVER_SHELL_SSH_PORT', value: Gitlab.config.gitlab_shell.ssh_port.to_s)\n      .append(key: 'CI_SERVER_NAME', value: 'GitLab')\n      .append(key: 'CI_SERVER_VERSION', value: Gitlab::VERSION)\n      .append(key: 'CI_SERVER_VERSION_MAJOR', value: Gitlab.version_info.major.to_s)\n      .append(key: 'CI_SERVER_VERSION_MINOR', value: Gitlab.version_info.minor.to_s)\n      .append(key: 'CI_SERVER_VERSION_PATCH', value: Gitlab.version_info.patch.to_s)\n      .append(key: 'CI_SERVER_REVISION', value: Gitlab.revision)\n  end",
        "comment": "rubocop: enable Metrics/AbcSize",
        "label": "What",
        "id": "6761"
    },
    {
        "raw_code": "def inventory_path\n          if config.inventory_path\n            config.inventory_path\n          else\n            @inventory_path ||= generate_inventory\n          end",
        "comment": "Auto-generate \"safe\" inventory file based on Vagrantfile, unless inventory_path is explicitly provided",
        "label": "What",
        "id": "9886"
    },
    {
        "raw_code": "def proxy\n        ENV.fetch('OCTOKIT_PROXY', nil)\n      end",
        "comment": "Default proxy server URI for Faraday connection from ENV @return [String]",
        "label": "What",
        "id": "14893"
    },
    {
        "raw_code": "def must_understand\n      response.cache_control[:must_understand] = true\n      response.cache_control[:no_store] = true\n    end",
        "comment": "Adds the `must-understand` directive to the `Cache-Control` header, which indicates that a cache MUST understand the semantics of the response status code that has been received, or discard the response.  This is particularly useful when returning responses with new or uncommon status codes that might not be properly interpreted by older caches.  #### Example  def show @article = Article.find(params[:id])  if @article.early_access? must_understand render status: 203 # Non-Authoritative Information else fresh_when @article end end ",
        "label": "What",
        "id": "11256"
    },
    {
        "raw_code": "def index_statement_from!(definition)\n          parsed_query = PgQuery.parse(definition)\n\n          parsed_query.tree.stmts[0].stmt.index_stmt\n        end",
        "comment": "This raises `PgQuery::ParseError` if the given statement is syntactically incorrect, therefore, validates that the index definition is correct.",
        "label": "What",
        "id": "3059"
    },
    {
        "raw_code": "def ci_available_runners\n    Ci::Runner.from_union([ci_available_project_runners, ci_available_group_runners])\n  end",
        "comment": "Lists runners that are available to the user (group runners assigned to groups where the user has owner access to and project runners assigned to projects the user has maintainer access to)",
        "label": "What",
        "id": "7093"
    },
    {
        "raw_code": "def test_has_many_through_has_many_with_has_many_through_source_reflection\n    general = tags(:general)\n    assert_equal [general, general], authors(:david).tags\n  end",
        "comment": "Through associations can either use the has_many or has_one macros.  has_many - Source reflection can be has_many, has_one, belongs_to or has_and_belongs_to_many - Through reflection can be has_many, has_one, belongs_to or has_and_belongs_to_many  has_one - Source reflection can be has_one or belongs_to - Through reflection can be has_one or belongs_to  Additionally, the source reflection and/or through reflection may be subject to polymorphism and/or STI.  When testing these, we need to make sure it works via loading the association directly, or joining the association, or including the association. We also need to ensure that associations are readonly where relevant. has_many through Source: has_many through Through: has_many",
        "label": "What",
        "id": "13551"
    },
    {
        "raw_code": "def third_party_docker_registry\n        ENV['QA_THIRD_PARTY_DOCKER_REGISTRY']\n      end",
        "comment": "ENV variables for authenticating against a private container registry These need to be set if using the Service::DockerRun::Mixins::ThirdPartyDocker module",
        "label": "What",
        "id": "4465"
    },
    {
        "raw_code": "def _RawHtml\n\n    _save = self.pos\n    while true # sequence\n      _text_start = self.pos\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_HtmlComment)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_HtmlBlockScript)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_HtmlTag)\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      if _tmp\n        text = get_text(_text_start)\n      end",
        "comment": "RawHtml = < (HtmlComment | HtmlBlockScript | HtmlTag) > { if html? then text else '' end }",
        "label": "What",
        "id": "15791"
    },
    {
        "raw_code": "def middleware\n          @middleware ||= Middleware.new(\"ActiveSupport::Cache::Strategy::LocalCache\", self)\n        end",
        "comment": "Middleware class can be inserted as a Rack handler to be local cache for the duration of request.",
        "label": "What",
        "id": "14057"
    },
    {
        "raw_code": "def default(text: \"Button\", url: \"\", type: :button, color: :primary, size: :large, style: :fill, disabled: false) # rubocop:disable Metrics/ParameterLists\n    args = [text, url].compact_blank\n    render ButtonComponent.new(\n      *args,\n      type: type,\n      color: color,\n      size: size,\n      style: style,\n      disabled: disabled\n    )\n  end",
        "comment": "@param text text \"text\" @param url url \"link\" @param type select \"type\", { choices: [button, link, submit] } @param color select \"color\", { choices: [primary, secondary, red, orange, hammy, yellow, green, blue, neutral] } @param size select \"size\", { choices: [small, large] } @param style select \"style\", { choices: [fill, outline, plain] } @param disabled toggle \"disabled\"",
        "label": "What",
        "id": "10023"
    },
    {
        "raw_code": "def module_names\n    @cache[:modules]\n  end",
        "comment": " Modules cache accessor.  An Array of all the module (and class) names in the store.",
        "label": "What",
        "id": "15882"
    },
    {
        "raw_code": "def transform_api_resource(api_resource)\n        return api_resource if api_resource[:username] == username\n\n        path = begin\n          # /users/:id can't be used as default get path because it returns very limited response if admin token is\n          # not used\n          \"/users/#{id}\"\n        rescue NoValueError\n          # if id is not yet known, attempt to find the id based on username\n          \"/users/#{fetch_id(username)}\"\n        end",
        "comment": "Use id specific path in case api get action was not performed with the token that belongs to user of resource This will happen when user was created with admin token without option 'with_personal_access_token' set to true  @param api_resource [Hash] @return [Hash]",
        "label": "What",
        "id": "4195"
    },
    {
        "raw_code": "def update_params_for_auth!(header_params, query_params, auth_names)\n      Array(auth_names).each do |auth_name|\n        auth_setting = @config.auth_settings[auth_name]\n        next unless auth_setting\n        case auth_setting[:in]\n        when 'header' then header_params[auth_setting[:key]] = auth_setting[:value]\n        when 'query'  then query_params[auth_setting[:key]] = auth_setting[:value]\n        else fail ArgumentError, 'Authentication token must be in `query` or `header`'\n        end",
        "comment": "Update header and query params based on authentication settings.  @param [Hash] header_params Header parameters @param [Hash] query_params Query parameters @param [String] auth_names Authentication scheme name",
        "label": "What",
        "id": "837"
    },
    {
        "raw_code": "def wait_for(deadline, &condblock)\n      remaining = deadline - ::Process.clock_gettime(::Process::CLOCK_MONOTONIC)\n      while remaining > PAUSE_TIME\n        return if condblock.call\n        sleep PAUSE_TIME\n        remaining = deadline - ::Process.clock_gettime(::Process::CLOCK_MONOTONIC)\n      end",
        "comment": "Wait for the orblock to be true or the deadline passed.",
        "label": "What",
        "id": "5100"
    },
    {
        "raw_code": "def save(merge = true, file = nil)\n      if file && file != @file\n        @file = file\n        @serializer = Serializers::YardocSerializer.new(@file)\n      end",
        "comment": "Saves the database to disk @param [Boolean] merge if true, merges the data in memory with the data on disk, otherwise the data on disk is deleted. @param [String, nil] file if supplied, the name of the file to save to @return [Boolean] whether the database was saved",
        "label": "What",
        "id": "99"
    },
    {
        "raw_code": "def signature(meth, link = true, show_extras = true, full_attr_name = true)\n        meth = convert_method_to_overload(meth)\n\n        type = signature_types(meth, link)\n        type = \"&#x21d2; #{type}\" if type && !type.empty?\n        scope = meth.scope == :class ? \".\" : \"#\"\n        name = full_attr_name ? meth.name : meth.name.to_s.gsub(/^(\\w+)=$/, '\\1')\n        blk = format_block(meth)\n        args = !full_attr_name && meth.writer? ? \"\" : format_args(meth)\n        extras = []\n        extras_text = ''\n        if show_extras\n          rw = meth.attr_info\n          if rw\n            attname = [rw[:read] ? 'read' : nil, rw[:write] ? 'write' : nil].compact\n            attname = attname.size == 1 ? attname.join('') + 'only' : nil\n            extras << attname if attname\n          end",
        "comment": "Formats the signature of method +meth+.  @param [CodeObjects::MethodObject] meth the method object to list the signature of @param [Boolean] link whether to link the method signature to the details view @param [Boolean] show_extras whether to show extra meta-data (visibility, attribute info) @param [Boolean] full_attr_name whether to show the full attribute name (\"name=\" instead of \"name\") @return [String] the formatted method signature",
        "label": "What",
        "id": "418"
    },
    {
        "raw_code": "def verify_pipelines_import\n        logger.info(\"== Verifying pipelines import ==\")\n        expect(pipelines).to eq(source_pipelines)\n      end",
        "comment": "Verify pipelines import  @return [void]",
        "label": "What",
        "id": "4380"
    },
    {
        "raw_code": "def hash_for_location(offense)\n        {\n          start_line:   offense.line,\n          start_column: offense.real_column,\n          last_line:    offense.last_line,\n          last_column:  offense.last_column.zero? ? 1 : offense.last_column,\n          length:       offense.location.length,\n          # `line` and `column` exist for compatibility.\n          # Use `start_line` and `start_column` instead.\n          line:         offense.line,\n          column:       offense.real_column\n        }\n      end",
        "comment": "TODO: Consider better solution for Offense#real_column. The minimum value of `start_column: real_column` is 1. So, the minimum value of `last_column` should be 1. And non-zero value of `last_column` should be used as is.",
        "label": "What",
        "id": "10188"
    },
    {
        "raw_code": "def remove_legacy_registry_tags\n      return true unless Gitlab.config.registry.enabled\n\n      root_repository = ::ContainerRepository.build_root_repository(project)\n      root_repository.has_tags? ? destroy_repository(project, root_repository) : true\n    end",
        "comment": " This method makes sure that we correctly remove registry tags for legacy image repository (when repository path equals project path). ",
        "label": "What",
        "id": "5919"
    },
    {
        "raw_code": "def systemd_networkd?(comm)\n          comm.test(\"systemctl -q is-active systemd-networkd.service\", sudo: true)\n        end",
        "comment": "systemd-networkd.service is in use  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @return [Boolean]",
        "label": "What",
        "id": "9258"
    },
    {
        "raw_code": "def process_api_response(parsed_response)\n        self.api_response = parsed_response\n        self.api_resource = transform_api_resource(parsed_response.deep_dup)\n      end",
        "comment": "rubocop:enable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "4119"
    },
    {
        "raw_code": "def send(*args)\n        super\n      rescue\n        # Both threads try (and fail) to dispatch to the subclass's name\n        @barrier.wait\n        raise\n      ensure\n        # Then one thread successfully completes (updating the dispatch\n        # table in the process) before the other finishes raising its\n        # exception.\n        Thread.current[:delay].wait if Thread.current[:delay]\n      end",
        "comment": "This is terrible, but it's the only way to reliably reproduce the possible race where two threads attempt to correct the dispatch hash at the same time.",
        "label": "What",
        "id": "13544"
    },
    {
        "raw_code": "def accept_blank_line(blank_line)\n    # @res << annotate(\"<p />\") << \"\\n\"\n  end",
        "comment": " Adds +blank_line+ to the output",
        "label": "What",
        "id": "16341"
    },
    {
        "raw_code": "def has_directive?(tag_name)\n        tag_name && respond_to?(self.class.directive_method_name(tag_name))\n      end",
        "comment": "@param [#to_s] tag_name the name of the tag to look for @return [Boolean] whether a directive by the given name is registered in the library.",
        "label": "What",
        "id": "246"
    },
    {
        "raw_code": "def \\#{unsafe_method}(*params, &block)\n            to_str.\\#{unsafe_method}(*params, &block)\n          end",
        "comment": "def capitalize(*params, &block) to_str.capitalize(*params, &block) end",
        "label": "What",
        "id": "10860"
    },
    {
        "raw_code": "def down\n    drop_table :authentication_event_archived_records\n  end",
        "comment": "rubocop:enable Migration/EnsureFactoryForTable",
        "label": "What",
        "id": "5017"
    },
    {
        "raw_code": "def log_slow_code(param_info = '', **kwargs)\n          starting = kwargs.fetch(:starting_time, Time.now)\n          result = yield\n          ending = kwargs.fetch(:ending_time, Time.now)\n          duration = (ending - starting).round(3)\n          method_name = caller_locations(1, 1).first.label\n          called_from = caller_locations(2, 1).first.path\n          CodeRuntimeTracker.record_method_call(\n            name: method_name,\n            runtime: duration,\n            filename: called_from.gsub(\"#{Runtime::Path.qa_root}/\", ''),\n            call_arg: param_info.is_a?(QA::Page::Element) ? param_info.name : param_info\n          )\n\n          if duration > kwargs.fetch(:log_slow_threshold, 1)\n            Runtime::Logger.warn(\"Potentially Slow Code '#{method_name} #{param_info}' took #{duration}s\")\n          end",
        "comment": "Prints warning log if code duration is slower than threshold @param [String (frozen)] paramInfo is info relating to the slow element",
        "label": "What",
        "id": "4581"
    },
    {
        "raw_code": "def get_warning_events\n          items = JSON.parse(kubeclient.events(json_format: true), symbolize_names: true)[:items]\n\n          events = items\n            .select { |item| item[:kind] == \"Event\" && item[:type] == \"Warning\" }\n            .reject { |item| IGNORED_EVENTS.include?(item[:reason]) }\n            .map do |item|\n              object = item[:involvedObject]\n\n              {\n                **item.slice(:type, :reason),\n                name: \"#{object[:kind]}/#{object[:name]}\",\n                message: item[:message]\n              }\n            end",
        "comment": "Get cluster events with warning type  @return [String]",
        "label": "What",
        "id": "4010"
    },
    {
        "raw_code": "def self.single\n        ::Resolvers::DesignManagement::VersionInCollectionResolver\n      end",
        "comment": "This resolver has a custom singular resolver",
        "label": "What",
        "id": "6196"
    },
    {
        "raw_code": "def self.build(klass, params = nil)\n        if params\n          \"#{klass}.new(#{params})\"\n        else\n          \"#{klass}.new\"\n        end",
        "comment": "Used for:  * GET +new+ * POST +create+",
        "label": "What",
        "id": "14750"
    },
    {
        "raw_code": "def create_merge_request?\n    # Even if the field is set, if we're checking the same branch\n    # as the target branch in the same project,\n    # we don't want to create a merge request.\n    # FIXME: We should use either 1 or true, not both.\n    ActiveModel::Type::Boolean.new.cast(params[:create_merge_request]) &&\n      (@different_project || @start_branch != @branch_name) # rubocop:disable Gitlab/ModuleWithInstanceVariables\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop:enable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "6518"
    },
    {
        "raw_code": "def execute\n      return unless Gitlab::Git.branch_ref?(ref)\n\n      enqueue_update_mrs\n      enqueue_detect_repository_languages\n      enqueue_record_project_target_platforms\n\n      execute_related_hooks\n\n      stop_environments\n      unlock_artifacts\n\n      true\n    end",
        "comment": "This method will be called after each git update and only if the provided user and project are present in GitLab.  All callbacks for post receive action should be placed here.  Next, this method: 1. Creates the push event 2. Updates merge requests 3. Recognizes cross-references from commit messages 4. Executes the project's webhooks 5. Executes the project's services 6. Checks if the project's main language has changed ",
        "label": "What",
        "id": "5857"
    },
    {
        "raw_code": "def connect\n          @raw_connection = self.class.new_client(@connection_parameters)\n        rescue ConnectionNotEstablished => ex\n          raise ex.set_pool(@pool)\n        end",
        "comment": "Connects to a PostgreSQL server and sets up the adapter depending on the connected server's characteristics.",
        "label": "What",
        "id": "12982"
    },
    {
        "raw_code": "def self.pick_storage_shard(expire: true)\n    Gitlab::CurrentSettings.expire_current_application_settings if expire\n    Gitlab::CurrentSettings.pick_repository_storage\n  end",
        "comment": "Choose one of the available repository storage options based on a normalized weighted probability. We should always use the latest settings, to avoid picking a deleted shard.",
        "label": "What",
        "id": "7154"
    },
    {
        "raw_code": "def parse\n        until files.empty?\n          file = files.shift\n          log.capture(\"Parsing #{file}\") do\n            SourceParser.new(SourceParser.parser_type, @global_state).parse(file)\n          end",
        "comment": "Parses the remainder of the {#files} list.  @see Processor#parse_remaining_files",
        "label": "What",
        "id": "286"
    },
    {
        "raw_code": "def register(name, class_name, path = class_name.underscore)\n        @adapters[name.to_s] = [class_name, path]\n      end",
        "comment": "Registers a custom database adapter.  Can also be used to define aliases.  == Example  ActiveRecord::ConnectionAdapters.register(\"megadb\", \"MegaDB::ActiveRecordAdapter\", \"mega_db/active_record_adapter\")  ActiveRecord::ConnectionAdapters.register(\"mysql\", \"ActiveRecord::ConnectionAdapters::TrilogyAdapter\", \"active_record/connection_adapters/trilogy_adapter\") ",
        "label": "What",
        "id": "12394"
    },
    {
        "raw_code": "def post_init\n    start_gitaly\n  end",
        "comment": "Can be overriden",
        "label": "What",
        "id": "8469"
    },
    {
        "raw_code": "def []=(key, value)\n        load_for_write!\n        @delegate[key.to_s] = value\n      end",
        "comment": "Writes given value to given key of the session.",
        "label": "What",
        "id": "11551"
    },
    {
        "raw_code": "def commit(repo, sha, options = {})\n        get \"#{Repository.path repo}/commits/#{sha}\", options\n      end",
        "comment": "Get a single commit  @param repo [Integer, String, Hash, Repository] A GitHub repository @param sha [String] The SHA of the commit to fetch @return [Sawyer::Resource] A hash representing the commit @see https://developer.github.com/v3/repos/commits/#get-a-single-commit",
        "label": "What",
        "id": "15061"
    },
    {
        "raw_code": "def fabricate!(*args, &prepare_block)\n          if Specs::Helpers::ContextSelector.dot_com? || Runtime::Env.personal_access_tokens_disabled?\n            return fabricate_via_browser_ui!(*args, &prepare_block)\n          end",
        "comment": "Force top level group creation via UI if test is executed on dot_com environment",
        "label": "What",
        "id": "4110"
    },
    {
        "raw_code": "def connected_to(role: nil, shard: nil, prevent_writes: false, &blk)\n      if self != Base && !abstract_class\n        raise NotImplementedError, \"calling `connected_to` is only allowed on ActiveRecord::Base or abstract classes.\"\n      end",
        "comment": "Connects to a role (e.g. writing, reading, or a custom role) and/or shard for the duration of the block. At the end of the block the connection will be returned to the original role / shard.  If only a role is passed, Active Record will look up the connection based on the requested role. If a non-established role is requested an +ActiveRecord::ConnectionNotEstablished+ error will be raised:  ActiveRecord::Base.connected_to(role: :writing) do Dog.create! # creates dog using dog writing connection end  ActiveRecord::Base.connected_to(role: :reading) do Dog.create! # throws exception because we're on a replica end  When swapping to a shard, the role must be passed as well. If a non-existent shard is passed, an +ActiveRecord::ConnectionNotEstablished+ error will be raised.  When a shard and role is passed, Active Record will first lookup the role, and then look up the connection by shard key.  ActiveRecord::Base.connected_to(role: :reading, shard: :shard_one_replica) do Dog.first # finds first Dog record stored on the shard one replica end",
        "label": "What",
        "id": "12397"
    },
    {
        "raw_code": "def lfs_http_url_to_repo(_operation = nil)\n    http_url_to_repo\n  end",
        "comment": "Is overridden in EE::Project for Geo support",
        "label": "What",
        "id": "7304"
    },
    {
        "raw_code": "def execute(triggers)\n          # ensure on_error is respected by exiting or continuing\n          triggers.each do |trigger|\n            @logger.debug(\"Running trigger #{trigger.id}...\")\n\n            if trigger.name\n              @ui.info(I18n.t(\"vagrant.trigger.fire_with_name\",\n                                      name: trigger.name))\n            else\n              @ui.info(I18n.t(\"vagrant.trigger.fire\"))\n            end",
        "comment": "Execute all triggers in the given array  @param [Array] triggers An array of triggers to be fired",
        "label": "What",
        "id": "9044"
    },
    {
        "raw_code": "def aref\n    title = @title || '[untitled]'\n\n    CGI.escape(title).gsub('%', '-').sub(/^-/, '')\n  end",
        "comment": " Anchor reference for linking to this section",
        "label": "What",
        "id": "16836"
    },
    {
        "raw_code": "def on_block(node)\n          symbol_proc?(node) do |dispatch_node, arguments_node, method_name|\n            if active_support_extensions_enabled?\n              return if proc_node?(dispatch_node)\n              return if LAMBDA_OR_PROC.include?(dispatch_node.method_name)\n            end",
        "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10549"
    },
    {
        "raw_code": "def finished_checking(component)\n      $stdout.puts ''\n      $stdout.puts \"Checking #{Rainbow(component).yellow} ... #{Rainbow('Finished').green}\"\n      $stdout.puts ''\n    end",
        "comment": "Prints footer content for the series of checks executed for this component  @param [String] component name of the component relative to the checks being executed",
        "label": "What",
        "id": "3702"
    },
    {
        "raw_code": "def merge(class_module)\n    @parent      = class_module.parent\n    @parent_name = class_module.parent_name\n\n    other_document = parse class_module.comment_location\n\n    if other_document then\n      document = parse @comment_location\n\n      document = document.merge other_document\n\n      @comment = RDoc::Comment.from_document(document)\n      @comment_location = document\n    end",
        "comment": " Merges +class_module+ into this ClassModule.  The data in +class_module+ is preferred over the receiver.",
        "label": "What",
        "id": "16751"
    },
    {
        "raw_code": "def ensure_filename_size(filename)\n        limit = BulkImports::FileDownloads::FilenameFetch::FILENAME_SIZE_LIMIT\n        return filename if filename.length <= limit\n\n        extname = File.extname(filename)\n        basename = File.basename(filename, extname)[0, limit]\n        \"#{basename}#{extname}\"\n      end",
        "comment": "rubocop:enable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "3613"
    },
    {
        "raw_code": "def set(options)\n          @options = options\n        end",
        "comment": "Set global cli options  @param [Hash] options @return [Hash]",
        "label": "What",
        "id": "4546"
    },
    {
        "raw_code": "def build_attributes\n            pipeline_attributes.merge(\n              yaml_variables: @yaml_variables)\n          end",
        "comment": "Remove this method with FF `read_from_new_ci_destinations`",
        "label": "What",
        "id": "2473"
    },
    {
        "raw_code": "def detect_generated_files(base, head, changed_paths)\n        return Set.new if changed_paths.blank?\n\n        # We only display diffs upto the diff_max_files size so we can avoid\n        # checking the rest if it exceeds the limit.\n        changed_paths = changed_paths.take(Gitlab::CurrentSettings.diff_max_files)\n\n        # Check .gitattributes overrides first\n        checked_files = get_file_attributes(\n          base,\n          changed_paths.map(&:path),\n          Gitlab::Git::ATTRIBUTE_OVERRIDES[:generated]\n        ).map { |attrs| { path: attrs[:path], generated: attrs[:value] == \"set\" } }\n\n        # Check automatic generated file detection for the remaining paths\n        overridden_paths = checked_files.pluck(:path)\n        remainder = changed_paths.reject { |changed_path| overridden_paths.include?(changed_path.path) }\n        checked_files += check_blobs_generated(base, head, remainder) if remainder.present?\n\n        checked_files\n          .select { |attrs| attrs[:generated] }\n          .pluck(:path)\n          .to_set\n\n      rescue Gitlab::Git::CommandError, Gitlab::Git::ResourceExhaustedError => e\n        # An exception can be raised due to an unknown revision or paths.\n        # Gitlab::Git::ResourceExhaustedError could be raised if the request payload is too large.\n        Gitlab::ErrorTracking.track_exception(\n          e,\n          gl_project_path: @gl_project_path,\n          base: base,\n          head: head,\n          paths_count: changed_paths.count,\n          paths_bytesize: changed_paths.map(&:path).join.bytesize\n        )\n\n        Set.new\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord -- not an active record operation",
        "label": "What",
        "id": "2658"
    },
    {
        "raw_code": "def save_method(klass, method)\n    full_name = klass.full_name\n\n    FileUtils.mkdir_p class_path(full_name) unless @dry_run\n\n    cache = if method.singleton then\n              @cache[:class_methods]\n            else\n              @cache[:instance_methods]\n            end",
        "comment": " Writes the ri data for +method+ on +klass+",
        "label": "What",
        "id": "15890"
    },
    {
        "raw_code": "def gitlab_access_token\n        @gitlab_access_token ||= ENV[\"GITLAB_ACCESS_TOKEN\"] || raise(\"Missing GITLAB_ACCESS_TOKEN env variable\")\n      end",
        "comment": "Gitlab access token  @return [String]",
        "label": "What",
        "id": "4706"
    },
    {
        "raw_code": "def list_network_names\n        list_network(\"--format={{.Name}}\").split(\"\\n\").map(&:strip)\n      end",
        "comment": "@return [Array<String>] list of all docker networks",
        "label": "What",
        "id": "9497"
    },
    {
        "raw_code": "def resolve_links(text)\n        code_tags = 0\n        text.gsub(%r{<(/)?(pre|code|tt)|(\\\\|!)?\\{(?!\\})(\\S+?)(?:\\s([^\\}]*?\\S))?\\}(?=[\\W<]|.+</|$)}m) do |str|\n          closed = $1\n          tag = $2\n          escape = $3\n          name = $4\n          title = $5\n          match = $&\n          if tag\n            code_tags += (closed ? -1 : 1)\n            next str\n          end",
        "comment": "@group Linking Objects and URLs Resolves any text in the form of +{Name}+ to the object specified by Name. Also supports link titles in the form +{Name title}+.  @example Linking to an instance method resolve_links(\"{MyClass#method}\") # => \"<a href='...'>MyClass#method</a>\" @example Linking to a class with a title resolve_links(\"{A::B::C the C class}\") # => \"<a href='...'>the c class</a>\" @param [String] text the text to resolve links in @return [String] HTML with linkified references",
        "label": "What",
        "id": "402"
    },
    {
        "raw_code": "def permanently_deleted?(resource)\n        response = get(resource_request(resource))\n        response.code == HTTP_STATUS_NOT_FOUND\n      end",
        "comment": "Check if resource is permanently deleted  @param [Hash] resource Resource to check @return [Boolean]",
        "label": "What",
        "id": "4742"
    },
    {
        "raw_code": "def license_info\n        get 'enterprise/settings/license'\n      end",
        "comment": "Get information about the Enterprise license  @return [Sawyer::Resource] The license information",
        "label": "What",
        "id": "14936"
    },
    {
        "raw_code": "def enabled_by_config?(scope: STEP_UP_AUTH_SCOPE_ADMIN_MODE)\n            oauth_providers.any? do |provider|\n              enabled_for_provider?(provider_name: provider, scope: scope)\n            end",
        "comment": "Checks if step-up authentication is enabled for the step-up auth scope 'admin_mode'  @return [Boolean] true if any OAuth provider requires step-up auth for admin mode",
        "label": "What",
        "id": "2367"
    },
    {
        "raw_code": "def setup_workhorse\n    measure_setup_duration('GitLab Workhorse') do\n      # Always rebuild the config file\n      if skip_compile_workhorse?\n        Gitlab::SetupHelper::Workhorse.create_configuration(workhorse_dir, nil, force: true)\n      else\n        FileUtils.rm_rf(workhorse_dir)\n        Gitlab::SetupHelper::Workhorse.compile_into(workhorse_dir)\n        Gitlab::SetupHelper::Workhorse.create_configuration(workhorse_dir, nil)\n\n        File.write(workhorse_tree_file, workhorse_tree) if workhorse_source_clean?\n      end",
        "comment": "Feature specs are run through Workhorse",
        "label": "What",
        "id": "8471"
    },
    {
        "raw_code": "def systemd?(comm)\n          comm.test(\"ps -o comm= 1 | grep systemd\", sudo: true)\n        end",
        "comment": "systemd helpers systemd is in use  @return [Boolean]",
        "label": "What",
        "id": "9257"
    },
    {
        "raw_code": "def method1\n          end",
        "comment": "{keyword} A",
        "label": "What",
        "id": "10970"
    },
    {
        "raw_code": "def show\n  end",
        "comment": "GET /messages/1",
        "label": "What",
        "id": "11703"
    },
    {
        "raw_code": "def relabeled_merge_request_email(recipient_id, merge_request_id, label_names, updated_by_user_id, reason = nil)\n      setup_merge_request_mail(merge_request_id, recipient_id)\n\n      @label_names = label_names\n      @labels_url = project_labels_url(@project, subscribed: true)\n      mail_answer_thread(@merge_request, merge_request_thread_options(updated_by_user_id, reason))\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6259"
    },
    {
        "raw_code": "def blank?\n    false\n  end",
        "comment": "No DateTime is ever blank:  DateTime.now.blank? # => false  @return [false]",
        "label": "What",
        "id": "14180"
    },
    {
        "raw_code": "def legacy_sort_cookie_name\n    nil\n  end",
        "comment": "Implement legacy_sort_cookie_name method on controllers to set sort from cookie for backwards compatibility.",
        "label": "What",
        "id": "6559"
    },
    {
        "raw_code": "def bar; end\n            end",
        "comment": "{access_modifier} get_method_name if get_method_name =~ /a/ {access_modifier}",
        "label": "What",
        "id": "10882"
    },
    {
        "raw_code": "def _HtmlBlockAddress\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenAddress)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockAddress = HtmlBlockOpenAddress (HtmlBlockAddress | !HtmlBlockCloseAddress .)* HtmlBlockCloseAddress",
        "label": "What",
        "id": "15628"
    },
    {
        "raw_code": "def request_authenticity_tokens # :doc:\n        [form_authenticity_param, request.x_csrf_token]\n      end",
        "comment": "Possible authenticity tokens sent in the request.",
        "label": "What",
        "id": "11341"
    },
    {
        "raw_code": "def finalize!\n          super\n\n          @recipe_url = nil if @recipe_url == UNSET_VALUE\n          @synced_folder_type = nil if @synced_folder_type == UNSET_VALUE\n          @legacy_mode = false if @legacy_mode == UNSET_VALUE\n\n          if @cookbooks_path == UNSET_VALUE\n            @cookbooks_path = []\n            @cookbooks_path << [:host, \"cookbooks\"] if !@recipe_url\n            @cookbooks_path << [:vm, \"cookbooks\"]\n          end",
        "comment": "------------------------------------------------------------ Internal methods ------------------------------------------------------------",
        "label": "What",
        "id": "9909"
    },
    {
        "raw_code": "def _reduce_136(val, _values, result)\n result << val[1]\n    result\nend",
        "comment": "reduce 116 omitted reduce 117 omitted reduce 118 omitted reduce 119 omitted reduce 120 omitted reduce 121 omitted reduce 122 omitted reduce 123 omitted reduce 124 omitted reduce 125 omitted reduce 126 omitted reduce 127 omitted reduce 128 omitted reduce 129 omitted reduce 130 omitted reduce 131 omitted reduce 132 omitted reduce 133 omitted reduce 134 omitted reduce 135 omitted",
        "label": "What",
        "id": "16556"
    },
    {
        "raw_code": "def normalize_pattern(pattern)\n      # Remove `\\` when escaping `\\#`\n      pattern = pattern.sub(/\\A\\\\#/, '#')\n      # Replace all whitespace preceded by a \\ with a regular whitespace\n      pattern = pattern.gsub(/\\\\\\s+/, ' ')\n\n      return '/**/*' if pattern == '*'\n\n      unless pattern.start_with?('/')\n        pattern = \"/**/#{pattern}\"\n      end",
        "comment": "Copied from ee/lib/gitlab/code_owners/file.rb",
        "label": "What",
        "id": "8088"
    },
    {
        "raw_code": "def shell_installed(home)\n        @logger.info(\"Searching for config in home #{home}\")\n        @config_paths.each do |path|\n          config_file = File.join(home, path)\n          if File.exist?(config_file)\n            @logger.info(\"Found config file #{config_file}\")\n            return config_file\n          end",
        "comment": "Searches a users home dir for a shell config file based on a given home dir and a configured set of config paths. If there are multiple config paths, it will return the first match.  @param [string] path to users home dir @return [string] path to shell config file if exists",
        "label": "What",
        "id": "9254"
    },
    {
        "raw_code": "def empty_content?(element)\n        element.texts.join.blank?\n      end",
        "comment": "Determines if a document element has text content  element:: XML element to be checked.",
        "label": "What",
        "id": "14598"
    },
    {
        "raw_code": "def send_blob_byte_range_data(blob, range_header, disposition: nil)\n      ranges = Rack::Utils.get_byte_ranges(range_header, blob.byte_size)\n\n      return head(:range_not_satisfiable) if ranges.blank? || ranges.all?(&:blank?)\n\n      if ranges.length == 1\n        range = ranges.first\n        content_type = blob.content_type_for_serving\n        data = blob.download_chunk(range)\n\n        response.headers[\"Content-Range\"] = \"bytes #{range.begin}-#{range.end}/#{blob.byte_size}\"\n      else\n        boundary = SecureRandom.hex\n        content_type = \"multipart/byteranges; boundary=#{boundary}\"\n        data = +\"\"\n\n        ranges.compact.each do |range|\n          chunk = blob.download_chunk(range)\n\n          data << \"\\r\\n--#{boundary}\\r\\n\"\n          data << \"Content-Type: #{blob.content_type_for_serving}\\r\\n\"\n          data << \"Content-Range: bytes #{range.begin}-#{range.end}/#{blob.byte_size}\\r\\n\\r\\n\"\n          data << chunk\n        end",
        "comment": "Stream the blob in byte ranges specified through the header",
        "label": "What",
        "id": "13591"
    },
    {
        "raw_code": "def remove_authorized_key(key)\n      conn = authenticated_client\n      case key\n      when String\n        if File.exist?(key)\n          key = File.open(key, 'r')\n          content = key.read.strip\n          key.close\n        else\n          content = key\n        end",
        "comment": "Removes an authorized SSH keys from the Enterprise install  @param key Either the file path to a key, a File handler to the key, or the contents of the key itself @return [nil]",
        "label": "What",
        "id": "14931"
    },
    {
        "raw_code": "def remote_storage_base_path\n    File.join(self.class.model_path_segment(model), dynamic_segment)\n  end",
        "comment": "To avoid prefacing the remote storage path with `/uploads/-/system`, we just drop that part so that the destination path will be personal_snippet/:id/:random_hex/:filename.",
        "label": "What",
        "id": "8056"
    },
    {
        "raw_code": "def match?(re)\n      (re == name) || (re == MAPPING[name]) ||\n        ((Regexp === re) && (re.match?(name) || re.match?(MAPPING[name])))\n    end",
        "comment": "Compare #name and TZInfo identifier to a supplied regexp, returning +true+ if a match is found.",
        "label": "What",
        "id": "14566"
    },
    {
        "raw_code": "def create_commit\n        logger.info(\"Creating master_report.json update commit\")\n        runtime_report = knapsack_reporter.create_merged_runtime_report.sort.to_h\n\n        api_request(:post, \"repository/commits\", {\n          branch: UPDATE_BRANCH_NAME,\n          commit_message: \"Update master_report.json for E2E tests\",\n          actions: [\n            {\n              action: \"update\",\n              file_path: File.join(\"qa\", Support::KnapsackReport::RUNTIME_REPORT),\n              content: \"#{JSON.pretty_generate(runtime_report)}\\n\"\n            },\n            {\n              action: \"update\",\n              file_path: File.join(\"qa\", Support::KnapsackReport::FALLBACK_REPORT),\n              content: \"#{JSON.pretty_generate(knapsack_reporter.create_knapsack_report(runtime_report).sort.to_h)}\\n\"\n            }\n          ]\n        })\n      end",
        "comment": "Create update commit for knapsack report  @return [void]",
        "label": "What",
        "id": "4712"
    },
    {
        "raw_code": "def accessible?\n      open_authorized_keys_file('r') { true }\n    rescue Errno::ENOENT, Errno::EACCES\n      false\n    end",
        "comment": "Checks if the file is accessible or not  @return [Boolean]",
        "label": "What",
        "id": "1684"
    },
    {
        "raw_code": "def resumed?\n        @resumed\n      end",
        "comment": "Has this step been resumed from a previous job execution?",
        "label": "What",
        "id": "12152"
    },
    {
        "raw_code": "def strong_memoize(name)\n        key = ivar(name)\n\n        if instance_variable_defined?(key)\n          instance_variable_get(key)\n        else\n          instance_variable_set(key, yield)\n        end",
        "comment": "Instead of writing patterns like this:  def trigger_from_token return @trigger if defined?(@trigger)  @trigger = Ci::Trigger.find_by_token(params[:token].to_s) end  We could write it like:  include Gitlab::Utils::StrongMemoize  def trigger_from_token Ci::Trigger.find_by_token(params[:token].to_s) end strong_memoize_attr :trigger_from_token  def enabled? Feature.enabled?(:some_feature) end strong_memoize_attr :enabled? ",
        "label": "What",
        "id": "1236"
    },
    {
        "raw_code": "def deliver_now\n      processed_mailer.handle_exceptions do\n        processed_mailer.run_callbacks(:deliver) do\n          message.deliver\n        end",
        "comment": "Delivers an email:  Notifier.welcome(User.first).deliver_now ",
        "label": "What",
        "id": "11148"
    },
    {
        "raw_code": "def _NormalChar\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n\n      _save2 = self.pos\n      while true # choice\n        _tmp = _SpecialChar()\n        break if _tmp\n        self.pos = _save2\n        _tmp = _Spacechar()\n        break if _tmp\n        self.pos = _save2\n        _tmp = _Newline()\n        break if _tmp\n        self.pos = _save2\n        break\n      end # end choice\n\n      _tmp = _tmp ? nil : true\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "NormalChar = !(@SpecialChar | @Spacechar | @Newline) .",
        "label": "What",
        "id": "15802"
    },
    {
        "raw_code": "def ff_yaml_for_file(change)\n          return unless %r{/feature_flags/.*\\.yml}.match?(change[:path])\n\n          if change[:deleted_file]\n            return { name: change[:path].split(\"/\").last.gsub(/\\.(yml|yaml)/, \"\"), deleted: true }\n          end",
        "comment": "Loads the YAML feature flag definition based on changed files in merge requests. The definition is loaded from the definition file itself.  @param [Hash] change mr file change @return [Hash] a hash containing the YAML data for the feature flag definition",
        "label": "What",
        "id": "4828"
    },
    {
        "raw_code": "def x\n        end",
        "comment": "steep:ignore",
        "label": "What",
        "id": "10868"
    },
    {
        "raw_code": "def down\n    add_concurrent_foreign_key :alert_management_alerts, TABLE_NAME,\n      column: :prometheus_alert_id,\n      name: ALERTS_FK_NAME\n\n    add_concurrent_foreign_key TABLE_NAME, :environments,\n      column: :environment_id,\n      name: ENVIRONMENTS_FK_NAME\n\n    add_concurrent_foreign_key TABLE_NAME, :prometheus_metrics,\n      column: :prometheus_metric_id,\n      name: METRICS_FK_NAME\n\n    add_concurrent_foreign_key TABLE_NAME, :projects,\n      column: :project_id,\n      name: PROJECTS_FK_NAME\n  end",
        "comment": "Original SQL:  ALTER TABLE ONLY alert_management_alerts ADD CONSTRAINT fk_51ab4b6089 FOREIGN KEY (prometheus_alert_id) REFERENCES prometheus_alerts(id) ON DELETE CASCADE;  ALTER TABLE ONLY prometheus_alerts ADD CONSTRAINT fk_rails_6d9b283465 FOREIGN KEY (environment_id) REFERENCES environments(id) ON DELETE CASCADE;  ALTER TABLE ONLY prometheus_alerts ADD CONSTRAINT fk_rails_e6351447ec FOREIGN KEY (prometheus_metric_id) REFERENCES prometheus_metrics(id) ON DELETE CASCADE;  ALTER TABLE ONLY prometheus_alerts ADD CONSTRAINT fk_rails_f0e8db86aa FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE; ",
        "label": "What",
        "id": "4928"
    },
    {
        "raw_code": "def self.mobilize_cops(cop_classes, config, options = {})\n        cop_classes = Registry.new(cop_classes.to_a, options) unless cop_classes.is_a?(Registry)\n\n        cop_classes.map do |cop_class|\n          cop_class.new(config, options)\n        end",
        "comment": "@return [Array<Cop::Base>]",
        "label": "What",
        "id": "10297"
    },
    {
        "raw_code": "def find_group(id, organization: nil)\n      collection = organization.present? ? Group.in_organization(organization) : Group.all\n\n      if INTEGER_ID_REGEX.match?(id.to_s)\n        collection.find_by(id: id)\n      else\n        collection.find_by_full_path(id)\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3775"
    },
    {
        "raw_code": "def self.name\n                'Gitlab::TestUsageWorker'\n              end",
        "comment": "`include ApplicationWorker` raises errors for unnamed classes",
        "label": "What",
        "id": "8289"
    },
    {
        "raw_code": "def self.action_snapshot_save\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use Call, Created do |env, b2|\n            if env[:result]\n              b2.use SnapshotSave\n            else\n              b2.use MessageNotCreated\n            end",
        "comment": "This is the action that is primarily responsible for saving a snapshot",
        "label": "What",
        "id": "9540"
    },
    {
        "raw_code": "def import_pull_requests\n        fetch_resources(:pull_requests, repo, state: :all, sort: :created, direction: :asc, per_page: 100) do |prs|\n          prs.each do |raw|\n            raw = raw.to_h\n            gh_pull_request = PullRequestFormatter.new(project, raw, client, source_user_mapper)\n\n            next unless gh_pull_request.valid?\n\n            begin\n              restore_source_branch(gh_pull_request) unless gh_pull_request.source_branch_exists?\n              restore_target_branch(gh_pull_request) unless gh_pull_request.target_branch_exists?\n\n              merge_request = gh_pull_request.create!\n\n              # Gitea doesn't return PR in the Issue API endpoint, so labels must be assigned at this stage\n              apply_labels(merge_request, raw) if project.gitea_import?\n            rescue StandardError => e\n              errors << {\n                type: :pull_request,\n                url: Gitlab::UrlSanitizer.sanitize(gh_pull_request.url),\n                errors: e.message\n              }\n            ensure\n              clean_up_restored_branches(gh_pull_request)\n            end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "1770"
    },
    {
        "raw_code": "def log(level, message)\n          QA::Runtime::Logger.public_send(level, \"[Allure]: #{message}\")\n        end",
        "comment": "Print log message  @param [Symbol] level @param [String] message @return [void]",
        "label": "What",
        "id": "4601"
    },
    {
        "raw_code": "def open(tmpdir: nil, &block)\n    service.open(\n      key,\n      checksum: checksum,\n      verify: !composed,\n      name: [ \"ActiveStorage-#{id}-\", filename.extension_with_delimiter ],\n      tmpdir: tmpdir,\n      &block\n    )\n  end",
        "comment": "Downloads the blob to a tempfile on disk. Yields the tempfile.  The tempfile's name is prefixed with +ActiveStorage-+ and the blob's ID. Its extension matches that of the blob.  By default, the tempfile is created in <tt>Dir.tmpdir</tt>. Pass +tmpdir:+ to create it in a different directory:  blob.open(tmpdir: \"/path/to/tmp\") do |file| # ... end  The tempfile is automatically closed and unlinked after the given block is executed.  Raises ActiveStorage::IntegrityError if the downloaded data does not match the blob's checksum.",
        "label": "What",
        "id": "13619"
    },
    {
        "raw_code": "def retry_on(*exceptions, wait: 3.seconds, attempts: 5, queue: nil, priority: nil, jitter: JITTER_DEFAULT, report: false)\n        rescue_from(*exceptions) do |error|\n          executions = executions_for(exceptions)\n          if attempts == :unlimited || executions < attempts\n            ActiveSupport.error_reporter.report(error, source: \"application.active_job\") if report\n            retry_job wait: determine_delay(seconds_or_duration_or_algorithm: wait, executions: executions, jitter: jitter), queue: queue, priority: priority, error: error\n          else\n            if block_given?\n              instrument :retry_stopped, error: error do\n                yield self, error\n              end",
        "comment": "Catch the exception and reschedule job for re-execution after so many seconds, for a specific number of attempts. If the exception keeps getting raised beyond the specified number of attempts, the exception is allowed to bubble up to the underlying queuing system, which may have its own retry mechanism or place it in a holding queue for inspection.  You can also pass a block that'll be invoked if the retry attempts fail for custom logic rather than letting the exception bubble up. This block is yielded with the job instance as the first and the error instance as the second parameter.  +retry_on+ and +discard_on+ handlers are searched from bottom to top, and up the class hierarchy. The handler of the first class for which <tt>exception.is_a?(klass)</tt> holds true is the one invoked, if any.  ==== Options * <tt>:wait</tt> - Re-enqueues the job with a delay specified either in seconds (default: 3 seconds), as a computing proc that takes the number of executions so far as an argument, or as a symbol reference of <tt>:polynomially_longer</tt>, which applies the wait algorithm of <tt>((executions**4) + (Kernel.rand * (executions**4) * jitter)) + 2</tt> (first wait ~3s, then ~18s, then ~83s, etc) * <tt>:attempts</tt> - Enqueues the job the specified number of times (default: 5 attempts) or a symbol reference of <tt>:unlimited</tt> to retry the job until it succeeds. The number of attempts includes the original job execution. * <tt>:queue</tt> - Re-enqueues the job on a different queue * <tt>:priority</tt> - Re-enqueues the job with a different priority * <tt>:jitter</tt> - A random delay of wait time used when calculating backoff. The default is 15% (0.15) which represents the upper bound of possible wait time (expressed as a percentage) * <tt>:report</tt> - Errors will be reported to the Rails.error reporter before being retried  ==== Examples  class RemoteServiceJob < ActiveJob::Base retry_on CustomAppException # defaults to ~3s wait, 5 attempts retry_on AnotherCustomAppException, wait: ->(executions) { executions * 2 } retry_on CustomInfrastructureException, wait: 5.minutes, attempts: :unlimited  retry_on ActiveRecord::Deadlocked, wait: 5.seconds, attempts: 3 retry_on Net::OpenTimeout, Timeout::Error, wait: :polynomially_longer, attempts: 10 # retries at most 10 times for Net::OpenTimeout and Timeout::Error combined # To retry at most 10 times for each individual exception: # retry_on Net::OpenTimeout, wait: :polynomially_longer, attempts: 10 # retry_on Net::ReadTimeout, wait: 5.seconds, jitter: 0.30, attempts: 10 # retry_on Timeout::Error, wait: :polynomially_longer, attempts: 10  retry_on YetAnotherCustomAppException, report: true retry_on EvenWorseCustomAppException do |job, error| CustomErrorHandlingCode.handle(job, error) end  def perform(*args) # Might raise CustomAppException, AnotherCustomAppException, or YetAnotherCustomAppException for something domain specific # Might raise ActiveRecord::Deadlocked when a local db deadlock is detected # Might raise Net::OpenTimeout or Timeout::Error when the remote service is down end end",
        "label": "What",
        "id": "12121"
    },
    {
        "raw_code": "def lock_both_roots\n        parent_ids = [\n          parent_id_was || self.id,\n          parent_id || self.id\n        ].compact\n\n        roots = Gitlab::ObjectHierarchy\n          .new(Namespace.id_in(parent_ids))\n          .base_and_ancestors\n          .without_order\n          .top_level\n\n        Namespace.lock('FOR NO KEY UPDATE').select(:id).id_in(roots).order(id: :asc).load\n      end",
        "comment": "Lock the root of the hierarchy we just left, and lock the root of the hierarchy we just joined. In most cases the two hierarchies will be the same.",
        "label": "What",
        "id": "7187"
    },
    {
        "raw_code": "def update_server_url\n          return unless docker_hostname\n\n          Helpers::Spinner.spin(\"updating kind cluster server url\") do\n            cluster_name = \"kind-#{name}\"\n            server = execute_shell([\n              \"kubectl\", \"config\", \"view\",\n              \"-o\", \"jsonpath={.clusters[?(@.name == \\\"#{cluster_name}\\\")].cluster.server}\"\n            ])\n            uri = URI.parse(server).tap { |uri| uri.host = docker_hostname }\n            execute_shell(%W[kubectl config set-cluster #{cluster_name} --server=#{uri}])\n          end",
        "comment": "Update server url in kubeconfig for kubectl to work correctly with remote docker  @return [void]",
        "label": "What",
        "id": "4046"
    },
    {
        "raw_code": "def handle_regexp_TIDYLINK(target)\n    text = target.text\n\n    return text unless text =~ /\\{(.*?)\\}\\[(.*?)\\]/ or text =~ /(\\S+)\\[(.*?)\\]/\n\n    label = $1\n    url   = $2\n\n    if url =~ /^rdoc-label:foot/ then\n      handle_rdoc_link url\n    else\n      gen_url url, label\n    end",
        "comment": " Converts the RDoc markup tidylink into a Markdown.style link.",
        "label": "What",
        "id": "16387"
    },
    {
        "raw_code": "def close\n        api_put_to(api_put_path, state_event: \"close\")\n      end",
        "comment": "Close issue  @return [void]",
        "label": "What",
        "id": "4139"
    },
    {
        "raw_code": "def clone_disk(source, destination, disk_format, **opts)\n          execute(\"clonemedium\", source, destination, '--format', disk_format)\n        end",
        "comment": "@param [String] source @param [String] destination @param [String] disk_format",
        "label": "What",
        "id": "9607"
    },
    {
        "raw_code": "def sanitize_description(body, transform_urls)\n        description = body&.gsub(created_by_pattern, \"\")\n        return description unless transform_urls\n\n        description&.gsub(source_project_url, imported_project_url)\n      end",
        "comment": "Remove added postfixes and transform urls  Source urls need to be replaced with target urls for comparison to work  @param [String] body @param [Boolean] transform_urls @return [String]",
        "label": "What",
        "id": "4388"
    },
    {
        "raw_code": "def dom_class(record_or_class, prefix = nil)\n      singular = model_name_from_record_or_class(record_or_class).param_key\n      prefix ? \"#{prefix}#{JOIN}#{singular}\" : singular\n    end",
        "comment": "The DOM class convention is to use the singular form of an object or class.  dom_class(post)   # => \"post\" dom_class(Person) # => \"person\"  If you need to address multiple instances of the same class in the same view, you can prefix the dom_class:  dom_class(post, :edit)   # => \"edit_post\" dom_class(Person, :edit) # => \"edit_person\"",
        "label": "What",
        "id": "11740"
    },
    {
        "raw_code": "def present?(obj)\n        case obj\n        when String\n          !obj.strip.empty?\n        when Symbol\n          !obj.to_s.strip.empty?\n        when Array\n          !obj.compact.empty?\n        when Hash\n          !obj.empty?\n        when TrueClass, FalseClass\n          obj\n        when NilClass\n          false\n        when Object\n          true\n        end",
        "comment": "Determines if the given object is \"present\". A String is considered present if the stripped contents are not empty. An Array/Hash is considered present if they have a length of more than 1. \"true\" is always present and `false` and `nil` are always not present. Any other object is considered to be present.  @return [true, false]",
        "label": "What",
        "id": "9184"
    },
    {
        "raw_code": "def initialize(payload, console_messages)\n        @payload = payload\n        @console_messages = console_messages\n      end",
        "comment": "Example of payload:  { 'action' => 'geo_proxy_to_primary', 'data' => { 'api_endpoints' => %w{geo/proxy_git_ssh/info_refs_receive_pack geo/proxy_git_ssh/receive_pack}, 'gl_username' => user.username, 'primary_repo' => geo_primary_http_url_to_repo(container) } } ",
        "label": "What",
        "id": "2809"
    },
    {
        "raw_code": "def bar\n              ^^^^^^^ Missing method documentation comment.\n                puts 'baz'\n              end",
        "comment": "rubocop:disable Style/For",
        "label": "What",
        "id": "10895"
    },
    {
        "raw_code": "def self.check_schema!\n    return if connection.primary_key(table_name).present?\n\n    raise \"The `#{table_name}` table is missing a primary key constraint in the database schema\"\n  end",
        "comment": "Due to the frequency with which settings are accessed, it is likely that during a backup restore a running GitLab process will insert a new `application_settings` row before the constraints have been added to the table. This would add an extra row with ID 1 and prevent the primary key constraint from being added, which made ActiveRecord throw a IrreversibleOrderError anytime the settings were accessed (https://gitlab.com/gitlab-org/gitlab/-/issues/36405).  To prevent this from happening, we do a sanity check that the primary key constraint is present before inserting a new entry.",
        "label": "What",
        "id": "6925"
    },
    {
        "raw_code": "def namespace_only?\n          @namespace_only ||= false\n        end",
        "comment": "@return [Boolean] whether the handler should only be processed inside a namespace.",
        "label": "What",
        "id": "173"
    },
    {
        "raw_code": "def container_path?(path)\n      wiki_path?(path) ||\n        ProjectPathValidator.valid_path?(path) ||\n        path =~ Gitlab::PathRegex.full_snippets_repository_path_regex\n    end",
        "comment": "Check if the path matches any known repository containers.",
        "label": "What",
        "id": "3367"
    },
    {
        "raw_code": "def eager_load!\n      Rails.autoloaders.each(&:eager_load)\n    end",
        "comment": "Eager loads the application code.",
        "label": "What",
        "id": "14650"
    },
    {
        "raw_code": "def self.branch_requires_code_owner_approval?(project, branch_name)\n    false\n  end",
        "comment": "overridden in EE",
        "label": "What",
        "id": "6794"
    },
    {
        "raw_code": "def default( # rubocop:disable Metrics/ParameterLists\n      category: :primary,\n      variant: :default,\n      size: :medium,\n      type: :button,\n      disabled: false,\n      loading: false,\n      block: false,\n      label: false,\n      selected: false,\n      icon: nil,\n      text: \"Edit\"\n    )\n      render(Pajamas::ButtonComponent.new(\n        category: category,\n        variant: variant,\n        size: size,\n        type: type,\n        disabled: disabled,\n        loading: loading,\n        block: block,\n        label: label,\n        selected: selected,\n        icon: icon\n      )) do\n        text.presence\n      end",
        "comment": "Button ---- See its design reference [here](https://design.gitlab.com/components/button).  @param category select {{ Pajamas::ButtonComponent::CATEGORY_OPTIONS }} @param variant select {{ Pajamas::ButtonComponent::VARIANT_OPTIONS }} @param size select {{ Pajamas::ButtonComponent::SIZE_OPTIONS }} @param type select {{ Pajamas::ButtonComponent::TYPE_OPTIONS }} @param disabled toggle @param loading toggle @param block toggle @param label toggle @param selected toggle @param icon select [~, star-o, issue-closed, tanuki] @param text text",
        "label": "What",
        "id": "8212"
    },
    {
        "raw_code": "def code_owner_approval_required?\n      false\n    end",
        "comment": "overriden in EE",
        "label": "What",
        "id": "5899"
    },
    {
        "raw_code": "def test_match_same_paths\n          table = tt %w{\n            /articles/new(.:format)\n            /articles/new(.:format)\n          }\n\n          sim = Simulator.new table\n\n          memos = sim.memos \"/articles/new\"\n          assert_equal 2, memos.length\n        end",
        "comment": " Identical Routes may have different restrictions.",
        "label": "What",
        "id": "11676"
    },
    {
        "raw_code": "def set_public(repo, options = {})\n        # GitHub Api for setting private updated to use private attr, rather than public\n        update_repository repo, options.merge({ private: false })\n      end",
        "comment": "Unhide a private repository  @param repo [Integer, String, Hash, Repository] A GitHub repository @return [Sawyer::Resource] Updated repository info",
        "label": "What",
        "id": "15139"
    },
    {
        "raw_code": "def repository_issue_events(repo, options = {})\n        paginate \"#{Repository.path repo}/issues/events\", options\n      end",
        "comment": "Get all Issue Events for a given Repository  @param repo [Integer, String, Repository, Hash] A GitHub repository  @return [Array<Sawyer::Resource>] Array of all Issue Events for this Repository @see https://developer.github.com/v3/issues/events/#list-events-for-a-repository @see https://developer.github.com/v3/activity/events/#list-issue-events-for-a-repository @example Get all Issue Events for Octokit Octokit.repository_issue_events(\"octokit/octokit.rb\")",
        "label": "What",
        "id": "15239"
    },
    {
        "raw_code": "def table(table)\n      @ast.relation = table\n      self\n    end",
        "comment": " UPDATE +table+",
        "label": "What",
        "id": "13472"
    },
    {
        "raw_code": "def error(message, http_status = nil, status: :error, pass_back: {})\n    result = {\n      message: message,\n      status: status\n    }.reverse_merge(pass_back)\n\n    result[:http_status] = http_status if http_status\n    result\n  end",
        "comment": "Return a Hash with an `error` status  message     - Error message to include in the Hash http_status - Optional HTTP status code override (default: nil) pass_back   - Additional attributes to be included in the resulting Hash",
        "label": "What",
        "id": "5709"
    },
    {
        "raw_code": "def detect_lang_in_codeblock_attributes(pre_html_attrs, code_html_attrs)\n        detected = nil\n        detected ||= (/\\bdata-lang=\"(.+?)\"/ =~ code_html_attrs && $1)\n        detected ||= (/\\blang=\"(.+?)\"/ =~ pre_html_attrs && $1)\n        detected ||= (/\\bclass=\"(.+?)\"/ =~ code_html_attrs && $1)\n        detected\n      end",
        "comment": "Parses code block's HTML attributes in order to detect the programming language of what's enclosed in that code block.  @param [String, nil] pre_html_attrs HTML attribute list of +pre+ element @param [String, nil] code_html_attrs HTML attribute list of +code+ element @return [String, nil] detected programming language",
        "label": "What",
        "id": "424"
    },
    {
        "raw_code": "def save_cache\n    clean_cache_collection @cache[:ancestors]\n    clean_cache_collection @cache[:attributes]\n    clean_cache_collection @cache[:class_methods]\n    clean_cache_collection @cache[:instance_methods]\n\n    @cache[:modules].uniq!\n    @cache[:modules].sort!\n\n    @cache[:pages].uniq!\n    @cache[:pages].sort!\n\n    @cache[:encoding] = @encoding # this gets set twice due to assert_cache\n\n    @cache[:c_class_variables].merge!           @c_class_variables\n    @cache[:c_singleton_class_variables].merge! @c_singleton_class_variables\n\n    return if @dry_run\n\n    File.open cache_path, 'wb' do |io|\n      Marshal.dump @cache, io\n    end",
        "comment": " Writes the cache file for this store",
        "label": "What",
        "id": "15888"
    },
    {
        "raw_code": "def job_name\n          @job_name ||= ci_job_name&.gsub(%r{ \\d{1,2}/\\d{1,2}}, '')\n        end",
        "comment": "Base ci job name  @return [String]",
        "label": "What",
        "id": "4634"
    },
    {
        "raw_code": "def _BlockQuote\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_BlockQuoteRaw)\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "BlockQuote = BlockQuoteRaw:a { RDoc::Markup::BlockQuote.new(*a) }",
        "label": "What",
        "id": "15606"
    },
    {
        "raw_code": "def perform_inline(*args)\n        Setter.new(self, {}).perform_inline(*args)\n      end",
        "comment": "Inline execution of job's perform method after passing through Sidekiq.client_middleware and Sidekiq.server_middleware",
        "label": "What",
        "id": "5176"
    },
    {
        "raw_code": "def render_string\n        binding.eval(Erubi::Engine.new(template, trim: true).src)\n      end",
        "comment": "Renders a template, handling the template as a string, but otherwise acting the same way as {#render}.  @return [String]",
        "label": "What",
        "id": "9157"
    },
    {
        "raw_code": "def backup_tasks\n      @backup_tasks ||= {\n        Backup::Tasks::Database.id => Backup::Tasks::Database.new(progress: progress, options: options),\n        Backup::Tasks::Repositories.id => Backup::Tasks::Repositories.new(progress: progress, options: options,\n          server_side_callable: -> { backup_information[:repositories_server_side] }),\n        Backup::Tasks::Uploads.id => Backup::Tasks::Uploads.new(progress: progress, options: options),\n        Backup::Tasks::Builds.id => Backup::Tasks::Builds.new(progress: progress, options: options),\n        Backup::Tasks::Artifacts.id => Backup::Tasks::Artifacts.new(progress: progress, options: options),\n        Backup::Tasks::Pages.id => Backup::Tasks::Pages.new(progress: progress, options: options),\n        Backup::Tasks::Lfs.id => Backup::Tasks::Lfs.new(progress: progress, options: options),\n        Backup::Tasks::TerraformState.id => Backup::Tasks::TerraformState.new(progress: progress, options: options),\n        Backup::Tasks::Registry.id => Backup::Tasks::Registry.new(progress: progress, options: options),\n        Backup::Tasks::Packages.id => Backup::Tasks::Packages.new(progress: progress, options: options),\n        Backup::Tasks::CiSecureFiles.id => Backup::Tasks::CiSecureFiles.new(progress: progress, options: options),\n        Backup::Tasks::ExternalDiffs.id => Backup::Tasks::ExternalDiffs.new(progress: progress, options: options)\n      }.freeze\n    end",
        "comment": "@return [Hash<String, Backup::Tasks::Task>]",
        "label": "What",
        "id": "3631"
    },
    {
        "raw_code": "def load_plugins(plugins)\n        if !Vagrant.plugins_enabled?\n          @logger.warn(\"Plugin loading is disabled\")\n          return\n        end",
        "comment": "Loads the requested plugins into the Vagrant runtime  @param [Hash] plugins List of plugins to load @return [nil]",
        "label": "What",
        "id": "8961"
    },
    {
        "raw_code": "def self.default_specifications_dir\n          File.join(Gem.old_default_dir, \"specifications\", \"default\")\n        end",
        "comment": "https://github.com/Homebrew/homebrew-core/issues/40872#issuecomment-542092547 https://github.com/Homebrew/homebrew-core/pull/48329#issuecomment-584418161",
        "label": "What",
        "id": "48"
    },
    {
        "raw_code": "def admin_variable_with_default(type, var_name, default)\n          ENV[var_name].then do |value|\n            next value unless value.blank?\n\n            Logger.warn(\"Admin #{type} variable '#{var_name}' not set, using default value!\")\n            default\n          end",
        "comment": "Admin user related variable with default value  @param type [String] @param var_name [String] @param default [String] @return [String]",
        "label": "What",
        "id": "4501"
    },
    {
        "raw_code": "def new\n    @book = Book.new\n  end",
        "comment": "GET /books/new",
        "label": "What",
        "id": "10746"
    },
    {
        "raw_code": "def filter_assignees\n        return if params[:assignees].nil?\n\n        # Always take first assignee while multiple are not currently supported\n        params[:assignees] = Array(params[:assignees].first)\n\n        param_errors << _('Assignee has no permissions') if unauthorized_assignees?\n      end",
        "comment": "----- Assignee-related behavior ------",
        "label": "What",
        "id": "5682"
    },
    {
        "raw_code": "def _HtmlBlockPre\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenPre)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockPre = HtmlBlockOpenPre (HtmlBlockPre | !HtmlBlockClosePre .)* HtmlBlockClosePre",
        "label": "What",
        "id": "15685"
    },
    {
        "raw_code": "def self.execute_batch_counting(projects_relation)\n        # Call the count methods on every project, so the BatchLoader would load them all at\n        # once when the entities are rendered\n        projects_relation.each(&:open_issues_count)\n\n        super\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3807"
    },
    {
        "raw_code": "def link_file(filename, title = nil, anchor = nil)\n        if CodeObjects::ExtraFileObject === filename\n          file = filename\n        else\n          contents = File.file?(filename) ? nil : ''\n          file = CodeObjects::ExtraFileObject.new(filename, contents)\n        end",
        "comment": "(see BaseHelper#link_file)",
        "label": "What",
        "id": "403"
    },
    {
        "raw_code": "def method_call_with_parenthesized_arg?(argument)\n          return false unless argument.parent.parent&.send_type?\n\n          argument.children.first && argument.parent.parenthesized?\n        end",
        "comment": "Checks for an acceptable case of `foo.+(bar).baz`.",
        "label": "What",
        "id": "10572"
    },
    {
        "raw_code": "def test_user\n            return @test_user if defined?(@test_user)\n\n            if ldap_user_configured?\n              info(\"LDAP credentials configured, using LDAP user for test as main test user\")\n              return @test_user = ldap_user\n            elsif create_unique_test_user?\n              return @test_user = create_new_user\n            end",
        "comment": "Global test user used as a primary user for test execution  @return [QA::Resource::User]",
        "label": "What",
        "id": "4506"
    },
    {
        "raw_code": "def noop_pipeline\n          @noop_pipeline ||= File.read(File.join(project_root, \".gitlab\", \"ci\", \"overrides\", \"skip.yml\"))\n        end",
        "comment": "Content of noop pipeline definition file  @return [String]",
        "label": "What",
        "id": "4773"
    },
    {
        "raw_code": "def reload(options = nil)\n      self.class.connection_pool.clear_query_cache\n\n      fresh_object = if apply_scoping?(options)\n        _find_record((options || {}).merge(all_queries: true))\n      else\n        self.class.unscoped { _find_record(options) }\n      end",
        "comment": "Reloads the record from the database.  This method finds the record by its primary key (which could be assigned manually) and modifies the receiver in-place:  account = Account.new # => #<Account id: nil, email: nil> account.id = 1 account.reload # Account Load (1.2ms)  SELECT \"accounts\".* FROM \"accounts\" WHERE \"accounts\".\"id\" = $1 LIMIT 1  [[\"id\", 1]] # => #<Account id: 1, email: 'account@example.com'>  Attributes are reloaded from the database, and caches busted, in particular the associations cache and the QueryCache.  If the record no longer exists in the database ActiveRecord::RecordNotFound is raised. Otherwise, in addition to the in-place modification the method returns +self+ for convenience.  The optional <tt>:lock</tt> flag option allows you to lock the reloaded record:  reload(lock: true) # reload with pessimistic locking  Reloading is commonly used in test suites to test something is actually written to the database, or when some action modifies the corresponding row in the database but not the object in memory:  assert account.deposit!(25) assert_equal 25, account.credit        # check it is updated in memory assert_equal 25, account.reload.credit # check it is also persisted  Another common use case is optimistic locking handling:  def with_optimistic_retry begin yield rescue ActiveRecord::StaleObjectError begin # Reload lock_version in particular. reload rescue ActiveRecord::RecordNotFound # If the record is gone there is nothing to do. else retry end end end ",
        "label": "What",
        "id": "12578"
    },
    {
        "raw_code": "def validate_configured_sources!\n      Gem.sources.each_source do |src|\n        begin\n          src.load_specs(:released)\n        rescue Gem::Exception => source_error\n          if ENV[\"VAGRANT_ALLOW_PLUGIN_SOURCE_ERRORS\"]\n            @logger.warn(\"Failed to load configured plugin source: #{src}!\")\n            @logger.warn(\"Error received attempting to load source (#{src}): #{source_error}\")\n            @logger.warn(\"Ignoring plugin source load failure due user request via env variable\")\n          else\n            @logger.error(\"Failed to load configured plugin source `#{src}`: #{source_error}\")\n            raise Vagrant::Errors::PluginSourceError,\n              source: src.uri.to_s,\n              error_msg: source_error.message\n          end",
        "comment": "Iterates each configured RubyGem source to validate that it is properly available. If source is unavailable an exception is raised.",
        "label": "What",
        "id": "8906"
    },
    {
        "raw_code": "def texts(element)\n        texts = []\n        child_nodes = element.child_nodes\n        (0...child_nodes.length).each do |i|\n          item = child_nodes.item(i)\n          if item.node_type == Node::TEXT_NODE\n            texts << item.get_data\n          end",
        "comment": "Determines if a document element has text content  element:: XML element to be checked.",
        "label": "What",
        "id": "14586"
    },
    {
        "raw_code": "def size\n        if Feature.enabled?(:use_repository_info_for_repository_size)\n          repository_info_size_megabytes\n        else\n          kilobytes = gitaly_repository_client.repository_size\n          (kilobytes.to_f / 1024).round(2)\n        end",
        "comment": "Return repo size in megabytes",
        "label": "What",
        "id": "2626"
    },
    {
        "raw_code": "def admin_user\n            return @admin_user if defined?(@admin_user)\n            return @admin_user = nil if Env.no_admin_environment?\n\n            info(\"Initializing admin user using predefined credentials\")\n            @admin_user = init_user(\n              username: admin_username,\n              password: admin_password,\n              api_client: @admin_api_client,\n              admin: true\n            )\n          end",
        "comment": "Global admin user  @return [QA::Resource::User]",
        "label": "What",
        "id": "4505"
    },
    {
        "raw_code": "def find_by(...)\n    if_authorized execute.reorder(nil).find_by(...)\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7996"
    },
    {
        "raw_code": "def build_event_channels\n        event_channel_names.map do |channel_field|\n          Field.new(\n            name: channel_field,\n            type: :text,\n            placeholder: default_channel_placeholder,\n            integration_class: self\n          )\n        end",
        "comment": "rubocop:enable Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "7485"
    },
    {
        "raw_code": "def installation(id, options = {})\n        get \"app/installations/#{id}\", options\n      end",
        "comment": "Get a single installation  @param id [Integer] Installation id  @see https://docs.github.com/en/rest/apps/apps#get-an-installation-for-the-authenticated-app  @return [Sawyer::Resource] Installation information",
        "label": "What",
        "id": "15013"
    },
    {
        "raw_code": "def retry_args\n              @retry_args ||= { sleep_interval: 0.5 }\n            end",
        "comment": "Custom retry arguments  @return [Hash]",
        "label": "What",
        "id": "4591"
    },
    {
        "raw_code": "def attribute_change(attr_name)\n        mutations_from_database.change_to_attribute(attr_name.to_s)\n      end",
        "comment": "Dispatch target for <tt>*_change</tt> attribute methods.",
        "label": "What",
        "id": "12209"
    },
    {
        "raw_code": "def initialize(review, project, client)\n            @review = review\n            @project = project\n            @client = client\n            @merge_request = project.merge_requests.find_by_iid(review.merge_request_iid)\n            @user_finder = GithubImport::UserFinder.new(project, client)\n          end",
        "comment": "review - An instance of `Gitlab::GithubImport::Representation::PullRequestReview` project - An instance of `Project` client - An instance of `Gitlab::GithubImport::Client`",
        "label": "What",
        "id": "2231"
    },
    {
        "raw_code": "def config_file(*paths)\n      Dir.chdir(root || '.') do\n        paths.each do |pattern|\n          Dir.glob(pattern) do |file|\n            raise UnsupportedConfigType unless ['.yml', '.yaml', '.erb'].include?(File.extname(file))\n\n            logger.info \"loading config file '#{file}'\" if logging? && respond_to?(:logger)\n            document = ERB.new(File.read(file)).result\n            yaml = YAML.respond_to?(:unsafe_load) ? YAML.unsafe_load(document) : YAML.load(document)\n            config = config_for_env(yaml)\n            config.each_pair { |key, value| set(key, value) }\n          end",
        "comment": "Loads the configuration from the YAML files whose +paths+ are passed as arguments, filtering the settings for the current environment.  Note that these +paths+ can actually be globs.",
        "label": "What",
        "id": "8684"
    },
    {
        "raw_code": "def remove_unique_constraint(table_name, column_name = nil, **options)\n          unique_name_to_delete = unique_constraint_for!(table_name, column: column_name, **options).name\n\n          remove_constraint(table_name, unique_name_to_delete)\n        end",
        "comment": "Removes the given unique constraint from the table.  remove_unique_constraint :sections, name: \"unique_position\"  The +column_name+ parameter will be ignored if present. It can be helpful to provide this in a migration's +change+ method so it can be reverted. In that case, +column_name+ will be used by #add_unique_constraint.",
        "label": "What",
        "id": "13270"
    },
    {
        "raw_code": "def create\n          log(\"Creating CNG deployment '#{name}'\", :info, bright: true)\n          chart_reference = run_pre_deploy_setup\n          run_deploy(chart_reference)\n          run_post_deploy_setup\n        # Exit on error to not duplicate error messages and exit cleanly when kubectl or helm related errors are raised\n        rescue Kubectl::Client::Error, Helm::Client::Error\n          exit(1)\n        end",
        "comment": "Perform deployment with all the additional setup  @return [void]",
        "label": "What",
        "id": "3997"
    },
    {
        "raw_code": "def self.run(args)\n        migrator = new(args)\n\n        migrator.migrate_data\n      end",
        "comment": "Run Influx Migrator  @param [Hash] the arguments hash @return [void]",
        "label": "What",
        "id": "4723"
    },
    {
        "raw_code": "def after_block_hook(user)\n      custom_attribute = {\n        user_id: user.id,\n        key: UserCustomAttribute::BLOCKED_BY,\n        value: \"#{current_user.username}/#{current_user.id}+#{Time.current}\"\n      }\n      UserCustomAttribute.upsert_custom_attributes([custom_attribute])\n    end",
        "comment": "overridden by EE module",
        "label": "What",
        "id": "6001"
    },
    {
        "raw_code": "def define_instance_internal_id_methods(scope, column, init)\n      define_method(\"ensure_#{scope}_#{column}!\") do\n        scope_value = internal_id_read_scope(scope)\n        value = read_attribute(column)\n        return value unless scope_value\n\n        if value.nil?\n          # We don't have a value yet and use a InternalId record to generate\n          # the next value.\n          value = InternalId.generate_next(\n            self,\n            internal_id_scope_attrs(scope),\n            internal_id_scope_usage,\n            init)\n          write_attribute(column, value)\n\n          @internal_id_set_manually = false\n        end",
        "comment": "Defines instance methods: - ensure_{scope}_{column}! - track_{scope}_{column}! - reset_{scope}_{column} - {column}=",
        "label": "What",
        "id": "7297"
    },
    {
        "raw_code": "def delete_release_asset(asset_url, options = {})\n        boolean_from_response(:delete, asset_url, options)\n      end",
        "comment": "Delete a release asset  @param asset_url [String] URL for the asset as returned from .release_assets @return [Boolean] Success or failure @see https://developer.github.com/v3/repos/releases/#delete-a-release-asset",
        "label": "What",
        "id": "15211"
    },
    {
        "raw_code": "def accept_heading(heading)\n    @res << heading unless suppressed? heading\n  end",
        "comment": " Adds +heading+ to the table of contents",
        "label": "What",
        "id": "16355"
    },
    {
        "raw_code": "def comparable\n        reload! if api_response.nil?\n\n        api_resource.except(\n          :id,\n          :web_url,\n          :project_id,\n          :source_project_id,\n          :target_project_id,\n          :detailed_merge_status,\n          # we consider mr to still be the same even if users changed\n          :author,\n          :reviewers,\n          :assignees,\n          # these can differ depending on user fetching mr\n          :user,\n          :subscribed,\n          :first_contribution\n        ).merge({ references: api_resource[:references].except(:full) })\n      end",
        "comment": "Return subset of fields for comparing merge requests  @return [Hash]",
        "label": "What",
        "id": "4168"
    },
    {
        "raw_code": "def self.merge_request_for_sha(project_id, sha)\n      MergeRequest\n        .joins(:generated_ref_commits)\n        .where(\n          merge_requests: { target_project_id: project_id },\n          generated_ref_commits: {\n            project_id: project_id,\n            commit_sha: sha\n          }\n        )\n        .limit(1)\n    end",
        "comment": "Since the MergeRequestsFinder expects us to provide a relation instead of a single object, we are returning here a relation, but limited to 1 since we only care about the merge request with the given commit sha and project id, which will be unique.",
        "label": "What",
        "id": "7198"
    },
    {
        "raw_code": "def attach_disk(disk_file_path,  **opts)\n        execute(:attach_disk_drive, VmId: @vm_id, Path: disk_file_path, ControllerType: opts[:ControllerType],\n                ControllerNumber: opts[:ControllerNumber], ControllerLocation: opts[:ControllerLocation])\n      end",
        "comment": " Disk Driver methods  @param [String] controller_type @param [String] controller_number @param [String] controller_location @param [Hash] opts @option opts [String] :ControllerType @option opts [String] :ControllerNumber @option opts [String] :ControllerLocation",
        "label": "What",
        "id": "9687"
    },
    {
        "raw_code": "def semantic_alignment_base(node, rhs)\n          return unless rhs.source.start_with?('.', '&.')\n\n          node = semantic_alignment_node(node)\n          return unless node&.loc&.selector && node.loc.dot\n\n          node.loc.dot.join(node.loc.selector)\n        end",
        "comment": "a.b .c",
        "label": "What",
        "id": "10386"
    },
    {
        "raw_code": "def take!\n      take || raise_record_not_found_exception!\n    end",
        "comment": "Same as #take but raises ActiveRecord::RecordNotFound if no record is found. Note that #take! accepts no arguments.",
        "label": "What",
        "id": "13366"
    },
    {
        "raw_code": "def after_run(_)\n          FileUtils.rm_rf(tmpdir)\n        end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3617"
    },
    {
        "raw_code": "def enrich!\n    # A container is needed in order to fetch data from gitaly. Containers\n    # can be absent from commits in certain rare situations (like when\n    # viewing a MR of a deleted fork). In these cases, assume that the\n    # enriched data is not needed.\n    return self if container.blank? || fully_enriched?\n\n    # Batch load full Commits from the repository\n    # and map to a Hash of id => Commit\n    replacements = unenriched.each_with_object({}) do |c, result|\n      result[c.id] = Commit.lazy(container, c.id)\n    end.compact\n\n    # Replace the commits, keeping the same order\n    @commits = @commits.map do |original_commit|\n      # Return the original instance: if it didn't need to be batchloaded, it was\n      # already enriched.\n      batch_loaded_commit = replacements.fetch(original_commit.id, original_commit)\n\n      # If batch loading the commit failed, fall back to the original commit.\n      # We need to explicitly check `.nil?` since otherwise a `BatchLoader` instance\n      # that looks like `nil` is returned.\n      batch_loaded_commit.nil? ? original_commit : batch_loaded_commit\n    end",
        "comment": "Batch load any commits that are not backed by full gitaly data, and replace them in the collection.",
        "label": "What",
        "id": "6702"
    },
    {
        "raw_code": "def set_note_author\n          old_author_id = @original_user['author_id']\n          author = @relation_hash.delete('author')\n\n          unless @members_mapper.include?(old_author_id)\n            @relation_hash['note'] = \"%{note}\\n\\n %{missing_author_note}\" % {\n              note: @relation_hash['note'].presence || '*Blank note*',\n              missing_author_note: missing_author_note(@relation_hash['updated_at'], author['name'])\n            }\n          end",
        "comment": "Sets the author for a note. If the user importing the project has admin access, an actual mapping with new project members will be used. Otherwise, a note stating the original author name is left.",
        "label": "What",
        "id": "2832"
    },
    {
        "raw_code": "def example_group_started(notification)\n        order = notification.group.metadata[:order]\n\n        output.puts \"  # order #{order}\" if order\n      end",
        "comment": "See https://github.com/rspec/rspec-core/blob/v3.11.0/lib/rspec/core/formatters/documentation_formatter.rb#L24-L29",
        "label": "What",
        "id": "8303"
    },
    {
        "raw_code": "def initialize(\n      message:, id:, theme:, dismissable:, expire_date:, cookie_key:, dismissal_path: nil,\n      button_testid: nil, banner: nil)\n      @message = message\n      @id = id\n      @theme = theme\n      @dismissable = dismissable\n      @expire_date = expire_date\n      @cookie_key = cookie_key\n      @dismissal_path = dismissal_path\n      @button_testid = button_testid\n      @banner = banner\n    end",
        "comment": "@param [String] message @param [String] id @param [String] theme @param [Boolean] dismissable @param [String] expire_date @param [String] cookie_key @param [String] dismissal_path @param [String] button_testid",
        "label": "What",
        "id": "5392"
    },
    {
        "raw_code": "def validates_exclusion_of(*attr_names)\n        validates_with ExclusionValidator, _merge_attributes(attr_names)\n      end",
        "comment": "Validates that the value of the specified attribute is not in a particular enumerable object.  class Person < ActiveRecord::Base validates_exclusion_of :username, in: %w( admin superuser ), message: \"You don't belong here\" validates_exclusion_of :age, in: 30..60, message: 'This site is only for under 30 and over 60' validates_exclusion_of :format, in: %w( mov avi ), message: \"extension %{value} is not allowed\" validates_exclusion_of :password, in: ->(person) { [person.username, person.first_name] }, message: 'should not be the same as your username or first name' validates_exclusion_of :karma, in: :reserved_karmas end  Configuration options: * <tt>:in</tt> - An enumerable object of items that the value shouldn't be part of. This can be supplied as a proc, lambda, or symbol which returns an enumerable. If the enumerable is a numerical, time, or datetime range the test is performed with <tt>Range#cover?</tt>, otherwise with <tt>include?</tt>. When using a proc or lambda the instance under validation is passed as an argument. * <tt>:within</tt> - A synonym(or alias) for <tt>:in</tt> <tt>Range#cover?</tt>, otherwise with <tt>include?</tt>. * <tt>:message</tt> - Specifies a custom error message (default is: \"is reserved\").  There is also a list of default options supported by every validator: +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+. See ActiveModel::Validations::ClassMethods#validates for more information.",
        "label": "What",
        "id": "12312"
    },
    {
        "raw_code": "def check_for_spam?(*)\n    spammable_attribute_changed?\n  end",
        "comment": "Override in included class if further checks are necessary",
        "label": "What",
        "id": "7248"
    },
    {
        "raw_code": "def validate_url_with_proxy!(\n          url,\n          schemes:,\n          ports: [],\n          allow_localhost: false,\n          allow_local_network: true,\n          extra_allowed_uris: [],\n          ascii_only: false,\n          enforce_user: false,\n          enforce_sanitization: false,\n          deny_all_requests_except_allowed: false,\n          dns_rebind_protection: true,\n          outbound_local_requests_allowlist: []\n        )\n          # rubocop:enable Metrics/ParameterLists\n\n          return Result.new(nil, nil, true) if url.nil?\n\n          raise ArgumentError, 'The schemes is a required argument' if schemes.blank?\n\n          # Param url can be a string, URI or Addressable::URI\n          uri = parse_url(url)\n\n          validate_uri(\n            uri: uri,\n            schemes: schemes,\n            ports: ports,\n            enforce_sanitization: enforce_sanitization,\n            enforce_user: enforce_user,\n            ascii_only: ascii_only\n          )\n\n          unless deny_all_requests_except_allowed || dns_rebind_protection || !allow_local_network || !allow_localhost\n            return Result.new(uri, nil, true)\n          end",
        "comment": "Validates the given url according to the constraints specified by arguments.  ports - Raises error if the given URL port is not between given ports. allow_localhost - Raises error if URL resolves to a localhost IP address and argument is false. allow_local_network - Raises error if URL resolves to a link-local address and argument is false. extra_allowed_uris - Array of URI objects that are allowed in addition to hostname and IP constraints. This parameter is passed in this class when making the HTTP request. ascii_only - Raises error if URL has unicode characters and argument is true. enforce_user - Raises error if URL user doesn't start with alphanumeric characters and argument is true. enforce_sanitization - Raises error if URL includes any HTML/CSS/JS tags and argument is true. deny_all_requests_except_allowed - Raises error if URL is not in the allow list and argument is true. Can be Boolean or Proc. Defaults to instance app setting. dns_rebind_protection - Enforce DNS-rebinding attack protection. outbound_local_requests_allowlist - A list of trusted domains or IP addresses to which local requests are allowed when local requests for webhooks and integrations are disabled. This parameter is static and comes from the `outbound_local_requests_whitelist` application setting. # rubocop:disable Naming/InclusiveLanguage  Returns a Result object. rubocop:disable Metrics/ParameterLists",
        "label": "What",
        "id": "1199"
    },
    {
        "raw_code": "def self.convert_timestamp_to_time(timestamp)\n            timestamp ? Time.at(timestamp / 1000, (timestamp % 1000) * 1000) : Time.at(0)\n          end",
        "comment": "Converts milliseconds since epoch timestamp into a time object.",
        "label": "What",
        "id": "13335"
    },
    {
        "raw_code": "def stderr\n            @result&.stderr || ''\n          end",
        "comment": "Return the captured error content  @return [String] stdout content",
        "label": "What",
        "id": "1061"
    },
    {
        "raw_code": "def execute\n      start_checking(component)\n\n      @checks.each do |check|\n        run_check(check)\n      end",
        "comment": "Executes defined checks in the specified order and outputs confirmation or error information",
        "label": "What",
        "id": "3699"
    },
    {
        "raw_code": "def activate_solution(solution)\n      retried = false\n      begin\n        @logger.debug(\"Activating solution set: #{solution.map(&:full_name)}\")\n        solution.each do |activation_request|\n          unless activation_request.full_spec.activated?\n            @logger.debug(\"Activating gem #{activation_request.full_spec.full_name}\")\n            activation_request.full_spec.activate\n            if(defined?(::Bundler))\n              @logger.debug(\"Marking gem #{activation_request.full_spec.full_name} loaded within Bundler.\")\n              ::Bundler.rubygems.mark_loaded activation_request.full_spec\n            end",
        "comment": "Activate a given solution",
        "label": "What",
        "id": "8909"
    },
    {
        "raw_code": "def render(options = {})\n          options = set_default_options(options)\n          mod = template(options.template, options.type, options.format)\n\n          if options.serializer && options.serialize != false\n            with_serializer(options.object, options.serializer) { mod.run(options) }\n          else\n            mod.run(options)\n          end",
        "comment": "Renders a template on a {CodeObjects::Base code object} using a set of default (overridable) options. Either the +:object+ or +:type+ keys must be provided.  If a +:serializer+ key is provided and +:serialize+ is not set to false, the rendered contents will be serialized through the {Serializers::Base} object. See {with_serializer}.  @example Renders an object with html formatting Engine.render(:format => :html, :object => obj) @example Renders without an object Engine.render(:type => :fulldoc, :otheropts => somevalue) @param [Hash] options the options hash @option options [Symbol] :format (:text) the default format @option options [Symbol] :type (nil) the :object's type. @option options [Symbol] :template (:default) the default template @return [String] the rendered template",
        "label": "What",
        "id": "373"
    },
    {
        "raw_code": "def initialize(plugin_file:, solution_file: nil)\n        @logger = Log4r::Logger.new(\"vagrant::bundler::solution_file\")\n        @plugin_file = Pathname.new(plugin_file.to_s)\n        if solution_file\n          @solution_file = Pathname.new(solution_file.to_s)\n        else\n          @solution_file = Pathname.new(@plugin_file.to_s + \".sol\")\n        end",
        "comment": "@param [Pathname] plugin_file Path to plugin file @param [Pathname] solution_file Custom path to solution file",
        "label": "What",
        "id": "8885"
    },
    {
        "raw_code": "def expect_no_corrections\n        raise '`expect_no_corrections` must follow `expect_offense`' unless @processed_source\n\n        return if @last_corrector.empty?\n\n        # This is just here for a pretty diff if the source actually got changed\n        new_source = @last_corrector.rewrite\n        expect(new_source).to eq(@processed_source.buffer.source)\n\n        # There is an infinite loop if a corrector is present that did not make\n        # any changes. It will cause the same offense/correction on the next loop.\n        raise RuboCop::Runner::InfiniteCorrectionLoop.new(@processed_source.path, [@offenses])\n      end",
        "comment": "rubocop:enable Metrics/AbcSize, Metrics/MethodLength, Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "10710"
    },
    {
        "raw_code": "def return_type_from_tag(member_tag)\n    member_tag && member_tag.types ? member_tag.types : \"Object\"\n  end",
        "comment": "Gets the return type for the member in a nicely formatted string. Used to be injected into auto-generated docstrings.  @param [Tags::Tag] member_tag the tag object to check for types @return [String] the user-declared type of the struct member, or [Object] if the user did not define a type for this member.",
        "label": "What",
        "id": "200"
    },
    {
        "raw_code": "def verify_issues_import\n        logger.info(\"== Verifying issue import ==\")\n        @issue_diff = verify_mrs_or_issues('issue')\n      end",
        "comment": "Verify imported issues and issue comments  @return [void]",
        "label": "What",
        "id": "4382"
    },
    {
        "raw_code": "def variables_attributes_for(variables)\n          variables.map do |variable|\n            variable.to_h.tap do |hash|\n              hash[:id] = GlobalID::Locator.locate(hash[:id]).id if hash[:id]\n\n              hash[:_destroy] = hash.delete(:destroy)\n            end",
        "comment": "This method transforms the GraphQL argument values for pipeline schedule variables into values that can be understood by ActiveRecord when performing a nested attributes collection update.",
        "label": "What",
        "id": "6161"
    },
    {
        "raw_code": "def upcase_first\n    ActiveSupport::Inflector.upcase_first(self)\n  end",
        "comment": "Converts the first character to uppercase.  'what a Lovely Day'.upcase_first # => \"What a Lovely Day\" 'w'.upcase_first                 # => \"W\" ''.upcase_first                  # => \"\"  See ActiveSupport::Inflector.upcase_first.",
        "label": "What",
        "id": "14376"
    },
    {
        "raw_code": "def subscribe(pattern = nil, callback = nil, &block)\n        notifier.subscribe(pattern, callback, monotonic: false, &block)\n      end",
        "comment": "Subscribe to a given event name with the passed +block+.  You can subscribe to events by passing a String to match exact event names, or by passing a Regexp to match all events that match a pattern.  If the block passed to the method only takes one argument, it will yield an +Event+ object to the block:  ActiveSupport::Notifications.subscribe(/render/) do |event| @event = event end  Otherwise the +block+ will receive five arguments with information about the event:  ActiveSupport::Notifications.subscribe('render') do |name, start, finish, id, payload| name    # => String, name of the event (such as 'render' from above) start   # => Time, when the instrumented block started execution finish  # => Time, when the instrumented block ended execution id      # => String, unique ID for the instrumenter that fired the event payload # => Hash, the payload end  Raises an error if invalid event name type is passed:  ActiveSupport::Notifications.subscribe(:render) {|event| ...} #=> ArgumentError (pattern must be specified as a String, Regexp or empty) ",
        "label": "What",
        "id": "13915"
    },
    {
        "raw_code": "def dependent_jobs\n      ordered_by_dag(\n        @pipeline.processables\n          .from_union(needs_dependent_jobs, stage_dependent_jobs)\n          .skipped\n          .ordered_by_stage\n          .preload(:needs)\n      )\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5782"
    },
    {
        "raw_code": "def add_source(source, options = {}, &block)\n        log :source, source\n\n        in_root do\n          if block\n            append_file_with_newline \"Gemfile\", \"\\nsource #{quote(source)} do\", force: true\n            with_indentation(&block)\n            append_file_with_newline \"Gemfile\", \"end\", force: true\n          else\n            prepend_file \"Gemfile\", \"source #{quote(source)}\\n\", verbose: false\n          end",
        "comment": "Add the given source to +Gemfile+  If block is given, gem entries in block are wrapped into the source group.  add_source \"http://gems.github.com/\"  add_source \"http://gems.github.com/\" do gem \"rspec-rails\" end",
        "label": "What",
        "id": "14729"
    },
    {
        "raw_code": "def issues\n    respond_to do |format|\n      format.html\n      format.atom do\n        @issues = issuables_collection\n                  .non_archived\n                  .page(params[:page])\n\n        @issuable_meta_data = Gitlab::IssuableMetadata.new(current_user, @issues).data\n\n        render layout: 'xml'\n      end",
        "comment": "rubocop:disable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "6545"
    },
    {
        "raw_code": "def store_unauthenticated_sessions\n    return if current_user\n\n    Gitlab::AnonymousSession.new(request.remote_ip).count_session_ip\n  end",
        "comment": "counting sessions per IP lets us check if there are associated multiple anonymous sessions with one IP and prevent situations when there are multiple attempts of logging in",
        "label": "What",
        "id": "6423"
    },
    {
        "raw_code": "def up\n    add_column :ssh_signatures, :author_email, :text\n  end",
        "comment": "rubocop:disable Migration/AddLimitToTextColumns -- limit is added in a separate migration 20250425111203",
        "label": "What",
        "id": "5018"
    },
    {
        "raw_code": "def each_value(&block)\n      return to_enum(:each_value) unless block_given?\n      @parameters.each_pair do |key, value|\n        yield convert_hashes_to_parameters(key, value)\n      end",
        "comment": "Convert all hashes in values into parameters, then yield each value in the same way as `Hash#each_value`.",
        "label": "What",
        "id": "11357"
    },
    {
        "raw_code": "def investigate(processed_source, offset: 0, original: processed_source)\n        reset\n\n        begin_investigation(processed_source, offset: offset, original: original)\n        if processed_source.valid_syntax?\n          invoke(:on_new_investigation, @cops)\n          invoke_with_argument(:investigate, @forces, processed_source)\n\n          walk(processed_source.ast) unless @cops.empty?\n          invoke(:on_investigation_end, @cops)\n        else\n          invoke(:on_other_file, @cops)\n        end",
        "comment": "@return [InvestigationReport]",
        "label": "What",
        "id": "10304"
    },
    {
        "raw_code": "def print_markers(request_row, limit_row, current_row)\n          # Show resource markers at correct positions\n          markers = []\n          markers << \"\u2190 LIMIT\" if limit_row == current_row\n          markers << \"\u2190 REQUEST\" if request_row == current_row\n          return unless markers.any?\n\n          print \" #{markers.join(', ')}\"\n        end",
        "comment": "Print markers for request and limit definitions  @param request_row [Integer] @param limit_row [Integer] @param current_row [Integer] @return [void]",
        "label": "What",
        "id": "3952"
    },
    {
        "raw_code": "def process_snippet_notes_with_ctes(ctes)\n        update_sql = <<~SQL\n          WITH\n            #{ctes},\n            relation_by_type AS (\n              SELECT * FROM filtered_relation\n              WHERE noteable_type = 'Snippet'\n            )\n          UPDATE notes\n          SET namespace_id = NULL,\n              organization_id = snippets.organization_id\n          FROM relation_by_type\n          JOIN snippets ON relation_by_type.noteable_id = snippets.id\n          WHERE notes.id = relation_by_type.id\n            AND snippets.project_id IS NULL\n        SQL\n\n        connection.execute(update_sql)\n      end",
        "comment": "rubocop:enable Metrics/MethodLength",
        "label": "What",
        "id": "3290"
    },
    {
        "raw_code": "def upgrade_home_path_v1_1\n      if !ENV[\"VAGRANT_UPGRADE_SILENT_1_5\"]\n        @ui.ask(I18n.t(\"vagrant.upgrading_home_path_v1_5\"))\n      end",
        "comment": "This upgrades a home directory that was in the v1.1 format to the v1.5 format. It will raise exceptions if anything fails.",
        "label": "What",
        "id": "8881"
    },
    {
        "raw_code": "def repository_assignees(repo, options = {})\n        paginate \"#{Repository.path repo}/assignees\", options\n      end",
        "comment": "List users available for assigning to issues.  Requires authenticated client for private repos.  @param repo [Integer, String, Hash, Repository] A GitHub repository. @return [Array<Sawyer::Resource>] Array of hashes representing users. @see https://developer.github.com/v3/issues/assignees/#list-assignees @example Octokit.repository_assignees('octokit/octokit.rb') @example Octokit.repo_assignees('octokit/octokit.rb') @example @client.repository_assignees('octokit/octokit.rb')",
        "label": "What",
        "id": "15165"
    },
    {
        "raw_code": "def extension name, enable\n    if enable then\n      @extensions |= [name]\n    else\n      @extensions -= [name]\n    end",
        "comment": " :category: Extensions  Enables or disables the extension with `name`",
        "label": "What",
        "id": "15577"
    },
    {
        "raw_code": "def attribute_instance_methods_as_symbols_available?\n          false\n        end",
        "comment": "Prevent attr_encrypted from defining virtual accessors for encryption data when the code and schema are out of sync. See this issue for more details: https://github.com/attr-encrypted/attr_encrypted/issues/332",
        "label": "What",
        "id": "1300"
    },
    {
        "raw_code": "def create_empty_file(file_path)\n    create_file(file_path, '')\n  end",
        "comment": "rubocop:enable Metrics/MethodLength rubocop:disable InternalAffairs/CreateEmptyFile",
        "label": "What",
        "id": "11009"
    },
    {
        "raw_code": "def configure_rspec\n          # Shared tooling that adds relevant rspec configuration\n          require_relative '../../../../spec/support/fast_quarantine'\n        end",
        "comment": "Configure rspec  @return [void]",
        "label": "What",
        "id": "4426"
    },
    {
        "raw_code": "def build_index\n    reset @store.all_files.sort, @store.all_classes_and_modules.sort\n\n    index_classes\n    index_methods\n    index_pages\n\n    { :index => @index }\n  end",
        "comment": " Builds the JSON index as a Hash.",
        "label": "What",
        "id": "16443"
    },
    {
        "raw_code": "def swap_pool_repository!\n    return unless repository_exists?\n\n    old_pool_repository = pool_repository\n    return if old_pool_repository.blank?\n    return if pool_repository_shard_matches_repository?(old_pool_repository)\n\n    new_pool_repository = PoolRepository.by_disk_path_and_shard_name(old_pool_repository.disk_path, repository_storage).take!\n    update!(pool_repository: new_pool_repository)\n\n    old_pool_repository.unlink_repository(repository, disconnect: !pending_delete?)\n  end",
        "comment": "After repository is moved from shard to shard, disconnect it from the previous object pool and connect to the new pool",
        "label": "What",
        "id": "6767"
    },
    {
        "raw_code": "def self.check_for_non_superuser\n      user = PgUser.find_by('usename = CURRENT_USER')\n      am_i_superuser = user.usesuper\n\n      Gitlab::AppLogger.info(\n        \"Account details: User: \\\"#{user.usename}\\\", UseSuper: (#{am_i_superuser})\"\n      )\n\n      raise 'Error: detected superuser' if am_i_superuser\n    rescue ActiveRecord::StatementInvalid\n      raise 'User CURRENT_USER not found'\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "1451"
    },
    {
        "raw_code": "def self.execute(path, *args, **opts, &block)\n        validate_install!\n        if opts.delete(:sudo) || opts.delete(:runas)\n          powerup_command(path, args, opts)\n        else\n          if mpath = opts.delete(:module_path)\n            m_env = opts.fetch(:env, {})\n            m_env[\"PSModulePath\"] = \"$env:PSModulePath+';#{mpath}'\"\n            opts[:env] = m_env\n          end",
        "comment": "Execute a powershell script.  @param [String] path Path to the PowerShell script to execute. @param [Array<String>] args Command arguments @param [Hash] opts Options passed to execute @option opts [Hash] :env Custom environment variables @return [Subprocess::Result]",
        "label": "What",
        "id": "9271"
    },
    {
        "raw_code": "def pipeline_mappings(**kwargs)\n          @pipeline_mapping = kwargs\n        end",
        "comment": "Pipeline mapping for this scenario  Defines pipeline mapping hash for this scenario Mapping must use one of the pipeline types defined in QA::Ci::Tools::PipelineCreator::SUPPORTED_PIPELINES and an array of jobs which must exist in that pipeline  @example pipeline_mappings test_on_cng: ['cng-instance'], test_on_gdk: ['gdk-instance']  @return [Hash<String, Array<String>>]",
        "label": "What",
        "id": "4246"
    },
    {
        "raw_code": "def stub_feature_flags(features)\n    features.each do |feature_name, actors|\n      warn(\"Invalid Feature Flag #{feature_name} stubbed\") unless Feature::Definition.get(feature_name)\n\n      # Remove feature flag overwrite\n      feature = Feature.get(feature_name) # rubocop:disable Gitlab/AvoidFeatureGet\n      feature.remove\n\n      Array(actors).each do |actor|\n        raise ArgumentError, \"actor cannot be Hash\" if actor.is_a?(Hash)\n\n        # Control a state of feature flag\n        if actor == true || actor.nil? || actor.respond_to?(:flipper_id)\n          feature.enable(actor)\n        elsif actor == false\n          feature.disable\n        else\n          raise ArgumentError, \"#stub_feature_flags accepts only `nil`, `bool`, an object responding to `#flipper_id` or including `FeatureGate`.\"\n        end",
        "comment": "Stub Feature flags with `flag_name: true/false`  @param [Hash] features where key is feature name and value is boolean whether enabled or not. Alternatively, you can specify Hash to enable the flag on a specific thing.  Examples - `stub_feature_flags(ci_live_trace: false)` ... Disable `ci_live_trace` feature flag globally. - `stub_feature_flags(ci_live_trace: project)` ... - `stub_feature_flags(ci_live_trace: [project1, project2])` ... Enable `ci_live_trace` feature flag only on the specified projects.",
        "label": "What",
        "id": "8504"
    },
    {
        "raw_code": "def xml_name_escape(name)\n      name = name.to_s\n      return \"\" if name.blank?\n      return name if name.match?(SAFE_XML_TAG_NAME_REGEXP)\n\n      starting_char = name[0]\n      starting_char.gsub!(INVALID_TAG_NAME_START_REGEXP, TAG_NAME_REPLACEMENT_CHAR)\n\n      return starting_char if name.size == 1\n\n      following_chars = name[1..-1]\n      following_chars.gsub!(INVALID_TAG_NAME_FOLLOWING_REGEXP, TAG_NAME_REPLACEMENT_CHAR)\n\n      starting_char << following_chars\n    end",
        "comment": "A utility method for escaping XML names of tags and names of attributes.  xml_name_escape('1 < 2 & 3') # => \"1___2___3\"  It follows the requirements of the specification: https://www.w3.org/TR/REC-xml/#NT-Name",
        "label": "What",
        "id": "14219"
    },
    {
        "raw_code": "def show_error\n      raise NotImplementedError\n    end",
        "comment": "Prints troubleshooting instructions  This is where you should print detailed information for any error found during #check?  You may use helper methods to help format the output:  @see #try_fixing_it @see #fix_and_rerun @see #for_more_information",
        "label": "What",
        "id": "3719"
    },
    {
        "raw_code": "def execute(commit_to_changelog: true)\n      config = Gitlab::Changelog::Config.from_git(@project, @user, @config_file, @config_file_ref)\n      from = start_of_commit_range(config)\n\n      # For every entry we want to only include the merge request that\n      # originally introduced the commit, which is the oldest merge request that\n      # contains the commit. We fetch there merge requests in batches, reducing\n      # the number of SQL queries needed to get this data.\n      mrs_finder = MergeRequests::OldestPerCommitFinder.new(@project)\n      release = Gitlab::Changelog::Release\n        .new(version: @version, date: @date, config: config)\n\n      commits =\n        ChangelogCommitsFinder.new(project: @project, from: from, to: @to)\n\n      verify_commit_range!(from, @to)\n\n      commits.each_page(@trailer) do |page|\n        mrs = mrs_finder.execute(page)\n\n        # Preload the authors. This ensures we only need a single SQL query per\n        # batch of commits, instead of needing a query for every commit.\n        page.each(&:lazy_author)\n\n        # Preload author permissions\n        @project.team.max_member_access_for_user_ids(page.map(&:author).compact.map(&:id))\n\n        page.each do |commit|\n          release.add_entry(\n            title: commit.title,\n            commit: commit,\n            category: commit.trailers.fetch(@trailer),\n            author: commit.author,\n            merge_request: mrs[commit.id]\n          )\n        end",
        "comment": "rubocop: enable Metrics/ParameterLists",
        "label": "What",
        "id": "6011"
    },
    {
        "raw_code": "def column_owner\n            return unless owner_table && owner_column\n\n            \"#{column_schema}.#{owner_table}.#{owner_column}\"\n          end",
        "comment": "Fully qualified column reference (schema.table.column)",
        "label": "What",
        "id": "1184"
    },
    {
        "raw_code": "def variables_section\n          @pipeline_variables ||= \"variables:\\n\".then do |variables|\n            vars = {\n              **base_pipeline_variables,\n              # QA_SUITES is only used by test-on-omnibus due to pipeline being reusable in external projects\n              \"QA_SUITES\" => executable_qa_suites,\n              \"QA_TESTS\" => tests&.join(\" \")\n            }.filter_map { |k, v| \"  #{k}: \\\"#{v}\\\"\" unless v.blank? }.join(\"\\n\")\n\n            \"#{variables}#{vars}\"\n          end",
        "comment": "Additional variables section for generated pipeline  @return [String]",
        "label": "What",
        "id": "4781"
    },
    {
        "raw_code": "def _reduce_13(val, _values, result)\n      content = val[1]\n      result = inline \"<em>#{content}</em>\", content\n\n    result\nend",
        "comment": "reduce 4 omitted reduce 5 omitted reduce 6 omitted reduce 7 omitted reduce 8 omitted reduce 9 omitted reduce 10 omitted reduce 11 omitted reduce 12 omitted",
        "label": "What",
        "id": "16544"
    },
    {
        "raw_code": "def retry_disabled?\n      get_sidekiq_options['retry'] == 0 || get_sidekiq_options['retry'] == false\n    end",
        "comment": "Checks if sidekiq retry support is disabled",
        "label": "What",
        "id": "6350"
    },
    {
        "raw_code": "def build(event, include_deprecated_owner: false)\n        [\n          event_data(event),\n          timestamps_data,\n          project_data(include_deprecated_owner: include_deprecated_owner),\n          event_specific_project_data(event)\n        ].reduce(:merge)\n      end",
        "comment": "Sample data { event_name: \"project_rename\", created_at: \"2021-04-19T07:05:36Z\", updated_at: \"2021-04-19T07:05:36Z\", name: \"my_project\", path: \"my_project\", path_with_namespace: \"namespace2/my_project\", project_id: 1, owner_name: \"John\", owner_email: \"user1@example.org\", owners: [name: \"John\", email: \"user1@example.org\"], project_visibility: \"internal\", old_path_with_namespace: \"old-path-with-namespace\" }",
        "label": "What",
        "id": "2414"
    },
    {
        "raw_code": "def valid_visibility_level_change?(target, new_visibility)\n    return true unless new_visibility\n\n    new_visibility_level = Gitlab::VisibilityLevel.level_value(new_visibility, fallback_value: nil)\n\n    if new_visibility_level != target.visibility_level_value\n      unless can?(current_user, :change_visibility_level, target) &&\n          Gitlab::VisibilityLevel.allowed_for?(current_user, new_visibility_level)\n\n        deny_visibility_level(target, new_visibility_level)\n        return false\n      end",
        "comment": "check that user is allowed to set specified visibility_level",
        "label": "What",
        "id": "5711"
    },
    {
        "raw_code": "def loaded_plugins\n      @loaded_plugins ||= ConfigLoader.loaded_plugins\n    end",
        "comment": "rubocop:enable Metrics/AbcSize, Metrics/MethodLength",
        "label": "What",
        "id": "10167"
    },
    {
        "raw_code": "def serializer\n    raise NotImplementedError\n  end",
        "comment": "rubocop:enable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "6520"
    },
    {
        "raw_code": "def will_be_destroyed?(association_name, attributes)\n        allow_destroy?(association_name) && has_destroy_flag?(attributes)\n      end",
        "comment": "Only take into account the destroy flag if <tt>:allow_destroy</tt> is true",
        "label": "What",
        "id": "12540"
    },
    {
        "raw_code": "def update_resource_label_events(group_label, label_ids)\n      ResourceLabelEvent\n        .where(label: label_ids)\n        .update_all(label_id: group_label.id)\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6051"
    },
    {
        "raw_code": "def begin_fast_destroy\n        all_stores.each_with_object({}) do |store, result|\n          relation = public_send(store) # rubocop:disable GitlabSecurity/PublicSend\n          keys = get_store_class(store).keys(relation)\n\n          result[store] = keys if keys.present?\n        end",
        "comment": " FastDestroyAll concerns",
        "label": "What",
        "id": "7511"
    },
    {
        "raw_code": "def maximum(key)\n    map(&key).max\n  end",
        "comment": "Calculates the maximum from the extracted elements.  payments = [Payment.new(5), Payment.new(15), Payment.new(10)] payments.maximum(:price) # => 15",
        "label": "What",
        "id": "14066"
    },
    {
        "raw_code": "def prepend(klass, *args)\n        remove(klass)\n        entries.insert(0, Entry.new(@config, klass, *args))\n      end",
        "comment": "Identical to {#add} except the middleware is added to the front of the chain.",
        "label": "What",
        "id": "5201"
    },
    {
        "raw_code": "def self.new\n    @instance\n  end",
        "comment": " RDoc::Markup::HardBreak is a singleton",
        "label": "What",
        "id": "16297"
    },
    {
        "raw_code": "def to_s\n    if length1 == 0\n      coords1 = start1.to_s + \",0\"\n    elsif length1 == 1\n      coords1 = (start1 + 1).to_s\n    else\n      coords1 = (start1 + 1).to_s + \",\" + length1.to_s\n    end",
        "comment": "Emulate GNU diff's format Header: @@ -382,8 +481,9 @@ Indices are printed as 1-based, not 0-based.",
        "label": "What",
        "id": "5044"
    },
    {
        "raw_code": "def append_username(base, username)\n          result = base.dup\n          result << (result.include?('?') ? '&' : '?')\n          result << 'username='\n          result << Rack::Utils.escape(username)\n        end",
        "comment": "Adds +service+ as an URL-escaped parameter to +base+.  @param [String] base the base URL @param [String] service the service (a.k.a. return-to) URL.  @return [String] the new joined URL.",
        "label": "What",
        "id": "5249"
    },
    {
        "raw_code": "def self.isofs_available(env)\n          !!Vagrant::Util::Which.which(BUILD_ISO_CMD)\n        end",
        "comment": "Check that the host has the ability to generate ISOs  @param [Vagrant::Environment] env @return [Boolean]",
        "label": "What",
        "id": "9723"
    },
    {
        "raw_code": "def dropdown_toggle(toggle_text, data_attr, options = {})\n    default_label = data_attr[:default_label]\n    content_tag(:button, disabled: options[:disabled], class: \"dropdown-menu-toggle #{options[:toggle_class] if options.key?(:toggle_class)}\", id: (options[:id] if options.key?(:id)), type: \"button\", data: data_attr) do\n      output = content_tag(:span, toggle_text, class: \"dropdown-toggle-text #{'is-default' if toggle_text == default_label}\")\n      output << sprite_icon('chevron-down', css_class: \"dropdown-menu-toggle-icon\")\n      output.html_safe\n    end",
        "comment": "rubocop:enable Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "7760"
    },
    {
        "raw_code": "def remove_siginfo_handler\n    return unless Signal.list.key? 'INFO'\n\n    handler = @old_siginfo || 'DEFAULT'\n\n    trap 'INFO', handler\n  end",
        "comment": " Removes a siginfo handler and replaces the previous",
        "label": "What",
        "id": "16022"
    },
    {
        "raw_code": "def perform(integration_id, min_id, max_id)\n    integration = Integration.find_by_id(integration_id)\n    return unless integration\n\n    batch = if integration.instance_level?\n              Group.where(id: min_id..max_id).without_integration(integration)\n            else\n              integration.group.descendants.where(id: min_id..max_id).without_integration(integration)\n            end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6286"
    },
    {
        "raw_code": "def self.init(context)\n        context => { requested_setting_names: Array => requested_setting_names }\n\n        # NOTE: We override the requested_setting_names to include *all* nested setting dependencies.\n        requested_setting_names = Gitlab::Fp::Settings::SettingsDependencyResolver.resolve(\n          requested_setting_names,\n          SETTINGS_DEPENDENCIES\n        )\n        context[:requested_setting_names] = requested_setting_names\n\n        context[:settings], context[:setting_types] = Gitlab::Fp::Settings::DefaultSettingsParser.parse(\n          module_name: \"Web IDE\",\n          requested_setting_names: requested_setting_names,\n          default_settings: DefaultSettings.default_settings\n        )\n\n        # NOTE: This is context which is required by shared Gitlab::Fp::Settings::EnvVarOverrideProcessor class\n        context[:env_var_prefix] = \"GITLAB_WEB_IDE\"\n        context[:env_var_failed_message_class] =\n          WebIde::Settings::Messages::SettingsEnvironmentVariableOverrideFailed\n\n        context\n      end",
        "comment": "@param [Hash] context @return [Hash] @raise [RuntimeError]",
        "label": "What",
        "id": "3570"
    },
    {
        "raw_code": "def definition\n    \"class << #{full_name}\"\n  end",
        "comment": " The definition of this singleton class, <tt>class << MyClassName</tt>",
        "label": "What",
        "id": "16781"
    },
    {
        "raw_code": "def self.openapi_types\n      {\n        :'frequency' => :'Object'\n      }\n    end",
        "comment": "Attribute type mapping.",
        "label": "What",
        "id": "985"
    },
    {
        "raw_code": "def execute\n        ApplicationController.helpers\n      end",
        "comment": "This method assumes an +ApplicationController+ exists, and that it extends ActionController::Base.",
        "label": "What",
        "id": "14721"
    },
    {
        "raw_code": "def urlencode(text)\n        text = text.dup\n        enc = nil\n        if text.respond_to?(:force_encoding)\n          enc = text.encoding\n          text = text.force_encoding('binary')\n        end",
        "comment": "Escapes a URL  @param [String] text the URL @return [String] the escaped URL",
        "label": "What",
        "id": "386"
    },
    {
        "raw_code": "def punch_card_stats(repo, options = {})\n        get_stats(repo, 'punch_card', options)\n      end",
        "comment": "Get the number of commits per hour in each day  @param repo [Integer, String, Hash, Repository] A GitHub repository @option retry_timeout [Number] How long Octokit should keep trying to get stats (in seconds) @option retry_wait [Number] How long Octokit should wait between retries. @return [Array<Array>] Arrays containing the day number, hour number, and number of commits @see https://developer.github.com/v3/repos/statistics/#get-the-number-of-commits-per-hour-in-each-day @example Get octokit punch card @octokit.punch_card_stats",
        "label": "What",
        "id": "15380"
    },
    {
        "raw_code": "def api_post_to(post_path, post_body, args = {})\n        super(post_path, post_body, { content_type: 'multipart/form-data' })\n      end",
        "comment": "Override api_post_to method to add multipart request option  @param [String] post_path @param [Hash] post_body @param [Hash] args @return [Hash]",
        "label": "What",
        "id": "4125"
    },
    {
        "raw_code": "def execute(pod_name, command, container: nil)\n          args = [\"--\", *command]\n          args.unshift(\"-c\", container) if container\n\n          run_in_namespace(\"exec\", get_pod_name(pod_name), args: args)\n        end",
        "comment": "Execute command in a pod  @param [String] pod full or part of pod name @param [Array] command @param [String] container @return [String]",
        "label": "What",
        "id": "3968"
    },
    {
        "raw_code": "def store!\n        if !plugin_file.exist?\n          @logger.debug(\"plugin file does not exist, not storing solution\")\n          return\n        end",
        "comment": "Store the solution file",
        "label": "What",
        "id": "8890"
    },
    {
        "raw_code": "def update_organization_membership(org, options = {})\n        options = options.dup\n        if user = options.delete(:user)\n          options.delete(:state)\n          put \"#{Organization.path(org)}/memberships/#{user}\", options\n        else\n          options.delete(:role)\n          patch \"user/memberships/orgs/#{org}\", options\n        end",
        "comment": "Edit an organization membership  @param org [String, Integer] Organization GitHub login or id. @option options [String] :role  The role of the user in the organization. @option options [String] :state The state that the membership should be in. @option options [String] :user  The login of the user, otherwise authenticated user. @return [Sawyer::Resource] Hash representing the updated organization membership. @see https://developer.github.com/v3/orgs/members/#edit-your-organization-membership @see https://developer.github.com/v3/orgs/members/#add-or-update-organization-membership",
        "label": "What",
        "id": "15455"
    },
    {
        "raw_code": "def import(project)\n          waiter = importer_class.new(project).execute\n\n          AdvanceStageWorker.perform_async(\n            project.id,\n            { waiter.key => waiter.jobs_remaining },\n            :finish\n          )\n        end",
        "comment": "project - An instance of Project.",
        "label": "What",
        "id": "6303"
    },
    {
        "raw_code": "def file_path_rerun_argument\n        loaded_spec_files = RSpec.configuration.loaded_spec_files\n\n        RSpec::Core::Metadata.ascending(metadata) do |meta|\n          break meta[:file_path] if loaded_spec_files.include?(meta[:absolute_file_path])\n        end",
        "comment": "Based on https://github.com/rspec/rspec-core/blob/d57c371ee92b16211b80ac7b0b025968438f5297/lib/rspec/core/example.rb#L96-L104, Same as location_rerun_argument but with line number",
        "label": "What",
        "id": "8342"
    },
    {
        "raw_code": "def community_plugin_detected?\n          if !defined?(@_triggers_enabled)\n            plugins = Vagrant::Plugin::Manager.instance.installed_plugins\n            @_triggers_enabled = plugins.keys.include?(\"vagrant-triggers\")\n          end",
        "comment": "Looks up if the community plugin `vagrant-triggers` is installed and also caches the result  @return [Boolean]",
        "label": "What",
        "id": "9042"
    },
    {
        "raw_code": "def update\n    if @message.update(message_params)\n      redirect_to @message, notice: 'Message was successfully updated.'\n    else\n      render :edit, status: :unprocessable_entity\n    end",
        "comment": "PATCH/PUT /messages/1",
        "label": "What",
        "id": "11707"
    },
    {
        "raw_code": "def comparable\n        raise(\"comparable method needs to be implemented in order to compare resources via '=='\")\n      end",
        "comment": "Custom resource comparison logic using resource attributes from api_resource  @return [Hash]",
        "label": "What",
        "id": "4137"
    },
    {
        "raw_code": "def nm_controlled?(comm, device_name)\n          comm.test(\"nmcli -t d show #{device_name}\") &&\n            !comm.test(\"nmcli -t d show #{device_name} | grep unmanaged\")\n        end",
        "comment": "NetworkManager currently controls device  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @param device_name [String] @return [Boolean]",
        "label": "What",
        "id": "9267"
    },
    {
        "raw_code": "def jh_queues_for_sidekiq_queues_yml\n        []\n      end",
        "comment": "Override in JH repo",
        "label": "What",
        "id": "1415"
    },
    {
        "raw_code": "def milestone(repository, number, options = {})\n        get \"#{Repository.path repository}/milestones/#{number}\", options\n      end",
        "comment": "Get a single milestone for a repository  @param repository [Integer, String, Repository, Hash] A GitHub repository @param options [Hash] A customizable set of options. @option options [Integer] :milestone Milestone number. @return [Sawyer::Resource] A single milestone from a repository. @see https://developer.github.com/v3/issues/milestones/#get-a-single-milestone @example Get a single milestone for a repository Octokit.milestone(\"octokit/octokit.rb\", 1)",
        "label": "What",
        "id": "15337"
    },
    {
        "raw_code": "def duplicable?\n    false\n  end",
        "comment": "Singleton instances are not duplicable:  Class.new.include(Singleton).instance.dup # TypeError (can't dup instance of singleton",
        "label": "What",
        "id": "14316"
    },
    {
        "raw_code": "def rm_network(*network)\n        command = ['docker', 'network', 'rm', *network]\n        output = execute(*command)\n        output\n      end",
        "comment": "Delete network(s)  @param [String] network - name of network to remove",
        "label": "What",
        "id": "9492"
    },
    {
        "raw_code": "def api_put_path\n        \"/groups/#{id}\"\n      end",
        "comment": "API put path  @return [String]",
        "label": "What",
        "id": "4157"
    },
    {
        "raw_code": "def user_repository_invitations(options = {})\n        paginate '/user/repository_invitations', options\n      end",
        "comment": "List all repository invitations for the user  Requires authenticated client  @return [Array<Sawyer::Resource>] The users repository invitations @see https://developer.github.com/v3/repos/invitations/#list-a-users-repository-invitations",
        "label": "What",
        "id": "15399"
    },
    {
        "raw_code": "def update_extends\n    extends.reject! do |ext|\n      mod = ext.module\n\n      !(String === mod) && @store.modules_hash[mod.full_name].nil?\n    end",
        "comment": " Deletes from #extends those whose module has been removed from the documentation. -- FIXME: like update_includes, extends are not reliably removed",
        "label": "What",
        "id": "16769"
    },
    {
        "raw_code": "def test_user_password\n          ENV[TEST_USER_PASSWORD_VARIABLE_NAME]\n        end",
        "comment": "Global test user password  @return [String]",
        "label": "What",
        "id": "4497"
    },
    {
        "raw_code": "def attr_encrypted(*attributes)\n    options = attributes.last.is_a?(Hash) ? attributes.pop : {}\n    options = attr_encrypted_default_options.dup.merge!(attr_encrypted_options).merge!(options)\n\n    options[:encode] = options[:default_encoding] if options[:encode] == true\n    options[:encode_iv] = options[:default_encoding] if options[:encode_iv] == true\n    options[:encode_salt] = options[:default_encoding] if options[:encode_salt] == true\n\n    attributes.each do |attribute|\n      encrypted_attribute_name = (options[:attribute] || [options[:prefix], attribute,\n        options[:suffix]].join).to_sym\n\n      if attribute_instance_methods_as_symbols_available?\n        instance_methods_as_symbols = attribute_instance_methods_as_symbols\n\n        attr_reader encrypted_attribute_name unless instance_methods_as_symbols.include?(encrypted_attribute_name)\n\n        unless instance_methods_as_symbols.include?(:\"#{encrypted_attribute_name}=\")\n          attr_writer encrypted_attribute_name\n        end",
        "comment": "rubocop:disable Metrics/AbcSize -- This is upstream code rubocop:disable Metrics/CyclomaticComplexity -- This is upstream code rubocop:disable Metrics/PerceivedComplexity -- This is upstream code",
        "label": "What",
        "id": "1301"
    },
    {
        "raw_code": "def self.dummy_singleton_method(foo, bar); end\n\n  # Example instance method.\n  def dummy_instance_method(foo, bar); end;\n\n  alias dummy_instance_alias dummy_instance_method\n\n  # Example attribute.\n  attr_accessor :dummy_attribute\n\n  alias dummy_attribute_alias dummy_attribute\n\n  # Example constant.\n  DUMMY_CONSTANT = ''\n\n  # :call-seq:\n  #   call_seq_directive(foo, bar)\n  #   Can be anything -> bar\n  #   Also anything more -> baz or bat\n  #\n  # The <tt>:call-seq:</tt> directive overrides the actual calling sequence\n  # found in the Ruby code.\n  #\n  # - It can specify anything at all.\n  # - It can have multiple calling sequences.\n  #\n  # This one includes <tt>Can be anything -> foo</tt>, which is nonsense.\n  #\n  # Note that the \"arrow\" is two characters, hyphen and right angle-bracket,\n  # which is made into a single character in the HTML.\n  #\n  # Click on the calling sequence to see the code.\n  #\n  # Here is the <tt>:call-seq:</tt> directive given for the method:\n  #\n  #   :call-seq:\n  #     call_seq_directive(foo, bar)\n  #     Can be anything -> bar\n  #     Also anything more -> baz or bat\n  #\n  def call_seq_directive\n    nil\n  end\n\n  # The <tt>:args:</tt> directive overrides the actual arguments found in the Ruby code.\n  #\n  # Click on the calling sequence to see the code.\n  #\n  def args_directive(foo, bar) # :args: baz\n    nil\n  end\n\n  # The <tt>:yields:</tt> directive overrides the actual yield found in the Ruby code.\n  #\n  # Click on the calling sequence to see the code.\n  #\n  def yields_directive(foo, bar) # :yields: 'bat'\n    yield 'baz'\n  end\n\n  # This method is documented only by \\RDoc, except for these comments.\n  #\n  # Click on the calling sequence to see the code.\n  #\n  def method(foo, bar)\n    yield 'baz'\n  end\n\nend",
        "comment": "Example singleton method.",
        "label": "What",
        "id": "16844"
    },
    {
        "raw_code": "def initialize(page, container)\n          @page = page\n          @container = container\n        end",
        "comment": "page      - A QA::Page::Base object container - CSS selector of the comment textarea's container",
        "label": "What",
        "id": "4282"
    },
    {
        "raw_code": "def self.remove_renderer(key)\n    Renderers.remove(key)\n  end",
        "comment": "See Renderers.remove",
        "label": "What",
        "id": "11320"
    },
    {
        "raw_code": "def drop_partitioned_table_for(table_name)\n          assert_table_is_allowed(table_name)\n          assert_not_in_transaction_block(scope: ERROR_SCOPE)\n\n          with_lock_retries do\n            drop_sync_trigger(table_name)\n          end",
        "comment": "Clean up a partitioned copy of an existing table. First, deletes the database function and trigger that were used to copy writes to the partitioned table, then removes the partitioned table (also removing partitions).  Example:  drop_partitioned_table_for :audit_events ",
        "label": "What",
        "id": "3051"
    },
    {
        "raw_code": "def normalize_controller!\n          if controller\n            if controller.start_with?(\"/\")\n              @options[:controller] = controller[1..-1]\n            else\n              @options[:controller] = controller\n            end",
        "comment": "Remove leading slashes from controllers",
        "label": "What",
        "id": "11600"
    },
    {
        "raw_code": "def comment_range(comment)\n        range = comment.loc.expression\n        adjusted_range = range.adjust(begin_pos: -1)\n\n        return range if comment.document?\n\n        adjusted_range.source.start_with?(' ') ? adjusted_range : range\n      end",
        "comment": "Finds the proper range for the comment.  @Note inline comments can cause trailing whitespaces. For such cases, the extra whitespace needs to be removed",
        "label": "What",
        "id": "8083"
    },
    {
        "raw_code": "def classes\n    return @classes if @classes\n\n    @classes = {}\n\n    @stores.each do |store|\n      store.cache[:modules].each do |mod|\n        # using default block causes searched-for modules to be added\n        @classes[mod] ||= []\n        @classes[mod] << store\n      end",
        "comment": " Hash mapping a known class or module to the stores it can be loaded from",
        "label": "What",
        "id": "16590"
    },
    {
        "raw_code": "def table_name_options(config = ActiveRecord::Base) # :nodoc:\n      {\n        table_name_prefix: config.table_name_prefix,\n        table_name_suffix: config.table_name_suffix\n      }\n    end",
        "comment": "Builds a hash for use in ActiveRecord::Migration#proper_table_name using the Active Record object's table_name prefix and suffix",
        "label": "What",
        "id": "12500"
    },
    {
        "raw_code": "def by_visibility_level(items)\n    params[:visibility_level].present? ? items.where(visibility_level: params[:visibility_level]) : items\n  end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7925"
    },
    {
        "raw_code": "def check_branches(node, branches)\n          # return if any branch is empty. An empty branch can be an `if`\n          # without an `else` or a branch that contains only comments.\n          return if branches.any?(&:nil?)\n\n          tails = branches.map { |branch| tail(branch) }\n          check_expressions(node, tails, :after_condition) if duplicated_expressions?(node, tails)\n\n          return if last_child_of_parent?(node) &&\n                    branches.any? { |branch| single_child_branch?(branch) }\n\n          heads = branches.map { |branch| head(branch) }\n\n          return unless duplicated_expressions?(node, heads)\n\n          condition_variable = assignable_condition_value(node)\n\n          head = heads.first\n          if head.respond_to?(:assignment?) && head.assignment?\n            # The `send` node is used instead of the `indexasgn` node, so `name` cannot be used.\n            # https://github.com/rubocop/rubocop-ast/blob/v1.29.0/lib/rubocop/ast/node/indexasgn_node.rb\n            #\n            # FIXME: It would be better to update `RuboCop::AST::OpAsgnNode` or its subclasses to\n            # handle `self.foo ||= value` as a solution, instead of using `head.node_parts[0].to_s`.\n            assigned_value = head.send_type? ? head.receiver.source : head.node_parts[0].to_s\n\n            return if condition_variable == assigned_value\n          end",
        "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10489"
    },
    {
        "raw_code": "def webmock_enable_with_http_connect_on_start!\n  webmock_enable!(net_http_connect_on_start: true)\nend",
        "comment": "This prevents Selenium/WebMock from spawning thousands of connections while waiting for an element to appear via Capybara's find: https://github.com/teamcapybara/capybara/issues/2322#issuecomment-619321520",
        "label": "What",
        "id": "8305"
    },
    {
        "raw_code": "def remove_private\n    # Workaround for gsub encoding for Ruby 1.9.2 and earlier\n    empty = ''\n    empty = RDoc::Encoding.change_encoding empty, @text.encoding\n\n    @text = @text.gsub(%r%^\\s*([#*]?)--.*?^\\s*(\\1)\\+\\+\\n?%m, empty)\n    @text = @text.sub(%r%^\\s*[#*]?--.*%m, '')\n  end",
        "comment": " Removes private sections from this comment.  Private sections are flush to the comment marker and start with <tt>--</tt> and end with <tt>++</tt>. For C-style comments, a private marker may not start at the opening of the comment.  /* *-- * private *++ * public */",
        "label": "What",
        "id": "15964"
    },
    {
        "raw_code": "def record_chat_activity(chat_name)\n      chat_name.update_last_used_at\n      Users::ActivityService.new(author: chat_name.user).execute\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5878"
    },
    {
        "raw_code": "def generate_gzipped\n    return if @options.dry_run or not defined?(Zlib)\n\n    debug_msg \"Compressing generated JSON index\"\n    out_dir = @base_dir + @options.op_dir\n\n    search_index_file = out_dir + SEARCH_INDEX_FILE\n    outfile           = out_dir + \"#{search_index_file}.gz\"\n\n    debug_msg \"Reading the JSON index file from %s\" % search_index_file\n    search_index = search_index_file.read(mode: 'r:utf-8')\n\n    debug_msg \"Writing gzipped search index to %s\" % outfile\n\n    Zlib::GzipWriter.open(outfile) do |gz|\n      gz.mtime = File.mtime(search_index_file)\n      gz.orig_name = search_index_file.basename.to_s\n      gz.write search_index\n      gz.close\n    end",
        "comment": " Compress the search_index.js file using gzip",
        "label": "What",
        "id": "16446"
    },
    {
        "raw_code": "def reset(force: true)\n          response = post(\"#{admin_url}/reset?force=#{force}\", {}.to_json)\n          parse_body(response)['message'] == 'Reset successful'\n        end",
        "comment": "Clears mocks and history  @param force [Boolean] remove locked mocks? @return [Boolean] reset was successful?",
        "label": "What",
        "id": "4343"
    },
    {
        "raw_code": "def enable_extension(name, **)\n      end",
        "comment": "This is meant to be implemented by the adapters that support extensions",
        "label": "What",
        "id": "12910"
    },
    {
        "raw_code": "def lazy_job_execution_status(object:, key:)\n          BatchLoader.for(object.id).batch(key: key) do |object_ids, loader|\n            statuses = object.class.id_in(object_ids).with_executing_builds.index_by(&:id)\n\n            object_ids.each do |id|\n              loader.call(id, statuses[id] ? :active : :idle)\n            end",
        "comment": "Efficiently determines job execution status for multiple runners using BatchLoader to avoid N+1 queries. Returns :active if runner has executing builds, :idle otherwise.",
        "label": "What",
        "id": "3823"
    },
    {
        "raw_code": "def each_send_node(node, &block)\n      node.each_descendant(:send, &block)\n    end",
        "comment": "Yields every send node found in the given AST node.",
        "label": "What",
        "id": "3898"
    },
    {
        "raw_code": "def find_knn_child(node)\n          node.children.find { |child| child.type == :knn }\n        end",
        "comment": "Finds the KNN child in a query node  @param node [ActiveContext::Query] The query node to search @return [ActiveContext::Query, nil] The KNN query node if found",
        "label": "What",
        "id": "1137"
    },
    {
        "raw_code": "def get_bootstrap\n        if @config.bootstrap_script\n          bootstrap_abs_path = expanded_path(@config.bootstrap_script)\n        else\n          bootstrap_downloader = BootstrapDownloader.new(@machine.config.vm.guest)\n          bootstrap_script = bootstrap_downloader.get_bootstrap_script\n          bootstrap_abs_path = expanded_path(bootstrap_script.path)\n        end",
        "comment": "Get bootstrap file location, bundled or custom",
        "label": "What",
        "id": "9882"
    },
    {
        "raw_code": "def invalid_info?\n          if @env[\"package.info\"] != \"\"\n            info_path = Pathname.new(@env[\"package.info\"])\n\n            return !info_path.file? || File.basename(info_path) != \"info.json\"\n          end",
        "comment": "Check to see if package.info is a valid file and titled info.json",
        "label": "What",
        "id": "9326"
    },
    {
        "raw_code": "def self.find_by_full_path(path, follow_redirects: false, route_scope: nil)\n    return unless path.present?\n\n    # Convert path to string to prevent DB error: function lower(integer) does not exist\n    path = path.to_s\n\n    # Case sensitive match first (it's cheaper and the usual case)\n    # If we didn't have an exact match, we perform a case insensitive search\n    #\n    # We need to qualify the columns with the table name, to support both direct lookups on\n    # Route/RedirectRoute, and scoped lookups through the Routable classes.\n    path_condition = { path: path }\n\n    source_type_condition = route_scope ? { source_type: route_scope.klass.base_class } : {}\n\n    route =\n      Route.where(source_type_condition).find_by(path_condition) ||\n      Route.where(source_type_condition).iwhere(path_condition).take\n\n    if follow_redirects\n      route ||= RedirectRoute.where(source_type_condition).iwhere(path_condition).take\n    end",
        "comment": "Finds a Routable object by its full path, without knowing the class.  Usage:  Routable.find_by_full_path('groupname')             # -> Group Routable.find_by_full_path('groupname/projectname') # -> Project  Returns a single object, or nil.",
        "label": "What",
        "id": "7261"
    },
    {
        "raw_code": "def import(project)\n          waiter = importer_class.new(project).execute\n\n          AdvanceStageWorker.perform_async(\n            project.id,\n            { waiter.key => waiter.jobs_remaining },\n            :issues\n          )\n        end",
        "comment": "project - An instance of Project.",
        "label": "What",
        "id": "6304"
    },
    {
        "raw_code": "def self.chef_installed(machine, product, version)\n            verify_bin = product == 'chef-workstation' ? 'chef' : 'chef-client'\n            if version != :latest\n              command = 'if ((&' + verify_bin + ' --version) -Match \"' + version.to_s + '\"){ exit 0 } else { exit 1 }'\n            else\n              command = 'if ((&' + verify_bin + ' --version) -Match \"Chef*\"){ exit 0 } else { exit 1 }'\n            end",
        "comment": "Check if Chef is installed at the given version. @return [true, false]",
        "label": "What",
        "id": "9904"
    },
    {
        "raw_code": "def minimum(column_name)\n      calculate(:minimum, column_name)\n    end",
        "comment": "Calculates the minimum value on a given column. The value is returned with the same data type of the column, or +nil+ if there's no row. See #calculate for examples with options.  Person.minimum(:age) # => 7",
        "label": "What",
        "id": "13349"
    },
    {
        "raw_code": "def self.verify_backup\n        lock_backup do\n          ::Backup::Manager.new(backup_progress).verify!\n        end",
        "comment": "Verify backup file to ensure it is compatible with current GitLab's version",
        "label": "What",
        "id": "3739"
    },
    {
        "raw_code": "def render_commit_status(commit, status, ref: nil, tooltip_placement: 'left')\n      project = commit.project\n      path = pipelines_project_commit_path(project, commit, ref: ref)\n\n      render_ci_icon(\n        status,\n        path,\n        tooltip_placement: tooltip_placement\n      )\n    end",
        "comment": "rubocop:enable Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "7844"
    },
    {
        "raw_code": "def find_version_by_class_name(class_name)\n        @migrations.find do |_version, klass|\n          klass.name&.demodulize == class_name\n        end&.first\n      end",
        "comment": "Find a version by class name (e.g., 'CreateCode')",
        "label": "What",
        "id": "1117"
    },
    {
        "raw_code": "def show; end\n\n  def new\n    @environment = project.environments.new\n  end\n\n  def edit; end\n\n  def k8s\n    render action: :show\n  end\n\n  def create\n    @environment = project.environments.create(environment_params)\n\n    if @environment.persisted?\n      render json: { environment: @environment, path: project_environment_path(project, @environment) }\n    else\n      render json: { message: @environment.errors.full_messages }, status: :bad_request\n    end\n  end\n\n  def update\n    if @environment.update(environment_params)\n      render json: { environment: @environment, path: project_environment_path(project, @environment) }\n    else\n      render json: { message: @environment.errors.full_messages }, status: :bad_request\n    end\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6596"
    },
    {
        "raw_code": "def current_job\n          id = params[:id]\n\n          load_balancer_stick_request(::Ci::Build, :build, id) if id\n\n          strong_memoize(:current_job) do\n            ::Ci::Build.find_by_id(id)\n          end",
        "comment": "current_job is queried by URL :id param with no authentication",
        "label": "What",
        "id": "3821"
    },
    {
        "raw_code": "def delete(key)\n      perform_across_services :delete, key\n    end",
        "comment": "Delete the file at the +key+ on all services.",
        "label": "What",
        "id": "13695"
    },
    {
        "raw_code": "def can_read_group_reference?(node, user, groups)\n        node_group = groups[node]\n\n        node_group && can?(user, :read_group, node_group)\n      end",
        "comment": "Check if project belongs to a group which user can read.",
        "label": "What",
        "id": "3418"
    },
    {
        "raw_code": "def load_schema\n        File.read(File.expand_path(\"fixtures/db_definitions/sqlite.sql\", __dir__)).split(\";\").each do |sql|\n          ActiveRecord::Base.lease_connection.execute(sql) unless sql.blank?\n        end",
        "comment": "Load actionpack sqlite3 tables",
        "label": "What",
        "id": "12028"
    },
    {
        "raw_code": "def docstring(locale = I18n::Locale.default)\n        if locale.nil?\n          @docstring.resolve_reference\n          return @docstring\n        end",
        "comment": "The documentation string associated with the object  @param [String, I18n::Locale] locale (I18n::Locale.default) the locale of the documentation string. @return [Docstring] the documentation string",
        "label": "What",
        "id": "576"
    },
    {
        "raw_code": "def config_accessor(*names, instance_reader: true, instance_writer: true, instance_accessor: true, default: nil) # :doc:\n        names.each do |name|\n          raise NameError.new(\"invalid config attribute name\") unless /\\A[_A-Za-z]\\w*\\z/.match?(name)\n\n          reader, reader_line = \"def #{name}; config.#{name}; end\", __LINE__\n          writer, writer_line = \"def #{name}=(value); config.#{name} = value; end\", __LINE__\n\n          singleton_class.class_eval reader, __FILE__, reader_line\n          singleton_class.class_eval writer, __FILE__, writer_line\n\n          if instance_accessor\n            class_eval reader, __FILE__, reader_line if instance_reader\n            class_eval writer, __FILE__, writer_line if instance_writer\n          end",
        "comment": "Allows you to add shortcut so that you don't have to refer to attribute through config. Also look at the example for config to contrast.  Defines both class and instance config accessors.  class User include ActiveSupport::Configurable config_accessor :allowed_access end  User.allowed_access # => nil User.allowed_access = false User.allowed_access # => false  user = User.new user.allowed_access # => false user.allowed_access = true user.allowed_access # => true  User.allowed_access # => false  The attribute name must be a valid method name in Ruby.  class User include ActiveSupport::Configurable config_accessor :\"1_Badname\" end # => NameError: invalid config attribute name  To omit the instance writer method, pass <tt>instance_writer: false</tt>. To omit the instance reader method, pass <tt>instance_reader: false</tt>.  class User include ActiveSupport::Configurable config_accessor :allowed_access, instance_reader: false, instance_writer: false end  User.allowed_access = false User.allowed_access # => false  User.new.allowed_access = true # => NoMethodError User.new.allowed_access        # => NoMethodError  Or pass <tt>instance_accessor: false</tt>, to omit both instance methods.  class User include ActiveSupport::Configurable config_accessor :allowed_access, instance_accessor: false end  User.allowed_access = false User.allowed_access # => false  User.new.allowed_access = true # => NoMethodError User.new.allowed_access        # => NoMethodError  Also you can pass <tt>default</tt> or a block to set up the attribute with a default value.  class User include ActiveSupport::Configurable config_accessor :allowed_access, default: false config_accessor :hair_colors do [:brown, :black, :blonde, :red] end end  User.allowed_access # => false User.hair_colors # => [:brown, :black, :blonde, :red]",
        "label": "What",
        "id": "13783"
    },
    {
        "raw_code": "def last!\n      last || raise_record_not_found_exception!\n    end",
        "comment": "Same as #last but raises ActiveRecord::RecordNotFound if no record is found. Note that #last! accepts no arguments.",
        "label": "What",
        "id": "13372"
    },
    {
        "raw_code": "def mark_assignments_as_referenced_in_loop(node)\n        referenced_variable_names_in_loop, assignment_nodes_in_loop = find_variables_in_loop(node)\n\n        referenced_variable_names_in_loop.each do |name|\n          variable = variable_table.find_variable(name)\n          # Non related references which are caught in the above scan\n          # would be skipped here.\n          next unless variable\n\n          loop_assignments = variable.assignments.select do |assignment|\n            assignment_nodes_in_loop.include?(assignment.node)\n          end",
        "comment": "Mark last assignments which are referenced in the same loop as referenced by ignoring AST order since they would be referenced in next iteration.",
        "label": "What",
        "id": "10287"
    },
    {
        "raw_code": "def connection\n      pool = connection_pool\n      if pool.permanent_lease?\n        case ActiveRecord.permanent_connection_checkout\n        when :deprecated\n          ActiveRecord.deprecator.warn <<~MESSAGE\n            Called deprecated `ActiveRecord::Base.connection` method.\n\n            Either use `with_connection` or `lease_connection`.\n          MESSAGE\n        when :disallowed\n          raise ActiveRecordError, <<~MESSAGE\n            Called deprecated `ActiveRecord::Base.connection` method.\n\n            Either use `with_connection` or `lease_connection`.\n          MESSAGE\n        end",
        "comment": "Soft deprecated. Use +#with_connection+ or +#lease_connection+ instead.",
        "label": "What",
        "id": "12407"
    },
    {
        "raw_code": "def top_pods\n          args = [\"--no-headers\", \"--containers\"]\n\n          output = run_in_namespace(\"top\", \"pods\", args: args).split(\"\\n\").map { |line| line.strip.split(/\\s+/) }\n          unless output.all? { |row| row.length == 4 }\n            raise Error, \"Unexpected top pods output: #{output}\\nExpected row format: POD_NAME CONTAINER CPU MEMORY\"\n          end",
        "comment": "Get resource consumption from top pods command  @return [Hash<Array>]",
        "label": "What",
        "id": "3971"
    },
    {
        "raw_code": "def sidekiq_worker_class\n        raise NotImplementedError\n      end",
        "comment": "The Sidekiq worker class used for scheduling the importing of objects in parallel.",
        "label": "What",
        "id": "1818"
    },
    {
        "raw_code": "def apply_file_link_rules!\n          @uri = Addressable::URI.join(@slug, @uri) if @uri.extname.present?\n        end",
        "comment": "Of the form 'file.md'",
        "label": "What",
        "id": "3475"
    },
    {
        "raw_code": "def root_search(req, res)\n    search_index = []\n    info         = []\n\n    installed_docs.map do |name, href, exists, type, path|\n      next unless exists\n\n      search_index << name\n\n      case type\n      when :gem\n        gemspec = path.gsub(%r%/doc/([^/]*?)/ri$%,\n                            '/specifications/\\1.gemspec')\n\n        spec = Gem::Specification.load gemspec\n\n        path    = spec.full_name\n        comment = spec.summary\n      when :system then\n        path    = 'ruby'\n        comment = 'Documentation for the Ruby standard library'\n      when :site then\n        path    = 'site'\n        comment = 'Documentation for non-gem libraries'\n      when :home then\n        path    = 'home'\n        comment = 'Documentation from your home directory'\n      when :extra\n        comment = name\n      end",
        "comment": " Generates a search index for the root page on +res+.  +req+ is ignored.",
        "label": "What",
        "id": "15946"
    },
    {
        "raw_code": "def group_or_project?(resource)\n        %w[group project].include?(resource[:type])\n      end",
        "comment": "Checks if resource type is a group or project  @param [Hash] resource @return [Boolean]",
        "label": "What",
        "id": "4734"
    },
    {
        "raw_code": "def _layout(*); end\n\n    # Determine the layout for a given name, taking into account the name type.\n    #\n    # ==== Parameters\n    # * <tt>name</tt> - The name of the template\n    def _layout_for_option(name)\n      case name\n      when String     then _normalize_layout(name)\n      when Proc       then name\n      when true       then Proc.new { |lookup_context, formats, keys| _default_layout(lookup_context, formats, keys, true)  }\n      when :default   then Proc.new { |lookup_context, formats, keys| _default_layout(lookup_context, formats, keys, false) }\n      when false, nil then nil\n      else\n        raise ArgumentError,\n          \"String, Proc, :default, true, or false, expected for `layout'; you passed #{name.inspect}\"\n      end\n    end",
        "comment": "This will be overwritten by _write_layout_method",
        "label": "What",
        "id": "11729"
    },
    {
        "raw_code": "def import(client, project)\n          info(project.id, message: \"starting importer\", importer: 'Importer::ProtectedBranchesImporter')\n          waiter = Importer::ProtectedBranchesImporter\n            .new(project, client)\n            .execute\n\n          AdvanceStageWorker.perform_async(\n            project.id,\n            { waiter.key => waiter.jobs_remaining },\n            'lfs_objects'\n          )\n        end",
        "comment": "client - An instance of Gitlab::GithubImport::Client. project - An instance of Project.",
        "label": "What",
        "id": "6316"
    },
    {
        "raw_code": "def support_bot_id\n        new.support_bot.id\n      end",
        "comment": "Checks against this bot are now included in every issue and work item detail and list page rendering and in GraphQL queries (especially for determining the web_url of an issue/work item). Because the bot never changes once created, we can memoize it for the lifetime of the application process. It also doesn't matter that different nodes may have different object instances of the bot. We only memoize the id because this is the information we check against.",
        "label": "What",
        "id": "3672"
    },
    {
        "raw_code": "def import_status\n        response = get(Runtime::API::Request.new(api_client, \"/bulk_imports/#{import_id}\").url)\n\n        unless response.code == HTTP_STATUS_OK\n          raise ResourceQueryError, \"Could not get import status. Request returned (#{response.code}): `#{response}`.\"\n        end",
        "comment": "Get import status  @return [String]",
        "label": "What",
        "id": "4142"
    },
    {
        "raw_code": "def execute\n      in_lock(EXCLUSIVE_LOCK_KEY, ttl: LOCK_TIMEOUT, retries: 1) do\n        loop_until(timeout: LOOP_TIMEOUT, limit: LOOP_LIMIT) do\n          recover_in_batch\n        end",
        "comment": " Recover environments that are stuck stopping on a GitLab instance  This auto stop process cannot run for more than 45 minutes. This is for preventing multiple `AutoStopCronWorker` CRON jobs run concurrently, which is scheduled at every hour.",
        "label": "What",
        "id": "5850"
    },
    {
        "raw_code": "def load_seed\n      seed_file = paths[\"db/seeds.rb\"].existent.first\n      run_callbacks(:load_seed) { load(seed_file) } if seed_file\n    end",
        "comment": "Load data from db/seeds.rb file. It can be used in to load engines' seeds, e.g.:  Blog::Engine.load_seed",
        "label": "What",
        "id": "14670"
    },
    {
        "raw_code": "def extra_file_valid?(file, check_exists = true)\n        if file =~ %r{^(?:\\.\\./|/)}\n          log.warn \"Invalid file: #{file}\"\n          false\n        elsif check_exists && !File.file?(file)\n          log.warn \"Could not find file: #{file}\"\n          false\n        else\n          true\n        end",
        "comment": "@param file [String] the filename to validate @param check_exists [Boolean] whether the file should exist on disk @return [Boolean] whether the file is allowed to be used",
        "label": "What",
        "id": "535"
    },
    {
        "raw_code": "def accepts_nested_attributes_for(*attr_names)\n        options = { allow_destroy: false, update_only: false }\n        options.update(attr_names.extract_options!)\n        options.assert_valid_keys(:allow_destroy, :reject_if, :limit, :update_only)\n        options[:reject_if] = REJECT_ALL_BLANK_PROC if options[:reject_if] == :all_blank\n\n        attr_names.each do |association_name|\n          if reflection = _reflect_on_association(association_name)\n            reflection.autosave = true\n            define_autosave_validation_callbacks(reflection)\n\n            nested_attributes_options = self.nested_attributes_options.dup\n            nested_attributes_options[association_name.to_sym] = options\n            self.nested_attributes_options = nested_attributes_options\n\n            type = (reflection.collection? ? :collection : :one_to_one)\n            generate_association_writer(association_name, type)\n          else\n            raise ArgumentError, \"No association found for name `#{association_name}'. Has it been defined yet?\"\n          end",
        "comment": "Defines an attributes writer for the specified association(s).  Supported options: [:allow_destroy] If true, destroys any members from the attributes hash with a <tt>_destroy</tt> key and a value that evaluates to +true+ (e.g. 1, '1', true, or 'true'). This option is false by default. [:reject_if] Allows you to specify a Proc or a Symbol pointing to a method that checks whether a record should be built for a certain attribute hash. The hash is passed to the supplied Proc or the method and it should return either +true+ or +false+. When no +:reject_if+ is specified, a record will be built for all attribute hashes that do not have a <tt>_destroy</tt> value that evaluates to true. Passing <tt>:all_blank</tt> instead of a Proc will create a proc that will reject a record where all the attributes are blank excluding any value for +_destroy+. [:limit] Allows you to specify the maximum number of associated records that can be processed with the nested attributes. Limit also can be specified as a Proc or a Symbol pointing to a method that should return a number. If the size of the nested attributes array exceeds the specified limit, NestedAttributes::TooManyRecords exception is raised. If omitted, any number of associations can be processed. Note that the +:limit+ option is only applicable to one-to-many associations. [:update_only] For a one-to-one association, this option allows you to specify how nested attributes are going to be used when an associated record already exists. In general, an existing record may either be updated with the new set of attribute values or be replaced by a wholly new record containing those values. By default the +:update_only+ option is false and the nested attributes are used to update the existing record only if they include the record's <tt>:id</tt> value. Otherwise a new record will be instantiated and used to replace the existing one. However if the +:update_only+ option is true, the nested attributes are used to update the record's attributes always, regardless of whether the <tt>:id</tt> is present. The option is ignored for collection associations.  Examples: # creates avatar_attributes= accepts_nested_attributes_for :avatar, reject_if: proc { |attributes| attributes['name'].blank? } # creates avatar_attributes= accepts_nested_attributes_for :avatar, reject_if: :all_blank # creates avatar_attributes= and posts_attributes= accepts_nested_attributes_for :avatar, :posts, allow_destroy: true",
        "label": "What",
        "id": "12530"
    },
    {
        "raw_code": "def handle_method(type, var_name, meth_name, function, param_count,\n                    source_file = nil)\n    class_name = @known_classes[var_name]\n    singleton  = @singleton_classes.key? var_name\n\n    @methods[var_name][function] << meth_name\n\n    return unless class_name\n\n    class_obj = find_class var_name, class_name\n\n    if existing_method = class_obj.method_list.find { |m| m.c_function == function }\n      add_alias(var_name, class_obj, existing_method.name, meth_name, existing_method.comment)\n    end",
        "comment": " Adds an RDoc::AnyMethod +meth_name+ defined on a class or module assigned to +var_name+.  +type+ is the type of method definition function used. +singleton_method+ and +module_function+ create a singleton method.",
        "label": "What",
        "id": "16163"
    },
    {
        "raw_code": "def distutils\n    site_packages(libexec).parent/\"distutils\"\n  end",
        "comment": "The Cellar location of distutils",
        "label": "What",
        "id": "33"
    },
    {
        "raw_code": "def run_create_task(task)\n      build_backup_information\n\n      unless task.enabled?\n        logger.info \"Dumping #{task.human_name} ... \" + \"[DISABLED]\"\n        return true\n      end",
        "comment": "@param [Gitlab::Backup::Tasks::Task] task @return [Boolean] whether the task succeeded",
        "label": "What",
        "id": "3627"
    },
    {
        "raw_code": "def execute\n        # Get the timeout, if we have one\n        timeout = @options[:timeout]\n\n        # Get the working directory\n        workdir = @options[:workdir] || Dir.pwd\n\n        # Get what we're interested in being notified about\n        notify  = @options[:notify] || []\n        notify  = [notify] if !notify.is_a?(Array)\n        if notify.empty? && block_given?\n          # If a block is given, subscribers must be given, otherwise the\n          # block is never called. This is usually NOT what you want, so this\n          # is an error.\n          message = \"A list of notify subscriptions must be given if a block is given\"\n          raise ArgumentError, message\n        end",
        "comment": "Start the process  @return [Result]",
        "label": "What",
        "id": "9290"
    },
    {
        "raw_code": "def after_save_commit\n          return unless target_work_item.get_widget(:hierarchy)\n\n          handle_parent\n\n          # we only handle child items for `move` functionality, `clone` does not copy child items.\n          return unless params[:operation] == :move\n\n          handle_children\n        end",
        "comment": "overriden in EE",
        "label": "What",
        "id": "6032"
    },
    {
        "raw_code": "def list_org_dependabot_secrets(org)\n        paginate \"#{Organization.path org}/dependabot/secrets\" do |data, last_response|\n          data.secrets.concat last_response.data.secrets\n        end",
        "comment": "List org secrets  @param org [String] A GitHub organization @return [Hash] total_count and list of secrets (each item is hash with name, created_at and updated_at) @see https://docs.github.com/en/rest/dependabot/organization-secrets?apiVersion=2022-11-28#list-organization-secrets",
        "label": "What",
        "id": "14988"
    },
    {
        "raw_code": "def initialize(dry_run: false, exclude_groups: nil)\n        super(dry_run: dry_run)\n\n        @type = 'group'\n        @exclude_groups = Array(exclude_groups.to_s.split(',')) + EXCLUDE_GROUPS\n        @permanently_delete = false # this option is only available for subgroups\n      end",
        "comment": "@example - delete user groups older than 24 hours GITLAB_ADDRESS=<address> \\ GITLAB_QA_ACCESS_TOKEN=<token> \\ bundle exec rake delete_user_groups  @example - delete all user groups older than 2019-01-01 GITLAB_ADDRESS=<address> \\ GITLAB_QA_ACCESS_TOKEN=<token> \\ DELETE_BEFORE=2019-01-01 \\ bundle exec rake delete_user_groups  @example - dry run GITLAB_ADDRESS=<address> \\ GITLAB_QA_ACCESS_TOKEN=<token> \\ bundle exec rake \"delete_user_groups[true]\"",
        "label": "What",
        "id": "4722"
    },
    {
        "raw_code": "def default(header: nil, body: \"Every card has a body.\", footer: nil)\n      render(Pajamas::CardComponent.new) do |c|\n        c.with_header { header } if header\n\n        c.with_body do\n          content_tag(:p, body)\n        end",
        "comment": "Card ---- See its design reference [here](https://design.gitlab.com/components/card).  @param header text @param body textarea @param footer text",
        "label": "What",
        "id": "8194"
    },
    {
        "raw_code": "def append_message(message)\n        log << message\n      end",
        "comment": "We always want to append in-place on the log",
        "label": "What",
        "id": "2075"
    },
    {
        "raw_code": "def bar\n            do_something # rubocop:disable Metrics - note\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^ Unnecessary disabling of `Metrics` department.\n          end",
        "comment": "rubocop:disable Metrics",
        "label": "What",
        "id": "10961"
    },
    {
        "raw_code": "def compute_asset_path(source, options = {})\n        dir = ASSET_PUBLIC_DIRECTORIES[options[:type]] || \"\"\n        File.join(dir, source)\n      end",
        "comment": "Computes asset path to public directory. Plugins and extensions can override this method to point to custom assets or generate digested paths or query strings.",
        "label": "What",
        "id": "11792"
    },
    {
        "raw_code": "def extract_partial_keyword(partial_filename)\n        File.basename(partial_filename).delete_prefix('_').delete_suffix('.html.haml')\n      end",
        "comment": "e.g. if app/views/clusters/clusters/_sidebar.html.haml was modified, the partial keyword is `sidebar`.",
        "label": "What",
        "id": "8099"
    },
    {
        "raw_code": "def compute_table_name\n          if base_class?\n            # Nested classes are prefixed with singular parent table name.\n            if module_parent < Base && !module_parent.abstract_class?\n              contained = module_parent.table_name\n              contained = contained.singularize if module_parent.pluralize_table_names\n              contained += \"_\"\n            end",
        "comment": "Computes and returns a table name according to default conventions.",
        "label": "What",
        "id": "12529"
    },
    {
        "raw_code": "def self.host_capability(host, cap, &block)\n          components.host_capabilities[host.to_sym].register(cap.to_sym, &block)\n          nil\n        end",
        "comment": "Defines a capability for the given host. The block should return a class/module that has a method with the capability name, ready to be executed. This means that if it is an instance method, the block should return an instance of the class.  @param [String] host The name of the host @param [String] cap The name of the capability",
        "label": "What",
        "id": "9110"
    },
    {
        "raw_code": "def =~(re)\n      re === name || re === MAPPING[name]\n    end",
        "comment": "Compare #name and TZInfo identifier to a supplied regexp, returning +true+ if a match is found.",
        "label": "What",
        "id": "14565"
    },
    {
        "raw_code": "def server_port\n          @server_port ||= random_port\n        end",
        "comment": "Random open port for server  @return [Integer]",
        "label": "What",
        "id": "4232"
    },
    {
        "raw_code": "def drag_active?\n    page.evaluate_script('window.SIMULATE_DRAG_ACTIVE').nonzero?\n  end",
        "comment": "rubocop:enable Metrics/ParameterLists",
        "label": "What",
        "id": "8440"
    },
    {
        "raw_code": "def create_language(name, color)\n      ProgrammingLanguage.transaction do\n        ProgrammingLanguage.where(name: name).first_or_create(color: color)\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5892"
    },
    {
        "raw_code": "def foo\n        something\n      end",
        "comment": "comment",
        "label": "What",
        "id": "10796"
    },
    {
        "raw_code": "def workfile_path(for_file = original_filename)\n    # To be safe, keep this directory outside of the the cache directory\n    # because calling CarrierWave.clean_cache_files! will remove any files in\n    # the cache directory.\n    File.join(work_dir, cache_id, version_name.to_s, for_file)\n  end",
        "comment": "To prevent files from moving across filesystems, override the default implementation: http://github.com/carrierwaveuploader/carrierwave/blob/v1.0.0/lib/carrierwave/uploader/cache.rb#L181-L183",
        "label": "What",
        "id": "8061"
    },
    {
        "raw_code": "def execute\n      in_lock(EXCLUSIVE_LOCK_KEY, ttl: LOCK_TIMEOUT, retries: 1) do\n        loop_until(timeout: LOOP_TIMEOUT, limit: LOOP_LIMIT) do\n          stop_in_batch\n        end",
        "comment": " Stop expired environments on GitLab instance  This auto stop process cannot run for more than 45 minutes. This is for preventing multiple `AutoStopCronWorker` CRON jobs run concurrently, which is scheduled at every hour.",
        "label": "What",
        "id": "5848"
    },
    {
        "raw_code": "def primary_key\n      'id'\n    end",
        "comment": "Used by ActiveRecord's polymorphic association to set object_id",
        "label": "What",
        "id": "1325"
    },
    {
        "raw_code": "def add_tag(*tags)\n      tags.each_with_index do |tag, i|\n        case tag\n        when Tags::Tag\n          tag.object = object\n          @tags << tag\n        when Tags::RefTag, Tags::RefTagList\n          @ref_tags << tag\n        else\n          raise ArgumentError, \"expected Tag or RefTag, got #{tag.class} (at index #{i})\"\n        end",
        "comment": "@group Creating and Accessing Meta-data Adds a tag or reftag object to the tag list. If you want to parse tag data based on the {Tags::DefaultFactory} tag factory, use {DocstringParser} instead.  @param [Tags::Tag, Tags::RefTag] tags list of tag objects to add @return [void]",
        "label": "What",
        "id": "130"
    },
    {
        "raw_code": "def labels_for_issue(repo, number, options = {})\n        paginate \"#{Repository.path repo}/issues/#{number}/labels\", options\n      end",
        "comment": "List labels for a given issue  @param repo [Integer, String, Repository, Hash] A GitHub repository @param number [Integer] Number ID of the issue @return [Array<Sawyer::Resource>] A list of the labels currently on the issue @see https://developer.github.com/v3/issues/labels/#list-labels-on-an-issue @example List labels for octokit/octokit.rb, issue # 1 Octokit.labels_for_issue(\"octokit/octokit.rb\", 1)",
        "label": "What",
        "id": "15289"
    },
    {
        "raw_code": "def self.process(context)\n          return Gitlab::Fp::Result.ok(context) if Rails.env.production?\n\n          context => {\n            env_var_prefix: String => env_var_prefix,\n            env_var_failed_message_class: Class => env_var_failed_message_class,\n          }\n\n          err_result = nil\n          context[:settings].each_key do |setting_name|\n            env_var_name = \"#{env_var_prefix}_#{setting_name.to_s.upcase}\"\n            env_var_value_string = ENV[env_var_name]\n\n            # If there is no matching ENV var, break the loop and go to the next setting\n            next unless env_var_value_string\n\n            begin\n              env_var_value = cast_value(\n                env_var_name: env_var_name,\n                env_var_value_string: env_var_value_string,\n                setting_type: context[:setting_types][setting_name]\n              )\n            rescue RuntimeError => e\n              # err_result will be set to a non-nil Gitlab::Fp::Result.err if casting fails\n              err_result = Gitlab::Fp::Result.err(env_var_failed_message_class.new(details: e.message))\n            end",
        "comment": "@param [Hash] context @return [Gitlab::Fp::Result]",
        "label": "What",
        "id": "2405"
    },
    {
        "raw_code": "def add_module_by_normal_module(mod)\n    add_class_or_module mod, @modules, @store.modules_hash\n  end",
        "comment": " Adds a module by +RDoc::NormalModule+ instance. See also #add_module.",
        "label": "What",
        "id": "16645"
    },
    {
        "raw_code": "def handle_singleton(sclass_var, class_var)\n    class_name = @known_classes[class_var]\n\n    @known_classes[sclass_var]     = class_name\n    @singleton_classes[sclass_var] = class_name\n  end",
        "comment": " Registers a singleton class +sclass_var+ as a singleton of +class_var+",
        "label": "What",
        "id": "16164"
    },
    {
        "raw_code": "def pp(result)\n          result.rows.map do |row|\n            row.join(\"|\")\n          end.join(\"\\n\") + \"\\n\"\n        end",
        "comment": "Pretty prints the result of an EXPLAIN QUERY PLAN in a way that resembles the output of the SQLite shell:  0|0|0|SEARCH TABLE users USING INTEGER PRIMARY KEY (rowid=?) (~1 rows) 0|1|1|SCAN TABLE posts (~100000 rows) ",
        "label": "What",
        "id": "13282"
    },
    {
        "raw_code": "def find_class_or_module(name)\n    name = $' if name =~ /^::/\n    @classes_hash[name] || @modules_hash[name]\n  end",
        "comment": " Finds the class or module with +name+",
        "label": "What",
        "id": "15864"
    },
    {
        "raw_code": "def provider(name, &block)\n        name = name.to_sym\n        @__providers[name] ||= []\n        @__provider_overrides[name] ||= []\n\n        # Add the provider to the ordering list\n        @__provider_order << name\n\n        if block_given?\n          @__providers[name] << block if block_given?\n\n          # If this block takes two arguments, then we curry it and store\n          # the configuration override for use later.\n          if block.arity == 2\n            @__provider_overrides[name] << block.curry[Vagrant::Config::V2::DummyConfig.new]\n          end",
        "comment": "Configures a provider for this VM.  @param [Symbol] name The name of the provider.",
        "label": "What",
        "id": "9451"
    },
    {
        "raw_code": "def to_h\n        clear_enrollment_queue\n        @cops_by_cop_name\n      end",
        "comment": "@return [Hash{String => Array<Class>}]",
        "label": "What",
        "id": "10212"
    },
    {
        "raw_code": "def setup\n      self.class.load_yard\n\n      if File.exist?(@doc_dir)\n        raise Gem::FilePermissionError, @doc_dir unless File.writable?(@doc_dir)\n      else\n        FileUtils.mkdir_p @doc_dir\n      end",
        "comment": " Prepares the spec for documentation generation",
        "label": "What",
        "id": "255"
    },
    {
        "raw_code": "def quote_table_name(table_name)\n          quote_column_name(table_name)\n        end",
        "comment": "Quotes the table name. Defaults to column name quoting.",
        "label": "What",
        "id": "13088"
    },
    {
        "raw_code": "def disconnect!(timeout: 120)\n          start_time = ::Gitlab::Metrics::System.monotonic_time\n\n          while (::Gitlab::Metrics::System.monotonic_time - start_time) <= timeout\n            return if try_disconnect\n\n            sleep(2)\n          end",
        "comment": "Disconnects the pool, once all connections are no longer in use.  timeout - The time after which the pool should be forcefully disconnected.",
        "label": "What",
        "id": "3068"
    },
    {
        "raw_code": "def self.hooks # :nodoc:\n          @hooks ||= from_superclass(:hooks, {})\n        end",
        "comment": "Keep hooks configuration that are used on prepare_for_invocation.",
        "label": "What",
        "id": "14775"
    },
    {
        "raw_code": "def move_pos(src, pos, step, condition, regexp)\n        offset = step == -1 ? -1 : 0\n        pos += step while condition && regexp.match?(src[pos + offset])\n        pos.negative? ? 0 : pos\n      end",
        "comment": "rubocop:enable Metrics/ParameterLists",
        "label": "What",
        "id": "10443"
    },
    {
        "raw_code": "def service_acount_token_type\n        'kubernetes.io/service-account-token'\n      end",
        "comment": "as per https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/#to-create-additional-api-tokens",
        "label": "What",
        "id": "2068"
    },
    {
        "raw_code": "def find_pipeline(id)\n      return unless id\n\n      if INTEGER_ID_REGEX.match?(id.to_s)\n        ::Ci::Pipeline.find_by(id: id)\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3773"
    },
    {
        "raw_code": "def self.resolver_complexity(args, child_complexity:)\n      super + (args[:paths] || []).size\n    end",
        "comment": "We fetch blobs from Gitaly efficiently but it still scales O(N) with the number of paths being fetched, so apply a scaling limit to that.",
        "label": "What",
        "id": "6174"
    },
    {
        "raw_code": "def h(text)\n        CGI.escapeHTML(text.to_s)\n      end",
        "comment": "@group Escaping Template Data Escapes HTML entities  @param [String] text the text to escape @return [String] the HTML with escaped entities",
        "label": "What",
        "id": "385"
    },
    {
        "raw_code": "def primary_keys(table_name) # :nodoc:\n        pks = table_structure(table_name).select { |f| f[\"pk\"] > 0 }\n        pks.sort_by { |f| f[\"pk\"] }.map { |f| f[\"name\"] }\n      end",
        "comment": "SCHEMA STATEMENTS ========================================",
        "label": "What",
        "id": "12994"
    },
    {
        "raw_code": "def delete_batch!(klass)\n      deleted = 0\n\n      klass.transaction do\n        ids = klass.deletable.lock('FOR UPDATE SKIP LOCKED').limit(BATCH_SIZE).pluck(:id)\n        deleted = klass.where(id: ids).delete_all if ids.any?\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5797"
    },
    {
        "raw_code": "def flush_idle_connections!(role = nil)\n        each_connection_pool(role).each(&:flush!)\n      end",
        "comment": "Disconnects all currently idle connections.  See ConnectionPool#flush! for details.",
        "label": "What",
        "id": "13006"
    },
    {
        "raw_code": "def create_merge_request_without_hooks(project, attributes, iid)\n        # This work must be wrapped in a transaction as otherwise we can leave\n        # behind incomplete data in the event of an error. This can then lead\n        # to duplicate key errors when jobs are retried.\n        MergeRequest.transaction do\n          # When creating merge requests there are a lot of hooks that may\n          # run, for many different reasons. Many of these hooks (e.g. the\n          # ones used for rendering Markdown) are completely unnecessary and\n          # may even lead to transaction timeouts.\n          #\n          # To ensure importing pull requests has a minimal impact and can\n          # complete in a reasonable time we bypass all the hooks by inserting\n          # the row and then retrieving it. We then only perform the\n          # additional work that is strictly necessary.\n          merge_request_id = insert_and_return_id(attributes, project.merge_requests)\n\n          merge_request = project.merge_requests.reset.find(merge_request_id)\n\n          [merge_request, false]\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2920"
    },
    {
        "raw_code": "def unsafe_execute!(environment)\n      if params[:force]\n        actions = []\n\n        environment.stop_complete!\n      else\n        actions = environment.stop_with_actions!\n      end",
        "comment": " Stops the environment without checking user permissions. This should only be used if initiated by a system action and a user cannot be specified.",
        "label": "What",
        "id": "5851"
    },
    {
        "raw_code": "def scenario_runtimes\n          @scenario_runtimes ||= scenario_examples\n            .each_with_object(Hash.new { |hsh, key| hsh[key] = 0 }) do |(scenario, examples), runtimes|\n              next unless scenario.pipeline_mapping\n\n              executable_examples = examples.reject { |example| example[:status] == \"pending\" }\n              # set runtime to 0 if particular scenario would skip all tests\n              next runtimes[scenario] = 0 if executable_examples.empty?\n\n              # Sum total runtime for all examples in scenario\n              # Default to small value if runtimes report has no value for particular example\n              # in order to not skip scenario entirely if report simply hasn't runtime data yet\n              executable_examples.each { |example| runtimes[scenario] += example_runtimes[example[:id]] || 0.01 }\n            end",
        "comment": "Total runtime value for each scenario that has pipeline mapping defined  @return [Hash<Class, Number>]",
        "label": "What",
        "id": "4783"
    },
    {
        "raw_code": "def filter_by_project_environment(items, app, env)\n      filter_by_annotation(items, {\n        'app.gitlab.com/app' => app,\n        'app.gitlab.com/env' => env\n      })\n    end",
        "comment": "Filters an array of pods (as returned by the kubernetes API) by their project and environment",
        "label": "What",
        "id": "1515"
    },
    {
        "raw_code": "def verify_deletions(unverified_deletions, permanent)\n        logger.info('Verifying deletions...')\n\n        unverified_deletions.filter_map do |resource|\n          wait_for_resource_deletion(resource, permanent: permanent)\n          response = get(resource_request(resource))\n\n          if response&.code == HTTP_STATUS_NOT_FOUND\n            log_permanent_deletion(resource)\n          else\n            log_failure(resource, response)\n          end",
        "comment": "Verifies deletions of given resources by attempting to find them. If the resource is found, logs a failure. Used with delayed_verification.  @param [Array<Hash>] unverified_deletions List of resources that were not verified @param [Boolean] permanent If resource is permanently deleted or only marked for deletion @return [void]",
        "label": "What",
        "id": "4747"
    },
    {
        "raw_code": "def self.set_ssh_key_permissions(env, key_path)\n          key_path.chmod(0600)\n        end",
        "comment": "Set the ownership and permissions for SSH private key  @param [Vagrant::Environment] env @param [Pathname] key_path",
        "label": "What",
        "id": "9714"
    },
    {
        "raw_code": "def latest_source_head?(suggestion)\n        suggestion.position.head_sha == suggestion.noteable.source_branch_sha\n      end",
        "comment": "Checks whether the latest source branch HEAD matches with the position HEAD we're using to update the file content. Since the persisted HEAD is updated async (for MergeRequest), it's more consistent to fetch this data directly from the repository.",
        "label": "What",
        "id": "2757"
    },
    {
        "raw_code": "def remove_key(id)\n      lock do\n        logger.info(\"Removing key (#{id})\")\n        open_authorized_keys_file('r+') do |f|\n          while line = f.gets\n            next unless line.start_with?(\"command=\\\"#{command(id)}\\\"\")\n\n            f.seek(-line.length, IO::SEEK_CUR)\n            # Overwrite the line with #'s. Because the 'line' variable contains\n            # a terminating '\\n', we write line.length - 1 '#' characters.\n            f.write('#' * (line.length - 1))\n          end",
        "comment": "Remove key by ID from the authorized_keys file  @param [String] id identifier of the key to be removed prefixed by `key-` @return [Boolean]",
        "label": "What",
        "id": "1688"
    },
    {
        "raw_code": "def puts(content, stderr: false)\n            stderr ? warn(timestamp_format(content)) : $stdout.puts(timestamp_format(content))\n          end",
        "comment": "Display provided content in a new line with a timestamp  @param [String] content the content to be displayed @param [Boolean] stderr when true outputs to stderr instead of stdout",
        "label": "What",
        "id": "1035"
    },
    {
        "raw_code": "def concerning(topic, prepend: false, &block)\n      method = prepend ? :prepend : :include\n      __send__(method, concern(topic, &block))\n    end",
        "comment": "Define a new concern and mix it in.",
        "label": "What",
        "id": "14270"
    },
    {
        "raw_code": "def enabled?\n      return false unless feature_flag_defined?\n      return false unless available?\n      return false unless ::Feature.enabled?(:gitlab_experiment, type: :ops)\n\n      feature_flag_instance.state != :off\n    end",
        "comment": "For this rollout strategy to consider an experiment as enabled, we must:  - have a feature flag yaml file that declares it. - be in an environment that permits it. - not have rolled out the feature flag at all (no percent of actors, no inclusions, etc.)",
        "label": "What",
        "id": "1721"
    },
    {
        "raw_code": "def transfer\n    return access_denied! unless can?(current_user, :change_namespace, @project)\n\n    namespace = Namespace.find_by(id: params[:new_namespace_id])\n    ::Projects::TransferService.new(project, current_user).execute(namespace)\n\n    if @project.errors[:new_namespace].present?\n      flash[:alert] = @project.errors[:new_namespace].first\n      return redirect_to edit_project_path(@project)\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6432"
    },
    {
        "raw_code": "def etag(&etagger)\n        self.etaggers += [etagger]\n      end",
        "comment": "Allows you to consider additional controller-wide information when generating an ETag. For example, if you serve pages tailored depending on who's logged in at the moment, you may want to add the current user id to be part of the ETag to prevent unauthorized displaying of cached pages.  class InvoicesController < ApplicationController etag { current_user&.id }  def show # Etag will differ even for the same invoice when it's viewed by a different current_user @invoice = Invoice.find(params[:id]) fresh_when etag: @invoice end end",
        "label": "What",
        "id": "11249"
    },
    {
        "raw_code": "def migrate_files_to_external_storage!\n    return if stored_externally? || !use_external_diff? || files_count == 0\n\n    rows = build_merge_request_diff_files(merge_request_diff_files)\n    rows = build_external_merge_request_diff_files(rows)\n\n    # Perform carrierwave activity before entering the database transaction.\n    # This is safe as until the `external_diff_store` column is changed, we will\n    # continue to consult the in-database content.\n    self.external_diff.store!\n\n    transaction do\n      MergeRequestDiffFile.where(merge_request_diff_id: id).delete_all\n      ApplicationRecord.legacy_bulk_insert('merge_request_diff_files', rows) # rubocop:disable Gitlab/BulkInsert\n      save!\n    end",
        "comment": "Transactionally migrate the current merge_request_diff_files entries to external storage. If external storage isn't an option for this diff, the method is a no-op.",
        "label": "What",
        "id": "6870"
    },
    {
        "raw_code": "def by_action(events)\n    safe_action = Event.actions[params[:action]]\n    return events unless safe_action\n\n    events.where(action: safe_action)\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7932"
    },
    {
        "raw_code": "def valid_request_origin? # :doc:\n        if forgery_protection_origin_check\n          # We accept blank origin headers because some user agents don't send it.\n          raise InvalidAuthenticityToken, NULL_ORIGIN_MESSAGE if request.origin == \"null\"\n          request.origin.nil? || request.origin == request.base_url\n        else\n          true\n        end",
        "comment": "Checks if the request originated from the same origin by looking at the Origin header.",
        "label": "What",
        "id": "11347"
    },
    {
        "raw_code": "def entries\n            return @entries if defined?(@entries)\n\n            @entries = database_configurations.map do |config|\n              Database.new(config)\n            end",
        "comment": "All unique configured databases (excluding hidden/partitions)",
        "label": "What",
        "id": "1073"
    },
    {
        "raw_code": "def persist_object_store?\n      model.respond_to?(:\"#{store_serialization_column}=\")\n    end",
        "comment": "rubocop:enable Gitlab/ModuleWithInstanceVariables Return true if the current file is part or the model (i.e. is mounted in the model) ",
        "label": "What",
        "id": "8044"
    },
    {
        "raw_code": "def child_teams(team_id, options = {})\n        paginate \"teams/#{team_id}/teams\", options\n      end",
        "comment": "List child teams  Requires authenticated organization member.  @param team_id [Integer] Team id. @return [Sawyer::Resource] Hash representing team. @see https://developer.github.com/v3/orgs/teams/#list-child-teams @example @client.child_teams(100000, :accept => \"application/vnd.github.hellcat-preview+json\")",
        "label": "What",
        "id": "15434"
    },
    {
        "raw_code": "def autocorrect_action\n        LanguageServer::Protocol::Interface::CodeAction.new(\n          title: \"Autocorrect #{@offense.cop_name}\",\n          kind: LanguageServer::Protocol::Constant::CodeActionKind::QUICK_FIX,\n          edit: LanguageServer::Protocol::Interface::WorkspaceEdit.new(\n            document_changes: [\n              LanguageServer::Protocol::Interface::TextDocumentEdit.new(\n                text_document: LanguageServer::Protocol::Interface::OptionalVersionedTextDocumentIdentifier.new(\n                  uri: ensure_uri_scheme(@uri.to_s).to_s,\n                  version: nil\n                ),\n                edits: correctable? ? offense_replacements : []\n              )\n            ]\n          ),\n          is_preferred: true\n        )\n      end",
        "comment": "rubocop:disable Metrics/MethodLength",
        "label": "What",
        "id": "10201"
    },
    {
        "raw_code": "def self.expire(jid, expire = DEFAULT_EXPIRATION)\n      with_redis do |redis|\n        redis.expire(key_for(jid), expire.to_i)\n      end",
        "comment": "Refreshes the timeout on the key if it exists  jid = The Sidekiq job ID expire - The expiration time of the Redis key.",
        "label": "What",
        "id": "1469"
    },
    {
        "raw_code": "def perform\n        each_sub_batch do |sub_batch|\n          # rubocop:disable Rails/FindEach -- This already operates on a sub_batch\n          sub_batch.where(\"name LIKE '%/%'\").each do |src_component|\n            dst_component = Component.find_by(\n              name: component_name_without_os_prefix(src_component.name),\n              purl_type: src_component.purl_type,\n              component_type: src_component.component_type,\n              organization_id: src_component.organization_id\n            )\n\n            # This uses loop based batching to efficiently iterate over\n            # all occurrences. Since we update the component_id column,\n            # this will eventually return no results and break out of the\n            # loop.\n            loop do\n              occurrences = Occurrence.includes(:component_version)\n                .where(component_id: src_component.id)\n                .limit(OCCURRENCE_BATCH_SIZE)\n\n              break unless occurrences.present?\n\n              component_version_attributes = build_component_version_attributes(dst_component, occurrences)\n\n              component_versions = bulk_upsert_component_versions(component_version_attributes).to_h do |row|\n                [row['version'], row['id']]\n              end",
        "comment": "rubocop:disable Metrics/AbcSize -- It went above limit when adding support for organization_id sharding key.",
        "label": "What",
        "id": "3265"
    },
    {
        "raw_code": "def feature_flags\n          return @feature_flags if defined?(@feature_flags)\n\n          @feature_flags ||= options[:set_feature_flags] || feature_flags_from_env\n        end",
        "comment": "Feature flags to set  @return [<String, nil>]",
        "label": "What",
        "id": "4435"
    },
    {
        "raw_code": "def update_repository_invitation(repo, invitation_id, options = {})\n        patch \"#{Repository.path repo}/invitations/#{invitation_id}\", options\n      end",
        "comment": "Update an invitation for a repository  Requires authenticated client  @param repo [Integer, String, Repository, Hash] A GitHub repository @param invitation_id [Integer] The id of the invitation @return [Sawyer::Resource] The updated repository invitation @see https://developer.github.com/v3/repos/invitations/#update-a-repository-invitation",
        "label": "What",
        "id": "15398"
    },
    {
        "raw_code": "def hash\n      1\n    end",
        "comment": "this isn't very realistic, but it is the worst case and therefore a good case to test",
        "label": "What",
        "id": "13525"
    },
    {
        "raw_code": "def user_events(user, options = {})\n        paginate \"#{User.path user}/events\", options\n      end",
        "comment": "List all user events  @param user [Integer, String] GitHub user login or id. @return [Array<Sawyer::Resource>] A list of all user events @see https://developer.github.com/v3/activity/events/#list-events-performed-by-a-user @example List all user events Octokit.user_events(\"sferik\")",
        "label": "What",
        "id": "15231"
    },
    {
        "raw_code": "def inspect\n          typeinfo = type && type != :list ? ':' + type.to_s + ', ' : ''\n          's(' + typeinfo + map(&:inspect).join(\", \") + ')'\n        end",
        "comment": "@return [String] inspects the object",
        "label": "What",
        "id": "325"
    },
    {
        "raw_code": "def puts_with_offset(io, message)\n          offset = nested_spinner? ? \"  \" : \"\"\n          io.puts(message.split(\"\\n\").map { |line| \"#{offset}#{line}\" }.join(\"\\n\"))\n        end",
        "comment": "Print output with a leading offset for correct nested spinner display  @param [IO] io @param [String] message @return [void]",
        "label": "What",
        "id": "4066"
    },
    {
        "raw_code": "def references(node, cte_refs)\n              refs = {}\n\n              return refs unless node\n\n              node.from_clause.each do |from|\n                range_var = Node.dig(from, :range_var)\n                range_sq = Node.dig(from, :range_subselect)\n\n                if range_var\n                  # FROM some_table\n                  # FROM some_table some_alias\n                  refs.merge!(range_var_reference(range_var, cte_refs))\n                elsif Node.dig(from, :join_expr)\n                  # FROM some_table INNER JOIN other_table\n                  range_vars = Node.locate_descendants(from, :range_var)\n                  range_vars.each do |range_var|\n                    refs.merge!(range_var_reference(range_var, cte_refs))\n                  end",
        "comment": "Parse the FROM part of the SELECT. Construct a mapping of FROM names to their PgQuery node. Recurse any sub-queries and resolve to a Set of dynamic/static/error.  Whenever a node is aliased, use the alias name as it's reference and ignore it's original name.  For example, given:  SELECT id FROM namespaces ns  Return a Hash of { 'ns' => NodeObject }  @param [PgQuery::Node] node The PgQuery SELECT statement node containing the CTEs. @param [References] cte_refs Inherited CTEs from scopes that wrap this SELECT statement.  @return [Hash] name of from references mapped to the node that defines their value, or Set if already resolved.",
        "label": "What",
        "id": "3194"
    },
    {
        "raw_code": "def self.set_default_disk_ext(machine)\n          DEFAULT_DISK_EXT\n        end",
        "comment": "@param [Vagrant::Machine] machine @return [String]",
        "label": "What",
        "id": "9620"
    },
    {
        "raw_code": "def on_interpolation(node)\n          node.each_child_node(:if) do |child_node|\n            if style == :trailing_conditional\n              if empty_if_outcome?(child_node)\n                ternary_style_autocorrect(child_node, child_node.else_branch.source, 'unless')\n              end",
        "comment": "rubocop:disable Metrics/AbcSize, Metrics/MethodLength, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10556"
    },
    {
        "raw_code": "def validates_format_of(*attr_names)\n        validates_with FormatValidator, _merge_attributes(attr_names)\n      end",
        "comment": "Validates whether the value of the specified attribute is of the correct form, going by the regular expression provided. You can require that the attribute matches the regular expression:  class Person < ActiveRecord::Base validates_format_of :email, with: /\\A([^@\\s]+)@((?:[-a-z0-9]+\\.)+[a-z]{2,})\\z/i, on: :create end  Alternatively, you can require that the specified attribute does _not_ match the regular expression:  class Person < ActiveRecord::Base validates_format_of :email, without: /NOSPAM/ end  You can also provide a proc or lambda which will determine the regular expression that will be used to validate the attribute.  class Person < ActiveRecord::Base # Admin can have number as a first letter in their screen name validates_format_of :screen_name, with: ->(person) { person.admin? ? /\\A[a-z0-9][a-z0-9_\\-]*\\z/i : /\\A[a-z][a-z0-9_\\-]*\\z/i } end  Note: use <tt>\\A</tt> and <tt>\\z</tt> to match the start and end of the string, <tt>^</tt> and <tt>$</tt> match the start/end of a line.  Due to frequent misuse of <tt>^</tt> and <tt>$</tt>, you need to pass the <tt>multiline: true</tt> option in case you use any of these two anchors in the provided regular expression. In most cases, you should be using <tt>\\A</tt> and <tt>\\z</tt>.  You must pass either <tt>:with</tt> or <tt>:without</tt> as an option. In addition, both must be a regular expression or a proc or lambda, or else an exception will be raised.  Configuration options: * <tt>:message</tt> - A custom error message (default is: \"is invalid\"). * <tt>:with</tt> - Regular expression that if the attribute matches will result in a successful validation. This can be provided as a proc or lambda returning regular expression which will be called at runtime. * <tt>:without</tt> - Regular expression that if the attribute does not match will result in a successful validation. This can be provided as a proc or lambda returning regular expression which will be called at runtime. * <tt>:multiline</tt> - Set to true if your regular expression contains anchors that match the beginning or end of lines as opposed to the beginning or end of the string. These anchors are <tt>^</tt> and <tt>$</tt>.  There is also a list of default options supported by every validator: +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+. See ActiveModel::Validations::ClassMethods#validates for more information.",
        "label": "What",
        "id": "12313"
    },
    {
        "raw_code": "def process_table_cell(element, ast_node)\n        new_element = Element.new(:td)\n        element.children << new_element\n\n        process_content(new_element, ast_node, TABLE_CELL_NODES)\n      end",
        "comment": "we ignore the attributes, attrs.background, attrs.colspan, attrs.colwidth, and attrs.rowspan",
        "label": "What",
        "id": "3669"
    },
    {
        "raw_code": "def write(key, hash)\n      raise InvalidHashProvidedError unless hash.is_a?(Hash) && hash.any?\n\n      full_key = cache_key(key)\n\n      hash = standardize_hash(hash)\n\n      with do |redis|\n        results = redis.pipelined do |pipeline|\n          # Set each hash key to the provided value\n          hash.each do |h_key, h_value|\n            pipeline.hset(full_key, h_key, h_value)\n          end",
        "comment": "Write a hash to the store. All keys and values will be strings when stored.  @param key [String] @param hash [Hash] the hash to be written to Redis @return [Boolean] whether all operations were successful or not",
        "label": "What",
        "id": "1534"
    },
    {
        "raw_code": "def edit\n    @badge_api_endpoint = expose_path(api_v4_projects_badges_path(id: @project.id))\n    render_edit\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6431"
    },
    {
        "raw_code": "def run_with_clean_state(query, **args)\n    ::Gitlab::SafeRequestStore.ensure_request_store do\n      with_clean_rails_cache do\n        with_clean_batchloader_executor do\n          ::GitlabSchema.execute(query, **args)\n        end",
        "comment": "Use this when writing N+1 tests.  It does not use the controller, so it avoids confounding factors due to authentication (token set-up, license checks) It clears the request store, rails cache, and BatchLoader Executor between runs.",
        "label": "What",
        "id": "8395"
    },
    {
        "raw_code": "def create_license\n          log(\"Creating gitlab license secret\", :info)\n          return log(\"`QA_EE_LICENSE|EE_LICENSE` variable is not set, skipping\", :warn) unless license\n\n          secret = Kubectl::Resources::Secret.new(LICENSE_SECRET, \"license\", license)\n          puts mask_secrets(kubeclient.create_resource(secret), [license, Base64.encode64(license)])\n        end",
        "comment": "Create gitlab license  @return [void]",
        "label": "What",
        "id": "4008"
    },
    {
        "raw_code": "def badges(auto_paginate: false)\n        response = if auto_paginate\n                     auto_paginated_response(request_url(\"#{api_get_path}/badges\", per_page: '100'))\n                   else\n                     parse_body(api_get_from(\"#{api_get_path}/badges\"))\n                   end",
        "comment": "Get group badges  @return [Array<QA::Resource::GroupBadge>]",
        "label": "What",
        "id": "4153"
    },
    {
        "raw_code": "def create_volume(name)\n          cmd = [\"docker\", \"volume\", \"create\", name]\n          execute_shell(cmd)\n        rescue StandardError => e\n          raise Error, \"Failed to create volume: #{e.message}\"\n        end",
        "comment": "Create Docker volume  @param [String] name @return [String]",
        "label": "What",
        "id": "3928"
    },
    {
        "raw_code": "def user_access_config\n      user_access_authorizations&.config\n    end",
        "comment": "As of today, all config values of associated authorization rows have the same value. See `UserAccess::RefreshService` for more information.",
        "label": "What",
        "id": "7673"
    },
    {
        "raw_code": "def forward\n      raise 'downstream app not set' unless @app.respond_to? :call\n\n      status, headers, body = @app.call env\n      @response.status = status\n      @response.body = body\n      @response.headers.merge! headers\n      nil\n    end",
        "comment": "Forward the request to the downstream app -- middleware only.",
        "label": "What",
        "id": "8582"
    },
    {
        "raw_code": "def user_commit_patches(user, branch_name:, patches:, target_sha: nil)\n        header = Gitaly::UserApplyPatchRequest::Header.new(\n          repository: @gitaly_repo,\n          user: gitaly_user(user),\n          target_branch: encode_binary(branch_name),\n          timestamp: Google::Protobuf::Timestamp.new(seconds: Time.now.utc.to_i),\n          expected_old_oid: target_sha\n        )\n        reader = binary_io(patches)\n\n        chunks = Enumerator.new do |chunk|\n          chunk.yield Gitaly::UserApplyPatchRequest.new(header: header)\n\n          until reader.eof?\n            patch_chunk = reader.read(MAX_MSG_SIZE)\n\n            chunk.yield(Gitaly::UserApplyPatchRequest.new(patches: patch_chunk))\n          end",
        "comment": "rubocop:enable Metrics/ParameterLists",
        "label": "What",
        "id": "1806"
    },
    {
        "raw_code": "def serializable_hash(_opts = {})\n      { title: title, name: name, id: id }\n    end",
        "comment": "Ensure these models match the interface required for exporting",
        "label": "What",
        "id": "7313"
    },
    {
        "raw_code": "def version\n    return unless persisted?\n\n    @version ||= @page.version || last_version\n  end",
        "comment": "The GitLab Commit instance for this page.",
        "label": "What",
        "id": "7165"
    },
    {
        "raw_code": "def queue\n        get_sidekiq_options[\"queue\"]\n      end",
        "comment": "Queue for this worker",
        "label": "What",
        "id": "5161"
    },
    {
        "raw_code": "def repo_tree\n      logger.info(\"Fetching repo tree for ref '#{ref}'\")\n      downstream_client\n        .repo_tree(downstream_project_path, ref: ref, per_page: 100).auto_paginate\n        .select { |node| node[\"type\"] == \"tree\" }\n        .map { |node| \"#{node['mode']} #{node['type']} #{node['id']}  #{node['path']}\" }\n        .join(\"\\n\")\n    end",
        "comment": "Repository file tree in form of the output of `git ls-tree` command  @return [String]",
        "label": "What",
        "id": "5268"
    },
    {
        "raw_code": "def self.removal_hook(uninstaller)\n      new(uninstaller.spec).remove\n    end",
        "comment": " Pre uninstalls hook that removes documentation ",
        "label": "What",
        "id": "252"
    },
    {
        "raw_code": "def initialize(namespace, current_user:)\n        @namespace = namespace\n        @current_user = current_user\n      end",
        "comment": "@param namespace [Namespace, Group] The namespace where the import source users are associated @param current_user [User] The user performing the CSV export",
        "label": "What",
        "id": "6101"
    },
    {
        "raw_code": "def find_class_named(name)\n    return self if full_name == name\n    return self if @name == name\n\n    @classes.values.find do |klass|\n      next if klass == self\n      klass.find_class_named name\n    end",
        "comment": " Finds a class or module with +name+ in this namespace or its descendants",
        "label": "What",
        "id": "16746"
    },
    {
        "raw_code": "def find_existing_label(title)\n      return existing_labels_by_title[title] if existing_labels_by_title\n\n      available_labels.find_by(title: title)\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6056"
    },
    {
        "raw_code": "def self.define_accessors(model, reflection)\n      mixin = model.generated_association_methods\n      name = reflection.name\n      define_readers(mixin, name)\n      define_writers(mixin, name)\n    end",
        "comment": "Defines the setter and getter methods for the association class Post < ActiveRecord::Base has_many :comments end  Post.first.comments and Post.first.comments= methods are defined by this method...",
        "label": "What",
        "id": "12820"
    },
    {
        "raw_code": "def invalid_registry_path\n      @invalid_path_error = true\n\n      render :index\n    end",
        "comment": "rubocop:disable Gitlab/ModuleWithInstanceVariables These instance variables are only read by a view helper to pass them to the frontend See app/views/projects/registry/repositories/index.html.haml app/views/groups/registry/repositories/index.html.haml",
        "label": "What",
        "id": "6581"
    },
    {
        "raw_code": "def compact_blank # :nodoc:\n    reject { |_k, v| v.blank? }\n  end",
        "comment": "Hash#reject has its own definition, so this needs one too.",
        "label": "What",
        "id": "14078"
    },
    {
        "raw_code": "def column_list\n            [timestamp_projection]\n          end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2887"
    },
    {
        "raw_code": "def set_provider_info(provider, options={})\n          provider.url = options[:url] if options.key?(:url)\n          provider.checksum_type = options[:checksum_type] if options.key?(:checksum_type)\n          provider.checksum = options[:checksum] if options.key?(:checksum)\n          provider.architecture = options[:architecture] if options.key?(:architecture)\n          provider.default_architecture = options[:default_architecture] if options.key?(:default_architecture)\n          provider\n        end",
        "comment": "Set any provider related attributes that were provided  @param [VagrantCloud::Box::Provider] provider Vagrant Cloud box version provider @param [Hash] options @option options [String] architecture Guest architecture of box @option options [String] :url Remote URL for self hosted @option options [String] :checksum_type Type of checksum value provided @option options [String] :checksum Checksum of the box asset @option options [Boolean] :default_architecture Default architecture for named provider @return [VagrantCloud::Box::Provider]",
        "label": "What",
        "id": "9761"
    },
    {
        "raw_code": "def update_issues_milestone(old_milestone, new_milestone)\n      Issue.where(project: project, milestone_id: old_milestone.id)\n        .update_all(milestone_id: new_milestone&.id)\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6139"
    },
    {
        "raw_code": "def finish(name, payload)\n        @notifier.finish name, @id, payload\n      end",
        "comment": "Send a finish notification with +name+ and +payload+.",
        "label": "What",
        "id": "14510"
    },
    {
        "raw_code": "def deleted?(name, options = {})\n        options.symbolize_keys!\n        handle_options(options)\n        @delete_cookies[name.to_s] == options\n      end",
        "comment": "Whether the given cookie is to be deleted by this CookieJar. Like `[]=`, you can pass in an options hash to test if a deletion applies to a specific `:path`, `:domain` etc.",
        "label": "What",
        "id": "11519"
    },
    {
        "raw_code": "def single_line?\n        first_line == last_line\n      end",
        "comment": "Adds `Range#single_line?` to parallel `Node#single_line?`",
        "label": "What",
        "id": "10704"
    },
    {
        "raw_code": "def uid(object)\n        # We want this to only match either placeholder or email\n        # depending on the flag state. There should be no fall-through.\n        if user_mapping_enabled?(project)\n          return unless object[:username]\n\n          if project.root_ancestor.user_namespace? && user_mapping_to_personal_namespace_owner_enabled?(project)\n            return project.root_ancestor.owner_id\n          end",
        "comment": "Object should behave as a object so we can remove object.is_a?(Hash) check This will be fixed in https://gitlab.com/gitlab-org/gitlab/-/issues/412328",
        "label": "What",
        "id": "1822"
    },
    {
        "raw_code": "def self.provider_capability(provider, cap, &block)\n          components.provider_capabilities[provider.to_sym].register(cap.to_sym, &block)\n          nil\n        end",
        "comment": "Defines a capability for the given provider. The block should return a class/module that has a method with the capability name, ready to be executed. This means that if it is an instance method, the block should return an instance of the class.  @param [String] provider The name of the provider @param [String] cap The name of the capability",
        "label": "What",
        "id": "9112"
    },
    {
        "raw_code": "def http_port\n          @http_port ||= rand(30000..31000)\n        end",
        "comment": "Random http port to expose outside cluster  @return [Integer]",
        "label": "What",
        "id": "4051"
    },
    {
        "raw_code": "def add_ref(ref)\n          raise NotImplementedError\n        end",
        "comment": "Adds a reference to the refs array  @param ref [Object] The reference to add @return [Boolean] True if bulk processing should be forced, e.g., when a size threshold is reached",
        "label": "What",
        "id": "1146"
    },
    {
        "raw_code": "def format_windows_path(path, *args)\n          path = cygwin_path(path) if cygwin?\n          path = msys_path(path) if msys?\n          path = wsl_to_windows_path(path) if wsl?\n          if windows? || wsl?\n            path = windows_unc_path(path) if !args.include?(:disable_unc)\n          end",
        "comment": "Takes a windows path and formats it to the 'unix' style (i.e. `/cygdrive/c` or `/c/`)  @param [Pathname, String] path Path to convert @param [Hash] hash of arguments @return [String]",
        "label": "What",
        "id": "9209"
    },
    {
        "raw_code": "def unlock?\n        request_method == 'UNLOCK'\n      end",
        "comment": "def lock? request_method == 'LOCK' end",
        "label": "What",
        "id": "8664"
    },
    {
        "raw_code": "def on_send(node)\n          return if node.arguments.empty?\n          return unless node.arguments.all?(&:array_type?)\n\n          offense = offense_range(node)\n          current = offense.source\n\n          if (use_percent_literal = node.arguments.any?(&:percent_literal?))\n            if percent_literals_includes_only_basic_literals?(node)\n              prefer = preferred_method(node)\n              message = format(MSG, prefer: prefer, current: current)\n            else\n              message = format(MSG_FOR_PERCENT_LITERALS, current: current)\n            end",
        "comment": "rubocop:disable Metrics",
        "label": "What",
        "id": "10577"
    },
    {
        "raw_code": "def vmdk_to_vdi(defined_disk_path)\n          source = defined_disk_path\n          destination = File.join(File.dirname(source), File.basename(source, \".*\")) + \".vdi\"\n\n          clone_disk(source, destination, 'VDI')\n\n          destination\n        end",
        "comment": "@param [VagrantPlugins::VirtualboxProvider::Driver] driver @param [String] defined_disk_path @return [String] destination - The cloned disk",
        "label": "What",
        "id": "9615"
    },
    {
        "raw_code": "def yyaccept\n      throw :racc_jump, 2\n    end",
        "comment": "Exit parser. Return value is +Symbol_Value_Stack[0]+.",
        "label": "What",
        "id": "16499"
    },
    {
        "raw_code": "def find_duplicate_indexes(table_name, schema_name: connection.current_schema)\n          find_indexes(table_name, schema_name: schema_name)\n            .group_by { |r| r['index_id'] }\n            .select { |_, v| v.size > 1 }\n            .map { |_, indexes| indexes.map { |index| index['index_name'] } }\n        end",
        "comment": "Finds duplicate indexes for a given schema and table. This finds indexes where the index definition is identical but the names are different. Returns an array of arrays containing duplicate index name pairs.  Example:  find_duplicate_indexes('table_name_goes_here')",
        "label": "What",
        "id": "3039"
    },
    {
        "raw_code": "def refresh_if_necessary\n          wait_time, from_dns = addresses_from_dns\n\n          current = addresses_from_load_balancer\n\n          if from_dns != current\n            ::Gitlab::Database::LoadBalancing::Logger.info(\n              event: :host_list_update,\n              message: \"Updating the host list for service discovery\",\n              host_list_length: from_dns.length,\n              old_host_list_length: current.length\n            )\n            replace_hosts(from_dns)\n          end",
        "comment": "Refreshes the hosts, but only if the DNS record returned a new list of addresses.  The return value is the amount of time (in seconds) to wait before checking the DNS record for any changes.",
        "label": "What",
        "id": "3078"
    },
    {
        "raw_code": "def initialize(user, source: nil, incorrect_auth_found_callback: nil, missing_auth_found_callback: nil)\n      @user = user\n      @source = source\n      @incorrect_auth_found_callback = incorrect_auth_found_callback\n      @missing_auth_found_callback = missing_auth_found_callback\n\n      @start_time = current_monotonic_time\n      @duration_statistics = {}\n    end",
        "comment": "user - The User for which to refresh the authorized projects.",
        "label": "What",
        "id": "5985"
    },
    {
        "raw_code": "def test_remove_private_comments\n    parser = util_parser \"foo\\n\\n--\\nbar\\n++\\n\\nbaz\\n\"\n\n    parser.scan\n\n    expected = \"foo\\n\\n\\nbaz\"\n\n    assert_equal expected, @top_level.comment.text\n  end",
        "comment": "RDoc stops processing comments if it finds a comment line CONTAINING '<tt>#--</tt>'. This can be used to separate external from internal comments, or to stop a comment being associated with a method, class, or module. Commenting CAN be turned back on with a line that STARTS '<tt>#++</tt>'.  I've seen guys that comment their code like this: # This method.... #----------------- def method  => either we do it only in ruby code, or we require the leading # (to avoid conflict with rules).  TODO: require the leading #, to provide the feature in simple text files. Note: in ruby & C code, we require '#--' & '#++' or '*--' & '*++', to allow rules:  # this is a comment #--- # private text #+++ # this is a rule: # ---",
        "label": "What",
        "id": "16846"
    },
    {
        "raw_code": "def connection_pool\n            @connection_pool ||= connection_base_model.establish_connection(configuration)\n          end",
        "comment": "@return [ActiveRecord::ConnectionAdapters::ConnectionPool] connection",
        "label": "What",
        "id": "1070"
    },
    {
        "raw_code": "def self.set_ssh_key_permissions(env, key_path)\n          script_path = Host.scripts_path.join(\"set_ssh_key_permissions.ps1\")\n          result = Vagrant::Util::PowerShell.execute(\n            script_path.to_s, \"-KeyPath\", key_path.to_s.gsub(' ', '` '),\n            module_path: Host.modules_path.to_s\n          )\n          if result.exit_code != 0\n            raise Vagrant::Errors::PowerShellError,\n              script: script_path,\n              stderr: result.stderr\n          end",
        "comment": "Set the ownership and permissions for SSH private key  @param [Vagrant::Environment] env @param [Pathname] key_path",
        "label": "What",
        "id": "9735"
    },
    {
        "raw_code": "def get_single_setting(setting_name, options = {})\n          get([setting_name], options).fetch(setting_name)\n        end",
        "comment": "@param [Symbol] setting_name @param [Hash] options @return [Object] @raise [RuntimeError]",
        "label": "What",
        "id": "2403"
    },
    {
        "raw_code": "def do_something\n      end",
        "comment": "comment",
        "label": "What",
        "id": "10776"
    },
    {
        "raw_code": "def list_new_commits(revisions)\n        git_env = Gitlab::Git::HookEnv.all(@gitaly_repo.gl_repository)\n        if git_env['GIT_OBJECT_DIRECTORY_RELATIVE'].present?\n          # If we have a quarantine environment, then we can optimize the check\n          # by doing a ListAllCommitsRequest. Instead of walking through\n          # references, we just walk through all quarantined objects, which is\n          # a lot more efficient. To do so, we throw away any alternate object\n          # directories, which point to the main object directory of the\n          # repository, and only keep the object directory which points into\n          # the quarantine object directory.\n          quarantined_repo = @gitaly_repo.dup\n          quarantined_repo.git_alternate_object_directories = Google::Protobuf::RepeatedField.new(:string)\n\n          request = Gitaly::ListAllCommitsRequest.new(\n            repository: quarantined_repo\n          )\n\n          response = gitaly_client_call(@repository.storage, :commit_service, :list_all_commits, request, timeout: GitalyClient.medium_timeout)\n\n          quarantined_commits = consume_commits_response(response)\n          quarantined_commit_ids = quarantined_commits.map(&:id)\n\n          # While in general the quarantine directory would only contain objects\n          # which are actually new, this is not guaranteed by Git. In fact,\n          # git-push(1) may sometimes push objects which already exist in the\n          # target repository. We do not want to return those from this method\n          # though given that they're not actually new.\n          #\n          # To fix this edge-case we thus have to filter commits down to those\n          # which don't yet exist. To do so, we must check for object existence\n          # in the main repository, but the object directory of our repository\n          # points into the object quarantine. This can be fixed by unsetting\n          # it, which will cause us to use the normal repository as indicated by\n          # its relative path again.\n          main_repo = @gitaly_repo.dup\n          main_repo.git_object_directory = \"\"\n\n          # Check object existence of all quarantined commits' IDs.\n          quarantined_commit_existence = object_existence_map(quarantined_commit_ids, gitaly_repo: main_repo)\n\n          # And then we reject all quarantined commits which exist in the main\n          # repository already.\n          quarantined_commits.reject! { |c| quarantined_commit_existence[c.id] }\n\n          quarantined_commits\n        else\n          list_commits(Array.wrap(revisions) + %w[--not --all])\n        end",
        "comment": "List all commits which are new in the repository. If commits have been pushed into the repo",
        "label": "What",
        "id": "1798"
    },
    {
        "raw_code": "def reload_routes!\n      if routes_reloader.execute_unless_loaded\n        routes_reloader.loaded = false\n      else\n        routes_reloader.reload!\n      end",
        "comment": "Reload application routes regardless if they changed or not.",
        "label": "What",
        "id": "14629"
    },
    {
        "raw_code": "def clear\n        load_for_delete!\n        @delegate.clear\n      end",
        "comment": "Clears the session.",
        "label": "What",
        "id": "11552"
    },
    {
        "raw_code": "def composition_path\n          data_directory.join(\"docker-compose.yml\")\n        end",
        "comment": "@return [Pathname] path to the docker-compose.yml file",
        "label": "What",
        "id": "9510"
    },
    {
        "raw_code": "def cache_key_for(name)\n        format(CACHE_KEY, project: project.id, name: name)\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2185"
    },
    {
        "raw_code": "def find_alias_comment(class_name, new_name, old_name)\n    content =~ %r%((?>/\\*.*?\\*/\\s+))\n                  rb_define_alias\\(\\s*#{Regexp.escape class_name}\\s*,\n                                   \\s*\"#{Regexp.escape new_name}\"\\s*,\n                                   \\s*\"#{Regexp.escape old_name}\"\\s*\\);%xm\n\n    new_comment($1 || '', @top_level, :c)\n  end",
        "comment": " Finds the comment for an alias on +class_name+ from +new_name+ to +old_name+",
        "label": "What",
        "id": "16149"
    },
    {
        "raw_code": "def download_file(request)\n      tempfile = nil\n      encoding = nil\n      request.on_headers do |response|\n        content_disposition = response.headers['Content-Disposition']\n        if content_disposition && content_disposition =~ /filename=/i\n          filename = content_disposition[/filename=['\"]?([^'\"\\s]+)['\"]?/, 1]\n          prefix = sanitize_filename(filename)\n        else\n          prefix = 'download-'\n        end",
        "comment": "Save response body into a file in (the defined) temporary folder, using the filename from the \"Content-Disposition\" header if provided, otherwise a random filename. The response body is written to the file in chunks in order to handle files which size is larger than maximum Ruby String or even larger than the maximum memory a Ruby process can use.  @see Configuration#temp_folder_path",
        "label": "What",
        "id": "832"
    },
    {
        "raw_code": "def read_attribute(attr_name)\n        send(attr_name)\n      end",
        "comment": "Mock AR methods",
        "label": "What",
        "id": "1174"
    },
    {
        "raw_code": "def gcs_url(bucket, file)\n        \"https://storage.cloud.google.com/#{bucket}/#{file.name}\"\n      end",
        "comment": "Construct the url of the uploaded file in GCS @param [String] bucket name the file is uploaded to @param [String] file uploaded to gcs  @return [String]",
        "label": "What",
        "id": "4661"
    },
    {
        "raw_code": "def can_read_project?(request, project)\n        return true if project.public?\n        return false unless has_basic_credentials?(request)\n\n        login, password = user_name_and_password(request)\n        auth_result = Gitlab::Auth.find_for_git_client(login, password, project: project, request: request)\n\n        auth_result.success? &&\n          auth_result.authentication_abilities_include?(:read_project) &&\n          auth_result.can_perform_action_on_project?(:read_project, project)\n      end",
        "comment": "can_read_project? checks if the request's credentials have read access to the project",
        "label": "What",
        "id": "2040"
    },
    {
        "raw_code": "def sign_in_and_redirect_or_verify_identity(user, _, _)\n    sign_in_and_redirect(user, event: :authentication)\n  end",
        "comment": "overridden in EE",
        "label": "What",
        "id": "6413"
    },
    {
        "raw_code": "def send_response(body)\n          Integrations::Clients::HTTP.post(\n            pipeline.chat_data.response_url,\n            {\n              headers: { 'Content-Type': 'application/json' },\n              body: body.to_json\n            }\n          )\n        end",
        "comment": "Sends a response back to Mattermost  body - The message payload to send back to Mattermost, as a Hash.",
        "label": "What",
        "id": "2446"
    },
    {
        "raw_code": "def valid_desired_state?(state)\n            VALID_DESIRED_STATES.include?(state)\n          end",
        "comment": "@param [String] state @return [TrueClass, FalseClass]",
        "label": "What",
        "id": "3322"
    },
    {
        "raw_code": "def symbolized_options\n            @symbolized_options ||= super.tap do |opts|\n              next unless opts[:gitlab_domain].nil?\n\n              # merge default option lazily to not fetch ip_address_list every time class is loaded\n              opts.merge!({ gitlab_domain: \"#{Socket.ip_address_list.detect(&:ipv4_private?).ip_address}.nip.io\" })\n            end",
        "comment": "Populate options with default gitlab domain if missing  @return [Hash]",
        "label": "What",
        "id": "4083"
    },
    {
        "raw_code": "def deserialize(job_data)\n      self.job_id               = job_data[\"job_id\"]\n      self.provider_job_id      = job_data[\"provider_job_id\"]\n      self.queue_name           = job_data[\"queue_name\"]\n      self.priority             = job_data[\"priority\"]\n      self.serialized_arguments = job_data[\"arguments\"]\n      self.executions           = job_data[\"executions\"]\n      self.exception_executions = job_data[\"exception_executions\"]\n      self.locale               = job_data[\"locale\"] || I18n.locale.to_s\n      self.timezone             = job_data[\"timezone\"] || Time.zone&.name\n      self.enqueued_at          = deserialize_time(job_data[\"enqueued_at\"]) if job_data[\"enqueued_at\"]\n      self.scheduled_at         = deserialize_time(job_data[\"scheduled_at\"]) if job_data[\"scheduled_at\"]\n    end",
        "comment": "Attaches the stored job data to the current instance. Receives a hash returned from +serialize+  ==== Examples  class DeliverWebhookJob < ActiveJob::Base attr_writer :attempt_number  def attempt_number @attempt_number ||= 0 end  def serialize super.merge('attempt_number' => attempt_number + 1) end  def deserialize(job_data) super self.attempt_number = job_data['attempt_number'] end  rescue_from(Timeout::Error) do |exception| raise exception if attempt_number > 5 retry_job(wait: 10) end end",
        "label": "What",
        "id": "12116"
    },
    {
        "raw_code": "def fetch_published_port(container_port)\n          port = published_ports.split(\"\\n\").find { |line| line.start_with?(container_port.to_s) }.split(':').last\n          raise(\"Could not find published #{container_port} port for container #{name}\") unless port\n\n          port.to_i\n        end",
        "comment": "Fetch published container port  @param [Integer] container_port @return [Integer]",
        "label": "What",
        "id": "4236"
    },
    {
        "raw_code": "def vue_readme_header_additional_data\n    {}\n  end",
        "comment": "@return [Hash]",
        "label": "What",
        "id": "7816"
    },
    {
        "raw_code": "def delete_environment(repo, environment_name, options = {})\n        delete(\"#{Repository.path repo}/environments/#{environment_name}\", options)\n      end",
        "comment": "Delete an Environment  @param repo [Integer, String, Repository, Hash] A GitHub repository @param environment_name [String] The name of the environment @return [No Content] @see https://docs.github.com/en/rest/deployments/environments#delete-an-environment",
        "label": "What",
        "id": "15229"
    },
    {
        "raw_code": "def milestone_events(auto_paginate: false, attempts: 0)\n        events(\"milestone\", auto_paginate: auto_paginate, attempts: attempts)\n      end",
        "comment": "Issue milestone events  @param [Boolean] auto_paginate @param [Integer] attempts @return [Array<Hash>]",
        "label": "What",
        "id": "4205"
    },
    {
        "raw_code": "def oci_repository_path_regex\n      @oci_repository_path_regex ||= %r{\\A[a-zA-Z0-9]+([._-][a-zA-Z0-9]+)*\\z}\n    end",
        "comment": "Project path must conform to this regex. See https://gitlab.com/gitlab-org/gitlab/-/issues/27483",
        "label": "What",
        "id": "1391"
    },
    {
        "raw_code": "def heredoc_closing_delimiter_range_from(node)\n          node.location.heredoc_end.end.adjust(\n            begin_pos: -heredoc_delimiter_string_from(node).length\n          )\n        end",
        "comment": "@param node [RuboCop::AST::StrNode] @return [Parser::Source::Range]",
        "label": "What",
        "id": "10333"
    },
    {
        "raw_code": "def destroy\n    @book.destroy\n    respond_to do |format|\n      format.html { redirect_to books_url, notice: 'Book was successfully destroyed.' } # aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n      format.json { head :no_content }\n    end",
        "comment": "DELETE /books/1 DELETE /books/1.json",
        "label": "What",
        "id": "10741"
    },
    {
        "raw_code": "def self.action_up\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use Call, IsState, :not_created do |env, b2|\n            if env[:result]\n              b2.use HandleBox\n            end",
        "comment": "This action brings the \"machine\" up from nothing, including creating the container, configuring metadata, and booting.",
        "label": "What",
        "id": "9473"
    },
    {
        "raw_code": "def next_migration_number(dirname)\n          next_migration_number = current_migration_number(dirname) + 1\n          ActiveRecord::Migration.next_migration_number(next_migration_number)\n        end",
        "comment": "Implement the required interface for Rails::Generators::Migration.",
        "label": "What",
        "id": "13490"
    },
    {
        "raw_code": "def assert_routing(path, options, defaults = {}, extras = {}, message = nil)\n        assert_recognizes(options, path, extras, message)\n\n        controller, default_controller = options[:controller], defaults[:controller]\n        if controller && controller.include?(?/) && default_controller && default_controller.include?(?/)\n          options[:controller] = \"/#{controller}\"\n        end",
        "comment": "Asserts that path and options match both ways; in other words, it verifies that `path` generates `options` and then that `options` generates `path`. This essentially combines `assert_recognizes` and `assert_generates` into one step.  The `extras` hash allows you to specify options that would normally be provided as a query string to the action. The `message` parameter allows you to specify a custom error message to display upon failure.  # Asserts a basic route: a controller with the default action (index) assert_routing '/home', controller: 'home', action: 'index'  # Test a route generated with a specific controller, action, and parameter (id) assert_routing '/entries/show/23', controller: 'entries', action: 'show', id: 23  # Asserts a basic route (controller + default action), with an error message if it fails assert_routing '/store', { controller: 'store', action: 'index' }, {}, {}, 'Route for store index not generated properly'  # Tests a route, providing a defaults hash assert_routing 'controller/action/9', {id: \"9\", item: \"square\"}, {controller: \"controller\", action: \"action\"}, {}, {item: \"square\"}  # Tests a route with an HTTP method assert_routing({ method: 'put', path: '/product/321' }, { controller: \"product\", action: \"update\", id: \"321\" })",
        "label": "What",
        "id": "11644"
    },
    {
        "raw_code": "def set_project_id\n      self.project_id ||= build&.project_id\n    end",
        "comment": "TODO: This is temporary code to assist the backfilling of records for this epic: https://gitlab.com/groups/gitlab-org/-/epics/12323 To be removed in 17.7: https://gitlab.com/gitlab-org/gitlab/-/issues/488163 ",
        "label": "What",
        "id": "7585"
    },
    {
        "raw_code": "def setup_go_projects\n    setup_gitaly\n    setup_gitlab_shell\n    setup_workhorse\n  end",
        "comment": "Can be overriden The Go build cache is not safe for concurrent builds: https://github.com/golang/go/issues/43645",
        "label": "What",
        "id": "8467"
    },
    {
        "raw_code": "def overridden_by_department?(cop)\n      in_directive_department?(cop) && raw_cop_names.include?(cop)\n    end",
        "comment": "Checks if cop department has already used in directive comment",
        "label": "What",
        "id": "10110"
    },
    {
        "raw_code": "def find_by_deploy_key(project, key_id)\n        project.deploy_keys_projects.find_by!(deploy_key: key_id)\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3800"
    },
    {
        "raw_code": "def redundant_feature?(feature_name)\n          feature_name == 'enumerator' ||\n            (target_ruby_version >= 2.1 && feature_name == 'thread') ||\n            (target_ruby_version >= 2.2 && RUBY_22_LOADED_FEATURES.include?(feature_name)) ||\n            (target_ruby_version >= 2.7 && feature_name == 'ruby2_keywords') ||\n            (target_ruby_version >= 3.1 && feature_name == 'fiber') ||\n            (target_ruby_version >= 3.2 && feature_name == 'set')\n        end",
        "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10648"
    },
    {
        "raw_code": "def _ListItem\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_Bullet)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_Enumerator)\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ListItem = (Bullet | Enumerator) @StartList:a ListBlock:b { a << b } (ListContinuationBlock:c { a.push(*c) })* { list_item_from a }",
        "label": "What",
        "id": "15616"
    },
    {
        "raw_code": "def acts_like_date?\n    true\n  end",
        "comment": "Duck-types as a Date-like class. See Object#acts_like?.",
        "label": "What",
        "id": "14110"
    },
    {
        "raw_code": "def test_generate_message_exclusion_with_default_message\n    assert_equal \"is reserved\", @person.errors.generate_message(:title, :exclusion, value: \"title\")\n  end",
        "comment": "validates_exclusion_of: generate_message(attr_name, :exclusion, message: custom_message, value: value)",
        "label": "What",
        "id": "12326"
    },
    {
        "raw_code": "def populate_target_and_source_if_required\n        return if @no_preparation\n\n        populate(:target) if create_target?\n        populate(:source)\n      end",
        "comment": "Create source and target and commits if necessary  @return [void]",
        "label": "What",
        "id": "4169"
    },
    {
        "raw_code": "def create_tmp_dir\n        FileUtils.mkdir_p('tmp/')\n      end",
        "comment": "Create a 'tmp' directory  @return [String]",
        "label": "What",
        "id": "4659"
    },
    {
        "raw_code": "def cache_options\n    { raw: raw? }\n  end",
        "comment": "subclasses can override to add any specific options, such as super.merge({ expires_in: 5.minutes })",
        "label": "What",
        "id": "5521"
    },
    {
        "raw_code": "def node_to_operate(relation, column)\n            if join_relation?(relation) && joined_column?(column)\n              table_name, column_name = column.split(\".\")\n              Arel::Table.new(table_name)[column_name]\n            else\n              relation.all.table[column]\n            end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "1985"
    },
    {
        "raw_code": "def commit(release:, file:, branch:, message:)\n        # When retrying, we need to reprocess the existing changelog from\n        # scratch, otherwise we may end up throwing away changes. As such, all\n        # the logic is contained within the retry block.\n        Retriable.retriable(on: Error) do\n          commit = Gitlab::Git::Commit.last_for_path(\n            @project.repository,\n            branch,\n            file,\n            literal_pathspec: true\n          )\n\n          content = blob_content(file, commit)\n\n          # If the release has already been added (e.g. concurrently by another\n          # API call), we don't want to add it again.\n          break if content&.match?(release.header_start_pattern)\n\n          service = Files::MultiService.new(\n            @project,\n            @user,\n            commit_message: message,\n            branch_name: branch,\n            start_branch: branch,\n            actions: [\n              {\n                action: content ? 'update' : 'create',\n                content: Generator.new(content.to_s).add(release),\n                file_path: file,\n                last_commit_id: commit&.sha\n              }\n            ]\n          )\n\n          result = service.execute\n\n          raise Error, result[:message] if result[:status] != :success\n        end",
        "comment": "Commits a release's changelog to a file on a branch.  The `release` argument is a `Gitlab::Changelog::Release` for which to update the changelog.  The `file` argument specifies the path to commit the changes to.  The `branch` argument specifies the branch to commit the changes on.  The `message` argument specifies the commit message to use.",
        "label": "What",
        "id": "3236"
    },
    {
        "raw_code": "def expired?\n        @expires_in && @created_at + @expires_in <= Time.now.to_f\n      end",
        "comment": "Checks if the entry is expired. The +expires_in+ parameter can override the value set when the entry was created.",
        "label": "What",
        "id": "14001"
    },
    {
        "raw_code": "def verified_request? # :doc:\n        request.get? || request.head? || !protect_against_forgery? ||\n          (valid_request_origin? && any_authenticity_token_valid?)\n      end",
        "comment": "Returns true or false if a request is verified. Checks:  *   Is it a GET or HEAD request? GETs should be safe and idempotent *   Does the form_authenticity_token match the given token value from the params? *   Does the `X-CSRF-Token` header match the form_authenticity_token? ",
        "label": "What",
        "id": "11339"
    },
    {
        "raw_code": "def replacement_range_and_content(node)\n          variable = node.children.first\n          expression = node.source_range\n\n          if array_new?(variable)\n            expression = node.parent.source_range if node.parent.array_type?\n            [expression, variable.source]\n          elsif !variable.array_type?\n            [expression, \"[#{variable.source}]\"]\n          elsif redundant_brackets?(node)\n            [expression, remove_brackets(variable)]\n          else\n            [node.loc.operator, '']\n          end",
        "comment": "rubocop:disable Metrics/AbcSize",
        "label": "What",
        "id": "10661"
    },
    {
        "raw_code": "def destroy\n    spam_log = SpamLog.find(safe_params[:id])\n\n    if safe_params[:remove_user]\n      spam_log.remove_user(deleted_by: current_user)\n      redirect_to admin_spam_logs_path,\n        status: :found,\n        notice: format(_('User %{username} was successfully removed.'), username: spam_log.user.username)\n    else\n      spam_log.destroy\n      head :ok\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6459"
    },
    {
        "raw_code": "def done_documenting=(value)\n    return unless @track_visibility\n    @done_documenting  = value\n    @document_self     = !value\n    @document_children = @document_self\n  end",
        "comment": " Turns documentation on/off, and turns on/off #document_self and #document_children.  Once documentation has been turned off (by +:enddoc:+), the object will refuse to turn #document_self or #document_children on, so +:doc:+ and +:start_doc:+ directives will have no effect in the current file.",
        "label": "What",
        "id": "15916"
    },
    {
        "raw_code": "def response_status\n      @response[:status]\n    end",
        "comment": "Status code returned by the GitHub server.  @return [Integer]",
        "label": "What",
        "id": "14862"
    },
    {
        "raw_code": "def up\n    add_concurrent_index(\n      :merge_request_diff_commits,\n      :merge_request_commits_metadata_id,\n      name: INDEX_NAME,\n      where: \"merge_request_commits_metadata_id IS NOT NULL\"\n    )\n  end",
        "comment": "rubocop:disable Migration/PreventIndexCreation -- this index is already present on GitLab.com which was prepared in https://gitlab.com/gitlab-org/gitlab/-/merge_requests/189775.",
        "label": "What",
        "id": "4884"
    },
    {
        "raw_code": "def hash\n      [fingerprint, project_id, name, description, actor, event_count, approximated_user_count, last_seen_at, first_seen_at, status, stats].hash\n    end",
        "comment": "Calculates hash code according to all attributes. @return [Integer] Hash code",
        "label": "What",
        "id": "906"
    },
    {
        "raw_code": "def on_interpolation(begin_node)\n          final_node = begin_node.children.last\n          return unless offending?(final_node)\n\n          # %W and %I split the content into words before expansion\n          # treating each interpolation as a word component, so\n          # interpolation should not be removed if the expanded value\n          # contains a space character.\n          expanded_value = autocorrected_value(final_node)\n          expanded_value = handle_special_regexp_chars(begin_node, expanded_value)\n\n          return if in_array_percent_literal?(begin_node) && /\\s|\\A\\z/.match?(expanded_value)\n\n          add_offense(final_node) do |corrector|\n            next if final_node.dstr_type? # nested, fixed in next iteration\n\n            replacement = if final_node.str_type? && !final_node.value.valid_encoding?\n                            final_node.source.delete_prefix('\"').delete_suffix('\"')\n                          else\n                            expanded_value\n                          end",
        "comment": "rubocop:disable Metrics/AbcSize",
        "label": "What",
        "id": "10669"
    },
    {
        "raw_code": "def where(options)\n          repo = options.delete(:repo)\n          raise 'Gitlab::Git::Repository is required' unless repo.respond_to?(:log)\n\n          repo.log(options)\n        end",
        "comment": "Get commits collection  Ex. Commit.where( repo: repo, ref: 'master', path: 'app/models', limit: 10, offset: 5, ) ",
        "label": "What",
        "id": "2587"
    },
    {
        "raw_code": "def indentation_and_offset(node, parenthesized)\n          node_indentation = indentation(node)\n          node_offset = offset(node)\n          if parenthesized\n            node_indentation = node_indentation[0...-1]\n            node_offset = node_offset[0...-1]\n          end",
        "comment": "rubocop:enable Metrics/AbcSize",
        "label": "What",
        "id": "10527"
    },
    {
        "raw_code": "def author\n          @author ||= User.find_by(incoming_email_token: incoming_email_token)\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3250"
    },
    {
        "raw_code": "def javascript_path(source, options = {})\n        path_to_asset(source, { type: :javascript }.merge!(options))\n      end",
        "comment": "Computes the path to a JavaScript asset in the public javascripts directory. If the +source+ filename has no extension, .js will be appended (except for explicit URIs) Full paths from the document root will be passed through. Used internally by +javascript_include_tag+ to build the script path.  javascript_path \"xmlhr\"                              # => /assets/xmlhr.js javascript_path \"dir/xmlhr.js\"                       # => /assets/dir/xmlhr.js javascript_path \"/dir/xmlhr\"                         # => /dir/xmlhr.js javascript_path \"http://www.example.com/js/xmlhr\"    # => http://www.example.com/js/xmlhr javascript_path \"http://www.example.com/js/xmlhr.js\" # => http://www.example.com/js/xmlhr.js",
        "label": "What",
        "id": "11794"
    },
    {
        "raw_code": "def serializer\n      @serializer ||= ::Gitlab::ImportExport::Json::StreamingSerializer.new(\n        portable,\n        config.portable_tree,\n        ::Gitlab::ImportExport::Json::NdjsonWriter.new(export_path),\n        exportable_path: '',\n        current_user: user\n      )\n    end",
        "comment": "rubocop: disable CodeReuse/Serializer",
        "label": "What",
        "id": "5871"
    },
    {
        "raw_code": "def aws?\n      provider == AWS_PROVIDER\n    end",
        "comment": "AWS-specific options",
        "label": "What",
        "id": "3729"
    },
    {
        "raw_code": "def map_line_number(from_line, from:, to:)\n        # If no diff file could be found, the file wasn't changed, and the\n        # mapped line number is the same as the specified line number.\n        return from_line unless diff_file\n\n        # To find the mapped line number for the specified line number,\n        # we need to find:\n        # - The diff line with that exact line number, if it is in the diff context\n        # - The first diff line with a higher line number, if it falls between diff contexts\n        # - The last known diff line, if it falls after the last diff context\n        diff_line = diff_lines.find do |diff_line|\n          diff_from_line = diff_line.public_send(from) # rubocop:disable GitlabSecurity/PublicSend\n          diff_from_line && diff_from_line >= from_line\n        end",
        "comment": "Find old/new line number based on its old/new counterpart line number.",
        "label": "What",
        "id": "2693"
    },
    {
        "raw_code": "def generate(what, *args)\n        log :generate, what\n\n        options = args.extract_options!\n        options[:abort_on_failure] = !options[:inline]\n\n        rails_command \"generate #{what} #{args.join(\" \")}\", options\n      end",
        "comment": "Runs another generator.  generate \"scaffold\", \"Post title:string body:text\" generate \"scaffold\", \"Post\", \"title:string\", \"body:text\"  The first argument is the generator name, and the remaining arguments are joined together and passed to the generator.",
        "label": "What",
        "id": "14736"
    },
    {
        "raw_code": "def by_name(items)\n      return items unless params[:name].present?\n\n      items.for_name(params[:name])\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "8009"
    },
    {
        "raw_code": "def execute_action_for_2fa_reason(actions)\n    reason = two_factor_verifier.two_factor_authentication_reason\n    groups_enforcing_two_factor = current_user.source_groups_of_two_factor_authentication_requirement\n                                              .reorder(name: :asc)\n    actions[reason].call(groups_enforcing_two_factor)\n  end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6536"
    },
    {
        "raw_code": "def self.coerce_result(value, _ctx)\n      ::Gitlab::GlobalId.as_global_id(value).to_s\n    end",
        "comment": "@param value [GID] @return [String]",
        "label": "What",
        "id": "6208"
    },
    {
        "raw_code": "def link_sanitizer\n          @link_sanitizer ||= sanitizer_vendor.link_sanitizer.new\n        end",
        "comment": "Gets the Rails::HTML::LinkSanitizer instance used by +strip_links+. Replace with any object that responds to +sanitize+.  class Application < Rails::Application config.action_view.link_sanitizer = MySpecialSanitizer.new end",
        "label": "What",
        "id": "11967"
    },
    {
        "raw_code": "def access_levels_attributes(access_levels, access_levels_params)\n      attributes = access_levels.filter_map do |access_level|\n        next if remove_matched_access_level_params!(access_levels_params, access_level)\n\n        # access levels that do not have matching params are marked for deletion\n        { id: access_level.id, _destroy: true }\n      end",
        "comment": "In ProtectedBranch we are using:  `accepts_nested_attributes_for :{type}_access_levels, allow_destroy: true`  This branch rule update service acts like we have defined this `accepts_nested_attributes_for` with `update: true`.  Unfortunately we are unable to modify the `accepts_nested_attributes_for` config as we use this logic in other locations. As we are reusing the ProtectedBranches::UpdateService we also can't custom write the logic to persist the access levels manually.  For now the best solution appears to be matching the params against the existing levels to check which access levels still exist and marking unmatched access levels for destruction.  Given the following: access_levels = [{ id: 1, access_level: 30 }, { id: 2, user_id: 1 }, { id: 3, group_id: 1 }] access_levels_params = [{ access_level: 30 }, { user_id: 1 }, { deploy_key_id: 1 }]  The output should be: [{ id: 3, _destroy: true }, { deploy_key_id: 1 }]  NOTE: :user_id and :group_id are only available in EE. ",
        "label": "What",
        "id": "6148"
    },
    {
        "raw_code": "def unsigned_commit_shas(commit_shas)\n      return [] if commit_shas.empty?\n\n      signed = by_commit_sha(commit_shas).pluck(:commit_sha)\n      commit_shas - signed\n    end",
        "comment": "Find commits that are lacking a signature in the database at present",
        "label": "What",
        "id": "7341"
    },
    {
        "raw_code": "def reference_prefix\n      '@'\n    end",
        "comment": "Referable methods should be the same as User",
        "label": "What",
        "id": "7204"
    },
    {
        "raw_code": "def run_post_deploy_setup\n          Helpers::Spinner.spin(\"running post-deployment setup\") { configuration.run_post_deployment_setup }\n        end",
        "comment": "Execute post-deployment setup  @return [void]",
        "label": "What",
        "id": "4006"
    },
    {
        "raw_code": "def refs\n    find_refs = refs_params['find']\n\n    find_branches = true\n    find_tags = true\n    find_commits = true\n\n    unless find_refs.nil?\n      find_branches = find_refs.include?('branches')\n      find_tags = find_refs.include?('tags')\n      find_commits = find_refs.include?('commits')\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6434"
    },
    {
        "raw_code": "def upgrade_v1_1_v1_5\n      with_collection_lock do\n        temp_dir = Pathname.new(Dir.mktmpdir(TEMP_PREFIX, @temp_root))\n\n        @directory.children(true).each do |boxdir|\n          # Ignore all non-directories because they can't be boxes\n          next if !boxdir.directory?\n\n          box_name = boxdir.basename.to_s\n\n          # If it is a v1 box, then we need to upgrade it first\n          if v1_box?(boxdir)\n            upgrade_dir = v1_upgrade(boxdir)\n            FileUtils.mv(upgrade_dir, boxdir.join(\"virtualbox\"))\n          end",
        "comment": "This upgrades a v1.1 - v1.4 box directory structure up to a v1.5 directory structure. This will raise exceptions if it fails in any way.",
        "label": "What",
        "id": "8733"
    },
    {
        "raw_code": "def gpg_keys\n    keys = user.gpg_keys.filter_map { |gpg_key| gpg_key.key if gpg_key.verified? }.join(\"\\n\")\n    keys << \"\\n\" unless keys.empty?\n    render plain: keys\n  end",
        "comment": "Get all gpg keys of a user(params[:username]) in a text format",
        "label": "What",
        "id": "6398"
    },
    {
        "raw_code": "def build(object, **options)\n        # Objects are sometimes wrapped in a BatchLoader instance\n        case object.itself\n        when Board\n          board_url(object, **options)\n        when ::Ci::Build\n          instance.project_job_url(object.project, object, **options)\n        when ::Ci::Pipeline\n          instance.project_pipeline_url(object.project, object, **options)\n        when Commit\n          commit_url(object, **options)\n        when Compare\n          compare_url(object, **options)\n        when Group\n          instance.group_canonical_url(object, **options)\n        when WorkItem\n          instance.work_item_url(object, **options)\n        when Issue\n          instance.issue_url(object, **options)\n        when MergeRequest\n          instance.merge_request_url(object, **options)\n        when Milestone\n          instance.milestone_url(object, **options)\n        when Note\n          note_url(object, **options)\n        when AntiAbuse::Reports::Note\n          abuse_report_note_url(object, **options)\n        when Release\n          instance.release_url(object, **options)\n        when ::Organizations::Organization\n          instance.root_url(organization_path: object.path, **options)\n        when Project\n          instance.project_url(object, **options)\n        when Snippet\n          snippet_url(object, **options)\n        when User\n          instance.user_url(object, **options)\n        when Namespaces::UserNamespace\n          instance.user_url(object.owner, **options)\n        when Namespaces::ProjectNamespace\n          instance.project_url(object.project, **options)\n        when Wiki\n          wiki_url(object, **options)\n        when WikiPage\n          wiki_page_url(object.wiki, object, **options)\n        when WikiPage::Meta\n          wiki_page_url(object.container.wiki, object.canonical_slug, **options)\n        when ::DesignManagement::Design\n          design_url(object, **options)\n        when ::Packages::Package\n          package_url(object, **options)\n        when ::Key\n          instance.user_settings_ssh_key_url(object)\n        else\n          raise NotImplementedError, \"No URL builder defined for #{object.inspect}\"\n        end",
        "comment": "Using a case statement here is preferable for readability and maintainability. See discussion in https://gitlab.com/gitlab-org/gitlab/-/issues/217397  rubocop:disable Metrics/AbcSize rubocop:disable Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "1336"
    },
    {
        "raw_code": "def investigate(processed_source)\n        root_node = processed_source.ast\n        return unless root_node\n\n        variable_table.push_scope(root_node)\n        process_node(root_node)\n        variable_table.pop_scope\n      end",
        "comment": "Starting point.",
        "label": "What",
        "id": "10285"
    },
    {
        "raw_code": "def parse_set_cookies_headers(set_cookies)\n    if set_cookies.is_a?(String)\n      set_cookies = set_cookies.split(\"\\n\")\n    end",
        "comment": "Parse the set-cookie header and return a hash of cookie names and values.  Example: set_cookies = headers[\"set-cookie\"] parse_set_cookies_headers(set_cookies)",
        "label": "What",
        "id": "11651"
    },
    {
        "raw_code": "def params(*params, &block)\n          @params = block || params\n        end",
        "comment": "Allows to define params for the next quick action. These params are shown in the autocomplete menu.  Example:  params \"~label ~label2\" command :command_key do |arguments| # Awesome code block end",
        "label": "What",
        "id": "2943"
    },
    {
        "raw_code": "def link_object(obj, title = nil, anchor = nil, relative = true)\n        return title if obj.nil?\n        obj = Registry.resolve(object, obj, true, true) if obj.is_a?(String)\n        if title\n          title = title.to_s\n        elsif object.is_a?(CodeObjects::Base)\n          # Check if we're linking to a class method in the current\n          # object. If we are, create a title in the format of\n          # \"CurrentClass.method_name\"\n          if obj.is_a?(CodeObjects::MethodObject) && obj.scope == :class && obj.parent == object\n            title = h([object.name, obj.sep, obj.name].join)\n          elsif obj.title != obj.path\n            title = h(obj.title)\n          else\n            title = h(object.relative_path(obj))\n          end",
        "comment": "(see BaseHelper#link_object)",
        "label": "What",
        "id": "407"
    },
    {
        "raw_code": "def with_temp_dir(dir=nil)\n      dir ||= Dir.mktmpdir(TEMP_PREFIX, @temp_root)\n      dir = Pathname.new(dir)\n\n      yield dir\n    ensure\n      FileUtils.rm_rf(dir.to_s)\n    end",
        "comment": "This is a helper that makes sure that our temporary directories are cleaned up no matter what.  @param [String] dir Path to a temporary directory @return [Object] The result of whatever the yield is",
        "label": "What",
        "id": "8740"
    },
    {
        "raw_code": "def update_batch(sub_batch)\n        connection.execute <<~SQL\n            UPDATE issues\n            SET namespace_id = projects.project_namespace_id\n            FROM (#{sub_batch.to_sql}) AS projects(issue_id, project_namespace_id)\n            WHERE issues.id = issue_id\n        SQL\n      end",
        "comment": "rubocop:enable Database/RescueQueryCanceled rubocop:enable Database/RescueStatementTimeout",
        "label": "What",
        "id": "3295"
    },
    {
        "raw_code": "def self.configure_nettools(machine, interfaces, comm, networks)\n          commands = []\n          entries = []\n          root_device = interfaces.first\n          networks.each do |network|\n            network[:device] = interfaces[network[:interface]]\n\n            entry = TemplateRenderer.render(\"guests/debian/network_#{network[:type]}\",\n              options: network.merge(:root_device => root_device),\n            )\n            entries << entry\n          end",
        "comment": "Configure guest networking using net-tools",
        "label": "What",
        "id": "9841"
    },
    {
        "raw_code": "def index_name_exists?(table_name, index_name)\n        index_name = index_name.to_s\n        indexes(table_name).detect { |i| i.name == index_name }\n      end",
        "comment": "Verifies the existence of an index with a given name.",
        "label": "What",
        "id": "13160"
    },
    {
        "raw_code": "def view_exists?(view_name)\n        query_values(data_source_sql(view_name, type: \"VIEW\"), \"SCHEMA\").any? if view_name.present?\n      rescue NotImplementedError\n        views.include?(view_name.to_s)\n      end",
        "comment": "Checks to see if the view +view_name+ exists on the database.  view_exists?(:ebooks) ",
        "label": "What",
        "id": "13133"
    },
    {
        "raw_code": "def baz1; end\n        end",
        "comment": "class that defines this method is unknown",
        "label": "What",
        "id": "16848"
    },
    {
        "raw_code": "def push_test_metrics_to_gcs\n          init_gcs_client! # init client and exit early if mandatory configuration is missing\n          retry_on_exception(sleep_interval: 30, message: 'Failed to push test metrics to GCS') do\n            gcs_client.put_object(\n              gcs_bucket,\n              metrics_file_name(prefix: 'test'),\n              execution_data.to_json,\n              force: true, content_type: 'application/json'\n            )\n\n            log(:info, \"Pushed #{execution_data.length} test execution entries to GCS\")\n          end",
        "comment": "Push test execution metrics to GCS  @return [void]",
        "label": "What",
        "id": "4621"
    },
    {
        "raw_code": "def kill\n      remove_job do |message|\n        DeadSet.new.kill(message)\n      end",
        "comment": "Move this job from its current set into the Dead set.",
        "label": "What",
        "id": "5129"
    },
    {
        "raw_code": "def up\n    # rubocop:disable Migration/PreventIndexCreation -- Legacy migration\n    add_concurrent_index :vulnerability_reads, [:owasp_top_10, :state, :report_type, :resolved_on_default_branch,\n      # rubocop:enable Migration/PreventIndexCreation\n      :severity, :traversal_ids, :vulnerability_id],\n      where: 'archived = false',\n      name: INDEX_NAME\n  end",
        "comment": "-- Legacy migration",
        "label": "What",
        "id": "4920"
    },
    {
        "raw_code": "def protect_from_path_traversal!(file)\n    PROTECTED_METHODS.each do |method|\n      Gitlab::PathTraversal.check_path_traversal!(self.send(method)) # rubocop: disable GitlabSecurity/PublicSend\n\n    rescue ObjectNotReadyError\n      # Do nothing. This test was attempted before the file was ready for that method\n    end",
        "comment": "Protect against path traversal attacks This takes a list of methods to test for path traversal, e.g. ../../ and checks each of them. This uses `.send` so that any potential errors don't block the entire set from being tested.  @param [CarrierWave::SanitizedFile] @return [Nil] @raise [Gitlab::PathTraversal::PathTraversalAttackError]",
        "label": "What",
        "id": "8062"
    },
    {
        "raw_code": "def finish!\n        @cpu_time_finish = now_cpu\n        @gc_time_finish = now_gc\n        @end = now\n        @allocation_count_finish = now_allocations\n      end",
        "comment": "Record information at the time this event finishes",
        "label": "What",
        "id": "14512"
    },
    {
        "raw_code": "def up; end\n  def down; end\nend",
        "comment": "No-op for https://gitlab.com/gitlab-com/gl-infra/production/-/issues/19464",
        "label": "What",
        "id": "4911"
    },
    {
        "raw_code": "def initialize(content = {})\n        raise ArgumentError, 'content must be a Hash' unless content.is_a?(Hash)\n\n        @content = content\n      end",
        "comment": "@param [Hash] content @return [Message] raise [ArgumentError] if content is not a Hash",
        "label": "What",
        "id": "2393"
    },
    {
        "raw_code": "def self.bat\n          end",
        "comment": "{visibility}_class_method :baz {'private' unless visibility.to_sym == :private} != visibility from reopened class. (Verifies class was reopened.)",
        "label": "What",
        "id": "770"
    },
    {
        "raw_code": "def offense_replacements\n        @offense.corrector.as_replacements.map do |range, replacement|\n          LanguageServer::Protocol::Interface::TextEdit.new(\n            range: LanguageServer::Protocol::Interface::Range.new(\n              start: LanguageServer::Protocol::Interface::Position.new(\n                line: range.line - 1,\n                character: to_position_character(range.column)\n              ),\n              end: LanguageServer::Protocol::Interface::Position.new(\n                line: range.last_line - 1,\n                character: to_position_character(range.last_column)\n              )\n            ),\n            new_text: replacement\n          )\n        end",
        "comment": "rubocop:enable Metrics/MethodLength rubocop:disable Metrics/MethodLength",
        "label": "What",
        "id": "10202"
    },
    {
        "raw_code": "def all_forwarding_offenses_correctable?(send_classifications)\n          return true if target_ruby_version >= 3.4\n\n          send_classifications.none? do |send_node, *|\n            send_node.each_ancestor(:any_block).any?\n          end",
        "comment": "Checks if forwarding is uses both in blocks and outside of blocks. On Ruby 3.3.0, anonymous block forwarding in blocks can be is a syntax error, so we only want to register an offense if we can change all occurrences.",
        "label": "What",
        "id": "10584"
    },
    {
        "raw_code": "def self.transaction_begin?(parsed)\n          # We ignore BEGIN or START in tests\n          unless Rails.env.test?\n            return true if transaction_stmt?(parsed, :TRANS_STMT_BEGIN)\n            return true if transaction_stmt?(parsed, :TRANS_STMT_START)\n          end",
        "comment": "rubocop:enable Metrics/AbcSize",
        "label": "What",
        "id": "3184"
    },
    {
        "raw_code": "def list_codespaces_secrets(repo)\n        paginate \"#{Repository.path repo}/codespaces/secrets\" do |data, last_response|\n          data.secrets.concat last_response.data.secrets\n        end",
        "comment": "List secrets  @param repo [Integer, String, Hash, Repository] A GitHub repository @return [Hash] total_count and list of secrets (each item is hash with name, created_at and updated_at) @see https://docs.github.com/en/rest/codespaces/repository-secrets?apiVersion=2022-11-28#list-repository-secrets",
        "label": "What",
        "id": "15217"
    },
    {
        "raw_code": "def _HtmlBlockTd\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenTd)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockTd = HtmlBlockOpenTd (HtmlBlockTd | !HtmlBlockCloseTd .)* HtmlBlockCloseTd",
        "label": "What",
        "id": "15709"
    },
    {
        "raw_code": "def test_typical_find_with_lock\n      assert_nothing_raised do\n        Person.transaction do\n          Person.lock.find(1)\n        end",
        "comment": "Test typical find.",
        "label": "What",
        "id": "13520"
    },
    {
        "raw_code": "def foo; end\n      )\n      expect(Registry.at('#foo').docstring).to eq \"Docstring here\"\n      expect(Registry.at('#foo').file).to eq '(stdin)'\n    end",
        "comment": "Docstring here",
        "label": "What",
        "id": "773"
    },
    {
        "raw_code": "def environment(data = nil, options = {})\n        sentinel = \"class Application < Rails::Application\\n\"\n        env_file_sentinel = \"Rails.application.configure do\\n\"\n        data ||= yield if block_given?\n\n        in_root do\n          if options[:env].nil?\n            inject_into_file \"config/application.rb\", optimize_indentation(data, 4), after: sentinel, verbose: false\n          else\n            Array(options[:env]).each do |env|\n              inject_into_file \"config/environments/#{env}.rb\", optimize_indentation(data, 2), after: env_file_sentinel, verbose: false\n            end",
        "comment": "Adds configuration code to a \\Rails runtime environment.  By default, adds code inside the +Application+ class in +config/application.rb+ so that it applies to all environments.  environment %(config.asset_host = \"cdn.provider.com\")  Results in:  # config/application.rb class Application < Rails::Application config.asset_host = \"cdn.provider.com\" # ... end  If the +:env+ option is specified, the code will be added to the corresponding file in +config/environments+ instead.  environment %(config.asset_host = \"localhost:3000\"), env: \"development\"  Results in:  # config/environments/development.rb Rails.application.configure do config.asset_host = \"localhost:3000\" # ... end  +:env+ can also be an array. In which case, the code is added to each corresponding file in +config/environments+.  The code can also be specified as the return value of the block:  environment do %(config.asset_host = \"cdn.provider.com\") end  environment(nil, env: \"development\") do %(config.asset_host = \"localhost:3000\") end ",
        "label": "What",
        "id": "14730"
    },
    {
        "raw_code": "def to_s\n        \"trigger\"\n      end",
        "comment": "The String representation of this Trigger.  @return [String]",
        "label": "What",
        "id": "9440"
    },
    {
        "raw_code": "def remove_filters!\n      @filters = []\n    end",
        "comment": "Removes all filters, but leaves in the silencers. Useful if you suddenly need to see entire filepaths in the backtrace that you had already filtered out.",
        "label": "What",
        "id": "13713"
    },
    {
        "raw_code": "def swap(node_or_range1, node_or_range2)\n        range1 = to_range(node_or_range1)\n        range2 = to_range(node_or_range2)\n\n        if range1.end_pos == range2.begin_pos\n          insert_before(range1, range2.source)\n          remove(range2)\n        elsif range2.end_pos == range1.begin_pos\n          insert_before(range2, range1.source)\n          remove(range1)\n        else\n          replace(range1, range2.source)\n          replace(range2, range1.source)\n        end",
        "comment": "Swaps sources at the given ranges.  @param [Parser::Source::Range, RuboCop::AST::Node] node_or_range1 @param [Parser::Source::Range, RuboCop::AST::Node] node_or_range2",
        "label": "What",
        "id": "10283"
    },
    {
        "raw_code": "def create_milestone\n      return unless current_user.can?(:admin_milestone, project)\n\n      new_milestone if new_milestone.persisted?\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6147"
    },
    {
        "raw_code": "def on_send(node)\n          module_node, method_name, first_arg = feature_flag_method?(node)\n          return unless method_name\n\n          return if first_arg.sym_type?\n\n          message = format(MSG, module: module_node.source, method: method_name)\n\n          add_offense(first_arg, message: message) do |corrector|\n            autocorrect(corrector, first_arg)\n          end",
        "comment": "rubocop:disable InternalAffairs/OnSendWithoutOnCSend -- `Feature&.enabled?` is not possible",
        "label": "What",
        "id": "3904"
    },
    {
        "raw_code": "def prepare_variables(input)\n    return input.map { prepare_variables(_1) } if input.is_a?(Array)\n    return input.to_s if input.is_a?(GlobalID) || input.is_a?(Symbol)\n    return input unless input.is_a?(Hash)\n\n    input.to_h do |name, value|\n      [GraphqlHelpers.fieldnamerize(name), prepare_variables(value)]\n    end",
        "comment": "Recursively convert any ruby object we can pass as a variable value to an object we can serialize with JSON, using fieldname-style keys  prepare_variables({ 'my_key' => 1 }) => { 'myKey' => 1 } prepare_variables({ enums: [:FOO, :BAR], user_id: global_id_of(user) }) => { 'enums' => ['FOO', 'BAR'], 'userId' => \"gid://User/123\" } prepare_variables({ nested: { hash_values: { are_supported: true } } }) => { 'nested' => { 'hashValues' => { 'areSupported' => true } } }",
        "label": "What",
        "id": "8398"
    },
    {
        "raw_code": "def upload(io, identify: true)\n    unfurl io, identify: identify\n    upload_without_unfurling io\n  end",
        "comment": "Uploads the +io+ to the service on the +key+ for this blob. Blobs are intended to be immutable, so you shouldn't be using this method after a file has already been uploaded to fit with a blob. If you want to create a derivative blob, you should instead simply create a new blob based on the old one.  Prior to uploading, we compute the checksum, which is sent to the service for transit integrity validation. If the checksum does not match what the service receives, an exception will be raised. We also measure the size of the +io+ and store that in +byte_size+ on the blob record. The content type is automatically extracted from the +io+ unless you specify a +content_type+ and pass +identify+ as false.  Normally, you do not have to call this method directly at all. Use the +create_and_upload!+ class method instead. If you do use this method directly, make sure you are using it on a persisted Blob as otherwise another blob's data might get overwritten on the service.",
        "label": "What",
        "id": "13616"
    },
    {
        "raw_code": "def _reduce_1(val, _values, result)\n result = RDoc::Markup::Document.new(*val[0])\n    result\nend",
        "comment": "State transition tables end ##### reduce 0 omitted",
        "label": "What",
        "id": "16517"
    },
    {
        "raw_code": "def self.run(*args) new.run(*args) end\n\n      def initialize\n        super\n        @cache = {}\n        @search_paths = []\n        add_default_paths\n        add_gem_paths\n        load_cache\n        @search_paths.uniq!\n      end\n\n      def description\n        \"A tool to view documentation in the console like `ri`\"\n      end\n\n      # Runs the command-line utility.\n      #\n      # @example\n      #   YRI.new.run('String#reverse')\n      # @param [Array<String>] args each tokenized argument\n      def run(*args)\n        optparse(*args)\n\n        if ::RbConfig::CONFIG['host_os'] =~ /mingw|win32/\n          @serializer ||= YARD::Serializers::StdoutSerializer.new\n        else\n          @serializer ||= YARD::Serializers::ProcessSerializer.new('less')\n        end\n\n        if @name.nil? || @name.strip.empty?\n          print_usage\n          return exit(1)\n        end",
        "comment": "Helper method to run the utility on an instance. @see #run",
        "label": "What",
        "id": "489"
    },
    {
        "raw_code": "def optimize_repository(eager: false)\n        strategy = if eager\n                     Gitaly::OptimizeRepositoryRequest::Strategy::STRATEGY_EAGER\n                   else\n                     Gitaly::OptimizeRepositoryRequest::Strategy::STRATEGY_HEURISTICAL\n                   end",
        "comment": "Optimize the repository. By default, this will perform heuristical housekeeping in the repository, which is the recommended approach and will only optimize what needs to be optimized. If `eager = true`, then Gitaly will instead be asked to perform eager housekeeping. As a consequence the housekeeping run will take a _lot_ longer. It is not recommended to use eager housekeeping in general, but only in situations where it is explicitly required.",
        "label": "What",
        "id": "1790"
    },
    {
        "raw_code": "def show\n    if @group\n      @group_members = present_members(\n        @group.members.order(\"access_level DESC\").page(params[:group_members_page]))\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6466"
    },
    {
        "raw_code": "def respond_to_missing?(command_name, include_private = false)\n        true\n      end",
        "comment": "rubocop:enable GitlabSecurity/PublicSend",
        "label": "What",
        "id": "1899"
    },
    {
        "raw_code": "def default_factory\n          @default_factory ||= DefaultFactory.new\n        end",
        "comment": "@!attribute default_factory Replace the factory object responsible for parsing tags by setting this to an object (or class) that responds to +parse_TAGNAME+ methods where +TAGNAME+ is the name of the tag.  You should set this value before performing any source parsing with YARD, otherwise your factory class will not be used.  @example YARD::Tags::Library.default_factory = MyFactory  @see DefaultFactory",
        "label": "What",
        "id": "237"
    },
    {
        "raw_code": "def import_comments(issuable_type)\n        resource_type = \"#{issuable_type}_comments\".to_sym\n\n        # Two notes here:\n        # 1. We don't have a distinctive attribute for comments (unlike issues\n        # iid), so we fetch the last inserted note, compare it against every\n        # comment in the current imported page until we find match, and that's\n        # where start importing\n        # 2. GH returns comments for _both_ issues and PRs through\n        # issues_comments API, while pull_requests_comments returns only\n        # comments on diffs, so select last note not based on noteable_type but\n        # on line_code\n        line_code_is = issuable_type == :pull_requests ? 'NOT NULL' : 'NULL'\n        last_note    = project.notes.where(\"line_code IS #{line_code_is}\").last\n\n        fetch_resources(resource_type, repo, per_page: 100) do |comments|\n          if last_note\n            discard_inserted_comments(comments, last_note)\n            last_note = nil\n          end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "1771"
    },
    {
        "raw_code": "def pipeline_schedule_variable\n          @pipeline_schedule_variable ||=\n            pipeline_schedule.variables.find_by(key: params[:key]).tap do |pipeline_schedule_variable|\n              unless pipeline_schedule_variable\n                not_found!('Pipeline Schedule Variable')\n              end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3817"
    },
    {
        "raw_code": "def self.home_dir\n    HOMEDIR\n  end",
        "comment": " The location of the rdoc data in the user's home directory.  Like ::system, ri data in the user's home directory is rare and predates libraries distributed via RubyGems.  ri data is rarely generated into this directory.",
        "label": "What",
        "id": "16561"
    },
    {
        "raw_code": "def autocorrect(corrector, node)\n          [\n            heredoc_opening_delimiter_range_from(node),\n            heredoc_closing_delimiter_range_from(node)\n          ].each do |range|\n            corrector.replace(range, EXPECTED_HEREDOC_DELIMITER)\n          end",
        "comment": "@param corrector [RuboCop::Cop::Corrector] @param node [RuboCop::AST::StrNode] @return [void]",
        "label": "What",
        "id": "10327"
    },
    {
        "raw_code": "def primary_key\n            reset_primary_key if PRIMARY_KEY_NOT_SET.equal?(@primary_key)\n            @primary_key\n          end",
        "comment": "Defines the primary key field -- can be overridden in subclasses. Overwriting will negate any effect of the +primary_key_prefix_type+ setting, though.",
        "label": "What",
        "id": "12858"
    },
    {
        "raw_code": "def signature(meth)\n          # use first overload tag if it has a return type and method itself does not\n          if !meth.tag(:return) && meth.tag(:overload) && meth.tag(:overload).tag(:return)\n            meth = meth.tag(:overload)\n          end",
        "comment": "@return [String] the formatted signature for a method",
        "label": "What",
        "id": "455"
    },
    {
        "raw_code": "def personal_access_token\n        @personal_access_token ||= begin\n          admin_token = ENV['GITLAB_QA_ADMIN_ACCESS_TOKEN']\n          user_token = ENV['GITLAB_QA_ACCESS_TOKEN']\n\n          if admin_token.blank? && user_token.blank?\n            abort(\"\\nPlease provide either GITLAB_QA_ADMIN_ACCESS_TOKEN or GITLAB_QA_ACCESS_TOKEN\")\n          end",
        "comment": "Returns the appropriate personal access token for API authentication  Retrieves and memoizes a GitLab personal access token, prioritizing admin tokens when available. Admin tokens (GITLAB_QA_ADMIN_ACCESS_TOKEN) are preferred for environments that support admin scope operations, as they're required for cleaning up User resources and other admin-level operations.  Admin tokens will soon be required for resource cleanup  @return [String] Personal access token for GitLab API authentication @raise [SystemExit] Aborts program execution if neither token environment variable is set",
        "label": "What",
        "id": "4743"
    },
    {
        "raw_code": "def in_order_of(column, values, filter: true)\n      model.disallow_raw_sql!([column], permit: model.adapter_class.column_name_with_order_matcher)\n      return spawn.none! if values.empty?\n\n      references = column_references([column])\n      self.references_values |= references unless references.empty?\n\n      values = values.map { |value| model.type_caster.type_cast_for_database(column, value) }\n      arel_column = column.is_a?(Arel::Nodes::SqlLiteral) ? column : order_column(column.to_s)\n\n      scope = spawn.order!(build_case_for_value_position(arel_column, values, filter: filter))\n\n      if filter\n        where_clause =\n          if values.include?(nil)\n            arel_column.in(values.compact).or(arel_column.eq(nil))\n          else\n            arel_column.in(values)\n          end",
        "comment": "Applies an <tt>ORDER BY</tt> clause based on a given +column+, ordered and filtered by a specific set of +values+.  User.in_order_of(:id, [1, 5, 3]) # SELECT \"users\".* FROM \"users\" #   WHERE \"users\".\"id\" IN (1, 5, 3) #   ORDER BY CASE #     WHEN \"users\".\"id\" = 1 THEN 1 #     WHEN \"users\".\"id\" = 5 THEN 2 #     WHEN \"users\".\"id\" = 3 THEN 3 #   END ASC  +column+ can point to an enum column; the actual query generated may be different depending on the database adapter and the column definition.  class Conversation < ActiveRecord::Base enum :status, [ :active, :archived ] end  Conversation.in_order_of(:status, [:archived, :active]) # SELECT \"conversations\".* FROM \"conversations\" #   WHERE \"conversations\".\"status\" IN (1, 0) #   ORDER BY CASE #     WHEN \"conversations\".\"status\" = 1 THEN 1 #     WHEN \"conversations\".\"status\" = 0 THEN 2 #   END ASC  +values+ can also include +nil+.  Conversation.in_order_of(:status, [nil, :archived, :active]) # SELECT \"conversations\".* FROM \"conversations\" #   WHERE (\"conversations\".\"status\" IN (1, 0) OR \"conversations\".\"status\" IS NULL) #   ORDER BY CASE #     WHEN \"conversations\".\"status\" IS NULL THEN 1 #     WHEN \"conversations\".\"status\" = 1 THEN 2 #     WHEN \"conversations\".\"status\" = 0 THEN 3 #   END ASC  +filter+ can be set to +false+ to include all results instead of only the ones specified in +values+.  Conversation.in_order_of(:status, [:archived, :active], filter: false) # SELECT \"conversations\".* FROM \"conversations\" #   ORDER BY CASE #     WHEN \"conversations\".\"status\" = 1 THEN 1 #     WHEN \"conversations\".\"status\" = 0 THEN 2 #     ELSE 3 #   END ASC",
        "label": "What",
        "id": "13406"
    },
    {
        "raw_code": "def internal_include_prepended?\n          true\n        end",
        "comment": ":nocov: rubocop:enable Gitlab/NoCodeCoverageComment",
        "label": "What",
        "id": "2499"
    },
    {
        "raw_code": "def board_url(board, **options)\n        if board.project_board?\n          instance.project_board_url(board.resource_parent, board, **options)\n        else\n          instance.group_board_url(board.resource_parent, board, **options)\n        end",
        "comment": "rubocop:enable Metrics/AbcSize rubocop:enable Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "1337"
    },
    {
        "raw_code": "def markdown(text, options = {})\n        options[:text] = text\n        options[:repo] = Repository.new(options[:repo]) if options[:repo]\n        options[:accept] = 'application/vnd.github.raw'\n\n        post 'markdown', options\n      end",
        "comment": "Render an arbitrary Markdown document  @param text [String] Markdown source @option options [String] (optional) :mode (`markdown` or `gfm`) @option options [String] (optional) :context Repo context @return [String] HTML renderization @see https://developer.github.com/v3/markdown/#render-an-arbitrary-markdown-document @example Render some GFM Octokit.markdown('Fixed in #111', :mode => \"gfm\", :context => \"octokit/octokit.rb\")",
        "label": "What",
        "id": "15214"
    },
    {
        "raw_code": "def up\n    create_table :vulnerability_namespace_historical_statistics do |t|\n      t.bigint :namespace_id, null: false, index: { name: NAMESPACE_ID_FK_INDEX_NAME }\n      t.timestamps_with_timezone null: false\n      t.bigint :traversal_ids, array: true, default: [], null: false\n      t.integer :total, default: 0, null: false\n      t.integer :critical, default: 0, null: false\n      t.integer :high, default: 0, null: false\n      t.integer :medium, default: 0, null: false\n      t.integer :low, default: 0, null: false\n      t.integer :unknown, default: 0, null: false\n      t.integer :info, default: 0, null: false\n      t.date :date, null: false\n      t.integer :letter_grade, limit: 1, null: false\n      t.index [:traversal_ids, :date], unique: true, name: TRAVERSAL_IDS_DATE_INDEX_NAME\n    end",
        "comment": "rubocop:disable Migration/EnsureFactoryForTable -- False Positive",
        "label": "What",
        "id": "4982"
    },
    {
        "raw_code": "def interrupt_job_during_step(job, step, cursor: nil, &block)\n        require_active_job_test_adapter!(\"interrupt_job_during_step\")\n        queue_adapter.with(stopping: ->() { during_step?(job, step, cursor: cursor) }, &block)\n      end",
        "comment": "Interrupt a job during a step.  class MyJob < ApplicationJob include ActiveJob::Continuable  cattr_accessor :items, default: [] def perform step :my_step, start: 1 do |step| (step.cursor..10).each do |i| items << i step.advance! end end end end  test \"interrupt job during step\" do MyJob.perform_later interrupt_job_during_step(MyJob, :my_step, cursor: 6) { perform_enqueued_jobs } assert_equal [1, 2, 3, 4, 5], MyJob.items perform_enqueued_jobs assert_equal [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], MyJob.items end",
        "label": "What",
        "id": "12154"
    },
    {
        "raw_code": "def protect_against_forgery? # :doc:\n        allow_forgery_protection && (!session.respond_to?(:enabled?) || session.enabled?)\n      end",
        "comment": "Checks if the controller allows forgery protection.",
        "label": "What",
        "id": "11346"
    },
    {
        "raw_code": "def find_by_full_path(path, follow_redirects: false)\n      route_scope = all\n\n      Routable.find_by_full_path(\n        path,\n        follow_redirects: follow_redirects,\n        route_scope: route_scope\n      )\n    end",
        "comment": "Finds a single object by full path match in routes table.  Usage:  Klass.find_by_full_path('gitlab-org/gitlab-foss')  Returns a single object, or nil.",
        "label": "What",
        "id": "7262"
    },
    {
        "raw_code": "def create_or_update_org_dependabot_secret(org, name, options)\n        put \"#{Organization.path org}/dependabot/secrets/#{name}\", options\n      end",
        "comment": "Create or update org secrets  @param org [String] A GitHub organization @param name [String] Name of secret @param options [Hash] encrypted_value and key_id @see https://docs.github.com/en/rest/dependabot/organization-secrets?apiVersion=2022-11-28#create-or-update-an-organization-secret",
        "label": "What",
        "id": "14992"
    },
    {
        "raw_code": "def commits_between(*args)\n        arguments = Octokit::RepoArguments.new(args)\n        date = parse_date(arguments.shift)\n        end_date = parse_date(arguments.shift)\n        if date > end_date\n          raise ArgumentError, \"Start date #{date} does not precede #{end_date}\"\n        end",
        "comment": "Get commits made between two nominated dates  @overload commits_between(repo, start_date, end_date, options = {}) @param repo [Integer, String, Hash, Repository] A GitHub repository @param start_date [String] Start Date on which we want to compare @param end_date [String] End Date on which we want to compare @overload commits_between(repo, start_date, end_date, sha_or_branch, options = {}) @deprecated @param repo [Integer, String, Hash, Repository] A GitHub repository @param start_date [String] Start Date on which we want to compare @param end_date [String] End Date on which we want to compare @param sha_or_branch [String] Commit SHA or branch name from which to start the list @return [Array<Sawyer::Resource>] An array of hashes representing commits @see https://developer.github.com/v3/repos/commits/#list-commits-on-a-repository @example Octokit.commits_between('octokit/octokit.rb', '2012-10-01', '2012-11-01')",
        "label": "What",
        "id": "15060"
    },
    {
        "raw_code": "def change_table_comment(table_name, comment_or_changes)\n        raise NotImplementedError, \"#{self.class} does not support changing table comments\"\n      end",
        "comment": "Changes the comment for a table or removes it if +nil+.  Passing a hash containing +:from+ and +:to+ will make this change reversible in migration:  change_table_comment(:posts, from: \"old_comment\", to: \"new_comment\")",
        "label": "What",
        "id": "13174"
    },
    {
        "raw_code": "def already_appropriate_call?(operand, dot_op)\n          return true if operand.safe_navigation? && dot_op == '&.'\n\n          (operand.dot? || operand.operator_method?) && dot_op == '.'\n        end",
        "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10655"
    },
    {
        "raw_code": "def read_rails_version_from_bundler_lock_file\n      return nil unless gem_versions_in_target\n\n      # Look for `railties` instead of `rails`, to support apps that only use a subset of `rails`\n      # See https://github.com/rubocop/rubocop/pull/11289\n      rails_version_in_target = gem_versions_in_target['railties']\n      return nil unless rails_version_in_target\n\n      gem_version_to_major_minor_float(rails_version_in_target)\n    end",
        "comment": "@return [Float, nil] The Rails version as a `major.minor` Float.",
        "label": "What",
        "id": "10179"
    },
    {
        "raw_code": "def all_organizations(options = {})\n        paginate 'organizations', options\n      end",
        "comment": "List all GitHub organizations  This provides a list of every organization, in the order that they were created.  @param options [Hash] Optional options. @option options [Integer] :since The integer ID of the last Organization that you\u2019ve seen.  @see https://developer.github.com/v3/orgs/#list-all-organizations  @return [Array<Sawyer::Resource>] List of GitHub organizations.",
        "label": "What",
        "id": "15419"
    },
    {
        "raw_code": "def git(commands = {})\n        if commands.is_a?(Symbol)\n          run \"git #{commands}\"\n        else\n          commands.each do |cmd, options|\n            run \"git #{cmd} #{options}\"\n          end",
        "comment": "Runs one or more git commands.  git :init # => runs `git init`  git add: \"this.file that.rb\" # => runs `git add this.file that.rb`  git commit: \"-m 'First commit'\" # => runs `git commit -m 'First commit'`  git add: \"good.rb\", rm: \"bad.cxx\" # => runs `git add good.rb; git rm bad.cxx` ",
        "label": "What",
        "id": "14731"
    },
    {
        "raw_code": "def initialize(note, project, client)\n          @note = note\n          @project = project\n          @client = client\n        end",
        "comment": "note - An instance of `Gitlab::GithubImport::Representation::DiffNote` project - An instance of `Project` client - An instance of `Gitlab::GithubImport::Client`",
        "label": "What",
        "id": "2197"
    },
    {
        "raw_code": "def architecture\n          if !defined?(@_host_architecture)\n            if ENV[\"VAGRANT_HOST_ARCHITECTURE\"].to_s != \"\"\n              return @_host_architecture = ENV[\"VAGRANT_HOST_ARCHITECTURE\"]\n            end",
        "comment": "Detect architecture of host system  @return [String]",
        "label": "What",
        "id": "9194"
    },
    {
        "raw_code": "def track(build, transition)\n      return if build.runner.nil?\n\n      raise InvalidQueueTransition unless transition.to == 'running'\n\n      transition.within_transaction do\n        result = ::Ci::RunningBuild.upsert_build!(build)\n\n        unless result.empty?\n          metrics.increment_queue_operation(:shared_runner_build_new) if build.shared_runner_build?\n\n          result.rows.dig(0, 0)\n        end",
        "comment": " Add runner build tracking entry (used for queuing and for runner fleet dashboard). ",
        "label": "What",
        "id": "5794"
    },
    {
        "raw_code": "def self.metadata_enabled\n        { enabled: true }\n      end",
        "comment": "@return [Hash]",
        "label": "What",
        "id": "3568"
    },
    {
        "raw_code": "def create\n    @book = Book.new(book_params)\n\n    respond_to do |format|\n      if @book.save\n        format.html { redirect_to @book, notice: 'Book was successfully created.' } # aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n        format.json { render :show, status: :created, location: @book }\n      else\n        format.html { render :new }\n        format.json { render json: @book.errors, status: :unprocessable_entity }\n      end",
        "comment": "POST /books POST /books.json",
        "label": "What",
        "id": "10748"
    },
    {
        "raw_code": "def handle_install_failure(error)\n          log(\"Docker container creation failed!\", :error)\n          log(\"For more information on troubleshooting failures, see: '#{TROUBLESHOOTING_LINK}'\", :warn)\n          raise error\n        end",
        "comment": "Handle Docker container creation failure  @param [StandardError] error @return [void]",
        "label": "What",
        "id": "3938"
    },
    {
        "raw_code": "def get_code_scanning_alert(repo, alert_number, options = {})\n        get \"#{Repository.path repo}/code-scanning/alerts/#{alert_number}\", options\n      end",
        "comment": "Gets a single code scanning alert  @param repo [Integer, String, Repository, Hash] A GitHub repository @param alert_number [Integer] The number that identifies an alert  @return [Sawyer::Resource] Code Scanning Alert @see https://docs.github.com/en/rest/code-scanning/code-scanning#get-a-code-scanning-alert",
        "label": "What",
        "id": "15371"
    },
    {
        "raw_code": "def add_alias(var_name, class_obj, old_name, new_name, comment)\n    al = RDoc::Alias.new '', old_name, new_name, comment, singleton: @singleton_classes.key?(var_name)\n    al.record_location @top_level\n    class_obj.add_alias al\n    @stats.add_alias al\n    al\n  end",
        "comment": " Add alias, either from a direct alias definition, or from two method that reference the same function.",
        "label": "What",
        "id": "16141"
    },
    {
        "raw_code": "def none?(*args)\n      return true if @none\n\n      return super if args.present? || block_given?\n      empty?\n    end",
        "comment": "Returns true if there are no records.  When a pattern argument is given, this method checks whether elements in the Enumerable match the pattern via the case-equality operator (<tt>===</tt>).  posts.none?(Comment) # => true or false",
        "label": "What",
        "id": "12636"
    },
    {
        "raw_code": "def prompt_option_tag(type, options)\n          prompt = \\\n            case options\n            when Hash\n              default_options = { year: false, month: false, day: false, hour: false, minute: false, second: false }\n              default_options.merge!(options)[type.to_sym]\n            when String\n              options\n            else\n              I18n.translate(:\"datetime.prompts.#{type}\", locale: @options[:locale])\n            end",
        "comment": "Builds a prompt option tag with supplied options or from default options.  prompt_option_tag(:month, prompt: 'Select month') => \"<option value=\"\">Select month</option>\"",
        "label": "What",
        "id": "11852"
    },
    {
        "raw_code": "def restore_snapshot(snapshot_name)\n        execute(:restore_snapshot, VmId: vm_id,  SnapName: snapshot_name)\n      end",
        "comment": "Restore the given snapshot  @param [String] snapshot_name Name of snapshot to restore @return [nil]",
        "label": "What",
        "id": "9682"
    },
    {
        "raw_code": "def cache_key(type)\n      \"#{type}:#{namespace}:hash\"\n    end",
        "comment": "@param type [String] @return [String]",
        "label": "What",
        "id": "1530"
    },
    {
        "raw_code": "def _Label\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"[\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Label = \"[\" (!\"^\" &{ notes? } | &. &{ !notes? }) @StartList:a (!\"]\" Inline:l { a << l })* \"]\" { a.join.gsub(/\\s+/, ' ') }",
        "label": "What",
        "id": "15777"
    },
    {
        "raw_code": "def rate_limited?\n        rate_limiter.rate_limited?\n      end",
        "comment": "@return [Boolean] Whether or not the WebHook is currently throttled.",
        "label": "What",
        "id": "7495"
    },
    {
        "raw_code": "def present_as_json\n      Gitlab::Json.generate(present.deep_transform_keys { |k| k.to_s.camelize(:lower) })\n    end",
        "comment": "rubocop:enable Metrics/AbcSize",
        "label": "What",
        "id": "5411"
    },
    {
        "raw_code": "def reset\n          @refs = []\n          # also reset anything that builds up from the refs array\n        end",
        "comment": "Resets the adapter to a clean state",
        "label": "What",
        "id": "1150"
    },
    {
        "raw_code": "def up\n    with_lock_retries do\n      remove_foreign_key_if_exists(\n        :work_item_colors,\n        column: :namespace_id,\n        on_delete: :nullify,\n        name: OLD_FK_NAME\n      )\n    end",
        "comment": "new foreign key added in FixWorkItemColorsCascadeOptionOnFkToNamespaceId and validated in ValidateNewNamespaceIdFkOnWorkItemColors",
        "label": "What",
        "id": "4981"
    },
    {
        "raw_code": "def self.reset!\n        instance_variables.each(&method(:remove_instance_variable))\n      end",
        "comment": "@private Reset the cached values for platform. This is not considered a public API and should only be used for testing.",
        "label": "What",
        "id": "9277"
    },
    {
        "raw_code": "def find_file(path_info, accept_encoding:)\n        each_candidate_filepath(path_info) do |filepath, content_type|\n          if response = try_files(filepath, content_type, accept_encoding: accept_encoding)\n            return response\n          end",
        "comment": "Match a URI path to a static file to be served.  Used by the `Static` class to negotiate a servable file in the `public/` directory (see Static#call).  Checks for `path`, `path`.html, and `path`/index.html files, in that order, including .br and .gzip compressed extensions.  If a matching file is found, the path and necessary response headers (Content-Type, Content-Encoding) are returned.",
        "label": "What",
        "id": "11541"
    },
    {
        "raw_code": "def schedule(timestamp, job)\n      Sidekiq.redis do |conn|\n        conn.zadd(name, timestamp.to_f.to_s, Sidekiq.dump_json(job))\n      end",
        "comment": "Add a job with the associated timestamp to this set. @param timestamp [Time] the score for the job @param job [Hash] the job data",
        "label": "What",
        "id": "5135"
    },
    {
        "raw_code": "def self.main(parent_context) # rubocop:disable Metrics/MethodLength -- this is a won't fix\n                parent_context => {\n                  params: params,\n                  workspace: workspace,\n                  logger: logger\n                }\n\n                context = {\n                  workspace_id: workspace.id,\n                  workspace_name: workspace.name,\n                  workspace_namespace: workspace.namespace,\n                  workspace_desired_state_is_running: workspace.desired_state_running?,\n                  workspaces_agent_id: params[:agent].id,\n                  workspaces_agent_config: workspace.workspaces_agent_config,\n                  processed_devfile_yaml: workspace.processed_devfile,\n                  logger: logger,\n                  desired_config_array: []\n                }\n\n                initial_result = Gitlab::Fp::Result.ok(context)\n\n                result =\n                  initial_result\n                    .map(BmConfigValuesExtractor.method(:extract))\n                    .map(BmDevfileParserGetter.method(:get))\n                    .map(BmDesiredConfigYamlParser.method(:parse))\n                    .map(BmDevfileResourceModifier.method(:modify))\n                    .map(BmDevfileResourceAppender.method(:append))\n                    .map(\n                      ->(context) do\n                        context.merge(\n                          desired_config:\n                            RemoteDevelopment::WorkspaceOperations::BmDesiredConfig.new(\n                              desired_config_array: context.fetch(:desired_config_array)\n                            )\n                        )\n                      end",
        "comment": "@param [Hash] parent_context @return [Hash]",
        "label": "What",
        "id": "3331"
    },
    {
        "raw_code": "def next_batch(table_name, column_name, batch_min_value:, batch_size:, job_arguments:, job_class: nil)\n          model_class = define_batchable_model(table_name, connection: connection)\n\n          quoted_column_name = model_class.connection.quote_column_name(column_name)\n          relation = model_class.where(\"#{quoted_column_name} >= ?\", batch_min_value)\n          next_batch_bounds = nil\n\n          relation.distinct_each_batch(of: batch_size, column: column_name) do |batch|\n            next_batch_bounds = batch.pick(Arel.sql(\"MIN(#{quoted_column_name}), MAX(#{quoted_column_name})\"))\n\n            break\n          end",
        "comment": "Finds and returns the next batch in the table.  table_name - The table to batch over column_name - The column to batch over batch_min_value - The minimum value which the next batch will start at batch_size - The size of the next batch job_arguments - The migration job arguments job_class - The migration job class",
        "label": "What",
        "id": "3296"
    },
    {
        "raw_code": "def err?\n        !ok?\n      end",
        "comment": "The `err?` attribute is false if the Result was constructed with .ok, and true if it was constructed with .err \"#err?\" corresponds to \"is_err\" in Rust.  @return [Boolean]",
        "label": "What",
        "id": "2379"
    },
    {
        "raw_code": "def add_team_repository(team_id, repo, options = {})\n        boolean_from_response :put, \"teams/#{team_id}/repos/#{Repository.new(repo)}\", options\n      end",
        "comment": "Add team repository  This can also be used to update the permission of an existing team  Requires authenticated user to be an owner of the organization that the team is associated with. Also, the repo must be owned by the organization, or a direct form of a repo owned by the organization.  @param team_id [Integer] Team id. @param repo [String, Hash, Repository] A GitHub repository. @option options [String] :permission The permission to grant the team. Only valid on organization-owned repositories. Can be one of: <tt>pull</tt>, <tt>push</tt>, or <tt>admin</tt>. If not specified, the team's <tt>permission</tt> attribute will be used to determine what permission to grant the team on this repository. @return [Boolean] True if successful, false otherwise. @see Octokit::Repository @see https://developer.github.com/v3/orgs/teams/#add-or-update-team-repository @example @client.add_team_repository(100000, 'github/developer.github.com') @example @client.add_team_repo(100000, 'github/developer.github.com') @example Add a team with admin permissions @client.add_team_repository(100000, 'github/developer.github.com', permission: 'admin')",
        "label": "What",
        "id": "15444"
    },
    {
        "raw_code": "def [](*key)\n        begin\n          @header[key[0].downcase].join(\", \")\n        rescue StandardError, NameError\n          super\n        end",
        "comment": " Retrieves the header at the first entry in +key+",
        "label": "What",
        "id": "672"
    },
    {
        "raw_code": "def self.kill(signal)\n      Process.kill(signal, Process.pid)\n    end",
        "comment": "Kill will send the given signal to the current process.",
        "label": "What",
        "id": "1344"
    },
    {
        "raw_code": "def self.path(repo)\n      new(repo).path\n    end",
        "comment": "Get the api path for a repo @param repo [Integer, String, Hash, Repository] A GitHub repository. @return [String] Api path.",
        "label": "What",
        "id": "14919"
    },
    {
        "raw_code": "def unique_milestone_ids_from_events\n    eventable.resource_milestone_events.select(:milestone_id).distinct\n  end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7858"
    },
    {
        "raw_code": "def destroy(id)\n      multiple_ids = if model.composite_primary_key?\n        id.first.is_a?(Array)\n      else\n        id.is_a?(Array)\n      end",
        "comment": "Destroy an object (or multiple objects) that has the given id. The object is instantiated first, therefore all callbacks and filters are fired off before the object is deleted. This method is less efficient than #delete but allows cleanup methods and other actions to be run.  This essentially finds the object (or multiple objects) with the given id, creates a new object from the attributes, and then calls destroy on it.  ==== Parameters  * +id+ - This should be the id or an array of ids to be destroyed.  ==== Examples  # Destroy a single object Todo.destroy(1)  # Destroy multiple objects todos = [1,2,3] Todo.destroy(todos)",
        "label": "What",
        "id": "12656"
    },
    {
        "raw_code": "def test; end\n          end",
        "comment": "{access_modifier} # let's modify the rest {'^' * access_modifier.size} Keep a blank line before and after `#{access_modifier}`.",
        "label": "What",
        "id": "10831"
    },
    {
        "raw_code": "def deactivate_deployments_with_same_path_prefix\n    project.pages_deployments.active.id_not_in(id).with_path_prefix(path_prefix).each(&:deactivate)\n  end",
        "comment": "Stop existing active deployment with same path when a deleted one is restored",
        "label": "What",
        "id": "7117"
    },
    {
        "raw_code": "def project_id\n          @project_id ||= Project.where_full_path_in([full_path], preload_routes: false).pluck(:id)\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2728"
    },
    {
        "raw_code": "def all_cops?\n      cops == 'all'\n    end",
        "comment": "Checks if all cops specified in this directive",
        "label": "What",
        "id": "10105"
    },
    {
        "raw_code": "def metadata\n        model_class = case object.package.package_type\n                      when 'nuget'\n                        ::Packages::Nuget::DependencyLinkMetadatum\n                      end",
        "comment": "NOTE: This method must be kept in sync with the union type: `Types::Packages::DependencyLinkMetadata`.  `Types::Packages::DependencyLinkMetadata.resolve_type(metadata, ctx)` must never raise.",
        "label": "What",
        "id": "6216"
    },
    {
        "raw_code": "def revert_backfill_conversion_of_integer_to_bigint(table, columns, primary_key: :id)\n        Gitlab::Database::Migrations::Conversions::BigintConverter\n          .new(self, table, columns)\n          .revert_backfill(primary_key: primary_key)\n      end",
        "comment": "Reverts `backfill_conversion_of_integer_to_bigint`  table - The name of the database table containing the column columns - The name, or an array of names, of the column(s) we want to convert to bigint. primary_key - The name of the primary key column (most often :id)",
        "label": "What",
        "id": "2999"
    },
    {
        "raw_code": "def container_versions_script\n      logger.info(\"Fetching container versions script for ref '#{ref}'\")\n      downstream_client.file_contents(\n        downstream_project_path,\n        \"build-scripts/container_versions.sh\",\n        ref\n      )\n    end",
        "comment": "Script used for container version calculations in CNG build jobs  @return [String]",
        "label": "What",
        "id": "5269"
    },
    {
        "raw_code": "def decode(json, options = {})\n        data = ::JSON.parse(json, options)\n\n        if ActiveSupport.parse_json_times\n          convert_dates_from(data)\n        else\n          data\n        end",
        "comment": "Parses a JSON string (JavaScript Object Notation) into a Ruby object. See http://www.json.org for more info.  ActiveSupport::JSON.decode(\"{\\\"team\\\":\\\"rails\\\",\\\"players\\\":\\\"36\\\"}\") # => {\"team\" => \"rails\", \"players\" => \"36\"} ActiveSupport::JSON.decode(\"2.39\") # => 2.39",
        "label": "What",
        "id": "14482"
    },
    {
        "raw_code": "def apply_query_customization(query)\n            query.joins(:metrics)\n          end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2885"
    },
    {
        "raw_code": "def self.remove(key)\n      RENDERERS.delete(key.to_sym)\n      method_name = _render_with_renderer_method_name(key)\n      remove_possible_method(method_name)\n    end",
        "comment": "This method is the opposite of add method.  To remove a csv renderer:  ActionController::Renderers.remove(:csv)",
        "label": "What",
        "id": "11322"
    },
    {
        "raw_code": "def dig(*args)\n      args[0] = convert_key(args[0]) if args.size > 0\n      super(*args)\n    end",
        "comment": "Same as <tt>Hash#dig</tt> where the key passed as argument can be either a string or a symbol:  counters = ActiveSupport::HashWithIndifferentAccess.new counters[:foo] = { bar: 1 }  counters.dig('foo', 'bar')     # => 1 counters.dig(:foo, :bar)       # => 1 counters.dig(:zoo)             # => nil",
        "label": "What",
        "id": "13881"
    },
    {
        "raw_code": "def all_attributes\n        @all_attributes ||= self.class.ancestors\n                                .select { |clazz| clazz <= QA::Resource::Base }\n                                .map { |clazz| clazz.instance_variable_get(:@attribute_names) } # rubocop:disable Performance/FlatMap\n                                .flatten\n                                .compact\n      end",
        "comment": "Get all defined attributes across all parents  @return [Array<Symbol>]",
        "label": "What",
        "id": "4138"
    },
    {
        "raw_code": "def check_send_node(node, cur_vis, unused)\n          if node.bare_access_modifier?\n            check_new_visibility(node, unused, node.method_name, cur_vis)\n          elsif node.method?(:private_class_method) && !node.arguments?\n            add_offense(node, message: format(MSG, current: node.method_name)) do |corrector|\n              autocorrect(corrector, node)\n            end",
        "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10683"
    },
    {
        "raw_code": "def check_disjunctive_assignment(node)\n          lhs = node.child_nodes.first\n          return unless lhs.ivasgn_type?\n\n          add_offense(node.loc.operator) do |corrector|\n            corrector.replace(node.loc.operator, '=')\n          end",
        "comment": "Add an offense if the LHS of the given disjunctive assignment is an instance variable.  For now, we only care about assignments to instance variables.  @param [Node] node a disjunctive assignment",
        "label": "What",
        "id": "10635"
    },
    {
        "raw_code": "def self.restore_full_path(namespace:, project:)\n        if project.include?(ENCODED_SLASH)\n          # Replace multiple slashes with single ones to make sure the redirect stays on the same host\n          # full_path should not start with a `/`\n          project.gsub(ENCODED_SLASH, SLASH).gsub(%r{\\/{2,}}, '/').gsub(%r{^\\/}, '')\n        else\n          \"#{namespace}/#{project}\"\n        end",
        "comment": "To interpret two types of project names stored by Jira (see `encode_project_name`)  @param [String] project Either an encoded full path, or just project name @param [String] namespace",
        "label": "What",
        "id": "2899"
    },
    {
        "raw_code": "def has_update?(version=nil, download_options: {})\n      if !@metadata_url\n        raise Errors::BoxUpdateNoMetadata, name: @name\n      end",
        "comment": "Checks if the box has an update and returns the metadata, version, and provider. If the box doesn't have an update that satisfies the constraints, it will return nil.  This will potentially make a network call if it has to load the metadata from the network.  @param [String] version Version constraints the update must satisfy. If nil, the version constrain defaults to being a larger version than this box. @return [Array]",
        "label": "What",
        "id": "8725"
    },
    {
        "raw_code": "def dependency_changes\n          changed_files.any? { |file| file.match?(DEPENDENCY_PATTERN) }\n        end",
        "comment": "Changes to gitlab dependencies  @return [Boolean]",
        "label": "What",
        "id": "4808"
    },
    {
        "raw_code": "def has_active_hooks?(hooks_scope = :push_hooks)\n    false\n  end",
        "comment": "overriden in EE",
        "label": "What",
        "id": "7029"
    },
    {
        "raw_code": "def update_member(user, access_level: AccessLevel::DEVELOPER)\n        Support::Retrier.retry_until do\n          QA::Runtime::Logger.info(%(Updating user #{user.username} in #{full_path} #{self.class.name}))\n          response = put Runtime::API::Request.new(api_client, \"#{api_members_path}/#{user.id}\").url,\n            { access_level: access_level }\n          next true if success?(response.code)\n        end",
        "comment": "Update the access level for single user in a group or project  @param [Resource::User] user @param [Integer] access_level (default Developer)",
        "label": "What",
        "id": "4100"
    },
    {
        "raw_code": "def increase\n      redis_cmd do |redis|\n        redis.incr(key)\n        redis.expire(key, REFERENCE_EXPIRE_TIME)\n      end",
        "comment": "Increase the counter  @return [Boolean] whether operation was a success",
        "label": "What",
        "id": "1693"
    },
    {
        "raw_code": "def _HtmlBlockCloseTbody\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseTbody = \"<\" Spnl \"/\" (\"tbody\" | \"TBODY\") Spnl \">\"",
        "label": "What",
        "id": "15705"
    },
    {
        "raw_code": "def attach_disk(controller_name, port, device, type, file, **opts)\n          comment = \"This disk is managed externally by Vagrant. Removing or adjusting settings could potentially cause issues with Vagrant.\"\n\n          execute('storageattach', @uuid,\n                  '--storagectl', controller_name,\n                  '--port', port.to_s,\n                  '--device', device.to_s,\n                  '--type', type,\n                  '--medium', file,\n                  '--comment', comment)\n        end",
        "comment": "Controller-Port-Device looks like: SATA Controller-ImageUUID-0-0 (sub out ImageUUID) - Controller: SATA Controller - Port: 0 - Device: 0  @param [String] controller_name - name of storage controller to attach disk to @param [String] port - port on device to attach disk to @param [String] device - device on controller for disk @param [String] type - type of disk to attach @param [String] file - disk file path @param [Hash]   opts -  additional options",
        "label": "What",
        "id": "9606"
    },
    {
        "raw_code": "def create_service?\n    class_name = self.class.name\n\n    class_name.include?('WorkItems::CreateService') || class_name.include?('Issues::CreateService')\n  end",
        "comment": "Method to determine if this is a create service for a WorkItem or Issue",
        "label": "What",
        "id": "5487"
    },
    {
        "raw_code": "def show\n  end",
        "comment": "GET /books/1 GET /books/1.json",
        "label": "What",
        "id": "10736"
    },
    {
        "raw_code": "def visit_Arel_Nodes_SelectOptions(o, collector)\n          collector = maybe_visit o.limit, collector\n          collector = maybe_visit o.offset, collector\n          maybe_visit o.lock, collector\n        end",
        "comment": "The Oracle enhanced adapter uses this private method, see https://github.com/rsim/oracle-enhanced/issues/2186",
        "label": "What",
        "id": "13484"
    },
    {
        "raw_code": "def stop_workers\n          if @status == :stop # rubocop:disable Gitlab/ModuleWithInstanceVariables\n            Gitlab::Cluster::LifecycleEvents.do_before_graceful_shutdown\n          end",
        "comment": "This looks at internal status of `Puma::Cluster` https://github.com/puma/puma/blob/v3.12.1/lib/puma/cluster.rb#L333",
        "label": "What",
        "id": "1974"
    },
    {
        "raw_code": "def non_splat_or_block_pass_lvar_references(body)\n          body.each_descendant(:lvar, :lvasgn).filter_map do |lvar|\n            parent = lvar.parent\n\n            next if lvar.lvar_type? && FORWARDING_LVAR_TYPES.include?(parent.type)\n\n            lvar.children.first\n          end.uniq\n        end",
        "comment": "rubocop:enable Metrics/AbcSize, Metrics/MethodLength",
        "label": "What",
        "id": "10583"
    },
    {
        "raw_code": "def rdoc_installed?\n    File.exist? @rdoc_dir\n  end",
        "comment": " Is rdoc documentation installed?",
        "label": "What",
        "id": "15905"
    },
    {
        "raw_code": "def self.sleep(duration_s)\n      Kernel.sleep(duration_s)\n    end",
        "comment": "sleep will sleep for the specified duration",
        "label": "What",
        "id": "1343"
    },
    {
        "raw_code": "def respond_to?(sym, include_private = false)\n          @dn.respond_to?(sym, include_private)\n        end",
        "comment": " Redefined to be consistent with redefined `method_missing` behavior",
        "label": "What",
        "id": "2353"
    },
    {
        "raw_code": "def docstring=(comments)\n        @docstrings.clear\n        @docstring = Docstring === comments ?\n          comments : Docstring.new(comments, self)\n      end",
        "comment": "Attaches a docstring to a code object by parsing the comments attached to the statement and filling the {#tags} and {#docstring} methods with the parsed information.  @param [String, Array<String>, Docstring] comments the comments attached to the code object to be parsed into a docstring and meta tags.",
        "label": "What",
        "id": "577"
    },
    {
        "raw_code": "def save_lfs_data\n        %w[project wiki].each do |repository_type|\n          create(\n            :lfs_objects_project,\n            project: project,\n            repository_type: repository_type,\n            lfs_object: lfs_object\n          )\n        end",
        "comment": "Use the LfsSaver to save data to be restored",
        "label": "What",
        "id": "8238"
    },
    {
        "raw_code": "def call(env)\n        request = Rack::Request.new(env)\n        request.path_info = unescape(request.path_info) # unescape things like %3F\n        router.call(request)\n      rescue StandardError => ex\n        log.backtrace(ex)\n        [500, {'Content-Type' => 'text/plain'},\n          [ex.message + \"\\n\" + ex.backtrace.join(\"\\n\")]]\n      end",
        "comment": "Responds to Rack requests and builds a response with the {Router}. @return [Array(Numeric,Hash,Array)] the Rack-style response",
        "label": "What",
        "id": "691"
    },
    {
        "raw_code": "def set_skip_metadata(example)\n          return if Runtime::Scenario.attributes[:test_metadata_only]\n          return skip_only(example.metadata) if example.metadata.key?(:only)\n          return skip_except(example.metadata) if example.metadata.key?(:except)\n        end",
        "comment": "Skip example_group or example  @param [<RSpec::Core::ExampleGroup, RSpec::Core::Example>] example @return [void]",
        "label": "What",
        "id": "4608"
    },
    {
        "raw_code": "def references(*args, **options)\n        args.each do |ref_name|\n          ReferenceDefinition.new(ref_name, **options).add_to(self)\n        end",
        "comment": "Adds a reference.  t.references(:user) t.belongs_to(:supplier, foreign_key: true) t.belongs_to(:supplier, foreign_key: true, type: :integer)  See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.",
        "label": "What",
        "id": "13103"
    },
    {
        "raw_code": "def verify_same_origin_request # :doc:\n        if marked_for_same_origin_verification? && non_xhr_javascript_response?\n          if logger && log_warning_on_csrf_failure\n            logger.warn CROSS_ORIGIN_JAVASCRIPT_WARNING\n          end",
        "comment": ":startdoc: If `verify_authenticity_token` was run (indicating that we have forgery protection enabled for this request) then also verify that we aren't serving an unauthorized cross-origin response.",
        "label": "What",
        "id": "11335"
    },
    {
        "raw_code": "def all_commit_shas\n    return commit_shas unless persisted?\n\n    all_commits.pluck(:sha).uniq\n  end",
        "comment": "Note that this could also return SHA from now dangling commits ",
        "label": "What",
        "id": "6993"
    },
    {
        "raw_code": "def add_spec(gem_spec, name = gem_spec.full_name)\n    # No idea why, but the Indexer wants to insert them using original_name\n    # instead of full_name. So we make it an optional arg.\n    @gems[name] = gem_spec\n  end",
        "comment": " Add a gem specification to the source index.",
        "label": "What",
        "id": "268"
    },
    {
        "raw_code": "def explicit?\n          ![ZERO_ARITY_SUPER_TYPE, SEND_TYPE].include?(@node.type)\n        end",
        "comment": "There's an implicit variable reference by the zero-arity `super`:  def some_method(foo) super end  Another case is `binding`:  def some_method(foo) do_something(binding) end  In these cases, the variable `foo` is not explicitly referenced, but it can be considered used implicitly by the `super` or `binding`.",
        "label": "What",
        "id": "10698"
    },
    {
        "raw_code": "def metrics_params\n          super.merge(includes_patches: patch_attachments.any?)\n        end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3253"
    },
    {
        "raw_code": "def m\n      end",
        "comment": "123",
        "label": "What",
        "id": "10790"
    },
    {
        "raw_code": "def initialize(user, entity, requesting_user)\n      @user = user\n      @requesting_user = requesting_user\n      @entity = entity\n    end",
        "comment": "@param [User] user user whose membership is being deleted from entity @param [Group, Project] entity @param [User] requesting_user user who initiated the membership deletion of `user`",
        "label": "What",
        "id": "6115"
    },
    {
        "raw_code": "def _HtmlBlockCloseForm\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseForm = \"<\" Spnl \"/\" (\"form\" | \"FORM\") Spnl \">\"",
        "label": "What",
        "id": "15648"
    },
    {
        "raw_code": "def verify_git_repo!(path)\n        if !File.directory?(git_dir(path))\n          raise Errors::NotAGitRepo, path: path\n        end",
        "comment": "Verify that the given path is a git directory. @raise [Errors::NotAGitRepo] @param [String]",
        "label": "What",
        "id": "9372"
    },
    {
        "raw_code": "def delete_box(org, box_name, access_token)\n            account = VagrantCloud::Account.new(\n              custom_server: api_server_url,\n              access_token: access_token\n            )\n            with_box(account: account, org: org, box: box_name) do |box|\n              box.delete\n              @env.ui.success(I18n.t(\"cloud_command.box.delete_success\", org: org, box_name: box_name))\n              0\n            end",
        "comment": "Delete the requested box  @param [String] org Organization name of box @param [String] box_name Name of box @param [String] access_token User access token @return [Integer]",
        "label": "What",
        "id": "9786"
    },
    {
        "raw_code": "def attributes\n    @cache[:attributes]\n  end",
        "comment": " Attributes cache accessor.  Maps a class to an Array of its attributes.",
        "label": "What",
        "id": "15852"
    },
    {
        "raw_code": "def api_client\n        @api_client ||= user.api_client\n      end",
        "comment": "Api client  Api client is set as public for MergeRequestFromFork resource to use correct client  @return [Runtime::API::Client]",
        "label": "What",
        "id": "4096"
    },
    {
        "raw_code": "def execute(accepted:)\n      agreement = @user.term_agreements.find_or_initialize_by(term: @term)\n      agreement.accepted = accepted\n\n      if agreement.save\n        store_accepted_term(accepted)\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5988"
    },
    {
        "raw_code": "def configure\n      if block_given?\n        yield(Configuration.default)\n      else\n        Configuration.default\n      end",
        "comment": "Customize default settings for the SDK using block. ErrorTrackingOpenAPI.configure do |config| config.username = \"xxx\" config.password = \"xxx\" end If no block given, return the default Configuration object.",
        "label": "What",
        "id": "818"
    },
    {
        "raw_code": "def generate_inventory_groups\n          groups_of_groups = {}\n          defined_groups = []\n          group_vars = {}\n          inventory_groups = \"\"\n\n          # Verify if host range patterns exist and warn\n          if config.groups.any? { |gm| gm.to_s[RANGE_PATTERN] }\n            @machine.ui.warn(I18n.t(\"vagrant.provisioners.ansible.ansible_host_pattern_detected\"))\n          end",
        "comment": "Write out groups information. All defined groups will be included, but only supported machines and defined child groups will be included.",
        "label": "What",
        "id": "9887"
    },
    {
        "raw_code": "def unlock_issue(repo, number, options = {})\n        boolean_from_response :delete, \"#{Repository.path repo}/issues/#{number}/lock\", options\n      end",
        "comment": "Unlock an issue's conversation, opening it to all viewers  @param repo [Integer, String, Repository, Hash] A GitHub repository @param number [Integer] Number ID of the issue @return [Boolean] Success @see https://developer.github.com/v3/issues/#unlock-an-issue @example Unlock Issue #25 from octokit/octokit.rb Octokit.close_issue(\"octokit/octokit.rb\", \"25\")",
        "label": "What",
        "id": "15250"
    },
    {
        "raw_code": "def fabrication_type(resource, method)\n          return \"Built\" if method == :browser_ui || [:post, :put].include?(resource.api_fabrication_http_method)\n          return \"Retrieved\" if resource.api_fabrication_http_method == :get || resource.retrieved_from_cache\n\n          Runtime::Logger.warn(\"Resource fabrication http method has not been set properly, assuming :get value!\")\n          \"Built\"\n        end",
        "comment": "Fetch type of fabrication, either resource was built or fetched  @param [Resource] resource @param [Symbol] method @return [String]",
        "label": "What",
        "id": "4131"
    },
    {
        "raw_code": "def standardize_opts(opts)\n        opts ||= {}\n        opts[:mode] = :rails\n        opts[:symbol_keys] = opts[:symbolize_keys] || opts[:symbolize_names]\n\n        opts\n      end",
        "comment": "Take a JSON standard options hash and standardize it to work across adapters An example of this is Oj taking :symbol_keys instead of :symbolize_names  @param opts [Hash, Nil] @return [Hash]",
        "label": "What",
        "id": "1646"
    },
    {
        "raw_code": "def enabled?\n      license_operational_metric_enabled? || ::Gitlab::CurrentSettings.usage_ping_enabled?\n    end",
        "comment": "If it is EE and license operational metric is true, then we will show enable service ping checkbox checked, as it will always send service ping",
        "label": "What",
        "id": "3618"
    },
    {
        "raw_code": "def on_send(node)\n          return if node.arguments.any? || hash_or_set_with_block?(node)\n\n          receiver = find_receiver(node)\n          return unless literal_receiver?(node, receiver) ||\n                        constructor?(node, receiver) ||\n                        chained_conversion?(node, receiver) ||\n                        chained_to_typed_method?(node, receiver)\n\n          message = format(MSG, method: node.method_name)\n\n          add_offense(node.loc.selector, message: message) do |corrector|\n            corrector.remove(node.loc.dot.join(node.loc.end || node.loc.selector))\n          end",
        "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "10636"
    },
    {
        "raw_code": "def _EmphStar\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"*\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "EmphStar = \"*\" !@Whitespace @StartList:a (!\"*\" Inline:b { a << b } | StrongStar:b { a << b })+ \"*\" { emphasis a.join }",
        "label": "What",
        "id": "15755"
    },
    {
        "raw_code": "def delete_registry_repository(project_id, repository_id)\n          response = delete(Runtime::API::Request.new(api_client,\n            \"/projects/#{project_id}/registry/repositories/#{repository_id}\").url)\n\n          if success?(response&.code)\n            logger.info(\"Deleted registry repository #{repository_id}\")\n          else\n            logger.warn(\"Failed to delete registry repository #{repository_id}: #{response&.code}\")\n          end",
        "comment": "Deletes a registry repository  @param [String] project_id Project ID @param [Integer] repository_id Repository ID @return [void]",
        "label": "What",
        "id": "4766"
    },
    {
        "raw_code": "def substitution(*substitution_names, &block)\n          define_command(SubstitutionDefinition, *substitution_names, &block)\n        end",
        "comment": "Registers a new substitution which is recognizable from body of email or comment. It accepts aliases and takes a block with the formatted content.  Example:  command :my_substitution, :alias_for_my_substitution do |text| \"#{text} MY AWESOME SUBSTITUTION\" end",
        "label": "What",
        "id": "2950"
    },
    {
        "raw_code": "def self.chef_installed(machine, product, version)\n            product_name = product == 'chef-workstation' ? 'chef-workstation' : 'chef'\n            verify_bin = product_name == 'chef-workstation' ? 'chef' : 'chef-client'\n            verify_path = \"/opt/#{product_name}/bin/#{verify_bin}\"\n            command = \"test -x #{verify_path}\"\n\n            if version != :latest\n              command << \"&& #{verify_path} --version | grep '#{version}'\"\n            end",
        "comment": "Check if Chef is installed at the given version. @return [true, false]",
        "label": "What",
        "id": "9902"
    },
    {
        "raw_code": "def update_invalid_gpg_signatures\n    user.update_invalid_gpg_signatures if confirmed?\n  end",
        "comment": "once email is confirmed, update the gpg signatures",
        "label": "What",
        "id": "6846"
    },
    {
        "raw_code": "def <=>(other)\n    return unless self.class === other\n\n    [parent_name, name] <=> [other.parent_name, other.name]\n  end",
        "comment": " Constants are ordered by name",
        "label": "What",
        "id": "16806"
    },
    {
        "raw_code": "def initialize(dry_run: false)\n        super\n\n        @type = 'project'\n      end",
        "comment": "@example mark projects for deletion that are older than 24 hours under gitlab-e2e-sandbox-group-<#1-8> groups GITLAB_ADDRESS=<address> \\ GITLAB_QA_ACCESS_TOKEN=<token> bundle exec rake delete_projects  @example permanently delete projects older than 24 hours under all gitlab-e2e-sandbox-group-<#1-8> groups GITLAB_ADDRESS=<address> \\ GITLAB_QA_ACCESS_TOKEN=<token> \\ PERMANENTLY_DELETE=true bundle exec rake delete_projects  @example mark projects for deletion under 'gitlab-e2e-sandbox-group-2' created before 2023-01-01 GITLAB_ADDRESS=<address> \\ GITLAB_QA_ACCESS_TOKEN=<token> \\ TOP_LEVEL_GROUP_NAME=<gitlab-e2e-sandbox-group-2> \\ DELETE_BEFORE=2023-01-01 bundle exec rake delete_projects  @example - dry run GITLAB_ADDRESS=<address> \\ GITLAB_QA_ACCESS_TOKEN=<token> bundle exec rake \"delete_projects[true]\"",
        "label": "What",
        "id": "4727"
    },
    {
        "raw_code": "def self.stop_logging!\n        @@log_requests.value = false\n      end",
        "comment": "Stops logging requests",
        "label": "What",
        "id": "2739"
    },
    {
        "raw_code": "def logger\n      ActionMailer::Base.logger\n    end",
        "comment": "Use the logger configured for ActionMailer::Base.",
        "label": "What",
        "id": "11132"
    },
    {
        "raw_code": "def self.merge_nested_errors(object)\n        object.errors.each do |error|\n          association = object.class.reflect_on_association(error.attribute)\n\n          next unless association&.collection?\n\n          records = object.public_send(error.attribute).select(&:invalid?) # rubocop: disable GitlabSecurity/PublicSend\n\n          records.each do |record|\n            merge_nested_errors(record)\n\n            object.errors.merge!(record.errors)\n          end",
        "comment": "Merges all nested subrelation errors into base errors object.  @example issue = Project.last.issues.new( title: 'test', author: User.first, notes: [Note.new( award_emoji: [AwardEmoji.new(name: 'test')] )])  issue.validate issue.errors.full_messages => [\"Notes is invalid\"]  Gitlab::Import::Errors.merge_nested_errors(issue) issue.errors.full_messages => [\"Notes is invalid\", \"Award emoji is invalid\", \"Awardable can't be blank\", \"Name is not a valid emoji name\", ... ]",
        "label": "What",
        "id": "2922"
    },
    {
        "raw_code": "def test_user_api_token\n          ENV[TEST_USER_API_TOKEN_VARIABLE_NAME]\n        end",
        "comment": "Global test user api token  @return [String]",
        "label": "What",
        "id": "4498"
    },
    {
        "raw_code": "def initialize(user, params)\n      super(nil, user, params.merge(issue: nil))\n    end",
        "comment": "@param user [User] The current user @param [Hash] params @option params [DesignManagement::Design] :current_design @option params [DesignManagement::Design] :previous_design (nil) @option params [DesignManagement::Design] :next_design (nil)",
        "label": "What",
        "id": "6076"
    },
    {
        "raw_code": "def valid_commits?\n    commit_start.present? && commit_end.present?\n  end",
        "comment": "Check if both the starting and ending commit IDs exist in a project's repository",
        "label": "What",
        "id": "6716"
    },
    {
        "raw_code": "def define_commit_box_vars\n    @last_pipeline = @commit.last_pipeline\n\n    return unless @commit.last_pipeline\n\n    @last_pipeline_stages = StageSerializer.new(\n      project: @project,\n      current_user: @current_user\n    ).represent(@last_pipeline.stages)\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6622"
    },
    {
        "raw_code": "def to_html\n      HtmlConversion.node_to_html(node)\n    end",
        "comment": "Converts the attachment to HTML.  attachable = Person.create! name: \"Javan\" attachment = ActionText::Attachment.from_attachable(attachable) attachment.to_html # => \"<action-text-attachment sgid=\\\"BAh7CEk...",
        "label": "What",
        "id": "11689"
    },
    {
        "raw_code": "def deprecate_constant(old_constant_name, new_constant_path, deprecator:, message: nil)\n            class_variable_set(:@@_deprecated_constants, {}) unless class_variable_defined?(:@@_deprecated_constants)\n            class_variable_get(:@@_deprecated_constants)[old_constant_name.to_s] = { new: new_constant_path, message: message, deprecator: deprecator }\n          end",
        "comment": "Provides a way to rename constants with a deprecation cycle in which both the old and new names work, but using the old one prints a deprecation message.  In order to rename <tt>A::B</tt> to <tt>C::D</tt>, you need to delete the definition of <tt>A::B</tt> and declare the deprecation in +A+:  require \"active_support/deprecation\"  module A include ActiveSupport::Deprecation::DeprecatedConstantAccessor  deprecate_constant \"B\", \"C::D\", deprecator: ActiveSupport::Deprecation.new end  The first argument is a constant name (no colons). It is the name of the constant you want to deprecate in the enclosing class or module.  The second argument is the constant path of the replacement. That has to be a full path even if the replacement is defined in the same namespace as the deprecated one was.  In both cases, strings and symbols are supported.  The +deprecator+ keyword argument is the object that will print the deprecation message, an instance of ActiveSupport::Deprecation.  With that in place, references to <tt>A::B</tt> still work, they evaluate to <tt>C::D</tt> now, and trigger a deprecation warning:  DEPRECATION WARNING: A::B is deprecated! Use C::D instead. (called from ...)  The message can be customized with the optional +message+ keyword argument.  For this to work, a +const_missing+ hook is installed. When client code references the deprecated constant, the callback prints the message and constantizes the replacement.  Caveat: If the deprecated constant name is reachable in a different namespace and Ruby constant lookup finds it, the hook won't be called and the deprecation won't work as intended. This may happen, for example, if an ancestor of the enclosing namespace has a constant with the same name. This is an unsupported edge case.",
        "label": "What",
        "id": "14428"
    },
    {
        "raw_code": "def add_predicate_return_tag(obj)\n        if obj.tag(:return) && (obj.tag(:return).types || []).empty?\n          obj.tag(:return).types = ['Boolean']\n        elsif obj.tag(:return).nil?\n          unless obj.tags(:overload).any? {|overload| overload.tag(:return) }\n            obj.add_tag(YARD::Tags::Tag.new(:return, \"\", \"Boolean\"))\n          end",
        "comment": "@param [MethodObject] obj",
        "label": "What",
        "id": "223"
    },
    {
        "raw_code": "def build_year_options(selected, options = {})\n          start = options.delete(:start)\n          stop = options.delete(:end)\n          step = options.delete(:step)\n\n          select_options = []\n          start.step(stop, step) do |value|\n            tag_options = { value: value }\n            tag_options[:selected] = \"selected\" if selected == value\n            text = year_name(value)\n            select_options << content_tag(\"option\", text, tag_options)\n          end",
        "comment": "Build select option HTML for year.  build_year_options(1998, start: 1998, end: 2000) => \"<option value=\"1998\" selected=\"selected\">1998</option> <option value=\"1999\">1999</option> <option value=\"2000\">2000</option>\"",
        "label": "What",
        "id": "11849"
    },
    {
        "raw_code": "def has_custom_head_branch?\n      project.repository.branch_names.any? { |name| name.casecmp('head') == 0 }\n    end",
        "comment": "See issue: https://gitlab.com/gitlab-org/gitlab/-/issues/381731",
        "label": "What",
        "id": "5933"
    },
    {
        "raw_code": "def attributes(attributes)\n          tag_options(attributes.to_h).to_s.strip.html_safe\n        end",
        "comment": "Transforms a Hash into HTML Attributes, ready to be interpolated into ERB.  <input <%= tag.attributes(type: :text, aria: { label: \"Search\" }) %> > # => <input type=\"text\" aria-label=\"Search\">",
        "label": "What",
        "id": "11969"
    },
    {
        "raw_code": "def duplicable?\n      false\n    end",
        "comment": "Unbound methods are not duplicable:  method(:puts).unbind.duplicable? # => false method(:puts).unbind.dup         # => TypeError: allocator undefined for UnboundMethod",
        "label": "What",
        "id": "14315"
    },
    {
        "raw_code": "def systemd_network_manager?(comm)\n          comm.test(\"systemctl -q is-active NetworkManager.service\", sudo: true)\n        end",
        "comment": "NetworkManager.service is in use  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @return [Boolean]",
        "label": "What",
        "id": "9259"
    },
    {
        "raw_code": "def list_projects_with_http_info(group_id, opts = {})\n      if @api_client.config.debugging\n        @api_client.config.logger.debug 'Calling API: ErrorsV2Api.list_projects ...'\n      end",
        "comment": "List of projects @param group_id [Integer] ID of the group @param [Hash] opts the optional parameters @return [Array<(Array<Project>, Integer, Hash)>] Array<Project> data, response status code and response headers",
        "label": "What",
        "id": "1023"
    },
    {
        "raw_code": "def create_release(repo, tag_name, options = {})\n        opts = options.merge(tag_name: tag_name)\n        post \"#{Repository.path repo}/releases\", opts\n      end",
        "comment": "Create a release  @param repo [Integer, String, Repository, Hash] A GitHub repository @param tag_name [String] Git tag from which to create release @option options [String] :target_commitish Specifies the commitish value that determines where the Git tag is created from. @option options [String] :name Name for the release @option options [String] :body Content for release notes @option options [Boolean] :draft Mark this release as a draft @option options [Boolean] :prerelease Mark this release as a pre-release @return [Sawyer::Resource] The release @see https://developer.github.com/v3/repos/releases/#create-a-release",
        "label": "What",
        "id": "15203"
    },
    {
        "raw_code": "def foo() end\n    RUBY\n  end",
        "comment": "encoding: us-ascii",
        "label": "What",
        "id": "10907"
    },
    {
        "raw_code": "def destroy_mr_diff_relations!\n      delete_batch_size = 1000\n\n      project.merge_requests.each_batch(column: :iid, of: BATCH_SIZE) do |relation_ids|\n        [MergeRequestDiffCommit, MergeRequestDiffFile].each do |model|\n          loop do\n            inner_query = model\n              .select(:merge_request_diff_id, :relative_order)\n              .where(merge_request_diff_id: MergeRequestDiff.where(merge_request_id: relation_ids).select(:id))\n              .limit(delete_batch_size)\n\n            deleted_rows = model\n              .where(\"(#{model.table_name}.merge_request_diff_id, #{model.table_name}.relative_order) IN (?)\", inner_query) # rubocop:disable GitlabSecurity/SqlInjection\n              .delete_all\n\n            break if deleted_rows == 0\n          end",
        "comment": "Projects will have at least one merge_request_diff_commit for every commit contained in every MR, which deleting via `project.destroy!` and cascading deletes may exceed statement timeouts, causing failures. (see https://gitlab.com/gitlab-org/gitlab/-/issues/346166)  Removing merge_request_diff_files records may also cause timeouts, so they can be deleted in batches as well.  rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5913"
    },
    {
        "raw_code": "def parser\n      return @parser if defined?(@parser)\n\n      @parser = if @lockfile_path && File.exist?(@lockfile_path) && use_bundler_lock_parser?\n                  begin\n                    lockfile = ::Bundler.read_file(@lockfile_path)\n                    ::Bundler::LockfileParser.new(lockfile) if lockfile\n                  rescue ::Bundler::BundlerError\n                    nil\n                  end",
        "comment": "@return [Bundler::LockfileParser, nil]",
        "label": "What",
        "id": "10094"
    },
    {
        "raw_code": "def logged_in?\n        return false if !client&.access_token\n\n        Vagrant::Util::CredentialScrubber.sensitive(client.access_token)\n\n        with_error_handling do\n          client.authentication_token_validate\n          true\n        end",
        "comment": "Checks if the user is logged in by verifying their authentication token.  @return [Boolean]",
        "label": "What",
        "id": "9776"
    },
    {
        "raw_code": "def active?\n        @lock.synchronize do\n          return false unless @raw_connection\n          @raw_connection.query \";\"\n          verified!\n        end",
        "comment": "Is this connection alive and ready for queries?",
        "label": "What",
        "id": "12966"
    },
    {
        "raw_code": "def create_org_project(org, name, options = {})\n        options[:name] = name\n        post \"orgs/#{org}/projects\", options\n      end",
        "comment": "Create organization project  Requires authenticated client  @param org [String] A GitHub organization @param name [String] Project name @option options [String] :body Project body @return [Sawyer::Resource] Organization project @see https://developer.github.com/v3/projects/#create-an-organization-project @example Create with only a name @client.create_org_project(\"octocat\", \"make more octocats\") @example Create a project with name and body @client.create_org_project(\"octokit\", \"octocan\", body: 'Improve clients')",
        "label": "What",
        "id": "15316"
    },
    {
        "raw_code": "def missing?(obj)\n        obj.to_s.strip.empty?\n      end",
        "comment": "Determine if the given string is \"missing\" (blank) @return [true, false]",
        "label": "What",
        "id": "9392"
    },
    {
        "raw_code": "def class_eval(*args, &block)\n    singleton_class.class_eval(*args, &block)\n  end",
        "comment": "class_eval on an object acts like +singleton_class.class_eval+.",
        "label": "What",
        "id": "14258"
    },
    {
        "raw_code": "def average(column_name)\n      calculate(:average, column_name)\n    end",
        "comment": "Calculates the average value on a given column. Returns +nil+ if there's no row. See #calculate for examples with options.  Person.average(:age) # => 35.8",
        "label": "What",
        "id": "13347"
    },
    {
        "raw_code": "def _BlankLine\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _Sp()\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "BlankLine = @Sp @Newline { \"\\n\" }",
        "label": "What",
        "id": "15792"
    },
    {
        "raw_code": "def load_schema\n        return if schema_loaded?\n        @load_schema_monitor.synchronize do\n          return if schema_loaded?\n\n          load_schema!\n\n          @schema_loaded = true\n        rescue\n          reload_schema_from_cache # If the schema loading failed half way through, we must reset the state.\n          raise\n        end",
        "comment": "Load the model's schema information either from the schema cache or directly from the database.",
        "label": "What",
        "id": "12527"
    },
    {
        "raw_code": "def diverging_commit_count(from, to, max_count: 0)\n        wrapped_gitaly_errors do\n          gitaly_commit_client.diverging_commit_count(from, to, max_count: max_count)\n        end",
        "comment": "Return total diverging commits count",
        "label": "What",
        "id": "2643"
    },
    {
        "raw_code": "def generate_discussion_id\n          Digest::SHA1.hexdigest(\n            [:discussion, noteable_type.try(:underscore), noteable_id || commit_id, SecureRandom.hex].join('-')\n          )\n        end",
        "comment": "Based on https://gitlab.com/gitlab-org/gitlab/blob/117c14d0c79403e169cf52922b48f69d1dcf6a85/app/models/discussion.rb#L62-74",
        "label": "What",
        "id": "3275"
    },
    {
        "raw_code": "def check_body_lines(lines)\n          lines.each do |line|\n            case line.type\n            when :or_asgn\n              check_disjunctive_assignment(line)\n            else\n              # Once we encounter something other than a disjunctive\n              # assignment, we cease our investigation, because we can't be\n              # certain that any future disjunctive assignments are offensive.\n              # You're off the case, detective!\n              break\n            end",
        "comment": "@param [Array] lines the logical lines of the constructor",
        "label": "What",
        "id": "10634"
    },
    {
        "raw_code": "def up\n    # rubocop:disable Migration/PreventIndexCreation -- Legacy migration\n    add_concurrent_index :vulnerability_reads, COLUMNS, name: INDEX_NAME, where: WHERE_CLAUSE\n    # rubocop:enable Migration/PreventIndexCreation\n  end",
        "comment": "-- Legacy migration",
        "label": "What",
        "id": "4902"
    },
    {
        "raw_code": "def self.current=(rdoc)\n    @current = rdoc\n  end",
        "comment": " Sets the active RDoc::RDoc instance",
        "label": "What",
        "id": "16005"
    },
    {
        "raw_code": "def test_generate_message_too_long_with_default_message_plural\n    assert_equal \"is too long (maximum is 10 characters)\", @person.errors.generate_message(:title, :too_long, count: 10)\n  end",
        "comment": "validates_length_of: generate_message(attr, :too_long, message: custom_message, count: option_value.end)",
        "label": "What",
        "id": "12332"
    },
    {
        "raw_code": "def after_run(_)\n          ::Repositories::HousekeepingService.new(context.portable, :gc).execute\n        end",
        "comment": "The initial fetch can bring in lots of loose refs and objects. Running a `git gc` will make importing merge requests faster.",
        "label": "What",
        "id": "3615"
    },
    {
        "raw_code": "def api_get_path\n        \"/groups/#{CGI.escape(group.full_path)}/badges/#{id}\"\n      end",
        "comment": "API get path  @return [String]",
        "label": "What",
        "id": "4196"
    },
    {
        "raw_code": "def destroy\n    record&.destroy\n  end",
        "comment": "Destroys record and deletes file from service.",
        "label": "What",
        "id": "13641"
    },
    {
        "raw_code": "def non_qa_changes?\n          changed_files.none? { |file_path| file_path =~ QA_PATTERN }\n        end",
        "comment": "Are the changed files only outside the qa directory?  @return [Boolean] whether the changes files are outside of qa directory",
        "label": "What",
        "id": "4807"
    },
    {
        "raw_code": "def load_page(page_name)\n    file = page_file page_name\n\n    obj = marshal_load(file)\n    obj.store = self\n    obj\n  rescue Errno::ENOENT => e\n    error = MissingFileError.new(self, file, page_name)\n    error.set_backtrace e.backtrace\n    raise error\n  end",
        "comment": " Loads ri data for +page_name+",
        "label": "What",
        "id": "15877"
    },
    {
        "raw_code": "def print_cop_with_doc(cop) # rubocop:todo Metrics/AbcSize, Metrics/MethodLength\n    cop_config = config.for_cop(cop)\n    non_display_keys = %w[\n      Enabled\n      Description\n      StyleGuide\n      Reference References\n      Safe SafeAutoCorrect AutoCorrect\n      VersionAdded VersionChanged\n    ]\n    parameters = cop_config.reject { |k| non_display_keys.include? k }\n    description = 'No documentation'\n    example_objects = safety_objects = see_objects = []\n    cop_code(cop) do |code_object|\n      description = code_object.docstring unless code_object.docstring.blank?\n      example_objects = code_object.tags('example')\n      safety_objects = code_object.tags('safety')\n      see_objects = code_object.tags('see')\n    end",
        "comment": "rubocop:enable Metrics/MethodLength",
        "label": "What",
        "id": "10147"
    },
    {
        "raw_code": "def check_all_foreign_keys_valid!\n      end",
        "comment": "Override to check all foreign key constraints in a database. The adapter should raise a +ActiveRecord::StatementInvalid+ if foreign key constraints are not met.",
        "label": "What",
        "id": "12923"
    },
    {
        "raw_code": "def fields\n          @fields ||= []\n        end",
        "comment": ":nocov: rubocop:enable Gitlab/NoCodeCoverageComment",
        "label": "What",
        "id": "7457"
    },
    {
        "raw_code": "def select_up_to_date_host(location)\n          all_hosts = @host_list.hosts.shuffle\n          first_caught_up_host = nil\n\n          # We must loop through all of them so that we know if all are caught up. Some callers only care about finding\n          # one caught up host and storing it in request_cache. But Sticking needs to know if ALL_CAUGHT_UP so that it\n          # can clear the LSN position from Redis and not ask again in future.\n          results = all_hosts.map do |host|\n            caught_up = host.caught_up?(location)\n            first_caught_up_host ||= host if caught_up\n            caught_up\n          end",
        "comment": "Finds any up to date replica for the given LSN location and stores an up to date replica in the SafeRequestStore to be used later for read-only queries. It returns a symbol to indicate if :any, :all or :none were found to be caught up.",
        "label": "What",
        "id": "3097"
    },
    {
        "raw_code": "def _deserialize(type, value)\n      case type.to_sym\n      when :Time\n        Time.parse(value)\n      when :Date\n        Date.parse(value)\n      when :String\n        value.to_s\n      when :Integer\n        value.to_i\n      when :Float\n        value.to_f\n      when :Boolean\n        if value.to_s =~ /\\A(true|t|yes|y|1)\\z/i\n          true\n        else\n          false\n        end",
        "comment": "Deserializes the data based on type @param string type Data type @param string value Value to be deserialized @return [Object] Deserialized data",
        "label": "What",
        "id": "891"
    },
    {
        "raw_code": "def root_ancestor\n      return self unless child?\n\n      object_hierarchy(project_condition: :same)\n        .base_and_ancestors(hierarchy_order: :desc)\n        .first\n    end",
        "comment": "Follow the parent-child relationships and return the top-level parent",
        "label": "What",
        "id": "7575"
    },
    {
        "raw_code": "def normalized_join_header(header)\n    header.is_a?(Array) ? header.join(\",\") : header\n  end",
        "comment": "This works for most headers, but not all, e.g. `set-cookie`.",
        "label": "What",
        "id": "11652"
    },
    {
        "raw_code": "def yield_valid_link(node)\n          link = unescape_link(node.attr('href').to_s)\n          inner_html = node.inner_html\n\n          return unless link.force_encoding('UTF-8').valid_encoding?\n\n          yield link, inner_html\n        end",
        "comment": "Yields the link's URL and inner HTML whenever the node is a valid <a> tag.",
        "label": "What",
        "id": "3494"
    },
    {
        "raw_code": "def extract_service_logs\n          copy(from: \"#{@name}:/var/log/gitlab\", to: Runtime::Path.qa_tmp(@name))\n        end",
        "comment": "Copy logs for GitLab services from the Docker container to the test framework's tmp folder",
        "label": "What",
        "id": "4244"
    },
    {
        "raw_code": "def initialize(scope, user)\n        @scope = scope\n        @user = user\n      end",
        "comment": "@param [ApplicationSetting, Project, Group] scope: the scope of the reset operation @param [User] user: the user performing the operation",
        "label": "What",
        "id": "5840"
    },
    {
        "raw_code": "def add_assignees(repo, number, assignees, options = {})\n        post \"#{Repository.path repo}/issues/#{number}/assignees\", options.merge({ assignees: assignees })\n      end",
        "comment": "Add assignees to an issue  @param repo [Integer, String, Repository, Hash] A GitHub repository @param number [Integer] Issue number @param assignees [Array<String>] Assignees to be added @return [Sawyer::Resource] Issue @see https://developer.github.com/v3/issues/assignees/#add-assignees-to-an-issue @example Add assignees \"pengwynn\" and \"joeyw\" to Issue #23 on octokit/octokit.rb Octokit.add_assignees(\"octokit/octokit.rb\", 23, [\"pengwynn\", \"joeyw\"])",
        "label": "What",
        "id": "15260"
    },
    {
        "raw_code": "def translate_location(spot, _backtrace_location, source)\n          compiled = spot[:script_lines]\n          highlight = compiled[spot[:first_lineno] - 1]&.byteslice((spot[:first_column] - 1)...spot[:last_column])\n          return nil if highlight.blank?\n\n          source_lines = source.lines\n          lineno_delta = find_lineno_offset(compiled, source_lines, highlight, spot[:first_lineno])\n\n          tokens = ::ERB::Util.tokenize(source_lines[spot[:first_lineno] - lineno_delta - 1])\n          column_delta = find_offset(spot[:snippet], tokens, spot[:first_column])\n\n          spot[:first_lineno] -= lineno_delta\n          spot[:last_lineno] -= lineno_delta\n          spot[:first_column] -= column_delta\n          spot[:last_column] -= column_delta\n          spot[:script_lines] = source_lines\n\n          spot\n        rescue NotImplementedError, LocationParsingError\n          nil\n        end",
        "comment": "Translate an error location returned by ErrorHighlight to the correct source location inside the template.",
        "label": "What",
        "id": "12023"
    },
    {
        "raw_code": "def parse markdown\n    @references          = {}\n    @unlinked_references = {}\n\n    markdown += \"\\n\\n\"\n\n    setup_parser markdown, @debug\n    peg_parse 'References'\n\n    if notes? then\n      @footnotes       = {}\n\n      setup_parser markdown, @debug\n      peg_parse 'Notes'\n\n      # using note_order on the first pass would be a bug\n      @note_order      = []\n    end",
        "comment": " Parses `markdown` into an RDoc::Document",
        "label": "What",
        "id": "15584"
    },
    {
        "raw_code": "def to_param\n    { from: sha_start, to: sha_to }\n  end",
        "comment": "Return a Hash of parameters for passing to a URL helper  See `namespace_project_compare_url`",
        "label": "What",
        "id": "6715"
    },
    {
        "raw_code": "def load_sidebar\n    @sidebar_page = wiki.find_sidebar(params[:version_id])\n    @wiki_pages_count = pages_list.total_count\n  end",
        "comment": "rubocop:disable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "6572"
    },
    {
        "raw_code": "def self.to_label\n    @to_label ||= RDoc::Markup::ToLabel.new\n  end",
        "comment": " A singleton RDoc::Markup::ToLabel formatter for headings.",
        "label": "What",
        "id": "16263"
    },
    {
        "raw_code": "def render(context, options)\n      render_to_object(context, options).body\n    end",
        "comment": "Main render entry point shared by Action View and Action Controller.",
        "label": "What",
        "id": "12005"
    },
    {
        "raw_code": "def entry_create!(key, value)\n          factory = self.class\n            .nodes[key]\n            .value(value)\n            .with(key: key, parent: self)\n\n          entries[key] = factory.create!\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "1921"
    },
    {
        "raw_code": "def verification_domain\n    return unless domain.present?\n\n    \"_#{VERIFICATION_KEY}.#{domain}\"\n  end",
        "comment": "Verification codes may be TXT records for domain or verification_domain, to support the use of CNAME records on domain.",
        "label": "What",
        "id": "6947"
    },
    {
        "raw_code": "def next_migration_number(number)\n      if ActiveRecord.timestamped_migrations\n        [Time.now.utc.strftime(\"%Y%m%d%H%M%S\"), \"%.14d\" % number].max\n      else\n        \"%.3d\" % number.to_i\n      end",
        "comment": "Determines the version number of the next migration.",
        "label": "What",
        "id": "12499"
    },
    {
        "raw_code": "def record_identifier(record)\n          { label_id: record.id, label_name: record.title }\n        end",
        "comment": "We assume that most classes are identifying records by ID.  This method has the contract that if a string `ref` refers to a record `record`, then `class.parse_symbol(ref) == record_identifier(record)`. See note in `parse_symbol` above",
        "label": "What",
        "id": "3499"
    },
    {
        "raw_code": "def pipeline_for_ref_subquery(items)\n      where_query = Arel.sql(\"#{Ci::Pipeline.table_name}.ref = refs.ref\")\n\n      items\n        .where(where_query)\n        .order(id: :desc)\n        .limit(1) # Limit to 1 because we only want the latest pipeline per ref\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "8004"
    },
    {
        "raw_code": "def generate_otp_backup_codes_pbkdf2!\n        codes           = []\n        number_of_codes = self.class.otp_number_of_backup_codes\n        code_length     = self.class.otp_backup_code_length\n\n        number_of_codes.times do\n          codes << SecureRandom.hex(code_length / 2) # Hexstring has length 2*n\n        end",
        "comment": "1) Invalidates all existing backup codes 2) Generates otp_number_of_backup_codes backup codes 3) Stores the hashed backup codes in the database 4) Returns a plaintext array of the generated backup codes ",
        "label": "What",
        "id": "5244"
    },
    {
        "raw_code": "def discard_on(*exceptions, report: false)\n        rescue_from(*exceptions) do |error|\n          instrument :discard, error: error do\n            ActiveSupport.error_reporter.report(error, source: \"application.active_job\") if report\n            yield self, error if block_given?\n            run_after_discard_procs(error)\n          end",
        "comment": "Discard the job with no attempts to retry, if the exception is raised. This is useful when the subject of the job, like an Active Record, is no longer available, and the job is thus no longer relevant.  Passing the <tt>:report</tt> option reports the error through the error reporter before discarding the job.  You can also pass a block that'll be invoked. This block is yielded with the job instance as the first and the error instance as the second parameter.  +retry_on+ and +discard_on+ handlers are searched from bottom to top, and up the class hierarchy. The handler of the first class for which <tt>exception.is_a?(klass)</tt> holds true is the one invoked, if any.  ==== Example  class SearchIndexingJob < ActiveJob::Base discard_on ActiveJob::DeserializationError discard_on CustomAppException, report: true discard_on(AnotherCustomAppException) do |job, error| CustomErrorHandlingCode.handle(job, error) end  def perform(record) # Will raise ActiveJob::DeserializationError if the record can't be deserialized # Might raise CustomAppException for something domain specific end end",
        "label": "What",
        "id": "12122"
    },
    {
        "raw_code": "def delete_artifact(repo, id, options = {})\n        boolean_from_response :delete, \"#{Repository.path repo}/actions/artifacts/#{id}\", options\n      end",
        "comment": "Delete an artifact  @param repo [Integer, String, Repository, Hash] A GitHub repository @param id [Integer] Id of an artifact  @return [Boolean] Return true if the artifact was successfully deleted @see https://docs.github.com/en/rest/actions/artifacts#delete-an-artifact",
        "label": "What",
        "id": "14984"
    },
    {
        "raw_code": "def close_medium(disk_uuid)\n          execute(\"closemedium\", disk_uuid, '--delete')\n        end",
        "comment": "Removes a disk from the given virtual machine  @param [String] disk_uuid or file path @param [Hash]   opts -  additional options",
        "label": "What",
        "id": "9608"
    },
    {
        "raw_code": "def accept_raw(raw)\n    @res << raw.parts.join(\"\\n\")\n  end",
        "comment": " Adds +raw+ to the output",
        "label": "What",
        "id": "16203"
    },
    {
        "raw_code": "def each_associated(_parent_record, associated)\n        associated = associated.to_h\n\n        return if already_imported?(associated)\n\n        Gitlab::GithubImport::ObjectCounter.increment(project, object_type, :fetched)\n\n        yield(associated)\n\n        mark_as_imported(associated)\n      end",
        "comment": "Sometimes we need to add some extra info from parent to associated record that is not available by default in Github API response object. For example: lib/gitlab/github_import/importer/single_endpoint_issue_events_importer.rb:26",
        "label": "What",
        "id": "2176"
    },
    {
        "raw_code": "def self.baz\n          end",
        "comment": "== visibility from reopening class.",
        "label": "What",
        "id": "769"
    },
    {
        "raw_code": "def all_projects\n    namespace = user_namespace? ? self : self_and_descendant_ids\n    Project.where(namespace: namespace)\n  end",
        "comment": "Includes projects from this namespace and projects from all subgroups that belongs to this namespace",
        "label": "What",
        "id": "6689"
    },
    {
        "raw_code": "def validate_api_client!(client, check_admin: true)\n            debug(\"Validating api client\")\n            resp = fetch_user_details(client)\n\n            if resp.code == 403 && resp.body.include?(\"Your password expired\")\n              raise ExpiredPasswordError, \"Password for client's user has expired and must be reset\"\n            elsif !status_ok?(resp)\n              raise InvalidTokenError, \"API client validation failed! Code: #{resp.code}, Err: '#{resp.body}'\"\n            end",
        "comment": "Validate if client belongs to an admin user  @param [QA::Runtime::API::Client] client @return [void]",
        "label": "What",
        "id": "4516"
    },
    {
        "raw_code": "def clear_data_source_cache!(_connection, name)\n        @columns.delete name\n        @columns_hash.delete name\n        @primary_keys.delete name\n        @data_sources.delete name\n        @indexes.delete name\n      end",
        "comment": "Clear out internal caches for the data source +name+.",
        "label": "What",
        "id": "12990"
    },
    {
        "raw_code": "def remove_index(column_name = nil, **options)\n        raise_on_if_exist_options(options)\n        @base.remove_index(name, column_name, **options)\n      end",
        "comment": "Removes the given index from the table.  t.remove_index(:branch_id) t.remove_index(column: [:branch_id, :party_id]) t.remove_index(name: :by_branch_party) t.remove_index(:branch_id, name: :by_branch_party)  See {connection.remove_index}[rdoc-ref:SchemaStatements#remove_index]",
        "label": "What",
        "id": "13114"
    },
    {
        "raw_code": "def skip_forgery_protection(options = {})\n        skip_before_action :verify_authenticity_token, options.reverse_merge(raise: false)\n      end",
        "comment": "Turn off request forgery protection. This is a wrapper for:  skip_before_action :verify_authenticity_token  See `skip_before_action` for allowed options.",
        "label": "What",
        "id": "11331"
    },
    {
        "raw_code": "def scan\n    reset\n\n    catch :eof do\n      begin\n        parse_top_level_statements @top_level\n\n      rescue StandardError => e\n        if @content.include?('<%') and @content.include?('%>') then\n          # Maybe, this is ERB.\n          $stderr.puts \"\\033[2KRDoc detects ERB file. Skips it for compatibility:\"\n          $stderr.puts @file_name\n          return\n        end",
        "comment": " Scans this Ruby file for Ruby constructs",
        "label": "What",
        "id": "16124"
    },
    {
        "raw_code": "def status(name, namespace:)\n          run_helm(%W[status #{name} --namespace #{namespace}])\n        rescue Error => e\n          e.message.include?(\"release: not found\") ? nil : raise(e)\n        end",
        "comment": "Display status of helm release  @param [String] name @param [String] namespace @return [<String, nil>] status of helm release or nil if release is not found",
        "label": "What",
        "id": "3958"
    },
    {
        "raw_code": "def run_pre_deployment_setup\n            return if self.class.skip_pre_deployment_setup\n\n            raise(NoMethodError, \"run_pre_deployment_setup not implemented\")\n          end",
        "comment": "Steps to be executed before performing helm deployment  @return [void]",
        "label": "What",
        "id": "4031"
    },
    {
        "raw_code": "def add_api_verifier\n        no_api = true if apis.delete('')\n        exprs = []\n\n        exprs << \"#{apis.uniq.inspect}.include?(@api.text)\" unless apis.empty?\n\n        unless hidden_apis.empty?\n          exprs << \"!#{hidden_apis.uniq.inspect}.include?(@api.text)\"\n        end",
        "comment": "Adds verifier rule for APIs @return [void] @since 0.8.1",
        "label": "What",
        "id": "538"
    },
    {
        "raw_code": "def host_vm_lock\n        hash = Digest::MD5.hexdigest(host_vm.data_dir.to_s)\n\n        # We do a process-level mutex on the outside, since we can\n        # wait for that a short amount of time. Then, we do a process lock\n        # on the inside, which will raise an exception if locked.\n        host_vm_mutex.synchronize do\n          @machine.env.lock(hash) do\n            return yield\n          end",
        "comment": "This acquires a lock on the host VM.",
        "label": "What",
        "id": "9468"
    },
    {
        "raw_code": "def extensions(stream)\n      end",
        "comment": "extensions are only supported by PostgreSQL",
        "label": "What",
        "id": "12684"
    },
    {
        "raw_code": "def magic_comment_in_scope(node)\n            processed_source_till_node(node).reverse_each.find do |line|\n              MagicComment.parse(line).valid_shareable_constant_value?\n            end",
        "comment": "Identifies the most recent magic comment with valid shareable constant values that's in scope for this node",
        "label": "What",
        "id": "10500"
    },
    {
        "raw_code": "def totals_by_status(pipelines_by_interval)\n          return {} unless @totals.slice(*SELECTABLE_STATUSES).any?\n\n          analytics_status_grouping = COMPLETED_STATUSES.index_with { |status| status }\n\n          counts_by_status = pipelines_by_interval\n            .group(:status) # rubocop: disable CodeReuse/ActiveRecord -- this grouping is very specific to this chart\n            .count(:created_at)\n\n          # Convert hash layout from [2024-05-14 00:00:00 UTC, \"failed\"]=>1 to {:failed=>{\"14 May\"=>1}\n          counts_by_status\n            .group_by { |(_date, status),| analytics_status_grouping.fetch(status.to_sym, :other) }\n            .transform_values do |values|\n              values.to_h.transform_keys { |date,| date.strftime(@format) }\n            end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2451"
    },
    {
        "raw_code": "def skip?\n      raise NotImplementedError\n    end",
        "comment": "When implemented by a subclass, will evaluate whether check should be skipped or not  @return [Boolean] whether or not this check should be skipped",
        "label": "What",
        "id": "3721"
    },
    {
        "raw_code": "def calculate_size\n          trace_chunks.order(chunk_index: :desc).first.try(&:end_offset).to_i\n        end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2530"
    },
    {
        "raw_code": "def emails(options = {})\n        paginate 'user/emails', options\n      end",
        "comment": "List email addresses for a user.  Requires authenticated client.  @return [Array<String>] Array of email addresses. @see https://developer.github.com/v3/users/emails/#list-email-addresses-for-a-user @example @client.emails",
        "label": "What",
        "id": "15484"
    },
    {
        "raw_code": "def load_events\n    projects = Project.where(id: @project.id)\n\n    @events = EventCollection\n      .new(projects, offset: params[:offset].to_i, filter: event_filter)\n      .to_a\n      .map(&:present)\n  end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6437"
    },
    {
        "raw_code": "def ignore_runtime_data?\n        enabled?(ENV[\"QA_IGNORE_RUNTIME_DATA\"], default: false)\n      end",
        "comment": "Ignore runtime data when generating knapsack reports  @return [Boolean]",
        "label": "What",
        "id": "4477"
    },
    {
        "raw_code": "def locate_descendant(node, field, filter: DEFAULT_FIELD_FILTER)\n              descendants(node, filter: filter).find { |_, child_field| child_field == field }&.first\n            end",
        "comment": "Return the first node that matches the field.",
        "label": "What",
        "id": "3196"
    },
    {
        "raw_code": "def project_group_links_with_preload\n    project_group_links\n  end",
        "comment": "overridden in EE",
        "label": "What",
        "id": "6778"
    },
    {
        "raw_code": "def locate_descendants(node, field, filter: DEFAULT_FIELD_FILTER)\n              descendants(node, filter: filter).select { |_, child_field| child_field == field }.map(&:first)\n            end",
        "comment": "Return all nodes that match the field.",
        "label": "What",
        "id": "3197"
    },
    {
        "raw_code": "def discussions_to_resolve\n      return [] unless merge_request_to_resolve_discussions_of\n\n      @discussions_to_resolve ||= # rubocop:disable Gitlab/ModuleWithInstanceVariables\n        if discussion_to_resolve_id\n          discussion_or_nil = merge_request_to_resolve_discussions_of\n                                .find_discussion(discussion_to_resolve_id)\n          Array(discussion_or_nil)\n        else\n          merge_request_to_resolve_discussions_of\n            .discussions_to_be_resolved\n        end.reject(&:confidential?)\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5717"
    },
    {
        "raw_code": "def upload_to_gcs(bucket, file_path, file_name)\n        retry_on_exception(sleep_interval: 30) do\n          file = gcs_client.put_object(bucket, file_name, File.new(file_path, \"r\"), force: true)\n          QA::Runtime::Logger.info(\"Uploaded file #{file_path} to #{gcs_url(bucket, file)}\")\n        end",
        "comment": "Upload file to GCS  @param [String] bucket to be uploaded to @param [String] file_path of file to be uploaded @param [String] file_name of file to be uploaded @return [void]",
        "label": "What",
        "id": "4660"
    },
    {
        "raw_code": "def git_upload_pack\n      update_fetch_statistics\n\n      render_ok\n    end",
        "comment": "POST /foo/bar.git/git-upload-pack (git pull)",
        "label": "What",
        "id": "6659"
    },
    {
        "raw_code": "def find(*args)\n        return super if block_given?\n        @association.find(*args)\n      end",
        "comment": " :method: select  :call-seq: select(*fields, &block)  Works in two ways.  *First:* Specify a subset of fields to be selected from the result set.  class Person < ActiveRecord::Base has_many :pets end  person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.select(:name) # => [ #      #<Pet id: nil, name: \"Fancy-Fancy\">, #      #<Pet id: nil, name: \"Spook\">, #      #<Pet id: nil, name: \"Choo-Choo\"> #    ]  person.pets.select(:id, :name) # => [ #      #<Pet id: 1, name: \"Fancy-Fancy\">, #      #<Pet id: 2, name: \"Spook\">, #      #<Pet id: 3, name: \"Choo-Choo\"> #    ]  Be careful because this also means you're initializing a model object with only the fields that you've selected. If you attempt to access a field except +id+ that is not in the initialized record you'll receive:  person.pets.select(:name).first.person_id # => ActiveModel::MissingAttributeError: missing attribute 'person_id' for Pet  *Second:* You can pass a block so it can be used just like <tt>Array#select</tt>. This builds an array of objects from the database for the scope, converting them into an array and iterating through them using <tt>Array#select</tt>.  person.pets.select { |pet| /oo/.match?(pet.name) } # => [ #      #<Pet id: 2, name: \"Spook\", person_id: 1>, #      #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ] Finds an object in the collection responding to the +id+. Uses the same rules as ActiveRecord::FinderMethods.find. Raises ActiveRecord::RecordNotFound error if the object cannot be found.  class Person < ActiveRecord::Base has_many :pets end  person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.find(1) # => #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1> person.pets.find(4) # => ActiveRecord::RecordNotFound: Couldn't find Pet with 'id'=4  person.pets.find(2) { |pet| pet.name.downcase! } # => #<Pet id: 2, name: \"fancy-fancy\", person_id: 1>  person.pets.find(2, 3) # => [ #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]",
        "label": "What",
        "id": "12783"
    },
    {
        "raw_code": "def transfer(project)\n      @old_path = project.full_path\n      @old_group = project.group\n      @new_path = File.join(@new_namespace.try(:full_path) || '', project.path)\n      @old_namespace = project.namespace\n\n      if Project.where(namespace_id: @new_namespace.try(:id)).where('path = ? or name = ?', project.path, project.name).exists?\n        raise TransferError, s_(\"TransferProject|Project with same name or path in target namespace already exists\")\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5894"
    },
    {
        "raw_code": "def add_html(tag, name)\n    @attribute_manager.add_html(tag, name)\n  end",
        "comment": " Add to the sequences recognized as general markup.",
        "label": "What",
        "id": "15952"
    },
    {
        "raw_code": "def perform_in(interval, *args)\n        int = interval.to_f\n        now = Time.now.to_f\n        ts = ((int < 1_000_000_000) ? now + int : int)\n\n        item = {\"class\" => self, \"args\" => args}\n\n        # Optimization to enqueue something now that is scheduled to go out now or in the past\n        item[\"at\"] = ts if ts > now\n\n        client_push(item)\n      end",
        "comment": "+interval+ must be a timestamp, numeric or something that acts numeric (like an activesupport time interval).",
        "label": "What",
        "id": "5178"
    },
    {
        "raw_code": "def up\n    # rubocop:disable Migration/PreventIndexCreation -- Legacy migration\n    prepare_async_index :vulnerability_finding_links, :project_id, name: INDEX_NAME\n    # rubocop:enable Migration/PreventIndexCreation\n  end",
        "comment": "-- Legacy migration",
        "label": "What",
        "id": "4907"
    },
    {
        "raw_code": "def instance_attributes\n      attributes[:instance]\n    end",
        "comment": "Only the instance attributes @return [Hash] a list of method names and their read/write objects @see #attributes",
        "label": "What",
        "id": "620"
    },
    {
        "raw_code": "def breaks_macos_users\n    %w[dir dircolors vdir]\n  end",
        "comment": "https://github.com/Homebrew/homebrew-core/pull/36494",
        "label": "What",
        "id": "2"
    },
    {
        "raw_code": "def fetch_github_objects\n        logger.info(\"== Fetching github repo objects ==\")\n\n        gh_repo\n        gh_branches\n        gh_commits\n        gh_labels\n        gh_milestones\n        gh_issues\n        gh_prs\n      end",
        "comment": "Persist all objects from repository being imported  @return [void]",
        "label": "What",
        "id": "4396"
    },
    {
        "raw_code": "def up\n    return unless index_name\n\n    prepare_async_index_removal TABLE_NAME, COLUMNS, name: index_name\n  end",
        "comment": "TODO: Index to be destroyed synchronously in https://gitlab.com/gitlab-org/gitlab/-/issues/532779",
        "label": "What",
        "id": "4968"
    },
    {
        "raw_code": "def histogram(relation, column, buckets:, bucket_size: buckets.size)\n            count_grouped = relation.group(column).select(Arel.star.count.as('count_grouped'))\n            cte = Gitlab::SQL::CTE.new(:count_cte, count_grouped)\n\n            bucket_segments = bucket_size - 1\n            width_bucket = Arel::Nodes::NamedFunction\n              .new('WIDTH_BUCKET', [cte.table[:count_grouped], buckets.first, buckets.last, bucket_segments])\n              .as('buckets')\n\n            query = cte\n              .table\n              .project(width_bucket, cte.table[:count])\n              .group('buckets')\n              .order('buckets')\n              .with(cte.to_arel)\n\n            query.to_sql\n          end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "1981"
    },
    {
        "raw_code": "def distutils\n    libexec/\"lib-python/2.7/distutils\"\n  end",
        "comment": "The Cellar location of distutils",
        "label": "What",
        "id": "30"
    },
    {
        "raw_code": "def to_param\n    {\n      from: @straight ? start_commit_sha : (base_commit_sha || start_commit_sha),\n      to: head_commit_sha\n    }\n  end",
        "comment": "Return a Hash of parameters for passing to a URL helper  See `namespace_project_compare_url`",
        "label": "What",
        "id": "7008"
    },
    {
        "raw_code": "def ssh_upload_pack\n      render plain: \"Not found\", status: :not_found\n    end",
        "comment": "POST /foo/bar.git/ssh-upload-pack\" (git pull via SSH)",
        "label": "What",
        "id": "6661"
    },
    {
        "raw_code": "def apply_relative_link_rules!\n          if @uri.relative? && @uri.path.present?\n            link = @uri.path\n            link = ::File.join(@wiki_base_path, link) unless prefixed_with_base_path?(link)\n            link = \"#{link}##{@uri.fragment}\" if @uri.fragment\n            @uri = Addressable::URI.parse(link)\n          end",
        "comment": "Any link _not_ of the form `http://example.com/`",
        "label": "What",
        "id": "3477"
    },
    {
        "raw_code": "def caveats\n    <<~EOS\n      Ogmtools has not been updated since 2004 and is no longer being developed,\n      maintained or supported. There are several issues, especially on 64-bit\n      architectures, which the author will not fix or accept patches for.\n      Keep this in mind when deciding whether to use this software.\n    EOS\n  end",
        "comment": "Borrow warning from MacPorts",
        "label": "What",
        "id": "19"
    },
    {
        "raw_code": "def find_instance_method_named(name)\n    @method_list.find { |meth| !meth.singleton && meth.name == name }\n  end",
        "comment": " Finds an instance method with +name+ in this context",
        "label": "What",
        "id": "16669"
    },
    {
        "raw_code": "def to_s\n        inspect\n      end",
        "comment": "@return [String]",
        "label": "What",
        "id": "2395"
    },
    {
        "raw_code": "def build_can_push?(requested_project)\n      # Build can push only to the project from which it originates\n      has_authentication_ability?(:build_create_container_image) &&\n        requested_project == project\n    end",
        "comment": " We still support legacy pipeline triggers which do not have associated actor. New permissions model and new triggers are always associated with an actor. So this should be improved once https://gitlab.com/gitlab-org/gitlab-foss/issues/37452 is resolved. ",
        "label": "What",
        "id": "5702"
    },
    {
        "raw_code": "def association_key_name\n          reflection.join_primary_key(klass)\n        end",
        "comment": "The name of the key on the associated records",
        "label": "What",
        "id": "12824"
    },
    {
        "raw_code": "def starred\n    @projects = load_projects.reorder('star_count DESC')\n\n    respond_to do |format|\n      format.html\n      format.json do\n        render json: {\n          html: view_to_html_string(\"explore/projects/_projects\", projects: @projects)\n        }\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6486"
    },
    {
        "raw_code": "def load_server(app = self)\n      run_server_blocks(app)\n      self\n    end",
        "comment": "Invoke the server registered hooks. Check Rails::Railtie.server for more info.",
        "label": "What",
        "id": "14661"
    },
    {
        "raw_code": "def prepare_notes_for_rendering(notes)\n    preload_noteable_for_regular_notes(notes)\n    preload_note_namespace(notes)\n    preload_max_access_for_authors(notes, @project)\n    preload_author_status(notes)\n    Notes::RenderService.new(current_user).execute(notes)\n\n    notes\n  end",
        "comment": "rubocop:disable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "6556"
    },
    {
        "raw_code": "def foo; end\n    eof\n    expect(trim(signature(Registry.at('#foo')))).to eq @results[:two_types]\n  end",
        "comment": "@return [String, Symbol]",
        "label": "What",
        "id": "802"
    },
    {
        "raw_code": "def ref?\n          false\n        end",
        "comment": "@return [Boolean] whether the node is a reference (variable, constant name)",
        "label": "What",
        "id": "312"
    },
    {
        "raw_code": "def build_description(feature_flag, latest_feature_flag_status)\n      ready_for_removal = has_ready_for_removal_label?(feature_flag)\n\n      introduction_text = if ready_for_removal\n                            \"This feature flag was introduced in #{feature_flag.milestone} and has been \" \\\n                              \"marked as ready for removal with the `~\\\"feature flag::ready for removal\\\"` \" \\\n                              \"label, bypassing the standard milestone cutoff requirements.\"\n                          else\n                            cutoff_count = if latest_feature_flag_status == :enabled\n                                             CUTOFF_MILESTONE_FOR_ENABLED_FLAG\n                                           else\n                                             CUTOFF_MILESTONE_FOR_DISABLED_FLAG\n                                           end",
        "comment": "rubocop:disable Gitlab/DocumentationLinks/HardcodedUrl -- Not running inside rails application",
        "label": "What",
        "id": "8079"
    },
    {
        "raw_code": "def after_change_head\n    expire_all_method_caches\n    container.after_repository_change_head\n  end",
        "comment": "Runs code after the HEAD of a repository is changed.",
        "label": "What",
        "id": "7141"
    },
    {
        "raw_code": "def filter_jobs!\n            return unless @config.is_a?(Hash)\n\n            @jobs_config = @config\n              .except(*self.class.reserved_nodes_names)\n              .select do |name, config|\n              Entry::Jobs.find_type(name, config).present? || ALLOWED_KEYS.exclude?(name)\n            end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2481"
    },
    {
        "raw_code": "def symbolized_options\n            @symbolized_options ||= super.tap do |opts|\n              next unless opts[:gitlab_domain].nil?\n\n              opts.merge!({ gitlab_domain: \"localhost\" })\n            end",
        "comment": "Populate options with default gitlab domain if missing  @return [Hash]",
        "label": "What",
        "id": "4087"
    },
    {
        "raw_code": "def deinit\n      # no-op\n    end",
        "comment": "Removes any temporary files created by init",
        "label": "What",
        "id": "8898"
    },
    {
        "raw_code": "def rename_indexes_for_table(table_name, new_index_names, schema_name: connection.current_schema)\n          current_index_names = indexes_by_definition_for_table(table_name, schema_name: schema_name)\n          rename_indexes(current_index_names, new_index_names, schema_name: schema_name)\n        end",
        "comment": "Renames indexes for a given table and schema, mapping by index definition, to a hash of new index names.  Example:  index_names = indexes_by_definition_for_table('source_table_name_goes_here') drop_table('source_table_name_goes_here') rename_indexes_for_table('destination_table_name_goes_here', index_names)",
        "label": "What",
        "id": "3041"
    },
    {
        "raw_code": "def key?(key, h_key)\n      with { |redis| redis.hexists(cache_key(key), h_key) }\n    end",
        "comment": "Check if the provided hash key exists in the hash.  @param key [String] @param h_key [String] the key to check presence in Redis @return [True, False]",
        "label": "What",
        "id": "1532"
    },
    {
        "raw_code": "def instance_attributes\n    @instance_attributes ||= attributes.reject { |a| a.singleton }\n  end",
        "comment": " Instance attributes",
        "label": "What",
        "id": "16679"
    },
    {
        "raw_code": "def files\n        logger.info(\"Gathering JSON files using pattern #{@file_pattern}...\")\n        files = Dir.glob(@file_pattern)\n\n        if files.empty?\n          logger.info(\"There is no file with this pattern\")\n          exit 0\n        else\n          logger.info(\"Found #{files.size} JSON file(s) to process\")\n        end",
        "comment": "Gathers and validates JSON files matching the configured @file_pattern  @return [Array<String>] Array of file paths that match the pattern and contain data @raise [SystemExit] Exits with status 0 if no files match the pattern or all files are empty",
        "label": "What",
        "id": "4667"
    },
    {
        "raw_code": "def generate_hook_keys(key)\n          if key.is_a?(Class)\n            key = key.name.to_s\n          else\n            key = key.to_s\n          end",
        "comment": "Generate all valid lookup keys for given key  @param [Class, String] key Base key for generation @return [Array<String>] all valid keys",
        "label": "What",
        "id": "9065"
    },
    {
        "raw_code": "def add_email(email, _options = {})\n        email = Array(email)\n        post 'user/emails', email\n      end",
        "comment": "Add email address to user.  Requires authenticated client.  @param email [String] Email address to add to the user. @return [Array<String>] Array of all email addresses of the user. @see https://developer.github.com/v3/users/emails/#add-email-addresses @example @client.add_email('new_email@user.com')",
        "label": "What",
        "id": "15485"
    },
    {
        "raw_code": "def sanitize_css(style)\n        self.class.safe_list_sanitizer.sanitize_css(style)\n      end",
        "comment": "Sanitizes a block of CSS code. Used by #sanitize when it comes across a style attribute.",
        "label": "What",
        "id": "11963"
    },
    {
        "raw_code": "def downcase_first\n    ActiveSupport::Inflector.downcase_first(self)\n  end",
        "comment": "Converts the first character to lowercase.  'If they enjoyed The Matrix'.downcase_first # => \"if they enjoyed The Matrix\" 'I'.downcase_first                          # => \"i\" ''.downcase_first                           # => \"\"  See ActiveSupport::Inflector.downcase_first.",
        "label": "What",
        "id": "14377"
    },
    {
        "raw_code": "def reschedule(at)\n      Sidekiq.redis do |conn|\n        conn.zincrby(@parent.name, at.to_f - @score, Sidekiq.dump_json(@item))\n      end",
        "comment": "Change the scheduled time for this job.  @param at [Time] the new timestamp for this job",
        "label": "What",
        "id": "5126"
    },
    {
        "raw_code": "def find\n          BatchLoader::GraphQL.for([model_id.to_i, preloads]).batch(key: model_class) do |for_params, loader, args|\n            model = args[:key]\n            keys_by_id = for_params.group_by(&:first)\n            ids = for_params.map(&:first)\n            preloads = for_params.flat_map(&:second).uniq\n            results = model.where(id: ids)\n            results = results.preload(*preloads) unless preloads.empty?\n            results = results.index_by(&:id)\n\n            keys_by_id.each do |id, keys|\n              keys.each { |k| loader.call(k, results[id] || default_value) }\n            end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2099"
    },
    {
        "raw_code": "def put(*path_or_actions, as: DEFAULT, to: nil, controller: nil, action: nil, on: nil, defaults: nil, constraints: nil, anchor: nil, format: nil, path: nil, internal: nil, **mapping, &block)\n          if path_or_actions.grep(Hash).any? && (deprecated_options = path_or_actions.extract_options!)\n            as = assign_deprecated_option(deprecated_options, :as, :put) if deprecated_options.key?(:as)\n            to ||= assign_deprecated_option(deprecated_options, :to, :put)\n            controller ||= assign_deprecated_option(deprecated_options, :controller, :put)\n            action ||= assign_deprecated_option(deprecated_options, :action, :put)\n            on ||= assign_deprecated_option(deprecated_options, :on, :put)\n            defaults ||= assign_deprecated_option(deprecated_options, :defaults, :put)\n            constraints ||= assign_deprecated_option(deprecated_options, :constraints, :put)\n            anchor = assign_deprecated_option(deprecated_options, :anchor, :put) if deprecated_options.key?(:anchor)\n            format = assign_deprecated_option(deprecated_options, :format, :put) if deprecated_options.key?(:format)\n            path ||= assign_deprecated_option(deprecated_options, :path, :put)\n            internal ||= assign_deprecated_option(deprecated_options, :internal, :put)\n            assign_deprecated_options(deprecated_options, mapping, :put)\n          end",
        "comment": "Define a route that only recognizes HTTP PUT. For supported arguments, see [match](rdoc-ref:Base#match)  put 'bacon', to: 'food#bacon'",
        "label": "What",
        "id": "11566"
    },
    {
        "raw_code": "def create_or_update_org_codespaces_secret(org, name, options)\n        put \"#{Organization.path org}/codespaces/secrets/#{name}\", options\n      end",
        "comment": "Create or update org secrets  @param org [String] A GitHub organization @param name [String] Name of secret @param options [Hash] encrypted_value and key_id @see https://docs.github.com/en/rest/codespaces/organization-secrets?apiVersion=2022-11-28#create-or-update-an-organization-secret",
        "label": "What",
        "id": "15222"
    },
    {
        "raw_code": "def access_check_result\n        with_admin_mode_bypass!(actor.user&.id) do\n          access_check!(actor, params)\n        end",
        "comment": "rubocop:enable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "3831"
    },
    {
        "raw_code": "def build_ff_identifiers(feature_flag)\n      [self.class.name.demodulize, feature_flag.name]\n    end",
        "comment": "rubocop:enable Gitlab/DocumentationLinks/HardcodedUrl",
        "label": "What",
        "id": "8080"
    },
    {
        "raw_code": "def prune_method_listing(list, hide_attributes = true)\n          list = run_verifier(list)\n          list = list.reject {|o| run_verifier([o.parent]).empty? }\n          list = list.reject {|o| o.is_alias? unless CodeObjects::Proxy === o.namespace }\n          list = list.reject {|o| o.is_attribute? unless CodeObjects::Proxy === o.namespace } if hide_attributes\n          list\n        end",
        "comment": "Prunes the method listing by running the verifier and removing attributes/aliases @param [Array<CodeObjects::Base>] list a list of methods @param [Boolean] hide_attributes whether to prune attribute methods from the list @return [Array<CodeObjects::Base>] a pruned list of methods",
        "label": "What",
        "id": "448"
    },
    {
        "raw_code": "def disabled?\n      %w[disable todo].include?(mode)\n    end",
        "comment": "Checks if this directive disables cops",
        "label": "What",
        "id": "10101"
    },
    {
        "raw_code": "def get_stats_v2_with_http_info(group_id, opts = {})\n      if @api_client.config.debugging\n        @api_client.config.logger.debug 'Calling API: ErrorsV2Api.get_stats_v2 ...'\n      end",
        "comment": "Stats of events received for the group @param group_id [Integer] ID of the group @param [Hash] opts the optional parameters @return [Array<(Array<StatsObject>, Integer, Hash)>] Array<StatsObject> data, response status code and response headers",
        "label": "What",
        "id": "1019"
    },
    {
        "raw_code": "def pre_auth\n      @pre_auth ||= Doorkeeper::OAuth::PreAuthorization.new(\n        Doorkeeper.configuration, params)\n    end",
        "comment": "Next methods are needed for Doorkeeper",
        "label": "What",
        "id": "3514"
    },
    {
        "raw_code": "def column_cards(id, options = {})\n        paginate \"projects/columns/#{id}/cards\", options\n      end",
        "comment": "List columns cards  Requires authenticated client  @param id [Integer] Project column id @return [Array<Sawyer::Resource>] Cards in the column @see https://developer.github.com/v3/projects/cards/#list-project-cards @example @client.column_cards(30294)",
        "label": "What",
        "id": "15326"
    },
    {
        "raw_code": "def self.normalize_path(path)\n          return \"/\".dup unless path\n\n          # Fast path for the overwhelming majority of paths that don't need to be normalized\n          if path == \"/\" || (path.start_with?(\"/\") && !path.end_with?(\"/\") && !path.match?(%r{%|//}))\n            return path.dup\n          end",
        "comment": "Normalizes URI path.  Strips off trailing slash and ensures there is a leading slash. Also converts downcase URL encoded string to uppercase.  normalize_path(\"/foo\")  # => \"/foo\" normalize_path(\"/foo/\") # => \"/foo\" normalize_path(\"foo\")   # => \"/foo\" normalize_path(\"\")      # => \"/\" normalize_path(\"/%ab\")  # => \"/%AB\"",
        "label": "What",
        "id": "11513"
    },
    {
        "raw_code": "def extract_cmd(archive_file:, target_directory:)\n            tar_args = %W[\n              --unlink-first\n              --recursive-unlink\n              --directory=#{target_directory}\n              --extract\n              --file=#{archive_file}\n            ]\n\n            Shell::Command.new(cmd, *tar_args)\n          end",
        "comment": "@param [Object] archive_file @param [Object] target_directory @return [Gitlab::Backup::Cli::Shell::Command]",
        "label": "What",
        "id": "1052"
    },
    {
        "raw_code": "def destroy\n    result = ::Branches::DeleteService.new(project, current_user).execute(params[:id])\n\n    respond_to do |format|\n      format.html do\n        flash_type = result.error? ? :alert : :notice\n        flash[flash_type] = result.message\n\n        redirect_back_or_default(default: project_branches_path(@project), options: { status: :see_other })\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6592"
    },
    {
        "raw_code": "def belongs_to_touch_method\n    :touch\n  end",
        "comment": "Rails5 defaults to :touch_later, overwrite for normal touch",
        "label": "What",
        "id": "6954"
    },
    {
        "raw_code": "def runners(**kwargs)\n        auto_paginated_response(request_url(api_runners_path, **kwargs))\n      end",
        "comment": "Get group runners  @param [Hash] **kwargs optional query arguments, see: https://docs.gitlab.com/ee/api/runners.html#list-groups-runners @return [Array]",
        "label": "What",
        "id": "4154"
    },
    {
        "raw_code": "def _ReferenceLinkDouble\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_Label)\n      content = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ReferenceLinkDouble = Label:content < Spnl > !\"[]\" Label:label { link_to content, label, text }",
        "label": "What",
        "id": "15764"
    },
    {
        "raw_code": "def trace_chunks\n          strong_memoize(:trace_chunks) do\n            ::Ci::BuildTraceChunk.with_read_consistency(build) do\n              build.trace_chunks.persisted\n                .select(::Ci::BuildTraceChunk.metadata_attributes)\n            end",
        "comment": " Trace chunks will be persisted in a database if an object store is not configured - in that case we do not want to load entire raw data of all the chunks into memory.  We ignore `raw_data` attribute instead, and rely on internal build trace chunk database adapter to handle `ActiveModel::MissingAttributeError` exception.  Alternative solution would be separating chunk data from chunk metadata on the database level too. ",
        "label": "What",
        "id": "2523"
    },
    {
        "raw_code": "def _Table\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = begin;  github? ; end\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Table = &{ github? } TableHead:header TableLine:line TableRow+:body {           table = RDoc::Markup::Table.new(header, line, body)           parse_table_cells(table)         }",
        "label": "What",
        "id": "15828"
    },
    {
        "raw_code": "def _bulk_insert_saved_from_belongs_to?(name, args)\n      args.first == :before && args.second.to_s.start_with?('autosave_associated_records_for_')\n    end",
        "comment": "belongs_to associations will install a before_save hook during class loading",
        "label": "What",
        "id": "7252"
    },
    {
        "raw_code": "def clear_comment\n    @comment = ''\n  end",
        "comment": " Clears the comment. Used by the Ruby parser.",
        "label": "What",
        "id": "16739"
    },
    {
        "raw_code": "def find_target(node)\n          case node.type\n          when :begin\n            find_target(node.children.first)\n          when :or\n            find_target(node.lhs)\n          when :match_with_lvasgn\n            lhs, rhs = *node # rubocop:disable InternalAffairs/NodeDestructuring\n            if lhs.regexp_type?\n              rhs\n            elsif rhs.regexp_type?\n              lhs\n            end",
        "comment": "rubocop:disable Metrics/MethodLength",
        "label": "What",
        "id": "10529"
    },
    {
        "raw_code": "def clear_association_scope_cache # :nodoc:\n        delegate_reflection.clear_association_scope_cache\n        source_reflection.clear_association_scope_cache\n        through_reflection.clear_association_scope_cache\n      end",
        "comment": "This is for clearing cache on the reflection. Useful for tests that need to compare SQL queries on associations.",
        "label": "What",
        "id": "12619"
    },
    {
        "raw_code": "def perform\n          if should_defer_perform?\n            defer_job!\n            return\n          end",
        "comment": "This will continue the server middleware chain if the job should be executed. It will return false if the job should not be executed.",
        "label": "What",
        "id": "2767"
    },
    {
        "raw_code": "def pick_repository_storage\n    normalized_repository_storage_weights.max_by { |_, weight| rand**(1.0 / weight) }.first\n  end",
        "comment": "Choose one of the available repository storage options based on a normalized weighted probability.",
        "label": "What",
        "id": "6958"
    },
    {
        "raw_code": "def self.add_event(*args)\n      current_transaction&.add_event(*args)\n    end",
        "comment": "Tracks an event.  See `Gitlab::Metrics::Transaction#add_event` for more details.",
        "label": "What",
        "id": "1495"
    },
    {
        "raw_code": "def prefix_from(artifact_id)\n          artifact_id.gsub(/-?maven-?/, '')\n                     .gsub(/-?plugin-?/, '')\n        end",
        "comment": "Maven plugin prefix generation from https://github.com/apache/maven/blob/c3dba0e5ba71ee7cbd62620f669a8c206e71b5e2/maven-plugin-api/src/main/java/org/apache/maven/plugin/descriptor/PluginDescriptor.java#L189",
        "label": "What",
        "id": "5757"
    },
    {
        "raw_code": "def source_import_commit_authors(repo, options = {})\n        get \"#{Repository.path repo}/import/authors\", options\n      end",
        "comment": "List source import commit authors  @param repo [Integer, String, Hash, Repository] A GitHub repository. @param options [Hash] @option options [String] :since Only authors found after this id are returned. @return [Array<Sawyer::Resource>] Array of hashes representing commit_authors. @see https://developer.github.com/v3/migration/source_imports/#get-commit-authors  @example @client.source_import_commit_authors(\"octokit/octokit.rb\")",
        "label": "What",
        "id": "15277"
    },
    {
        "raw_code": "def copy_files(source, destination)\n        # if we are copying files, create the destination folder\n        destination_folder = File.file?(source) ? File.dirname(destination) : destination\n\n        mkdir_p(destination_folder)\n        FileUtils.copy_entry(source, destination)\n        true\n      end",
        "comment": "rubocop:enable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "2818"
    },
    {
        "raw_code": "def upload_license(license)\n      conn = authenticated_client\n      begin\n        conn.request :multipart\n      rescue Faraday::Error\n        raise Faraday::Error, <<~ERROR\n          The `faraday-multipart` gem is required to upload a license.\n          Please add `gem \"faraday-multipart\"` to your Gemfile.\n        ERROR\n      end",
        "comment": "Uploads a license for the first time  @param license [String] The path to your .ghl license file.  @return [nil]",
        "label": "What",
        "id": "14925"
    },
    {
        "raw_code": "def meow_at_3am?\n              rand < 0.8\n            end",
        "comment": "Here we go back an indentation level again. This is a violation of the indented_internal_methods style, but it's not for this cop to report. Layout/IndentationWidth will handle it.",
        "label": "What",
        "id": "10824"
    },
    {
        "raw_code": "def clear_token\n        @logger.info(\"Clearing token\")\n        token_path.delete if token_path.file?\n      end",
        "comment": "Removes the token, effectively logging the user out.",
        "label": "What",
        "id": "9775"
    },
    {
        "raw_code": "def list_dependabot_secrets(repo)\n        paginate \"#{Repository.path repo}/dependabot/secrets\" do |data, last_response|\n          data.secrets.concat last_response.data.secrets\n        end",
        "comment": "List secrets  @param repo [Integer, String, Hash, Repository] A GitHub repository @return [Hash] total_count and list of secrets (each item is hash with name, created_at and updated_at) @see https://docs.github.com/en/rest/dependabot/repository-secrets?apiVersion=2022-11-28#list-repository-secrets",
        "label": "What",
        "id": "14987"
    },
    {
        "raw_code": "def message(node)\n          format(MSG, source: node.source)\n        end",
        "comment": "rubocop:enable Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "10603"
    },
    {
        "raw_code": "def self.query(project_ids)\n      ForkNetworkMember.where(forked_from_project: project_ids)\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5904"
    },
    {
        "raw_code": "def has_repository?\n      return false unless has_project?\n\n      repository_project.container_repositories\n        .where(name: repository_name).any?\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3383"
    },
    {
        "raw_code": "def self.from_api_response(gist, additional_data = {})\n          hash = {\n            id: gist[:id],\n            description: gist[:description],\n            is_public: gist[:public],\n            files: gist[:files],\n            git_pull_url: gist[:git_pull_url],\n            created_at: gist[:created_at],\n            updated_at: gist[:updated_at]\n          }\n\n          new(hash)\n        end",
        "comment": "Builds a gist from a GitHub API response.  gist - An instance of `Hash` containing the gist details.",
        "label": "What",
        "id": "2684"
    },
    {
        "raw_code": "def list_interfaces\n          Socket.getifaddrs.find_all do |i|\n            !i.addr.nil? && i.addr.ip? && !i.addr.ipv4_loopback? &&\n              !i.addr.ipv6_loopback? && !i.addr.ipv6_linklocal?\n          end",
        "comment": "@return [Array<Socket::Ifaddr>] interface list",
        "label": "What",
        "id": "9519"
    },
    {
        "raw_code": "def has_ci_enabled?\n    has_ci? || pipeline_creating?\n  end",
        "comment": "We use a heuristic of if there are pipeline created, being created, or a ci integration is setup",
        "label": "What",
        "id": "6985"
    },
    {
        "raw_code": "def validate_check_constraint(table_name, **options)\n          chk_name_to_validate = check_constraint_for!(table_name, **options).name\n\n          validate_constraint table_name, chk_name_to_validate\n        end",
        "comment": "Validates the given check constraint.  validate_check_constraint :products, name: \"price_check\"  The +options+ hash accepts the same keys as {add_check_constraint}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_check_constraint].",
        "label": "What",
        "id": "13275"
    },
    {
        "raw_code": "def start_with_marker?\n      comment.text.start_with?(DIRECTIVE_MARKER_REGEXP)\n    end",
        "comment": "Checks if the comment starts with `# rubocop:` marker",
        "label": "What",
        "id": "10095"
    },
    {
        "raw_code": "def by_label(issuables)\n      return issuables unless label_names_from_params.present?\n\n      if filter_by_no_label?\n        issuables.where(label_link_query(issuables).arel.exists.not)\n      elsif filter_by_any_label?\n        issuables.where(label_link_query(issuables).arel.exists)\n      else\n        issuables_with_selected_labels(issuables, label_names_from_params)\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7976"
    },
    {
        "raw_code": "def focus_filtered_search\n      page.within(search_bar_selector) do\n        page.find('.gl-filtered-search-term-token').click\n      end",
        "comment": "The filters must be clicked first to be able to receive events See: https://gitlab.com/gitlab-org/gitlab-services/design.gitlab.com/-/issues/2799",
        "label": "What",
        "id": "8518"
    },
    {
        "raw_code": "def parse_symbol(sha_hash, _match)\n          sha_hash\n        end",
        "comment": "The default behaviour is `#to_i` - we just pass the hash through.",
        "label": "What",
        "id": "3504"
    },
    {
        "raw_code": "def self.authorization\n      @authorization ||= ::Gitlab::Graphql::Authorize::ObjectAuthorization.new(authorize, authorization_scopes)\n    end",
        "comment": "See: AuthorizeResource#authorized_resource?",
        "label": "What",
        "id": "6154"
    },
    {
        "raw_code": "def _HtmlBlockTfoot\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenTfoot)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockTfoot = HtmlBlockOpenTfoot (HtmlBlockTfoot | !HtmlBlockCloseTfoot .)* HtmlBlockCloseTfoot",
        "label": "What",
        "id": "15712"
    },
    {
        "raw_code": "def rate_limit_remaining(_options = {})\n        octokit_warn 'Deprecated: Please use .rate_limit.remaining'\n        rate_limit.remaining\n      end",
        "comment": "Get number of rate limted requests remaining  @see https://developer.github.com/v3/rate_limit/#rate-limit @return [Integer] Number of requests remaining in this period",
        "label": "What",
        "id": "15047"
    },
    {
        "raw_code": "def associate_document(document, object)\n      # XML nodes respond to \"document\" but will return a Document instance,\n      # even when they belong to a DocumentFragment.\n      document = document.document if document.fragment?\n\n      @projects[document] = object.project if object.respond_to?(:project)\n    end",
        "comment": "Associates an HTML document with a Project.  document - The HTML document to map to a Project. object - The object that produced the HTML document.",
        "label": "What",
        "id": "3389"
    },
    {
        "raw_code": "def user_id_for(user, ghost: true)\n        if user.nil? || user[:login].nil? || user[:login] == 'ghost'\n          return ghost ? GithubImport.ghost_user_id : nil\n        end",
        "comment": "Returns the GitLab user ID for a GitHub user. Can return nil if `ghost` is `false`. The `ghost: false` argument is used to avoid assigning ghost users as assignees or reviewers.  @param user [Gitlab::GithubImport::Representation::User, Hash] @param ghost [Boolean] Determines what to do if user is nil or is the GitHub ghost. If `true`, ID of the GitLab ghost is returned. If `false`, nil is returned. @return [Integer, NilClass]",
        "label": "What",
        "id": "2144"
    },
    {
        "raw_code": "def _LineBreak\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"  \")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "LineBreak = \"  \" @NormalEndline { RDoc::Markup::HardBreak.new }",
        "label": "What",
        "id": "15748"
    },
    {
        "raw_code": "def up\n    validate_foreign_key(:epics, :parent_id, name: FK_NAME)\n  end",
        "comment": "foreign key added in db/migrate/20240403113607_replace_epics_fk_on_parent_id.rb",
        "label": "What",
        "id": "5029"
    },
    {
        "raw_code": "def up\n    remove_foreign_key_if_exists(\n      :work_item_dates_sources,\n      column: :namespace_id,\n      on_delete: :nullify,\n      name: OLD_FK_NAME\n    )\n  end",
        "comment": "new foreign key added in FixWorkItemSourceDatesCascadeOptionOnFkToNamespaceId and validated in ValidateNewNamespaceIdFkOnWorkItemDatesSources",
        "label": "What",
        "id": "5008"
    },
    {
        "raw_code": "def filter_by_package_type(packages)\n      # Only filter by package_type when using the base `Packages::Package` class\n      # Format-specific classes like `Packages::TerraformModule::Package` don't need this filter\n      return packages unless packages_class == ::Packages::Package\n      return packages.without_package_type(:terraform_module) unless package_type\n      raise InvalidPackageTypeError unless ::Packages::Package.package_types.key?(package_type)\n\n      packages.with_package_type(package_type)\n    end",
        "comment": "TODO: Remove with the rollout of the FF packages_refactor_group_packages_finder https://gitlab.com/gitlab-org/gitlab/-/issues/568923",
        "label": "What",
        "id": "8000"
    },
    {
        "raw_code": "def find_by_path_or_name(path)\n      find_by(\"lower(path) = :path OR lower(name) = :path\", path: path.downcase)\n    end",
        "comment": "Case insensitive search for namespace by path or name",
        "label": "What",
        "id": "6685"
    },
    {
        "raw_code": "def read_scsi_controllers\n        result = execute(:get_scsi_controller, VmId: vm_id)\n        return result if result.is_a?(Array)\n        [result]\n      end",
        "comment": "Get SCSI controllers attached to VM  @return [Array<Hash>]",
        "label": "What",
        "id": "9697"
    },
    {
        "raw_code": "def download(repo, id, options = {})\n        get \"#{Repository.path repo}/downloads/#{id}\", options\n      end",
        "comment": "Get single download for a repository  @param repo [Integer, String, Repository, Hash] A GitHub repository @param id [Integer] ID of the download @return [Sawyer::Resource] A single download from the repository @deprecated As of December 11th, 2012: https://github.com/blog/1302-goodbye-uploads @see https://developer.github.com/v3/repos/downloads/#get-a-single-download @example Get the \"Robawt\" download from Github/Hubot Octokit.download(\"github/hubot\")",
        "label": "What",
        "id": "15052"
    },
    {
        "raw_code": "def ssh_key_expiring_soon(user, fingerprints)\n    return unless user.can?(:receive_notifications)\n\n    mailer.ssh_key_expiring_soon_email(user, fingerprints).deliver_later\n  end",
        "comment": "Notify the user when at least one of their ssh key is expiring soon",
        "label": "What",
        "id": "5462"
    },
    {
        "raw_code": "def unsuspend(user, options = {})\n        boolean_from_response :delete, \"users/#{user}/suspended\", options\n      end",
        "comment": "Unsuspend a user.  @param user [String] Username of the user to unsuspend. @return [Boolean] True if unsuspend was successful, false otherwise. @see https://developer.github.com/enterprise/v3/enterprise-admin/users/#unsuspend-a-user @example @admin_client.unsuspend('holman')",
        "label": "What",
        "id": "14963"
    },
    {
        "raw_code": "def by_label_union(issuables)\n      return issuables unless label_names_from_or_params.present?\n\n      if root_namespace\n        all_label_ids = find_label_ids(label_names_from_or_params).flatten\n        issuables.where(label_link_query(issuables, label_ids: all_label_ids).arel.exists)\n      else\n        issuables.where(label_link_query(issuables, label_names: label_names_from_or_params).arel.exists)\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7977"
    },
    {
        "raw_code": "def self.reset!\n          instance_variables.each(&method(:remove_instance_variable))\n        end",
        "comment": "@private Reset the cached values for capability. This is not considered a public API and should only be used for testing.",
        "label": "What",
        "id": "9727"
    },
    {
        "raw_code": "def self.fetch(\n        stage_name:,\n        access_token:,\n        project_id: ENV[\"CI_PROJECT_ID\"],\n        pipeline_id: ENV[\"CI_PIPELINE_ID\"]\n      )\n        new(\n          stage_name: stage_name,\n          project_id: project_id,\n          pipeline_id: pipeline_id,\n          access_token: access_token\n        ).parallel_jobs\n      end",
        "comment": "Fetch parallel job names in given stage  Default to arguments available on CI  @param [String] stage_name @param [Integer] project_id @param [Integer] pipeline_id @param [String] access_token @return [Array]",
        "label": "What",
        "id": "4524"
    },
    {
        "raw_code": "def ignore *node\n  end",
        "comment": " Use ignore in your subclass to ignore the content of a node.  ## # We don't support raw nodes in ToNoRaw  alias accept_raw ignore",
        "label": "What",
        "id": "16281"
    },
    {
        "raw_code": "def self.delete_bulk(merge_request, commits)\n    commit_ids = commits.map(&:sha)\n    merge_request.merge_request_context_commits.where(sha: commit_ids).delete_all\n  end",
        "comment": "delete all MergeRequestContextCommit & MergeRequestContextCommitDiffFile for given merge_request & commit SHAs",
        "label": "What",
        "id": "6862"
    },
    {
        "raw_code": "def quote_and_escape(text, quote = '\"')\n        \"#{quote}#{text.gsub(/#{quote}/) { |m| \"#{m}\\\\#{m}#{m}\" }}#{quote}\"\n      end",
        "comment": "Quote and escape strings for shell execution, thanks to Capistrano.",
        "label": "What",
        "id": "9359"
    },
    {
        "raw_code": "def on_block(node)\n          return unless node.parent&.begin_type?\n          return unless collection_looping_method?(node)\n          return unless same_collection_looping_block?(node, node.left_sibling)\n          return unless node.body && node.left_sibling.body\n\n          add_offense(node) do |corrector|\n            next unless node.arguments == node.left_sibling.arguments\n\n            combine_with_left_sibling(corrector, node)\n          end",
        "comment": "rubocop:disable Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "10604"
    },
    {
        "raw_code": "def app_generators\n        @@app_generators ||= Rails::Configuration::Generators.new\n        yield(@@app_generators) if block_given?\n        @@app_generators\n      end",
        "comment": "This allows you to modify application's generators from Railties.  Values set on app_generators will become defaults for application, unless application overwrites them.",
        "label": "What",
        "id": "14812"
    },
    {
        "raw_code": "def safe_url(allowed_usernames: [])\n    return if url.nil?\n\n    escaped = Addressable::URI.escape(url)\n    uri = URI.parse(escaped)\n    uri.password = '*****' if uri.password\n    uri.user = '*****' if uri.user && allowed_usernames.exclude?(uri.user)\n    Addressable::URI.unescape(uri.to_s)\n  rescue URI::Error, TypeError, Addressable::URI::InvalidURIError\n  end",
        "comment": "Return the URL with obfuscated userinfo and keeping it intact",
        "label": "What",
        "id": "7294"
    },
    {
        "raw_code": "def unregister_separator_by_type(type)\n        seps = NamespaceMapper.rev_map[type]\n        return unless seps\n        \n        seps.each {|s| NamespaceMapper.map.delete(s) }\n        NamespaceMapper.rev_map.delete(type)\n        NamespaceMapper.invalidate\n      end",
        "comment": "Unregisters a separator by a type.  @param type [Symbol] the type to unregister @see #register_separator",
        "label": "What",
        "id": "597"
    },
    {
        "raw_code": "def strip_comments\n        source.comments.each do |comment|\n          next if comment.text.include?('frozen_string_literal: true')\n\n          rewriter.remove(comment_range(comment))\n        end",
        "comment": "Strip comments from the source file, except the for frozen_string_literal: true",
        "label": "What",
        "id": "8082"
    },
    {
        "raw_code": "def default(\n      message: 'Message for the broadcast banner',\n      id: '99',\n      theme: 'light-indigo',\n      dismissable: true,\n      expire_date: Time.now.next_year.iso8601,\n      cookie_key: 'my_cookie',\n      dismissal_path: '/my-path'\n    )\n      render(Pajamas::BroadcastBannerComponent.new(\n        message: message,\n        id: id,\n        theme: theme,\n        dismissable: dismissable,\n        expire_date: expire_date,\n        cookie_key: cookie_key,\n        dismissal_path: dismissal_path\n      ))\n    end",
        "comment": "@param message text @param id text @param theme text @param dismissable toggle @param expire_date text @param cookie_key text @param dismissal_path text",
        "label": "What",
        "id": "8193"
    },
    {
        "raw_code": "def stats_for_constants\n        output \"Constants\", *type_statistics(:constant)\n      end",
        "comment": "Statistics for constants",
        "label": "What",
        "id": "521"
    },
    {
        "raw_code": "def meths(opts = {})\n      opts = SymbolHash[\n        :visibility => [:public, :private, :protected],\n        :scope => [:class, :instance],\n        :included => true\n      ].update(opts)\n\n      opts[:visibility] = [opts[:visibility]].flatten\n      opts[:scope] = [opts[:scope]].flatten\n\n      ourmeths = children.select do |o|\n        o.is_a?(MethodObject) &&\n          opts[:visibility].include?(o.visibility) &&\n          opts[:scope].include?(o.scope)\n      end",
        "comment": "Returns all methods that match the attributes specified by +opts+. If no options are provided, returns all methods.  @example Finds all private and protected class methods namespace.meths(:visibility => [:private, :protected], :scope => :class) # => [#<yardoc method MyClass.privmeth>, #<yardoc method MyClass.protmeth>] @option opts [Array<Symbol>, Symbol] :visibility ([:public, :private, :protected]) the visibility of the methods to list. Can be an array or single value. @option opts [Array<Symbol>, Symbol] :scope ([:class, :instance]) the scope of the methods to list. Can be an array or single value. @option opts [Boolean] :included (true) whether to include mixed in methods in the list. @return [Array<MethodObject>] a list of method objects",
        "label": "What",
        "id": "622"
    },
    {
        "raw_code": "def parse(paths = DEFAULT_PATH_GLOB, excluded = [], level = log.level)\n          log.debug(\"Parsing #{paths.inspect} with `#{parser_type}` parser\")\n          excluded = excluded.map do |path|\n            case path\n            when Regexp; path\n            else Regexp.new(path.to_s, Regexp::IGNORECASE)\n            end",
        "comment": "Parses a path or set of paths  @param [String, Array<String>] paths a path, glob, or list of paths to parse @param [Array<String, Regexp>] excluded a list of excluded path matchers @param [Fixnum] level the logger level to use during parsing. See {YARD::Logger} @return [void]",
        "label": "What",
        "id": "287"
    },
    {
        "raw_code": "def build_create_index_definition(table_name, column_name, **options) # :nodoc:\n        index, algorithm, if_not_exists = add_index_options(table_name, column_name, **options)\n        CreateIndexDefinition.new(index, algorithm, if_not_exists)\n      end",
        "comment": "Builds a CreateIndexDefinition object.  This definition object contains information about the index that would be created if the same arguments were passed to #add_index. See #add_index for information about passing a +table_name+, +column_name+, and other additional options that can be passed.",
        "label": "What",
        "id": "13157"
    },
    {
        "raw_code": "def initialize(name, union_args: {})\n        @table = Arel::Table.new(name)\n        @queries = []\n        @union_args = union_args\n      end",
        "comment": "name - The name of the CTE as a String or Symbol. union_args - The arguments supplied to Gitlab::SQL::Union class when building inner recursive query",
        "label": "What",
        "id": "2854"
    },
    {
        "raw_code": "def existing_merge_request_path\n    project_merge_request_path(@project, @merge_request) # rubocop:disable Gitlab/ModuleWithInstanceVariables\n  end",
        "comment": "rubocop:enable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "6516"
    },
    {
        "raw_code": "def destroy_all_records(pipeline)\n      pipeline.destroy!\n    rescue ActiveRecord::StaleObjectError\n      force_destroy_all_records(pipeline)\n    end",
        "comment": "The pipeline, the builds, job and pipeline artifacts all get destroyed here. Ci::Pipeline#destroy triggers fast destroy on job_artifacts and build_trace_chunks to remove the records and data stored in object storage. ci_builds records are deleted using ON DELETE CASCADE from ci_pipelines ",
        "label": "What",
        "id": "5774"
    },
    {
        "raw_code": "def vm_exists?(uuid)\n        end",
        "comment": "Checks if a VM with the given UUID exists.  @return [Boolean]",
        "label": "What",
        "id": "9600"
    },
    {
        "raw_code": "def sort_value_created_date\n    'created_date'\n  end",
        "comment": "Values.",
        "label": "What",
        "id": "7778"
    },
    {
        "raw_code": "def grouped_choices?\n            return false if @choices.blank?\n\n            first_choice = @choices.first\n            return false unless first_choice.is_a?(Enumerable)\n\n            first_choice.second.is_a?(Array)\n          end",
        "comment": "Grouped choices look like this:  [nil, []] { nil => [] }",
        "label": "What",
        "id": "12001"
    },
    {
        "raw_code": "def has_vmcx_support?\n        !!execute(:has_vmcx_support)[\"result\"]\n      end",
        "comment": "@return [Boolean] Supports VMCX",
        "label": "What",
        "id": "9667"
    },
    {
        "raw_code": "def root(req, res)\n    generator = RDoc::Generator::Darkfish.new nil, @options\n\n    res.body = generator.generate_servlet_root installed_docs\n\n    res.content_type = 'text/html'\n  end",
        "comment": " Generates the root page on +res+.  +req+ is ignored.",
        "label": "What",
        "id": "15945"
    },
    {
        "raw_code": "def with_engine(engine)\n      engine_was = @current_engine\n      @current_engine = engine.to_sym\n      yield\n    ensure\n      @current_engine = engine_was\n    end",
        "comment": "@param engine [Symbol, String] Name of Engine to shift to.",
        "label": "What",
        "id": "8682"
    },
    {
        "raw_code": "def opened_content(comments)\n        while comment = comments.shift\n          if comment['sVerb'] == 'Opened'\n            return comment['s']\n          end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2795"
    },
    {
        "raw_code": "def create_pre_receive_hook\n            log(\"Creating pre-receive hook\", :info)\n            configmap = Kubectl::Resources::Configmap.new(PRE_RECEIVE_HOOK_CONFIGMAP_NAME, \"hook.sh\", PRE_RECEIVE_HOOK)\n            puts kubeclient.create_resource(configmap)\n          end",
        "comment": "Create pre-receive hook  @return [void]",
        "label": "What",
        "id": "4027"
    },
    {
        "raw_code": "def in_directive_department?(cop)\n      department_names.any? { |department| cop.start_with?(department) }\n    end",
        "comment": "Checks if directive departments include cop",
        "label": "What",
        "id": "10109"
    },
    {
        "raw_code": "def add_project_watchers\n        add_recipients(project_watchers, :watch, nil) if project\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6065"
    },
    {
        "raw_code": "def self.logger\n          @logger ||= ::Gitlab::BackgroundMigration::Logger.build\n        end",
        "comment": "rubocop:enable Metrics/MethodLength @return [Gitlab::BackgroundMigration::Logger]",
        "label": "What",
        "id": "3304"
    },
    {
        "raw_code": "def x\n        end",
        "comment": "steep",
        "label": "What",
        "id": "10867"
    },
    {
        "raw_code": "def lower(column)\n      Nodes::NamedFunction.new \"LOWER\", [Nodes.build_quoted(column)]\n    end",
        "comment": " Create a LOWER() function",
        "label": "What",
        "id": "13470"
    },
    {
        "raw_code": "def ==(o)\n      return true if self.equal?(o)\n      self.class == o.class &&\n          fingerprint == o.fingerprint &&\n          project_id == o.project_id &&\n          name == o.name &&\n          description == o.description &&\n          actor == o.actor &&\n          event_count == o.event_count &&\n          approximated_user_count == o.approximated_user_count &&\n          last_seen_at == o.last_seen_at &&\n          first_seen_at == o.first_seen_at &&\n          status == o.status &&\n          stats == o.stats\n    end",
        "comment": "Checks equality by comparing each attribute. @param [Object] Object to be compared",
        "label": "What",
        "id": "904"
    },
    {
        "raw_code": "def do_something\n      end",
        "comment": "comment",
        "label": "What",
        "id": "10775"
    },
    {
        "raw_code": "def user_revert(user:, commit:, branch_name:, message:, start_branch_name:, start_repository:, dry_run: false)\n        request = Gitaly::UserRevertRequest.new(\n          repository: @gitaly_repo,\n          user: gitaly_user(user),\n          commit: commit.to_gitaly_commit,\n          branch_name: encode_binary(branch_name),\n          message: encode_binary(message),\n          start_branch_name: encode_binary(start_branch_name.to_s),\n          start_repository: start_repository.gitaly_repository,\n          dry_run: dry_run,\n          timestamp: Google::Protobuf::Timestamp.new(seconds: Time.now.utc.to_i)\n        )\n\n        response = gitaly_client_call(\n          @repository.storage,\n          :operation_service,\n          :user_revert,\n          request,\n          remote_storage: start_repository.storage,\n          timeout: GitalyClient.long_timeout\n        )\n\n        if response.pre_receive_error.presence\n          raise Gitlab::Git::PreReceiveError, response.pre_receive_error\n        elsif response.commit_error.presence\n          raise Gitlab::Git::CommitError, response.commit_error\n        elsif response.create_tree_error.presence\n          raise Gitlab::Git::Repository::CreateTreeError, response.create_tree_error_code\n        end",
        "comment": "rubocop:enable Metrics/ParameterLists",
        "label": "What",
        "id": "1804"
    },
    {
        "raw_code": "def url_for(obj, anchor = nil, relative = false) # rubocop:disable Lint/UnusedMethodArgument\n        return '' if obj.nil?\n        return url_for_index if obj == '_index.html'\n        return abs_url(base_path(router.static_prefix), obj) if String === obj\n        url = super(obj, anchor, false)\n        return unless url\n        abs_url(base_path(router.docs_prefix), url)\n      end",
        "comment": "Modifies {Templates::Helpers::HtmlHelper#url_for} to return a URL instead of a disk location. @param (see Templates::Helpers::HtmlHelper#url_for) @return (see Templates::Helpers::HtmlHelper#url_for)",
        "label": "What",
        "id": "681"
    },
    {
        "raw_code": "def expect_correction(correction, loop: true, source: nil)\n        if source\n          expected_annotations = parse_annotations(source, raise_error: false)\n          @processed_source = parse_processed_source(expected_annotations.plain_source)\n          _investigate(cop, @processed_source)\n        end",
        "comment": "rubocop:enable Metrics/AbcSize rubocop:disable Metrics/AbcSize, Metrics/MethodLength, Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "10709"
    },
    {
        "raw_code": "def starred?(repo, options = {})\n        boolean_from_response :get, \"user/starred/#{Repository.new(repo)}\", options\n      end",
        "comment": "Check if you are starring a repo.  Requires authenticated client.  @param repo [String, Hash, Repository] A GitHub repository @return [Boolean] True if you are following the repo, false otherwise. @see https://developer.github.com/v3/activity/starring/#check-if-you-are-starring-a-repository @example @client.starred?('pengwynn/octokit')",
        "label": "What",
        "id": "15477"
    },
    {
        "raw_code": "def format_object_title(object)\n      case object\n      when YARD::CodeObjects::RootObject\n        \"Top Level Namespace\"\n      else\n        format_object_type(object) + \": \" + object.title\n      end",
        "comment": "@example s = format_object_title ModuleObject.new(:root, :MyModuleName) s # => \"Module: MyModuleName\" @param [CodeObjects::Base] object the object to retrieve a title for @return [String] the page title name for a given object",
        "label": "What",
        "id": "436"
    },
    {
        "raw_code": "def update_params\n        placeholder_creator = Gitlab::Import::PlaceholderUserCreator.new(import_source_user)\n\n        update_params = {}\n        update_params[:name] = placeholder_creator.placeholder_name if params[:source_name]\n\n        if params[:source_username]\n          update_params[:username] = placeholder_creator.send(:username_and_email_generator).username # rubocop:disable GitlabSecurity/PublicSend -- Safe to call, we don't want to publically expose this method.\n        end",
        "comment": "overridden in EE",
        "label": "What",
        "id": "6107"
    },
    {
        "raw_code": "def generate_log(exception, context_payload)\n        payload = {}\n\n        Gitlab::ExceptionLogFormatter.format!(exception, payload)\n        append_user_to_log!(payload, context_payload)\n        append_tags_to_log!(payload, context_payload)\n        append_extra_to_log!(payload, context_payload)\n\n        payload\n      end",
        "comment": "Note: all the accesses to Sentry's contexts here are to keep the backward-compatibility to Sentry's built-in integrations. In the future, they can be removed.",
        "label": "What",
        "id": "2776"
    },
    {
        "raw_code": "def ping_path\n      '/ping'\n    end",
        "comment": "to be overwritten",
        "label": "What",
        "id": "8654"
    },
    {
        "raw_code": "def initialize(project, options = {})\n        raise ArgumentError, 'project must be a valid Project instance' unless project.is_a?(Project)\n\n        @project = project\n        @select_fields = options[:select_fields] || []\n        @aggregations = options[:aggregations] || []\n        @sort = options[:sort]\n        @source = options[:source]\n        @ref = options[:ref]\n        @from_time = options[:from_time] || 1.week.ago.utc\n        @to_time = options[:to_time]\n        @name_search = options[:name_search]\n      end",
        "comment": "@param project [Project] The project to find jobs for @param options [Hash] Options for filtering and configuring the query builder @option options [Array] :select_fields Fields to select @option options [Array] :aggregations Aggregations to perform @option options [String] :sort Sort order (ex. rate_of_success_asc) @option options [String] :source Pipeline source @option options [String] :ref Git reference @option options [Time] :from_time Start time for filtering (defaults to 7 days ago) @option options [Time] :to_time End time for filtering @option options [String] :name_search Search by name of the pipeline jobs.",
        "label": "What",
        "id": "5842"
    },
    {
        "raw_code": "def blah\n          end",
        "comment": "{keyword} A {modifier == 'private' ? 'protected' : 'private'}",
        "label": "What",
        "id": "10973"
    },
    {
        "raw_code": "def self.which(cmd, **opts)\n        exts = nil\n\n        if !Platform.windows? || ENV['PATHEXT'].nil?\n          # If the PATHEXT variable is empty, we're on *nix and need to find\n          # the exact filename\n          exts = ['']\n        elsif File.extname(cmd).length != 0\n          # On Windows: if filename contains an extension, we must match that\n          # exact filename\n          exts = ['']\n        else\n          # On Windows: otherwise try to match all possible executable file\n          # extensions (.EXE .COM .BAT etc.)\n          exts = ENV['PATHEXT'].split(';')\n        end",
        "comment": "Cross-platform way of finding an executable in the PATH.  which('ruby') #=> /usr/bin/ruby  This code is adapted from the following post by mislav: http://stackoverflow.com/questions/2108727/which-in-ruby-checking-if-program-exists-in-path-from-ruby  @param [String] cmd The command to search for in the PATH. @param [Hash] opts Optional flags @option [Boolean] :original_path Search within original path if available @return [String] The full path to the executable or `nil` if not found.",
        "label": "What",
        "id": "9164"
    },
    {
        "raw_code": "def enforce_uri_hostname(ip_address, uri, dns_rebind_protection, proxy_in_use)\n          unless dns_rebind_protection && ip_address && ip_address != uri.hostname\n            return Result.new(uri, nil, proxy_in_use)\n          end",
        "comment": "Returns the given URI with IP address as hostname and the original hostname respectively in an Array.  It checks whether the resolved IP address matches with the hostname. If not, it changes the hostname to the resolved IP address.  The original hostname is used to validate the SSL, given in that scenario we'll be making the request to the IP address, instead of using the hostname.",
        "label": "What",
        "id": "1201"
    },
    {
        "raw_code": "def defaults\n    super\n\n    @rdoc_dir = '.rdoc'\n  end",
        "comment": " Sets default task values",
        "label": "What",
        "id": "16567"
    },
    {
        "raw_code": "def stub_session(session_data:, user_id: nil)\n    unless RSpec.current_example.metadata[:clean_gitlab_redis_sessions]\n      raise 'Add :clean_gitlab_redis_sessions to your spec!'\n    end",
        "comment": "Stub a session in Redis, for use in request specs where we can't mock the session directly. This also needs the :clean_gitlab_redis_sessions tag on the spec.",
        "label": "What",
        "id": "8374"
    },
    {
        "raw_code": "def get_user\n      @email = Base64.urlsafe_decode64(params.permit(:email)[:email])\n      User.find_by(email: @email)\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6648"
    },
    {
        "raw_code": "def after_remove_tag\n    expire_caches_for_tags\n  end",
        "comment": "Runs code after removing a tag.",
        "label": "What",
        "id": "7140"
    },
    {
        "raw_code": "def self.validate_install!\n        if !defined?(@_powershell_validation)\n          raise Errors::PowerShellNotFound if !available?\n          if version.to_i < MINIMUM_REQUIRED_VERSION\n            raise Errors::PowerShellInvalidVersion,\n              minimum_version: MINIMUM_REQUIRED_VERSION,\n              installed_version: version ? version : \"N/A\"\n          end",
        "comment": "Validates that powershell is installed, available, and at or above minimum required version  @return [Boolean] @raises []",
        "label": "What",
        "id": "9275"
    },
    {
        "raw_code": "def update_counters(id, counters)\n            counters = counters.merge(locking_column => 1) if locking_enabled?\n            super\n          end",
        "comment": "Make sure the lock version column gets updated when counters are updated.",
        "label": "What",
        "id": "13330"
    },
    {
        "raw_code": "def _SetextBottom2\n\n    _save = self.pos\n    while true # sequence\n      _tmp = scan(/\\G(?-mix:-{1,})/)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "SetextBottom2 = /-{1,}/ @Newline",
        "label": "What",
        "id": "15602"
    },
    {
        "raw_code": "def self.healthy_shard?(shard_name)\n      with_redis { |redis| redis.sismember(HEALTHY_SHARDS_KEY, shard_name) }\n    end",
        "comment": "Checks whether the given shard name is in the list of healthy shards.  shard_name - The string to check",
        "label": "What",
        "id": "1629"
    },
    {
        "raw_code": "def comment_ranges(comments)\n          comments.map(&:source_range)\n        end",
        "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10391"
    },
    {
        "raw_code": "def any_content(includes = true)\n    @any_content ||= !(\n      @comment.empty? &&\n      @method_list.empty? &&\n      @attributes.empty? &&\n      @aliases.empty? &&\n      @external_aliases.empty? &&\n      @requires.empty? &&\n      @constants.empty?\n    )\n    @any_content || (includes && !(@includes + @extends).empty? )\n  end",
        "comment": " Is there any content?  This means any of: comment, aliases, methods, attributes, external aliases, require, constant.  Includes and extends are also checked unless <tt>includes == false</tt>.",
        "label": "What",
        "id": "16650"
    },
    {
        "raw_code": "def update_pull_request(*args)\n        arguments = Octokit::Arguments.new(args)\n        repo = arguments.shift\n        number = arguments.shift\n        patch \"#{Repository.path repo}/pulls/#{number}\", arguments.options\n      end",
        "comment": "Update a pull request @overload update_pull_request(repo, number, title=nil, body=nil, state=nil, options = {}) @deprecated @param repo [Integer, String, Hash, Repository] A GitHub repository. @param number [Integer] Number of pull request to update. @param title [String] Title for the pull request. @param body [String] Body content for pull request. Supports GFM. @param state [String] State of the pull request. `open` or `closed`. @overload update_pull_request(repo, number,  options = {}) @param repo [Integer, String, Hash, Repository] A GitHub repository. @param number [Integer] Number of pull request to update. @option options [String] :title Title for the pull request. @option options [String] :body Body for the pull request. @option options [String] :state State for the pull request. @return [Sawyer::Resource] Hash representing updated pull request. @see https://developer.github.com/v3/pulls/#update-a-pull-request @example @client.update_pull_request('octokit/octokit.rb', 67, 'new title', 'updated body', 'closed') @example Passing nil for optional attributes to update specific attributes. @client.update_pull_request('octokit/octokit.rb', 67, nil, nil, 'open') @example Empty body by passing empty string @client.update_pull_request('octokit/octokit.rb', 67, nil, '')",
        "label": "What",
        "id": "15088"
    },
    {
        "raw_code": "def find_class_named(name)\n    @classes_hash[name]\n  end",
        "comment": " Finds the class with +name+ in all discovered classes",
        "label": "What",
        "id": "15862"
    },
    {
        "raw_code": "def build_add_column_definition(table_name, column_name, type, **options) # :nodoc:\n        return if options[:if_not_exists] == true && column_exists?(table_name, column_name)\n\n        if supports_datetime_with_precision?\n          if type == :datetime && !options.key?(:precision)\n            options[:precision] = 6\n          end",
        "comment": "Builds an AlterTable object for adding a column to a table.  This definition object contains information about the column that would be created if the same arguments were passed to #add_column. See #add_column for information about passing a +table_name+, +column_name+, +type+ and other options that can be passed.",
        "label": "What",
        "id": "13148"
    },
    {
        "raw_code": "def restore(path, backup_id)\n        raise NotImplementedError\n      end",
        "comment": "restore task backup from `path`",
        "label": "What",
        "id": "3651"
    },
    {
        "raw_code": "def method\n              end",
        "comment": "documentation comment {keyword} Test",
        "label": "What",
        "id": "10885"
    },
    {
        "raw_code": "def rename_table(table_name, new_name, **options)\n          validate_table_length!(new_name) unless options[:_uses_legacy_table_name]\n          clear_cache!\n          schema_cache.clear_data_source_cache!(table_name.to_s)\n          schema_cache.clear_data_source_cache!(new_name.to_s)\n          execute \"ALTER TABLE #{quote_table_name(table_name)} RENAME TO #{quote_table_name(new_name)}\"\n          pk, seq = pk_and_sequence_for(new_name)\n          if pk\n            # PostgreSQL automatically creates an index for PRIMARY KEY with name consisting of\n            # truncated table name and \"_pkey\" suffix fitting into max_identifier_length number of characters.\n            max_pkey_prefix = max_identifier_length - \"_pkey\".size\n            idx = \"#{table_name[0, max_pkey_prefix]}_pkey\"\n            new_idx = \"#{new_name[0, max_pkey_prefix]}_pkey\"\n            execute \"ALTER INDEX #{quote_table_name(idx)} RENAME TO #{quote_table_name(new_idx)}\"\n\n            # PostgreSQL automatically creates a sequence for PRIMARY KEY with name consisting of\n            # truncated table name and \"#{primary_key}_seq\" suffix fitting into max_identifier_length number of characters.\n            max_seq_prefix = max_identifier_length - \"_#{pk}_seq\".size\n            if seq && seq.identifier == \"#{table_name[0, max_seq_prefix]}_#{pk}_seq\"\n              new_seq = \"#{new_name[0, max_seq_prefix]}_#{pk}_seq\"\n              execute \"ALTER TABLE #{seq.quoted} RENAME TO #{quote_table_name(new_seq)}\"\n            end",
        "comment": "Renames a table. Also renames a table's primary key sequence if the sequence name exists and matches the Active Record default.  Example: rename_table('octopuses', 'octopi')",
        "label": "What",
        "id": "13258"
    },
    {
        "raw_code": "def perform(&block)\n          Strategies.for(strategy).new(self).perform(job, &block)\n        end",
        "comment": "This will continue the server middleware chain if the job should be executed. It will return false if the job should not be executed.",
        "label": "What",
        "id": "2763"
    },
    {
        "raw_code": "def merge_request\n          (!!merge_request_iid).to_s\n        end",
        "comment": "Is a merge request execution  @return [String]",
        "label": "What",
        "id": "4636"
    },
    {
        "raw_code": "def template(name, &block)\n        filename, line = caller_locations.first\n        templates[name] = [block, filename, line.to_i]\n      end",
        "comment": "Define a named template. The block must return the template source.",
        "label": "What",
        "id": "8601"
    },
    {
        "raw_code": "def initialize(parse = true)\n        super()\n        @parse = parse\n        @undoc_list = nil\n        @compact = false\n      end",
        "comment": "@param [Boolean] parse whether to parse and load registry (see {#parse})",
        "label": "What",
        "id": "513"
    },
    {
        "raw_code": "def self.string(s)\n          [s.length].pack(\"N\") + s\n        end",
        "comment": "Encodes given string  @param [String] s String to encode @return [String]",
        "label": "What",
        "id": "9176"
    },
    {
        "raw_code": "def reference!(node)\n          reference = Reference.new(node, @scope)\n          @references << reference\n          consumed_branches = nil\n\n          @assignments.reverse_each do |assignment|\n            next if consumed_branches&.include?(assignment.branch)\n\n            assignment.reference!(node) unless assignment.run_exclusively_with?(reference)\n\n            # Modifier if/unless conditions are special. Assignments made in\n            # them do not put the assigned variable in scope to the left of the\n            # if/unless keyword. A preceding assignment is needed to put the\n            # variable in scope. For this reason we skip to the next assignment\n            # here.\n            next if in_modifier_conditional?(assignment)\n\n            break if !assignment.branch || assignment.branch == reference.branch\n\n            unless assignment.branch.may_run_incompletely?\n              (consumed_branches ||= Set.new) << assignment.branch\n            end",
        "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10699"
    },
    {
        "raw_code": "def create_temporary_workdir!\n          # Ensure base directory exists\n          FileUtils.mkdir_p(context.backup_basedir)\n\n          Pathname(Dir.mktmpdir('backup', context.backup_basedir))\n        end",
        "comment": "@return [Pathname] temporary directory",
        "label": "What",
        "id": "1028"
    },
    {
        "raw_code": "def nlbr(str)\n      ActionView::Base.full_sanitizer.sanitize(+str, tags: []).gsub(/\\r?\\n/, '<br>').html_safe\n    end",
        "comment": "Converts newlines into HTML line break elements",
        "label": "What",
        "id": "1213"
    },
    {
        "raw_code": "def on_send(node)\n          return unless node.arguments.size == 1 && node.first_argument.int_type?\n\n          value = node.first_argument.value\n          return unless [0, -1].include?(value)\n\n          node = innermost_braces_node(node)\n          return if node.parent && brace_method?(node.parent)\n\n          preferred = (value.zero? ? 'first' : 'last')\n          offense_range = find_offense_range(node)\n\n          add_offense(offense_range, message: format(MSG, preferred: preferred)) do |corrector|\n            corrector.replace(offense_range, preferred_value(node, preferred))\n          end",
        "comment": "rubocop:disable Metrics/AbcSize",
        "label": "What",
        "id": "10547"
    },
    {
        "raw_code": "def rate_limit(_options = {})\n        return rate_limit! if last_response.nil?\n\n        Octokit::RateLimit.from_response(last_response)\n      end",
        "comment": "Get rate limit info from last response if available or make a new request to fetch rate limit  @see https://developer.github.com/v3/rate_limit/#rate-limit @return [Octokit::RateLimit] Rate limit info",
        "label": "What",
        "id": "15046"
    },
    {
        "raw_code": "def update(plugins, specific, **opts)\n      specific ||= []\n      update = opts.merge({gems: specific.empty? ? true : specific})\n      internal_install(plugins, update)\n    end",
        "comment": "Update updates the given plugins, or every plugin if none is given.  @param [Hash] plugins @param [Array<String>] specific Specific plugin names to update. If empty or nil, all plugins will be updated.",
        "label": "What",
        "id": "8901"
    },
    {
        "raw_code": "def rename_branch(repo, branch, new_name, options = {})\n        params = {\n          new_name: new_name\n        }\n        post \"#{Repository.path repo}/branches/#{branch}/rename\", params.merge(options)\n      end",
        "comment": "Rename a single branch from a repository  Requires authenticated client  @param repo [Integer, String, Hash, Repository] A GitHub repository. @param branch [String] Current branch name @param new_name [String] New branch name @return [Sawyer::Resource] The renamed branch @see https://developer.github.com/v3/repos/#rename-a-branch @example @client.rename_branch('octokit/octokit.rb', 'master', 'main')",
        "label": "What",
        "id": "15164"
    },
    {
        "raw_code": "def safe_downcase!(str)\n      if str.frozen?\n        str.downcase\n      else\n        str.downcase! || str\n      end",
        "comment": "A safe alternative to String#downcase!  This will make copies of frozen strings but downcase unfrozen strings in place, reducing allocations.",
        "label": "What",
        "id": "1216"
    },
    {
        "raw_code": "def up\n    return unless should_run?\n\n    prepare_async_index_removal :project_statistics, COLUMNS, name: INDEX_NAME\n  end",
        "comment": "TODO: Index to be destroyed synchronously in https://gitlab.com/gitlab-org/gitlab/-/issues/466691",
        "label": "What",
        "id": "4883"
    },
    {
        "raw_code": "def extract_milestone\n        node = ast.each_descendant(:send).find do |n|\n          n.method_name == :milestone &&\n            n.arguments.first&.type == :str &&\n            !n.parenthesized?\n        end",
        "comment": "Extracts milestone info Looking for milestone '15.0' / milestone \"14.5\"",
        "label": "What",
        "id": "8162"
    },
    {
        "raw_code": "def check_assignee(repo, assignee, options = {})\n        boolean_from_response :get, \"#{Repository.path repo}/assignees/#{assignee}\", options\n      end",
        "comment": "Check to see if a particular user is an assignee for a repository.  @param repo [Integer, String, Hash, Repository] A GitHub repository. @param assignee [String] User login to check @return [Boolean] True if assignable on project, false otherwise. @see https://developer.github.com/v3/issues/assignees/#check-assignee @example Octokit.check_assignee('octokit/octokit.rb', 'andrew')",
        "label": "What",
        "id": "15166"
    },
    {
        "raw_code": "def _conditional_layout?\n            return unless super\n\n            conditions = _layout_conditions\n\n            if only = conditions[:only]\n              only.include?(action_name)\n            elsif except = conditions[:except]\n              !except.include?(action_name)\n            else\n              true\n            end",
        "comment": "Determines whether the current action has a layout definition by checking the action name against the :only and :except conditions set by the <tt>layout</tt> method.  ==== Returns * <tt>Boolean</tt> - True if the action has a layout definition, false otherwise.",
        "label": "What",
        "id": "11723"
    },
    {
        "raw_code": "def self.adjusted_exit_status(status)\n        return status unless status == RuboCop::CLI::STATUS_OFFENSES\n        return RuboCop::CLI::STATUS_SUCCESS if active_offenses == 0\n\n        status\n      end",
        "comment": "We consider this run a success without any active offenses.",
        "label": "What",
        "id": "3900"
    },
    {
        "raw_code": "def binding\n          super\n        end",
        "comment": "Make Kernel#binding public. rubocop:disable Lint/UselessMethodDefinition",
        "label": "What",
        "id": "10184"
    },
    {
        "raw_code": "def validate_backup_version!\n        gitlab_backup_same_version? ? gitlab_version_matches! : gitlab_version_mismatch!\n      end",
        "comment": "Validate and report whether Backup version is compatible with current GitLab installation",
        "label": "What",
        "id": "3659"
    },
    {
        "raw_code": "def scope_type(node)\n          while (parent = node.parent)\n            case parent.type\n            when :class, :module\n              return :lexical\n            when :def, :defs\n              return :dynamic\n            when :block\n              return :instance_eval if parent.method?(:instance_eval)\n\n              return :dynamic\n            end",
        "comment": "In this expression, will `self` be the same as the innermost enclosing class or module block (:lexical)? Or will it be something else (:dynamic)? If we're in an instance_eval block, return that.",
        "label": "What",
        "id": "10564"
    },
    {
        "raw_code": "def valid_setting_panels\n      VALID_SETTING_PANELS\n    end",
        "comment": "overridden in EE",
        "label": "What",
        "id": "6474"
    },
    {
        "raw_code": "def import(client, project)\n          IMPORTERS.each do |klass|\n            info(project.id, message: \"starting importer\", importer: klass.name)\n            klass.new(project, client).execute\n          end",
        "comment": "client - An instance of Gitlab::GithubImport::Client. project - An instance of Project.",
        "label": "What",
        "id": "6320"
    },
    {
        "raw_code": "def create_or_update_dependabot_secret(repo, name, options)\n        put \"#{Repository.path repo}/dependabot/secrets/#{name}\", options\n      end",
        "comment": "Create or update secrets  @param repo [Integer, String, Hash, Repository] A GitHub repository @param name [String] Name of secret @param options [Hash] encrypted_value and key_id @see https://docs.github.com/en/rest/dependabot/repository-secrets?apiVersion=2022-11-28#create-or-update-a-repository-secret",
        "label": "What",
        "id": "14991"
    },
    {
        "raw_code": "def relative(feature)\n      ::File.join(@config_directory_path, feature)\n    end",
        "comment": "@param [String] @return [String]",
        "label": "What",
        "id": "10116"
    },
    {
        "raw_code": "def set_name(vmname)\n        execute(:set_name, VMID: vm_id, VMName: vmname)\n      end",
        "comment": "Set the name of the VM  @param [String] vmname Name of the VM @return [nil]",
        "label": "What",
        "id": "9686"
    },
    {
        "raw_code": "def self.default\n      @@default ||= Configuration.new\n    end",
        "comment": "The default Configuration object.",
        "label": "What",
        "id": "819"
    },
    {
        "raw_code": "def starred_gists(options = {})\n        paginate 'gists/starred', options\n      end",
        "comment": "List the authenticated user\u2019s starred gists  @return [Array<Sawyer::Resource>] A list of gists @see https://developer.github.com/v3/gists/#list-gists",
        "label": "What",
        "id": "15180"
    },
    {
        "raw_code": "def m(*args) end\n      eof\n    end",
        "comment": "@overload m(a) @return [void] @overload m(b) @param [String] b hi",
        "label": "What",
        "id": "792"
    },
    {
        "raw_code": "def discard_saved_state\n        end",
        "comment": "Discards any saved state associated with this VM.",
        "label": "What",
        "id": "9570"
    },
    {
        "raw_code": "def version_info(version)\n        provider_arches = version.providers.group_by(&:name).map { |provider_name, info|\n          \"#{provider_name} (#{info.map(&:architecture).sort.join(\", \")})\"\n        }.sort.join(\"\\n\")\n        Hash.new.tap do |i|\n          i[\"Box\"] = version.box.tag\n          i[\"Version\"] = version.version\n          i[\"Description\"] = version.description\n          i[\"Status\"] = version.status\n          i[\"Providers\"] = provider_arches\n          i[\"Created\"] = version.created_at\n          i[\"Updated\"] = version.updated_at\n        end",
        "comment": "Extract version information for display  @param [VagrantCloud::Box::Version] version Box version for extracting information @return [Hash<String,String>]",
        "label": "What",
        "id": "9750"
    },
    {
        "raw_code": "def filter_by_search(items, text)\n      items.search(text)\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3786"
    },
    {
        "raw_code": "def handle_access(access_as)\n        access_as_agent if access_as.key?('agent')\n      end",
        "comment": "Override in EE",
        "label": "What",
        "id": "6039"
    },
    {
        "raw_code": "def tag(repo, tag_sha, options = {})\n        get \"#{Repository.path repo}/git/tags/#{tag_sha}\", options\n      end",
        "comment": "Get a tag  @param repo [Integer, String, Hash, Repository] A GitHub repository. @param tag_sha [String] The SHA of the tag to fetch. @return [Sawyer::Resource] Hash representing the tag. @see https://developer.github.com/v3/git/tags/#get-a-tag @example Fetch a tag Octokit.tag('octokit/octokit.rb', '23aad20633f4d2981b1c7209a800db3014774e96')",
        "label": "What",
        "id": "15112"
    },
    {
        "raw_code": "def rename_table(table_name, new_name, **options)\n        validate_table_length!(new_name) unless options[:_uses_legacy_table_name]\n        schema_cache.clear_data_source_cache!(table_name.to_s)\n        schema_cache.clear_data_source_cache!(new_name.to_s)\n        execute \"RENAME TABLE #{quote_table_name(table_name)} TO #{quote_table_name(new_name)}\"\n        rename_table_indexes(table_name, new_name, **options)\n      end",
        "comment": "Renames a table.  Example: rename_table('octopuses', 'octopi')",
        "label": "What",
        "id": "12954"
    },
    {
        "raw_code": "def _InStyleTags\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_StyleOpen)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "InStyleTags = StyleOpen (!StyleClose .)* StyleClose",
        "label": "What",
        "id": "15736"
    },
    {
        "raw_code": "def find_label_ids(label_names)\n      find_label_ids_uncached(label_names)\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7981"
    },
    {
        "raw_code": "def subscriptions(user = login, options = {})\n        paginate user_path(user, 'subscriptions'), options\n      end",
        "comment": "List repositories being watched by a user.  @param user [Integer, String] GitHub user login or id. @return [Array<Sawyer::Resource>] Array of repositories. @see https://developer.github.com/v3/activity/watching/#list-repositories-being-watched @example @client.subscriptions(\"pengwynn\")",
        "label": "What",
        "id": "15487"
    },
    {
        "raw_code": "def update(project, user, changes, refs)\n        {\n          event_name: 'repository_update',\n\n          user_id: user.id,\n          user_name: user.name,\n          user_email: user.email,\n          user_avatar: user.avatar_url,\n\n          project_id: project.id,\n          project: project.hook_attrs,\n\n          changes: changes,\n\n          refs: refs\n        }\n      end",
        "comment": "Produce a hash of post-receive data",
        "label": "What",
        "id": "1786"
    },
    {
        "raw_code": "def opaque(secret_key)\n        OpenSSL::Digest::MD5.hexdigest(secret_key)\n      end",
        "comment": "Opaque based on digest of secret key",
        "label": "What",
        "id": "11279"
    },
    {
        "raw_code": "def ddl_transaction(migration, &block)\n        if use_transaction?(migration)\n          connection.transaction(&block)\n        else\n          yield\n        end",
        "comment": "Wrap the migration in a transaction only if supported by the adapter.",
        "label": "What",
        "id": "12507"
    },
    {
        "raw_code": "def export_jest_metrics\n        export_all_strategies(TEST_TYPES[:frontend]) do |strategy|\n          generate_and_record_metrics(strategy, jest_matching_tests)\n        end",
        "comment": "Export jest test metrics  @return [Boolean]",
        "label": "What",
        "id": "8114"
    },
    {
        "raw_code": "def add_failure_issues_link(example, example_notification)\n          return unless example.execution_result.status == :failed\n\n          search_parameters = {\n            sort: 'updated_desc',\n            scope: 'all',\n            state: 'opened'\n          }.map { |key, value| \"#{key}=#{value}\" }.join('&')\n\n          exception_message = example.exception.message || \"\"\n          message_lines = strip_ansi_codes(example_notification.message_lines) || []\n          exception_message_lines = message_lines.first(20)\n          search_terms = {\n            test_file_path: example.file_path.gsub('./qa/specs/features/', '').to_s,\n            exception_message: exception_message_lines.empty? ? exception_message : exception_message_lines.join(\"\\n\")\n          }.map { |_, value| \"search=#{ERB::Util.url_encode(value)}\" }.join('&')\n\n          search_url = \"https://gitlab.com/#{ISSUE_PROJECT}/-/issues?#{search_parameters}&#{search_terms}\"\n          example.issue('Failure issues', search_url)\n        rescue StandardError => e\n          log(:error, \"Failed to add failure issue link for example '#{example.description}', error: #{e}\")\n        end",
        "comment": "Add failure issues link  @param [RSpec::Core::Example] example @return [void]",
        "label": "What",
        "id": "4598"
    },
    {
        "raw_code": "def collection?\n        false\n      end",
        "comment": "Whether the association represents a single record or a collection of records.",
        "label": "What",
        "id": "12755"
    },
    {
        "raw_code": "def by_active(descendants)\n    return descendants if params[:active].nil?\n\n    params[:active] ? descendants.self_and_ancestors_active : descendants.self_or_ancestors_inactive\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7892"
    },
    {
        "raw_code": "def merge_when_checks_pass(noteable, project, author, sha)\n    ::SystemNotes::MergeRequestsService.new(noteable: noteable, container: project, author: author).merge_when_checks_pass(sha)\n  end",
        "comment": "Called when 'merge when checks pass' is executed",
        "label": "What",
        "id": "5507"
    },
    {
        "raw_code": "def config\n      @config ||= Engine::Configuration.new(self.class.find_root(self.class.called_from))\n    end",
        "comment": "Define the configuration object for the engine.",
        "label": "What",
        "id": "14669"
    },
    {
        "raw_code": "def self.smb_mount_options(env)\n          [\"vers=2.0\"]\n        end",
        "comment": "Required options for mounting a share hosted on Windows NOTE: Windows deprecated smb 1.0 so a minimum of 2.0 must be enabled",
        "label": "What",
        "id": "9730"
    },
    {
        "raw_code": "def initialize(integration, current_user, params)\n        @integration = integration\n\n        super(integration.project, current_user, params)\n      end",
        "comment": "@param integration [AlertManagement::HttpIntegration] @param current_user [User] @param params [Hash]",
        "label": "What",
        "id": "5688"
    },
    {
        "raw_code": "def password\n        ENV.fetch('OCTOKIT_PASSWORD', nil)\n      end",
        "comment": "Default GitHub password for Basic Auth from ENV @return [String]",
        "label": "What",
        "id": "14891"
    },
    {
        "raw_code": "def invalidate\n          @map_match = nil\n          (@invalidation_callbacks || []).each(&:call)\n        end",
        "comment": "Invalidates all separators @return [void]",
        "label": "What",
        "id": "607"
    },
    {
        "raw_code": "def self.system_firmlink?(firmlink)\n          if !@_firmlinks\n            if File.exist?(\"/usr/share/firmlinks\")\n              @_firmlinks = File.readlines(\"/usr/share/firmlinks\").map do |line|\n                line.split.first\n              end",
        "comment": "Check if firmlink is provided by the system  @param [String] firmlink Firmlink path @return [Boolean]",
        "label": "What",
        "id": "9837"
    },
    {
        "raw_code": "def build_day_options(selected)\n          select_options = []\n          (1..31).each do |value|\n            tag_options = { value: value }\n            tag_options[:selected] = \"selected\" if selected == value\n            text = day_name(value)\n            select_options << content_tag(\"option\", text, tag_options)\n          end",
        "comment": "Build select option HTML for day.  build_day_options(2) => \"<option value=\"1\">1</option> <option value=\"2\" selected=\"selected\">2</option> <option value=\"3\">3</option>...\"  If <tt>day_format: ->(day) { day.ordinalize }</tt> option is passed to DateTimeSelector  build_day_options(2) => \"<option value=\"1\">1st</option> <option value=\"2\" selected=\"selected\">2nd</option> <option value=\"3\">3rd</option>...\"  If <tt>use_two_digit_numbers: true</tt> option is passed to DateTimeSelector  build_day_options(2) => \"<option value=\"1\">01</option> <option value=\"2\" selected=\"selected\">02</option> <option value=\"3\">03</option>...\"",
        "label": "What",
        "id": "11848"
    },
    {
        "raw_code": "def self.openapi_types\n      {\n        :'fingerprint' => :'Integer',\n        :'project_id' => :'Integer',\n        :'payload' => :'String',\n        :'name' => :'String',\n        :'description' => :'String',\n        :'actor' => :'String',\n        :'environment' => :'String',\n        :'platform' => :'String'\n      }\n    end",
        "comment": "Attribute type mapping.",
        "label": "What",
        "id": "916"
    },
    {
        "raw_code": "def on_or_asgn(node)\n          allow_self(node.lhs)\n\n          lhs_name = node.lhs.lvasgn_type? ? node.lhs.name : node.lhs\n          add_lhs_to_local_variables_scopes(node.rhs, lhs_name)\n        end",
        "comment": "Assignment of self.x",
        "label": "What",
        "id": "10606"
    },
    {
        "raw_code": "def find(preview)\n        all.find { |p| p.preview_name == preview }\n      end",
        "comment": "Find a mailer preview by its underscored class name.",
        "label": "What",
        "id": "11160"
    },
    {
        "raw_code": "def expires_at\n        @expires_at || (Time.now.utc.to_date + 2)\n      end",
        "comment": "Expire in 2 days just in case the token is created just before midnight",
        "label": "What",
        "id": "4207"
    },
    {
        "raw_code": "def initialize(finder, project = nil, fast_fail: false, store_in_redis_cache: false)\n      @finder = finder\n      @project = project\n      @fast_fail = fast_fail\n      @cache = Gitlab::SafeRequestStore[CACHE_KEY] ||= initialize_cache\n      @store_in_redis_cache = store_in_redis_cache\n    end",
        "comment": "finder - The finder class to use for retrieving the issuables. fast_fail - restrict counting to a shorter period, degrading gracefully on failure",
        "label": "What",
        "id": "1486"
    },
    {
        "raw_code": "def self.after_parse(&block)\n      after_parse_callbacks << block\n    end",
        "comment": "Creates a callback that is called after a docstring is successfully parsed. Use this method to perform sanity checks on a docstring's tag data, or add any extra tags automatically to a docstring.  @yield [parser] a block to be called after a docstring is parsed @yieldparam [DocstringParser] parser the docstring parser object with all directives and tags created. @yieldreturn [void] @return [void]",
        "label": "What",
        "id": "83"
    },
    {
        "raw_code": "def on_or_asgn(node)\n          lhs = node.lhs\n          return unless lhs.ivasgn_type?\n\n          method_node, method_name = find_definition(node)\n          return unless method_node\n\n          body = method_node.body\n          return unless body == node || body.children.last == node\n\n          return if matches?(method_name, lhs)\n\n          suggested_var = suggested_var(method_name)\n          msg = format(\n            message(lhs.name),\n            var: lhs.name,\n            suggested_var: suggested_var,\n            method: method_name\n          )\n          add_offense(lhs, message: msg) do |corrector|\n            corrector.replace(lhs.loc.name, \"@#{suggested_var}\")\n          end",
        "comment": "rubocop:disable Metrics/AbcSize rubocop:disable Metrics/MethodLength",
        "label": "What",
        "id": "10344"
    },
    {
        "raw_code": "def show\n  end",
        "comment": "GET /books/1 GET /books/1.json",
        "label": "What",
        "id": "10745"
    },
    {
        "raw_code": "def get_tkread\n    read = @read.join(\"\")\n    @read = []\n    read\n  end",
        "comment": " Retrieves a String representation of the read tokens",
        "label": "What",
        "id": "16174"
    },
    {
        "raw_code": "def test_user_username\n          ENV[TEST_USER_USERNAME_VARIABLE_NAME]\n        end",
        "comment": "Global test user username  @return [String]",
        "label": "What",
        "id": "4496"
    },
    {
        "raw_code": "def server_error?\n      status.between? 500, 599\n    end",
        "comment": "whether or not the status is set to 5xx",
        "label": "What",
        "id": "8568"
    },
    {
        "raw_code": "def active_access_tokens\n      find_by_testid('active-tokens')\n    end",
        "comment": "Remove when we migrate the legacy UI to use initSharedAccessTokenApp",
        "label": "What",
        "id": "8516"
    },
    {
        "raw_code": "def add_module(mod)\n    @display.print_module mod\n  end",
        "comment": " Records the parsing of a module +mod+",
        "label": "What",
        "id": "15987"
    },
    {
        "raw_code": "def update_files(files)\n          validate_files!(files)\n\n          actions.push(*files.map { |file| file.merge({ action: \"update\" }) })\n        end",
        "comment": "Update files Pass in array of files and it's contents, example: [{ \"file_path\": \"foo/bar\", \"content\": \"some content\" }]  @param [Array<Hash>] files @return [void]",
        "label": "What",
        "id": "4214"
    },
    {
        "raw_code": "def noteable_finder_class\n    case params[:noteable_type]\n    when 'issues'\n      IssuesFinder\n    when 'merge_requests'\n      MergeRequestsFinder\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6604"
    },
    {
        "raw_code": "def start_configuration\n        octokit_warn('The Management Console API will be deprecated in GitHub Enterprise Server 3.15.0, please use the ManageGHES client instead.')\n        post '/setup/api/configure', password_hash\n      end",
        "comment": "Start a configuration process.  @return nil",
        "label": "What",
        "id": "14969"
    },
    {
        "raw_code": "def display_class(name)\n    return if name =~ /#|\\./\n\n    found, klasses, includes, extends =\n      classes_and_includes_and_extends_for name\n\n    return if found.empty?\n\n    out = class_document name, found, klasses, includes, extends\n\n    display out\n  end",
        "comment": " Outputs formatted RI data for class +name+.  Groups undocumented classes",
        "label": "What",
        "id": "16594"
    },
    {
        "raw_code": "def rename_table(table_name, new_name, **options)\n        validate_table_length!(new_name) unless options[:_uses_legacy_table_name]\n        schema_cache.clear_data_source_cache!(table_name.to_s)\n        schema_cache.clear_data_source_cache!(new_name.to_s)\n        exec_query \"ALTER TABLE #{quote_table_name(table_name)} RENAME TO #{quote_table_name(new_name)}\"\n        rename_table_indexes(table_name, new_name, **options)\n      end",
        "comment": "Renames a table.  Example: rename_table('octopuses', 'octopi')",
        "label": "What",
        "id": "12998"
    },
    {
        "raw_code": "def self.reset!\n          instance_variables.each(&method(:remove_instance_variable))\n        end",
        "comment": "@private Reset the cached values for capability. This is not considered a public API and should only be used for testing.",
        "label": "What",
        "id": "9713"
    },
    {
        "raw_code": "def self.handle_cleanup_dvd(machine, defined_dvds, dvd_meta)\n          raise TypeError, \"Expected `Array` but received `#{dvd_meta.class}`\" if !dvd_meta.is_a?(Array)\n          dvd_meta.each do |d|\n            dsk = defined_dvds.select { |dk| dk.name == d[\"name\"] }\n            if !dsk.empty?\n              next\n            else\n              LOGGER.warn(\"Found dvd not in Vagrantfile config: '#{d[\"name\"]}'. Removing dvd from guest #{machine.name}\")\n              machine.ui.warn(\"DVD '#{d[\"name\"]}' no longer exists in Vagrant config. Removing medium from guest...\", prefix: true)\n\n              storage_controllers = machine.provider.driver.read_storage_controllers\n              controller = storage_controllers.get_controller(d[\"controller\"])\n              attachment = controller.get_attachment(uuid: d[\"uuid\"])\n\n              if !attachment\n                LOGGER.warn(\"DVD '#{d[\"name\"]}' not attached to guest, but still exists.\")\n              else\n                machine.provider.driver.remove_disk(controller.name, attachment[:port], attachment[:device])\n              end",
        "comment": "@param [Vagrant::Machine] machine @param [VagrantPlugins::Kernel_V2::VagrantConfigDisk] defined_dvds @param [Array<Hash>] dvd_meta - An array of all the previously defined dvds from the last configure_disk action",
        "label": "What",
        "id": "9623"
    },
    {
        "raw_code": "def self.use(*args, &block)\n    Delegator.target.use(*args, &block)\n  end",
        "comment": "Use the middleware for classic applications.",
        "label": "What",
        "id": "8617"
    },
    {
        "raw_code": "def on(event, &block)\n      raise ArgumentError, \"Symbols only please: #{event}\" unless event.is_a?(Symbol)\n      raise ArgumentError, \"Invalid event name: #{event}\" unless @options[:lifecycle_events].key?(event)\n      @options[:lifecycle_events][event] << block\n    end",
        "comment": "Register a block to run at a point in the Sidekiq lifecycle. :startup, :quiet or :shutdown are valid events.  Sidekiq.configure_server do |config| config.on(:shutdown) do puts \"Goodbye cruel world!\" end end",
        "label": "What",
        "id": "5189"
    },
    {
        "raw_code": "def filtered_groups_with_ancestors(groups)\n    filtered_groups = groups.search(safe_params[:filter]).page(safe_params[:page])\n\n    # We find the ancestors by ID of the search results here.\n    # Otherwise the ancestors would also have filters applied,\n    # which would cause them not to be preloaded.\n    #\n    # Pagination needs to be applied before loading the ancestors to\n    # make sure ancestors are not cut off by pagination.\n    ancestors = Group.where(id: filtered_groups.select(:id)).self_and_ancestors\n    ancestors = ancestors.self_or_ancestors_inactive if inactive?\n    ancestors\n  end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6522"
    },
    {
        "raw_code": "def create_tag(repo, tag, message, object_sha, type, tagger_name, tagger_email, tagger_date, options = {})\n        options.merge!(\n          tag: tag,\n          message: message,\n          object: object_sha,\n          type: type,\n          tagger: {\n            name: tagger_name,\n            email: tagger_email,\n            date: tagger_date\n          }\n        )\n        post \"#{Repository.path repo}/git/tags\", options\n      end",
        "comment": "Create a tag  Requires authenticated client.  @param repo [Integer, String, Hash, Repository] A GitHub repository. @param tag [String] Tag string. @param message [String] Tag message. @param object_sha [String] SHA of the git object this is tagging. @param type [String] Type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`. @param tagger_name [String] Name of the author of the tag. @param tagger_email [String] Email of the author of the tag. @param tagger_date [string] Timestamp of when this object was tagged. @return [Sawyer::Resource] Hash representing new tag. @see https://developer.github.com/v3/git/tags/#create-a-tag-object @example @client.create_tag( \"octokit/octokit.rb\", \"v9000.0.0\", \"Version 9000\\n\", \"f4cdf6eb734f32343ce3f27670c17b35f54fd82e\", \"commit\", \"Wynn Netherland\", \"wynn.netherland@gmail.com\", \"2012-06-03T17:03:11-07:00\" )",
        "label": "What",
        "id": "15113"
    },
    {
        "raw_code": "def copy_indexes(table, old, new)\n        old = old.to_s\n        new = new.to_s\n\n        indexes_for(table, old).each do |index|\n          new_columns = index.columns.map do |column|\n            column == old ? new : column\n          end",
        "comment": "Copies all indexes for the old column to a new column.  table - The table containing the columns and indexes. old - The old column. new - The new column.",
        "label": "What",
        "id": "3002"
    },
    {
        "raw_code": "def print(content, timestamp: false, stderr: false)\n            output = stderr ? $stderr : $stdout\n            output.print(timestamp ? timestamp_format(content) : content)\n          end",
        "comment": "Display provided content in the current line with option to use a timestamp  @param [String] content the content to be displayed @param [Boolean] timestamp when true prepends content with a timestamp format",
        "label": "What",
        "id": "1036"
    },
    {
        "raw_code": "def present_entity(result)\n          representation = entity_representation_for(::API::Entities::BatchedBackgroundMigration, result, {})\n          json_representation = Gitlab::Json.dump(representation)\n\n          body Gitlab::Json::PrecompiledJson.new(json_representation)\n        end",
        "comment": "Force progress evaluation to occur now while we're using the right connection",
        "label": "What",
        "id": "3803"
    },
    {
        "raw_code": "def with\n        super do |conn|\n          next yield conn unless conn.respond_to?(:with_borrowed_connection)\n\n          conn.with_borrowed_connection do\n            yield conn\n          end",
        "comment": "We intercept the returned connection and borrow the connections before yielding the block.",
        "label": "What",
        "id": "1909"
    },
    {
        "raw_code": "def post(data, params: {}, path: '', headers: {})\n          get_crumb\n          RestClient.post(\n            \"#{api_path}#{path}?#{params_to_s(params)}\",\n            data,\n            headers.merge(full_headers)\n          )\n        end",
        "comment": "Posts data to Jenkins This might be useful for filling in gaps in this lib  @param data [String | Hash] the xml to post @param params [Hash] the query parameters as a hash @param path [String] the path to post to ex: /job/<name>/build @param headers [Hash] additional headers to send @return [Typhoeus::Response]",
        "label": "What",
        "id": "4324"
    },
    {
        "raw_code": "def list_messages_with_http_info(project_id, opts = {})\n      if @api_client.config.debugging\n        @api_client.config.logger.debug 'Calling API: MessagesApi.list_messages ...'\n      end",
        "comment": "List of messages @param project_id [Integer] ID of the project where the message was created @param [Hash] opts the optional parameters @option opts [Integer] :limit Number of entries to return (default to 20) @return [Array<(Array<MessageEvent>, Integer, Hash)>] Array<MessageEvent> data, response status code and response headers",
        "label": "What",
        "id": "1009"
    },
    {
        "raw_code": "def delete_subscription(repo, options = {})\n        boolean_from_response :delete, \"#{Repository.path repo}/subscription\", options\n      end",
        "comment": "Delete a repository subscription  @param repo [Integer, String, Hash, Repository] A GitHub repository. @return [Boolean] True if subscription deleted, false otherwise. @see https://developer.github.com/v3/activity/watching/#delete-a-repository-subscription  @example @client.delete_subscription(\"octokit/octokit.rb\")",
        "label": "What",
        "id": "15170"
    },
    {
        "raw_code": "def send_scaled_image(location, width, content_type)\n        params = {\n          'Location' => location,\n          'Width' => width,\n          'ContentType' => content_type\n        }\n\n        [\n          SEND_DATA_HEADER,\n          \"send-scaled-img:#{encode(params)}\"\n        ]\n      end",
        "comment": "rubocop:enable Metrics/ParameterLists",
        "label": "What",
        "id": "1615"
    },
    {
        "raw_code": "def duration\n            @result&.duration || 0.0\n          end",
        "comment": "Return the captured execution duration  @return [Float] execution duration",
        "label": "What",
        "id": "1062"
    },
    {
        "raw_code": "def derived_from_braceless_interpolation?(node)\n          %i[dstr regexp xstr].include?(node.parent&.type)\n        end",
        "comment": "@private @param [RuboCop::AST::Node] node @return [Boolean]",
        "label": "What",
        "id": "10509"
    },
    {
        "raw_code": "def authentication_url(username)\n          append_username @authentication_url, username\n        end",
        "comment": "Build a Crowd authentication URL from +username+.  @param [String] username the username to validate  @return [String] a URL like `https://crowd.myhost.com/crowd/rest/usermanagement/latest/authentication?username=USERNAME`",
        "label": "What",
        "id": "5248"
    },
    {
        "raw_code": "def initialize(*tasks, chdir: Gitlab::Backup::Cli.root)\n            @tasks = tasks\n            @chdir = chdir\n          end",
        "comment": "@param [Array<String>] *tasks a list of tasks to be executed @param [String|Pathname] chdir a path where rake tasks are run from",
        "label": "What",
        "id": "1056"
    },
    {
        "raw_code": "def find_changed_paths(objects, merge_commit_diff_mode: nil, find_renames: false, diff_filters: nil)\n        request = find_changed_paths_request(objects, merge_commit_diff_mode, find_renames, diff_filters)\n\n        return [] if request.nil?\n\n        response = gitaly_client_call(@repository.storage, :diff_service, :find_changed_paths, request, timeout: GitalyClient.medium_timeout)\n        response.flat_map do |msg|\n          msg.paths.map do |path|\n            Gitlab::Git::ChangedPath.new(\n              status: path.status,\n              path: EncodingHelper.encode!(path.path),\n              old_path: EncodingHelper.encode!(path.old_path),\n              old_mode: path.old_mode.to_s(8),\n              new_mode: path.new_mode.to_s(8),\n              old_blob_id: path.old_blob_id,\n              new_blob_id: path.new_blob_id\n            )\n          end",
        "comment": "When finding changed paths and passing a sha for a merge commit we can specify how to diff the commit.  When diffing a merge commit and merge_commit_diff_mode is :all_parents file paths are only returned if changed in both parents (or all parents if diffing an octopus merge)  This means if we create a merge request that includes a merge commit of changes already existing in the target branch, we can omit those changes when looking up the changed paths.  e.g. 1. User branches from master to new branch named feature/foo_bar 2. User changes ./foo_bar.rb and commits change to feature/foo_bar 3. Another user merges a change to ./bar_baz.rb to master 4. User merges master into feature/foo_bar 5. User pushes to GitLab 6. GitLab checks which files have changed  case merge_commit_diff_mode when :all_parents ['foo_bar.rb'] when :include_merges ['foo_bar.rb', 'bar_baz.rb'], else # defaults to :include_merges behavior ['foo_bar.rb', 'bar_baz.rb'], ",
        "label": "What",
        "id": "1797"
    },
    {
        "raw_code": "def activerecord_configuration\n      ActiveRecord::DatabaseConfigurations::HashConfig.new(\n        @activerecord_database_config.env_name,\n        connection_name,\n        activerecord_variables\n      )\n    end",
        "comment": "Return the HashConfig for the database  @return [ActiveRecord::DatabaseConfigurations::HashConfig]",
        "label": "What",
        "id": "3642"
    },
    {
        "raw_code": "def delete_thread_subscription(thread_id, options = {})\n        boolean_from_response :delete, \"notifications/threads/#{thread_id}/subscription\", options\n      end",
        "comment": "Delete a thread subscription  @param thread_id [Integer] Id of the thread. @return [Boolean] True if delete successful, false otherwise. @see https://developer.github.com/v3/activity/notifications/#delete-a-thread-subscription @example @client.delete_thread_subscription(1)",
        "label": "What",
        "id": "15045"
    },
    {
        "raw_code": "def is_dhcp_enabled(nic_index)\n        cmd = <<-EOH\n          if (Get-WmiObject -Class Win32_NetworkAdapterConfiguration -Filter \"Index=#{nic_index} and DHCPEnabled=True\") {\n            exit 0\n          }\n          exit 1\n        EOH\n        @communicator.test(cmd)\n      end",
        "comment": "Checks to see if the specified NIC is currently configured for DHCP.  @return [Boolean]",
        "label": "What",
        "id": "9845"
    },
    {
        "raw_code": "def process(...) # :nodoc:\n      old_config, I18n.config = I18n.config, I18nProxy.new(I18n.config, lookup_context)\n      super\n    ensure\n      I18n.config = old_config\n    end",
        "comment": "Override process to set up I18n proxy.",
        "label": "What",
        "id": "11744"
    },
    {
        "raw_code": "def comparable_release(release)\n          release&.except(:_links)&.merge(\n            {\n              author: release[:author].except(:web_url),\n              commit: release[:commit].except(:web_url),\n              commit_path: release[:commit_path].split(\"/-/\").last,\n              tag_path: release[:tag_path].split(\"/-/\").last,\n              assets: release[:assets].merge({\n                sources: release.dig(:assets, :sources).map do |source|\n                  source.merge({ url: source[:url].split(\"/-/\").last })\n                end",
        "comment": "Update release object to be comparable  Convert objects with project specific attributes like paths and urls to be comparable  @param [Hash] release @return [Hash]",
        "label": "What",
        "id": "4375"
    },
    {
        "raw_code": "def expect_offense(source, file = nil, severity: nil, chomp: false, **replacements)\n        expected_annotations = parse_annotations(source, **replacements)\n        source = expected_annotations.plain_source\n        source = source.chomp if chomp\n\n        @processed_source = parse_processed_source(source, file)\n        @offenses = _investigate(cop, @processed_source)\n        actual_annotations = expected_annotations.with_offense_annotations(@offenses)\n\n        expect(actual_annotations).to eq(expected_annotations), ''\n        expect(@offenses.map(&:severity).uniq).to eq([severity]) if severity\n\n        # Validate that all offenses have a range that formatters can display\n        expect do\n          @offenses.each { |offense| offense.location.source_line }\n        end.not_to raise_error, 'One of the offenses has a misconstructed range, for ' \\\n                                'example if the offense is on line 1 and the source is empty'\n\n        @offenses\n      end",
        "comment": "rubocop:disable Metrics/AbcSize",
        "label": "What",
        "id": "10708"
    },
    {
        "raw_code": "def gfm_autocomplete_search(query)\n      where(\n        \"REPLACE(users.name, ' ', '') ILIKE :pattern OR users.username ILIKE :pattern\",\n        pattern: \"%#{sanitize_sql_like(query)}%\"\n      ).order(\n        Arel.sql(sanitize_sql(\n          [\n            \"CASE WHEN REPLACE(users.name, ' ', '') ILIKE :prefix_pattern OR users.username ILIKE :prefix_pattern THEN 1 ELSE 2 END\",\n            { prefix_pattern: \"#{sanitize_sql_like(query)}%\" }\n          ]\n        )),\n        :username,\n        :id\n      )\n    end",
        "comment": "This should be kept in sync with the frontend filtering in https://gitlab.com/gitlab-org/gitlab/-/blob/5d34e3488faa3982d30d7207773991c1e0b6368a/app/assets/javascripts/gfm_auto_complete.js#L68 and https://gitlab.com/gitlab-org/gitlab/-/blob/5d34e3488faa3982d30d7207773991c1e0b6368a/app/assets/javascripts/gfm_auto_complete.js#L1053",
        "label": "What",
        "id": "7057"
    },
    {
        "raw_code": "def self.parse_json(env_var_name:, value:)\n          # noinspection InvalidCallToProtectedPrivateMethod - See https://handbook.gitlab.com/handbook/tools-and-tips/editors-and-ides/jetbrains-ides/code-inspection/why-are-there-noinspection-comments/\n          Oj.load(value, mode: :rails, symbol_keys: true)\n        rescue EncodingError => e\n          raise \"ENV var '#{env_var_name}' value was not valid parseable JSON. Parse error was: '#{e.message}'\"\n        end",
        "comment": "@param [String] env_var_name @param [String] value @return [Object, Array] @raise [EncodingError]",
        "label": "What",
        "id": "2407"
    },
    {
        "raw_code": "def initialize(jobs_remaining = 0, key = \"#{KEY_PREFIX}:#{SecureRandom.uuid}\")\n      @key = key\n      @jobs_remaining = jobs_remaining\n      @finished = []\n    end",
        "comment": "jobs_remaining - the number of jobs left to wait for key - The key of this waiter.",
        "label": "What",
        "id": "1540"
    },
    {
        "raw_code": "def for_cop(cop)\n      @for_cop[cop]\n    end",
        "comment": "@return [Config] for the given cop / cop name. Note: the 'Enabled' attribute is calculated according to the department's and 'AllCops' configuration; other attributes are not inherited.",
        "label": "What",
        "id": "10169"
    },
    {
        "raw_code": "def initialize(relation_object:, relation_key:, relation_definition:, importable:)\n          @relation_object = relation_object\n          @relation_key = relation_key\n          @relation_definition = relation_definition\n          @importable = importable\n          @invalid_subrelations = []\n          @failed_subrelations = []\n          @exceptions_rescued = 0\n        end",
        "comment": "@param relation_object [Object] Object of a project/group, e.g. an issue @param relation_key [String] Name of the object association to group/project, e.g. :issues @param relation_definition [Hash] Object subrelations as defined in import_export.yml @param importable [Project|Group] Project or group where relation object is getting saved to  @example Gitlab::ImportExport::Base::RelationObjectSaver.new( relation_key: 'merge_requests', relation_object: #<MergeRequest id: root/mrs!1, notes: [#<Note id: nil, note: 'test', ...>, #<Note id: nil, noteL 'another note'>]>, relation_definition: {\"metrics\"=>{}, \"award_emoji\"=>{}, \"notes\"=>{\"author\"=>{}, ... }} importable: @importable ).execute",
        "label": "What",
        "id": "2839"
    },
    {
        "raw_code": "def find_object(name)\n        @search_paths.unshift(@cache[name]) if @cache[name]\n        @search_paths.unshift(Registry.yardoc_file)\n\n        # Try to load it from in memory cache\n        log.debug \"Searching for #{name} in memory\"\n        obj = try_load_object(name, nil)\n        return obj if obj\n\n        log.debug \"Searching for #{name} in search paths\"\n        @search_paths.each do |path|\n          next unless File.exist?(path)\n          log.debug \"Searching for #{name} in #{path}...\"\n          Registry.load(path)\n          obj = try_load_object(name, path)\n          return obj if obj\n        end",
        "comment": "Locates an object by name starting in the cached paths and then searching through any search paths.  @param [String] name the full name of the object @return [CodeObjects::Base] an object if found @return [nil] if no object is found",
        "label": "What",
        "id": "493"
    },
    {
        "raw_code": "def constantize(camel_cased_word)\n      Object.const_get(camel_cased_word)\n    end",
        "comment": "Tries to find a constant with the name specified in the argument string.  constantize('Module')   # => Module constantize('Foo::Bar') # => Foo::Bar  The name is assumed to be the one of a top-level constant, no matter whether it starts with \"::\" or not. No lexical context is taken into account:  C = 'outside' module M C = 'inside' C                # => 'inside' constantize('C') # => 'outside', same as ::C end  NameError is raised when the name is not in CamelCase or the constant is unknown.",
        "label": "What",
        "id": "14474"
    },
    {
        "raw_code": "def set_maintenance_mode(enabled, options = {})\n        conn = authenticated_client\n\n        options[:enabled] = enabled\n        @last_response = conn.post('/manage/v1/maintenance', options)\n      end",
        "comment": "Configure the maintenance mode of the GHES instance  @param maintenance [Hash] A hash configuration of the maintenance mode status @return [nil]",
        "label": "What",
        "id": "14924"
    },
    {
        "raw_code": "def convert_encoding(content)\n        return content unless content.respond_to?(:force_encoding)\n        if content =~ ENCODING_LINE\n          content.force_encoding($1)\n        else\n          content.force_encoding('binary')\n          ENCODING_BYTE_ORDER_MARKS.each do |encoding, bom|\n            bom.force_encoding('binary')\n            if content.start_with?(bom)\n              return content.sub(bom, '').force_encoding(encoding)\n            end",
        "comment": "Searches for encoding line and forces encoding @since 0.5.3",
        "label": "What",
        "id": "295"
    },
    {
        "raw_code": "def destroy(force = false)\n      if (!force && file =~ /\\.yardoc$/) || force\n        if File.file?(@file)\n          # Handle silent upgrade of old .yardoc format\n          File.unlink(@file)\n        elsif File.directory?(@file)\n          FileUtils.rm_rf(@file)\n        end",
        "comment": "Deletes the .yardoc database on disk  @param [Boolean] force if force is not set to true, the file/directory will only be removed if it ends with .yardoc. This helps with cases where the directory might have been named incorrectly. @return [Boolean] true if the .yardoc database was deleted, false otherwise.",
        "label": "What",
        "id": "102"
    },
    {
        "raw_code": "def returned_timeout_value\n        Banzai::PipelineBase.parse(COMPLEX_MARKDOWN_MESSAGE)\n      end",
        "comment": "If sanitization times out, we can not return partial un-sanitized results. It's ok to allow any following filters to run since this is safe HTML.",
        "label": "What",
        "id": "3469"
    },
    {
        "raw_code": "def truncate(offset)\n          raise ArgumentError, 'Outside of file' if offset > size || offset < 0\n          return if offset == size # Skip the following process as it doesn't affect anything\n\n          @tell = offset\n          @size = offset\n\n          # remove all next chunks\n          trace_chunks.where('chunk_index > ?', chunk_index).fast_destroy_all\n\n          # truncate current chunk\n          current_chunk.truncate(chunk_offset)\n        ensure\n          invalidate_chunk_cache\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2524"
    },
    {
        "raw_code": "def prepend_current_user?\n      filter_by_current_user.present? && current_user\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7989"
    },
    {
        "raw_code": "def user\n    @user ||= User.find_by!(username: params[:user_id])\n  end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6462"
    },
    {
        "raw_code": "def async_execute\n        return ServiceResponse.error(message: csv_validator.formatted_errors) unless csv_validator.valid?\n\n        Import::UserMapping::AssignmentFromCsvWorker.perform_async(\n          current_user.id,\n          namespace.id,\n          upload.id\n        )\n\n        ServiceResponse.success\n      end",
        "comment": "@return [ServiceResponse]",
        "label": "What",
        "id": "6102"
    },
    {
        "raw_code": "def new_note(note)\n    return true unless note.noteable_type.present?\n\n    # ignore gitlab service messages\n    return true if note.system_note_with_references?\n\n    send_new_note_notifications(note)\n    send_service_desk_notification(note)\n  end",
        "comment": "Notify users on new note in system",
        "label": "What",
        "id": "5478"
    },
    {
        "raw_code": "def preview(**options)\n      raise NotImplementedError\n    end",
        "comment": "Override this method in a concrete subclass. Have it yield an attachable preview image (i.e. anything accepted by ActiveStorage::Attached::One#attach). Pass the additional options to the underlying blob that is created.",
        "label": "What",
        "id": "13663"
    },
    {
        "raw_code": "def close(reason: nil, reconnect: true)\n        transmit(\n          type: ActionCable::INTERNAL[:message_types][:disconnect],\n          reason: reason,\n          reconnect: reconnect\n        )\n        websocket.close\n      end",
        "comment": "Close the WebSocket connection.",
        "label": "What",
        "id": "11070"
    },
    {
        "raw_code": "def _HtmlBlockCloseTfoot\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseTfoot = \"<\" Spnl \"/\" (\"tfoot\" | \"TFOOT\") Spnl \">\"",
        "label": "What",
        "id": "15711"
    },
    {
        "raw_code": "def web_endpoint\n        ENV.fetch('OCTOKIT_WEB_ENDPOINT') { WEB_ENDPOINT }\n      end",
        "comment": "Default web endpoint from ENV or {WEB_ENDPOINT} @return [String]",
        "label": "What",
        "id": "14896"
    },
    {
        "raw_code": "def parse_entries\n      entries = []\n\n      @content.scan(/^commit\\s+(\\h{20})\\h*\\n((?:.+\\n)*)\\n((?: {4}.*\\n+)*)/) do\n        entry_name, header, entry_body = $1, $2, $3.gsub(/^ {4}/, '')\n        # header = header.scan(/^ *(\\S+?): +(.*)/).to_h\n        # date = header[\"CommitDate\"] || header[\"Date\"]\n        date = header[/^ *(?:Author)?Date: +(.*)/, 1]\n        author = header[/^ *Author: +(.*)/, 1]\n        begin\n          time = parse_date(header[/^ *CommitDate: +(.*)/, 1] || date)\n          @time_cache[entry_name] = time\n          author.sub!(/\\s*<(.*)>/, '')\n          email = $1\n          entries << [entry_name, [author, email, date, entry_body]]\n        rescue ArgumentError\n        end",
        "comment": " Parses the entries in the Git commit logs",
        "label": "What",
        "id": "16058"
    },
    {
        "raw_code": "def pages_builds(repo, options = {})\n        get \"#{Repository.path repo}/pages/builds\", options\n      end",
        "comment": "List Pages builds for a repository  @param repo [Integer, String, Repository, Hash] A GitHub repository @return [Array<Sawyer::Resource>] A list of build history for a repository. @see https://developer.github.com/v3/repos/pages/#list-pages-builds",
        "label": "What",
        "id": "15359"
    },
    {
        "raw_code": "def find_already_added_projects(import_type)\n    current_user.created_projects.inc_routes.where(import_type: import_type).with_import_state\n  end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6673"
    },
    {
        "raw_code": "def json_response\n    Gitlab::Json.parse(response.body)\n  end",
        "comment": "This should _not_ be a let block, otherwise it is memoized, and breaks the contract of #response, which is to always return the response of the last request. Request specs may do multiple requests in a single example, and making this a let would cause stale responses to be returned.",
        "label": "What",
        "id": "8327"
    },
    {
        "raw_code": "def heredoc?(argument)\n          argument.respond_to?(:heredoc?) && argument.heredoc?\n        end",
        "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10481"
    },
    {
        "raw_code": "def process_toc_tag(node)\n        build_toc\n\n        # Replace the entire paragraph containing the TOC tag\n        node.parent.replace(result[:toc].presence || '')\n      end",
        "comment": "Replace an entire `[TOC]` node",
        "label": "What",
        "id": "3467"
    },
    {
        "raw_code": "def initialize(card: {}, card_options: {}, header_options: {}, body_options: {}, footer_options: {})\n      @card_options = card_options\n      @header_options = header_options\n      @body_options = body_options\n      @footer_options = footer_options\n      @card = card\n    end",
        "comment": "@param [Hash] card_options @param [Hash] header_options @param [Hash] body_options @param [Hash] footer_options @card [Hash] card structure as an object. This enables .with_collection functionality.",
        "label": "What",
        "id": "5399"
    },
    {
        "raw_code": "def text\n    @parts.join\n  end",
        "comment": " The text of the section",
        "label": "What",
        "id": "16243"
    },
    {
        "raw_code": "def column_exists?(column_name, type = nil, **options)\n        @base.column_exists?(name, column_name, type, **options)\n      end",
        "comment": "Checks to see if a column exists.  t.string(:name) unless t.column_exists?(:name, :string)  See {connection.column_exists?}[rdoc-ref:SchemaStatements#column_exists?]",
        "label": "What",
        "id": "13105"
    },
    {
        "raw_code": "def _Spnl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _Sp()\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Spnl = @Sp (@Newline @Sp)?",
        "label": "What",
        "id": "15800"
    },
    {
        "raw_code": "def increment_intermediate_lists\n        board.lists.movable.where('position >= ?', new_position)\n                           .where('position < ?',  old_position)\n                           .update_all('position = position + 1')\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5658"
    },
    {
        "raw_code": "def messages_for(attribute)\n      where(attribute).map(&:message)\n    end",
        "comment": "Returns all the error messages for a given attribute in an array.  class Person validates_presence_of :name, :email validates_length_of :name, in: 5..30 end  person = Person.create() person.errors.messages_for(:name) # => [\"is too short (minimum is 5 characters)\", \"can't be blank\"]",
        "label": "What",
        "id": "12237"
    },
    {
        "raw_code": "def clean_test_path\n    Dir[File.join(TMP_TEST_PATH, '**')].each do |entry|\n      unless test_dirs.include?(File.basename(entry))\n        FileUtils.rm_rf(entry)\n      end",
        "comment": "Clean /tmp/tests  Keeps gitlab-shell and gitlab-test",
        "label": "What",
        "id": "8470"
    },
    {
        "raw_code": "def gfm_autocomplete_search(query)\n      namespaces_cte = Gitlab::SQL::CTE.new(table_name, without_order)\n\n      # This scope does not work with `ProjectNamespace` records because they don't have a corresponding `route` association.\n      # We do not chain the `without_project_namespaces` scope because it results in an expensive query plan in certain cases\n      unscoped\n        .with(namespaces_cte.to_arel)\n        .from(namespaces_cte.table)\n        .joins(:route)\n        .where(\n          \"REPLACE(routes.name, ' ', '') ILIKE :pattern OR routes.path ILIKE :pattern\",\n          pattern: \"%#{sanitize_sql_like(query)}%\"\n        )\n        .order(\n          Arel.sql(sanitize_sql(\n            [\n              \"CASE WHEN REPLACE(routes.name, ' ', '') ILIKE :prefix_pattern OR routes.path ILIKE :prefix_pattern THEN 1 ELSE 2 END\",\n              { prefix_pattern: \"#{sanitize_sql_like(query)}%\" }\n            ]\n          )),\n          'routes.path'\n        )\n    end",
        "comment": "This should be kept in sync with the frontend filtering in https://gitlab.com/gitlab-org/gitlab/-/blob/5d34e3488faa3982d30d7207773991c1e0b6368a/app/assets/javascripts/gfm_auto_complete.js#L68 and https://gitlab.com/gitlab-org/gitlab/-/blob/5d34e3488faa3982d30d7207773991c1e0b6368a/app/assets/javascripts/gfm_auto_complete.js#L1053",
        "label": "What",
        "id": "6687"
    },
    {
        "raw_code": "def metadata\n        box     = env.vagrantfile.config.vm.box\n        box_url = env.vagrantfile.config.vm.box_url\n\n        result = {}\n\n        if !box.nil? && !box.empty?\n          result[\"box\"] = box\n        end",
        "comment": "The metadata command for this push.  @return [Array<String>]",
        "label": "What",
        "id": "9366"
    },
    {
        "raw_code": "def cache_method_asymmetrically(name)\n        uncached_name = alias_uncached_method(name)\n\n        define_method(name) do\n          cache_method_output_asymmetrically(name) do\n            __send__(uncached_name) # rubocop:disable GitlabSecurity/PublicSend\n          end",
        "comment": "Caches truthy values from the method. All values are strongly memoized, and cached in RequestStore.  Currently only used to cache `exists?` since stale false values are particularly troublesome. This can occur, for example, when an NFS mount is temporarily down.  This only works for methods that do not take any arguments.  name - The name of the method to be cached.",
        "label": "What",
        "id": "1701"
    },
    {
        "raw_code": "def tty?\n          spinner.send(:tty?) && !nested_spinner? # rubocop:disable GitlabSecurity/PublicSend -- method is public on master branch but not released yet\n        end",
        "comment": "Check tty and nested spinner Nested spinners override $stdout which won't be tty so we need to return false  @return [Boolean]",
        "label": "What",
        "id": "4062"
    },
    {
        "raw_code": "def auth_user\n    if user_signed_in?\n      current_user\n    else\n      try(:authenticated_user)\n    end",
        "comment": " Controllers such as GitHttpController may use alternative methods (e.g. tokens) to authenticate the user, whereas Devise sets current_user. ",
        "label": "What",
        "id": "6399"
    },
    {
        "raw_code": "def self.available?\n        !executable.nil?\n      end",
        "comment": "@return [Boolean] powershell executable available on PATH",
        "label": "What",
        "id": "9270"
    },
    {
        "raw_code": "def split_on_separators_match\n      @@split_on_separators_match ||= /(.+?)(#{separators_match}|$)/\n    end",
        "comment": "@return [Regexp] the regexp that can be used to split a string on all occurrences of separator tokens",
        "label": "What",
        "id": "123"
    },
    {
        "raw_code": "def all_jobs\n          # We fetch all relevant data in one go.\n          #\n          # This is more efficient than relying on PostgreSQL to calculate composite status for us\n          #\n          # Since we need to reprocess everything we can fetch all of them and do processing ourselves.\n          strong_memoize(:all_jobs) do\n            raw_jobs = pipeline\n              .current_jobs\n              .ordered_by_stage\n              .pluck(*JOB_ATTRS)\n\n            raw_jobs.map do |row|\n              JOB_ATTRS.zip(row).to_h\n            end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5830"
    },
    {
        "raw_code": "def http_url\n    @relative_name.tr('.', '_') + '.html'\n  end",
        "comment": " URL for this with a +prefix+",
        "label": "What",
        "id": "16726"
    },
    {
        "raw_code": "def parse_comment(container, tk, comment)\n    return parse_comment_tomdoc container, tk, comment if @markup == 'tomdoc'\n    column  = tk[:char_no]\n    line_no = comment.line.nil? ? tk[:line_no] : comment.line\n\n    comment.text = comment.text.sub(/(^# +:?)(singleton-)(method:)/, '\\1\\3')\n    singleton = !!$~\n\n    co =\n      if (comment.text = comment.text.sub(/^# +:?method: *(\\S*).*?\\n/i, '')) && !!$~ then\n        line_no += $`.count(\"\\n\")\n        parse_comment_ghost container, comment.text, $1, column, line_no, comment\n      elsif (comment.text = comment.text.sub(/# +:?(attr(_reader|_writer|_accessor)?): *(\\S*).*?\\n/i, '')) && !!$~ then\n        parse_comment_attr container, $1, $3, comment\n      end",
        "comment": " Generates an RDoc::Method or RDoc::Attr from +comment+ by looking for :method: or :attr: directives in +comment+.",
        "label": "What",
        "id": "16090"
    },
    {
        "raw_code": "def resolve\n      if rubygems_org_admin?\n        scope.all\n      else\n        scope.none\n      end",
        "comment": "NOTE: Be explicit about which records you allow access to!",
        "label": "What",
        "id": "10004"
    },
    {
        "raw_code": "def self.use_encoder(encoder)\n        previous_encoder = json_encoder\n        self.json_encoder = encoder\n\n        result = yield\n\n        self.json_encoder = previous_encoder\n\n        result\n      end",
        "comment": "This method is used only to test that our encoder maintains compatibility with the default ActiveSupport encoder. See spec/lib/gitlab/json_spec.rb",
        "label": "What",
        "id": "1287"
    },
    {
        "raw_code": "def demote(user, options = {})\n        boolean_from_response :delete, \"users/#{user}/site_admin\", options\n      end",
        "comment": "Demote a site administrator to an ordinary user  @param user [String] Username of the user to demote. @return [Boolean] True if demote was successful, false otherwise. @see https://developer.github.com/enterprise/v3/enterprise-admin/users/#demote-a-site-administrator-to-an-ordinary-user @example @admin_client.demote('holman')",
        "label": "What",
        "id": "14959"
    },
    {
        "raw_code": "def ordinalize(number)\n      I18n.translate(\"number.nth.ordinalized\", number: number)\n    end",
        "comment": "Turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.  ordinalize(1)     # => \"1st\" ordinalize(2)     # => \"2nd\" ordinalize(1002)  # => \"1002nd\" ordinalize(1003)  # => \"1003rd\" ordinalize(-11)   # => \"-11th\" ordinalize(-1021) # => \"-1021st\"",
        "label": "What",
        "id": "14477"
    },
    {
        "raw_code": "def logs_section_prefix_regex\n      /section_((?:start)|(?:end)):(\\d+):([a-zA-Z0-9_.-]+)/\n    end",
        "comment": "The section start, e.g. section_start:12345678:NAME",
        "label": "What",
        "id": "1396"
    },
    {
        "raw_code": "def specs_in_path(path, scenario_specs)\n          scenario_specs.select { |spec| spec.match?(%r{#{Specs::Runner::ABSOLUTE_PATH_PREFIX_PATTERN}#{path}}) }\n        end",
        "comment": "List of specs within a path  @param path [String] @param scenario_specs [Array] @return [Array]",
        "label": "What",
        "id": "4819"
    },
    {
        "raw_code": "def debug_mode?\n      @debug_mode || Fiber[:event_reporter_debug_mode]\n    end",
        "comment": "Check if debug mode is currently enabled. Debug mode is enabled on the reporter via +with_debug+, and in local environments.",
        "label": "What",
        "id": "13854"
    },
    {
        "raw_code": "def by_milestone(items)\n    return items unless params.milestones?\n\n    if params.filter_by_no_milestone?\n      items.left_joins_milestones.where(milestone_id: [-1, nil])\n    elsif params.filter_by_any_milestone?\n      items.any_milestone\n    elsif params.filter_by_upcoming_milestone?\n      upcoming_ids = Milestone.upcoming_ids(accessible_projects, params.related_groups,\n        legacy_filtering_logic: use_legacy_milestone_filtering?)\n      items.left_joins_milestones.where(milestone_id: upcoming_ids)\n    elsif params.filter_by_started_milestone?\n      items.left_joins_milestones\n           .merge(Milestone.started(legacy_filtering_logic: use_legacy_milestone_filtering?))\n    else\n      items.with_milestone(params[:milestone_title])\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7917"
    },
    {
        "raw_code": "def search_context\n        builder = Builder.new(view_context)\n\n        builder.with_snippet(@snippet) if @snippet.present?\n        @snippets.each(&builder.method(:with_snippet)) if @snippets.present?\n        builder.with_project(@project) if @project.present? && @project.persisted?\n        builder.with_group(@group) if @group.present? && @group.persisted?\n        builder.with_ref(@ref) if @ref.present?\n\n        builder.build!\n      end",
        "comment": "rubocop:disable Gitlab/ModuleWithInstanceVariables  Introspect the current controller's assignments and and builds the proper SearchContext object for it.",
        "label": "What",
        "id": "1570"
    },
    {
        "raw_code": "def test_a_marked_for_destruction_record_should_not_be_be_marked_after_reload\n    @pirate.mark_for_destruction\n    @pirate.ship.mark_for_destruction\n\n    assert_not_predicate @pirate.reload, :marked_for_destruction?\n    assert_not_predicate @pirate.ship.reload, :marked_for_destruction?\n  end",
        "comment": "reload",
        "label": "What",
        "id": "13497"
    },
    {
        "raw_code": "def counter(idx, total)\n        \"(#{idx + 1}/#{total})\" if total > 1\n      end",
        "comment": "Formats a counter if there's anything to count  @return [String, nil] ex) \"(3/4)\"\"",
        "label": "What",
        "id": "5353"
    },
    {
        "raw_code": "def try_obtain\n      report_lock_attempt_inside_transaction unless self.class.skip_transaction_check?\n\n      # Performing a single SET is atomic\n      Gitlab::Redis::SharedState.with do |redis|\n        redis.set(@redis_shared_state_key, @uuid, nx: true, ex: @timeout) && @uuid\n      end",
        "comment": "Try to obtain the lease. Return lease UUID on success, false if the lease is already taken.",
        "label": "What",
        "id": "1759"
    },
    {
        "raw_code": "def self.derive_join_table_name(first_table, second_table) # :nodoc:\n      [first_table.to_s, second_table.to_s].sort.join(\"\\0\").gsub(/^(.*[_.])(.+)\\0\\1(.+)/, '\\1\\2_\\3').tr(\"\\0\", \"_\")\n    end",
        "comment": "Derives the join table name for +first_table+ and +second_table+. The table names appear in alphabetical order. A common prefix is removed (useful for namespaced models like Music::Artist and Music::Record):  artists, records => artists_records records, artists => artists_records music_artists, music_records => music_artists_records music.artists, music.records => music.artists_records",
        "label": "What",
        "id": "12508"
    },
    {
        "raw_code": "def management_console_password=(value)\n      reset_agent\n      @management_console_password = value\n    end",
        "comment": "Set Enterprise Management Console password  @param value [String] Management console admin password",
        "label": "What",
        "id": "14837"
    },
    {
        "raw_code": "def represent_status(resource)\n    return {} unless resource.present?\n\n    data = represent(resource, { only: [{ details: [:status] }] })\n    data.dig(:details, :status) || {}\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6240"
    },
    {
        "raw_code": "def warn!\n      dispatch(:warn!)\n    end",
        "comment": "Sets the log level to +Logger::WARN+ for the whole broadcast.",
        "label": "What",
        "id": "13724"
    },
    {
        "raw_code": "def me; \"VALUE\" end\n            end",
        "comment": "Docstring",
        "label": "What",
        "id": "776"
    },
    {
        "raw_code": "def code_paths_mapping_file(prefix, bucket = DEFAULT_BUCKET)\n          paginated_list(client.list_objects(bucket, prefix: prefix)).last&.name\n        end",
        "comment": "Code paths mapping file from GCS  Get most up to date mapping file based on pipeline type @return [String]",
        "label": "What",
        "id": "4824"
    },
    {
        "raw_code": "def _make_regex(str) /([#{Regexp.escape(str)}])/n end\n    def _make_regex!(str) /([^#{Regexp.escape(str)}])/n end\n    def _escape(str, regex)\n      str = str.b\n      str.gsub!(regex) {\"%%%02X\" % $1.ord}\n      # %-escaped string should contain US-ASCII only\n      str.force_encoding(Encoding::US_ASCII)\n    end\n    def _unescape(str, regex)\n      str = str.b\n      str.gsub!(regex) {$1.hex.chr}\n      # encoding of %-unescaped string is unknown\n      str\n    end\n\n    UNESCAPED = _make_regex(control+space+delims+unwise+nonascii)\n    UNESCAPED_FORM = _make_regex(reserved+control+delims+unwise+nonascii)\n    NONASCII  = _make_regex(nonascii)\n    ESCAPED   = /%([0-9a-fA-F]{2})/\n    UNESCAPED_PCHAR = _make_regex!(unreserved+\":@&=+$,\")\n\n    # :startdoc:\n\n    ##\n    # Escapes HTTP reserved and unwise characters in +str+\n\n    def escape(str)\n      _escape(str, UNESCAPED)\n    end\n\n    ##\n    # Unescapes HTTP reserved and unwise characters in +str+\n\n    def unescape(str)\n      _unescape(str, ESCAPED)\n    end\n\n    ##\n    # Escapes form reserved characters in +str+\n\n    def escape_form(str)\n      ret = _escape(str, UNESCAPED_FORM)\n      ret.gsub!(/ /, \"+\")\n      ret\n    end\n\n    ##\n    # Unescapes form reserved characters in +str+\n\n    def unescape_form(str)\n      _unescape(str.gsub(/\\+/, \" \"), ESCAPED)\n    end\n\n    ##\n    # Escapes path +str+\n\n    def escape_path(str)\n      result = \"\"\n      str.scan(%r{/([^/]*)}).each{|i|\n        result << \"/\" << _escape(i[0], UNESCAPED_PCHAR)\n      }\n      return result\n    end\n\n    ##\n    # Escapes 8 bit characters in +str+\n\n    def escape8bit(str)\n      _escape(str, NONASCII)\n    end\n  end\nend",
        "comment": ":stopdoc:",
        "label": "What",
        "id": "680"
    },
    {
        "raw_code": "def down\n    add_concurrent_foreign_key TABLE_NAME, :prometheus_alert_events,\n      column: :prometheus_alert_event_id,\n      name: EVENTS_FK_NAME\n\n    add_concurrent_foreign_key TABLE_NAME, :issues,\n      column: :issue_id,\n      name: ISSUES_FK_NAME\n  end",
        "comment": "Original SQL:  ALTER TABLE ONLY issues_prometheus_alert_events ADD CONSTRAINT fk_rails_b32edb790f FOREIGN KEY (prometheus_alert_event_id) REFERENCES prometheus_alert_events(id) ON DELETE CASCADE;  ALTER TABLE ONLY issues_prometheus_alert_events ADD CONSTRAINT fk_rails_db5b756534 FOREIGN KEY (issue_id) REFERENCES issues(id) ON DELETE CASCADE; ",
        "label": "What",
        "id": "4855"
    },
    {
        "raw_code": "def self.create(password=nil, type: :rsa)\n        if !VALID_TYPES.key?(type)\n          raise ArgumentError,\n                \"Invalid key type requested (supported types: #{available_types.map(&:inspect).join(\", \")})\"\n        end",
        "comment": "Create a new keypair  @param [String] password Password for the key or nil for no password (only supported for rsa type) @param [Symbol] type Key type to generate @return [Array<String, String, String>] Public key, openssh private key, openssh public key with comment",
        "label": "What",
        "id": "9171"
    },
    {
        "raw_code": "def disable_query_cache(dirties: true)\n          cache = query_cache\n          old_enabled, cache.enabled, old_dirties, cache.dirties = cache.enabled, false, cache.dirties, dirties\n          begin\n            yield\n          ensure\n            cache.enabled, cache.dirties = old_enabled, old_dirties\n          end",
        "comment": "Disable the query cache within the block.",
        "label": "What",
        "id": "13080"
    },
    {
        "raw_code": "def self.exclude_to_regexp(exclude)\n        start_anchor = false\n\n        if exclude.start_with?(\"/\")\n          start_anchor = true\n        end",
        "comment": "This converts an rsync exclude pattern to a regular expression we can send to Listen.  Note: Listen expects a path relative to the parameter passed into the Listener, not a fully qualified path  @param [String]  - exclude path @return [Regexp] - A regex of the path, modified, to exclude",
        "label": "What",
        "id": "9415"
    },
    {
        "raw_code": "def preferred_expression_to_node_with_constant_prefix(node)\n          expression = preferred_expression_to(node)\n          return unless expression\n\n          \"#{constant_prefix(node)}#{expression}\"\n        end",
        "comment": "@private @param [RuboCop::AST::Node] node @return [String, nil]",
        "label": "What",
        "id": "10513"
    },
    {
        "raw_code": "def following(user = login, options = {})\n        paginate \"#{User.path user}/following\", options\n      end",
        "comment": "Get list of users a user is following.  @param user [Intger, String] GitHub user login or id of the user who you are getting the list of the people they follow. @return [Array<Sawyer::Resource>] Array of hashes representing users a user is following. @see https://developer.github.com/v3/users/followers/#list-users-followed-by-another-user @example Octokit.following('pengwynn')",
        "label": "What",
        "id": "15472"
    },
    {
        "raw_code": "def queue_adapter\n      ActiveJob::Base.queue_adapter\n    end",
        "comment": "Accesses the queue_adapter set by ActiveJob::Base.  def test_assert_job_has_custom_queue_adapter_set assert_instance_of CustomQueueAdapter, HelloJob.queue_adapter end",
        "label": "What",
        "id": "12147"
    },
    {
        "raw_code": "def _EscapedChar\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"\\\\\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "EscapedChar = \"\\\\\" !@Newline < /[:\\\\`|*_{}\\[\\]()#+.!><-]/ > { text }",
        "label": "What",
        "id": "15743"
    },
    {
        "raw_code": "def _Entity\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_HexEntity)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_DecEntity)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_CharEntity)\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Entity = (HexEntity | DecEntity | CharEntity):a { a }",
        "label": "What",
        "id": "15744"
    },
    {
        "raw_code": "def compile_forwarded_ports(config)\n          mappings = {}\n\n          config.vm.networks.each do |type, options|\n            if type == :forwarded_port\n              guest_port = options[:guest]\n              host_port  = options[:host]\n              host_ip    = options[:host_ip]\n              protocol   = options[:protocol] || \"tcp\"\n              options    = scoped_hash_override(options, :virtualbox)\n              id         = options[:id]\n\n              # If the forwarded port was marked as disabled, ignore.\n              next if options[:disabled]\n\n              key = \"#{host_ip}#{protocol}#{host_port}\"\n              mappings[key] =\n                Model::ForwardedPort.new(id, host_port, guest_port, options)\n            end",
        "comment": "This method compiles the forwarded ports into {ForwardedPort} models.",
        "label": "What",
        "id": "9634"
    },
    {
        "raw_code": "def attachment(filename = nil, disposition = :attachment)\n      response['Content-Disposition'] = disposition.to_s.dup\n      return unless filename\n\n      params = format('; filename=\"%s\"', File.basename(filename).gsub(/[\"\\r\\n]/, MULTIPART_FORM_DATA_REPLACEMENT_TABLE))\n      response['Content-Disposition'] << params\n      ext = File.extname(filename)\n      content_type(ext) unless response['content-type'] || ext.empty?\n    end",
        "comment": "Set the Content-Disposition to \"attachment\" with the specified filename, instructing the user agents to prompt to save.",
        "label": "What",
        "id": "8556"
    },
    {
        "raw_code": "def project_for_path(path_info)\n        project_path_match = \"#{path_info}/\".match(PROJECT_PATH_REGEX)\n        return unless project_path_match\n\n        path = project_path_match[1]\n\n        # A go package path may use a subdirectory. For example a valid package path\n        # is `example.com/namespace/group/group/project/path1/path2/path3`.\n        # So we need to find all potential gitlab project paths from the package path.\n        # For more details on package paths see https://go.dev/ref/mod.\n\n        # Apply maximum upper limit to number of segments (group + 20 subgroups + project = 22 elements)\n        path_segments = path.split('/').take(22) # rubocop: disable CodeReuse/ActiveRecord -- not an active record operation\n\n        project_paths = []\n        begin\n          project_paths << path_segments.join('/')\n          path_segments.pop\n        end while path_segments.length >= 2\n\n        project = Project.where_full_path_in(project_paths).first\n        return project if project\n\n        # It's possible that the project was transferred and has a redirect\n        redirect = RedirectRoute.for_source_type(Project).by_paths(project_paths).first\n        return redirect.source if redirect\n\n        nil\n      end",
        "comment": "project_for_path searches for a project based on the path_info",
        "label": "What",
        "id": "2039"
    },
    {
        "raw_code": "def find_session(env, sid)\n        unless sid && (session = get_session_with_fallback(sid))\n          sid, session = generate_sid, {}\n        end",
        "comment": "Get a session from the cache.",
        "label": "What",
        "id": "11542"
    },
    {
        "raw_code": "def exchange_code_for_token(code, app_id = client_id, app_secret = client_secret, options = {})\n        options = options.merge({\n                                  code: code,\n                                  client_id: app_id,\n                                  client_secret: app_secret,\n                                  headers: {\n                                    content_type: 'application/json',\n                                    accept: 'application/json'\n                                  }\n                                })\n\n        post \"#{web_endpoint}login/oauth/access_token\", options\n      end",
        "comment": "Retrieve the access_token.  @param code [String] Authorization code generated by GitHub. @param app_id [String] Client Id we received when our application was registered with GitHub. Defaults to client_id. @param app_secret [String] Client Secret we received when our application was registered with GitHub. Defaults to client_secret. @return [Sawyer::Resource] Hash holding the access token. @see https://developer.github.com/v3/oauth/#web-application-flow @example Octokit.exchange_code_for_token('aaaa', 'xxxx', 'yyyy', {:accept => 'application/json'})",
        "label": "What",
        "id": "15467"
    },
    {
        "raw_code": "def create_commit(repo, message, tree, parents = nil, options = {})\n        params = { message: message, tree: tree }\n        params[:parents] = [parents].flatten if parents\n        post \"#{Repository.path repo}/git/commits\", options.merge(params)\n      end",
        "comment": "Create a commit  Optionally pass <tt>author</tt> and <tt>committer</tt> hashes in <tt>options</tt> if you'd like manual control over those parameters. If absent, details will be inferred from the authenticated user. See <a href=\"http://developer.github.com/v3/git/commits/\">GitHub's documentation</a> for details about how to format committer identities.  @param repo [Integer, String, Hash, Repository] A GitHub repository @param message [String] The commit message @param tree [String] The SHA of the tree object the new commit will point to @param parents [String, Array] One SHA (for a normal commit) or an array of SHAs (for a merge) of the new commit's parent commits. If ommitted or empty, a root commit will be created @return [Sawyer::Resource] A hash representing the new commit @see https://developer.github.com/v3/git/commits/#create-a-commit @example Create a commit commit = Octokit.create_commit(\"octocat/Hello-World\", \"My commit message\", \"827efc6d56897b048c772eb4087f854f46256132\", \"7d1b31e74ee336d15cbd21741bc88a537ed063a0\") commit.sha # => \"7638417db6d59f3c431d3e1f261cc637155684cd\" commit.tree.sha # => \"827efc6d56897b048c772eb4087f854f46256132\" commit.message # => \"My commit message\" commit.committer # => { \"name\" => \"Wynn Netherland\", \"email\" => \"wynn@github.com\", ... }",
        "label": "What",
        "id": "15063"
    },
    {
        "raw_code": "def _HtmlBlockFrameset\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenFrameset)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockFrameset = HtmlBlockOpenFrameset (HtmlBlockFrameset | !HtmlBlockCloseFrameset .)* HtmlBlockCloseFrameset",
        "label": "What",
        "id": "15700"
    },
    {
        "raw_code": "def version_fetch_env_variables\n      {\n        **cng_versions,\n        **version_file_variables,\n        **default_build_vars,\n        \"GITLAB_VERSION\" => gitlab_version,\n        \"RUBY_VERSION\" => RUBY_VERSION,\n        \"DEBIAN_DIGEST\" => debian_image.split(\"@\").last,\n        \"ALPINE_DIGEST\" => alpine_image.split(\"@\").last,\n        \"REPOSITORY_TREE\" => repo_tree\n      }\n    end",
        "comment": "Environment variables required for container version fetching All these variables influence final container version values  @return [Hash]",
        "label": "What",
        "id": "5274"
    },
    {
        "raw_code": "def perform(action, data = {})\n          check_subscribed!\n          subscription.perform_action(data.stringify_keys.merge(\"action\" => action.to_s))\n        end",
        "comment": "Perform action on a channel.  NOTE: Must be subscribed.",
        "label": "What",
        "id": "11059"
    },
    {
        "raw_code": "def eql?(o)\n      self == o\n    end",
        "comment": "@see the `==` method @param [Object] Object to be compared",
        "label": "What",
        "id": "887"
    },
    {
        "raw_code": "def wrap_parameters(name_or_model_or_options, options = {})\n        model = nil\n\n        case name_or_model_or_options\n        when Hash\n          options = name_or_model_or_options\n        when false\n          options = options.merge(format: [])\n        when Symbol, String\n          options = options.merge(name: name_or_model_or_options)\n        else\n          model = name_or_model_or_options\n        end",
        "comment": "Sets the name of the wrapper key, or the model which `ParamsWrapper` would use to determine the attribute names from.  #### Examples wrap_parameters format: :xml # enables the parameter wrapper for XML format  wrap_parameters :person # wraps parameters into params[:person] hash  wrap_parameters Person # wraps parameters by determining the wrapper key from Person class # (:person, in this case) and the list of attribute names  wrap_parameters include: [:username, :title] # wraps only :username and :title attributes from parameters.  wrap_parameters false # disables parameters wrapping for this controller altogether.  #### Options *   `:format` - The list of formats in which the parameters wrapper will be enabled. *   `:include` - The list of attribute names which parameters wrapper will wrap into a nested hash. *   `:exclude` - The list of attribute names which parameters wrapper will exclude from a nested hash. ",
        "label": "What",
        "id": "11306"
    },
    {
        "raw_code": "def perform\n    if MergeRequest.use_locked_set?\n      MergeRequests::UnstickLockedMergeRequestsService.new.execute\n    else\n      stuck_merge_requests.find_in_batches(batch_size: 100) do |group|\n        # The logic in this block also exists in `MergeRequests::UnstickLockedMergeRequestsService`\n        # since that is intended to replace this once the feature flag is fully rolled out.\n        #\n        # Any changes that needs to be applied here should be applied to the service as well.\n        jids = group.map(&:merge_jid)\n\n        # Find the jobs that aren't currently running or that exceeded the threshold.\n        completed_jids = Gitlab::SidekiqStatus.completed_jids(jids)\n\n        if completed_jids.any?\n          completed_ids = group.select { |merge_request| completed_jids.include?(merge_request.merge_jid) }.map(&:id)\n\n          apply_current_state!(completed_jids, completed_ids)\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6281"
    },
    {
        "raw_code": "def missing_name\n    # Since ruby v2.3.0 `did_you_mean` gem is loaded by default.\n    # It extends NameError#message with spell corrections which are SLOW.\n    # We should use original_message message instead.\n    message = respond_to?(:original_message) ? original_message : self.message\n    return unless message.start_with?(\"uninitialized constant \")\n\n    receiver = begin\n      self.receiver\n    rescue ArgumentError\n      nil\n    end",
        "comment": "Extract the name of the missing constant from the exception message.  begin HelloWorld rescue NameError => e e.missing_name end # => \"HelloWorld\"",
        "label": "What",
        "id": "14083"
    },
    {
        "raw_code": "def percent_doc\n    return @percent_doc if @percent_doc\n\n    @fully_documented = (@num_items - @doc_items) == 0\n\n    @percent_doc = @doc_items.to_f / @num_items * 100 if @num_items.nonzero?\n    @percent_doc ||= 0\n\n    @percent_doc\n  end",
        "comment": " Calculates the percentage of items documented.",
        "label": "What",
        "id": "15995"
    },
    {
        "raw_code": "def find_by!(arg, *args)\n      where(arg, *args).take!\n    end",
        "comment": "Like #find_by, except that if no record is found, raises an ActiveRecord::RecordNotFound error.",
        "label": "What",
        "id": "13364"
    },
    {
        "raw_code": "def enqueue_project_cache_update(post_received, project)\n      stats_to_invalidate = %w[repository_size]\n      stats_to_invalidate << 'commit_count' if post_received.includes_default_branch?\n\n      ProjectCacheWorker.perform_async(project.id, [], stats_to_invalidate, true)\n    end",
        "comment": "Schedule an update for the repository size and commit count if necessary.",
        "label": "What",
        "id": "6389"
    },
    {
        "raw_code": "def locals\n      if strict_locals?\n        nil\n      else\n        @locals\n      end",
        "comment": "The locals this template has been or will be compiled for, or nil if this is a strict locals template.",
        "label": "What",
        "id": "11752"
    },
    {
        "raw_code": "def head(action, **args)\n        process(action, method: \"HEAD\", **args)\n      end",
        "comment": "Simulate a HEAD request with the given parameters and set/volley the response. See `get` for more details.",
        "label": "What",
        "id": "11246"
    },
    {
        "raw_code": "def fetch_ghost_user\n      attempt = 0\n\n      begin\n        attempt += 1\n        query = <<~GRAPHQL\n          {\n            users(usernames: [\"ghost\", \"ghost1\", \"ghost2\", \"ghost3\", \"ghost4\", \"ghost5\", \"ghost6\"], humans: false) {\n              nodes {\n                id\n                username\n                type\n              }\n            }\n          }\n        GRAPHQL\n\n        response = client.execute(query: query)\n        response = response.dig('data', 'users', 'nodes') || []\n        response.find { |user| user[\"type\"] == 'GHOST' }\n      rescue StandardError => e\n        if attempt < MAX_RETRIES\n          delay = 2**attempt # Exponential backoff (2, 4, 8...)\n          sleep(delay)\n          retry\n        end",
        "comment": "@return [Hash, nil]",
        "label": "What",
        "id": "3595"
    },
    {
        "raw_code": "def text?\n    @parser and @parser.include? RDoc::Parser::Text\n  end",
        "comment": " Is this TopLevel from a text file instead of a source code file?",
        "label": "What",
        "id": "16733"
    },
    {
        "raw_code": "def compile!(view)\n        return if @compiled\n\n        # Templates can be used concurrently in threaded environments\n        # so compilation and any instance variable modification must\n        # be synchronized\n        @compile_mutex.synchronize do\n          # Any thread holding this lock will be compiling the template needed\n          # by the threads waiting. So re-check the @compiled flag to avoid\n          # re-compilation\n          return if @compiled\n\n          mod = view.compiled_method_container\n\n          instrument(\"!compile_template\") do\n            compile(mod)\n          end",
        "comment": "Compile a template. This method ensures a template is compiled just once and removes the source after it is compiled.",
        "label": "What",
        "id": "11760"
    },
    {
        "raw_code": "def verify!\n        unless active?\n          @lock.synchronize do\n            if @unconfigured_connection\n              @raw_connection = @unconfigured_connection\n              @unconfigured_connection = nil\n              attempt_configure_connection\n              @last_activity = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n              @verified = true\n              @allow_preconnect = true\n              return\n            end",
        "comment": "Checks whether the connection to the database is still active (i.e. not stale). This is done under the hood by calling #active?. If the connection is no longer active, then this method will reconnect to the database.",
        "label": "What",
        "id": "12933"
    },
    {
        "raw_code": "def validates_presence_of(*attr_names)\n        validates_with PresenceValidator, _merge_attributes(attr_names)\n      end",
        "comment": "Validates that the specified attributes are not blank (as defined by Object#blank?). If the attribute is an association, the associated object is also considered blank if it is marked for destruction.  class Person < ActiveRecord::Base has_one :face validates_presence_of :face end  The face attribute must be in the object and it cannot be blank or marked for destruction.  This validator defers to the Active Model validation for presence, adding the check to see that an associated object is not marked for destruction. This prevents the parent object from validating successfully and saving, which then deletes the associated object, thus putting the parent object into an invalid state.  See ActiveModel::Validations::HelperMethods.validates_presence_of for more information.  NOTE: This validation will not fail while using it with an association if the latter was assigned but not valid. If you want to ensure that it is both present and valid, you also need to use {validates_associated}[rdoc-ref:Validations::ClassMethods#validates_associated].",
        "label": "What",
        "id": "13467"
    },
    {
        "raw_code": "def test\n            end",
        "comment": "{access_modifier} {'^' * access_modifier.size} Keep a blank line after `#{access_modifier}`.",
        "label": "What",
        "id": "10839"
    },
    {
        "raw_code": "def delete_jobs_for(set:, kwargs:, job_klasses:)\n          until_equal_to(0, **kwargs) do\n            set.count do |job|\n              job_klasses.include?(job.klass) && job.delete\n            end",
        "comment": "Handle the \"jobs deleted\" tracking that is needed in order to track whether a job was deleted or not.",
        "label": "What",
        "id": "3168"
    },
    {
        "raw_code": "def cache_source_name(username, source_name)\n        Gitlab::Cache::Import::Caching.write(source_name_cache_key(username), source_name)\n      end",
        "comment": "Caches the source name associated to the username  @param [String] username The username of the GitHub user. @param [String] source_name The source_name to value to be cached.",
        "label": "What",
        "id": "2156"
    },
    {
        "raw_code": "def delete_code_scanning_analysis(repo, analysis_id, options = {})\n        delete \"#{Repository.path repo}/code-scanning/analyses/#{analysis_id}\", options\n      end",
        "comment": "Delete a specified code scanning analysis from a repository  @param repo [Integer, String, Repository, Hash] A GitHub repository @param analysis_id [Integer] ID of the code scanning analysis  @return [Sawyer::Resource] Next Code Scanning Analysis Information @see https://docs.github.com/en/rest/code-scanning/code-scanning#delete-a-code-scanning-analysis-from-a-repository",
        "label": "What",
        "id": "15366"
    },
    {
        "raw_code": "def log_permanent_deletion(resource)\n        path = resource_path(resource)\n        logger.info(\"\\e[32mSUCCESS\\e[0m: Permanently deleted #{resource[:type]} #{path}\\n\")\n        [\"permanent_deletions\", resource]\n      end",
        "comment": "Print permanent deletion message for a given resource  @param [<Hash>] resource @return [Array<String, Hash>] results",
        "label": "What",
        "id": "4738"
    },
    {
        "raw_code": "def token_valid?(token, check_admin:)\n            return unless token\n\n            debug(\"Validating if api token is valid\")\n            validate_api_client!(API::Client.new(personal_access_token: token), check_admin: check_admin)\n            debug(\"Api token is valid\")\n            true\n          rescue InvalidTokenError => e\n            debug(\"Api token is not valid, error: #{e}. Skipping...\")\n            false\n          end",
        "comment": "Check if provided token is valid?  @param [String] token @param [Boolean] check_admin @return [Boolean]",
        "label": "What",
        "id": "4514"
    },
    {
        "raw_code": "def self.resize_disk(machine, disk_config, defined_disk, controller)\n          machine.ui.detail(I18n.t(\"vagrant.cap.configure_disks.resize_disk\", name: disk_config.name), prefix: true)\n\n          if defined_disk[:storage_format] == \"VMDK\"\n            LOGGER.warn(\"Disk type VMDK cannot be resized in VirtualBox. Vagrant will convert disk to VDI format to resize first, and then convert resized disk back to VMDK format\")\n\n            # original disk information in case anything goes wrong during clone/resize\n            original_disk = defined_disk\n            backup_disk_location = \"#{original_disk[:location]}.backup\"\n\n            # clone disk to vdi formatted disk\n            vdi_disk_file = machine.provider.driver.vmdk_to_vdi(defined_disk[:location])\n            # resize vdi\n            machine.provider.driver.resize_disk(vdi_disk_file, disk_config.size.to_i)\n\n            begin\n              # Danger Zone\n              # remove and close original volume\n              machine.provider.driver.remove_disk(controller.name, defined_disk[:port], defined_disk[:device])\n              # Create a backup of the original disk if something goes wrong\n              LOGGER.warn(\"Making a backup of the original disk at #{defined_disk[:location]}\")\n              FileUtils.mv(defined_disk[:location], backup_disk_location)\n\n              # we have to close here, otherwise we can't re-clone after\n              # resizing the vdi disk\n              machine.provider.driver.close_medium(defined_disk[:uuid])\n\n              # clone back to original vmdk format and attach resized disk\n              vmdk_disk_file = machine.provider.driver.vdi_to_vmdk(vdi_disk_file)\n              machine.provider.driver.attach_disk(controller.name,\n                                                  defined_disk[:port],\n                                                  defined_disk[:device],\n                                                  \"hdd\",\n                                                  vmdk_disk_file)\n            rescue ScriptError, SignalException, StandardError\n              LOGGER.warn(\"Vagrant encountered an error while trying to resize a disk. Vagrant will now attempt to reattach and preserve the original disk...\")\n              machine.ui.error(I18n.t(\"vagrant.cap.configure_disks.recovery_from_resize\",\n                                      location: original_disk[:location],\n                                      name: machine.name))\n              recover_from_resize(machine, defined_disk, backup_disk_location, original_disk, vdi_disk_file, controller)\n              raise\n            ensure\n              # Remove backup disk file if all goes well\n              FileUtils.remove(backup_disk_location, force: true)\n            end",
        "comment": "@param [Vagrant::Machine] machine @param [Config::Disk] disk_config - the current disk to configure @param [Hash] defined_disk - current disk as represented by VirtualBox @param [VagrantPlugins::ProviderVirtualBox::Model::StorageController] controller - the storage controller to use @return [Hash] - disk_metadata",
        "label": "What",
        "id": "9631"
    },
    {
        "raw_code": "def \\#{unsafe_method}(*params, &block)\n            to_str.\\#{unsafe_method}(*params, &block)\n          end",
        "comment": "def capitalize(*params, &block) to_str.capitalize(*params, &block) end",
        "label": "What",
        "id": "10856"
    },
    {
        "raw_code": "def public_gists(options = {})\n        paginate 'gists/public', options\n      end",
        "comment": "List public gists  @return [Array<Sawyer::Resource>] A list of gists @example Fetch all public gists Octokit.public_gists @see https://developer.github.com/v3/gists/#list-gists",
        "label": "What",
        "id": "15179"
    },
    {
        "raw_code": "def labels(auto_paginate: false)\n        response = if auto_paginate\n                     auto_paginated_response(request_url(\"#{api_get_path}/labels\", per_page: '100'))\n                   else\n                     parse_body(api_get_from(\"#{api_get_path}/labels\"))\n                   end",
        "comment": "Get group labels  @return [Array<QA::Resource::GroupLabel>]",
        "label": "What",
        "id": "4151"
    },
    {
        "raw_code": "def post(url, options = {})\n      request :post, url, options\n    end",
        "comment": "Make a HTTP POST request  @param url [String] The path, relative to {#api_endpoint} @param options [Hash] Body and header params for request @return [Sawyer::Resource]",
        "label": "What",
        "id": "14903"
    },
    {
        "raw_code": "def process_upload_type(sub_batch, model_table, model_name, sources, targets, join_key, db_name)\n        relation = sub_batch.select(:id, :model_type).limit(sub_batch_size)\n        targets ||= sources\n        join_key ||= 'id'\n        # Columns that will be reset (nullified) as they are not used for sharding keys\n        reset_columns = sharding_key_columns - targets\n        # All columns to back-fill\n        target_columns = (columns + targets + reset_columns).join(', ')\n        # All columns to source from\n        source_columns = source_columns_sql(sources, reset_columns)\n        # For existing records update only sharding key columns (if any)\n        on_conflict = if targets.any?\n                        \"UPDATE SET #{sharding_key_columns.map { |c| \"#{c} = EXCLUDED.#{c}\" }.join(', ')}\"\n                      else\n                        \"NOTHING\"\n                      end",
        "comment": "Back-fill partitioned table `uploads_9ba88c4165`. For each sub-batch execute an upsert query per model_type, joining with the respective model_table. This join will exclude uploads belonging to records that no longer exist.  Arguments are: sub_batch -  batch to operate on. model_table - table storing the parent model model_name - model class name source - columns to source the sharding key values from targets - sharding key columns to back-fill join_key - column to join with the model table, defaults to id db_name - database the model table belongs to",
        "label": "What",
        "id": "3279"
    },
    {
        "raw_code": "def literal?\n          false\n        end",
        "comment": "@return [Boolean] whether the node is a literal value",
        "label": "What",
        "id": "313"
    },
    {
        "raw_code": "def self.transform(collection:, node:, user:)\n          new(collection: collection, user: user).process(node)\n        end",
        "comment": "Transforms a query node into Elasticsearch query DSL  @param node [ActiveContext::Query] The query node to transform @return [Hash] The Elasticsearch query DSL @example Processor.transform(ActiveContext::Query.filter(status: 'active'))",
        "label": "What",
        "id": "1151"
    },
    {
        "raw_code": "def identify_using_ssh_key(identifier)\n      key_id = identifier.gsub(\"key-\", \"\")\n\n      identify_with_cache(:ssh_key, key_id) do\n        User.find_by_ssh_key_id(key_id)\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord Tries to identify a user based on an SSH key identifier (e.g. \"key-123\"). Deploy keys are excluded.",
        "label": "What",
        "id": "1612"
    },
    {
        "raw_code": "def decline_repository_invitation(invitation_id, options = {})\n        boolean_from_response :delete, \"/user/repository_invitations/#{invitation_id}\", options\n      end",
        "comment": "Decline a repository invitation  Requires authenticated client  @param invitation_id [Integer] The id of the invitation @return [Boolean] True if the acceptance of the invitation was successful @see https://developer.github.com/v3/repos/invitations/#decline-a-repository-invitation",
        "label": "What",
        "id": "15401"
    },
    {
        "raw_code": "def url_for_list(type)\n        abs_url(base_path(router.list_prefix), type.to_s)\n      end",
        "comment": "Modifies {Templates::Helpers::HtmlHelper#url_for_list} to return a URL based on the list prefix instead of a HTML filename. @param (see Templates::Helpers::HtmlHelper#url_for_list) @return (see Templates::Helpers::HtmlHelper#url_for_list)",
        "label": "What",
        "id": "683"
    },
    {
        "raw_code": "def init\n    unless Rails.env.test?\n      puts \"\\nTestEnv.init can only be run if `RAILS_ENV` is set to 'test' not '#{Rails.env}'!\\n\"\n      exit 1\n    end",
        "comment": "Test environment  See gitlab.yml.example test section for paths ",
        "label": "What",
        "id": "8468"
    },
    {
        "raw_code": "def create\n    # TODO: remove this with the release creation moved to it's own form https://gitlab.com/gitlab-org/gitlab/-/issues/214245\n    evidence_pipeline = find_evidence_pipeline\n\n    result = ::Tags::CreateService.new(@project, current_user)\n      .execute(params[:tag_name], params[:ref], params[:message])\n\n    if result[:status] == :success\n      # TODO: remove this with the release creation moved to it's own form https://gitlab.com/gitlab-org/gitlab/-/issues/214245\n      if params[:release_description].present?\n        release_params = {\n          tag: params[:tag_name],\n          name: params[:tag_name],\n          description: params[:release_description],\n          evidence_pipeline: evidence_pipeline\n        }\n\n        Releases::CreateService\n          .new(@project, current_user, release_params)\n          .execute\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6599"
    },
    {
        "raw_code": "def reopen_issue(repo, number, options = {})\n        patch \"#{Repository.path repo}/issues/#{number}\", options.merge({ state: 'open' })\n      end",
        "comment": "Reopen an issue  @param repo [Integer, String, Repository, Hash] A GitHub repository @param number [Integer] Number ID of the issue @param options [Hash] A customizable set of options. @option options [String] :assignee User login. @option options [Array<String>] :assignees User login. @option options [Integer] :milestone Milestone number. @option options [Array<String>] :labels List of Label names. Example: <tt>['bug', 'ui', '@high']</tt>. @return [Sawyer::Resource] The updated Issue @see https://developer.github.com/v3/issues/#edit-an-issue @example Reopen Issue #25 from octokit/octokit.rb Octokit.reopen_issue(\"octokit/octokit.rb\", \"25\")",
        "label": "What",
        "id": "15248"
    },
    {
        "raw_code": "def initialize(note, project, client)\n          @note = note\n          @project = project\n          @client = client\n          @user_finder = GithubImport::UserFinder.new(project, client)\n        end",
        "comment": "note - An instance of `Gitlab::GithubImport::Representation::Note`. project - An instance of `Project`. client - An instance of `Gitlab::GithubImport::Client`.",
        "label": "What",
        "id": "2201"
    },
    {
        "raw_code": "def setup\n            setup_output_dir\n            check_namespace\n            setup_signal_handlers\n          end",
        "comment": "Run initial setup  @return [void]",
        "label": "What",
        "id": "3985"
    },
    {
        "raw_code": "def time_select(method, options = {}, html_options = {})\n        @template.time_select(@object_name, method, objectify_options(options), html_options)\n      end",
        "comment": "Wraps ActionView::Helpers::DateHelper#time_select for form builders:  <%= form_with model: @race do |f| %> <%= f.time_select :average_lap %> <%= f.submit %> <% end %>  Please refer to the documentation of the base helper for details.",
        "label": "What",
        "id": "11859"
    },
    {
        "raw_code": "def schedule_backup_job(storage, relative_path, gl_project_path, always_create)\n            json_job = {\n              storage_name: storage,\n              relative_path: relative_path,\n              gl_project_path: gl_project_path,\n              always_create: always_create\n            }.to_json\n\n            @input_stream.puts(json_job)\n          end",
        "comment": "Schedule a new backup job through a non-blocking JSON based pipe protocol  @see https://gitlab.com/gitlab-org/gitaly/-/blob/master/doc/gitaly-backup.md",
        "label": "What",
        "id": "1064"
    },
    {
        "raw_code": "def attach_partition_tables(partitions)\n          partitions.each do |partition|\n            connection.execute(partition.to_attach_sql)\n            process_created_partition(partition)\n          end",
        "comment": "Attach all partitions (takes SHARE UPDATE EXCLUSIVE lock)",
        "label": "What",
        "id": "3207"
    },
    {
        "raw_code": "def next(lower_bounds)\n          dup.tap do |next_page|\n            next_page.lower_bounds = lower_bounds&.symbolize_keys\n          end",
        "comment": "Construct a Page for the next page Uses identical order_by/per_page information for the next page",
        "label": "What",
        "id": "1997"
    },
    {
        "raw_code": "def mergeable_state?(**params)\n    execute_merge_checks(\n      self.class.mergeable_state_checks,\n      params: params,\n      execute_all: false\n    ).success?\n  end",
        "comment": "mergeable_state_check_params allows a hash of merge checks to skip or not skip_ci_check skip_discussions_check skip_draft_check skip_approved_check skip_blocked_check skip_external_status_check skip_requested_changes_check skip_jira_check",
        "label": "What",
        "id": "6978"
    },
    {
        "raw_code": "def to_s\n        \"Push\"\n      end",
        "comment": "The String representation of this Push.  @return [String]",
        "label": "What",
        "id": "9427"
    },
    {
        "raw_code": "def attribute_alias?(new_name)\n        attribute_aliases.key? new_name.to_s\n      end",
        "comment": "Is +new_name+ an alias?",
        "label": "What",
        "id": "12179"
    },
    {
        "raw_code": "def self.add_devfile_command_scripts_to_configmap_data(\n                configmap_data:,\n                devfile_commands:,\n                devfile_events:\n              )\n                devfile_events => { postStart: Array => poststart_command_ids }\n\n                poststart_command_ids.each do |poststart_command_id|\n                  command = devfile_commands.find { |command| command.fetch(:id) == poststart_command_id }\n                  command => {\n                    exec: {\n                      commandLine: String => command_line\n                    }\n                  }\n\n                  configmap_data[poststart_command_id.to_sym] = command_line\n                end",
        "comment": "@param [Hash] configmap_data @param [Array<Hash>] devfile_commands @param [Hash] devfile_events @return [void]",
        "label": "What",
        "id": "3327"
    },
    {
        "raw_code": "def disable_extension(name, force: false)\n        _schema, name = name.to_s.split(\".\").values_at(-2, -1)\n        internal_exec_query(\"DROP EXTENSION IF EXISTS \\\"#{name}\\\"#{' CASCADE' if force == :cascade}\").tap {\n          reload_type_map\n        }\n      end",
        "comment": "Removes an extension from the database.  [<tt>:force</tt>] Set to +:cascade+ to drop dependent objects as well. Defaults to false.",
        "label": "What",
        "id": "12968"
    },
    {
        "raw_code": "def initialize(path, project: nil)\n      @path = path.to_s.downcase\n      @project = project\n    end",
        "comment": "The 'project' argument is optional. If provided during initialization, it will limit the path to the specified project, potentially reducing the need for a database query.",
        "label": "What",
        "id": "3380"
    },
    {
        "raw_code": "def move_to_lost_and_found(path, dry_run)\n        new_path = path.sub(/\\A#{ProjectUploadFileFinder::ABSOLUTE_UPLOAD_DIR}/o, LOST_AND_FOUND)\n\n        move(path, new_path, 'move to lost and found', dry_run)\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2725"
    },
    {
        "raw_code": "def charset\n      header_info = parsed_content_type_header\n      header_info.charset || self.class.default_charset\n    end",
        "comment": "The charset of the response. HTML wants to know the encoding of the content you're giving them, so we need to send that along.",
        "label": "What",
        "id": "11472"
    },
    {
        "raw_code": "def cache_last_push_event(event)\n      keys = [\n        project_cache_key(event.project),\n        user_cache_key\n      ]\n\n      if forked_from = event.project.forked_from_project\n        keys << project_cache_key(forked_from)\n      end",
        "comment": "Caches the given push event for the current user in the Rails cache.  event - An instance of PushEvent to cache.",
        "label": "What",
        "id": "5992"
    },
    {
        "raw_code": "def verify_image(path)\n        end",
        "comment": "Verifies that an image can be imported properly.  @param [String] path Path to an OVF file. @return [Boolean]",
        "label": "What",
        "id": "9599"
    },
    {
        "raw_code": "def route(routing_code, namespace: nil)\n        namespace = Array(namespace)\n        namespace_pattern = route_namespace_pattern(namespace)\n        routing_code = namespace.reverse.reduce(routing_code) do |code, name|\n          \"namespace :#{name} do\\n#{rebase_indentation(code, 2)}end\"\n        end",
        "comment": "Make an entry in \\Rails routing file <tt>config/routes.rb</tt>  route \"root 'welcome#index'\" route \"root 'admin#index'\", namespace: :admin",
        "label": "What",
        "id": "14739"
    },
    {
        "raw_code": "def item_ids\n    item_ids = []\n\n    if project?\n      if project\n        if project.group.present?\n          labels_table = Label.arel_table\n          group_ids = group_ids_for(project.group)\n\n          item_ids << Label.where(\n            labels_table[:type].eq('GroupLabel').and(labels_table[:group_id].in(group_ids)).or(\n              labels_table[:type].eq('ProjectLabel').and(labels_table[:project_id].eq(project.id))\n            )\n          )\n        else\n          item_ids << project.labels\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7864"
    },
    {
        "raw_code": "def on_send(node)\n          fix_exploded(node) || fix_compact(node)\n        end",
        "comment": "Switch `raise RuntimeError, 'message'` to `raise 'message'`, and `raise RuntimeError.new('message')` to `raise 'message'`.",
        "label": "What",
        "id": "10494"
    },
    {
        "raw_code": "def initialize(user_ids)\n      @user_ids = user_ids\n    end",
        "comment": "user_ids - An array of User IDs",
        "label": "What",
        "id": "5997"
    },
    {
        "raw_code": "def bar\n            do_something\n          end",
        "comment": "rubocop:disable Metrics",
        "label": "What",
        "id": "10958"
    },
    {
        "raw_code": "def check_static_cache\n        return nil unless adapter.document_root\n        cache_path = File.join(adapter.document_root, request.path.sub(/\\.html$/, '') + '.html')\n        cache_path = cache_path.sub(%r{/\\.html$}, '.html')\n        if File.file?(cache_path)\n          log.debug \"Loading cache from disk: #{cache_path}\"\n          return [200, {'Content-Type' => 'text/html'}, [File.read_binary(cache_path)]]\n        end",
        "comment": "Called by a router to return the cached object. By default, this method performs disk-based caching. To perform other forms of caching, implement your own +#check_static_cache+ method and mix the module into the Router class.  Note that caching does not occur here. This method simply checks for the existence of cached data. To actually cache a response, see {Commands::Base#cache}.  @example Implementing In-Memory Cache Checking module MemoryCaching def check_static_cache # $memory_cache is filled by {Commands::Base#cache} cached_data = $memory_cache[request.path] if cached_data [200, {'Content-Type' => 'text/html'}, [cached_data]] else nil end end end  class YARD::Server::Router; include MemoryCaching; end @return [Array(Numeric,Hash,Array)] the Rack-style response @return [nil] if no cache is available and routing should continue @see Commands::Base#cache",
        "label": "What",
        "id": "653"
    },
    {
        "raw_code": "def access_token_created(user, token_name)\n    return unless user.can?(:receive_notifications)\n\n    mailer.access_token_created_email(user, token_name).deliver_later\n  end",
        "comment": "Notify the owner of the account when a new personal access token is created",
        "label": "What",
        "id": "5455"
    },
    {
        "raw_code": "def add_method_list(out, methods, name)\n    return if methods.empty?\n\n    out << RDoc::Markup::Heading.new(1, \"#{name}:\")\n    out << RDoc::Markup::BlankLine.new\n\n    if @use_stdout and !@interactive then\n      out.concat methods.map { |method|\n        RDoc::Markup::Verbatim.new method\n      }\n    else\n      out << RDoc::Markup::IndentedParagraph.new(2, methods.join(', '))\n    end",
        "comment": " Adds a list of +methods+ to +out+ with a heading of +name+",
        "label": "What",
        "id": "16584"
    },
    {
        "raw_code": "def canonical_url\n    options = @store.options\n    if path\n      File.join(options.canonical_root, path.to_s)\n    else\n      options.canonical_root\n    end",
        "comment": " The preferred URL for this object.",
        "label": "What",
        "id": "16482"
    },
    {
        "raw_code": "def duplicates?(collection)\n        collection.size > 1 && collection.size > collection.uniq.size\n      end",
        "comment": "Whether the `collection` contains any duplicates.  @param [Array] collection an array to check for duplicates @return [Boolean] whether the array contains any duplicates",
        "label": "What",
        "id": "10454"
    },
    {
        "raw_code": "def build(dir, **opts, &block)\n          name = machine.name.to_s\n          @logger.debug(\"Applying build for `#{name}` using `#{dir}` directory.\")\n          begin\n            update_composition do |composition|\n              services = composition[\"services\"] ||= {}\n              services[name] ||= {}\n              services[name][\"build\"] = {\"context\" => dir}\n              # Extract custom dockerfile location if set\n              if opts[:extra_args] && opts[:extra_args].include?(\"--file\")\n                services[name][\"build\"][\"dockerfile\"] = opts[:extra_args][opts[:extra_args].index(\"--file\") + 1]\n              end",
        "comment": "Updates the docker compose config file with the given arguments  @param [String] dir - local directory or git repo URL @param [Hash] opts - valid key: extra_args @param [Block] block @return [Nil]",
        "label": "What",
        "id": "9503"
    },
    {
        "raw_code": "def remove_repository_from_app_installation(installation, repo, options = {})\n        boolean_from_response :delete, \"user/installations/#{installation}/repositories/#{repo}\", options\n      end",
        "comment": "Remove a single repository to an installation  @param installation [Integer] The id of a GitHub App Installation @param repo [Integer] The id of the GitHub repository @param options [Hash] A customizable set of options  @see https://docs.github.com/en/rest/apps/installations#remove-a-repository-from-an-app-installation  @return [Boolean] Success",
        "label": "What",
        "id": "15020"
    },
    {
        "raw_code": "def wsl_windows_accessible_path\n          if !defined?(@_wsl_windows_accessible_path)\n            access_path = ENV[\"VAGRANT_WSL_WINDOWS_ACCESS_USER_HOME_PATH\"]\n            if access_path.to_s.empty?\n              begin\n                process = Subprocess.execute(\"wslpath\", \"-u\", \"-a\", wsl_windows_home)\n                access_path = process.stdout.chomp if process.exit_code == 0\n              rescue Errors::CommandUnavailable => e\n                # pass\n              end",
        "comment": "The allowed windows system path Vagrant can manage from the Windows Subsystem for Linux  @return [Pathname]",
        "label": "What",
        "id": "9212"
    },
    {
        "raw_code": "def generate_pot\n      super([])\n    end",
        "comment": "Overrides method from GetText::Tools::XGetText This makes a method public and passes in an empty array of paths, as our overidden \"parse\" method needs no paths",
        "label": "What",
        "id": "8091"
    },
    {
        "raw_code": "def get_version\n          return @version if @version\n          @version = Gem::Version.new(Meta.new.version)\n        end",
        "comment": "VirtualBox version in use  @return [Gem::Version]",
        "label": "What",
        "id": "9563"
    },
    {
        "raw_code": "def self_and_downstreams_builds_of_pipeline(pipeline)\n          ::Ci::Build\n            .select(:id, :type, :started_at, :finished_at)\n            .in_pipelines(\n              pipeline.self_and_downstreams.select(:id)\n            )\n            .with_status(STATUSES)\n            .latest\n            .where.not(started_at: nil)\n            .order(:started_at)\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2505"
    },
    {
        "raw_code": "def hook_ssl_verification\n      if respond_to?(:enable_ssl_verification)\n        enable_ssl_verification\n      else\n        true\n      end",
        "comment": "Return whether the webhook should use SSL verification.",
        "label": "What",
        "id": "7448"
    },
    {
        "raw_code": "def print_cops_of_department(department)\n      selected_cops = cops_of_department(department)\n      content = formatter.to_comment(+<<~HEADER)\n        Do NOT edit this file by hand directly, as it is automatically generated.\n\n        Please make any necessary changes to the cop documentation within the source files themselves.\n      HEADER\n      content += formatter.to_header(department)\n      selected_cops.each { |cop| content << print_cop_with_doc(cop) }\n      content << footer_for_department(department)\n      file_name = formatter.to_filename(\"#{docs_path}/pages/#{department_to_basename(department)}\")\n      File.open(file_name, 'w') do |file|\n        puts \"* generated #{file_name}\"\n        file.write(\"#{content.strip}\\n\")\n      end",
        "comment": "rubocop:disable Metrics/MethodLength -- Exception already existed in upstream repo",
        "label": "What",
        "id": "3869"
    },
    {
        "raw_code": "def remove_instance(instance_name)\n          index = @list.index { |x| x.name == instance_name }\n          instance = @list.slice!(index)\n          instance.remove!\n        end",
        "comment": "Remove an instance with a given name @param instance_name [String] the name of the instance that was specified during initialization",
        "label": "What",
        "id": "4222"
    },
    {
        "raw_code": "def track_event\n      # no-op\n    end",
        "comment": "Override on child classes to perform actions when the service is executed.",
        "label": "What",
        "id": "6133"
    },
    {
        "raw_code": "def url_for_direct_upload(key, expires_in:, content_type:, content_length:, checksum:, custom_metadata: {})\n      raise NotImplementedError\n    end",
        "comment": "Returns a signed, temporary URL that a direct upload file can be PUT to on the +key+. The URL will be valid for the amount of seconds specified in +expires_in+. You must also provide the +content_type+, +content_length+, and +checksum+ of the file that will be uploaded. All these attributes will be validated by the service upon upload.",
        "label": "What",
        "id": "13679"
    },
    {
        "raw_code": "def inspect(cop_name)\n      path = path_for(cop_name)\n\n      if File.exist?(path)\n        FileUtils.mv(path, \"#{path}#{SUFFIX_INSPECT}\")\n        true\n      else\n        false\n      end",
        "comment": "Marks a TODO YAML file for inspection by renaming the original TODO YAML and appending the suffix +.inspect+ to it.  @return [Boolean] +true+ a file was marked for inspection successfully.",
        "label": "What",
        "id": "3875"
    },
    {
        "raw_code": "def execute\n        @controller ||= ApplicationController.new\n      end",
        "comment": "This method assumes an +ApplicationController+ exists, and that it extends ActionController::Base.",
        "label": "What",
        "id": "14722"
    },
    {
        "raw_code": "def validate_foreign_key(from_table, to_table = nil, **options)\n          fk_name_to_validate = foreign_key_for!(from_table, to_table: to_table, **options).name\n\n          validate_constraint from_table, fk_name_to_validate\n        end",
        "comment": "Validates the given foreign key.  Validates the foreign key on +accounts.branch_id+.  validate_foreign_key :accounts, :branches  Validates the foreign key on +accounts.owner_id+.  validate_foreign_key :accounts, column: :owner_id  Validates the foreign key named +special_fk_name+ on the +accounts+ table.  validate_foreign_key :accounts, name: :special_fk_name  The +options+ hash accepts the same keys as SchemaStatements#add_foreign_key.",
        "label": "What",
        "id": "13274"
    },
    {
        "raw_code": "def parse_method_params_and_body(container, single, meth, added_container)\n    token_listener meth do\n      parse_method_parameters meth\n\n      if meth.document_self or not @track_visibility then\n        container.add_method meth\n      elsif added_container then\n        container.document_self = false\n      end",
        "comment": " Parses the parameters and body of +meth+",
        "label": "What",
        "id": "16101"
    },
    {
        "raw_code": "def base_and_descendants_cte(with_depth: false)\n      cte = SQL::RecursiveCTE.new(:base_and_descendants)\n\n      base_query = descendants_base.except(:order)\n      base_query = base_query.select(\"1 AS #{DEPTH_COLUMN}\", \"ARRAY[#{objects_table.name}.id] AS tree_path\", \"false AS tree_cycle\", base_query.default_select_columns) if with_depth\n\n      cte << base_query\n\n      # Recursively get all the descendants of the base set.\n      descendants_query = unscoped_model\n        .from(from_tables(cte))\n        .where(descendant_conditions(cte))\n        .except(:order)\n\n      if with_depth\n        quoted_objects_table_name = model.connection.quote_table_name(objects_table.name)\n\n        descendants_query = descendants_query.select(\n          cte.table[DEPTH_COLUMN] + 1,\n          \"tree_path || #{quoted_objects_table_name}.id\",\n          \"#{quoted_objects_table_name}.id = ANY(tree_path)\",\n          descendants_query.default_select_columns\n        ).where(cte.table[:tree_cycle].eq(false))\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "1430"
    },
    {
        "raw_code": "def stable_sort_by(list)\n      list.each_with_index.sort_by {|tag, i| [yield(tag), i] }.map(&:first)\n    end",
        "comment": "A stable sort_by method.  @param list [Enumerable] the list to sort. @return [Array] a stable sorted list.",
        "label": "What",
        "id": "140"
    },
    {
        "raw_code": "def public_pages?\n    return true unless Gitlab.config.pages.access_control\n\n    return false if ::Gitlab::Pages.access_control_is_forced?\n\n    pages_access_level == PUBLIC || (pages_access_level == ENABLED && project.public?)\n  end",
        "comment": "This method checks whether access control is enabled on project level, to include the access setting from ancestors, use project.public_pages?",
        "label": "What",
        "id": "7123"
    },
    {
        "raw_code": "def increment(cache_key, expiry)\n        raise NotImplementedError\n      end",
        "comment": "Increment the rate limit count and return the new count value",
        "label": "What",
        "id": "1872"
    },
    {
        "raw_code": "def _TableLine\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n\n        _save2 = self.pos\n        while true # sequence\n          _tmp = apply(:_TableAlign)\n          align1 = @result\n          unless _tmp\n            self.pos = _save2\n            break\n          end",
        "comment": "TableLine = ((TableAlign:align1 TableAlign2*:aligns {[align1, *aligns] }):line | TableAlign2+:line) \"|\"? @Newline { line }",
        "label": "What",
        "id": "15833"
    },
    {
        "raw_code": "def perform(issue_id, user_id, issuable_class = 'Issue', skip_notifications = false)\n    @issuable_class = issuable_class.constantize\n\n    return unless objects_found?(issue_id, user_id)\n\n    ::EventCreateService.new.open_issue(issuable, user)\n    ::NotificationService.new.new_issue(issuable, user) unless skip_notifications\n\n    issuable.create_cross_references!(user)\n\n    Issues::AfterCreateService\n      .new(container: issuable.project, current_user: user)\n      .execute(issuable)\n\n    log_audit_event if user.project_bot?\n  end",
        "comment": "TODO: Add skip_notifications argument to the invocations of the worker in the next release (16.9)",
        "label": "What",
        "id": "6291"
    },
    {
        "raw_code": "def bar\n            do_something # - note\n          end",
        "comment": "rubocop:disable Metrics",
        "label": "What",
        "id": "10960"
    },
    {
        "raw_code": "def path_before_wildcard(path)\n    path = path.gsub(starting_with_namespace, \"\")\n    path_segments = path.split('/').reject(&:empty?)\n    wildcard_index = path_segments.index { |segment| parameter?(segment) }\n\n    segments_before_wildcard = path_segments[0..wildcard_index - 1]\n\n    segments_before_wildcard.join('/')\n  end",
        "comment": "Pass in a full path and get the last segment before a wildcard That's not a parameter `/*namespace_id/:project_id/builds/artifacts/*ref_name_and_path` -> 'builds/artifacts'",
        "label": "What",
        "id": "8224"
    },
    {
        "raw_code": "def localize(object, **options)\n        I18n.localize(object, **options)\n      end",
        "comment": "Delegates to <tt>I18n.localize</tt> with no additional functionality.  See https://www.rubydoc.info/gems/i18n/I18n/Backend/Base:localize for more information.",
        "label": "What",
        "id": "11987"
    },
    {
        "raw_code": "def approver_user_valid?\n        approver_user_id != 0\n      end",
        "comment": "Valid approver user is set  @return [Boolean]",
        "label": "What",
        "id": "4709"
    },
    {
        "raw_code": "def lease_timeout\n      LEASE_TIMEOUT\n    end",
        "comment": "Used by ExclusiveLeaseGuard",
        "label": "What",
        "id": "6334"
    },
    {
        "raw_code": "def open_submenu(parent_menu_name, sub_menu)\n          # If Project Studio is enabled, show the sidebar\n          expand_sidebar_if_collapsed if Runtime::Env.project_studio_enabled?\n\n          # prevent closing sub-menu if it was already open\n          unless has_element?('menu-section', section_name: parent_menu_name, wait: 0)\n            click_element('menu-section-button', section_name: parent_menu_name)\n          end",
        "comment": "Open sidebar navigation submenu  @param [String] parent_menu_name @param [String] sub_menu @return [void]",
        "label": "What",
        "id": "4278"
    },
    {
        "raw_code": "def source_query(start, finish)\n          col_as_arel = @column.is_a?(Arel::Attributes::Attribute) ? @column : Arel.sql(@column.to_s)\n          col_as_text = Arel::Nodes::NamedFunction.new('CAST', [col_as_arel.as('text')])\n          md5_of_col = Arel::Nodes::NamedFunction.new('md5', [col_as_text])\n          md5_as_hex = Arel::Nodes::Concat.new(Arel.sql(\"'X'\"), md5_of_col)\n          bits = Arel::Nodes::NamedFunction.new('CAST', [md5_as_hex.as('bit(32)')])\n\n          @relation\n            .where(@relation.primary_key => (start...finish))\n            .where(col_as_arel.not_eq(nil))\n            .select(bits.as('attr_hash_32_bits')).to_sql\n        end",
        "comment": "Generate the source query SQL snippet for the provided id range  @example SQL query template SELECT CAST(('X' || md5(CAST(%{column} as text))) as bit(32)) attr_hash_32_bits FROM %{relation} WHERE %{pkey} >= %{batch_start} AND %{pkey} < %{batch_end} AND %{column} IS NOT NULL  @param start initial id range @param finish final id range @return [String] SQL query fragment",
        "label": "What",
        "id": "3116"
    },
    {
        "raw_code": "def collect_commits\n      # https://gitlab.com/gitlab-org/gitlab-foss/issues/58013\n      Gitlab::GitalyClient.allow_n_plus_1_calls do\n        # Decorate with app/model/network/commit.rb\n        list_commits(count_to_display_commit_in_center).map do |commit|\n          Network::Commit.new(commit)\n        end",
        "comment": "Get commits from repository ",
        "label": "What",
        "id": "7217"
    },
    {
        "raw_code": "def video_url(source, options = {})\n        url_to_asset(source, { type: :video }.merge!(options))\n      end",
        "comment": "Computes the full URL to a video asset in the public videos directory. This will use +video_path+ internally, so most of their behaviors will be the same. Since +video_url+ is based on +asset_url+ method you can set +:host+ options. If +:host+ options is set, it overwrites global +config.action_controller.asset_host+ setting.  video_url \"hd.avi\", host: \"http://stage.example.com\" # => http://stage.example.com/videos/hd.avi ",
        "label": "What",
        "id": "11801"
    },
    {
        "raw_code": "def find_slack_integration\n        find_params = { team_id: params[:team_id], alias: project_alias }.compact\n        slack_app = SlackIntegration.find_by(find_params)\n\n        return unless slack_app\n\n        integration = slack_app.integration\n        integration if integration.active? && integration.project_level?\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2750"
    },
    {
        "raw_code": "def project_dropdown_label(project_id, default_label)\n    return default_label if project_id.nil?\n    return \"Any project\" if project_id == \"0\"\n\n    project = Project.find_by(id: project_id)\n\n    if project\n      project.full_name\n    else\n      default_label\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7818"
    },
    {
        "raw_code": "def generate_page(file)\n    template_file = @template_dir + 'page.rhtml'\n\n    out_file = @outputdir + file.path\n    debug_msg \"  working on %s (%s)\" % [file.full_name, out_file]\n    rel_prefix = @outputdir.relative_path_from out_file.dirname\n    search_index_rel_prefix = rel_prefix\n    search_index_rel_prefix += @asset_rel_path if @file_output\n\n    current          = file\n    asset_rel_prefix = rel_prefix + @asset_rel_path\n\n    @title = \"#{file.page_name} - #{@options.title}\"\n\n    debug_msg \"  rendering #{out_file}\"\n    render_template template_file, out_file do |io|\n      here = binding\n      # suppress 1.9.3 warning\n      here.local_variable_set(:current, current)\n      here.local_variable_set(:asset_rel_prefix, asset_rel_prefix)\n      here\n    end",
        "comment": " Generate a page file for +file+",
        "label": "What",
        "id": "16464"
    },
    {
        "raw_code": "def render_full_field(field, heading_level: 3, owner: nil)\n          conn = connection?(field)\n          args = field[:arguments].reject { |arg| conn && CONNECTION_ARGS.include?(arg[:name]) }\n          arg_owner = [owner, field[:name]]\n\n          chunks = [\n            render_name_and_description(field, level: heading_level, owner: owner),\n            render_return_type(field),\n            render_input_type(field),\n            render_connection_note(field),\n            render_argument_table(heading_level, args, arg_owner),\n            render_return_fields(field, owner: owner)\n          ]\n\n          join(:block, chunks)\n        end",
        "comment": "Template methods: Methods that return chunks of Markdown for insertion into the document",
        "label": "What",
        "id": "8142"
    },
    {
        "raw_code": "def import(_, project)\n          @project = project\n\n          return self.class.perform_in(30.seconds, project.id) if reference_store_pending?\n\n          project.after_import\n\n          report_import_time\n        end",
        "comment": "project - An instance of Project.",
        "label": "What",
        "id": "6314"
    },
    {
        "raw_code": "def copy_notes!(design_ids)\n        new_designs = DesignManagement::Design.unscoped.find(design_ids)\n\n        # Execute another query to filter only designs with notes\n        DesignManagement::Design.unscoped.where(id: designs).joins(:notes).distinct.find_each(batch_size: 100) do |old_design|\n          new_design = new_designs.find { |d| d.filename == old_design.filename }\n\n          Notes::CopyService.new(current_user, old_design, new_design).execute\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6089"
    },
    {
        "raw_code": "def workflow(repo, id, options = {})\n        get \"#{Repository.path repo}/actions/workflows/#{id}\", options\n      end",
        "comment": "Get single workflow in a repository  @param repo [Integer, String, Repository, Hash] A GitHub repository @param id [Integer, String] Id or file name of the workflow  @return [Sawyer::Resource] A single workflow @see https://developer.github.com/v3/actions/workflows/#get-a-workflow",
        "label": "What",
        "id": "15072"
    },
    {
        "raw_code": "def management_console_password\n        ENV.fetch('OCTOKIT_ENTERPRISE_MANAGEMENT_CONSOLE_PASSWORD', nil)\n      end",
        "comment": "Default management console password from ENV @return [String]",
        "label": "What",
        "id": "14882"
    },
    {
        "raw_code": "def link_object(obj, title = nil)\n      return title if title\n\n      case obj\n      when YARD::CodeObjects::Base, YARD::CodeObjects::Proxy\n        obj.title\n      when String, Symbol\n        P(obj).title\n      else\n        obj\n      end",
        "comment": "Links to an object with an optional title  @param [CodeObjects::Base] obj the object to link to @param [String] title the title to use for the link @return [String] the linked object",
        "label": "What",
        "id": "431"
    },
    {
        "raw_code": "def request_options(options)\n        default_options.merge(options)\n      end",
        "comment": "rubocop:enable GitlabSecurity/PublicSend",
        "label": "What",
        "id": "3609"
    },
    {
        "raw_code": "def trigger_events_for_integration(integration)\n    Integrations::EventSerializer.new(integration: integration).represent(integration.configurable_events).to_json\n  end",
        "comment": "rubocop:enable Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "7824"
    },
    {
        "raw_code": "def has_project?(project_name)\n        query_string = \"select name from projects where name LIKE '#{project_name}';\"\n\n        query(query_string).include?(project_name)\n      end",
        "comment": "checks if a project exists in the datastore @param project_name [string] name of project to be checked @return [boolean]",
        "label": "What",
        "id": "4482"
    },
    {
        "raw_code": "def generate_class_files\n    template_file = @template_dir + 'class.rhtml'\n    template_file = @template_dir + 'classpage.rhtml' unless\n      template_file.exist?\n    return unless template_file.exist?\n    debug_msg \"Generating class documentation in #{@outputdir}\"\n\n    current = nil\n\n    @classes.each do |klass|\n      current = klass\n\n      generate_class klass, template_file\n    end",
        "comment": " Generate a documentation file for each class and module",
        "label": "What",
        "id": "16462"
    },
    {
        "raw_code": "def write_metadata!\n          return if metadata.write!(workdir)\n\n          raise Gitlab::Backup::Cli::Error, 'Failed to write metadata to disk'\n        end",
        "comment": "Write the backup_information.json data to disk",
        "label": "What",
        "id": "1027"
    },
    {
        "raw_code": "def cookies # :doc:\n          request.cookie_jar\n        end",
        "comment": "The cookies of the request that initiated the WebSocket connection. Useful for performing authorization checks.",
        "label": "What",
        "id": "11074"
    },
    {
        "raw_code": "def gitlab_markdown?(filename)\n      MARKDOWN_EXTENSIONS.include?(extension(filename))\n    end",
        "comment": "Public: Determines if a given filename is compatible with GitLab-flavored Markdown.  filename - Filename string to check  Returns boolean",
        "label": "What",
        "id": "1356"
    },
    {
        "raw_code": "def sanitize_exif_if_needed(content, path)\n        exif_sanitizer = Gitlab::Sanitizers::Exif.new\n        exif_sanitizer.clean_existing_path(path, content: content, skip_unallowed_types: true)\n      end",
        "comment": "https://gitlab.com/gitlab-org/gitlab/-/issues/239343",
        "label": "What",
        "id": "3244"
    },
    {
        "raw_code": "def check_suites_for_ref(repo, ref, options = {})\n        paginate \"#{Repository.path repo}/commits/#{ref}/check-suites\", options do |data, last_response|\n          data.check_suites.concat last_response.data.check_suites\n          data.total_count += last_response.data.total_count\n        end",
        "comment": "List check suites for a specific ref  @param repo [Integer, String, Hash, Repository] A GitHub repository @param ref [String] A SHA, branch name, or tag name @param options [Hash] A set of optional filters @option options [Integer] :app_id Filters check suites by GitHub App <tt>id</tt> @option options [String] :check_name Filters checks suites by the <tt>name</tt> of the check run @return [Sawyer::Resource] A hash representing a collection of check suites @see https://developer.github.com/v3/checks/suites/#list-check-suites-for-a-specific-ref @example List check suites for a specific ref result = @client.check_suites_for_ref(\"octocat/Hello-World\", \"7638417db6d59f3c431d3e1f261cc637155684cd\", app_id: 76765) result.total_count # => 1 result.check_suites.count # => 1 result.check_suites[0].id # => 50440400 result.check_suites[0].app.id # => 76765",
        "label": "What",
        "id": "15270"
    },
    {
        "raw_code": "def hooks(repo, options = {})\n        paginate \"#{Repository.path repo}/hooks\", options\n      end",
        "comment": "List repo hooks  Requires authenticated client.  @param repo [Integer, String, Hash, Repository] A GitHub repository. @return [Array<Sawyer::Resource>] Array of hashes representing hooks. @see https://developer.github.com/v3/repos/hooks/#list-hooks @example @client.hooks('octokit/octokit.rb')",
        "label": "What",
        "id": "15341"
    },
    {
        "raw_code": "def down; end\n\n  private\n\n  def with_each_index\n    INDEXES_TO_RENAME.each do |table, indexes|\n      indexes.each do |index_info|\n        columns, old_name, new_name = index_info\n        yield table, columns, old_name, new_name\n      end\n    end",
        "comment": "We have no way of tracking which misnamed indexes existed before the migration, so let's not try to restore the previous, incorrect state.",
        "label": "What",
        "id": "4948"
    },
    {
        "raw_code": "def projects_sort_options_hash\n    options = {\n      sort_value_latest_activity => sort_title_latest_activity,\n      sort_value_name => sort_title_name,\n      sort_value_name_desc => sort_title_name_desc,\n      sort_value_oldest_activity => sort_title_oldest_activity,\n      sort_value_oldest_created => sort_title_oldest_created,\n      sort_value_recently_created => sort_title_recently_created,\n      sort_value_stars_desc => sort_title_most_stars\n    }\n\n    options[sort_value_largest_repo] = sort_title_largest_repo if current_controller?('admin/projects')\n\n    options\n  end",
        "comment": "rubocop: enable Metrics/AbcSize",
        "label": "What",
        "id": "7765"
    },
    {
        "raw_code": "def expect_graphql_error_to_be_created(error_class, match_message = '')\n    resolved = yield\n\n    expect(resolved).to be_instance_of(error_class)\n    expect(resolved.message).to match(match_message)\n  end",
        "comment": "Helps migrate to the new GraphQL interpreter, https://gitlab.com/gitlab-org/gitlab/-/issues/210556",
        "label": "What",
        "id": "8404"
    },
    {
        "raw_code": "def connection_params\n            @connection_params ||= configuration.configuration_hash.dup\n          end",
        "comment": "Return the connection params from `database.yml`  @return [Hash<Symbol => String>]",
        "label": "What",
        "id": "1068"
    },
    {
        "raw_code": "def has_changes?(project)\n      Project.with_push.exists?(project.id)\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6371"
    },
    {
        "raw_code": "def upload_license(license, settings = nil)\n        octokit_warn('The Management Console API will be deprecated in GitHub Enterprise Server 3.15.0, please use the ManageGHES client instead.')\n        conn = faraday_configuration\n\n        params = {}\n        params[:license] = Faraday::UploadIO.new(license, 'binary')\n        params[:password] = @management_console_password\n        params[:settings] = settings.to_json.to_s unless settings.nil?\n\n        @last_response = conn.post('/setup/api/start', params)\n      end",
        "comment": "Uploads a license for the first time  @param license [String] The path to your .ghl license file. @param settings [Hash] A hash configuration of the initial settings.  @see https://docs.github.com/en/enterprise-server@3.4/rest/enterprise-admin/management-console#create-a-github-license @return nil",
        "label": "What",
        "id": "14968"
    },
    {
        "raw_code": "def warnings?\n          @status_set.include?(:success_with_warnings)\n        end",
        "comment": "rubocop: enable Metrics/CyclomaticComplexity rubocop: enable Metrics/PerceivedComplexity",
        "label": "What",
        "id": "2553"
    },
    {
        "raw_code": "def delete_inspected\n      list_inspect.count do |path|\n        File.delete(path)\n      end",
        "comment": "Deletes a list of TODO yaml files which were marked for inspection.  @return [Integer] number of deleted YAML TODO files.  @see #inspect @see #inspect_all",
        "label": "What",
        "id": "3878"
    },
    {
        "raw_code": "def default(value: 50, variant: :primary)\n      render Pajamas::ProgressComponent.new(value: value, variant: variant)\n    end",
        "comment": "Progress ---  See its design reference [here](https://design.gitlab.com/components/progress-bar).  @param value range { min: 0, max: 100, step: 1 } @param variant select {{ Pajamas::ProgressComponent::VARIANT_OPTIONS }}",
        "label": "What",
        "id": "8210"
    },
    {
        "raw_code": "def verify_repository_import\n        logger.info(\"== Verifying repository import ==\")\n        expect(imported_project.description).to eq(source_project.description)\n        expect(branches).to match_array(source_branches)\n        expect(commits).to match_array(source_commits)\n      end",
        "comment": "Verify repository imported correctly  @return [void]",
        "label": "What",
        "id": "4377"
    },
    {
        "raw_code": "def os_name\n      os_name = run_command(%w[lsb_release -irs])\n      os_name ||=\n        if File.readable?('/etc/system-release')\n          File.read('/etc/system-release')\n        elsif File.readable?('/etc/debian_version')\n          \"Debian #{File.read('/etc/debian_version')}\"\n        elsif File.readable?('/etc/SuSE-release')\n          File.read('/etc/SuSE-release')\n        elsif os_x_version = run_command(%w[sw_vers -productVersion])\n          \"Mac OS X #{os_x_version}\"\n        elsif File.readable?('/etc/os-release')\n          File.read('/etc/os-release').match(/PRETTY_NAME=\\\"(.+)\\\"/)[1]\n        end",
        "comment": "Check which OS is running  It will primarily use lsb_relase to determine the OS. It has fallbacks to Debian, SuSE, OS X and systems running systemd.",
        "label": "What",
        "id": "1666"
    },
    {
        "raw_code": "def readme(repo, options = {})\n        get \"#{Repository.path repo}/readme\", options\n      end",
        "comment": "Receive the default Readme for a repository  @param repo [Integer, String, Repository, Hash] A GitHub repository @option options [String] :ref name of the Commit/Branch/Tag. Defaults to \u201cmaster\u201d. @return [Sawyer::Resource] The detail of the readme @see https://developer.github.com/v3/repos/contents/#get-the-readme @example Get the readme file for a repo Octokit.readme(\"octokit/octokit.rb\") @example Get the readme file for a particular branch of the repo Octokit.readme(\"octokit/octokit.rb\", :query => {:ref => 'some-other-branch'})",
        "label": "What",
        "id": "15196"
    },
    {
        "raw_code": "def has_go_to_project_link?(gh_project_name)\n            within_element('project-import-row', source_project: gh_project_name) do\n              has_element?('go-to-project-link')\n            end",
        "comment": "Check Go to project button present  @param [String] gh_project_name @return [Boolean]",
        "label": "What",
        "id": "4271"
    },
    {
        "raw_code": "def disable_dev_shm?\n        running_in_ci? || enabled?(ENV['CHROME_DISABLE_DEV_SHM'], default: false)\n      end",
        "comment": "Disable /dev/shm use in CI. See https://gitlab.com/gitlab-org/gitlab/issues/4252",
        "label": "What",
        "id": "4456"
    },
    {
        "raw_code": "def is_namespace?(object)\n        object.is_a?(CodeObjects::NamespaceObject)\n      end",
        "comment": "@return [Boolean] whether an object is a namespace",
        "label": "What",
        "id": "426"
    },
    {
        "raw_code": "def ensure_gitlab_shell_secret!\n    secret_file = rails_gitlab_shell_secret\n    shell_link = gitlab_shell_secret_file\n\n    unless File.size?(secret_file)\n      File.write(secret_file, SecureRandom.hex(16))\n    end",
        "comment": "Taken from Gitlab::Shell.generate_and_link_secret_token",
        "label": "What",
        "id": "8424"
    },
    {
        "raw_code": "def active_support_config\n          {\n            redis: pool,\n            pool: false,\n            compress: Gitlab::Utils.to_boolean(ENV.fetch('ENABLE_REDIS_CACHE_COMPRESSION', '1')),\n            namespace: CACHE_NAMESPACE,\n            expires_in: default_ttl_seconds\n          }\n        end",
        "comment": "Configuration options for Rails.cache, not Gitlab::Redis::Cache  Full list of options: https://api.rubyonrails.org/classes/ActiveSupport/Cache/RedisCacheStore.html#method-c-new pool argument event not documented in the link above is handled by RedisCacheStore see: https://github.com/rails/rails/blob/593893c901f87b4ed205751f72df41519b4d2da3/activesupport/lib/active_support/cache/redis_cache_store.rb#L165 and https://github.com/rails/rails/blob/ad790cb2f6bc724a89e4266b505b3c57d5089dae/activesupport/lib/active_support/cache.rb#L206",
        "label": "What",
        "id": "1888"
    },
    {
        "raw_code": "def before_remove_branch\n    expire_branches_cache\n\n    repository_event(:remove_branch)\n  end",
        "comment": "Runs code before removing an existing branch.",
        "label": "What",
        "id": "7144"
    },
    {
        "raw_code": "def top_level_method\n          ^^^^^^^^^^^^^^^^^^^^ Methods defined in rake tasks share the same namespace and can cause collisions. Please define it in a bounded contexts module in a separate Ruby file. For example, Search::RakeTask::<Namespace>. See https://github.com/rubocop/rubocop-rake/issues/42\n            'top level'\n          end",
        "comment": "Top-level method - also gets an offense",
        "label": "What",
        "id": "8256"
    },
    {
        "raw_code": "def get_codeql_database_for_repo(repo, language, options = {})\n        get \"#{Repository.path repo}/code-scanning/codeql/databases/#{language}\", options\n      end",
        "comment": "Gets a CodeQL database for a language in a repository  @param repo [Integer, String, Repository, Hash] A GitHub repository @param language [String]  @return [Sawyer::Resource] CodeQl Default Setup Configuration Information @see https://docs.github.com/en/rest/code-scanning/code-scanning#get-a-codeql-database-for-a-repository",
        "label": "What",
        "id": "15364"
    },
    {
        "raw_code": "def initialize(\n      type: :search,\n      **html_options\n    )\n      @type = filter_attribute(type.to_sym, TYPE_OPTIONS, default: :search)\n      @html_options = html_options\n    end",
        "comment": "@param [Symbol] type @param [Hash] html_options",
        "label": "What",
        "id": "5384"
    },
    {
        "raw_code": "def check\n        if enabled && @checkpoint_thread.nil?\n          logger.debug(\"starting plugin check\")\n          @checkpoint_thread = Thread.new do\n            Thread.current.abort_on_exception = false\n            if Thread.current.respond_to?(:report_on_exception=)\n              Thread.current.report_on_exception = false\n            end",
        "comment": "Run check  @return [self]",
        "label": "What",
        "id": "9242"
    },
    {
        "raw_code": "def self.compare_disk_size(machine, disk_config, defined_disk)\n          # Hyper-V returns disk size in bytes\n          requested_disk_size = disk_config.size\n          disk_actual = machine.provider.driver.get_disk(defined_disk[\"Path\"])\n          defined_disk_size = disk_actual[\"Size\"]\n\n          if defined_disk_size > requested_disk_size\n            if File.extname(disk_actual[\"Path\"]) == \".vhdx\"\n              # VHDX formats can be shrunk\n              return true\n            else\n              machine.ui.warn(I18n.t(\"vagrant.cap.configure_disks.shrink_size_not_supported\", name: disk_config.name))\n              return false\n            end",
        "comment": "Check to see if current disk is configured based on defined_disks  @param [Kernel_V2::VagrantConfigDisk] disk_config @param [Hash] defined_disk @return [Boolean]",
        "label": "What",
        "id": "9706"
    },
    {
        "raw_code": "def mock_response(code, body)\n    instance_double(RestClient::Response, code: code, body: body.to_json)\n  end",
        "comment": "Instance double for rest client response  @param code [Integer] @param body [Hash] @return [InstanceDouble]",
        "label": "What",
        "id": "4832"
    },
    {
        "raw_code": "def print_single(vm, ports, target)\n        map = ports.find { |_, guest| \"#{guest}\" == \"#{target}\" }\n        if !present?(map)\n          @env.ui.error(I18n.t(\"port_command.no_matching_port\",\n            port: target,\n          ))\n          return 1\n        end",
        "comment": "Print the host mapping that matches the given guest target. @return [0,1] the exit code",
        "label": "What",
        "id": "9810"
    },
    {
        "raw_code": "def execute\n        in_lock(EXCLUSIVE_LOCK_KEY, ttl: LOCK_TIMEOUT, retries: 1) do\n          destroy_unlocked_job_artifacts\n        end",
        "comment": " Destroy expired job artifacts on GitLab instance  This destroy process cannot run for more than 6 minutes. This is for preventing multiple `ExpireBuildArtifactsWorker` CRON jobs run concurrently, which is scheduled every 7 minutes.",
        "label": "What",
        "id": "5815"
    },
    {
        "raw_code": "def attachments\n      @attachments ||= attachment_nodes.map do |node|\n        attachment_for_node(node)\n      end",
        "comment": "Extracts ActionText::Attachment objects from the HTML fragment:  attachable = ActiveStorage::Blob.first html = %Q(<action-text-attachment sgid=\"#{attachable.attachable_sgid}\" caption=\"Captioned\"></action-text-attachment>) content = ActionText::Content.new(html) content.attachments # => [#<ActionText::Attachment attachable=#<ActiveStorage::Blob...",
        "label": "What",
        "id": "11694"
    },
    {
        "raw_code": "def length_validator_supports_dynamic_length_checks?(validator)\n  validator.options[:minimum].is_a?(Proc) &&\n    validator.options[:maximum].is_a?(Proc)\nend",
        "comment": "frozen_string_literal: true Discard the default Devise length validation from the `User` model. This needs to be discarded because the length validation provided by Devise does not support dynamically checking for min and max lengths. A new length validation has been added to the User model instead, to keep supporting dynamic password length validations, like: validates :password, length: { maximum: proc { password_length.max }, minimum: proc { password_length.min } }, allow_blank: true",
        "label": "What",
        "id": "1291"
    },
    {
        "raw_code": "def write_query?(sql)\n        raise NotImplementedError\n      end",
        "comment": "Determines whether the SQL statement is a write query.",
        "label": "What",
        "id": "13057"
    },
    {
        "raw_code": "def on_if(node)\n          return if allowed_if_condition?(node)\n\n          checked_variable, receiver, method_chain, _method = extract_parts_from_if(node)\n          return unless offending_node?(node, checked_variable, method_chain, receiver)\n\n          body = extract_if_body(node)\n          method_call = receiver.parent\n          return if dotless_operator_call?(method_call) || method_call.double_colon?\n\n          removal_ranges = [begin_range(node, body), end_range(node, body)]\n\n          report_offense(node, method_chain, method_call, *removal_ranges) do |corrector|\n            corrector.replace(receiver, checked_variable.source) if checked_variable.csend_type?\n            corrector.insert_before(method_call.loc.dot, '&') unless method_call.safe_navigation?\n          end",
        "comment": "rubocop:disable Metrics/AbcSize",
        "label": "What",
        "id": "10620"
    },
    {
        "raw_code": "def download(&block)\n    if processed?\n      presentation.download(&block)\n    else\n      raise UnprocessedError\n    end",
        "comment": "Downloads the file associated with this preview's variant. If no block is given, the entire file is read into memory and returned. That'll use a lot of RAM for very large files. If a block is given, then the download is streamed and yielded in chunks. Raises ActiveStorage::Preview::UnprocessedError if the preview has not been processed yet.",
        "label": "What",
        "id": "13634"
    },
    {
        "raw_code": "def using_tmp_keychain(&block)\n      if MUTEX.locked? && MUTEX.owned?\n        optimistic_using_tmp_keychain(&block)\n      else\n        ActiveSupport::Dependencies.interlock.permit_concurrent_loads do\n          MUTEX.synchronize do\n            optimistic_using_tmp_keychain(&block)\n          end",
        "comment": "Allows thread safe switching of temporary keychain files  1. The current thread may use nesting of temporary keychain 2. Another thread needs to wait for the lock to be released",
        "label": "What",
        "id": "1716"
    },
    {
        "raw_code": "def create_approval_rules\n        raise(\"Trying to create approval rules but no rules set!\") unless approval_rules\n\n        rule = { approvals_required: 1, name: \"Approval rule for mr #{title}\" }\n        rule[:user_ids] = approval_rules[:users].map(&:id) if approval_rules[:users]\n        rule[:group_ids] = approval_rules[:group].map(&:full_path) if approval_rules[:groups]\n\n        api_post_to(api_approvals_path, rule)\n      end",
        "comment": "Create approval rules  @return [Hash]",
        "label": "What",
        "id": "4095"
    },
    {
        "raw_code": "def default_page_out_of_bounds_response\n    head :bad_request\n  end",
        "comment": "By default just return a HTTP status code and an empty response",
        "label": "What",
        "id": "6534"
    },
    {
        "raw_code": "def self.count_stack\n      return unless Gitlab::SafeRequestStore.active?\n\n      stack_string = Gitlab::BacktraceCleaner.clean_backtrace(caller).drop(1).join(\"\\n\")\n\n      Gitlab::SafeRequestStore[:stack_counter] ||= {}\n\n      count = Gitlab::SafeRequestStore[:stack_counter][stack_string] || 0\n      Gitlab::SafeRequestStore[:stack_counter][stack_string] = count + 1\n    end",
        "comment": "Count a stack. Used for n+1 detection",
        "label": "What",
        "id": "1373"
    },
    {
        "raw_code": "def self.remove_hook_for(*names)\n        remove_invocation(*names)\n\n        names.each do |name|\n          singleton_class.undef_method(\"#{name}_generator\")\n          hooks.delete(name)\n        end",
        "comment": "Remove a previously added hook.  remove_hook_for :orm",
        "label": "What",
        "id": "14761"
    },
    {
        "raw_code": "def audio_path(source, options = {})\n        path_to_asset(source, { type: :audio }.merge!(options))\n      end",
        "comment": "Computes the path to an audio asset in the public audios directory. Full paths from the document root will be passed through. Used internally by +audio_tag+ to build the audio path.  audio_path(\"horse\")                                            # => /audios/horse audio_path(\"horse.wav\")                                        # => /audios/horse.wav audio_path(\"sounds/horse.wav\")                                 # => /audios/sounds/horse.wav audio_path(\"/sounds/horse.wav\")                                # => /sounds/horse.wav audio_path(\"http://www.example.com/sounds/horse.wav\")          # => http://www.example.com/sounds/horse.wav",
        "label": "What",
        "id": "11802"
    },
    {
        "raw_code": "def reference_names(target, select_stmt)\n              # Parse all targets to determine what is referenced.\n              fields = fields(target)\n              case fields.count\n              when 0\n                literal_ref_names(target, select_stmt)\n              when 1\n                unqualified_ref_names(fields, select_stmt)\n              else\n                # The target is qualified such as SELECT reference.id\n                field_ref = fields[fields.count - 2]\n                [field_ref.string.sval]\n              end",
        "comment": "Return the reference names used by the given target.  For example: `SELECT users.id` would return ['users'] `SELECT * FROM users, namespaces` would return ['users', 'namespaces']",
        "label": "What",
        "id": "3191"
    },
    {
        "raw_code": "def test_filename_max_size\n    key = \"#{'A' * ActiveSupport::Cache::FileStore::FILENAME_MAX_SIZE}\"\n    path = @cache.send(:normalize_key, key, {})\n    basename = File.basename(path)\n    dirname = File.dirname(path)\n    Dir::Tmpname.create(basename, Dir.tmpdir + dirname) do |tmpname, n, opts|\n      assert File.basename(tmpname + \".lock\").length <= 255, \"Temp filename too long: #{File.basename(tmpname + '.lock').length}\"\n    end",
        "comment": "Test that generated cache keys are short enough to have Tempfile stuff added to them and remain valid",
        "label": "What",
        "id": "14605"
    },
    {
        "raw_code": "def check_unused_block_args(node, key, value)\n          return if node.body.nil?\n\n          value_unused = unused_block_arg_exist?(node, value)\n          key_unused = unused_block_arg_exist?(node, key)\n          return if value_unused && key_unused\n\n          if value_unused\n            message = message('each_key', node.method_name, value.source)\n            unused_range = key.source_range.end.join(value.source_range.end)\n\n            register_each_args_offense(node, message, 'each_key', unused_range)\n          elsif key_unused\n            message = message('each_value', node.method_name, key.source)\n            unused_range = key.source_range.begin.join(value.source_range.begin)\n\n            register_each_args_offense(node, message, 'each_value', unused_range)\n          end",
        "comment": "rubocop:disable Metrics/AbcSize",
        "label": "What",
        "id": "10517"
    },
    {
        "raw_code": "def _Ticks2\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"``\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Ticks2 = \"``\" !\"`\"",
        "label": "What",
        "id": "15786"
    },
    {
        "raw_code": "def find_id_from_database(id, email)\n        id_for_github_id(id) || id_for_github_email(email)\n      end",
        "comment": "Finds a GitLab user ID from the database for a given GitHub user ID or Email.",
        "label": "What",
        "id": "2150"
    },
    {
        "raw_code": "def save!\n        Tempfile.open(@path.basename.to_s, @path.dirname.to_s) do |f|\n          f.binmode\n          f.write(JSON.dump(@data))\n          f.fsync\n          f.chmod(0644)\n          f.close\n          FileUtils.mv(f.path, @path)\n        end",
        "comment": "This saves the state back into the state file.",
        "label": "What",
        "id": "8970"
    },
    {
        "raw_code": "def matches?(kind, name, expected)\n          kind == expected[:kind] && expected[:name_pattern].match?(name)\n        end",
        "comment": "Validates if the given configuration matches the expected value  @param [String] kind The type of configuration to validate @param [String] name The name of the configuration item @param [Object] expected The expected value to match against. See {#EXPECTED_SEQUENCE} above. @return [Boolean] Returns true if the configuration matches the expected value, false otherwise",
        "label": "What",
        "id": "3301"
    },
    {
        "raw_code": "def up\n    add_concurrent_index(\n      :packages_packages,\n      %i[project_id name version],\n      name: INDEX_NAME,\n      unique: true,\n      where: \"package_type = #{PACKAGE_TYPE_ML_MODEL} AND status <> #{PACKAGE_STATUS_PENDING_DESTRUCTION}\"\n    )\n  end",
        "comment": "rubocop:disable Migration/PreventIndexCreation -- Legacy migration",
        "label": "What",
        "id": "4942"
    },
    {
        "raw_code": "def self.from_url(url)\n      Gist.new(URI.parse(url).path[1..])\n    end",
        "comment": "Instantiate {Gist} object from Gist URL @ return [Gist]",
        "label": "What",
        "id": "14872"
    },
    {
        "raw_code": "def self.mount_virtualbox_shared_folder(machine, name, guestpath, options)\n          guest_path = Shellwords.escape(guestpath)\n          mount_type = options[:plugin].capability(:mount_type)\n\n          @@logger.debug(\"Mounting #{name} (#{options[:hostpath]} to #{guestpath})\")\n\n          builtin_mount_type = \"-cit #{mount_type}\"\n          addon_mount_type = \"-t #{mount_type}\"\n\n          mount_options, mount_uid, mount_gid = options[:plugin].capability(:mount_options, name, guest_path, options)\n          mount_command = \"mount #{addon_mount_type} -o #{mount_options} #{name} #{guest_path}\"\n\n          # Create the guest path if it doesn't exist\n          machine.communicate.sudo(\"mkdir -p #{guest_path}\")\n\n          stderr = \"\"\n          result = machine.communicate.sudo(mount_command, error_check: false) do |type, data|\n            stderr << data if type == :stderr\n          end",
        "comment": "Mounts and virtualbox folder on linux guest  @param [Machine] machine @param [String] name of mount @param [String] path of mount on guest @param [Hash] hash of mount options",
        "label": "What",
        "id": "9816"
    },
    {
        "raw_code": "def definition\n    \"class #{full_name}\"\n  end",
        "comment": " The definition of this class, <tt>class MyClassName</tt>",
        "label": "What",
        "id": "16711"
    },
    {
        "raw_code": "def full_messages_for(attribute)\n      where(attribute).map(&:full_message).freeze\n    end",
        "comment": "Returns all the full error messages for a given attribute in an array.  class Person validates_presence_of :name, :email validates_length_of :name, in: 5..30 end  person = Person.create() person.errors.full_messages_for(:name) # => [\"Name is too short (minimum is 5 characters)\", \"Name can't be blank\"]",
        "label": "What",
        "id": "12236"
    },
    {
        "raw_code": "def content_security_policy_report_only(report_only = true, **options)\n        before_action(options) do\n          request.content_security_policy_report_only = report_only\n        end",
        "comment": "Overrides the globally configured `Content-Security-Policy-Report-Only` header:  class PostsController < ApplicationController content_security_policy_report_only only: :index end  Pass `false` to remove the `Content-Security-Policy-Report-Only` header:  class PostsController < ApplicationController content_security_policy_report_only false, only: :index end",
        "label": "What",
        "id": "11258"
    },
    {
        "raw_code": "def authorize_can_read_issuable!\n    action = [:read_, params[:template_type]].join\n\n    authorize_action!(action)\n  end",
        "comment": "User must have: - `read_merge_request` to see merge request templates, or - `read_issue` to see issue templates  Note params[:template_type] has a route constraint to limit it to `merge_request` or `issue`",
        "label": "What",
        "id": "6590"
    },
    {
        "raw_code": "def initialize(io, **_)\n      begin\n        @raw = JSON.load(io)\n      rescue JSON::ParserError => e\n        raise Errors::BoxMetadataMalformed,\n          error: e.to_s\n      end",
        "comment": "Loads the metadata associated with the box from the given IO.  @param [IO] io An IO object to read the metadata from.",
        "label": "What",
        "id": "8839"
    },
    {
        "raw_code": "def build_cache\n        mapping = @project\n          .labels\n          .pluck(:id, :name)\n          .each_with_object({}) do |(id, name), hash|\n            hash[cache_key_for(name)] = id\n          end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2184"
    },
    {
        "raw_code": "def accept_list_item_end(list_item)\n    @in_list_entry[-1] = list_end_for(@list.last)\n  end",
        "comment": " Finishes consumption of +list_item+",
        "label": "What",
        "id": "16340"
    },
    {
        "raw_code": "def suspend(user, options = {})\n        boolean_from_response :put, \"users/#{user}/suspended\", options\n      end",
        "comment": "Suspend a user.  @param user [String] Username of the user to suspend. @return [Boolean] True if suspend was successful, false otherwise. @see https://developer.github.com/enterprise/v3/enterprise-admin/users/#suspend-a-user @example @admin_client.suspend('holman')",
        "label": "What",
        "id": "14962"
    },
    {
        "raw_code": "def up\n    remove_concurrent_partitioned_index_by_name(:ai_usage_events, INDEX_NAME)\n  end",
        "comment": "rubocop:disable Migration/Datetime -- it's a column name",
        "label": "What",
        "id": "4970"
    },
    {
        "raw_code": "def site_packages(root)\n    root/\"lib/pypy#{abi_version}/site-packages\"\n  end",
        "comment": "The HOMEBREW_PREFIX location of site-packages",
        "label": "What",
        "id": "31"
    },
    {
        "raw_code": "def feeds\n        get 'feeds'\n      end",
        "comment": "List Feeds  The feeds returned depend on authentication, see the GitHub API docs for more information.  @return [Array<Sawyer::Resource>] list of feeds @see https://developer.github.com/v3/activity/feeds/#list-feeds",
        "label": "What",
        "id": "15355"
    },
    {
        "raw_code": "def update_project_bot_to_inherit_current_user_external_status\n      return unless target_user.project_bot?\n\n      target_user.update(external: current_user.external?)\n    end",
        "comment": "See https://gitlab.com/gitlab-org/gitlab/-/issues/509324",
        "label": "What",
        "id": "5965"
    },
    {
        "raw_code": "def class_list(root = Registry.root, tree = TreeContext.new)\n  out = String.new(\"\")\n  children = run_verifier(root.children)\n  if root == Registry.root\n    children += @items.select {|o| o.namespace.is_a?(CodeObjects::Proxy) }\n  end",
        "comment": "@return [String] HTML output of the classes to be displayed in the full_list_class template.",
        "label": "What",
        "id": "756"
    },
    {
        "raw_code": "def checksum\n          sha = OpenSSL::Digest.new('SHA256')\n          count = 0\n          chunk = (+'').force_encoding(Encoding::BINARY)\n          file.rewind\n\n          while file.read(SHA_CHUNK_SIZE, chunk)\n            count += 1\n            chunk[pdb_id] = TWENTY_ZEROED_BYTES if count == 1\n            sha.update(chunk)\n          end",
        "comment": "https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PE-COFF.md#portable-pdb-checksum",
        "label": "What",
        "id": "5763"
    },
    {
        "raw_code": "def valid_authenticity_token?(session, encoded_masked_token) # :doc:\n        if !encoded_masked_token.is_a?(String) || encoded_masked_token.empty?\n          return false\n        end",
        "comment": "Checks the client's masked token to see if it matches the session token. Essentially the inverse of `masked_authenticity_token`.",
        "label": "What",
        "id": "11344"
    },
    {
        "raw_code": "def old_to_new(old_line)\n        map_line_number(old_line, from: :old_line, to: :new_line)\n      end",
        "comment": "Find new line number for old line number.",
        "label": "What",
        "id": "2691"
    },
    {
        "raw_code": "def primary?\n        false\n      end",
        "comment": "@see PrimaryRunner @see Vagrant::Action::Builder#primary",
        "label": "What",
        "id": "9297"
    },
    {
        "raw_code": "def sandbox_name\n          return \"gitlab-e2e-sandbox-group-#{sandbox_number}\" if live_env?\n\n          \"e2e-sandbox-#{SecureRandom.hex(6)}\"\n        end",
        "comment": "Top level group name  @return [String]",
        "label": "What",
        "id": "4441"
    },
    {
        "raw_code": "def scaled_poll_interval(process_count)\n        process_count * @config[:average_scheduled_poll_interval]\n      end",
        "comment": "Calculates an average poll interval based on the number of known Sidekiq processes. This minimizes a single point of failure by dispersing check-ins but without taxing Redis if you run many Sidekiq processes.",
        "label": "What",
        "id": "5171"
    },
    {
        "raw_code": "def duplicated_expressions?(node, expressions)\n          unique_expressions = expressions.uniq\n          return false unless expressions.size >= 1 && unique_expressions.one?\n\n          unique_expression = unique_expressions.first\n          return true unless unique_expression&.assignment?\n\n          lhs = unique_expression.child_nodes.first\n          node.condition.child_nodes.none? { |n| n.source == lhs.source if n.variable? }\n        end",
        "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10490"
    },
    {
        "raw_code": "def queue_redis_migration_job(job_name)\n          RedisMigrationWorker.fetch_migrator!(job_name)\n          RedisMigrationWorker.perform_async(job_name, SCAN_START_CURSOR)\n        end",
        "comment": "Check if the migration exists before enqueueing the worker",
        "label": "What",
        "id": "3171"
    },
    {
        "raw_code": "def get_stats_v2(group_id, opts = {})\n      data, _status_code, _headers = get_stats_v2_with_http_info(group_id, opts)\n      data\n    end",
        "comment": "Stats of events received for the group @param group_id [Integer] ID of the group @param [Hash] opts the optional parameters @return [Array<StatsObject>]",
        "label": "What",
        "id": "1018"
    },
    {
        "raw_code": "def instance\n            Gitlab::SafeRequestStore[:web_hook_recursion_detection_uuid] ||= new\n          end",
        "comment": "Back the Singleton with RequestStore so it is isolated to this request.",
        "label": "What",
        "id": "2804"
    },
    {
        "raw_code": "def base_name\n          @base_name ||= if base = name.to_s.split(\"::\").first\n            base.underscore\n          end",
        "comment": "Sets the base_name taking into account the current class namespace.  Rails::Command::TestCommand.base_name # => 'rails'",
        "label": "What",
        "id": "14709"
    },
    {
        "raw_code": "def self.noteable_types\n    %w[MergeRequest Issue Commit Snippet WikiPage::Meta]\n  end",
        "comment": "Names of all implementers of `Noteable` that support discussions.",
        "label": "What",
        "id": "6875"
    },
    {
        "raw_code": "def should_unstick?(merge_request)\n      !merge_request.merge_exclusive_lease.exists?\n    end",
        "comment": "Check if MR is still in the process of merging so we don't interrupt the process. MergeRequest::MergeService will acquire a lease when merging and keep it for 15 minutes so we can check if the lease still exists and we can consider the MR as still merging.",
        "label": "What",
        "id": "5574"
    },
    {
        "raw_code": "def config_status\n        octokit_warn('The Management Console API will be deprecated in GitHub Enterprise Server 3.15.0, please use the ManageGHES client instead.')\n        get '/setup/api/configcheck', password_hash\n      end",
        "comment": "Get information about the Enterprise installation  @return [Sawyer::Resource] The installation information",
        "label": "What",
        "id": "14971"
    },
    {
        "raw_code": "def assert_notification(pattern, payload = nil, &block)\n        notifications = capture_notifications(pattern, &block)\n        assert_not_empty(notifications, \"No #{pattern} notifications were found\")\n\n        return notifications.first if payload.nil?\n\n        notification = notifications.find { |notification| notification.payload.slice(*payload.keys) == payload }\n        assert_not_nil(notification, \"No #{pattern} notification with payload #{payload} was found\")\n\n        notification\n      end",
        "comment": "Assert a notification was emitted with a given +pattern+ and optional +payload+.  You can assert that a notification was emitted by passing a pattern, which accepts either a string or regexp, an optional payload, and a block. While the block is executed, if a matching notification is emitted, the assertion will pass and the notification will be returned.  Note that the payload is matched as a subset, meaning that the notification must contain at least the specified keys and values, but may contain additional ones.  assert_notification(\"post.submitted\", title: \"Cool Post\") do post.submit(title: \"Cool Post\", body: \"Cool Body\") # => emits matching notification end  Using the returned notification, you can make more customized assertions.  notification = assert_notification(\"post.submitted\", title: \"Cool Post\") do ActiveSupport::Notifications.instrument(\"post.submitted\", title: \"Cool Post\", body: Body.new(\"Cool Body\")) end  assert_instance_of(Body, notification.payload[:body]) ",
        "label": "What",
        "id": "14539"
    },
    {
        "raw_code": "def non_authorized_planner_groups\n        entity.self_and_descendants.select(:id)\n          .id_not_in(authorized_planner_groups)\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5667"
    },
    {
        "raw_code": "def diff_paths\n          diff_files.flat_map(&:paths).uniq\n        end",
        "comment": "This is both the new and old paths for the diff_file",
        "label": "What",
        "id": "2721"
    },
    {
        "raw_code": "def available_artifacts?\n      (!artifacts_expired? || pipeline.artifacts_locked?) && job_artifacts_archive&.exists?\n    end",
        "comment": "This method is similar to #artifacts? but it includes the artifacts locking mechanics. A new method was created to prevent breaking existing behavior and avoid introducing N+1s.",
        "label": "What",
        "id": "7538"
    },
    {
        "raw_code": "def expanded_path(rel_path)\n        Pathname.new(rel_path).expand_path(@machine.env.root_path)\n      end",
        "comment": "Utilities",
        "label": "What",
        "id": "9872"
    },
    {
        "raw_code": "def find_class_named_from(name, from)\n    from = find_class_named from unless RDoc::Context === from\n\n    until RDoc::TopLevel === from do\n      return nil unless from\n\n      klass = from.find_class_named name\n      return klass if klass\n\n      from = from.parent\n    end",
        "comment": " Finds the class with +name+ starting in namespace +from+",
        "label": "What",
        "id": "15863"
    },
    {
        "raw_code": "def fabricate_group!(group_name: nil)\n        Page::Main::Menu.perform(&:go_to_groups)\n        Page::Dashboard::Groups.perform do |groups|\n          groups.click_new_group\n\n          Page::Group::New.perform do |group_new|\n            group_new.click_create_group\n\n            group_new.set_path(group_name)\n\n            group_new.create\n          end",
        "comment": "Fabricate a Group using the UI from the Groups Dashboard page @param [String] group_name @return [Page::Group::New]",
        "label": "What",
        "id": "4174"
    },
    {
        "raw_code": "def _HtmlBlockCloseTh\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseTh = \"<\" Spnl \"/\" (\"th\" | \"TH\") Spnl \">\"",
        "label": "What",
        "id": "15714"
    },
    {
        "raw_code": "def great_job\n    report = RDoc::Markup::Document.new\n\n    report << RDoc::Markup::Paragraph.new('100% documentation!')\n    report << RDoc::Markup::Paragraph.new('Great Job!')\n\n    report\n  end",
        "comment": " A report that says you did a great job!",
        "label": "What",
        "id": "15994"
    },
    {
        "raw_code": "def alias_attribute(new_name, old_name)\n        super\n\n        if @alias_attributes_mass_generated\n          ActiveSupport::CodeGenerator.batch(generated_attribute_methods, __FILE__, __LINE__) do |code_generator|\n            generate_alias_attribute_methods(code_generator, new_name, old_name)\n          end",
        "comment": "Allows you to make aliases for attributes.  class Person < ActiveRecord::Base alias_attribute :nickname, :name end  person = Person.create(name: 'Bob') person.name     # => \"Bob\" person.nickname # => \"Bob\"  The alias can also be used for querying:  Person.where(nickname: \"Bob\") # SELECT \"people\".* FROM \"people\" WHERE \"people\".\"name\" = \"Bob\"",
        "label": "What",
        "id": "12357"
    },
    {
        "raw_code": "def client_middleware\n      @client_chain ||= config.client_middleware.copy_for(self)\n      yield @client_chain if block_given?\n      @client_chain\n    end",
        "comment": "Allow the middleware to be different per-capsule. Avoid if possible and add middleware globally so all capsules share the same chains. Easier to debug that way.",
        "label": "What",
        "id": "5105"
    },
    {
        "raw_code": "def prepare_async_foreign_key_validation(table_name, column_name = nil, name: nil)\n          ensure_async_constraint_validation_is_enabled do\n            fk_name = name || concurrent_foreign_key_name(table_name, column_name)\n\n            unless foreign_key_exists?(table_name, name: fk_name)\n              raise missing_schema_object_message(table_name, \"foreign key\", fk_name)\n            end",
        "comment": "Prepares a foreign key for asynchronous validation.  Stores the FK information in the postgres_async_foreign_key_validations table to be executed later. ",
        "label": "What",
        "id": "3060"
    },
    {
        "raw_code": "def title=(title)\n    @cache[:title] = title\n  end",
        "comment": " Sets the title page for this RDoc store.",
        "label": "What",
        "id": "15894"
    },
    {
        "raw_code": "def commit_message(version)\n        \"Copy commit #{version.sha} from issue #{issue.to_reference(full: true)}\"\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6088"
    },
    {
        "raw_code": "def remove_remaining_deploy_keys_projects\n      source_project.deploy_keys_projects.destroy_all # rubocop: disable Cop/DestroyAll\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5931"
    },
    {
        "raw_code": "def merge(other)\n      self.class.new.tap do |result|\n        result.merge!(self)\n        result.merge!(other)\n      end",
        "comment": "Merge one registry with another and return a completely new registry. Note that the result cache is completely busted, so any gets on the new registry will result in a cache miss.",
        "label": "What",
        "id": "8750"
    },
    {
        "raw_code": "def marshal_dump\n    [\n      MARSHAL_VERSION,\n      @relative_name,\n      @parser,\n      parse(@comment),\n    ]\n  end",
        "comment": " Dumps this TopLevel for use by ri.  See also #marshal_load",
        "label": "What",
        "id": "16727"
    },
    {
        "raw_code": "def self.string(s)\n          [s.length].pack(\"N\") + s\n        end",
        "comment": "Encodes given string  @param [String] s String to encode @return [String]",
        "label": "What",
        "id": "9172"
    },
    {
        "raw_code": "def disable?\n      value.in?(%w[0 0.0 false])\n    end",
        "comment": "Note: `key` is NOT considered - setting to a percentage to 0 is the same as disabling.",
        "label": "What",
        "id": "5526"
    },
    {
        "raw_code": "def generate_plugin_set(*args)\n      plugin_path = args.detect{|i| i.is_a?(Pathname) } || plugin_gem_path\n      skip = args.detect{|i| i.is_a?(Array) } || []\n      plugin_set = PluginSet.new\n      @logger.debug(\"Generating new plugin set instance. Skip gems - #{skip}\")\n      Dir.glob(plugin_path.join('specifications/*.gemspec').to_s).each do |spec_path|\n        spec = Gem::Specification.load(spec_path)\n        desired_spec_path = File.join(spec.gem_dir, \"#{spec.name}.gemspec\")\n        # Vendor set requires the spec to be within the gem directory. Some gems will package their\n        # spec file, and that's not what we want to load.\n        if !File.exist?(desired_spec_path) || !FileUtils.cmp(spec.spec_file, desired_spec_path)\n          File.write(desired_spec_path, spec.to_ruby)\n        end",
        "comment": "Generate the plugin resolver set. Optionally provide specification names (short or full) that should be ignored  @param [Pathname] path to plugins @param [Array<String>] gems to skip @return [PluginSet]",
        "label": "What",
        "id": "8908"
    },
    {
        "raw_code": "def ==(o)\n      return true if self.equal?(o)\n      self.class == o.class &&\n          id == o.id &&\n          project == o.project &&\n          title == o.title &&\n          actor == o.actor &&\n          count == o.count &&\n          user_count == o.user_count &&\n          last_seen == o.last_seen &&\n          first_seen == o.first_seen &&\n          status == o.status\n    end",
        "comment": "Checks equality by comparing each attribute. @param [Object] Object to be compared",
        "label": "What",
        "id": "939"
    },
    {
        "raw_code": "def remove_collaborator(repo, collaborator, options = {})\n        boolean_from_response :delete, \"#{Repository.path repo}/collaborators/#{collaborator}\", options\n      end",
        "comment": "Remove collaborator from repo.  Requires authenticated client.  @param repo [Integer, String, Hash, Repository] A GitHub repository. @param collaborator [String] Collaborator GitHub username to remove. @return [Boolean] True if collaborator removed, false otherwise. @see https://developer.github.com/v3/repos/collaborators/#remove-user-as-a-collaborator @example @client.remove_collaborator('octokit/octokit.rb', 'holman') @example @client.remove_collab('octokit/octokit.rb', 'holman')",
        "label": "What",
        "id": "15147"
    },
    {
        "raw_code": "def ok?\n        # We don't make `@ok` an attr_reader, because we don't want to confusingly shadow the class method `.ok`\n        @ok\n      end",
        "comment": "The `ok?` attribute is true if the Result was constructed with .ok, and false if it was constructed with .err  \"#ok?\" corresponds to \"is_ok\" in Rust. @return [Boolean]",
        "label": "What",
        "id": "2378"
    },
    {
        "raw_code": "def remove_reference(table_name, ref_name, foreign_key: false, polymorphic: false, **options)\n        conditional_options = options.slice(:if_exists, :if_not_exists)\n\n        if foreign_key\n          reference_name = Base.pluralize_table_names ? ref_name.to_s.pluralize : ref_name\n          if foreign_key.is_a?(Hash)\n            foreign_key_options = foreign_key.merge(conditional_options)\n          else\n            foreign_key_options = { to_table: reference_name, **conditional_options }\n          end",
        "comment": "Removes the reference(s). Also removes a +type+ column if one exists.  ====== Remove the reference  remove_reference(:products, :user, index: false)  ====== Remove polymorphic reference  remove_reference(:products, :supplier, polymorphic: true)  ====== Remove the reference with a foreign key  remove_reference(:products, :user, foreign_key: true) ",
        "label": "What",
        "id": "13162"
    },
    {
        "raw_code": "def dump_pending(*); end\n\n      # The BEGIN/END comments are used by `spec_runner.rake` to determine what\n      # output goes where in the final parallelized output, and should not be\n      # removed!\n      def dump_failures(notification)\n        return if notification.failure_notifications.empty?\n\n        output.puts '# FAILURES BEGIN'\n        notification.failure_notifications.each do |failure|\n          output.puts failure.fully_formatted('*', colorizer)\n        end\n        output.puts\n        output.puts '# FAILURES END'\n      end",
        "comment": "Don't show pending tests",
        "label": "What",
        "id": "10705"
    },
    {
        "raw_code": "def safe_external_url\n    return unless self.external_url.present?\n\n    new_external_url = Addressable::URI.parse(self.external_url)\n\n    if Gitlab::Utils::SanitizeNodeLink::UNSAFE_PROTOCOLS.include?(new_external_url.normalized_scheme)\n      errors.add(:external_url, \"#{new_external_url.normalized_scheme} scheme is not allowed\")\n    end",
        "comment": "We deliberately avoid using AddressableUrlValidator to allow users to update their environments even if they have misconfigured `environment:url` keyword. The external URL is presented as a clickable link on UI and not consumed in GitLab internally, thus we sanitize the URL before the persistence to make sure the rendered link is XSS safe. See https://gitlab.com/gitlab-org/gitlab/-/issues/337417",
        "label": "What",
        "id": "7036"
    },
    {
        "raw_code": "def process_configured_plugins\n      return if !Vagrant.plugins_enabled?\n      errors = vagrantfile.config.vagrant.validate(nil)\n      if !Array(errors[\"vagrant\"]).empty?\n        raise Errors::ConfigInvalid,\n          errors: Util::TemplateRenderer.render(\n            \"config/validation_failed\",\n            errors: {vagrant: errors[\"vagrant\"]}\n          )\n      end",
        "comment": "Check for any local plugins defined within the Vagrantfile. If found, validate they are available. If they are not available, request to install them, or raise an exception  @return [Hash] plugin list for loading",
        "label": "What",
        "id": "8877"
    },
    {
        "raw_code": "def _EmptyTitle\n    _tmp = match_string(\"\")\n    set_failed_rule :_EmptyTitle unless _tmp\n    return _tmp\n  end",
        "comment": "EmptyTitle = \"\"",
        "label": "What",
        "id": "15780"
    },
    {
        "raw_code": "def diff\n    return render_404 unless page\n\n    apply_diff_view_cookie!\n\n    @diffs = page.diffs(diff_options)\n    @diff_notes_disabled = true\n\n    render 'shared/wikis/diff'\n  end",
        "comment": "rubocop:enable Gitlab/ModuleWithInstanceVariables rubocop:disable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "6569"
    },
    {
        "raw_code": "def migrations_paths\n        configuration_hash[:migrations_paths]\n      end",
        "comment": "The migrations paths for a database configuration. If the `migrations_paths` key is present in the config, `migrations_paths` will return its value.",
        "label": "What",
        "id": "13291"
    },
    {
        "raw_code": "def initialize(request)\n        @request = request\n      end",
        "comment": "@param [ActionDispatch::Request] request",
        "label": "What",
        "id": "2330"
    },
    {
        "raw_code": "def blank?\n    false\n  end",
        "comment": "No Date is blank:  Date.today.blank? # => false  @return [false]",
        "label": "What",
        "id": "14111"
    },
    {
        "raw_code": "def source_project_url\n        @source_group_url ||= \"#{source_gitlab_address}/#{source_project.full_path}\"\n      end",
        "comment": "Source project url  @return [String]",
        "label": "What",
        "id": "4391"
    },
    {
        "raw_code": "def initialize(collaborator, project, client)\n          @collaborator = collaborator\n          @project = project\n          @client = client\n          @members_finder = ::MembersFinder.new(project, project.creator)\n        end",
        "comment": "collaborator - An instance of `Gitlab::GithubImport::Representation::Collaborator` project - An instance of `Project` client - An instance of `Gitlab::GithubImport::Client`",
        "label": "What",
        "id": "2190"
    },
    {
        "raw_code": "def output_path\n        @output_path ||= File.join(@output_dir, test_type.to_s).tap { |path| FileUtils.mkdir_p(path) }\n      end",
        "comment": "Path for specific test type output  @return [String]",
        "label": "What",
        "id": "8117"
    },
    {
        "raw_code": "def self.cache_users_mapping(project_id, mapping)\n      cache_class.write_multiple(mapping, key_prefix: jira_user_key_prefix(project_id))\n    end",
        "comment": "Caches the mapping of jira_account_id -> gitlab user id project_id - id of a project mapping - hash in format of jira_account_id -> gitlab user id",
        "label": "What",
        "id": "1662"
    },
    {
        "raw_code": "def find_routes(req)\n        path_info = req.path_info\n        routes = filter_routes(path_info).concat custom_routes.find_all { |r|\n          r.path.match?(path_info)\n        }\n\n        if req.head?\n          routes = match_head_routes(routes, req)\n        else\n          routes.select! { |r| r.matches?(req) }\n        end",
        "comment": "Besides the patch, this method is a duplicate for the original method defined in Rails: https://github.com/rails/rails/blob/v7.0.5/actionpack/lib/action_dispatch/journey/router.rb#L109-L132 See https://github.com/rails/rails/issues/47244",
        "label": "What",
        "id": "1299"
    },
    {
        "raw_code": "def delete_session(env, sid, options)\n        @cache.delete(cache_key(sid.private_id))\n        @cache.delete(cache_key(sid.public_id))\n        generate_sid\n      end",
        "comment": "Remove a session from the cache.",
        "label": "What",
        "id": "11544"
    },
    {
        "raw_code": "def validate_options!(_)\n      raise ArgumentError, \"Param `partition_id` is not allowed\" if params[:partition_id]\n    end",
        "comment": "rubocop:disable Gitlab/NoCodeCoverageComment :nocov: Tested in FOSS and fully overridden and tested in EE",
        "label": "What",
        "id": "5802"
    },
    {
        "raw_code": "def self.inject_secrets(desired_config_array:, env_secret_name:, file_secret_name:)\n                volume = {\n                  name: VARIABLES_VOLUME_NAME,\n                  projected: {\n                    defaultMode: VARIABLES_VOLUME_DEFAULT_MODE,\n                    sources: [{ secret: { name: file_secret_name } }]\n                  }\n                }\n\n                volume_mount = {\n                  name: VARIABLES_VOLUME_NAME,\n                  mountPath: VARIABLES_VOLUME_PATH\n                }\n\n                env_from = [{ secretRef: { name: env_secret_name } }]\n\n                pod_spec = find_pod_spec(desired_config_array)\n                pod_spec.fetch(:volumes) << volume unless file_secret_name.empty?\n\n                pod_spec.fetch(:initContainers).each do |init_container|\n                  init_container.fetch(:volumeMounts) << volume_mount unless file_secret_name.empty?\n                  init_container[:envFrom] = env_from unless env_secret_name.empty?\n                end",
        "comment": "@param [Array<Hash>] desired_config_array @param [String] env_secret_name @param [String] file_secret_name @return [void]",
        "label": "What",
        "id": "3337"
    },
    {
        "raw_code": "def projects\n      scope = limit_projects\n      scope = scope.non_archived unless filters[:include_archived]\n\n      scope.search(query, include_namespace: true, use_minimum_char_limit: false)\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "1594"
    },
    {
        "raw_code": "def caveats\n    <<~EOS\n      This formula provides only the `vcpkg` executable. To use vcpkg:\n        git clone https://github.com/microsoft/vcpkg \"$HOME/vcpkg\"\n        export VCPKG_ROOT=\"$HOME/vcpkg\"\n    EOS\n  end",
        "comment": "This is specific to the way we install only the `vcpkg` tool.",
        "label": "What",
        "id": "51"
    },
    {
        "raw_code": "def x(a, b)\n        y\n      end",
        "comment": "comment",
        "label": "What",
        "id": "10866"
    },
    {
        "raw_code": "def validate(machine)\n        errors = _detected_errors\n\n        if @sensitive && (!@sensitive.is_a?(Array) && !@sensitive.is_a?(String))\n          errors << I18n.t(\"vagrant.config.root.sensitive_bad_type\")\n        end",
        "comment": "Validate the configuration  @param [Vagrant::Machine, NilClass] machine Machine instance or nil @return [Hash]",
        "label": "What",
        "id": "9431"
    },
    {
        "raw_code": "def each(&block)\n        all.each(&block)\n      end",
        "comment": "@group Accessing Objects in the Registry Iterates over {all} with no arguments",
        "label": "What",
        "id": "70"
    },
    {
        "raw_code": "def apply_min_access_level(groups)\n      return groups unless params[:shared_min_access_level]\n\n      groups.where('project_group_links.group_access >= ?', params[:shared_min_access_level])\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "8021"
    },
    {
        "raw_code": "def dasherize(underscored_word)\n      underscored_word.tr(\"_\", \"-\")\n    end",
        "comment": "Replaces underscores with dashes in the string.  dasherize('puni_puni') # => \"puni-puni\"",
        "label": "What",
        "id": "14470"
    },
    {
        "raw_code": "def self.from_api_response(review, additional_data = {})\n          user = Representation::User.from_api_response(review[:user]) if review[:user]\n\n          new(\n            merge_request_id: review[:merge_request_id],\n            merge_request_iid: review[:merge_request_iid],\n            author: user,\n            note: review[:body],\n            review_type: review[:state],\n            submitted_at: review[:submitted_at],\n            review_id: review[:id]\n          )\n        end",
        "comment": "Builds a PullRequestReview from a GitHub API response.  review - An instance of `Hash` containing the note details.",
        "label": "What",
        "id": "2241"
    },
    {
        "raw_code": "def workspace_did_change_watched_files(changes)\n        if (changed_config_file = changed_config_file(changes))\n          @runtime_adapter.reload_config\n\n          ::RuboCop::LSP::Logger.log(<<~MESSAGE, prefix: '[RuboCop]')\n            Re-initialized RuboCop LSP addon #{::RuboCop::Version::STRING} due to #{changed_config_file} change.\n          MESSAGE\n        end",
        "comment": "rubocop:enable Metrics/MethodLength",
        "label": "What",
        "id": "10732"
    },
    {
        "raw_code": "def fetch_root_templates_project(namespace)\n        if namespace.is_a?(::Namespaces::ProjectNamespace)\n          namespace.project\n        elsif namespace.is_a?(::Group)\n          Project.find(namespace.file_template_project_id)\n        end",
        "comment": "When we are at project level we return the project itself to fetch the description templates. When we are at group level we fetch first found file_template_project_id from the namespace or its ancestors",
        "label": "What",
        "id": "6192"
    },
    {
        "raw_code": "def vulnerability_alerts_enabled?(repo, options = {})\n        boolean_from_response(:get, \"#{Repository.path repo}/vulnerability-alerts\", options)\n      end",
        "comment": "Check to see if vulnerability alerts are enabled for a repository  The authenticated user must have admin access to the repository.  @param repo [Integer, String, Hash, Repository] A GitHub repository. @return [Boolean] True if vulnerability alerts are enabled, false otherwise. @see https://docs.github.com/en/rest/reference/repos#check-if-vulnerability-alerts-are-enabled-for-a-repository  @example @client.vulnerability_alerts_enabled?(\"octokit/octokit.rb\")",
        "label": "What",
        "id": "15172"
    },
    {
        "raw_code": "def mock_app(base=Sinatra::Base, &block)\n    @app = Sinatra.new(base, &block)\n  end",
        "comment": "Sets up a Sinatra::Base subclass defined with the block given. Used in setup or individual spec methods to establish the application.",
        "label": "What",
        "id": "8708"
    },
    {
        "raw_code": "def \\#{unsafe_method}(*params, &block)\n            to_str.\\#{unsafe_method}(*params, &block)\n          end",
        "comment": "EXAMPLE: def capitalize(*params, &block) to_str.capitalize(*params, &block) end",
        "label": "What",
        "id": "10858"
    },
    {
        "raw_code": "def gitignore_template(template_name, options = {})\n        get \"gitignore/templates/#{template_name}\", options\n      end",
        "comment": "Get a gitignore template.  Use the raw {http://developer.github.com/v3/media/ media type} to get the raw contents.  @param template_name [String] Name of the template. Template names are case sensitive, make sure to use a valid name from the .gitignore_templates list.  @see https://developer.github.com/v3/gitignore/#get-a-single-template  @return [Sawyer::Resource] Gitignore template  @example Get the Ruby gitignore template @client.gitignore_template('Ruby')",
        "label": "What",
        "id": "15055"
    },
    {
        "raw_code": "def notify_about_push(merge_request)\n      return unless @commits.present?\n\n      mr_commit_ids = Set.new(merge_request.commit_shas)\n\n      new_commits, existing_commits = @commits.partition do |commit|\n        mr_commit_ids.include?(commit.id)\n      end",
        "comment": "Add comment about pushing new commits to merge requests and send notification emails ",
        "label": "What",
        "id": "5552"
    },
    {
        "raw_code": "def self.tokenize(source) # :nodoc:\n      require \"strscan\"\n      source = StringScanner.new(source.chomp)\n      tokens = []\n\n      start_re = /<%(?:={1,2}|-|\\#|%)?/m\n      finish_re = /(?:[-=])?%>/m\n\n      while !source.eos?\n        pos = source.pos\n        source.scan_until(/(?:#{start_re}|#{finish_re})/)\n        return [[:PLAIN, source.string]] unless source.matched?\n        len = source.pos - source.matched.bytesize - pos\n\n        case source.matched\n        when start_re\n          tokens << [:TEXT, source.string.byteslice(pos, len)] if len > 0\n          tokens << [:OPEN, source.matched]\n          if source.scan(/(.*?)(?=#{finish_re}|\\z)/m)\n            tokens << [:CODE, source.matched] unless source.matched.empty?\n            tokens << [:CLOSE, source.scan(finish_re)] unless source.eos?\n          else\n            raise NotImplementedError\n          end",
        "comment": "Tokenizes a line of ERB.  This is really just for error reporting and nobody should use it.",
        "label": "What",
        "id": "14220"
    },
    {
        "raw_code": "def with_custom_attributes(collection_or_resource, options = {})\n            options = options.merge(\n              with_custom_attributes: params[:with_custom_attributes] &&\n                can?(current_user, :read_custom_attribute)\n            )\n\n            if options[:with_custom_attributes] && collection_or_resource.is_a?(ActiveRecord::Relation)\n              collection_or_resource = collection_or_resource.includes(:custom_attributes)\n            end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3843"
    },
    {
        "raw_code": "def get_end_token(tk) # :nodoc:\n    case tk[:kind]\n    when :on_lparen\n      token = RDoc::Parser::RipperStateLex::Token.new\n      token[:kind] = :on_rparen\n      token[:text] = ')'\n      token\n    when :on_rparen\n      nil\n    else\n      token = RDoc::Parser::RipperStateLex::Token.new\n      token[:kind] = :on_nl\n      token[:text] = \"\\n\"\n      token\n    end",
        "comment": " Little hack going on here. In the statement:  f = 2*(1+yield)  We see the RPAREN as the next token, so we need to exit early.  This still won't catch all cases (such as \"a = yield + 1\"",
        "label": "What",
        "id": "16075"
    },
    {
        "raw_code": "def resolve_todos_for_target(target, current_user)\n    attributes = attributes_for_target(target)\n\n    resolve_todos(pending_todos([current_user], attributes), current_user)\n\n    GraphqlTriggers.issuable_todo_updated(target)\n  end",
        "comment": "Resolves all todos related to target for the current_user",
        "label": "What",
        "id": "5450"
    },
    {
        "raw_code": "def lfs_objects_relation\n      project.lfs_objects_for_repository_types(nil, :project)\n    end",
        "comment": "Currently we only set repository_type for design repository objects, so push mirroring must send objects with a `nil` repository type - but if the wiki repository uses LFS, its objects will also be sent. This will be addressed by https://gitlab.com/gitlab-org/gitlab/-/issues/250346",
        "label": "What",
        "id": "6004"
    },
    {
        "raw_code": "def site_packages\n    HOMEBREW_PREFIX/\"lib/python#{version.major_minor}/site-packages\"\n  end",
        "comment": "The HOMEBREW_PREFIX location of site-packages.",
        "label": "What",
        "id": "42"
    },
    {
        "raw_code": "def self.realtime(unit = :float_second, &block)\n      time_start = Process.clock_gettime(Process::CLOCK_MONOTONIC, unit)\n      yield\n      Process.clock_gettime(Process::CLOCK_MONOTONIC, unit) - time_start\n    end",
        "comment": "Benchmark realtime in the specified time unit. By default, the returned unit is in seconds.  ActiveSupport::Benchmark.realtime { sleep 0.1 } # => 0.10007  ActiveSupport::Benchmark.realtime(:float_millisecond) { sleep 0.1 } # => 100.07  `unit` can be any of the values accepted by Ruby's `Process.clock_gettime`.",
        "label": "What",
        "id": "13714"
    },
    {
        "raw_code": "def self.load_plugin(name)\n      name = translate_plugin_name(name)\n      return false if options[:ignored_plugins].include?(name)\n      return false if name =~ /^yard-doc-/\n      log.debug \"Loading plugin '#{name}'...\"\n      require name\n      true\n    rescue LoadError => e\n      load_plugin_failed(name, e)\n    end",
        "comment": "Loads an individual plugin by name. It is not necessary to include the +yard-+ plugin prefix here.  @param [String] name the name of the plugin (with or without +yard-+ prefix) @return [Boolean] whether the plugin was successfully loaded",
        "label": "What",
        "id": "152"
    },
    {
        "raw_code": "def initialize(result:)\n        msg = \"Failed to pattern match #{result.ok? ? \"'ok'\" : \"'err'\"} Result \" \\\n          \"containing message of type: #{(result.ok? ? result.unwrap : result.unwrap_err).class.name}\"\n\n        super(msg)\n      end",
        "comment": "@param [Gitlab::Fp::Result] result @return [void]",
        "label": "What",
        "id": "2401"
    },
    {
        "raw_code": "def initialize(params = {})\n    @params = params\n\n    # To prevent N+1 queries when fetching the users of the PendingTodos.\n    @preload_user_association = params.fetch(:preload_user_association, false)\n  end",
        "comment": "users - The list of users to retrieve the todos for. If nil is passed, it won't filter todos based on users params - A Hash containing columns and values to use for filtering todos.",
        "label": "What",
        "id": "7896"
    },
    {
        "raw_code": "def self.register_extensions(*exts, &block)\n        extensions[/\\.(#{exts.join(\"|\")})$/] = block\n      end",
        "comment": "Registers new Annotations File Extensions Rails::SourceAnnotationExtractor::Annotation.register_extensions(\"css\", \"scss\", \"sass\", \"less\", \"js\") { |tag| /\\/\\/\\s*(#{tag}):?\\s*(.*)$/ }",
        "label": "What",
        "id": "14688"
    },
    {
        "raw_code": "def inspect\n      inspected = super\n\n      # mask password\n      inspected.gsub! @password, '*******' if @password\n      if @management_console_password\n        inspected.gsub! @management_console_password, '*******'\n      end",
        "comment": "Text representation of the client, masking tokens and passwords  @return [String]",
        "label": "What",
        "id": "14846"
    },
    {
        "raw_code": "def _HtmlBlockH3\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenH3)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockH3 = HtmlBlockOpenH3 (HtmlBlockH3 | !HtmlBlockCloseH3 .)* HtmlBlockCloseH3",
        "label": "What",
        "id": "15658"
    },
    {
        "raw_code": "def self.append_inventory_configmap(\n                desired_config_array:,\n                name:,\n                namespace:,\n                labels:,\n                annotations:,\n                prepend: false\n              )\n                extra_labels = { \"cli-utils.sigs.k8s.io/inventory-id\": name }\n\n                configmap = {\n                  kind: \"ConfigMap\",\n                  apiVersion: \"v1\",\n                  metadata: {\n                    name: name,\n                    namespace: namespace,\n                    labels: labels.merge(extra_labels),\n                    annotations: annotations\n                  }\n                }\n\n                if prepend\n                  desired_config_array.prepend(configmap)\n                else\n                  desired_config_array.append(configmap)\n                end",
        "comment": "@param [Array] desired_config_array @param [String] name @param [String] namespace @param [Hash<String, String>] labels @param [Hash<String, String>] annotations @param [Boolean] prepend -- If true, prepend the configmap to the desired_config_array @return [void]",
        "label": "What",
        "id": "3341"
    },
    {
        "raw_code": "def copy_assets\n        return unless options.serializer\n        outpath = options.serializer.basepath\n        assets.each do |from, to|\n          to = File.join(outpath, to)\n          log.debug \"Copying asset '#{from}' to '#{to}'\"\n          from += '/.' if File.directory?(from)\n          FileUtils.cp_r(from, to)\n        end",
        "comment": "Copies any assets to the output directory @return [void] @since 0.6.0",
        "label": "What",
        "id": "532"
    },
    {
        "raw_code": "def community_profile(repo, options = {})\n        get \"#{Repository.path repo}/community/profile\", options\n      end",
        "comment": "Get community profile metrics for a repository  @param repo [Integer, String, Hash, Repository] A GitHub repository @return [Sawyer::Resource] Community profile metrics @see https://developer.github.com/v3/repos/community/#retrieve-community-profile-metrics @example Get community profile metrics for octokit/octokit.rb @client.community_profile('octokit/octokit.rb')",
        "label": "What",
        "id": "15225"
    },
    {
        "raw_code": "def issue_template_names_hash\n    Gitlab::Template::IssueTemplate.repository_template_names(project)\n  end",
        "comment": "store issue_template_names as hash",
        "label": "What",
        "id": "7151"
    },
    {
        "raw_code": "def target_branch\n    @target_branch ||= params[:target_branch].presence\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7878"
    },
    {
        "raw_code": "def set_all_networks_to_work\n        @logger.info(\"Setting all networks to 'Work Network'\")\n        command = File.read(File.expand_path(\"../scripts/set_work_network.ps1\", __FILE__))\n        @communicator.execute(command, { shell: :powershell })\n      end",
        "comment": "Sets all networks on the guest to 'Work Network' mode. This is to allow guest access from the host via a private IP on Win7 https://github.com/WinRb/vagrant-windows/issues/63",
        "label": "What",
        "id": "9848"
    },
    {
        "raw_code": "def valid_message?(message)\n      !!catch_and_ignore(:invalid_message_format) { extract_encoded(message) }\n    end",
        "comment": "Checks if a signed message could have been generated by signing an object with the +MessageVerifier+'s secret.  verifier = ActiveSupport::MessageVerifier.new(\"secret\") signed_message = verifier.generate(\"signed message\") verifier.valid_message?(signed_message) # => true  tampered_message = signed_message.chop # editing the message invalidates the signature verifier.valid_message?(tampered_message) # => false",
        "label": "What",
        "id": "13909"
    },
    {
        "raw_code": "def find_error(id)\n        strategy.find_error(id)\n      end",
        "comment": "Finds an error by +id+.  @param id [Integer, String] unique error identifier  @return [Gitlab::ErrorTracking::DetailedError] a detail error",
        "label": "What",
        "id": "2780"
    },
    {
        "raw_code": "def paused?\n      false\n    end",
        "comment": "@return [Boolean] if the queue is currently paused",
        "label": "What",
        "id": "5113"
    },
    {
        "raw_code": "def self.from_json_hash(raw_hash)\n          hash = Representation.symbolize_hash(raw_hash)\n\n          hash[:allowed_to_push_users].map! do |u|\n            Representation::User.from_json_hash(u)\n          end",
        "comment": "Builds a new Protection using a Hash that was built from a JSON payload.",
        "label": "What",
        "id": "2247"
    },
    {
        "raw_code": "def create_cluster\n          Helpers::Spinner.spin(\"performing cluster creation\") do\n            puts execute_shell([\n              \"kind\",\n              \"create\",\n              \"cluster\",\n              \"--name\", name,\n              \"--wait\", \"30s\",\n              \"--config\", ci ? ci_config : default_config\n            ])\n          end",
        "comment": "Create kind cluster  @return [void]",
        "label": "What",
        "id": "4044"
    },
    {
        "raw_code": "def extract_captures(_match)\n        raise NotImplementedError\n      end",
        "comment": "@abstract  @return [Captures]",
        "label": "What",
        "id": "10448"
    },
    {
        "raw_code": "def log(level, message)\n          QA::Runtime::Logger.public_send(level, \"[influxdb exporter]: #{message}\")\n        end",
        "comment": "Print log message  @param [Symbol] level @param [String] message @return [void]",
        "label": "What",
        "id": "4645"
    },
    {
        "raw_code": "def options\n        Octokit::Configurable.keys.to_h { |key| [key, send(key)] }\n      end",
        "comment": "Configuration options @return [Hash]",
        "label": "What",
        "id": "14875"
    },
    {
        "raw_code": "def validate_address(address)\n          Runtime::Address.valid?(address) || raise(\n            ::ArgumentError, \"Configured gitlab address is not a valid url: #{address}\"\n          )\n        end",
        "comment": "Validate if address is a valid url  @param [String] address @return [void]",
        "label": "What",
        "id": "4576"
    },
    {
        "raw_code": "def has_ambiguous_refs?\n    return false unless branch_names.present? && tag_names.present?\n\n    with_slash = []\n    no_slash = []\n    (branch_names + tag_names).each do |ref|\n      slash_index = ref.index('/')\n      if slash_index.present?\n        with_slash << ref.first(slash_index)\n      else\n        no_slash << ref\n      end",
        "comment": "It's possible for a tag name to be a prefix (including slash) of a branch name, or vice versa. For instance, a tag named `foo` means we can't create a tag `foo/bar`, but we _can_ create a branch `foo/bar`.  If we know a repository has no refs of this type (which is the common case) then separating refs from paths - as in ExtractsRef - can be faster.  This method only checks one level deep, so only prefixes that contain no slashes are considered. If a repository has a tag `foo/bar` and a branch `foo/bar/baz`, it will return false.",
        "label": "What",
        "id": "7131"
    },
    {
        "raw_code": "def destroy_related_records(artifacts); end\n\n      # Overriden in EE\n      def after_batch_destroy_hook(artifacts); end\n\n      # using ! here since this can't be called inside a transaction\n      def update_project_statistics!\n        statistics_updates_per_project.each do |project, increments|\n          ProjectStatistics.bulk_increment_statistic(project, Ci::JobArtifact.project_statistics_name, increments)\n        end\n      end\n\n      def statistics_updates_per_project\n        strong_memoize(:statistics_updates_per_project) do\n          result = Hash.new { |updates, project| updates[project] = [] }\n\n          @job_artifacts.each_with_object(result) do |job_artifact, result|\n            next unless job_artifact.project\n\n            increment = Gitlab::Counters::Increment.new(amount: -job_artifact.size.to_i, ref: job_artifact.id)\n            result[job_artifact.project] << increment\n          end\n        end",
        "comment": ":nocov: Overriden in EE",
        "label": "What",
        "id": "5814"
    },
    {
        "raw_code": "def typed_specified?\n      specified?(extract_typed)\n    end",
        "comment": "Was the Sorbet `typed` sigil specified?  @return [Boolean]",
        "label": "What",
        "id": "10158"
    },
    {
        "raw_code": "def create_user(login, email, options = {})\n        options[:login] = login\n        options[:email] = email\n        post 'admin/users', options\n      end",
        "comment": "Create a new user.  @param login [String] The user's username. @param email [String] The user's email address. @see https://developer.github.com/enterprise/v3/enterprise-admin/users#create-a-new-user @example @admin_client.create_user('foobar', 'notreal@foo.bar')",
        "label": "What",
        "id": "14957"
    },
    {
        "raw_code": "def wsl_windows_username\n          if !@_wsl_windows_username\n            result = Util::Subprocess.execute(\"cmd.exe\", \"/c\", \"echo %USERNAME%\")\n            if result.exit_code == 0\n              @_wsl_windows_username = result.stdout.strip\n            end",
        "comment": "Fetch the Windows username currently in use  @return [String, Nil]",
        "label": "What",
        "id": "9217"
    },
    {
        "raw_code": "def _Strong\n\n    _save = self.pos\n    while true # choice\n      _tmp = apply(:_StrongStar)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_StrongUl)\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_Strong unless _tmp\n    return _tmp\n  end",
        "comment": "Strong = (StrongStar | StrongUl)",
        "label": "What",
        "id": "15757"
    },
    {
        "raw_code": "def upload_sarif_data(repo, file, sha, ref, options = {})\n        options[:sarif] = compress_sarif_data(file)\n        options[:commit_sha] = sha\n        options[:ref] = ref\n\n        post \"#{Repository.path repo}/code-scanning/sarifs\", options\n      end",
        "comment": "Uploads SARIF data containing the results of a code scanning analysis  @param repo [Integer, String, Repository, Hash] A GitHub repository @param file [String] Path to the SARIF file to upload @param sha [String] The SHA of the commit to which the analysis you are uploading relates @param ref [String] The full Git reference, formatted as `refs/heads/<branch name>`, `refs/pull/<number>/merge`, or `refs/pull/<number>/head`  @return [Sawyer::Resource] SARIF upload information @see https://docs.github.com/rest/code-scanning#upload-an-analysis-as-sarif-data",
        "label": "What",
        "id": "15374"
    },
    {
        "raw_code": "def option_list\n    result = @options.dup\n    result << \"-o\"       << @rdoc_dir\n    result << \"--main\"   << main      if main\n    result << \"--markup\" << markup    if markup\n    result << \"--title\"  << title     if title\n    result << \"-T\"       << template  if template\n    result << '-f'       << generator if generator\n    result\n  end",
        "comment": " List of options that will be supplied to RDoc",
        "label": "What",
        "id": "15522"
    },
    {
        "raw_code": "def query_parameters_to_string(parameters)\n        parameters.each_with_object([]) do |(k, v), arr|\n          arr << \"#{k}=#{v}\"\n        end.join('&').prepend('?').chomp('?') # prepend `?` unless the string is blank\n      end",
        "comment": "Query parameters formatted as `?key1=value1&key2=value2...`  @param parameters [Hash<String, String>] @return [String]",
        "label": "What",
        "id": "4121"
    },
    {
        "raw_code": "def before_change_head\n    # Cached divergent commit counts are based on repository head\n    expire_branch_cache\n    expire_root_ref_cache\n\n    repository_event(:change_default_branch)\n  end",
        "comment": "Runs code just before the HEAD of a repository is changed.",
        "label": "What",
        "id": "7137"
    },
    {
        "raw_code": "def _HtmlBlockCloseDiv\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseDiv = \"<\" Spnl \"/\" (\"div\" | \"DIV\") Spnl \">\"",
        "label": "What",
        "id": "15639"
    },
    {
        "raw_code": "def instance_type_new_trial_path(_group)\n    self_managed_new_trial_url\n  end",
        "comment": "overridden in EE",
        "label": "What",
        "id": "7812"
    },
    {
        "raw_code": "def clear_cache!(new_connection: false)\n        if @statements\n          @lock.synchronize do\n            if new_connection\n              @statements.reset\n            else\n              @statements.clear\n            end",
        "comment": "Clear any caching the database adapter may be doing.",
        "label": "What",
        "id": "12931"
    },
    {
        "raw_code": "def to_plain_text\n      if respond_to?(:attachable_plain_text_representation)\n        attachable_plain_text_representation(caption)\n      else\n        caption.to_s\n      end",
        "comment": "Converts the attachment to plain text.  attachable = ActiveStorage::Blob.find_by filename: \"racecar.jpg\" attachment = ActionText::Attachment.from_attachable(attachable) attachment.to_plain_text # => \"[racecar.jpg]\"  Use the `caption` when set:  attachment = ActionText::Attachment.from_attachable(attachable, caption: \"Vroom vroom\") attachment.to_plain_text # => \"[Vroom vroom]\"  The presentation can be overridden by implementing the `attachable_plain_text_representation` method:  class Person < ApplicationRecord include ActionText::Attachable  def attachable_plain_text_representation \"[#{name}]\" end end  attachable = Person.create! name: \"Javan\" attachment = ActionText::Attachment.from_attachable(attachable) attachment.to_plain_text # => \"[Javan]\"",
        "label": "What",
        "id": "11688"
    },
    {
        "raw_code": "def is_exception?\n      inheritance_tree.reverse.any? {|o| BUILTIN_EXCEPTIONS_HASH.key? o.path }\n    end",
        "comment": "Whether or not the class is a Ruby Exception  @return [Boolean] whether the object represents a Ruby exception",
        "label": "What",
        "id": "587"
    },
    {
        "raw_code": "def remove_repository_tags(project_id, repository)\n          repository_id = repository[:id]\n          logger.info(\"Removing tags from repository #{repository_id}...\")\n\n          tags = fetch_repository_tags(project_id, repository_id)\n          return if tags.empty?\n\n          tags.each do |tag|\n            delete_registry_tag(project_id, repository_id, tag[:name])\n          end",
        "comment": "Removes all tags from a specific repository  @param [String] project_id Project ID @param [Hash] repository Repository object with :id @return [void]",
        "label": "What",
        "id": "4763"
    },
    {
        "raw_code": "def department?(name)\n        departments.include?(name.to_sym)\n      end",
        "comment": "@return [Boolean] Checks if given name is department",
        "label": "What",
        "id": "10210"
    },
    {
        "raw_code": "def load!\n      return @backup_information unless @backup_information.nil?\n\n      manifest_data = load_from_file\n\n      @backup_information = BackupInformation.new(**manifest_data)\n    end",
        "comment": "Load #BackupInformation from a YAML manifest file on disk",
        "label": "What",
        "id": "3646"
    },
    {
        "raw_code": "def initialize(**args)\n            super(**args.slice(:namespace, :ci, :gitlab_domain))\n\n            @admin_password = args[:admin_password]\n            @admin_token = args[:admin_token]\n            @host_http_port = args[:host_http_port]\n            @host_ssh_port = args[:host_ssh_port]\n            @host_registry_port = args[:host_registry_port]\n            @resource_preset = args[:resource_preset]\n          end",
        "comment": "Instance of kind deployment configuration  @param **args [Hash] @option args [String] :namespace Namespace used for deployment @option args [Boolean] :ci Run for CI environment @option args [String] :gitlab_domain Custom gitlab domain @option args [String] :admin_password Initial password for admin user @option args [String] :admin_token Initial PAT token for admin user @option args [Integer] :host_http_port HTTP port for gitlab pages @option args [Integer] :host_ssh_port SSH port for gitlab @option args [Integer] :host_registry_port Registry port for gitlab @option args [String] :resource_preset resource preset name",
        "label": "What",
        "id": "4020"
    },
    {
        "raw_code": "def self.firmlink_map\n          if !@firmlink_map\n            return @firmlink_map = {} if !File.exist?(FIRMLINK_DEFS)\n            begin\n              @firmlink_map = Hash[\n                File.readlines(FIRMLINK_DEFS).map { |d|\n                  d.strip.split(/\\s+/, 2)\n                }\n              ]\n            rescue => err\n              @@logger.warn(\"Failed to parse firmlink definitions: #{err}\")\n              @firmlink_map = {}\n            end",
        "comment": "Generate mapping of firmlinks if available on the host  @return [Hash<String,String>]",
        "label": "What",
        "id": "9726"
    },
    {
        "raw_code": "def build_options(selected, options = {})\n          options = {\n            leading_zeros: true, ampm: false, use_two_digit_numbers: false\n          }.merge!(options)\n\n          start         = options.delete(:start) || 0\n          stop          = options.delete(:end) || 59\n          step          = options.delete(:step) || 1\n          leading_zeros = options.delete(:leading_zeros)\n\n          select_options = []\n          start.step(stop, step) do |i|\n            value = leading_zeros ? sprintf(\"%02d\", i) : i\n            tag_options = { value: value }\n            tag_options[:selected] = \"selected\" if selected == i\n            text = options[:use_two_digit_numbers] ? sprintf(\"%02d\", i) : value\n            text = options[:ampm] ? AMPM_TRANSLATION[i] : text\n            select_options << content_tag(\"option\", text, tag_options)\n          end",
        "comment": "Build select option HTML from date value and options.  build_options(15, start: 1, end: 31) => \"<option value=\"1\">1</option> <option value=\"2\">2</option> <option value=\"3\">3</option>...\"  If <tt>use_two_digit_numbers: true</tt> option is passed:  build_options(15, start: 1, end: 31, use_two_digit_numbers: true) => \"<option value=\"1\">01</option> <option value=\"2\">02</option> <option value=\"3\">03</option>...\"  If <tt>:step</tt> options is passed:  build_options(15, start: 1, end: 31, step: 2) => \"<option value=\"1\">1</option> <option value=\"3\">3</option> <option value=\"5\">5</option>...\"",
        "label": "What",
        "id": "11847"
    },
    {
        "raw_code": "def self.merge(old, new)\n        raise NotImplementedError\n      end",
        "comment": "Merges two configuration objects, returning the merged object. The values of `old` and `new` are the opaque objects returned by {load} or {init}.  Once again, the return object is treated as an opaque value by the Vagrant configuration loader, so it can be anything you'd like.  @param [Object] old Old configuration object. @param [Object] new New configuration object. @return [Object] The merged configuration object.",
        "label": "What",
        "id": "8923"
    },
    {
        "raw_code": "def remove(conn)\n        needs_new_connection = false\n\n        synchronize do\n          remove_connection_from_thread_cache conn\n\n          @connections.delete conn\n          @available.delete conn\n\n          # @available.any_waiting? => true means that prior to removing this\n          # conn, the pool was at its max size (@connections.size == @max_connections).\n          # This would mean that any threads stuck waiting in the queue wouldn't\n          # know they could checkout_new_connection, so let's do it for them.\n          # Because condition-wait loop is encapsulated in the Queue class\n          # (that in turn is oblivious to ConnectionPool implementation), threads\n          # that are \"stuck\" there are helpless. They have no way of creating\n          # new connections and are completely reliant on us feeding available\n          # connections into the Queue.\n          needs_new_connection = @available.num_waiting > @maintaining\n        end",
        "comment": "Remove a connection from the connection pool. The connection will remain open and active but will no longer be managed by this pool.",
        "label": "What",
        "id": "13027"
    },
    {
        "raw_code": "def git_access\n    render 'shared/wikis/git_access'\n  end",
        "comment": "rubocop:enable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "6571"
    },
    {
        "raw_code": "def compress_source_tgz(path)\n        tarfile = Tempfile.create([\"vagrant\", \".tar\"])\n        tarfile.close\n        tarfile = File.open(tarfile.path, \"wb+\")\n        tgzfile = Tempfile.create([\"vagrant\", \".tgz\"])\n        tgzfile.close\n        tgzfile = File.open(tgzfile.path, \"wb\")\n        tar = Gem::Package::TarWriter.new(tarfile)\n        tgz = Zlib::GzipWriter.new(tgzfile)\n        if File.file?(path)\n          tar.add_file(File.basename(path), File.stat(path).mode) do |io|\n            File.open(path, \"rb\") do |file|\n              while bytes = file.read(4096)\n                io.write(bytes)\n              end",
        "comment": "Compress path using tar and gzip into temporary file  @param [String] path Path to compress @return [String] path to compressed file",
        "label": "What",
        "id": "9807"
    },
    {
        "raw_code": "def github_client\n        @github_client ||= Octokit::Client.new(access_token: github_personal_access_token)\n      end",
        "comment": "Github client  @return [Octokit::Client]",
        "label": "What",
        "id": "4182"
    },
    {
        "raw_code": "def javascript_inline_importmap_tag(importmap_json = Rails.application.importmap.to_json(resolver: self))\n    tag.script importmap_json.html_safe,\n      type: \"importmap\", \"data-turbo-track\": \"reload\"\n  end",
        "comment": "Copied from importmap-rails but with the nonce removed. We rely on the sha256 hash instead. Relying on the hash improves the caching behavior by not sending the cached nonce to the client.",
        "label": "What",
        "id": "9971"
    },
    {
        "raw_code": "def do_something\n      end",
        "comment": "rubocop:enable Department/Cop",
        "label": "What",
        "id": "10787"
    },
    {
        "raw_code": "def update_authorizations(remove = [], add = [])\n      ProjectAuthorizations::Changes.new do |changes|\n        changes.add(add)\n        changes.remove_projects_for_user(user, remove)\n      end.apply!\n\n      user.update!(project_authorizations_recalculated_at: Time.zone.now) if remove.any? || add.any?\n\n      reset_timer_and_store_duration(:update_authorizations)\n\n      log_refresh_details(remove, add)\n\n      # Since we batch insert authorization rows, Rails' associations may get\n      # out of sync. As such we force a reload of the User object.\n      user.reset\n    end",
        "comment": "Updates the list of authorizations for the current user.  remove - The project IDs of the authorization rows to remove. add - Rows to insert in the form `[{ user_id: user_id, project_id: project_id, access_level: access_level}, ...]`",
        "label": "What",
        "id": "5987"
    },
    {
        "raw_code": "def set_private(repo, options = {})\n        # GitHub Api for setting private updated to use private attr, rather than public\n        update_repository repo, options.merge({ private: true })\n      end",
        "comment": "Hide a public repository  @param repo [Integer, String, Hash, Repository] A GitHub repository @return [Sawyer::Resource] Updated repository info",
        "label": "What",
        "id": "15138"
    },
    {
        "raw_code": "def add_ips_to_env!(env)\n          provider = env[:machine].provider\n\n          host_ip    = provider.driver.docker_bridge_ip\n          machine_ip = provider.ssh_info[:host]\n\n          raise Vagrant::Errors::NFSNoHostonlyNetwork if !host_ip || !machine_ip\n\n          env[:nfs_host_ip]    = host_ip\n          env[:nfs_machine_ip] = machine_ip\n        end",
        "comment": "Extracts the proper host and guest IPs for NFS mounts and stores them in the environment for the SyncedFolder action to use them in mounting.  The ! indicates that this method modifies its argument.",
        "label": "What",
        "id": "9515"
    },
    {
        "raw_code": "def use_fast_destroy(relation, opts = {})\n        set_callback :destroy, :before, opts.merge(prepend: true) do\n          perform_fast_destroy(public_send(relation)) # rubocop:disable GitlabSecurity/PublicSend\n        end",
        "comment": " This method is to be defined on models which have fast destroyable models as children, and let us avoid to use `dependent: :destroy` hook",
        "label": "What",
        "id": "7303"
    },
    {
        "raw_code": "def merge_request_to_resolve_discussions_of\n      strong_memoize(:merge_request_to_resolve_discussions_of) do\n        # sometimes this will be a Group, when work item is created at group level.\n        # Not sure if we will need to handle resolving an MR with an issue at group level?\n        next unless container.is_a?(Project)\n        next merge_request_to_resolve_discussions_object if merge_request_to_resolve_discussions_object.present?\n\n        MergeRequestsFinder.new(current_user, project_id: container.id)\n          .find_by(iid: merge_request_to_resolve_discussions_of_iid)\n      end",
        "comment": "rubocop:enable Gitlab/ModuleWithInstanceVariables rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5716"
    },
    {
        "raw_code": "def target_rails_version_from_bundler_lock_file\n      @target_rails_version_from_bundler_lock_file ||= read_rails_version_from_bundler_lock_file\n    end",
        "comment": "@return [Float, nil] The Rails version as a `major.minor` Float.",
        "label": "What",
        "id": "10178"
    },
    {
        "raw_code": "def push_frontend_feature_flag(name, *args, **kwargs)\n      enabled = Feature.enabled?(name, *args, **kwargs)\n\n      push_to_gon_attributes(:features, name, enabled)\n    end",
        "comment": "Exposes the state of a feature flag to the frontend code.  name - The name of the feature flag, e.g. `my_feature`. args - Any additional arguments to pass to `Feature.enabled?`. This allows you to check if a flag is enabled for a particular user.",
        "label": "What",
        "id": "1573"
    },
    {
        "raw_code": "def self.mount_nfs_folder(machine, ip, folders)\n          comm = machine.communicate\n\n          # Mount each folder separately so we can retry.\n          folders.each do |name, opts|\n            # Shellescape the paths in case they do not have special characters.\n            guest_path = Shellwords.escape(opts[:guestpath])\n            host_path  = Shellwords.escape(opts[:hostpath])\n\n            # Build the list of mount options.\n            mount_opts =  []\n            mount_opts << \"nfsv#{opts[:nfs_version]}\" if opts[:nfs_version]\n            mount_opts << \"mntudp\" if opts[:nfs_udp]\n            if opts[:mount_options]\n              mount_opts = mount_opts + opts[:mount_options].dup\n            end",
        "comment": "Mount the given NFS folder.",
        "label": "What",
        "id": "9830"
    },
    {
        "raw_code": "def upload(from, to)\n        file_manager = WinRM::FS::FileManager.new(connection)\n        if from.is_a?(String) && File.directory?(from)\n          if from.end_with?(\".\")\n            from = from[0, from.length - 1]\n          else\n            to = File.join(to, File.basename(File.expand_path(from)))\n          end",
        "comment": "@param from [Array<String>, String] a single path or folder, or an array of paths and folders to upload to the guest @param to [String] a path or folder on the guest to upload to @return [FixNum] Total size transfered from host to guest",
        "label": "What",
        "id": "9404"
    },
    {
        "raw_code": "def execute_async_for_all(pipelines, failure_reason, context_user)\n      pipelines.cancelable.select(:id).find_in_batches do |pipelines_batch|\n        Ci::DropPipelineWorker.bulk_perform_async_with_contexts(\n          pipelines_batch,\n          arguments_proc: ->(pipeline) { [pipeline.id, failure_reason] },\n          context_proc: ->(_) { { user: context_user } }\n        )\n      end",
        "comment": "execute service asynchronously for each cancelable pipeline",
        "label": "What",
        "id": "5764"
    },
    {
        "raw_code": "def run(config, on_error, exit_codes)\n          if config.inline\n            if Vagrant::Util::Platform.windows?\n              cmd = config.inline\n            else\n              cmd = Shellwords.split(config.inline)\n            end",
        "comment": "Runs a script on a guest  @param [Provisioners::Shell::Config] config A Shell provisioner config",
        "label": "What",
        "id": "9047"
    },
    {
        "raw_code": "def entry(path)\n    path = path.to_s\n    return if path.blank?\n    response = fs.head path_key(path)\n    return if response.blank? || response[:metadata].blank?\n    RubygemContents::Entry.from_metadata(response[:metadata]) { |entry| content(entry.fingerprint) }\n  end",
        "comment": "@return [RubygemContents::Entry]",
        "label": "What",
        "id": "9995"
    },
    {
        "raw_code": "def ==(o)\n    self.text == o.text && self.type == o.type\n  end",
        "comment": " Regexp handlings are equal when the have the same text and type",
        "label": "What",
        "id": "16437"
    },
    {
        "raw_code": "def start\n        server = RackServer.new(server_options)\n        server.instance_variable_set(\"@app\", self)\n        print_start_message(server)\n        server.start\n      end",
        "comment": "Starts the Rack server. This method will pass control to the server and block. @return [void]",
        "label": "What",
        "id": "692"
    },
    {
        "raw_code": "def parse_objects(objects)\n        objects.each do |object|\n          extract_documents(object)\n        end",
        "comment": "Parses {CodeObjects::Base} objects and stores extracted msgids into {#messages}  @param [Array<CodeObjects::Base>] objects a list of {CodeObjects::Base} to be parsed. @return [void]",
        "label": "What",
        "id": "709"
    },
    {
        "raw_code": "def delete_entry(key, **options)\n          raise NotImplementedError.new\n        end",
        "comment": "Deletes an entry from the cache implementation. Subclasses must implement this method.",
        "label": "What",
        "id": "13758"
    },
    {
        "raw_code": "def preload_emails_enabled\n    group_ids_with_disabled_email = Group.ids_with_disabled_email(groups.to_a)\n\n    groups.each do |group|\n      group.emails_enabled_memoized = group_ids_with_disabled_email.exclude?(group.id) if group.parent_id\n    end",
        "comment": "This method preloads the `emails_enabled` strong memoized method for the given groups.  For each group, look up the ancestor hierarchy and look for any group where emails_enabled is false. The lookup is implemented with an EXISTS subquery, so we can look up the ancestor chain for each group individually. The query will return groups where at least one ancestor has the `emails_disabled` set to true.  After the query, we set the instance variable.",
        "label": "What",
        "id": "7888"
    },
    {
        "raw_code": "def action_methods\n      self.class.action_methods\n    end",
        "comment": "Delegates to the class's ::action_methods.",
        "label": "What",
        "id": "11183"
    },
    {
        "raw_code": "def push(build, transition)\n      raise InvalidQueueTransition unless transition.to == 'pending'\n\n      transition.within_transaction do\n        result = build.create_queuing_entry!\n\n        unless result.empty?\n          metrics.increment_queue_operation(:build_queue_push)\n\n          result.rows.dig(0, 0)\n        end",
        "comment": " Add a build to the pending builds queue ",
        "label": "What",
        "id": "5791"
    },
    {
        "raw_code": "def qa_tests(from_code_path_mapping: false)\n          return [] if mr_diff.empty? || dependency_changes\n          return changed_specs if only_spec_changes?\n          return selective_tests_from_code_paths_mapping if from_code_path_mapping\n\n          []\n        end",
        "comment": "Specific specs to run  @return [Array]",
        "label": "What",
        "id": "4800"
    },
    {
        "raw_code": "def dedicated_gitlab_hosted?\n      false\n    end",
        "comment": "false in FOSS",
        "label": "What",
        "id": "7527"
    },
    {
        "raw_code": "def contributed_project_ids\n      # re-running the contributed projects query in each union is expensive, so\n      # use IN(project_ids...) instead. It's the intersection of two users so\n      # the list will be (relatively) short\n      @contributed_project_ids ||= projects.distinct.pluck(:id)\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord -- no need to move this to ActiveRecord model",
        "label": "What",
        "id": "1598"
    },
    {
        "raw_code": "def with_recursive!(*args) # :nodoc:\n      args = process_with_args(args)\n      self.with_values |= args\n      @with_is_recursive = true\n      self\n    end",
        "comment": "Like #with_recursive but modifies the relation in place.",
        "label": "What",
        "id": "13398"
    },
    {
        "raw_code": "def missing?(obj)\n        obj.to_s.strip.empty?\n      end",
        "comment": "Determine if the given string is \"missing\" (blank) @return [true, false]",
        "label": "What",
        "id": "9381"
    },
    {
        "raw_code": "def purge\n    transaction do\n      delete\n      record.touch if record&.persisted?\n    end",
        "comment": "Synchronously deletes the attachment and {purges the blob}[rdoc-ref:ActiveStorage::Blob#purge].",
        "label": "What",
        "id": "13593"
    },
    {
        "raw_code": "def head(url, options = {})\n      request :head, url, parse_query_and_convenience_headers(options)\n    end",
        "comment": "Make a HTTP HEAD request  @param url [String] The path, relative to {#api_endpoint} @param options [Hash] Query and header params for request @return [Sawyer::Resource]",
        "label": "What",
        "id": "14907"
    },
    {
        "raw_code": "def assert_notifications_count(pattern, count, &block)\n        actual_count = capture_notifications(pattern, &block).count\n        assert_equal(count, actual_count, \"Expected #{count} instead of #{actual_count} notifications for #{pattern}\")\n      end",
        "comment": "Assert the number of notifications emitted with a given +pattern+.  You can assert the number of notifications emitted by passing a pattern, which accepts either a string or regexp, a count, and a block. While the block is executed, the number of matching notifications emitted will be counted. After the block's execution completes, the assertion will pass if the count matches.  assert_notifications_count(\"post.submitted\", 1) do post.submit(title: \"Cool Post\") # => emits matching notification end ",
        "label": "What",
        "id": "14540"
    },
    {
        "raw_code": "def self.assign_device_names(machine, networks)\n          if machine.communicate.test(\"command -v biosdevname\")\n            # use biosdevname to get info about the interfaces\n            interfaces = get_interfaces(machine)\n            if machine.provider.capability?(:nic_mac_addresses)\n              # find device name by MAC lookup.\n              mac_addresses = machine.provider.capability(:nic_mac_addresses)\n              networks.each do |network|\n                mac_address = mac_addresses[network[:interface]+1]\n                interface = interfaces.detect {|nic| nic[:mac_address].gsub(\":\",\"\") == mac_address} if mac_address\n                network[:device] = interface[:kernel] if interface\n              end",
        "comment": "Set :device on each network. Attempts to use biosdevname when available to detect interface names, and falls back to ifconfig otherwise.",
        "label": "What",
        "id": "9855"
    },
    {
        "raw_code": "def is_explicit?\n      explicit ? true : false\n    end",
        "comment": "Tests boolean {#explicit} value.  @return [Boolean] whether the method is explicitly defined in source",
        "label": "What",
        "id": "557"
    },
    {
        "raw_code": "def track_usage_event(event_name, values)\n        Gitlab::UsageDataCounters::HLLRedisCounter.track_event(event_name.to_s, values: values)\n      end",
        "comment": "@param event_name [String, Symbol] the event name @param values [Array|String] the values counted",
        "label": "What",
        "id": "1865"
    },
    {
        "raw_code": "def with_restored_connection_stack(&block)\n          original_handler = ActiveRecord::Base.connection_handler\n\n          original_db_config = ActiveRecord::Base.connection_db_config\n          if ActiveRecord::Base.configurations.primary?(original_db_config.name)\n            return yield(ActiveRecord::Base.connection)\n          end",
        "comment": "This is workaround for `db:migrate` that switches `ActiveRecord::Base.connection` depending on execution. This is subject to be removed once proper fix is implemented: https://gitlab.com/gitlab-org/gitlab/-/issues/362341  In some cases when we run application code we need to restore application connection stack: - ApplicationRecord (in fact ActiveRecord::Base): points to main - Ci::ApplicationRecord: points to ci  rubocop:disable Database/MultipleDatabases",
        "label": "What",
        "id": "3151"
    },
    {
        "raw_code": "def unique_by_namespace(slug)\n        path = Namespaces::RandomizedSuffixPath.new(slug).to_s\n        Gitlab::Utils::Uniquify.new.string(path) do |s|\n          Namespace.all.find_by_path_or_name(s)\n        end",
        "comment": "decomposed from Namespace.clean_path",
        "label": "What",
        "id": "2342"
    },
    {
        "raw_code": "def finalize_fast_destroy(params)\n      by_project = params.group_by(&:shift)\n\n      by_project.each do |project, ref_paths|\n        project.repository.delete_refs(*ref_paths.flatten)\n      rescue Gitlab::Git::Repository::NoRepository\n        next\n      end",
        "comment": " FastDestroyAll concerns",
        "label": "What",
        "id": "6682"
    },
    {
        "raw_code": "def self.from_json_hash(raw_hash)\n          hash = Representation.symbolize_hash(raw_hash)\n\n          hash[:author] &&= Representation::User.from_json_hash(hash[:author])\n\n          new(hash)\n        end",
        "comment": "Builds a new note using a Hash that was built from a JSON payload.",
        "label": "What",
        "id": "2259"
    },
    {
        "raw_code": "def true?(encoded_value)\n          decode(encoded_value)\n        end",
        "comment": "Decode a boolean string, then test if it's true  @param value [String] the stored boolean string @return [Boolean] is the value true? @raise [NotAnEncodedBooleanStringError] if the provided value isn't an encoded boolean",
        "label": "What",
        "id": "1913"
    },
    {
        "raw_code": "def update_priorities(group_label, label_ids)\n      LabelPriority\n        .where(label: label_ids)\n        .update_all(label_id: group_label.id)\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6053"
    },
    {
        "raw_code": "def example_group_started(example_group_notification)\n          set_skip_metadata(example_group_notification.group)\n        end",
        "comment": "Starts example group @param [RSpec::Core::Notifications::GroupNotification] example_group_notification @return [void]",
        "label": "What",
        "id": "4606"
    },
    {
        "raw_code": "def separators_for_type(type)\n        NamespaceMapper.rev_map[type] || []\n      end",
        "comment": "@param type [String] the type to return separators for @return [Array<Symbol>] a list of separators registered to a type",
        "label": "What",
        "id": "603"
    },
    {
        "raw_code": "def add_menu_item_to_super_sidebar_parent(menus, menu_item)\n        parent = menu_item.super_sidebar_parent || ::Sidebars::UncategorizedMenu\n        return if parent == ::Sidebars::NilMenuItem\n\n        idx = index_of(menus, parent) || index_of(menus, ::Sidebars::UncategorizedMenu)\n        return unless idx\n\n        menus[idx].replace_placeholder(menu_item)\n      end",
        "comment": "Finds a menu_items super sidebar parent and adds the item to that menu Handles: - parent == nil, or parent not being part of the panel: we assume that the menu item hasn't been categorized yet - parent == ::Sidebars::NilMenuItem, the item explicitly is supposed to be removed",
        "label": "What",
        "id": "3688"
    },
    {
        "raw_code": "def link_dependencies\n        highlighted_lines.map!.with_index do |rich_line, i|\n          plain_line = plain_lines[i].chomp\n          match = REGEX.match(plain_line)\n          next rich_line unless match\n\n          i0, j0 = match.offset(:name)\n          i2, j2 = match.offset(:checksum)\n\n          marker = StringRangeMarker.new(plain_line, rich_line.html_safe)\n          marker.mark([i0..(j0 - 1), i2..(j2 - 1)]) do |text, left:, right:, mode:|\n            if left\n              url = package_url(text, match[:version])\n              url ? link_tag(text, url) : text\n\n            elsif right\n              link_tag(text, \"https://sum.golang.org/lookup/#{match[:name]}@#{match[:version]}\")\n            end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2116"
    },
    {
        "raw_code": "def respond_to?(name, include_private = false)\n      return false unless super\n\n      # If the result is true then check for the select case.\n      # For queries selecting a subset of columns, return false for unselected columns.\n      if @attributes\n        if name = self.class.symbol_column_to_string(name.to_sym)\n          return _has_attribute?(name)\n        end",
        "comment": "A Person object with a name attribute can ask <tt>person.respond_to?(:name)</tt>, <tt>person.respond_to?(:name=)</tt>, and <tt>person.respond_to?(:name?)</tt> which will all return +true+. It also defines the attribute methods if they have not been generated.  class Person < ActiveRecord::Base end  person = Person.new person.respond_to?(:name)    # => true person.respond_to?(:name=)   # => true person.respond_to?(:name?)   # => true person.respond_to?('age')    # => true person.respond_to?('age=')   # => true person.respond_to?('age?')   # => true person.respond_to?(:nothing) # => false",
        "label": "What",
        "id": "12365"
    },
    {
        "raw_code": "def add_gitlab_helm_chart(sha = nil)\n          return package_chart(sha) if sha\n\n          add_helm_chart(GITLAB_CHART_PREFIX, GITLAB_CHART_URL)\n          \"#{GITLAB_CHART_PREFIX}/gitlab\"\n        end",
        "comment": "Add helm chart and return reference  @param [String] sha fetch and package helm chart using specific repo sha @return [String] chart reference or path to packaged chart tgz",
        "label": "What",
        "id": "3955"
    },
    {
        "raw_code": "def template_for(file, page = true, klass = ERB)\n    template = @template_cache[file]\n\n    return template if template\n\n    if page then\n      template = assemble_template file\n      erbout = 'io'\n    else\n      template = file.read\n      template = template.encode @options.encoding\n\n      file_var = File.basename(file).sub(/\\..*/, '')\n\n      erbout = \"_erbout_#{file_var}\"\n    end",
        "comment": " Retrieves a cache template for +file+, if present, or fills the cache.",
        "label": "What",
        "id": "16473"
    },
    {
        "raw_code": "def remote_disconnect(connection)\n    if current_adapter?(:PostgreSQLAdapter)\n      # Connection was left in a bad state, need to reconnect to simulate fresh disconnect\n      connection.verify! if connection.instance_variable_get(:@raw_connection).status == ::PG::CONNECTION_BAD\n      unless connection.instance_variable_get(:@raw_connection).transaction_status == ::PG::PQTRANS_INTRANS\n        connection.instance_variable_get(:@raw_connection).async_exec(\"begin\")\n      end",
        "comment": "Arrange for the server to disconnect the connection, leaving it broken (by setting, and then sleeping to exceed, a very short timeout). Skips if we can't do so.",
        "label": "What",
        "id": "13588"
    },
    {
        "raw_code": "def delete_repository_invitation(repo, invitation_id, options = {})\n        boolean_from_response :delete, \"#{Repository.path repo}/invitations/#{invitation_id}\", options\n      end",
        "comment": "Delete an invitation for a repository  Requires authenticated client  @param repo [Integer, String, Repository, Hash] A GitHub repository @param invitation_id [Integer] The id of the invitation @return [Boolean] True if the invitation was successfully deleted @see https://developer.github.com/v3/repos/invitations/#delete-a-repository-invitation",
        "label": "What",
        "id": "15397"
    },
    {
        "raw_code": "def logger\n      request.logger\n    end",
        "comment": "Access shared logger object.",
        "label": "What",
        "id": "8553"
    },
    {
        "raw_code": "def define_gitlab_address_attribute!(address = Runtime::Env.gitlab_url)\n          return if initialized?\n\n          validate_address(address)\n\n          Runtime::Scenario.define(:gitlab_address, address_with_port(address, with_default_port: false))\n          # Define the \"About\" page as an `about` subdomain.\n          # @example\n          #   Given *gitlab_address* = 'https://gitlab.com/' #=> https://about.gitlab.com/\n          #   Given *gitlab_address* = 'https://staging.gitlab.com/' #=> https://about.staging.gitlab.com/\n          #   Given *gitlab_address* = 'http://gitlab-abc123.test/' #=> http://about.gitlab-abc123.test/\n          Runtime::Scenario.define(\n            :about_address,\n            URI(address).then { |uri| \"#{uri.scheme}://about.#{host_with_port(address, with_default_port: false)}\" }\n          )\n\n          @initialized = true\n        end",
        "comment": "Define gitlab address  @param [String] address @return [void]",
        "label": "What",
        "id": "4572"
    },
    {
        "raw_code": "def find_pages_domain!\n        user_project.pages_domains.find_by(domain: params[:domain]) || not_found!('PagesDomain')\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3749"
    },
    {
        "raw_code": "def clear\n      Sidekiq.redis do |conn|\n        conn.multi do |transaction|\n          transaction.unlink(@rname)\n          transaction.srem(\"queues\", [name])\n        end",
        "comment": "delete all jobs within this queue @return [Boolean] true",
        "label": "What",
        "id": "5116"
    },
    {
        "raw_code": "def excluded_dashboard_choices\n    ['operations']\n  end",
        "comment": "List of dashboard choice to be excluded from CE. EE would override this.",
        "label": "What",
        "id": "7834"
    },
    {
        "raw_code": "def title\n    @cache[:title]\n  end",
        "comment": " Gets the title for this RDoc store.  This is used as the title in each page on the RDoc server",
        "label": "What",
        "id": "15893"
    },
    {
        "raw_code": "def kubeclient\n              @kubeclient ||= Kubectl::Client.new(namespace)\n            end",
        "comment": "Instance of {Kubectl::Client}  @return [Kubectl::Client]",
        "label": "What",
        "id": "4039"
    },
    {
        "raw_code": "def settings\n      conn = authenticated_client\n      @last_response = conn.get('/manage/v1/config/settings')\n    end",
        "comment": "Get information about the Enterprise installation  @return [nil]",
        "label": "What",
        "id": "14928"
    },
    {
        "raw_code": "def up\n    prepare_async_index_removal :issues, [:health_status], name: INDEX_NAME\n  end",
        "comment": "Follow-up issue to remove index https://gitlab.com/gitlab-org/gitlab/-/issues/372205",
        "label": "What",
        "id": "4937"
    },
    {
        "raw_code": "def mergeability_checks_pass?(**params)\n    execute_merge_checks(\n      self.class.all_mergeability_checks,\n      params: params,\n      execute_all: false\n    ).success?\n  end",
        "comment": "This runs all the checks",
        "label": "What",
        "id": "6980"
    },
    {
        "raw_code": "def response_code\n      @status\n    end",
        "comment": "The response code of the request.",
        "label": "What",
        "id": "11473"
    },
    {
        "raw_code": "def jobs_by_migration_name\n          set_shared_model_connection do\n            Gitlab::Database::BackgroundMigration::BatchedMigration\n              .executable\n              .where('id > ?', from_id)\n              .to_h do |migration|\n              batching_strategy = migration.batch_class.new(connection: connection)\n\n              is_cursor = migration.cursor?\n\n              # Pretend every migration is a cursor migration. When actually running the job,\n              # we can unwrap the cursor if it is not.\n              cursor_columns = is_cursor ? migration.job_class.cursor_columns : [migration.column_name]\n\n              # Wrap the single result into an array (that we pretend is a cursor) if this\n              # is not a cursor migration. (next_min_value has an if check on cursor? and returns either array or int)\n              table_min_cursor = Array.wrap(migration.next_min_value)\n\n              ordering = cursor_columns.map { |c| { c => :desc } }\n\n              rows_ordered_backwards = define_batchable_model(migration.table_name, connection: connection)\n                                        .order(*ordering)\n              # If only one column, pluck.first returns a single value for that column instead of an array of\n              # all (1) column(s)\n              # So wrap the result for consistency between 1 and many columns\n              table_max_cursor = Array.wrap(rows_ordered_backwards.pick(*cursor_columns))\n\n              # variance is the portion of the batch range that we shrink between variance * 0 and variance * 1\n              # to pick actual batches to sample.\n\n              # Here we're going to do something that is explicitly WRONG, but good enough - we assume that we can\n              # just scale the first element of the cursor to get a reasonable percentage of the way through the table.\n              # This is really not true at all, but it's close enough for testing.\n              # For the rest of the components of our example cursors, we'll reuse parts of the end cursors for each\n              # batch for the start cursors of the next batch\n              variance = table_max_cursor[0] - table_min_cursor[0]\n\n              batch_first_elems = uniform_fractions.lazy.map { |frac| (variance * frac).to_i }\n\n              jobs_to_sample = Enumerator.new do |y|\n                completed_batches = []\n                # We construct the starting cursor from the end of the prev loop,\n                # or just the beginning of the table on the first loop\n                # This way, cursors for our batches start at interesting places in all of their positions\n                prev_end_cursor = table_min_cursor\n\n                loop do\n                  first_elem = batch_first_elems.next\n                  batch_start = [first_elem] + prev_end_cursor[1..]\n                  break if completed_batches.any? { |batch| batch.cover?(batch_start) }\n\n                  # The current block is lazily evaluated as part of the jobs_to_sample enumerable\n                  # so it executes after the enclosing using_connection block has already executed\n                  # Therefore we need to re-associate with the explicit connection again\n                  Gitlab::Database::SharedModel.using_connection(connection) do\n                    next_bounds = batching_strategy.next_batch(\n                      migration.table_name,\n                      migration.column_name,\n                      batch_min_value: is_cursor ? batch_start : batch_start[0],\n                      batch_size: migration.batch_size,\n                      job_class: migration.job_class,\n                      job_arguments: migration.job_arguments\n                    )\n\n                    # If no rows match, the next_bounds are nil.\n                    # This will only happen if there are zero rows to match from the current sampling point to the end\n                    # of the table\n                    # Simulate the approach in the actual background migration worker by not sampling a batch\n                    # from this range.\n                    # (The actual worker would finish the migration, but we may find batches that can be sampled\n                    # elsewhere in the table)\n                    if next_bounds.nil?\n                      # If the migration has no work to do across the entire table, sampling can get stuck\n                      # in a loop if we don't mark the attempted batches as completed\n                      # We need to guess a size for this. The batch size of the migration is way too big in all\n                      # cases with a 2-element or more cursor, but it doesn't really matter so we just guess that.\n                      synthetic_cursor_offset = migration.batch_size\n                      batch_end = batch_start.dup\n                      batch_end[0] += synthetic_cursor_offset\n                      completed_batches << (batch_start..batch_end)\n                      next\n                    end",
        "comment": "rubocop:disable Metrics/AbcSize -- This method is temporarily more complex while it deals with both cursor and non-cursor migrations. The complexity will significantly decrease when non-cursor migration support is removed.",
        "label": "What",
        "id": "3161"
    },
    {
        "raw_code": "def parse_module(container, single, tk, comment)\n    container, name_t, = get_class_or_module container\n\n    name = name_t[:text]\n\n    mod = container.add_module RDoc::NormalModule, name\n    mod.ignore unless container.document_children\n    record_location mod\n\n    read_documentation_modifiers mod, RDoc::CLASS_MODIFIERS\n    mod.add_comment comment, @top_level\n    parse_statements mod\n\n    # after end modifiers\n    read_documentation_modifiers mod, RDoc::CLASS_MODIFIERS\n\n    @stats.add_module mod\n  end",
        "comment": " Parses an RDoc::NormalModule in +container+ with +comment+",
        "label": "What",
        "id": "16108"
    },
    {
        "raw_code": "def up\n    prepare_async_index :approval_project_rules, :approval_policy_rule_id, name: INDEX_NAME\n  end",
        "comment": "TODO: Index to be created synchronously as part of https://gitlab.com/gitlab-org/gitlab/-/merge_requests/155256",
        "label": "What",
        "id": "4872"
    },
    {
        "raw_code": "def get_dependabot_secret(repo, name)\n        get \"#{Repository.path repo}/dependabot/secrets/#{name}\"\n      end",
        "comment": "Get a secret  @param repo [Integer, String, Hash, Repository] A GitHub repository @param name [String] Name of secret @return [Hash] name, created_at, updated_at, and visibility @see https://docs.github.com/en/rest/dependabot/repository-secrets?apiVersion=2022-11-28#get-a-repository-secret",
        "label": "What",
        "id": "14989"
    },
    {
        "raw_code": "def logger\n      @logger ||= Logger.new(ENV.fetch(\"CNG_VAR_SETUP_LOG_FILE\", \"tmp/cng-var-setup.log\"))\n    end",
        "comment": "overridden base class methods Logger with file output  @return [Logger]",
        "label": "What",
        "id": "5261"
    },
    {
        "raw_code": "def workflows(repo, options = {})\n        paginate \"#{Repository.path repo}/actions/workflows\", options do |data, last_response|\n          data.workflows.concat last_response.data.workflows\n        end",
        "comment": "Get the workflows in a repository  @param repo [Integer, String, Repository, Hash] A GitHub repository  @return [Sawyer::Resource] the total count and an array of workflows @see https://developer.github.com/v3/actions/workflows/#list-repository-workflows",
        "label": "What",
        "id": "15071"
    },
    {
        "raw_code": "def where_not_in(users = nil)\n      users ? where.not(id: users) : all\n    end",
        "comment": "Limits the result set to users _not_ in the given query/list of IDs.  users - The list of users to ignore. This can be an `ActiveRecord::Relation`, or an Array.",
        "label": "What",
        "id": "7058"
    },
    {
        "raw_code": "def log_results(results, dry_run = false)\n        return logger.info(\"Dry run complete\") if dry_run\n\n        return logger.info(\"No results to report\") if results.blank?\n\n        processed_results = results.group_by(&:shift).transform_values(&:flatten)\n\n        marked_deletions = processed_results[\"marked_deletions\"]\n        permanent_deletions = processed_results[\"permanent_deletions\"]\n        failed_deletions = processed_results[\"failed_deletions\"]\n\n        logger.info(\"Marked #{marked_deletions.length} resource(s) for deletion\") unless marked_deletions.blank?\n        logger.info(\"Deleted #{permanent_deletions.length} resource(s)\") unless permanent_deletions.blank?\n\n        print_failed_deletion_attempts(failed_deletions)\n\n        logger.info('Done')\n\n        exit 1 unless failed_deletions.blank?\n      end",
        "comment": "Print results of entire script run  @param [Array<String, Hash>] results @param [Boolean] dry_run Defaults to false @return [void]",
        "label": "What",
        "id": "4739"
    },
    {
        "raw_code": "def up\n    prepare_async_index_removal :issues, [:project_id, :external_key], name: INDEX_NAME\n  end",
        "comment": "Follow-up issue to remove index https://gitlab.com/gitlab-org/gitlab/-/issues/558770",
        "label": "What",
        "id": "4871"
    },
    {
        "raw_code": "def org_user_details\n          return {} unless Feature.enabled?(:organization_users_internal, organization)\n\n          Organizations::OrganizationUserDetail.for_references\n                                               .for_organization(organization)\n                                               .with_usernames(usernames)\n                                               .index_by(&:username)\n                                               .transform_keys(&:downcase)\n        end",
        "comment": "check for users that have an aliased name within an organization, for example the bot users created by Users::Internal",
        "label": "What",
        "id": "3510"
    },
    {
        "raw_code": "def upsert_records(batch)\n      keys = %i[build_id partition_id name project_id]\n\n      builds_upsert_data =\n        batch\n          .pluck(:id, :partition_id, :name, :project_id)\n          .map { |values| Hash[keys.zip(values)] }\n\n      return unless builds_upsert_data.any?\n\n      Ci::BuildName.upsert_all(builds_upsert_data, unique_by: [:build_id, :partition_id])\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord -- plucking attributes is more efficient than loading the records rubocop: disable Database/AvoidUsingPluckWithoutLimit -- plucking on batch",
        "label": "What",
        "id": "5787"
    },
    {
        "raw_code": "def delete_source_branch?\n      params.fetch('should_remove_source_branch', @merge_request.force_remove_source_branch?) &&\n        @merge_request.can_remove_source_branch?(branch_deletion_user)\n    end",
        "comment": "Verify again that the source branch can be removed, since branch may be protected, or the source branch may have been updated, or the user may not have permission ",
        "label": "What",
        "id": "5560"
    },
    {
        "raw_code": "def get_blocks(node, &block)\n          case node.type\n          when :block, :numblock, :itblock\n            yield node\n          when :send, :csend\n            # When a method has an argument which is another method with a block,\n            # that block needs braces, otherwise a syntax error will be introduced\n            # for subsequent arguments.\n            # Additionally, even without additional arguments, changing `{...}` to\n            # `do...end` will change the binding of the block to the outer method.\n            get_blocks(node.receiver, &block) if node.receiver\n            node.arguments.each { |argument| get_blocks(argument, &block) }\n          when :hash\n            # A hash which is passed as method argument may have no braces\n            # In that case, one of the K/V pairs could contain a block node\n            # which could change in meaning if `do...end` is replaced with `{...}`\n            return if node.braces?\n\n            node.each_child_node { |child| get_blocks(child, &block) }\n          when :pair\n            node.each_child_node { |child| get_blocks(child, &block) }\n          end",
        "comment": "rubocop:disable Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "10507"
    },
    {
        "raw_code": "def refresh_cache(&block)\n      count_grouped_by_confidential = self.class.query(@project, public_only: false).group(:confidential).count\n      public_count = count_grouped_by_confidential[false] || 0\n      total_count = public_count + (count_grouped_by_confidential[true] || 0)\n\n      update_cache_for_key(public_count_cache_key) do\n        public_count\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5927"
    },
    {
        "raw_code": "def hash\n      [project_id, event_id, timestamp, level, message, release, environment, platform].hash\n    end",
        "comment": "Calculates hash code according to all attributes. @return [Integer] Hash code",
        "label": "What",
        "id": "871"
    },
    {
        "raw_code": "def project_labels_for_root_namespace\n      Label.where(group_id: nil)\n           .where(project_id: Project.select(:id).where(namespace_id: root_namespace.self_and_descendant_ids))\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7984"
    },
    {
        "raw_code": "def create_lock!\n      lock = project.lfs_file_locks.create!(user: current_user, path: params[:path])\n\n      project.refresh_lfs_file_locks_changed_epoch\n\n      success(http_status: 201, lock: lock)\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6006"
    },
    {
        "raw_code": "def update_branch(repo, branch, sha, force = true, options = {})\n        update_ref repo, \"heads/#{branch}\", sha, force, options\n      end",
        "comment": "Update a branch  @param repo [Integer, String, Repository, Hash] A GitHub repository @param branch [String] The ref, e.g. <tt>feature/new-shiny</tt> @param sha [String] A SHA, e.g. <tt>827efc6d56897b048c772eb4087f854f46256132</tt> @param force [Boolean] A flag indicating whether to force the update or to make sure the update is a fast-forward update. @return [Array<Sawyer::Resource>] The list of references updated @see https://developer.github.com/v3/git/refs/#update-a-reference @example Force update heads/sc/featureA for octocat/Hello-World with sha aa218f56b14c9653891f9e74264a383fa43fefbd Octokit.update_branch(\"octocat/Hello-World\", \"sc/featureA\", \"aa218f56b14c9653891f9e74264a383fa43fefbd\") @example Fast-forward update heads/sc/featureA for octocat/Hello-World with sha aa218f56b14c9653891f9e74264a383fa43fefbd Octokit.update_branch(\"octocat/Hello-World\", \"sc/featureA\", \"aa218f56b14c9653891f9e74264a383fa43fefbd\", false)",
        "label": "What",
        "id": "15081"
    },
    {
        "raw_code": "def class_path(klass_name)\n    File.join @path, *klass_name.split('::')\n  end",
        "comment": " Path where data for +klass_name+ will be stored (methods or class data)",
        "label": "What",
        "id": "15856"
    },
    {
        "raw_code": "def call(env)\n        to_app(env).call(env)\n      end",
        "comment": "Runs the builder stack with the given environment.",
        "label": "What",
        "id": "9308"
    },
    {
        "raw_code": "def self.default_specifications_dir\n          File.join(Gem.old_default_dir, \"specifications\", \"default\")\n        end",
        "comment": "https://github.com/Homebrew/homebrew-core/issues/40872#issuecomment-542092547 https://github.com/Homebrew/homebrew-core/pull/48329#issuecomment-584418161",
        "label": "What",
        "id": "46"
    },
    {
        "raw_code": "def read_multi_entries(names, **options)\n          names.each_with_object({}) do |name, results|\n            key   = normalize_key(name, options)\n            entry = read_entry(key, **options)\n\n            next unless entry\n\n            version = normalize_version(name, options)\n\n            if entry.expired?\n              delete_entry(key, **options)\n            elsif !entry.mismatched?(version)\n              results[name] = entry.value\n            end",
        "comment": "Reads multiple entries from the cache implementation. Subclasses MAY implement this method.",
        "label": "What",
        "id": "13756"
    },
    {
        "raw_code": "def initialize_callbacks!(work_item)\n      @callbacks = work_item.widgets.filter_map do |widget|\n        callback_class = widget.class.try(:callback_class)\n        next if callback_class.nil?\n\n        callback_params = widget_params[widget.class.api_symbol] || {}\n        callback_params[:excluded_in_new_type] = true if new_type_excludes_widget?(widget, work_item.resource_parent)\n\n        if callback_class.const_defined?(:ALLOWED_PARAMS)\n          callback_params.reverse_merge!(params.slice(*callback_class::ALLOWED_PARAMS))\n        end",
        "comment": "rubocop:disable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "5718"
    },
    {
        "raw_code": "def resource_info(resource, key)\n        resource['info'] ? \"#{key} - #{resource['info']}\" : \"#{key} at #{resource['api_path']}\"\n      end",
        "comment": "Generates a descriptive string for a resource  @param [Hash] resource The resource hash containing resource data @param [String] key The resource type key (e.g., 'QA::Resource::Project') @return [String] Formatted resource description using 'info' if available, otherwise 'api_path'",
        "label": "What",
        "id": "4674"
    },
    {
        "raw_code": "def cutoff(id, sha)\n        if sha.present? || id.present?\n          specific_version(id, sha)\n        else\n          :unconstrained\n        end",
        "comment": "Find the most recent version that the client will accept",
        "label": "What",
        "id": "6197"
    },
    {
        "raw_code": "def preload_context\n              # no-op\n            end",
        "comment": "This method is overridden to load context into the memoized result or to lazily load context via BatchLoader",
        "label": "What",
        "id": "2489"
    },
    {
        "raw_code": "def route\n    ApplicationMailbox.route self\n  end",
        "comment": "Route this +InboundEmail+ using the routing rules declared on the +ApplicationMailbox+.",
        "label": "What",
        "id": "11095"
    },
    {
        "raw_code": "def loop?\n          false\n        end",
        "comment": "@return [Boolean] whether the node is a loop",
        "label": "What",
        "id": "318"
    },
    {
        "raw_code": "def to_s\n        \"disk config\"\n      end",
        "comment": "The String representation of this Disk.  @return [String]",
        "label": "What",
        "id": "9464"
    },
    {
        "raw_code": "def updated(date_or_time = nil)\n          @xml.updated((date_or_time || Time.now.utc).xmlschema)\n        end",
        "comment": "Accepts a Date or Time object and inserts it in the proper format. If +nil+ is passed, current time in UTC is used.",
        "label": "What",
        "id": "11809"
    },
    {
        "raw_code": "def handle_regexp_RDOCLINK(target)\n    handle_rdoc_link target.text\n  end",
        "comment": " Converts the rdoc-...: links into a Markdown.style links.",
        "label": "What",
        "id": "16388"
    },
    {
        "raw_code": "def attach_dvd(iso_path)\n        execute(:add_dvd, VmId: vm_id, ISOPath: iso_path)\n      end",
        "comment": "Add a DVD drive to VM  @param [String] iso_path @return [nil]",
        "label": "What",
        "id": "9691"
    },
    {
        "raw_code": "def create_non_functional\n          base_variables = base_pipeline_variables.map { |k, v| \"  #{k}: \\\"#{v}\\\"\" }.join(\"\\n\")\n          definitions = non_functional_test_pipeline_definitions.transform_values do |yml|\n            \"#{yml}\\nvariables:\\n#{base_variables}\"\n          end",
        "comment": "Generate non functional E2E test pipeline yaml files  @return [void]",
        "label": "What",
        "id": "4770"
    },
    {
        "raw_code": "def enqueue_upcoming_processables(free_resources, resource_group)\n        resource_group.upcoming_processables.take(free_resources).each do |upcoming|\n          Gitlab::OptimisticLocking.retry_lock(upcoming, name: 'enqueue_waiting_for_resource') do |processable|\n            if processable.has_outdated_deployment?\n              processable.drop!(:failed_outdated_deployment_job)\n            else\n              processable.enqueue_waiting_for_resource\n\n              track_internal_event(\n                \"job_enqueued_by_resource_group\",\n                user: processable.user,\n                project: resource_group.project,\n                additional_properties: {\n                  label: resource_group.process_mode,\n                  property: processable.id.to_s,\n                  resource_group_id: resource_group.id\n                }\n              )\n            end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5819"
    },
    {
        "raw_code": "def build_page(sha, ref)\n        # override this method in the including class\n      end",
        "comment": "Return complete url to build page  Ex. http://jenkins.example.com:8888/job/test1/scm/bySHA1/12d65c ",
        "label": "What",
        "id": "7477"
    },
    {
        "raw_code": "def with_entity(entity)\n      @entity = entity\n      self\n    end",
        "comment": "Extract key information from a provided entity and include it in log entries created from this logger instance. @param entity [BulkImports::Entity]",
        "label": "What",
        "id": "3601"
    },
    {
        "raw_code": "def heartbeat_runner_ack_wait(runner_manager_id)\n      return unless runner_manager_id.present? && runner_manager_id == runner_manager_id_waiting_for_ack\n\n      with_redis do |redis|\n        # Update TTL, only if key already exists\n        redis.set(runner_build_ack_queue_key, runner_manager_id, ex: RUNNER_ACK_QUEUE_EXPIRY_TIME, xx: true)\n      end",
        "comment": "Update the ttl for the Redis cache entry containing the runner manager id on which we're waiting on for acknowledgement (job accepted or job declined)",
        "label": "What",
        "id": "7543"
    },
    {
        "raw_code": "def push_licensed_features; end\n\n  def board\n    board_finder.execute.first\n  end\n  strong_memoize_attr :board\n\n  def board_visit_service\n    Boards::Visits::CreateService\n  end\n\n  def parent\n    group? ? group : project\n  end\n  strong_memoize_attr :parent\n\n  def board_path(board)\n    if group?\n      group_board_path(parent, board)\n    else\n      project_board_path(parent, board)\n    end\n  end",
        "comment": "Noop on FOSS",
        "label": "What",
        "id": "6532"
    },
    {
        "raw_code": "def in_range?\n      @chunk_range&.include?(tell)\n    end",
        "comment": " The below methods are not implemented in IO class ",
        "label": "What",
        "id": "1485"
    },
    {
        "raw_code": "def handler_base_namespace\n        self.class.namespace_for_handler[parser_type]\n      end",
        "comment": "The module holding the handlers to be loaded  @return [Module] the module containing the handlers depending on {#parser_type}.",
        "label": "What",
        "id": "185"
    },
    {
        "raw_code": "def stick_if_necessary(env)\n          namespaces_and_ids = sticking_namespaces(env)\n\n          namespaces_and_ids.each do |sticking, namespace, id|\n            lb = sticking.load_balancer\n            sticking.stick(namespace, id) if ::Gitlab::Database::LoadBalancing::SessionMap.current(lb).performed_write?\n          end",
        "comment": "Determine if we need to stick after handling a request.",
        "label": "What",
        "id": "3104"
    },
    {
        "raw_code": "def original_filename\n          @original_filename ||= self.class.original_filename(checksum)\n        end",
        "comment": "This method is used by the `carrierwave` gem",
        "label": "What",
        "id": "3270"
    },
    {
        "raw_code": "def pick(*keys)\n    return if none?\n\n    if keys.many?\n      keys.map { |key| first[key] }\n    else\n      first[keys.first]\n    end",
        "comment": "Extract the given key from the first element in the enumerable.  [{ name: \"David\" }, { name: \"Rafael\" }, { name: \"Aaron\" }].pick(:name) # => \"David\"  [{ id: 1, name: \"David\" }, { id: 2, name: \"Rafael\" }].pick(:id, :name) # => [1, \"David\"]",
        "label": "What",
        "id": "14074"
    },
    {
        "raw_code": "def canary_cookie\n        canary = ENV['QA_COOKIES']&.scan(/gitlab_canary=(true|false)/)&.dig(0, 0)\n\n        canary ? { gitlab_canary: canary } : {}\n      end",
        "comment": "Retrieves the value of the gitlab_canary cookie if set or returns an empty hash.  @return [Hash]",
        "label": "What",
        "id": "4453"
    },
    {
        "raw_code": "def test_generate_message_inclusion_with_default_message\n    assert_equal \"is not included in the list\", @person.errors.generate_message(:title, :inclusion, value: \"title\")\n  end",
        "comment": "validates_inclusion_of: generate_message(attr_name, :inclusion, message: custom_message, value: value)",
        "label": "What",
        "id": "12325"
    },
    {
        "raw_code": "def execute_script!(path, args)\n        path = File.expand_path(path, env.root_path)\n        FileUtils.chmod(\"+x\", path)\n\n        if args.is_a?(String)\n          args = \" #{args.to_s}\"\n        elsif args.is_a?(Array)\n          args = args.map { |a| quote_and_escape(a) }\n          args = \" #{args.join(\" \")}\"\n        end",
        "comment": "Execute the script, expanding the path relative to the current env root.",
        "label": "What",
        "id": "9357"
    },
    {
        "raw_code": "def result\n        if !enabled || @checkpoint_thread.nil?\n          nil\n        elsif !defined?(@result)\n          @checkpoint_thread.join(CHECKPOINT_TIMEOUT)\n          @result = @checkpoint_thread[:result]\n        else\n          @result\n        end",
        "comment": "Result of check  @return [Hash, nil]",
        "label": "What",
        "id": "9241"
    },
    {
        "raw_code": "def prepare_commits_for_rendering(commits)\n    commits.each(&:lazy_author) # preload commits' authors\n    commits.each(&:lazy_latest_pipeline)\n\n    Banzai::CommitRenderer.render(commits, @project, current_user) # rubocop:disable Gitlab/ModuleWithInstanceVariables\n\n    commits\n  end",
        "comment": "rubocop: enable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "6528"
    },
    {
        "raw_code": "def pull_request_files(repo, number, options = {})\n        paginate \"#{Repository.path repo}/pulls/#{number}/files\", options\n      end",
        "comment": "List files on a pull request  @see https://developer.github.com/v3/pulls/#list-pull-requests-files @param repo [Integer, String, Hash, Repository] A GitHub repository @param number [Integer] Number of pull request @return [Array<Sawyer::Resource>] List of files",
        "label": "What",
        "id": "15098"
    },
    {
        "raw_code": "def accept_block_quote(block_quote)\n    tt_sections block_quote.text\n  end",
        "comment": " Adds tts from +block_quote+ to the output",
        "label": "What",
        "id": "16254"
    },
    {
        "raw_code": "def transfer\n    parent_group = Group.find_by(id: params[:new_parent_group_id])\n    service = ::Groups::TransferService.new(@group, current_user)\n\n    if service.execute(parent_group)\n      flash[:notice] = \"Group '#{@group.name}' was successfully transferred.\"\n      redirect_to group_path(@group)\n    else\n      flash[:alert] = service.error.html_safe\n      redirect_to edit_group_path(@group)\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6443"
    },
    {
        "raw_code": "def update_commit_comment(repo, id, body, options = {})\n        params = {\n          body: body\n        }\n        patch \"#{Repository.path repo}/comments/#{id}\", options.merge(params)\n      end",
        "comment": "Update a commit comment  @param repo [Integer, String, Hash, Repository] A GitHub repository @param id [String] The ID of the comment to update @param body [String] Message @return [Sawyer::Resource] Updated commit comment @see https://developer.github.com/v3/repos/comments/#update-a-commit-comment @example Update a commit comment comment = Octokit.update_commit_comment(\"octocat/Hello-World\", \"860296\", \"Updated commit comment\") comment.id # => 860296 comment.body # => \"Updated commit comment\"",
        "label": "What",
        "id": "15393"
    },
    {
        "raw_code": "def decode(value)\n          raise NotAnEncodedBooleanStringError, value.class unless value.is_a?(String)\n\n          label, bool_str = *value.split(DELIMITER, 2)\n\n          raise NotAnEncodedBooleanStringError, label unless label == LABEL\n\n          from_string(bool_str)\n        end",
        "comment": "Decode a boolean string  @param value [String] the stored boolean string @return [Boolean] true or false @raise [NotAnEncodedBooleanStringError] if the provided value isn't an encoded boolean",
        "label": "What",
        "id": "1912"
    },
    {
        "raw_code": "def by_created_at_after(events)\n    return events unless params[:after]\n\n    events.where('events.created_at > ?', params[:after].end_of_day)\n  end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "7935"
    },
    {
        "raw_code": "def initialize(pull_request, project, client)\n            @pull_request = pull_request\n            @project = project\n            @client = client\n            @merged_by = pull_request.merged_by\n          end",
        "comment": "pull_request - An instance of `Gitlab::GithubImport::Representation::PullRequest` project - An instance of `Project` client - An instance of `Gitlab::GithubImport::Client`",
        "label": "What",
        "id": "2232"
    },
    {
        "raw_code": "def dry_run\n        enabled?(ENV[\"QA_RSPEC_DRY_RUN\"], default: false)\n      end",
        "comment": "Execution performed with --dry-run flag  @return [Boolean]",
        "label": "What",
        "id": "4476"
    },
    {
        "raw_code": "def stage\n      build.pipeline.stages.safe_find_or_create_by(name: 'deploy', pipeline_id: build.pipeline.id) do |stage|\n        stage.position = GenericCommitStatus::EXTERNAL_STAGE_IDX\n        stage.project = build.project\n      end",
        "comment": "rubocop: disable Performance/ActiveRecordSubtransactionMethods",
        "label": "What",
        "id": "5923"
    },
    {
        "raw_code": "def false?(encoded_value)\n          !true?(encoded_value)\n        end",
        "comment": "Decode a boolean string, then test if it's false  @param value [String] the stored boolean string @return [Boolean] is the value false? @raise [NotAnEncodedBooleanStringError] if the provided value isn't an encoded boolean",
        "label": "What",
        "id": "1914"
    },
    {
        "raw_code": "def keys_for_aggregation(events:, start_date:, end_date:, used_in_aggregate_metric: false)\n        # we always keep 1 week of margin\n        # .end_of_week is necessary to make sure this works for 1 week long periods too\n        end_date = end_date.end_of_week - 1.week\n        (start_date.to_date..end_date.to_date).flat_map do |date|\n          events.map { |event| redis_key(event, date, used_in_aggregate_metric) }\n        end.uniq\n      end",
        "comment": "requires a #redis_key(event, date, used_in_aggregate_metric) method to be defined",
        "label": "What",
        "id": "1975"
    },
    {
        "raw_code": "def modify_value(name, amount, options)\n          options = merged_options(options)\n          key = normalize_key(name, options)\n          version = normalize_version(name, options)\n          amount = Integer(amount)\n\n          lock_file(key) do\n            entry = read_entry(key, **options)\n\n            if !entry || entry.expired? || entry.mismatched?(version)\n              write(name, amount, options)\n              amount\n            else\n              num = entry.value.to_i + amount\n              entry = Entry.new(num, expires_at: entry.expires_at, version: entry.version)\n              write_entry(key, entry)\n              num\n            end",
        "comment": "Modifies the amount of an integer value that is stored in the cache. If the key is not found it is created and set to +amount+.",
        "label": "What",
        "id": "14014"
    },
    {
        "raw_code": "def list_user_installations(options = {})\n        paginate('user/installations', options) do |data, last_response|\n          data.installations.concat last_response.data.installations\n        end",
        "comment": "List all installations that are accessible to the authenticated user  @param options [Hash] A customizable set of options  @see https://docs.github.com/en/rest/apps/installations#list-app-installations-accessible-to-the-user-access-token  @return [Sawyer::Resource] the total_count and an array of installations",
        "label": "What",
        "id": "15012"
    },
    {
        "raw_code": "def days\n          seconds ? seconds.fdiv(1.day) : nil\n        end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2877"
    },
    {
        "raw_code": "def initialize(name, query, materialized: true)\n        @table = Arel::Table.new(name)\n        @query = query\n        @materialized = materialized\n      end",
        "comment": "name - The name of the CTE as a String or Symbol.",
        "label": "What",
        "id": "2848"
    },
    {
        "raw_code": "def create_check_suite(repo, head_sha, options = {})\n        options[:head_sha] = head_sha\n\n        post \"#{Repository.path repo}/check-suites\", options\n      end",
        "comment": "Create a check suite  @param repo [Integer, String, Hash, Repository] A GitHub repository @param head_sha [String] The SHA of the commit to check @return [Sawyer::Resource] A hash representing the new check suite @see https://developer.github.com/v3/checks/suites/#create-a-check-suite @example Create a check suite check_suite = @client.create_check_suite(\"octocat/Hello-World\", \"7638417db6d59f3c431d3e1f261cc637155684cd\") check_suite.head_sha # => \"7638417db6d59f3c431d3e1f261cc637155684cd\" check_suite.status # => \"queued\"",
        "label": "What",
        "id": "15272"
    },
    {
        "raw_code": "def provider_info(provider)\n        {\n          \"Box\" => provider.version.box.tag,\n          \"Private\" => provider.version.box.private ? \"yes\" : \"no\",\n          \"Version\" => provider.version.version,\n          \"Provider\" => provider.name,\n          \"Architecture\" => provider.architecture,\n          \"Default Architecture\" => provider.default_architecture ? \"yes\" : \"no\",\n        }\n      end",
        "comment": "Extract provider information for display  @param [VagrantCloud::Box::Provider] provider Box provider for extracting information @return [Hash<String,String>]",
        "label": "What",
        "id": "9751"
    },
    {
        "raw_code": "def namespace_with_same_path?\n      Namespace.exists?(path: @group.path, parent: @new_parent_group)\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5535"
    },
    {
        "raw_code": "def _AlphanumericAscii\n    _tmp = @_grammar_literals.external_invoke(self, :_AlphanumericAscii)\n    set_failed_rule :_AlphanumericAscii unless _tmp\n    return _tmp\n  end",
        "comment": "AlphanumericAscii = %literals.AlphanumericAscii",
        "label": "What",
        "id": "15805"
    },
    {
        "raw_code": "def process_message(method, **params)\n    server.process_message(id: request_id.next, method: method, params: params)\n  end",
        "comment": "rubocop:enable Metrics/MethodLength",
        "label": "What",
        "id": "11006"
    },
    {
        "raw_code": "def create_inbound_email_from_fixture(fixture_name, status: :processing)\n      create_inbound_email_from_source file_fixture(fixture_name).read, status: status\n    end",
        "comment": "Create an InboundEmail record using an eml fixture in the format of message/rfc822 referenced with +fixture_name+ located in +test/fixtures/files/fixture_name+.",
        "label": "What",
        "id": "11099"
    },
    {
        "raw_code": "def self.action_box_add\n      Builder.new.tap do |b|\n        b.use Builtin::BoxAdd\n      end",
        "comment": "This is the action that will add a box from a URL. This middleware sequence is built-in to Vagrant. Plugins can hook into this like any other middleware sequence. This is particularly useful for provider plugins, which can hook in to do things like verification of boxes that are downloaded.",
        "label": "What",
        "id": "8800"
    },
    {
        "raw_code": "def up\n    prepare_async_index_removal :merge_requests, COLUMN_NAME, name: INDEX_NAME\n  end",
        "comment": "TODO: Index to be destroyed synchronously in https://gitlab.com/gitlab-org/gitlab/-/issues/454457",
        "label": "What",
        "id": "4887"
    },
    {
        "raw_code": "def self.preload_relation(projects_relation, options = {})\n        # Preloading topics, should be done with using only `:topics`,\n        # as `:topics` are defined as: `has_many :topics, through: :project_topics`\n        # N+1 is solved then by using `subject.topics.map(&:name)`\n        # MR describing the solution: https://gitlab.com/gitlab-org/gitlab-foss/merge_requests/20555\n        projects_relation.preload(:project_feature, :route)\n                         .preload(:import_state, :topics)\n                         .preload(:auto_devops)\n                         .preload(namespace: [:route, :owner, :namespace_settings_with_ancestors_inherited_settings])\n      end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "3809"
    },
    {
        "raw_code": "def start_configuration\n      conn = authenticated_client\n      @last_response = conn.post('/manage/v1/config/apply')\n    end",
        "comment": "Start a configuration process.  @return [nil]",
        "label": "What",
        "id": "14926"
    },
    {
        "raw_code": "def self.load!(basepath)\n            basepath = Pathname(basepath) unless basepath.is_a? Pathname\n\n            json_file = basepath.join(METADATA_FILENAME)\n            json = JSON.parse(File.read(json_file), JSON_PARSE_OPTIONS)\n            deserializer = Gitlab::Backup::Cli::Metadata::Deserializer\n\n            parsed_fields = {}\n            METADATA_SCHEMA.each do |attribute_name, type|\n              stored_value = json[attribute_name]\n              parsed_value = deserializer.parse_value(type: type, value: stored_value)\n\n              parsed_fields[attribute_name] = parsed_value\n            end",
        "comment": "Load the metadata from the JSON file stored in the given basepath  @param [String|Pathname] basepath @return [Gitlab::Backup::Cli::Metadata::BackupMetadata, nil]",
        "label": "What",
        "id": "1083"
    },
    {
        "raw_code": "def self.mount_vmware_shared_folder(machine, name, guestpath, options)\n          # Use this variable to determine which machines\n          # have been registered with after hook\n          @apply_firmlinks ||= Hash.new{ |h, k| h[k] = {bootstrap: false, content: []} }\n\n          machine.communicate.tap do |comm|\n            # check if we are dealing with an APFS root container\n            if comm.test(\"test -d /System/Volumes/Data\")\n              parts = Pathname.new(guestpath).descend.to_a\n              firmlink = parts[1].to_s\n              firmlink.slice!(0, 1) if firmlink.start_with?(\"/\")\n              if parts.size > 2\n                guestpath = File.join(\"/System/Volumes/Data\", guestpath)\n              else\n                guestpath = nil\n              end",
        "comment": "we seem to be unable to ask 'mount -t vmhgfs' to mount the roots of specific shares, so instead we symlink from what is already mounted by the guest tools (ie. the behaviour of the VMware_fusion provider prior to 0.8.x)",
        "label": "What",
        "id": "9836"
    },
    {
        "raw_code": "def self.find_executable(binary)\n          executable_file = proc { |name| next name if File.file?(name) && File.executable?(name) }\n\n          # Retrieve PATH from ENV or use a fallback\n          path = ENV['PATH']&.split(File::PATH_SEPARATOR) || %w[/usr/local/bin /usr/bin /bin]\n\n          # check binary against each PATH\n          path.each do |dir|\n            file = File.expand_path(binary, dir)\n\n            return file if executable_file.call(file)\n          end",
        "comment": "Search on PATH or default locations for provided binary and return its fullpath  @param [String] binary name @return [String|False] full path to the binary file",
        "label": "What",
        "id": "1029"
    },
    {
        "raw_code": "def with_isolated_sidekiq_job\n          Sidekiq::Testing.fake! do\n            ::Gitlab::SafeRequestStore.ensure_request_store do\n              # If you are attempting to import a large project into a development environment,\n              # you may see Gitaly throw an error about too many calls or invocations.\n              # This is due to a n+1 calls limit being set for development setups (not enforced in production)\n              # https://gitlab.com/gitlab-org/gitlab/-/merge_requests/24475#note_283090635\n              # For development setups, this code-path will be excluded from n+1 detection.\n              ::Gitlab::GitalyClient.allow_n_plus_1_calls do\n                yield\n              end",
        "comment": "We want to ensure that all Sidekiq jobs are executed synchronously as part of that process. This ensures that all expensive operations do not escape to general Sidekiq clusters/nodes.",
        "label": "What",
        "id": "2824"
    },
    {
        "raw_code": "def octokit_warn(*message)\n      warn message unless ENV['OCTOKIT_SILENT']\n    end",
        "comment": "Wrapper around Kernel#warn to print warnings unless OCTOKIT_SILENT is set to true.  @return [nil]",
        "label": "What",
        "id": "14913"
    },
    {
        "raw_code": "def etag(action)\n        ActionDispatch::TestResponse.new.send(:generate_weak_etag, [action.cache_key])\n      end",
        "comment": "The design images generated by Factorybot are identical, so refer to the `ETag` header, which is uniquely generated from the Action (the record that represents the design at a specific version), to verify that the correct file is being returned.",
        "label": "What",
        "id": "8293"
    },
    {
        "raw_code": "def _HtmlBlockP\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenP)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockP = HtmlBlockOpenP (HtmlBlockP | !HtmlBlockCloseP .)* HtmlBlockCloseP",
        "label": "What",
        "id": "15682"
    },
    {
        "raw_code": "def write_lfs_json\n      filepath = File.join(export_path, \"#{BulkImports::FileTransfer::ProjectConfig::LFS_OBJECTS_RELATION}.json\")\n\n      File.write(filepath, Gitlab::Json.dump(lfs_json))\n    end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5875"
    },
    {
        "raw_code": "def each(&block) # :yields: gem.full_name, gem\n    @gems.each(&block)\n  end",
        "comment": " Iterate over the specifications in the source index.",
        "label": "What",
        "id": "271"
    },
    {
        "raw_code": "def self.set_ssh_key_permissions(env, key_path)\n          key_path.chmod(0600)\n        end",
        "comment": "Set the ownership and permissions for SSH private key  @param [Vagrant::Environment] env @param [Pathname] key_path",
        "label": "What",
        "id": "9717"
    },
    {
        "raw_code": "def write_entry(key, entry, **options)\n          raise NotImplementedError.new\n        end",
        "comment": "Writes an entry to the cache implementation. Subclasses must implement this method.",
        "label": "What",
        "id": "13755"
    },
    {
        "raw_code": "def update(**data)\n      @backup_information ||= BackupInformation.new\n\n      data.each_pair do |key, value|\n        backup_information[key] = value\n      end",
        "comment": "Update backup information with provided data  @param [Hash] data arguments matching #BackupInformation keyword arguments",
        "label": "What",
        "id": "3648"
    },
    {
        "raw_code": "def start\n        execute(:start_vm, VmId: vm_id )\n      end",
        "comment": "Start the VM  @return [nil]",
        "label": "What",
        "id": "9675"
    },
    {
        "raw_code": "def test_render_file_from_template\n    get :render_file_from_template\n    assert_equal \"The secret is &lt;%= @secret %&gt;\\n\", @response.body\n  end",
        "comment": ":assessed:",
        "label": "What",
        "id": "12073"
    },
    {
        "raw_code": "def line\n        tokens.first.line_no\n      end",
        "comment": "@return [Fixnum] the first line of Ruby source",
        "label": "What",
        "id": "330"
    },
    {
        "raw_code": "def clear_validators!\n        reset_callbacks(:validate)\n        _validators.clear\n      end",
        "comment": "Clears all of the validators and validations.  Note that this will clear anything that is being used to validate the model for both the +validates_with+ and +validate+ methods. It clears the validators that are created with an invocation of +validates_with+ and the callbacks that are set by an invocation of +validate+.  class Person include ActiveModel::Validations  validates_with MyValidator validates_with OtherValidator, on: :create validates_with StrictValidator, strict: true validate :cannot_be_robot  def cannot_be_robot errors.add(:base, 'A person cannot be a robot') if person_is_robot end end  Person.validators # => [ #      #<MyValidator:0x007fbff403e808 @options={}>, #      #<OtherValidator:0x007fbff403d930 @options={on: :create}>, #      #<StrictValidator:0x007fbff3204a30 @options={strict:true}> #    ]  If one runs <tt>Person.clear_validators!</tt> and then checks to see what validators this class has, you would obtain:  Person.validators # => []  Also, the callback set by <tt>validate :cannot_be_robot</tt> will be erased so that:  Person._validate_callbacks.empty?  # => true ",
        "label": "What",
        "id": "12266"
    },
    {
        "raw_code": "def on_back_ref_or_gvar_or_nth_ref(node)\n          preferred_expression = preferred_expression_to_node_with_constant_prefix(node)\n          return unless preferred_expression\n\n          add_offense(\n            node,\n            message: format_message(node: node, preferred_expression: preferred_expression)\n          ) do |corrector|\n            if derived_from_braceless_interpolation?(node)\n              preferred_expression = \"{#{preferred_expression}}\"\n            end",
        "comment": "@private @param [RuboCop::AST::Node] node",
        "label": "What",
        "id": "10515"
    },
    {
        "raw_code": "def self.current_version\n        2.3\n      end",
        "comment": "The current version to be used in new migrations",
        "label": "What",
        "id": "3030"
    },
    {
        "raw_code": "def update_project_card(id, options = {})\n        patch \"projects/columns/cards/#{id}\", options\n      end",
        "comment": "Update a project card  Requires authenticated client  @param id [Integer] Project card id @option options [String] :note The card's note content. Only valid for cards without another type of content, so this cannot be specified if the card already has a content_id and content_type. @return [Sawyer::Resource] Updated project card @see https://developer.github.com/v3/projects/cards/#update-a-project-card @example @client.update_project_card(12345, note: 'new note')",
        "label": "What",
        "id": "15329"
    },
    {
        "raw_code": "def label(repo, name, options = {})\n        get \"#{Repository.path repo}/labels/#{ERB::Util.url_encode(name)}\", options\n      end",
        "comment": "Get single label for a repository  @param repo [Integer, String, Repository, Hash] A GitHub repository @param name [String] Name of the label @return [Sawyer::Resource] A single label from the repository @see https://developer.github.com/v3/issues/labels/#get-a-single-label @example Get the \"V3 Addition\" label from octokit/octokit.rb Octokit.label(\"octokit/octokit.rb\", \"V3 Addition\")",
        "label": "What",
        "id": "15283"
    },
    {
        "raw_code": "def register_alias(string, symbol, extension_synonyms = [])\n        register(string, symbol, [], extension_synonyms, true)\n      end",
        "comment": "Registers an alias that's not used on MIME type lookup, but can be referenced directly. Especially useful for rendering different HTML versions depending on the user agent, like an iPhone.",
        "label": "What",
        "id": "11438"
    },
    {
        "raw_code": "def client_belongs_to_user?(client, user)\n            resp = fetch_user_details(client)\n            unless status_ok?(resp)\n              raise InvalidTokenError, \"API client validation failed! Code: #{resp.code}, Err: '#{resp.body}'\"\n            end",
        "comment": "Check if token belongs to specific user  @param [QA::Runtime::API::Client] client @param [QA::Resource::User] user @return [Boolean]",
        "label": "What",
        "id": "4517"
    },
    {
        "raw_code": "def self.directory_changed?(dir_path, threshold_time)\n        Dir.glob(Pathname.new(dir_path).join(\"**\", \"*\")).any? do |path|\n          Pathname.new(path).mtime > threshold_time\n        end",
        "comment": "Check if directory has any new updates  @param [Pathname, String] Path to directory @param [Time] time to compare to eg. has any file in dir_path changed since this time @return [Boolean]",
        "label": "What",
        "id": "9141"
    },
    {
        "raw_code": "def local_storage_config\n          <<~YAML\n            ---\n            apiVersion: v1\n            kind: ServiceAccount\n            metadata:\n              name: storage-provisioner\n              namespace: kube-system\n            ---\n            apiVersion: rbac.authorization.k8s.io/v1\n            kind: ClusterRoleBinding\n            metadata:\n              name: storage-provisioner\n            roleRef:\n              apiGroup: rbac.authorization.k8s.io\n              kind: ClusterRole\n              name: system:persistent-volume-provisioner\n            subjects:\n              - kind: ServiceAccount\n                name: storage-provisioner\n                namespace: kube-system\n            ---\n            apiVersion: v1\n            kind: Pod\n            metadata:\n              name: storage-provisioner\n              namespace: kube-system\n            spec:\n              serviceAccountName: storage-provisioner\n              tolerations:\n              - effect: NoExecute\n                key: node.kubernetes.io/not-ready\n                operator: Exists\n                tolerationSeconds: 300\n              - effect: NoExecute\n                key: node.kubernetes.io/unreachable\n                operator: Exists\n                tolerationSeconds: 300\n              hostNetwork: true\n              containers:\n              - name: storage-provisioner\n                image: gcr.io/k8s-minikube/storage-provisioner:v1.8.1\n                command: [\"/storage-provisioner\"]\n                imagePullPolicy: IfNotPresent\n                volumeMounts:\n                - mountPath: /tmp\n                  name: tmp\n              volumes:\n              - name: tmp\n                hostPath:\n                  path: /tmp\n                  type: Directory\n            ---\n            kind: StorageClass\n            apiVersion: storage.k8s.io/v1\n            metadata:\n              name: standard\n              namespace: kube-system\n              annotations:\n                storageclass.kubernetes.io/is-default-class: \"true\"\n              labels:\n                addonmanager.kubernetes.io/mode: EnsureExists\n            provisioner: k8s.io/minikube-hostpath\n          YAML\n        end",
        "comment": "See https://github.com/rancher/k3d/issues/67",
        "label": "What",
        "id": "4223"
    },
    {
        "raw_code": "def add_quarantine_issue_link(example)\n          issue_link = example.metadata.dig(:quarantine, :issue)\n\n          return unless issue_link\n          return example.issue('Quarantine issue', issue_link) if issue_link.is_a?(String)\n\n          issue_link.each { |link| example.issue('Quarantine issue', link) } if issue_link.is_a?(Array)\n        rescue StandardError => e\n          log(:error, \"Failed to add quarantine issue link for example '#{example.description}', error: #{e}\")\n        end",
        "comment": "Add quarantine issue links  @param [RSpec::Core::Example] example @return [void]",
        "label": "What",
        "id": "4597"
    },
    {
        "raw_code": "def up\n    # no-op\n  end",
        "comment": "To be re-enqueued by: db/post_migrate/20250708101955_requeue_backfill_terraform_modules_metadata_with_semver.rb",
        "label": "What",
        "id": "4946"
    },
    {
        "raw_code": "def up\n    prepare_async_index_removal :merge_requests, COLUMN_NAMES, name: INDEX_NAME\n  end",
        "comment": "TODO: Index to be destroyed synchronously in https://gitlab.com/gitlab-org/gitlab/-/issues/454262",
        "label": "What",
        "id": "4934"
    },
    {
        "raw_code": "def encode(value)\n          raise NotABooleanError, value unless bool?(value)\n\n          [LABEL, to_string(value)].join(DELIMITER)\n        end",
        "comment": "Turn a boolean into a string for storage in Redis  @param value [Boolean] true or false @return [String] the encoded boolean @raise [NotABooleanError] if the value isn't true or false",
        "label": "What",
        "id": "1911"
    },
    {
        "raw_code": "def gl_milestones\n        @gl_milestones ||= begin\n          logger.debug(\"= Fetching milestones =\")\n          imported_project.milestones(auto_paginate: true, attempts: 3).map { |ms| ms.slice(:title, :description) }\n        end",
        "comment": "Imported project milestones  @return [<Type>] <description>",
        "label": "What",
        "id": "4409"
    },
    {
        "raw_code": "def stopping?\n      self[\"quiet\"] == \"true\"\n    end",
        "comment": "@return [Boolean] true if this process is quiet or shutting down",
        "label": "What",
        "id": "5153"
    },
    {
        "raw_code": "def terraform_state_path\n            path = gitlab_config.dig(env, 'terraform_state', 'storage_path') ||\n              gitlab_shared_path.join(DEFAULT_TERRAFORM_STATE_PATH)\n\n            absolute_path(path)\n          end",
        "comment": "Terraform State basepath",
        "label": "What",
        "id": "1097"
    },
    {
        "raw_code": "def create_new(source_branch:)\n        if Page::Project::Show.perform(&:has_create_merge_request_button?)\n          Page::Project::Show.perform(&:new_merge_request)\n          return\n        end",
        "comment": "Opens the form to create a new merge request. It tries to use the \"Create merge request\" button that appears after a commit is pushed, but if that button isn't available, it uses the \"New merge request\" button on the page that lists merge requests.  @param [String] source_branch the branch to be merged",
        "label": "What",
        "id": "4249"
    },
    {
        "raw_code": "def length\n      @items.keys.length\n    end",
        "comment": "Return the number of elements in this registry.  @return [Integer]",
        "label": "What",
        "id": "8748"
    },
    {
        "raw_code": "def feature_table_exists?\n        # Use table_exists? (which uses ActiveRecord's schema cache) instead of Feature.feature_flags_available?\n        # as the latter runs a ';' SQL query which causes a connection to be checked out.\n        Feature::FlipperFeature.table_exists?\n      rescue StandardError\n        false\n      end",
        "comment": "@return [Boolean]",
        "label": "What",
        "id": "1903"
    },
    {
        "raw_code": "def trigger_abort(exit_code)\n          if Thread.current[:batch_parallel_action]\n            @ui.warn(I18n.t(\"vagrant.trigger.abort_threaded\"))\n            @logger.debug(\"Trigger abort within parallel batch action. \" \\\n              \"Setting exit code and terminating.\")\n            Thread.current[:exit_code] = exit_code\n            Thread.current.terminate\n          else\n            @ui.warn(I18n.t(\"vagrant.trigger.abort\"))\n            @logger.debug(\"Trigger abort within non-parallel action, exiting directly\")\n            Process.exit!(exit_code)\n          end",
        "comment": "Exits Vagrant immediately  @param [Integer] code Code to exit Vagrant on",
        "label": "What",
        "id": "9049"
    },
    {
        "raw_code": "def success(output)\n          if output.empty?\n            Gitlab::AppLogger.info(message: 'Chat pipeline successful, but output is empty')\n            return\n          end",
        "comment": "Sends the output for a build that completed successfully.  output - The output produced by the chat command.",
        "label": "What",
        "id": "2443"
    },
    {
        "raw_code": "def find_nth_file(basename, index = 1)\n          n = 1\n          full_paths.each do |path|\n            file = File.join(path, basename)\n            if File.file?(file)\n              return file if index == n\n              n += 1\n            end",
        "comment": "Searches for the nth file (where n = +index+) identified by basename in the template's path and any mixed in template paths.  @param [String] basename the filename to search for @param [Fixnum] index the nth existing file to return @return [String] the full path of the nth file on disk with filename +basename+ in one of the template paths",
        "label": "What",
        "id": "358"
    },
    {
        "raw_code": "def sticking_namespaces(env)\n          warden = env['warden']\n\n          if warden && warden.user\n            # When sticking per user, _only_ sticking the main connection could\n            # result in the application trying to read data from a different\n            # connection, while that data isn't available yet.\n            #\n            # To prevent this from happening, we scope sticking to all the\n            # models that support load balancing. In the future (if we\n            # determined this to be OK) we may be able to relax this.\n            ::Gitlab::Database::LoadBalancing.base_models.map do |model|\n              [model.sticking, :user, warden.user.id]\n            end",
        "comment": "Determines the sticking namespace and identifier based on the Rack environment.  For Rails requests this uses warden, but Grape and others have to manually set the right environment variable.",
        "label": "What",
        "id": "3105"
    },
    {
        "raw_code": "def up\n    create_table :oauth_access_token_archived_records, id: false do |t|\n      t.bigint :id, null: false\n      t.bigint :resource_owner_id\n      t.bigint :application_id\n      t.string :token, null: false\n      t.string :refresh_token\n      t.integer :expires_in, default: 7200, null: false\n      t.datetime :revoked_at\n      t.datetime :created_at, null: false\n      t.string :scopes\n      t.references :organization, null: false, index: true, foreign_key: { on_delete: :cascade }\n      t.datetime_with_timezone :archived_at, null: false, default: -> { 'CURRENT_TIMESTAMP' }\n    end",
        "comment": "rubocop:disable Migration/PreventStrings -- Keeps compatibility with existing table rubocop:disable Migration/Datetime -- Keeps compatibility with existing table",
        "label": "What",
        "id": "4985"
    },
    {
        "raw_code": "def generate\n    @store.save\n  end",
        "comment": " Writes the parsed data store to disk for use by ri.",
        "label": "What",
        "id": "16452"
    },
    {
        "raw_code": "def parallel_run?\n        ENV[\"TEST_ENV_NUMBER\"].present?\n      end",
        "comment": "Execution was started by parallel runner  @return [Boolean]",
        "label": "What",
        "id": "4472"
    },
    {
        "raw_code": "def self.action_install\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use InstallGem\n        end",
        "comment": "This middleware sequence will install a plugin.",
        "label": "What",
        "id": "9796"
    },
    {
        "raw_code": "def range_size(range_node)\n          vals = range_node.to_a\n          return :unknown unless vals.all? { |val| val.nil? || val.int_type? }\n\n          low, high = vals.map { |val| val.nil? ? 0 : val.children[0] }\n          return :unknown unless low.zero? && high >= 0\n\n          case range_node.type\n          when :erange\n            (low...high).size\n          when :irange\n            (low..high).size\n          end",
        "comment": "rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10545"
    },
    {
        "raw_code": "def interpret_app(path)\n        File.basename(path)\n      end",
        "comment": "Interpret the name of the Heroku application from the given path. @param [String] path @return [String]",
        "label": "What",
        "id": "9373"
    },
    {
        "raw_code": "def to_s\n        \"cloud_init config\"\n      end",
        "comment": "The String representation of this config.  @return [String]",
        "label": "What",
        "id": "9461"
    },
    {
        "raw_code": "def at\n      Time.at(score).utc\n    end",
        "comment": "The timestamp associated with this entry",
        "label": "What",
        "id": "5124"
    },
    {
        "raw_code": "def buckets(buckets = nil)\n          @buckets = buckets unless buckets.nil?\n\n          @buckets\n        end",
        "comment": "Measurement buckets for histograms",
        "label": "What",
        "id": "2314"
    },
    {
        "raw_code": "def prune_network(opts=nil)\n        command = ['docker', 'network', 'prune', '--force'].push(*opts)\n        output = execute(*command)\n        output\n      end",
        "comment": "Will delete _all_ defined but unused networks in the docker engine. Even networks not created by Vagrant.  @param [Array] opts - An array of flags used for listing networks",
        "label": "What",
        "id": "9491"
    },
    {
        "raw_code": "def extract_users(params)\n      Gitlab::QuickActions::UsersExtractor\n        .new(current_user, project: project, group: group, target: quick_action_target, text: params)\n        .execute\n\n    rescue Gitlab::QuickActions::UsersExtractor::Error => err\n      extract_users_failed(err)\n    end",
        "comment": "Find users for commands like /assign  eg. /assign me and @jane and jack",
        "label": "What",
        "id": "6121"
    },
    {
        "raw_code": "def plain?(filename)\n      extension(filename) == 'txt' || plain_filename?(filename)\n    end",
        "comment": "Public: Determines if the given filename is plain text.  filename - Filename string to check  Returns boolean",
        "label": "What",
        "id": "1358"
    },
    {
        "raw_code": "def self.generator_name # :doc:\n          @generator_name ||= if generator = name.to_s.split(\"::\").last\n            generator.delete_suffix!(\"Generator\")\n            generator.underscore\n          end",
        "comment": "Removes the namespaces and get the generator name. For example, Rails::Generators::ModelGenerator will return \"model\" as generator name.",
        "label": "What",
        "id": "14771"
    },
    {
        "raw_code": "def self.full_cache_multi_key(cache_key, pipeline_name)\n      return unless cache_key\n\n      Rails.cache.__send__(:expanded_key, full_cache_key(cache_key, pipeline_name)) # rubocop:disable GitlabSecurity/PublicSend\n    end",
        "comment": "To map Rails.cache.read_multi results we need to know the Rails.cache.expanded_key. Other option will be to generate stringified keys on our side and don't delegate to Rails.cache.expanded_key method.",
        "label": "What",
        "id": "3398"
    },
    {
        "raw_code": "def []=(key, value)\n        @req.set_header env_name(key), value\n      end",
        "comment": "Sets the given value for the key mapped to @env.",
        "label": "What",
        "id": "11426"
    },
    {
        "raw_code": "def position_between(pos_before, pos_after)\n        pos_before ||= range.first\n        pos_after ||= range.last\n\n        pos_before, pos_after = [pos_before, pos_after].sort\n\n        gap_width = pos_after - pos_before\n\n        if gap_too_small?(pos_before, pos_after)\n          raise NoSpaceLeft\n        elsif gap_width > MAX_GAP\n          if pos_before <= range.first\n            pos_after - IDEAL_DISTANCE\n          elsif pos_after >= range.last\n            pos_before + IDEAL_DISTANCE\n          else\n            midpoint(pos_before, pos_after)\n          end",
        "comment": "This method takes two integer values (positions) and calculates the position between them. The range is huge as the maximum integer value is 2147483647.  We avoid open ranges by clamping the range to [MIN_POSITION, MAX_POSITION].  Then we handle one of three cases: - If the gap is too small, we raise NoSpaceLeft - If the gap is larger than MAX_GAP, we place the new position at most IDEAL_DISTANCE from the edge of the gap. - otherwise we place the new position at the midpoint.  The new position will always satisfy: pos_before <= midpoint <= pos_after  As a precondition, the gap between pos_before and pos_after MUST be >= 2. If the gap is too small, NoSpaceLeft is raised.  @raises NoSpaceLeft",
        "label": "What",
        "id": "2935"
    },
    {
        "raw_code": "def update_sql(from_id, to_id)\n        <<~SQL\n          WITH updated_records AS MATERIALIZED (\n            UPDATE services SET active = TRUE\n            WHERE services.project_id BETWEEN #{Integer(from_id)} AND #{Integer(to_id)} AND services.properties = '{}' AND services.type = '#{Migratable::PrometheusService.type}'\n            AND #{group_cluster_condition(from_id, to_id)} AND services.active = FALSE\n            RETURNING *\n          )\n          SELECT COUNT(*) as number_of_updated_records\n          FROM updated_records\n        SQL\n      end",
        "comment": "there is no uniq constraint on project_id and type pair, which prevents us from using ON CONFLICT",
        "label": "What",
        "id": "3261"
    },
    {
        "raw_code": "def team_by_name(org, team_slug, options = {})\n        get \"#{Organization.path(org)}/teams/#{team_slug}\", options\n      end",
        "comment": "Get team by name and org  Requires authenticated organization member.  @param org [String, Integer] Organization GitHub login or id. @param team_slug [String] Team slug. @return [Sawyer::Resource] Hash representing team. @see https://developer.github.com/v3/teams/#get-team-by-name @example @client.team_by_name(\"github\", \"justice-league\")",
        "label": "What",
        "id": "15432"
    },
    {
        "raw_code": "def tags(path, page_size: 100, last: nil, before: nil, name: nil, sort: nil, referrers: nil, referrer_type: nil)\n      limited_page_size = [page_size, MAX_TAGS_PAGE_SIZE].min\n      with_token_faraday do |faraday_client|\n        url = \"#{GITLAB_REPOSITORIES_PATH}/#{path}/tags/list/\"\n        response = faraday_client.get(url) do |req|\n          req.params['n'] = limited_page_size\n          req.params['last'] = last if last\n          req.params['before'] = before if before\n          req.params['name'] = name if name.present?\n          req.params['sort'] = sort if sort\n          req.params['referrers'] = 'true' if referrers\n          req.params['referrer_type'] = referrer_type if referrer_type\n        end",
        "comment": "https://gitlab.com/gitlab-org/container-registry/-/blob/master/docs/spec/gitlab/api.md#list-repository-tags",
        "label": "What",
        "id": "3373"
    },
    {
        "raw_code": "def no_wait_poll\n            remove if can_remove_no_wait?\n          end",
        "comment": "Remove and return the head of the queue if the number of available elements is strictly greater than the number of threads currently waiting.  Otherwise, return +nil+.",
        "label": "What",
        "id": "13195"
    },
    {
        "raw_code": "def bundler_lock_file_path\n      return nil unless loaded_path\n\n      base_path = base_dir_for_path_parameters\n      ['Gemfile.lock', 'gems.locked'].each do |file_name|\n        path = find_file_upwards(file_name, base_path)\n        return path if path\n      end",
        "comment": "@return [String, nil]",
        "label": "What",
        "id": "10176"
    },
    {
        "raw_code": "def self.wsl_allow_non_drvfs?\n        true\n      end",
        "comment": "Enable rsync synced folders within WSL when in use on non-DrvFs file systems",
        "label": "What",
        "id": "9420"
    },
    {
        "raw_code": "def wsl_rootfs\n          return @_wsl_rootfs if defined?(@_wsl_rootfs)\n\n          if wsl?\n            # Mark our filesystem with a temporary file having an unique name.\n            marker = Tempfile.new(Time.now.to_i.to_s)\n            logger = Log4r::Logger.new(\"vagrant::util::platform::wsl\")\n\n            # Check for lxrun installation first\n            lxrun_path = [wsl_windows_appdata_local, \"lxss\"].join(\"\\\\\")\n            paths = [lxrun_path]\n\n            logger.debug(\"checking registry for WSL installation path\")\n            paths += PowerShell.execute_cmd(\n              '(Get-ChildItem HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Lxss ' \\\n                '| ForEach-Object {Get-ItemProperty $_.PSPath}).BasePath').to_s.split(\"\\r\\n\").map(&:strip)\n            paths.delete_if{|path| path.to_s.empty?}\n\n            paths.each do |path|\n              # Lowercase the drive letter, skip the next symbol (which is a\n              # colon from a Windows path) and convert path to UNIX style.\n              check_path = \"/mnt/#{path[0, 1].downcase}#{path[2..-1].tr('\\\\', '/')}/rootfs\"\n              begin\n                process = Subprocess.execute(\"wslpath\", \"-u\", \"-a\", path)\n                check_path = \"#{process.stdout.chomp}/rootfs\" if process.exit_code == 0\n              rescue Errors::CommandUnavailable => e\n                # pass\n              end",
        "comment": "Compute the path to rootfs of currently active WSL.  @return [String] A path to rootfs of a current WSL instance.",
        "label": "What",
        "id": "9207"
    },
    {
        "raw_code": "def remove_equals_in_def(asgn_tokens, processed_source)\n        nodes = processed_source.ast.each_node(:optarg, :def)\n        eqls_to_ignore = nodes.with_object([]) do |node, arr|\n          loc = if node.def_type?\n                  node.loc.assignment if node.endless?\n                else\n                  node.loc.operator\n                end",
        "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity rubocop:enable Metrics/PerceivedComplexity, Metrics/MethodLength",
        "label": "What",
        "id": "10474"
    },
    {
        "raw_code": "def ping_container_registry\n      ContainerRegistry::Client.registry_info\n    end",
        "comment": "rubocop:enable Gitlab/ModuleWithInstanceVariables",
        "label": "What",
        "id": "6582"
    },
    {
        "raw_code": "def self.from_api_response(lfs_object, additional_data = {})\n          new(\n            oid: lfs_object.oid,\n            link: lfs_object.link,\n            size: lfs_object.size,\n            headers: lfs_object.headers\n          )\n        end",
        "comment": "Builds a lfs_object",
        "label": "What",
        "id": "2265"
    },
    {
        "raw_code": "def connection_options\n        {\n          headers: {\n            accept: default_media_type,\n            user_agent: user_agent\n          }\n        }\n      end",
        "comment": "Default options for Faraday::Connection @return [Hash]",
        "label": "What",
        "id": "14887"
    },
    {
        "raw_code": "def add_serializers(*new_serializers)\n        new_serializers = new_serializers.flatten\n        new_serializers.map! do |s|\n          if s.is_a?(Class) && s < ObjectSerializer\n            s.instance\n          else\n            s\n          end",
        "comment": "Adds new serializers to a list of known serializers.",
        "label": "What",
        "id": "12138"
    },
    {
        "raw_code": "def disable_automated_security_fixes(repo, options = {})\n        boolean_from_response(:delete, \"#{Repository.path repo}/automated-security-fixes\", options)\n      end",
        "comment": "Disable automated security fixes for a repository  @param repo [Integer, String, Hash, Repository] A GitHub repository. @param options [Hash]  @return [Boolean] True if vulnerability alerts disabled, false otherwise. @see https://docs.github.com/en/rest/reference/repos#automated-security-fixes @example Disable  automated security fixes for a repository @client.disable_automated_security_fixes(\"octokit/octokit.rb\")",
        "label": "What",
        "id": "15177"
    },
    {
        "raw_code": "def find_or_create_source_user(source_name:, source_username:, source_user_identifier:, cache: true)\n        source_user = find_source_user(source_user_identifier)\n        return source_user if source_user\n\n        source_user = create_source_user(\n          source_name: source_name,\n          source_username: source_username,\n          source_user_identifier: source_user_identifier\n        )\n\n        cache_from_request_store[source_user_identifier] = source_user if cache\n\n        source_user\n      end",
        "comment": "Finds a source user by the provided `source_user_identifier` or creates a new one",
        "label": "What",
        "id": "2930"
    },
    {
        "raw_code": "def codequality_mr_diff_reports\n    reports_response(@merge_request.find_codequality_mr_diff_reports, head_pipeline)\n  end",
        "comment": "documented in doc/development/rails_endpoints/index.md",
        "label": "What",
        "id": "6609"
    },
    {
        "raw_code": "def name(prefix = false)\n        prefix ? \"#{@imethod && ISEP}#{@name}\" : @name\n      end",
        "comment": "(see Base#name)",
        "label": "What",
        "id": "628"
    },
    {
        "raw_code": "def authed_projects(feature)\n      strong_memoize(\"#{feature}_projects\") do\n        # no need to check features access of current user, if the contributor opted-in\n        # to show all private events anyway - otherwise they would get filtered out again\n        next contributed_project_ids if contributor.include_private_contributions?\n\n        # rubocop: disable CodeReuse/ActiveRecord -- no need to move this to ActiveRecord model\n        ProjectFeature\n          .with_feature_available_for_user(feature, current_user)\n          .where(project_id: contributed_project_ids)\n          .pluck(:project_id)\n        # rubocop: enable CodeReuse/ActiveRecord\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "1597"
    },
    {
        "raw_code": "def extractable_options?\n      true\n    end",
        "comment": "Returns +true+ so that <tt>Array#extract_options!</tt> finds members of this class.",
        "label": "What",
        "id": "13873"
    },
    {
        "raw_code": "def exists?(conditions = :none)\n      return false if @none\n\n      if Base === conditions\n        raise ArgumentError, <<-MSG.squish\n          You are passing an instance of ActiveRecord::Base to `exists?`.\n          Please pass the id of the object by calling `.id`.\n        MSG\n      end",
        "comment": "Returns true if a record exists in the table that matches the +id+ or conditions given, or false otherwise. The argument can take six forms:  * Integer - Finds the record with this primary key. * String - Finds the record with a primary key corresponding to this string (such as <tt>'5'</tt>). * Array - Finds the record that matches these +where+-style conditions (such as <tt>['name LIKE ?', \"%#{query}%\"]</tt>). * Hash - Finds the record that matches these +where+-style conditions (such as <tt>{name: 'David'}</tt>). * +false+ - Returns always +false+. * No args - Returns +false+ if the relation is empty, +true+ otherwise.  For more information about specifying conditions as a hash or array, see the Conditions section in the introduction to ActiveRecord::Base.  Note: You can't pass in a condition as a string (like <tt>name = 'Jamie'</tt>), since it would be sanitized and then queried against the primary key column, like <tt>id = 'name = \\'Jamie\\''</tt>.  Person.exists?(5) Person.exists?('5') Person.exists?(['name LIKE ?', \"%#{query}%\"]) Person.exists?(id: [1, 4, 8]) Person.exists?(name: 'David') Person.exists?(false) Person.exists? Person.where(name: 'Spartacus', rating: 4).exists?",
        "label": "What",
        "id": "13387"
    },
    {
        "raw_code": "def normalize(plugin_configs)\n          plugin_configs.to_h do |plugin_config|\n            if plugin_config == Plugin::OBSOLETE_INTERNAL_AFFAIRS_PLUGIN_NAME\n              warn Rainbow(<<~MESSAGE).yellow\n                Specify `rubocop-internal_affairs` instead of `rubocop/cop/internal_affairs` in your configuration.\n              MESSAGE\n              plugin_config = Plugin::INTERNAL_AFFAIRS_PLUGIN_NAME\n            end",
        "comment": "rubocop:disable Metrics/MethodLength",
        "label": "What",
        "id": "10196"
    },
    {
        "raw_code": "def pipeline_options\n      {\n        inputs: ci_push_options.inputs\n      }\n    end",
        "comment": "merges with EE override",
        "label": "What",
        "id": "5862"
    },
    {
        "raw_code": "def transaction(**options, &block)\n          transaction_type = get_transaction_type(connection.transaction_open?, options[:requires_new])\n\n          ::Gitlab::Database::Metrics.subtransactions_increment(self.name) if transaction_type == :sub_transaction\n\n          super(**options, &block)\n        end",
        "comment": "A patch over ApplicationRecord.transaction that provides observability into transactional methods.",
        "label": "What",
        "id": "1459"
    },
    {
        "raw_code": "def selected_target_project\n    return @project unless @project.forked?\n\n    if params[:target_project_id].present?\n      return @project if @project.id.to_s == params[:target_project_id]\n\n      MergeRequestTargetProjectFinder.new(current_user: current_user, source_project: @project)\n        .find_by(id: params[:target_project_id])\n    else\n      @project.default_merge_request_target\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6640"
    },
    {
        "raw_code": "def up\n    # no-op\n  end",
        "comment": "To be re-enqueued by db/post_migrate/20240827204855_reenqueue_deduplicate_lfs_objects_projects.rb",
        "label": "What",
        "id": "4929"
    },
    {
        "raw_code": "def _TableItem2\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"|\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "TableItem2 = \"|\" TableItem",
        "label": "What",
        "id": "15831"
    },
    {
        "raw_code": "def clear_association_scope_cache # :nodoc:\n        klass.initialize_find_by_cache\n      end",
        "comment": "This is for clearing cache on the reflection. Useful for tests that need to compare SQL queries on associations.",
        "label": "What",
        "id": "12611"
    },
    {
        "raw_code": "def self.global_logger\n    if @_global_logger.nil?\n      require \"log4r\"\n      @_global_logger = Log4r::Logger.new(\"vagrant::global\")\n    end",
        "comment": "Get the global logger instance  @return [Logger]",
        "label": "What",
        "id": "8833"
    },
    {
        "raw_code": "def download(&block)\n    service.download key, &block\n  end",
        "comment": "Downloads the file associated with this variant. If no block is given, the entire file is read into memory and returned. That'll use a lot of RAM for very large files. If a block is given, then the download is streamed and yielded in chunks.",
        "label": "What",
        "id": "13638"
    },
    {
        "raw_code": "def self.allowed_group_level_types(resource_parent)\n      if Feature.enabled?(:create_group_level_work_items, resource_parent, type: :wip)\n        base_types.keys.excluding('epic')\n      else\n        []\n      end",
        "comment": "method overridden in EE to perform the corresponding checks for the Epic type",
        "label": "What",
        "id": "7660"
    },
    {
        "raw_code": "def descendant_projects\n    projects_nested_in_group = Project.in_namespace(parent_group.self_and_descendants.as_ids)\n\n    finder_params = params.dup\n    finder_params[:search] = params[:filter] if params[:filter]\n\n    ProjectsFinder.new( # rubocop:disable CodeReuse/Finder\n      params: finder_params,\n      current_user: current_user,\n      project_ids_relation: projects_nested_in_group\n    ).execute\n  end",
        "comment": "Finds all projects nested under `parent_group` or any of its descendant groups",
        "label": "What",
        "id": "7890"
    },
    {
        "raw_code": "def licenses(options = {})\n        paginate 'licenses', options\n      end",
        "comment": "List all licenses  @see https://developer.github.com/v3/licenses/#list-all-licenses @return [Array<Sawyer::Resource>] A list of licenses @example Octokit.licenses",
        "label": "What",
        "id": "14996"
    },
    {
        "raw_code": "def self.decompress_zip(machine, compressed_file, destination, opts={})\n          comm = machine.communicate\n          extract_dir = create_tmp_path(machine, type: :directory)\n          cmds = []\n          if opts[:type] == :directory\n            cmds << \"mkdir -p '#{destination}'\"\n          else\n            cmds << \"mkdir -p '#{File.dirname(destination)}'\"\n          end",
        "comment": "Decompress zip file on guest to given location  @param [Vagrant::Machine] machine Vagrant guest machine @param [String] compressed_file Path to compressed file on guest @param [String] destination Path for decompressed files on guest",
        "label": "What",
        "id": "9829"
    },
    {
        "raw_code": "def perform(cursor = nil)\n    @updated_count = 0\n    paginator = paginate(cursor)\n\n    paginator.each { |member| process_member(member) }\n\n    status = paginator.has_next_page? ? :limit_reached : :completed\n    log_extra_metadata_on_done(:result,\n      status: status,\n      updated_rows: @updated_count\n    )\n\n    return unless paginator.has_next_page?\n\n    self.class.perform_in(BATCH_DELAY, paginator.cursor_for_next_page)\n  end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6278"
    },
    {
        "raw_code": "def parse(string, opts = {})\n        # Parse nil as nil\n        return if string.nil?\n\n        # First we should ensure this really is a string, not some other\n        # type which purports to be a string. This handles some legacy\n        # usage of the JSON class.\n        string = string.to_s unless string.is_a?(String)\n\n        legacy_mode = legacy_mode_enabled?(opts.delete(:legacy_mode))\n\n        log_oversize_object(string)\n\n        data = adapter_load(string, **opts)\n\n        handle_legacy_mode!(data) if legacy_mode\n\n        data\n      end",
        "comment": "Parse a string and convert it to a Ruby object  @param string [String] the JSON string to convert to Ruby objects @param opts [Hash] an options hash in the standard JSON gem format @return [Boolean, String, Array, Hash] @raise [JSON::ParserError] raised if parsing fails",
        "label": "What",
        "id": "1638"
    },
    {
        "raw_code": "def import(project, client, hash)\n        if project.import_state&.completed?\n          info(\n            project.id,\n            message: 'Project import is no longer running. Stopping worker.',\n            import_status: project.import_state.status\n          )\n\n          return\n        end",
        "comment": "project - An instance of `Project` to import the data into. client - An instance of `Gitlab::GithubImport::Client` hash - A Hash containing the details of the object to import.",
        "label": "What",
        "id": "6358"
    },
    {
        "raw_code": "def message_for_useless_assignment(assignment)\n          variable = assignment.variable\n\n          format(MSG, variable: variable.name) + message_specification(assignment, variable).to_s\n        end",
        "comment": "rubocop:enable Metrics/AbcSize, Metrics/PerceivedComplexity, Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "10644"
    },
    {
        "raw_code": "def extract_class_or_module_name\n        namespace_names = collect_module_and_class_names\n\n        # Find the module/class that comes after BackgroundMigration\n        bg_index = namespace_names.index(BACKGROUND_MIGRATION_MODULE)\n        return unless bg_index && bg_index < namespace_names.length - 1\n\n        namespace_names[bg_index + 1]\n      end",
        "comment": "Extracts both class and module name after the BackgroundMigration module ex: Gitlab => BackgroundMigration => ClassName ex: EE => Gitlab => BackgroundMigration => ModuleName",
        "label": "What",
        "id": "8159"
    },
    {
        "raw_code": "def readonly(value = true)\n      spawn.readonly!(value)\n    end",
        "comment": "Mark a relation as readonly. Attempting to update a record will result in an error.  users = User.readonly users.first.save # => ActiveRecord::ReadOnlyRecord: User is marked as readonly  To make a readonly relation writable, pass +false+.  users.readonly(false) users.first.save # => true",
        "label": "What",
        "id": "13423"
    },
    {
        "raw_code": "def deliver(event)\n      info do\n        if exception = event.payload[:exception_object]\n          \"Failed delivery of mail #{event.payload[:message_id]} error_class=#{exception.class} error_message=#{exception.message.inspect}\"\n        elsif event.payload[:perform_deliveries]\n          \"Delivered mail #{event.payload[:message_id]} (#{event.duration.round(1)}ms)\"\n        else\n          \"Skipped delivery of mail #{event.payload[:message_id]} as `perform_deliveries` is false\"\n        end",
        "comment": "An email was delivered.",
        "label": "What",
        "id": "11130"
    },
    {
        "raw_code": "def rate_limit!(_options = {})\n        get 'rate_limit'\n        Octokit::RateLimit.from_response(last_response)\n      end",
        "comment": "Refresh rate limit info by making a new request  @see https://developer.github.com/v3/rate_limit/#rate-limit @return [Octokit::RateLimit] Rate limit info",
        "label": "What",
        "id": "15048"
    },
    {
        "raw_code": "def validate(machine, ignore_provider=nil)\n          # Go through each of the configuration keys and validate\n          errors = {}\n          @keys.each do |_key, instance|\n            if instance.respond_to?(:validate)\n              # Validate this single item, and if we have errors then\n              # we merge them into our total errors list.\n              if _key == :vm\n                result = instance.validate(machine, ignore_provider)\n              else\n                result = instance.validate(machine)\n              end",
        "comment": "This validates the configuration and returns a hash of error messages by section. If there are no errors, an empty hash is returned.  @param [Environment] env @return [Hash]",
        "label": "What",
        "id": "8941"
    },
    {
        "raw_code": "def put(url, options = {})\n      request :put, url, options\n    end",
        "comment": "Make a HTTP PUT request  @param url [String] The path, relative to {#api_endpoint} @param options [Hash] Body and header params for request @return [Sawyer::Resource]",
        "label": "What",
        "id": "14904"
    },
    {
        "raw_code": "def available_state_names\n      [:opened, :closed]\n    end",
        "comment": "Available state names used to persist state_id column using state machine  Override this on subclasses if different states are needed  Check MergeRequest.available_states_names for example",
        "label": "What",
        "id": "7398"
    },
    {
        "raw_code": "def wsl_windows_access_bypass?(path)\n          wsl? && wsl_windows_access? &&\n            path.to_s.start_with?(wsl_windows_accessible_path.to_s)\n        end",
        "comment": "Checks given path to determine if Vagrant is allowed to bypass checks  @param [String] path Path to check @return [Boolean] Vagrant is allowed to bypass checks",
        "label": "What",
        "id": "9213"
    },
    {
        "raw_code": "def unfoldered_environment_names\n    respond_to do |format|\n      format.json do\n        render json: Environments::EnvironmentNamesFinder.new(@project, current_user).execute\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "6435"
    },
    {
        "raw_code": "def migrate_data\n        INFLUX_BUCKETS.each do |bucket|\n          INFLUX_STATS_TYPE.each do |stats_type|\n            if bucket == Support::InfluxdbTools::INFLUX_MAIN_TEST_METRICS_BUCKET && stats_type == \"fabrication-stats\"\n              break\n            end",
        "comment": "Fetch data from Influx DB, store as CSV and upload to GCS  @return [void]",
        "label": "What",
        "id": "4728"
    },
    {
        "raw_code": "def start_checking(component)\n      $stdout.puts \"Checking #{Rainbow(component).yellow} ...\"\n      $stdout.puts ''\n    end",
        "comment": "@deprecated This will no longer be used when all checks were executed using SystemCheck",
        "label": "What",
        "id": "3706"
    },
    {
        "raw_code": "def persist_object_store!\n      return unless persist_object_store?\n\n      updated = model.update_column(store_serialization_column, object_store)\n      raise 'Failed to update object store' unless updated\n    end",
        "comment": "Save the current @object_store to the model <mounted_as>_store column",
        "label": "What",
        "id": "8045"
    },
    {
        "raw_code": "def file_fixture_upload(path, mime_type = nil, binary = false)\n        if self.class.file_fixture_path && !File.exist?(path)\n          path = file_fixture(path)\n        end",
        "comment": "Shortcut for `Rack::Test::UploadedFile.new(File.join(ActionDispatch::IntegrationTest.file_fixture_path, path), type)`:  post :change_avatar, params: { avatar: file_fixture_upload('david.png', 'image/png') }  Default fixture files location is `test/fixtures/files`.  To upload binary files on Windows, pass `:binary` as the last parameter. This will not affect other platforms:  post :change_avatar, params: { avatar: file_fixture_upload('david.png', 'image/png', :binary) }",
        "label": "What",
        "id": "11632"
    },
    {
        "raw_code": "def bar; end\n            end",
        "comment": "{access_modifier} get_method_name_1 if get_method_name_1 =~ /a/ {access_modifier} get_method_name_2 if get_method_name_2 =~ /b/ {access_modifier}",
        "label": "What",
        "id": "10883"
    },
    {
        "raw_code": "def record_location(container) # :nodoc:\n    case container\n    when RDoc::ClassModule then\n      @top_level.add_to_classes_or_modules container\n    end",
        "comment": "Records the location of this +container+ in the file for this parser and adds it to the list of classes and modules in the file.",
        "label": "What",
        "id": "16027"
    },
    {
        "raw_code": "def validate_each(record, attribute, value)\n      raise NotImplementedError, \"Subclasses must implement a validate_each(record, attribute, value) method\"\n    end",
        "comment": "Override this method in subclasses with the validation logic, adding errors to the records +errors+ array where necessary.",
        "label": "What",
        "id": "12282"
    },
    {
        "raw_code": "def session\n      return {} unless last_request?\n      raise Rack::Test::Error, 'session not enabled for app' unless last_env['rack.session'] || app.session?\n\n      last_request.session\n    end",
        "comment": "@raise [Rack::Test:Error] If sessions are not enabled for app @return [Hash] Session of last request, or the empty Hash",
        "label": "What",
        "id": "8662"
    },
    {
        "raw_code": "def initialize(checker)\n      @checker = checker\n    end",
        "comment": "@param checker [RepositorySizeChecker]",
        "label": "What",
        "id": "1499"
    },
    {
        "raw_code": "def _Notes\n    while true\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_Note)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_SkipBlock)\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      break unless _tmp\n    end",
        "comment": "Notes = (Note | SkipBlock)*",
        "label": "What",
        "id": "15825"
    },
    {
        "raw_code": "def set(**options)\n        options.symbolize_keys!\n        keys = options.keys\n\n        store = record.store\n\n        previous_context = if block_given?\n          keys.zip(store.values_at(*keys)).to_h\n        end",
        "comment": "Updates the execution context. If a block is given, it resets the provided keys to their previous value once the block exits.",
        "label": "What",
        "id": "13860"
    },
    {
        "raw_code": "def wiki_path?(path)\n      NamespacePathValidator.valid_path?(path) && path.end_with?('.wiki')\n    end",
        "comment": "These also cover wikis, since a `.wiki` suffix is valid in project/group paths too.",
        "label": "What",
        "id": "3368"
    },
    {
        "raw_code": "def default_html_options_for_collection(item, value)\n            html_options = @html_options.dup\n\n            [:checked, :selected, :disabled, :readonly].each do |option|\n              current_value = @options[option]\n              next if current_value.nil?\n\n              accept = if current_value.respond_to?(:call)\n                current_value.call(item)\n              else\n                Array(current_value).map(&:to_s).include?(value.to_s)\n              end",
        "comment": "Generate default options for collection helpers, such as :checked and :disabled.",
        "label": "What",
        "id": "12000"
    },
    {
        "raw_code": "def initialize(records:, associations:, scope: nil, available_records: [], associate_by_default: true)\n        @records = records\n        @associations = associations\n        @scope = scope\n        @available_records = available_records || []\n        @associate_by_default = associate_by_default\n\n        @tree = Branch.new(\n          parent: nil,\n          association: nil,\n          children: @associations,\n          associate_by_default: @associate_by_default,\n          scope: @scope\n        )\n        @tree.preloaded_records = @records\n      end",
        "comment": "Eager loads the named associations for the given Active Record record(s).  In this description, 'association name' shall refer to the name passed to an association creation method. For example, a model that specifies <tt>belongs_to :author</tt>, <tt>has_many :buyers</tt> has association names +:author+ and +:buyers+.  == Parameters +records+ is an array of ActiveRecord::Base. This array needs not be flat, i.e. +records+ itself may also contain arrays of records. In any case, +preload_associations+ will preload all associations records by flattening +records+.  +associations+ specifies one or more associations that you want to preload. It may be: - a Symbol or a String which specifies a single association name. For example, specifying +:books+ allows this method to preload all books for an Author. - an Array which specifies multiple association names. This array is processed recursively. For example, specifying <tt>[:avatar, :books]</tt> allows this method to preload an author's avatar as well as all of their books. - a Hash which specifies multiple association names, as well as association names for the to-be-preloaded association objects. For example, specifying <tt>{ author: :avatar }</tt> will preload a book's author, as well as that author's avatar.  +:associations+ has the same format as the arguments to ActiveRecord::QueryMethods#includes. So +associations+ could look like this:  :books [ :books, :author ] { author: :avatar } [ :books, { author: :avatar } ]  +available_records+ is an array of ActiveRecord::Base. The Preloader will try to use the objects in this array to preload the requested associations before querying the database. This can save database queries by reusing in-memory objects. The optimization is only applied to single associations (i.e. :belongs_to, :has_one) with no scopes.",
        "label": "What",
        "id": "12812"
    },
    {
        "raw_code": "def foo; end\n          end",
        "comment": "{access_modifier} :foo",
        "label": "What",
        "id": "10884"
    },
    {
        "raw_code": "def any_import_in_progress?\n    last_relation_import_tracker = relation_import_trackers.last\n\n    (last_relation_import_tracker&.started? && !last_relation_import_tracker.stale?) ||\n      import_started? ||\n      BulkImports::Entity.with_status(:started).where(project_id: id).any?\n  end",
        "comment": "Determine whether any kind of import is in progress. - Full file import - Relation import - Direct Transfer",
        "label": "What",
        "id": "6739"
    },
    {
        "raw_code": "def method1\n          end",
        "comment": "{keyword} A {modifier}",
        "label": "What",
        "id": "10980"
    },
    {
        "raw_code": "def current_user\n    @feat.user\n  end",
        "comment": "Fake a `current_user` helper",
        "label": "What",
        "id": "8268"
    },
    {
        "raw_code": "def start_fabrication\n          Thread.current[:fabrications_ongoing] = 0 unless Thread.current.key?(:fabrications_ongoing)\n\n          Thread.current[:fabrications_ongoing] += 1\n        end",
        "comment": "Start fabrication and increment ongoing fabrication count  @return [void]",
        "label": "What",
        "id": "4559"
    },
    {
        "raw_code": "def in_progress?\n    scheduled? || started?\n  end",
        "comment": "This method is coupled to the repository mirror domain. Use with caution in the importers domain. As an alternative, use the `#completed?` method. See EE-override and https://gitlab.com/gitlab-org/gitlab/-/merge_requests/4697",
        "label": "What",
        "id": "6710"
    },
    {
        "raw_code": "def install_siginfo_handler\n    return unless Signal.list.include? 'INFO'\n\n    @old_siginfo = trap 'INFO' do\n      puts @current if @current\n    end",
        "comment": " Installs a siginfo handler that prints the current filename.",
        "label": "What",
        "id": "16010"
    },
    {
        "raw_code": "def configure_attachments\n          Capybara::Screenshot.after_save_screenshot do |path|\n            Allure.add_attachment(\n              name: 'screenshot',\n              source: File.open(path),\n              type: Allure::ContentType::PNG,\n              test_case: true\n            )\n          end",
        "comment": "Set up failure screenshot attachments  @return [void]",
        "label": "What",
        "id": "4450"
    },
    {
        "raw_code": "def filter_triggers(triggers, guest_name, type)\n          # look for only_on trigger constraint and if it doesn't match guest\n          # name, throw it away also be sure to preserve order\n          filter = triggers.dup\n\n          filter.each do |trigger|\n            index = nil\n            match = false\n            if trigger.only_on\n              trigger.only_on.each do |o|\n                if o.match(guest_name.to_s)\n                  # trigger matches on current guest, so we're fine to use it\n                  match = true\n                  break\n                end",
        "comment": "Filters triggers to be fired based on configured restraints  @param [Array] triggers An array of triggers to be filtered @param [String] guest_name The name of the current guest @param [Symbol] type The type of trigger (:command or :type) @return [Array] The filtered array of triggers",
        "label": "What",
        "id": "9043"
    },
    {
        "raw_code": "def delete!\n        if !solution_file.exist?\n          @logger.debug(\"solution file does not exist. nothing to delete.\")\n          return false\n        end",
        "comment": "Delete the solution file  @return [Boolean] true if file was deleted",
        "label": "What",
        "id": "8889"
    },
    {
        "raw_code": "def delete_issue_comment_reaction(repo, comment_id, reaction_id, options = {})\n        boolean_from_response :delete, \"#{Repository.path repo}/issues/comments/#{comment_id}/reactions/#{reaction_id}\", options\n      end",
        "comment": "Delete a reaction from an issue comment  @param repo [Integer, String, Hash, Repository] A GitHub repository @param comment_id [Integer] The Issue comment id @param reaction_id [Integer] The Reaction id  @see https://docs.github.com/en/rest/reactions/reactions#delete-an-issue-comment-reaction  @example @client.delete_issue_comment_reaction(\"octokit/octokit.rb\", 1, 2)  @return [Boolean] Return true if reaction was deleted, false otherwise.",
        "label": "What",
        "id": "15408"
    },
    {
        "raw_code": "def normalize_color(color)\n        return (color[0, 1] * 2) + (color[1, 1] * 2) + (color[2, 1] * 2) if color.length == 3\n\n        color\n      end",
        "comment": "Expands the short notation to the full colorcode notation 123456 -> 123456 123    -> 112233",
        "label": "What",
        "id": "7455"
    },
    {
        "raw_code": "def self.min_schema_gitlab_version\n      upgrade_path.last_required_stop\n    end",
        "comment": "Migrations before this version may have been removed.",
        "label": "What",
        "id": "1448"
    },
    {
        "raw_code": "def execute\n      start_id = next_start_id\n\n      return EMPTY_RESULT if start_id.nil?\n\n      result = consistency_checker.execute(start_id: start_id)\n      result[:start_id] = start_id\n\n      save_next_start_id(result[:next_start_id])\n\n      result\n    end",
        "comment": "This class takes two ActiveRecord models, and compares the selected columns of the two models tables, for the purposes of checking the consistency of mirroring of tables. For example Namespace and Ci::NamepaceMirror  It compares up to 25 batches (1000 records / batch), or up to 30 seconds for all the batches in total.  It saves the cursor of the next start_id (cursor) in Redis. If the start_id wasn't saved in Redis, for example, in the first run, it will choose some random start_id  Example: service = Database::ConsistencyCheckService.new( source_model: Namespace, target_model: Ci::NamespaceMirror, source_columns: %w[id traversal_ids], target_columns: %w[namespace_id traversal_ids], ) result = service.execute  result is a hash that has the following fields: - batches: Number of batches checked - matches: The number of matched records - mismatches: The number of mismatched records - mismatches_details: It's an array that contains details about the mismatched records. each record in this array is a hash of format {id: ID, source_table: [...], target_table: [...]} Each record represents the attributes of the records in the two tables. - start_id: The start id cursor of the current batch. <nil> means no records. - next_start_id: The ID that can be used for the next batch iteration check. <nil> means no records",
        "label": "What",
        "id": "6130"
    },
    {
        "raw_code": "def resolve\n      scope.all\n    end",
        "comment": "NOTE: Be explicit about which records you allow access to!",
        "label": "What",
        "id": "10006"
    },
    {
        "raw_code": "def bounce_with(message)\n      inbound_email.bounced!\n      message.deliver_later\n    end",
        "comment": "Enqueues the given +message+ for delivery and changes the inbound email's status to +:bounced+.",
        "label": "What",
        "id": "11096"
    },
    {
        "raw_code": "def validate_belongs_to_association(reflection)\n        association = association_instance_get(reflection.name)\n        record      = association && association.reader\n        return unless record && (record.changed_for_autosave? || custom_validation_context?)\n\n        begin\n          @validating_belongs_to_for ||= {}\n          @validating_belongs_to_for[association] = true\n          association_valid?(association, record)\n        ensure\n          @validating_belongs_to_for[association] = false\n        end",
        "comment": "Validate the association if <tt>:validate</tt> or <tt>:autosave</tt> is turned on for the belongs_to association.",
        "label": "What",
        "id": "12386"
    },
    {
        "raw_code": "def preconnect\n        sequential_maintenance -> c { (!c.connected? || !c.verified?) && c.allow_preconnect } do |conn|\n          conn.connect!\n        rescue\n          # Wholesale rescue: there's nothing we can do but move on. The\n          # connection will go back to the pool, and the next consumer will\n          # presumably try to connect again -- which will either work, or\n          # fail and they'll be able to report the exception.\n        end",
        "comment": "Preconnect all connections in the pool. This saves pool users from having to wait for a connection to be established when first using it after checkout.",
        "label": "What",
        "id": "13032"
    },
    {
        "raw_code": "def errors\n      @errors ||= Errors.new(self)\n    end",
        "comment": "Returns the +Errors+ object that holds all information about attribute error messages.  class Person include ActiveModel::Validations  attr_accessor :name validates_presence_of :name end  person = Person.new person.valid? # => false person.errors # => #<ActiveModel::Errors:0x007fe603816640 @messages={name:[\"can't be blank\"]}>",
        "label": "What",
        "id": "12271"
    },
    {
        "raw_code": "def execute(**args)\n      preload_reviewers_for_merge_requests(args[:merge_requests]) if args.key?(:merge_requests)\n\n      JiraConnectInstallation.for_project(project).flat_map do |installation|\n        client = Atlassian::JiraConnect::Client.new(installation.base_url, installation.shared_secret)\n\n        responses = client.send_info(project: project, **args)\n\n        responses.each { |r| log_response(r) }\n      end",
        "comment": "Parameters: see Atlassian::JiraConnect::Client#send_info Includes: update_sequence_id, commits, branches, merge_requests, pipelines",
        "label": "What",
        "id": "6008"
    },
    {
        "raw_code": "def email_creatable_types\n      %w[Issue]\n    end",
        "comment": "`Noteable` class names that support creating/forwarding individual notes.",
        "label": "What",
        "id": "7332"
    },
    {
        "raw_code": "def remove_all_labels(repo, number, options = {})\n        boolean_from_response :delete, \"#{Repository.path repo}/issues/#{number}/labels\", options\n      end",
        "comment": "Remove all label from an Issue  This removes the label from the Issue  @param repo [Integer, String, Repository, Hash] A GitHub repository @param number [Integer] Number ID of the issue @return [Boolean] Success of operation @see https://developer.github.com/v3/issues/labels/#remove-all-labels-from-an-issue @example Remove all labels from Issue #23 Octokit.remove_all_labels(\"octokit/octokit.rb\", 23)",
        "label": "What",
        "id": "15288"
    },
    {
        "raw_code": "def initialize(heading, description: nil, options: {})\n      @heading = heading\n      @description = description\n      @options = options\n    end",
        "comment": "@param [String] heading @param [Hash] options",
        "label": "What",
        "id": "5386"
    },
    {
        "raw_code": "def find_attr_comment(var_name, attr_name, read = nil, write = nil)\n    attr_name = Regexp.escape attr_name\n\n    rw = if read and write then\n           /\\s*#{read}\\s*,\\s*#{write}\\s*/xm\n         else\n           /.*?/m\n         end",
        "comment": " Finds a comment for rb_define_attr, rb_attr or Document-attr.  +var_name+ is the C class variable the attribute is defined on. +attr_name+ is the attribute's name.  +read+ and +write+ are the read/write flags ('1' or '0').  Either both or neither must be provided.",
        "label": "What",
        "id": "16150"
    },
    {
        "raw_code": "def action_methods\n        @action_methods ||= begin\n          # All public instance methods of this class, including ancestors except for\n          # public instance methods of Base and its ancestors.\n          methods = public_instance_methods(true) - internal_methods\n          # Be sure to include shadowed public instance methods of this class.\n          methods.concat(public_instance_methods(false))\n          methods.reject! { |m| m.start_with?(\"_\") }\n          methods.map!(&:name)\n          methods.to_set\n        end",
        "comment": "A `Set` of method names that should be considered actions. This includes all public instance methods on a controller, less any internal methods (see internal_methods), adding back in any methods that are internal, but still exist on the class itself.",
        "label": "What",
        "id": "11177"
    },
    {
        "raw_code": "def foo; end\n    eof\n    @stats.run('--list-undoc')\n    expect(@output.string).to eq \"Files:           1\\n\" \\\n                                 \"Modules:         0 (    0 undocumented)\\n\" \\\n                                 \"Classes:         0 (    0 undocumented)\\n\" \\\n                                 \"Constants:       0 (    0 undocumented)\\n\" \\\n                                 \"Attributes:      0 (    0 undocumented)\\n\" \\\n                                 \"Methods:         1 (    0 undocumented)\\n\" \\\n                                 \" 100.00% documented\\n\"\n  end",
        "comment": "documentation",
        "label": "What",
        "id": "812"
    },
    {
        "raw_code": "def initialize(\n    classes:, label: nil, label_position: nil,\n    id: nil, name: nil, help: nil, data: {},\n    is_disabled: false, is_checked: false, is_loading: false\n  )\n    @id = id\n    @name = name\n    @classes = classes\n    @label = label\n    @label_position = filter_attribute(label_position, LABEL_POSITION_OPTIONS)\n    @help = help\n    @data = data\n    @is_disabled = is_disabled\n    @is_checked = is_checked\n    @is_loading = is_loading\n  end",
        "comment": "@param [String] classes @param [String] label @param [Symbol] label_position :top, :left or :hidden @param [String] id @param [String] name @param [String] help @param [Hash] data @param [Boolean] is_disabled @param [Boolean] is_checked @param [Boolean] is_loading",
        "label": "What",
        "id": "5397"
    },
    {
        "raw_code": "def self.url_scrubber(string)\n        string.gsub(%r{(ftp|https?)://[^\\s]+@[^\\s]+}) do |address|\n          uri = URI.parse(address)\n          uri.user = uri.password = REPLACEMENT_TEXT\n          uri.to_s\n        end",
        "comment": "Detect URLs and remove any embedded credentials  @param [String] string @return [String]",
        "label": "What",
        "id": "9224"
    },
    {
        "raw_code": "def execute\n        return if user_id && authorized_users.where(user_id: user_id).exists?\n\n        related_todos.each_batch(of: BATCH_SIZE) do |batch|\n          pending_delete = without_authorized(batch).includes(:target, :user).reject do |todo|\n            Ability.allowed?(todo.user, :read_todo, todo, scope: :user)\n          end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5662"
    },
    {
        "raw_code": "def _StarLine\n\n    _save = self.pos\n    while true # choice\n\n      _save1 = self.pos\n      while true # sequence\n        _text_start = self.pos\n        _tmp = scan(/\\G(?-mix:\\*{4,})/)\n        if _tmp\n          text = get_text(_text_start)\n        end",
        "comment": "StarLine = (< /\\*{4,}/ > { text } | < @Spacechar /\\*+/ &@Spacechar > { text })",
        "label": "What",
        "id": "15751"
    },
    {
        "raw_code": "def find_body(class_name, meth_name, meth_obj, file_content, quiet = false)\n    if file_content\n      @body_table ||= {}\n      @body_table[file_content] ||= gen_body_table file_content\n      type, *args = @body_table[file_content][meth_name]\n    end",
        "comment": " Find the C code corresponding to a Ruby method",
        "label": "What",
        "id": "16152"
    },
    {
        "raw_code": "def flush!\n        reap\n        flush(-1)\n\n        # Stop maintaining the minimum size until reactivated\n        @activated = false\n      end",
        "comment": "Disconnect all currently idle connections. Connections currently checked out are unaffected. The pool will stop maintaining its minimum size until it is reactivated (such as by a subsequent checkout).",
        "label": "What",
        "id": "13030"
    },
    {
        "raw_code": "def actual_limits\n    self.limits || self.build_limits\n  end",
        "comment": "rubocop: enable Database/AvoidUsingPluckWithoutLimit",
        "label": "What",
        "id": "6879"
    },
    {
        "raw_code": "def down\n    remove_concurrent_index_by_name :projects, INDEX_NAME\n  end",
        "comment": "rubocop:enable Migration/PreventIndexCreation",
        "label": "What",
        "id": "4963"
    },
    {
        "raw_code": "def has_tag?(tag_name)\n        tag_name && respond_to?(self.class.tag_method_name(tag_name))\n      end",
        "comment": "@param [#to_s] tag_name the name of the tag to look for @return [Boolean] whether a tag by the given name is registered in the library.",
        "label": "What",
        "id": "244"
    },
    {
        "raw_code": "def content_for?(name)\n        @view_flow.get(name).present?\n      end",
        "comment": "<tt>content_for?</tt> checks whether any content has been captured yet using <tt>content_for</tt>.  Useful to render parts of your layout differently based on what is in your views.  <%# This is the layout %> <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\"> <head> <title>My Website</title> <%= yield :script %> </head> <body class=\"<%= content_for?(:right_col) ? 'two-column' : 'one-column' %>\"> <%= yield %> <%= yield :right_col %> </body> </html>",
        "label": "What",
        "id": "11820"
    },
    {
        "raw_code": "def foo\n          end",
        "comment": "rubocop:disable",
        "label": "What",
        "id": "10818"
    },
    {
        "raw_code": "def token\n        # If the client is defined, use the client for the access token\n        # to allow proper token generation if required\n        return client.access_token if client && !client.access_token.nil?\n\n        if present?(ENV[\"VAGRANT_CLOUD_TOKEN\"]) && token_path.exist?\n          # Only show warning if it has not been previously shown\n          if !defined?(@@double_token_warning)\n            @env.ui.warn <<-EOH.strip\nVagrant detected both the VAGRANT_CLOUD_TOKEN environment variable and a Vagrant login\ntoken are present on this system. The VAGRANT_CLOUD_TOKEN environment variable takes\nprecedence over the locally stored token. To remove this error, either unset\nthe VAGRANT_CLOUD_TOKEN environment variable or remove the login token stored on disk:\n\n    ~/.vagrant.d/data/vagrant_login_token\n\nEOH\n            @@double_token_warning = true\n          end",
        "comment": "Reads the access token if there is one. This will first read the `VAGRANT_CLOUD_TOKEN` environment variable and then fallback to the stored access token on disk.  @return [String]",
        "label": "What",
        "id": "9780"
    },
    {
        "raw_code": "def send_async(method, *arguments)\n        worker_pool.async_invoke(self, method, *arguments)\n      end",
        "comment": "Invoke a method on the connection asynchronously through the pool of thread workers.",
        "label": "What",
        "id": "11071"
    },
    {
        "raw_code": "def admin_api_client\n            return @admin_api_client if defined?(@admin_api_client)\n            return @admin_api_client = nil if Env.no_admin_environment? || Env.personal_access_tokens_disabled?\n\n            info(\"Creating admin api client for api fabrications\")\n            @admin_api_client = create_api_client(\n              token: admin_api_token,\n              default_token: Data::DEFAULT_ADMIN_API_TOKEN,\n              user_proc: -> { admin_user },\n              check_admin: true)\n\n            info(\"Global admin api client set up successfully\")\n            @admin_api_client\n          rescue InvalidCredentialsError => e\n            unless admin_username == Data::DEFAULT_ADMIN_USERNAME && admin_password == Data::DEFAULT_ADMIN_PASSWORD\n              # Only raise error when explicitly configured credentials are invalid\n              raise e\n            end",
        "comment": "Global admin client  @return [QA::Runtime::API::Client]",
        "label": "What",
        "id": "4503"
    },
    {
        "raw_code": "def groups_with_guest_access_plus\n      groups = GroupsFinder.new(current_user, min_access_level: Gitlab::Access::GUEST).execute\n\n      # We move the result into a materialized CTE to improve query performance during text search.\n      union_query = ::Group.from_union([groups])\n      cte = Gitlab::SQL::CTE.new(:my_union_cte, union_query)\n      Group.with(cte.to_arel).from(cte.alias_to(Group.arel_table)) # rubocop: disable CodeReuse/ActiveRecord -- CTE use\n    end",
        "comment": "rubocop: disable CodeReuse/Finder",
        "label": "What",
        "id": "7955"
    },
    {
        "raw_code": "def can_find_inverse_of_automatically?(reflection, inverse_reflection = false)\n          reflection.options[:inverse_of] != false &&\n            !reflection.options[:through] &&\n            !reflection.options[:foreign_key] &&\n            scope_allows_automatic_inverse_of?(reflection, inverse_reflection)\n        end",
        "comment": "Checks to see if the reflection doesn't have any options that prevent us from being able to guess the inverse automatically. First, the <tt>inverse_of</tt> option cannot be set to false. Second, we must have <tt>has_many</tt>, <tt>has_one</tt>, <tt>belongs_to</tt> associations. Third, we must not have options such as <tt>:foreign_key</tt> which prevent us from correctly guessing the inverse association.",
        "label": "What",
        "id": "12614"
    },
    {
        "raw_code": "def bytes_to_megabytes(bytes)\n          (bytes / MEGABYTE.to_f).round(2)\n        end",
        "comment": "Rounds actual value to two decimal places  @param [Integer] bytes @return [Integer] megabytes - bytes representation in megabytes",
        "label": "What",
        "id": "9146"
    },
    {
        "raw_code": "def network_defined?(subnet_string)\n        all_networks = list_network_names\n\n        network_info = inspect_network(all_networks)\n        network_info.each do |network|\n          config = Array(network.dig(\"IPAM\", \"Config\"))\n          next if config.empty? || !config.first.is_a?(Hash)\n          if (config.first[\"Subnet\"] == subnet_string)\n            @logger.debug(\"Found existing network #{network[\"Name\"]} already configured with #{subnet_string}\")\n            return network[\"Name\"]\n          end",
        "comment": "###################### Docker network helpers ###################### Determines if a given network has been defined through vagrant with a given subnet string  @param [String] subnet_string - Subnet to look for @return [String] network name - Name of network with requested subnet.`nil` if not found",
        "label": "What",
        "id": "9494"
    },
    {
        "raw_code": "def initialize(issue, project, client)\n          @issue = issue\n          @project = project\n          @client = client\n          @label_finder = LabelFinder.new(project)\n        end",
        "comment": "issue - An instance of `Gitlab::GithubImport::Representation::Issue` project - An instance of `Project` client - An instance of `Gitlab::GithubImport::Client`",
        "label": "What",
        "id": "2216"
    },
    {
        "raw_code": "def execute\n      deployments =\n        if ref\n          Deployment.where(ref: ref.to_s)\n        elsif sha\n          Deployment.where(sha: sha)\n        else\n          Deployment.none\n        end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "8020"
    },
    {
        "raw_code": "def request # :doc:\n          @request ||= begin\n            environment = Rails.application.env_config.merge(env) if defined?(Rails.application) && Rails.application\n            ActionDispatch::Request.new(environment || env)\n          end",
        "comment": "The request that initiated the WebSocket connection is available here. This gives access to the environment, cookies, etc.",
        "label": "What",
        "id": "11073"
    },
    {
        "raw_code": "def on_hash(node)\n          return if node.pairs.empty? || node.pairs.any?(&:hash_rocket?)\n          return unless (parent = node.parent)\n          return unless parent.type?(:call, :kwsplat)\n          return unless mergeable?(parent)\n          return unless (kwsplat = node.each_ancestor(:kwsplat).first)\n          return if !node.braces? || allowed_double_splat_receiver?(kwsplat)\n\n          add_offense(kwsplat) do |corrector|\n            autocorrect(corrector, node, kwsplat)\n          end",
        "comment": "rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10483"
    },
    {
        "raw_code": "def insert_after(idx_or_item, middleware, *args, **keywords, &block)\n        if idx_or_item.is_a?(Integer)\n          index = idx_or_item\n        else\n          index = self.index(idx_or_item)\n        end",
        "comment": "Inserts a middleware after the given index or middleware object.",
        "label": "What",
        "id": "9305"
    },
    {
        "raw_code": "def push_proc(&block)\n        proc_stack << block\n      end",
        "comment": "Adds (pushes) a proc to the stack. The actual proc added here is not executed, but merely stored.  @param [Proc] block",
        "label": "What",
        "id": "9234"
    },
    {
        "raw_code": "def retrieve_queue(queue_query_proc)\n      ##\n      # We want to reset a load balancing session to discard the side\n      # effects of writes that could have happened prior to this moment.\n      #\n      ::Gitlab::Database::LoadBalancing::SessionMap.clear_session\n\n      @metrics.observe_queue_time(:retrieve, @runner.runner_type) do\n        @logger.instrument(:retrieve_queue, once: true) do\n          queue_query_proc.call\n        end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "5768"
    },
    {
        "raw_code": "def import(client, project)\n          return skip_to_next_stage(project) if import_settings(project).disabled?(:attachments_import)\n\n          waiters = importers.each_with_object({}) do |importer, hash|\n            waiter = start_importer(project, importer, client)\n            hash[waiter.key] = waiter.jobs_remaining\n          end",
        "comment": "client - An instance of Gitlab::GithubImport::Client. project - An instance of Project.",
        "label": "What",
        "id": "6318"
    },
    {
        "raw_code": "def unlock_repository(org, id, repo, options = {})\n        delete \"#{Organization.path(org)}/migrations/#{id}/repos/#{repo}/lock\", options\n      end",
        "comment": "Unlock a previous migration archive.  Requires authenticated organization owner.  @param org [String, Integer] Organization GitHub login or id. @param id [Integer] ID number of the migration. @param repo [String] Name of the repository. @see https://docs.github.com/en/rest/reference/migrations#unlock-an-organization-repository",
        "label": "What",
        "id": "15462"
    },
    {
        "raw_code": "def commits_since(*args)\n        arguments = Octokit::RepoArguments.new(args)\n        date = parse_date(arguments.shift)\n        params = arguments.options\n        params.merge!(since: iso8601(date))\n        sha_or_branch = arguments.pop\n        params[:sha] = sha_or_branch if sha_or_branch\n        commits(arguments.repo, params)\n      end",
        "comment": "Get commits after a specified date  @overload commits_since(repo, date, options = {}) @param repo [Integer, String, Hash, Repository] A GitHub repository @param date [String] Date on which we want to compare @param options [String] :sha Commit SHA or branch name from which to start the list @overload commits_since(repo, date, sha_or_branch, options = {}) @deprecated @param repo [Integer, String, Hash, Repository] A GitHub repository @param date [String] Date on which we want to compare @param sha_or_branch [String] A commit SHA or branch name @param options [String] :sha Commit SHA or branch name from which to start the list @return [Array<Sawyer::Resource>] An array of hashes representing commits @see https://developer.github.com/v3/repos/commits/#list-commits-on-a-repository @example Octokit.commits_since('octokit/octokit.rb', '2012-10-01')",
        "label": "What",
        "id": "15057"
    },
    {
        "raw_code": "def minimum(key)\n    map(&key).min\n  end",
        "comment": "Calculates the minimum from the extracted elements.  payments = [Payment.new(5), Payment.new(15), Payment.new(10)] payments.minimum(:price) # => 5",
        "label": "What",
        "id": "14065"
    },
    {
        "raw_code": "def display_page_list(store, pages = store.cache[:pages], search = nil)\n    out = RDoc::Markup::Document.new\n\n    title = if search then\n              \"#{search} pages\"\n            else\n              'Pages'\n            end",
        "comment": " Outputs a formatted RI page list for the pages in +store+.",
        "label": "What",
        "id": "16599"
    },
    {
        "raw_code": "def on_if(node)\n          return if node.ternary? || node.unless?\n\n          else_branch = node.else_branch\n\n          return unless else_branch&.if_type? && else_branch.if?\n          return if allow_if_modifier_in_else_branch?(else_branch)\n\n          add_offense(else_branch.loc.keyword) do |corrector|\n            next if part_of_ignored_node?(node)\n\n            autocorrect(corrector, else_branch)\n            ignore_node(node)\n          end",
        "comment": "rubocop:disable Metrics/CyclomaticComplexity",
        "label": "What",
        "id": "10570"
    },
    {
        "raw_code": "def each\n        File.open(to_path, \"rb\") do |file|\n          while chunk = file.read(16384)\n            yield chunk\n          end",
        "comment": "Stream the file's contents if Rack::Sendfile isn't present.",
        "label": "What",
        "id": "11478"
    },
    {
        "raw_code": "def class_collisions(*class_names)\n          return unless behavior == :invoke\n          return if options.skip_collision_check?\n          return if options.force?\n\n          class_names.flatten.each do |class_name|\n            class_name = class_name.to_s\n            next if class_name.strip.empty?\n\n            # Split the class from its module nesting\n            nesting = class_name.split(\"::\")\n            last_name = nesting.pop\n            last = extract_last_module(nesting)\n\n            if last && last.const_defined?(last_name.camelize, false)\n              raise Error, \"The name '#{class_name}' is either already used in your application \" \\\n                           \"or reserved by Ruby on Rails. Please choose an alternative or use --skip-collision-check \"  \\\n                           \"or --force to skip this check and run this generator again.\"\n            end",
        "comment": "Check whether the given class names are already taken by user application or Ruby on Rails.",
        "label": "What",
        "id": "14766"
    },
    {
        "raw_code": "def self.registered(base)\n      base.set :environments, %w[test production development]\n    end",
        "comment": "When the extension is registered sets the +environments+ setting to the traditional environments: development, test and production.",
        "label": "What",
        "id": "8683"
    },
    {
        "raw_code": "def query_constraints(*columns_list)\n        raise ArgumentError, \"You must specify at least one column to be used in querying\" if columns_list.empty?\n\n        @query_constraints_list = columns_list.map(&:to_s)\n        @has_query_constraints = @query_constraints_list\n      end",
        "comment": "Accepts a list of attribute names to be used in the WHERE clause of SELECT / UPDATE / DELETE queries and in the ORDER BY clause for +#first+ and +#last+ finder methods.  class Developer < ActiveRecord::Base query_constraints :company_id, :id end  developer = Developer.first # SELECT \"developers\".* FROM \"developers\" ORDER BY \"developers\".\"company_id\" ASC, \"developers\".\"id\" ASC LIMIT 1 developer.inspect # => #<Developer id: 1, company_id: 1, ...>  developer.update!(name: \"Nikita\") # UPDATE \"developers\" SET \"name\" = 'Nikita' WHERE \"developers\".\"company_id\" = 1 AND \"developers\".\"id\" = 1  # It is possible to update an attribute used in the query_constraints clause: developer.update!(company_id: 2) # UPDATE \"developers\" SET \"company_id\" = 2 WHERE \"developers\".\"company_id\" = 1 AND \"developers\".\"id\" = 1  developer.name = \"Bob\" developer.save! # UPDATE \"developers\" SET \"name\" = 'Bob' WHERE \"developers\".\"company_id\" = 1 AND \"developers\".\"id\" = 1  developer.destroy! # DELETE FROM \"developers\" WHERE \"developers\".\"company_id\" = 1 AND \"developers\".\"id\" = 1  developer.delete # DELETE FROM \"developers\" WHERE \"developers\".\"company_id\" = 1 AND \"developers\".\"id\" = 1  developer.reload # SELECT \"developers\".* FROM \"developers\" WHERE \"developers\".\"company_id\" = 1 AND \"developers\".\"id\" = 1 LIMIT 1",
        "label": "What",
        "id": "12549"
    },
    {
        "raw_code": "def _reduce_57(val, _values, result)\n      result = val[0]\n\n    result\nend",
        "comment": "reduce 47 omitted reduce 48 omitted reduce 49 omitted reduce 50 omitted reduce 51 omitted reduce 52 omitted reduce 53 omitted reduce 54 omitted reduce 55 omitted reduce 56 omitted",
        "label": "What",
        "id": "16548"
    },
    {
        "raw_code": "def client\n      return @client if defined?(@client) && @client.same_options?(options)\n\n      @client = Octokit::Client.new(options)\n    end",
        "comment": "API client based on configured options {Configurable}  @return [Octokit::Client] API wrapper",
        "label": "What",
        "id": "14833"
    },
    {
        "raw_code": "def user(size: 64)\n      render(Pajamas::AvatarComponent.new(User.first, size: size))\n    end",
        "comment": "We show user avatars in a circle. @param size select {{ Pajamas::AvatarComponent::SIZE_OPTIONS }}",
        "label": "What",
        "id": "8216"
    },
    {
        "raw_code": "def skip_redundant_jobs?\n      ENV[\"CNG_SKIP_REDUNDANT_JOBS\"] == \"true\"\n    end",
        "comment": "Skip redundant build jobs by calculating if container images are already present in the registry  @return [Boolean]",
        "label": "What",
        "id": "5264"
    },
    {
        "raw_code": "def environment(repo, environment_name, options = {})\n        get(\"#{Repository.path repo}/environments/#{environment_name}\", options)\n      end",
        "comment": "Fetch a single environment for a repository  @param repo [Integer, String, Repository, Hash] A GitHub repository @param environment_name [String] The name of the environment @return <Sawyer::Resource> A single environment @see https://docs.github.com/en/rest/deployments/environments#get-an-environment",
        "label": "What",
        "id": "15226"
    },
    {
        "raw_code": "def requires_task?(file)\n          file.source.include?('task')\n        end",
        "comment": "Allow `require \"foo/rake_task\"`",
        "label": "What",
        "id": "3909"
    },
    {
        "raw_code": "def refresh_markdown_cache\n    return super if sharding_key_columns.any? { |s_column| self[s_column].present? }\n\n    # Using model callbacks to get sharding key values\n    ensure_organization_id\n    ensure_namespace_id\n\n    sharding_key_changes = changes.select { |k, _| sharding_key_columns.include?(k.to_sym) }\n    sharding_key_updates = sharding_key_changes.transform_values(&:last)\n\n    super.merge(sharding_key_updates)\n  end",
        "comment": "TODO: Remove when sharding key NOT NULL constraint is validated This should not happen often, and will only happen once for any record https://gitlab.com/gitlab-org/gitlab/-/work_items/570340",
        "label": "What",
        "id": "6939"
    },
    {
        "raw_code": "def workflow_run_job_logs(repo, job_id, options = {})\n        url = \"#{Repository.path repo}/actions/jobs/#{job_id}/logs\"\n\n        response = client_without_redirects.head(url, options)\n        response.headers['Location']\n      end",
        "comment": "Download job logs for a workflow run  @param repo [Integer, String, Repository, Hash] A GitHub repository @param job_id [Integer, String] Id of the job  @return [String] URL to the archived log files of the job @see https://docs.github.com/rest/actions/workflow-jobs#download-job-logs-for-a-workflow-run",
        "label": "What",
        "id": "15027"
    },
    {
        "raw_code": "def present(pipeline)\n          build = pipeline.builds.take\n\n          if build && (responder = Chat::Responder.responder_for(build))\n            in_channel_response(responder.scheduled_output)\n          else\n            unsupported_chat_service\n          end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord",
        "label": "What",
        "id": "2755"
    },
    {
        "raw_code": "def can_suggest_reviewers?\n    false\n  end",
        "comment": "overridden in EE",
        "label": "What",
        "id": "6769"
    },
    {
        "raw_code": "def exists\n      Arel::Nodes::Exists.new @ast\n    end",
        "comment": " Produces an Arel::Nodes::Exists node",
        "label": "What",
        "id": "13471"
    },
    {
        "raw_code": "def length\n    @parts.length\n  end",
        "comment": " Length of parts in the ListItem",
        "label": "What",
        "id": "16434"
    },
    {
        "raw_code": "def aref_to(target_path)\n    RDoc::Markup::ToHtml.gen_relative_url path, target_path\n  end",
        "comment": " Generates a relative URL from this object's path to +target_path+",
        "label": "What",
        "id": "16477"
    },
    {
        "raw_code": "def set_default_options(options = {})\n          if options.is_a?(Hash)\n            options = TemplateOptions.new.tap do |o|\n              o.reset_defaults\n              o.update(options)\n            end",
        "comment": "Sets default options on the options hash  @param [Hash] options the options hash @option options [Symbol] :format (:text) the default format @option options [Symbol] :type (nil) the :object's type, if provided @option options [Symbol] :template (:default) the default template @return [void]",
        "label": "What",
        "id": "376"
    },
    {
        "raw_code": "def each_object(method, *args, &block)\n        return to_enum(__method__, method, *args) unless block\n\n        each_page(method, nil, *args) do |page|\n          page.objects.each do |object|\n            yield object.to_h\n          end",
        "comment": "Iterates over all of the objects for the given method (e.g. `:labels`).  method - The method to send to Octokit for querying data. args - Any arguments to pass to the Octokit method.",
        "label": "What",
        "id": "2166"
    },
    {
        "raw_code": "def self.multiplier_expression(rule)\n        quoted_multiplier = ApplicationRecord.connection.quote(rule.fetch(:multiplier, DEFAULT_MULTIPLIER).to_s)\n\n        Arel::Nodes::NamedFunction.new('CAST', [Arel.sql(quoted_multiplier).as('numeric')])\n      end",
        "comment": "CAST(multiplier AS numeric)",
        "label": "What",
        "id": "3020"
    },
    {
        "raw_code": "def _NormalEndline\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _Sp()\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "NormalEndline = @Sp @Newline !@BlankLine !\">\" !AtxStart !(Line /={1,}|-{1,}/ @Newline) { \"\\n\" }",
        "label": "What",
        "id": "15746"
    },
    {
        "raw_code": "def call(env)\n      req = ActionDispatch::Request.new env\n      req.remote_ip = GetIp.new(req, check_ip, proxies)\n      @app.call(req.env)\n    end",
        "comment": "Since the IP address may not be needed, we store the object here without calculating the IP to keep from slowing down the majority of requests. For those requests that do need to know the IP, the GetIp#calculate_ip method will calculate the memoized client IP address.",
        "label": "What",
        "id": "11535"
    },
    {
        "raw_code": "def on_send(node)\n          return if allow_send? && !node.method?(:public_send)\n          return unless (first_argument = node.first_argument)\n          return unless first_argument.type?(*STATIC_METHOD_NAME_NODE_TYPES)\n\n          offense_range = offense_range(node)\n          method_name = first_argument.value\n          return if !METHOD_NAME_PATTERN.match?(method_name) || RESERVED_WORDS.include?(method_name)\n\n          add_offense(offense_range, message: format(MSG, method_name: method_name)) do |corrector|\n            if node.arguments.one?\n              corrector.replace(offense_range, method_name)\n            else\n              corrector.replace(node.loc.selector, method_name)\n              corrector.remove(removal_argument_range(first_argument, node.arguments[1]))\n            end",
        "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "What",
        "id": "10548"
    },
    {
        "raw_code": "def remove_nodoc(all_hash)\n    all_hash.keys.each do |name|\n      context = all_hash[name]\n      all_hash.delete(name) if context.remove_from_documentation?\n    end",
        "comment": " Removes from +all_hash+ the contexts that are nodoc or have no content.  See RDoc::Context#remove_from_documentation?",
        "label": "What",
        "id": "15886"
    },
    {
        "raw_code": "def key_from_settings(email)\n            return unless email.present?\n\n            # Normalize custom email to also include verification emails.\n            potential_custom_email = email.sub(ServiceDeskSetting::CUSTOM_EMAIL_VERIFICATION_SUBADDRESS, '')\n\n            settings = ServiceDeskSetting.find_by_custom_email(potential_custom_email)\n            return unless settings.present?\n\n            ::ServiceDesk::Emails.new(settings.project).default_subaddress_part\n          end",
        "comment": "Checks whether the given email is a custom email and returns the project's mail key.",
        "label": "What",
        "id": "3246"
    },
    {
        "raw_code": "def distance_of_time_in_words(from_time, to_time = 0, options = {})\n        options = {\n          scope: :'datetime.distance_in_words'\n        }.merge!(options)\n\n        from_time = normalize_distance_of_time_argument_to_time(from_time)\n        to_time = normalize_distance_of_time_argument_to_time(to_time)\n        from_time, to_time = to_time, from_time if from_time > to_time\n        distance_in_minutes = ((to_time - from_time) / 60.0).round\n        distance_in_seconds = (to_time - from_time).round\n\n        I18n.with_options locale: options[:locale], scope: options[:scope] do |locale|\n          case distance_in_minutes\n          when 0..1\n            return distance_in_minutes == 0 ?\n                   locale.t(:less_than_x_minutes, count: 1) :\n                   locale.t(:x_minutes, count: distance_in_minutes) unless options[:include_seconds]\n\n            case distance_in_seconds\n            when 0..4   then locale.t :less_than_x_seconds, count: 5\n            when 5..9   then locale.t :less_than_x_seconds, count: 10\n            when 10..19 then locale.t :less_than_x_seconds, count: 20\n            when 20..39 then locale.t :half_a_minute\n            when 40..59 then locale.t :less_than_x_minutes, count: 1\n            else             locale.t :x_minutes,           count: 1\n            end",
        "comment": "Reports the approximate distance in time between two Time, Date, or DateTime objects or integers as seconds. Pass <tt>include_seconds: true</tt> if you want more detailed approximations when distance < 1 min, 29 secs. Distances are reported based on the following table:  0 <-> 29 secs                                                             # => less than a minute 30 secs <-> 1 min, 29 secs                                                # => 1 minute 1 min, 30 secs <-> 44 mins, 29 secs                                       # => [2..44] minutes 44 mins, 30 secs <-> 89 mins, 29 secs                                     # => about 1 hour 89 mins, 30 secs <-> 23 hrs, 59 mins, 29 secs                             # => about [2..24] hours 23 hrs, 59 mins, 30 secs <-> 41 hrs, 59 mins, 29 secs                     # => 1 day 41 hrs, 59 mins, 30 secs  <-> 29 days, 23 hrs, 59 mins, 29 secs           # => [2..29] days 29 days, 23 hrs, 59 mins, 30 secs <-> 44 days, 23 hrs, 59 mins, 29 secs   # => about 1 month 44 days, 23 hrs, 59 mins, 30 secs <-> 59 days, 23 hrs, 59 mins, 29 secs   # => about 2 months 59 days, 23 hrs, 59 mins, 30 secs <-> 1 yr minus 1 sec                    # => [2..12] months 1 yr <-> 1 yr, 3 months                                                   # => about 1 year 1 yr, 3 months <-> 1 yr, 9 months                                         # => over 1 year 1 yr, 9 months <-> 2 yr minus 1 sec                                       # => almost 2 years 2 yrs <-> max time or date                                                # => (same rules as 1 yr)  With <tt>include_seconds: true</tt> and the difference < 1 minute 29 seconds: 0-4   secs      # => less than 5 seconds 5-9   secs      # => less than 10 seconds 10-19 secs      # => less than 20 seconds 20-39 secs      # => half a minute 40-59 secs      # => less than a minute 60-89 secs      # => 1 minute  from_time = Time.now distance_of_time_in_words(from_time, from_time + 50.minutes)                                # => about 1 hour distance_of_time_in_words(from_time, 50.minutes.from_now)                                   # => about 1 hour distance_of_time_in_words(from_time, from_time + 15.seconds)                                # => less than a minute distance_of_time_in_words(from_time, from_time + 15.seconds, include_seconds: true)         # => less than 20 seconds distance_of_time_in_words(from_time, 3.years.from_now)                                      # => about 3 years distance_of_time_in_words(from_time, from_time + 60.hours)                                  # => 3 days distance_of_time_in_words(from_time, from_time + 45.seconds, include_seconds: true)         # => less than a minute distance_of_time_in_words(from_time, from_time - 45.seconds, include_seconds: true)         # => less than a minute distance_of_time_in_words(from_time, 76.seconds.from_now)                                   # => 1 minute distance_of_time_in_words(from_time, from_time + 1.year + 3.days)                           # => about 1 year distance_of_time_in_words(from_time, from_time + 3.years + 6.months)                        # => over 3 years distance_of_time_in_words(from_time, from_time + 4.years + 9.days + 30.minutes + 5.seconds) # => about 4 years  to_time = Time.now + 6.years + 19.days distance_of_time_in_words(from_time, to_time, include_seconds: true)                        # => about 6 years distance_of_time_in_words(to_time, from_time, include_seconds: true)                        # => about 6 years distance_of_time_in_words(Time.now, Time.now)                                               # => less than a minute  With the <tt>scope</tt> option, you can define a custom scope for \\Rails to look up the translation.  For example you can define the following in your locale (e.g. en.yml).  datetime: distance_in_words: short: about_x_hours: one: 'an hour' other: '%{count} hours'  See https://github.com/svenfuchs/rails-i18n/blob/master/rails/locale/en.yml for more examples.  Which will then result in the following:  from_time = Time.now distance_of_time_in_words(from_time, from_time + 50.minutes, scope: 'datetime.distance_in_words.short') # => \"an hour\" distance_of_time_in_words(from_time, from_time + 3.hours, scope: 'datetime.distance_in_words.short')    # => \"3 hours\"",
        "label": "How-to-use",
        "id": "11824"
    },
    {
        "raw_code": "def create_table(table_name, id: :primary_key, primary_key: nil, force: nil, **options, &block)\n        validate_create_table_options!(options)\n        validate_table_length!(table_name) unless options[:_uses_legacy_table_name]\n\n        if force && options.key?(:if_not_exists)\n          raise ArgumentError, \"Options `:force` and `:if_not_exists` cannot be used simultaneously.\"\n        end",
        "comment": "Creates a new table with the name +table_name+. +table_name+ may either be a String or a Symbol.  There are two ways to work with #create_table. You can use the block form or the regular form, like this:  === Block form  # create_table() passes a TableDefinition object to the block. # This form will not only create the table, but also columns for the # table.  create_table(:suppliers) do |t| t.column :name, :string, limit: 60 # Other fields here end  === Block form, with shorthand  # You can also use the column types as method calls, rather than calling the column method. create_table(:suppliers) do |t| t.string :name, limit: 60 # Other fields here end  === Regular form  # Creates a table called 'suppliers' with no columns. create_table(:suppliers) # Add a column to 'suppliers'. add_column(:suppliers, :name, :string, {limit: 60})  The +options+ hash can include the following keys: [<tt>:id</tt>] Whether to automatically add a primary key column. Defaults to true. Join tables for {ActiveRecord::Base.has_and_belongs_to_many}[rdoc-ref:Associations::ClassMethods#has_and_belongs_to_many] should set it to false.  A Symbol can be used to specify the type of the generated primary key column.  A Hash can be used to specify the generated primary key column creation options. See {add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column] for available options. [<tt>:primary_key</tt>] The name of the primary key, if one is to be added automatically. Defaults to +id+. If <tt>:id</tt> is false, then this option is ignored.  If an array is passed, a composite primary key will be created.  Note that Active Record models will automatically detect their primary key. This can be avoided by using {self.primary_key=}[rdoc-ref:AttributeMethods::PrimaryKey::ClassMethods#primary_key=] on the model to define the key explicitly.  [<tt>:options</tt>] Any extra options you want appended to the table definition. [<tt>:temporary</tt>] Make a temporary table. [<tt>:force</tt>] Set to true to drop the table before creating it. Set to +:cascade+ to drop dependent objects as well. Defaults to false. [<tt>:if_not_exists</tt>] Set to true to avoid raising an error when the table already exists. Defaults to false. [<tt>:as</tt>] SQL to use to generate the table. When this option is used, the block is ignored, as are the <tt>:id</tt> and <tt>:primary_key</tt> options.  ====== Add a backend specific option to the generated SQL (MySQL)  create_table(:suppliers, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8mb4')  generates:  CREATE TABLE suppliers ( id bigint auto_increment PRIMARY KEY ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4  ====== Rename the primary key column  create_table(:objects, primary_key: 'guid') do |t| t.column :name, :string, limit: 80 end  generates:  CREATE TABLE objects ( guid bigint auto_increment PRIMARY KEY, name varchar(80) )  ====== Change the primary key column type  create_table(:tags, id: :string) do |t| t.column :label, :string end  generates:  CREATE TABLE tags ( id varchar PRIMARY KEY, label varchar )  ====== Create a composite primary key  create_table(:orders, primary_key: [:product_id, :client_id]) do |t| t.belongs_to :product t.belongs_to :client end  generates:  CREATE TABLE orders ( product_id bigint NOT NULL, client_id bigint NOT NULL );  ALTER TABLE ONLY \"orders\" ADD CONSTRAINT orders_pkey PRIMARY KEY (product_id, client_id);  ====== Do not add a primary key column  create_table(:categories_suppliers, id: false) do |t| t.column :category_id, :bigint t.column :supplier_id, :bigint end  generates:  CREATE TABLE categories_suppliers ( category_id bigint, supplier_id bigint )  ====== Create a temporary table based on a query  create_table(:long_query, temporary: true, as: \"SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id\")  generates:  CREATE TEMPORARY TABLE long_query AS SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id  See also TableDefinition#column for details on how to create columns.",
        "label": "How-to-use",
        "id": "13139"
    },
    {
        "raw_code": "def self.definition_for(method_obj)\n        path, begin_line = method_obj.source_location\n        begins_to_ends = new(File.read(path), path).parse\n        return unless end_line = begins_to_ends[begin_line]\n        [path, (begin_line..end_line)]\n      end",
        "comment": "Helper to translate a method object into the path and line range where the method was defined.",
        "label": "How-to-use",
        "id": "14822"
    },
    {
        "raw_code": "def on_def(node)\n          return unless in_migration?(node)\n\n          node.each_descendant(:send) do |send_node|\n            method_name = send_node.children[1]\n\n            if method_name == :datetime || method_name == :timestamp\n              add_offense(send_node.loc.selector, message: format(MSG, method_name))\n            end",
        "comment": "Check methods in table creation.",
        "label": "How-to-use",
        "id": "3913"
    },
    {
        "raw_code": "def revoke\n    tokens = params.expect(_json: [%i[token type url]]).index_by { |t| hashed_key(t.require(:token)) }\n    api_keys = ApiKey.where(hashed_key: tokens.keys).index_by(&:hashed_key)\n    resp = tokens.map do |hashed_key, t|\n      api_key = api_keys[hashed_key]\n      label = if api_key&.expire!\n                schedule_revoke_email(api_key, t[:url])\n                \"true_positive\"\n              else\n                \"false_positive\"\n              end",
        "comment": "API called by GitHub Secret Scanning tool see docs https://docs.github.com/en/developers/overview/secret-scanning Sample message:  POST / HTTP/1.1 Host: HOST Accept: */* content-type: application/json GITHUB-PUBLIC-KEY-IDENTIFIER: 90a421169f0a406205f1563a953312f0be898d3c7b6c06b681aa86a874555f4a GITHUB-PUBLIC-KEY-SIGNATURE: MEUCICxTWEpKo7BorLKutFZDS6ie+YFg6ecU7kEA6rUUSJqsAiEA9bK0Iy6vk2QpZOOg2IpBhZ3JRVdwXx1zmgmNAR7Izpc= Content-Length: 0000  [{\"token\": \"some_token\", \"type\": \"some_type\", \"url\": \"some_url\"}] ",
        "label": "How-to-use",
        "id": "9967"
    },
    {
        "raw_code": "def <=>(other)\n      utc <=> other\n    end",
        "comment": "Use the time in UTC for comparisons.",
        "label": "How-to-use",
        "id": "13974"
    },
    {
        "raw_code": "def render(options = {}, locals = {}, &block)\n        case options\n        when Hash\n          in_rendering_context(options) do |renderer|\n            if block_given?\n              view_renderer.render_partial(self, options.merge(partial: options[:layout]), &block)\n            else\n              view_renderer.render(self, options)\n            end",
        "comment": "Renders a template and returns the result.  Pass the template to render as the first argument. This is shorthand syntax for partial rendering, so the template filename should be prefixed with an underscore. The partial renderer looks for the partial template in the directory of the calling template first.  <% # app/views/posts/new.html.erb %> <%= render \"form\" %> # => renders app/views/posts/_form.html.erb  Use the complete view path to render a partial from another directory.  <% # app/views/posts/show.html.erb %> <%= render \"comments/form\" %> # => renders app/views/comments/_form.html.erb  Without the rendering mode, the second argument can be a Hash of local variable assignments for the template.  <% # app/views/posts/new.html.erb %> <%= render \"form\", post: Post.new %> # => renders app/views/posts/_form.html.erb  If the first argument responds to `render_in`, the template will be rendered by calling `render_in` with the current view context.  class Greeting def render_in(view_context) view_context.render html: \"<h1>Hello, World</h1>\" end  def format :html end end  <%= render Greeting.new %> # => \"<h1>Hello, World</h1>\"  #### Rendering Mode  Pass the rendering mode as first argument to override it.  `:partial` :   See ActionView::PartialRenderer for details.  <%= render partial: \"form\", locals: { post: Post.new } %> # => renders app/views/posts/_form.html.erb  `:file` :   Renders the contents of a file. This option should **not** be used with unsanitized user input.  <%= render file: \"/path/to/some/file\" %> # => renders /path/to/some/file  `:inline` :   Renders an ERB template string.  <% name = \"World\" %> <%= render inline: \"<h1>Hello, <%= name %>!</h1>\" %> # => renders \"<h1>Hello, World!</h1>\"  `:body` :   Renders the provided text, and sets the format as `:text`.  <%= render body: \"Hello, World!\" %> # => renders \"Hello, World!\"  `:plain` :   Renders the provided text, and sets the format as `:text`.  <%= render plain: \"Hello, World!\" %> # => renders \"Hello, World!\"  `:html` :   Renders the provided HTML string, and sets the format as `:html`. If the string is not `html_safe?`, performs HTML escaping on the string before rendering.  <%= render html: \"<h1>Hello, World!</h1>\".html_safe %> # => renders \"<h1>Hello, World!</h1>\"  <%= render html: \"<h1>Hello, World!</h1>\" %> # => renders \"&lt;h1&gt;Hello, World!&lt;/h1&gt;\"  `:renderable` :   Renders the provided object by calling `render_in` with the current view context. The format is determined by calling `format` on the renderable if it responds to `format`, falling back to `:html` by default.  <%= render renderable: Greeting.new %> # => renders \"<h1>Hello, World</h1>\"   #### Options  `:locals` :   Hash of local variable assignments for the template.  <%= render inline: \"<h1>Hello, <%= name %>!</h1>\", locals: { name: \"World\" } %> # => renders \"<h1>Hello, World!</h1>\"  `:formats` :   Override the current format to render a template for a different format.  <% # app/views/posts/show.html.erb %> <%= render template: \"posts/content\", formats: [:text] %> # => renders app/views/posts/content.text.erb  `:variants` :   Render a template for a different variant.  <% # app/views/posts/show.html.erb %> <%= render template: \"posts/content\", variants: [:tablet] %> # => renders app/views/posts/content.html+tablet.erb  `:handlers` :   Render a template for a different handler.  <% # app/views/posts/show.html.erb %> <%= render template: \"posts/content\", handlers: [:builder] %> # => renders app/views/posts/content.html.builder",
        "label": "How-to-use",
        "id": "11960"
    },
    {
        "raw_code": "def render_to_body(options)\n      _render_to_body_with_renderer(options) || super\n    end",
        "comment": "Called by `render` in AbstractController::Rendering which sets the return value as the `response_body`.  If no renderer is found, `super` returns control to `ActionView::Rendering.render_to_body`, if present.",
        "label": "How-to-use",
        "id": "11324"
    },
    {
        "raw_code": "def reset_callbacks(name)\n          callbacks = get_callbacks name\n\n          self.descendants.each do |target|\n            chain = target.get_callbacks(name).dup\n            callbacks.each { |c| chain.delete(c) }\n            target.set_callbacks name, chain\n          end",
        "comment": "Remove all set callbacks for the given event.",
        "label": "How-to-use",
        "id": "13775"
    },
    {
        "raw_code": "def method_missing(*)\n      nil\n    end",
        "comment": "Mimic behavior of OpenStruct, which absorbs any calls into undefined properties to return `nil`.",
        "label": "How-to-use",
        "id": "1663"
    },
    {
        "raw_code": "def fetch_examples(klass)\n          logger.info(\"Fetching examples for scenario '#{klass}'\")\n\n          spec_pattern = klass.spec_pattern\n          scenario_tests = scenario_class_tests(spec_pattern)\n          return [] if spec_pattern && scenario_tests.empty? # no executable specs for this scenario class\n\n          Support::ExampleData.fetch(klass.focus, scenario_tests, logger: logger).map do |example|\n            example.slice(:id, :status)\n          end",
        "comment": "Fetch list of executable examples for scenario class  @param klass [Class] @return [Array<Hash>]",
        "label": "How-to-use",
        "id": "4817"
    },
    {
        "raw_code": "def allow(allowed_warnings = :all, if: true, &block)\n        conditional = binding.local_variable_get(:if)\n        conditional = conditional.call if conditional.respond_to?(:call)\n        if conditional\n          @explicitly_allowed_warnings.bind(allowed_warnings, &block)\n        else\n          yield\n        end",
        "comment": "Allow previously disallowed deprecation warnings within the block. <tt>allowed_warnings</tt> can be an array containing strings, symbols, or regular expressions. (Symbols are treated as strings). These are compared against the text of deprecation warning messages generated within the block. Matching warnings will be exempt from the rules set by ActiveSupport::Deprecation#disallowed_warnings.  The optional <tt>if:</tt> argument accepts a truthy/falsy value or an object that responds to <tt>.call</tt>. If truthy, then matching warnings will be allowed. If falsey then the method yields to the block without allowing the warning.  deprecator = ActiveSupport::Deprecation.new deprecator.disallowed_behavior = :raise deprecator.disallowed_warnings = [ \"something broke\" ]  deprecator.warn('something broke!') # => ActiveSupport::DeprecationException  deprecator.allow ['something broke'] do deprecator.warn('something broke!') end # => nil  deprecator.allow ['something broke'], if: Rails.env.production? do deprecator.warn('something broke!') end # => ActiveSupport::DeprecationException for dev/test, nil for production",
        "label": "How-to-use",
        "id": "14445"
    },
    {
        "raw_code": "def hello\n        end",
        "comment": "Description of `hello` method.",
        "label": "How-to-use",
        "id": "10797"
    },
    {
        "raw_code": "def enqueue_after_transaction_commit?\n        true\n      end",
        "comment": "Defines whether enqueuing should happen implicitly to after commit when called from inside a transaction. @api private",
        "label": "How-to-use",
        "id": "5238"
    },
    {
        "raw_code": "def around_deliver(*filters, &blk)\n        set_callback(:deliver, :around, *filters, &blk)\n      end",
        "comment": "Defines a callback that will get called around the message's deliver method.",
        "label": "How-to-use",
        "id": "11125"
    },
    {
        "raw_code": "def snippet(text, limit = 100)\n    document = parse text\n\n    RDoc::Markup::ToHtmlSnippet.new(options, limit).convert document\n  end",
        "comment": " The first +limit+ characters of +text+ as HTML",
        "label": "How-to-use",
        "id": "15563"
    },
    {
        "raw_code": "def initialize(app, env, message, force_key=nil, **opts)\n          @app      = app\n          @message  = message\n          @force_key = force_key\n          @allowed  = opts[:allowed]\n        end",
        "comment": "For documentation, read the description of the {Confirm} class.  @param [String] message The message to ask the user. @param [Symbol] force_key The key that if present and true in the environment hash will skip the confirmation question.",
        "label": "How-to-use",
        "id": "9347"
    },
    {
        "raw_code": "def create_table(table_name, *args, **kwargs, &block)\n          helper_context = self\n\n          super do |t|\n            t.define_singleton_method(:text) do |column_name, **kwargs|\n              limit = kwargs.delete(:limit)\n\n              super(column_name, **kwargs)\n\n              if limit\n                # rubocop:disable GitlabSecurity/PublicSend\n                name = helper_context.send(:text_limit_name, table_name, column_name)\n                # rubocop:enable GitlabSecurity/PublicSend\n\n                column_name = helper_context.quote_column_name(column_name)\n                definition = \"char_length(#{column_name}) <= #{limit}\"\n\n                t.check_constraint(definition, name: name)\n              end",
        "comment": "Creates a new table, optionally allowing the caller to add text limit constraints to the table. This method only extends Rails' `create_table` method  Example:  create_table :db_guides do |t| t.bigint :stars, default: 0, null: false t.text :title, limit: 128 t.text :notes, limit: 1024  t.check_constraint 'stars > 1000', name: 'so_many_stars' end  See Rails' `create_table` for more info on the available arguments.  When adding foreign keys to other tables, consider wrapping the call into a with_lock_retries block to avoid traffic stalls.",
        "label": "How-to-use",
        "id": "3138"
    },
    {
        "raw_code": "def callback(paths, modified, added, removed)\n          @logger.info(\"File change callback called!\")\n          @logger.info(\"  - Modified: #{modified.inspect}\")\n          @logger.info(\"  - Added: #{added.inspect}\")\n          @logger.info(\"  - Removed: #{removed.inspect}\")\n\n          tosync = []\n          paths.each do |hostpath, folders|\n            # Find out if this path should be synced\n            found = catch(:done) do\n              [modified, added, removed].each do |changed|\n                changed.each do |listenpath|\n                  throw :done, true if listenpath.start_with?(hostpath)\n                end",
        "comment": "This is the callback that is called when any changes happen",
        "label": "How-to-use",
        "id": "9421"
    },
    {
        "raw_code": "def count(column_name = nil)\n      if block_given?\n        unless column_name.nil?\n          raise ArgumentError, \"Column name argument is not supported when a block is passed.\"\n        end",
        "comment": "Count the records.  Person.count # => the total count of all people  Person.count(:age) # => returns the total count of all people whose age is present in database  Person.count(:all) # => performs a COUNT(*) (:all is an alias for '*')  Person.distinct.count(:age) # => counts the number of different age values  If +count+ is used with {Relation#group}[rdoc-ref:QueryMethods#group], it returns a Hash whose keys represent the aggregated column, and the values are the respective amounts:  Person.group(:city).count # => { 'Rome' => 5, 'Paris' => 3 }  If +count+ is used with {Relation#group}[rdoc-ref:QueryMethods#group] for multiple columns, it returns a Hash whose keys are an array containing the individual values of each column and the value of each key would be the count.  Article.group(:status, :category).count # =>  {[\"draft\", \"business\"]=>10, [\"draft\", \"technology\"]=>4, [\"published\", \"technology\"]=>2}  If +count+ is used with {Relation#select}[rdoc-ref:QueryMethods#select], it will count the selected columns:  Person.select(:age).count # => counts the number of different age values  Note: not all valid {Relation#select}[rdoc-ref:QueryMethods#select] expressions are valid +count+ expressions. The specifics differ between databases. In invalid cases, an error from the database is thrown.  When given a block, calls the block with each record in the relation and returns the number of records for which the block returns a truthy value.  Person.count { |person| person.age > 21 } # => counts the number of people older that 21  If the relation hasn't been loaded yet, calling +count+ with a block will load all records in the relation. If there are a lot of records in the relation, loading all records could result in performance issues.",
        "label": "How-to-use",
        "id": "13345"
    },
    {
        "raw_code": "def add_check_constraint(table, check, constraint_name, validate: true)\n          # Transactions would result in ALTER TABLE locks being held for the\n          # duration of the transaction, defeating the purpose of this method.\n          validate_not_in_transaction!(:add_check_constraint)\n\n          validate_check_constraint_name!(constraint_name)\n\n          if check_constraint_exists?(table, constraint_name)\n            warning_message = <<~MESSAGE\n              Check constraint was not created because it exists already\n              (this may be due to an aborted migration or similar)\n              table: #{table}, check: #{check}, constraint name: #{constraint_name}\n            MESSAGE\n\n            Gitlab::AppLogger.warn warning_message\n          else\n            # Only add the constraint without validating it\n            # Even though it is fast, ADD CONSTRAINT requires an EXCLUSIVE lock\n            # Use with_lock_retries to make sure that this operation\n            # will not timeout on tables accessed by many processes\n            with_lock_retries do\n              execute <<~SQL\n              ALTER TABLE #{table}\n              ADD CONSTRAINT #{constraint_name}\n              CHECK ( #{check} )\n              NOT VALID;\n              SQL\n            end",
        "comment": "Adds a check constraint to a table  This method is the generic helper for adding any check constraint More specialized helpers may use it (e.g. add_text_limit or add_not_null)  This method only requires minimal locking: - The constraint is added using NOT VALID This allows us to add the check constraint without validating it - The check will be enforced for new data (inserts) coming in - If `validate: true` the constraint is also validated Otherwise, validate_check_constraint() can be used at a later stage - Check comments on add_concurrent_foreign_key for more info  table  - The table the constraint will be added to check  - The check clause to add e.g. 'char_length(name) <= 5' or 'store IS NOT NULL' constraint_name - The name of the check constraint (otherwise auto-generated) Should be unique per table (not per column) validate - Whether to validate the constraint in this call ",
        "label": "How-to-use",
        "id": "3156"
    },
    {
        "raw_code": "def add_constant(constant)\n    @display.print_constant constant\n  end",
        "comment": " Records the parsing of +constant+",
        "label": "How-to-use",
        "id": "15984"
    },
    {
        "raw_code": "def append_data(model, new_data, offset)\n        if offset > 0\n          truncated_data = data(model).to_s.byteslice(0, offset)\n          new_data = append_strings(truncated_data, new_data)\n        end",
        "comment": "This is the sequence that causes append_data to be called:  1. Runner sends a PUT /api/v4/jobs/:id to indicate the job is canceled or finished. 2. UpdateBuildStateService#accept_build_state! persists all live job logs to object storage (or filesystem). 3. UpdateBuildStateService#accept_build_state! returns a 202 to the runner. 4. The runner continues to send PATCH requests with job logs until all logs have been sent and received. 5. If the last PATCH request arrives after the job log has been persisted, we retrieve the data from object storage to append the remaining lines.",
        "label": "How-to-use",
        "id": "7591"
    },
    {
        "raw_code": "def attachment\n      change.present? ? change.attachment : record.public_send(\"#{name}_attachment\")\n    end",
        "comment": "Returns the associated attachment record.  You don't have to call this method to access the attachment's methods as they are all available at the model level.",
        "label": "How-to-use",
        "id": "13688"
    },
    {
        "raw_code": "def parse_constant_visibility(container, single, tk)\n    args = parse_symbol_arg\n    case tk[:text]\n    when 'private_constant'\n      vis = :private\n    when 'public_constant'\n      vis = :public\n    else\n      raise RDoc::Error, 'Unreachable'\n    end",
        "comment": " Parses a Module#private_constant or Module#public_constant call from +tk+.",
        "label": "How-to-use",
        "id": "16119"
    },
    {
        "raw_code": "def prefetch_primary_key?(table_name = nil)\n        false\n      end",
        "comment": "Should primary key values be selected from their corresponding sequence before the insert statement? If true, next_sequence_value is called before each insert to set the record's primary key.",
        "label": "How-to-use",
        "id": "12885"
    },
    {
        "raw_code": "def delete_all\n      return 0 if @none\n\n      invalid_methods = INVALID_METHODS_FOR_UPDATE_AND_DELETE_ALL.select do |method|\n        value = @values[method]\n        method == :distinct ? value : value&.any?\n      end",
        "comment": "Deletes the records without instantiating the records first, and hence not calling the {#destroy}[rdoc-ref:Persistence#destroy] method nor invoking callbacks. This is a single SQL DELETE statement that goes straight to the database, much more efficient than #destroy_all. Be careful with relations though, in particular <tt>:dependent</tt> rules defined on associations are not honored. Returns the number of rows affected.  Post.where(person_id: 5).where(category: ['Something', 'Else']).delete_all  Both calls delete the affected posts all at once with a single DELETE statement. If you need to destroy dependent associations or call your <tt>before_*</tt> or +after_destroy+ callbacks, use the #destroy_all method instead.  If an invalid method is supplied, #delete_all raises an ActiveRecordError:  Post.distinct.delete_all # => ActiveRecord::ActiveRecordError: delete_all doesn't support distinct",
        "label": "How-to-use",
        "id": "12654"
    },
    {
        "raw_code": "def merge_requests_count(user = nil)\n    ::MergeRequestsClosingIssues.count_for_issue(self.id, user)\n  end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "6816"
    },
    {
        "raw_code": "def racc_read_token(t, tok, val)\n      @racc_debug_out.print 'read    '\n      @racc_debug_out.print tok.inspect, '(', racc_token2str(t), ') '\n      @racc_debug_out.puts val.inspect\n      @racc_debug_out.puts\n    end",
        "comment": "For debugging output",
        "label": "How-to-use",
        "id": "16533"
    },
    {
        "raw_code": "def create_or_find_by!(attributes, &block)\n      with_connection do |connection|\n        record = nil\n        transaction(requires_new: true) do\n          record = create!(attributes, &block)\n          record._last_transaction_return_status || raise(ActiveRecord::Rollback)\n        end",
        "comment": "Like #create_or_find_by, but calls {create!}[rdoc-ref:Persistence::ClassMethods#create!] so an exception is raised if the created record is invalid.",
        "label": "How-to-use",
        "id": "12629"
    },
    {
        "raw_code": "def self.parse(source, filename = nil)\n        new(source, filename).parse\n      end",
        "comment": "Convenience method to create a new parser and {#parse}",
        "label": "How-to-use",
        "id": "280"
    },
    {
        "raw_code": "def _HtmlAttribute\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n\n      _save2 = self.pos\n      while true # choice\n        _tmp = apply(:_AlphanumericAscii)\n        break if _tmp\n        self.pos = _save2\n        _tmp = match_string(\"-\")\n        break if _tmp\n        self.pos = _save2\n        break\n      end # end choice\n\n      if _tmp\n        while true\n\n          _save3 = self.pos\n          while true # choice\n            _tmp = apply(:_AlphanumericAscii)\n            break if _tmp\n            self.pos = _save3\n            _tmp = match_string(\"-\")\n            break if _tmp\n            self.pos = _save3\n            break\n          end # end choice\n\n          break unless _tmp\n        end",
        "comment": "HtmlAttribute = (AlphanumericAscii | \"-\")+ Spnl (\"=\" Spnl (Quoted | (!\">\" Nonspacechar)+))? Spnl",
        "label": "How-to-use",
        "id": "15794"
    },
    {
        "raw_code": "def stream(keep_open = false)\n      scheduler = env['async.callback'] ? EventMachine : Stream\n      current   = @params.dup\n      stream = if scheduler == Stream  && keep_open\n        Stream.new(scheduler, false) do |out|\n          until out.closed?\n            with_params(current) { yield(out) }\n          end",
        "comment": "Allows to start sending data to the client even though later parts of the response body have not yet been generated.  The close parameter specifies whether Stream#close should be called after the block has been executed.",
        "label": "How-to-use",
        "id": "8558"
    },
    {
        "raw_code": "def accept_list_item_start(list_item)\n    @res << list_item_start(list_item, @list.last)\n  end",
        "comment": " Prepares the visitor for consuming +list_item+",
        "label": "How-to-use",
        "id": "16404"
    },
    {
        "raw_code": "def self.profile(url, logger: nil, post_data: nil, user: nil, private_token: nil, headers: {}, profiler_options: {})\n      app = ActionDispatch::Integration::Session.new(Rails.application)\n      verb = :get\n\n      if post_data\n        verb = :post\n        headers['Content-Type'] = 'application/json'\n      end",
        "comment": "Takes a URL to profile (can be a fully-qualified URL, or an absolute path) and returns the profiler result. Formatting that result is the caller's responsibility. Requests are GET requests unless post_data is passed.  Optional arguments: - logger: will be used for SQL logging, including a summary at the end of the log file of the total time spent per model class.  - post_data: a string of raw POST data to use. Changes the HTTP verb to POST.  - user: a user to authenticate as.  - private_token: instead of providing a user instance, the token can be given as a string. Takes precedence over the user option.  - profiler_options: A keyword Hash of arguments passed to the profiler. Defaults: { mode: :wall, out: <some temporary file>, interval: 1000, raw: true }",
        "label": "How-to-use",
        "id": "1500"
    },
    {
        "raw_code": "def configure\n      yield self\n    end",
        "comment": "Set configuration options using a block",
        "label": "How-to-use",
        "id": "14842"
    },
    {
        "raw_code": "def register_template_handler(*extensions, handler)\n        raise(ArgumentError, \"Extension is required\") if extensions.empty?\n        extensions.each do |extension|\n          @@template_handlers[extension.to_sym] = handler\n        end",
        "comment": "Register an object that knows how to handle template files with the given extensions. This can be used to implement new template types. The handler must respond to +:call+, which will be passed the template and should return the rendered template as a String.",
        "label": "How-to-use",
        "id": "12018"
    },
    {
        "raw_code": "def self.webide_extension_marketplace_settings(user:)\n      Settings.get_single_setting(:vscode_extension_marketplace_view_model, user: user)\n    end",
        "comment": "This returns a value to be used in the Web IDE config `extensionsGallerySettings` It should match the type expected by the Web IDE:  - https://gitlab.com/gitlab-org/gitlab-web-ide/-/blob/51f9e91f890752596e7a3ef51f436fea07885eff/packages/web-ide-types/src/config.ts#L109  @param [User] user The current user @return [Hash]",
        "label": "How-to-use",
        "id": "3553"
    },
    {
        "raw_code": "def _render_template(options)\n        variant = options.delete(:variant)\n        assigns = options.delete(:assigns)\n        context = view_context\n\n        context.assign assigns if assigns\n        lookup_context.variants = variant if variant\n\n        rendered_template = context.in_rendering_context(options) do |renderer|\n          renderer.render_to_object(context, options)\n        end",
        "comment": "Find and render a template based on the options given.",
        "label": "How-to-use",
        "id": "11747"
    },
    {
        "raw_code": "def run_type\n        @run_type ||= if env('QA_RUN_TYPE')\n                        env('QA_RUN_TYPE')\n                      elsif LIVE_ENVS.exclude?(ci_project_name)\n                        nil\n                      else\n                        test_subset = if env('SMOKE_ONLY') == 'true'\n                                        'sanity'\n                                      else\n                                        'full'\n                                      end",
        "comment": "Test run type Automatically infer for staging (`gstg`, `gstg-cny`, `gstg-ref`), canary, preprod or production env  @return [String, nil]",
        "label": "How-to-use",
        "id": "4567"
    },
    {
        "raw_code": "def filtered_omniauth_provider_names\n        omniauth_provider_names.reject { |name| name.starts_with?('ldap') }\n      end",
        "comment": "LDAP provider names are set by customers and could include sensitive info (server names, etc). LDAP providers normally don't appear in omniauth providers but filter to ensure no internal details leak via usage ping.",
        "label": "How-to-use",
        "id": "1745"
    },
    {
        "raw_code": "def self.run(*args) new.run(*args) end\n\n      def initialize\n        log.show_backtraces = false\n      end\n\n      # Runs the {Command} object matching the command name of the first\n      # argument.\n      # @return [void]\n      def run(*args)\n        unless args == ['--help']\n          if args.empty? || args.first =~ /^-/\n            command_name = self.class.default_command\n          else\n            command_name = args.first.to_sym\n            args.shift\n          end\n          if commands.key?(command_name)\n            return commands[command_name].run(*args)\n          end",
        "comment": "Convenience method to create a new CommandParser and call {#run} @return (see #run)",
        "label": "How-to-use",
        "id": "499"
    },
    {
        "raw_code": "def alert=(message)\n        self[:alert] = message\n      end",
        "comment": "Convenience accessor for `flash[:alert]=`.",
        "label": "How-to-use",
        "id": "11531"
    },
    {
        "raw_code": "def apply(docstring, call_params = [], full_source = '', block_source = '', _method_object = nil) # rubocop:disable Lint/UnusedMethodArgument\n          docstring = docstring.all if Docstring === docstring\n          parser = Docstring.parser\n          handler = OpenStruct.new\n          handler.call_params = call_params[1..-1]\n          handler.caller_method = call_params.first\n          handler.statement = OpenStruct.new(:source => full_source)\n          parser.parse(docstring, nil, handler).to_docstring.to_raw\n        end",
        "comment": "Applies a macro on a docstring by creating any macro data inside of the docstring first. Equivalent to calling {find_or_create} and {apply_macro} on the new macro object.  @param [Docstring] docstring the docstring to create a macro out of @!macro macro.expand @see find_or_create",
        "label": "How-to-use",
        "id": "613"
    },
    {
        "raw_code": "def sequential_maintenance(candidate_selector, &maintenance_work)\n          # This hash doesn't need to be synchronized, because it's only\n          # used by one thread at a time: the +perform_work+ block gives\n          # up its right to +connections_visited+ when it schedules the\n          # next iteration.\n          connections_visited = Hash.new(false)\n          connections_visited.compare_by_identity\n\n          perform_work = lambda do\n            connection_to_maintain = nil\n\n            synchronize do\n              unless self.discarded?\n                if connection_to_maintain = @connections.select { |conn| !conn.in_use? }.select(&candidate_selector).sort_by(&:seconds_idle).find { |conn| !connections_visited[conn] }\n                  checkout_for_maintenance connection_to_maintain\n                end",
        "comment": "Perform maintenance work on pool connections. This method will select a connection to work on by calling the +candidate_selector+ proc while holding the pool lock. If a connection is selected, it will be checked out for maintenance and passed to the +maintenance_work+ proc. The connection will always be returned to the pool after the proc completes.  If the pool has async threads, all work will be scheduled there. Otherwise, this method will block until all work is complete.  Each connection will only be processed once per call to this method, but (particularly in the async case) there is no protection against a second call to this method starting to work through the list before the first call has completed. (Though regular pool behavior will prevent two instances from working on the same specific connection at the same time.)",
        "label": "How-to-use",
        "id": "13036"
    },
    {
        "raw_code": "def active?(diff_refs = nil)\n    return @active if defined?(@active)\n    return true if for_commit?\n    return true unless diff_line\n    return false unless noteable\n    return false if diff_refs && diff_refs != noteable.diff_refs\n\n    noteable_diff = find_noteable_diff\n\n    if noteable_diff\n      parsed_lines = Gitlab::Diff::Parser.new.parse(noteable_diff.diff.each_line)\n\n      @active = parsed_lines.any? { |line_obj| line_obj.text == diff_line.text }\n    else\n      @active = false\n    end",
        "comment": "Check if this note is part of an \"active\" discussion  This will always return true for anything except MergeRequest noteables, which have special logic.  If the note's current diff cannot be matched in the MergeRequest's current diff, it's considered inactive.",
        "label": "How-to-use",
        "id": "6806"
    },
    {
        "raw_code": "def render_call_options(node)\n          # We are only looking for calls to render or render_to_string.\n          name = node.name.to_sym\n          return if name != :render && name != :render_to_string\n\n          # We are only looking for calls with arguments.\n          arguments = node.arguments\n          return unless arguments\n\n          arguments = arguments.arguments\n          length = arguments.length\n\n          # Get rid of any parentheses to get directly to the contents.\n          arguments.map! do |argument|\n            current = argument\n\n            while current.is_a?(Prism::ParenthesesNode) &&\n                  current.body.is_a?(Prism::StatementsNode) &&\n                  current.body.body.length == 1\n              current = current.body.body.first\n            end",
        "comment": "Accept a call node and return a hash of options for the render call. If it doesn't match the expected format, return nil.",
        "label": "How-to-use",
        "id": "12014"
    },
    {
        "raw_code": "def noteable_moved(noteable_ref, direction)\n      unless [:to, :from].include?(direction)\n        raise ArgumentError, \"Invalid direction `#{direction}`\"\n      end",
        "comment": "Called when noteable has been moved to another project  noteable_ref - Referenced noteable direction    - symbol, :to or :from  Example Note text:  \"moved to some_namespace/project_new#11\"  Returns the created Note object",
        "label": "How-to-use",
        "id": "5622"
    },
    {
        "raw_code": "def to_json(*a)\n          instance_variables_hash.to_json(*a)\n        end",
        "comment": "Converts this configuration object to JSON.",
        "label": "How-to-use",
        "id": "9023"
    },
    {
        "raw_code": "def to_hash\n          hash = {}\n\n          attributes.each do |key, value|\n            hash[key] = convert_value_for_to_hash(value)\n          end",
        "comment": "Converts the current representation to a Hash. The keys of this Hash will be Symbols.",
        "label": "How-to-use",
        "id": "2271"
    },
    {
        "raw_code": "def remove_invisible(min_visibility)\n    return if [:private, :nodoc].include? min_visibility\n    remove_invisible_in @method_list, min_visibility\n    remove_invisible_in @attributes, min_visibility\n    remove_invisible_in @constants, min_visibility\n  end",
        "comment": " Removes methods and attributes with a visibility less than +min_visibility+. -- TODO mark the visibility of attributes in the template (if not public?)",
        "label": "How-to-use",
        "id": "16690"
    },
    {
        "raw_code": "def aref\n    type = singleton ? 'c' : 'i'\n    \"#alias-#{type}-#{html_name}\"\n  end",
        "comment": " HTML fragment reference for this alias",
        "label": "How-to-use",
        "id": "16772"
    },
    {
        "raw_code": "def self.uuid_v3(uuid_namespace, name)\n      uuid_from_hash(OpenSSL::Digest::MD5, uuid_namespace, name)\n    end",
        "comment": "Convenience method for uuid_from_hash using OpenSSL::Digest::MD5.",
        "label": "How-to-use",
        "id": "14211"
    },
    {
        "raw_code": "def allow_unrouted_sidekiq_calls\n          currently_allowed = Thread.current[:allow_unrouted_sidekiq_calls]\n          Thread.current[:allow_unrouted_sidekiq_calls] = true\n\n          yield\n        ensure\n          Thread.current[:allow_unrouted_sidekiq_calls] = currently_allowed\n        end",
        "comment": "Used to allow Sidekiq API or Sidekiq.redis for spec set-ups and components that does not require sharding such as CronJobs (performed using Sidekiq.redis).",
        "label": "How-to-use",
        "id": "2427"
    },
    {
        "raw_code": "def original_activerecord_config\n      @activerecord_database_config.configuration_hash.dup\n    end",
        "comment": "Return the database configuration from rails config/database.yml file in the format expected by ActiveRecord::DatabaseConfigurations::HashConfig  @return [Hash] configuration hash",
        "label": "How-to-use",
        "id": "3645"
    },
    {
        "raw_code": "def execute_exec!(*cmd)\n        @@logger.debug(\"executing command via exec: #{cmd.inspect}\")\n        Vagrant::Util::SafeExec.exec(cmd[0], *cmd[1..-1])\n      end",
        "comment": "Run the command as exec (unix).",
        "label": "How-to-use",
        "id": "9360"
    },
    {
        "raw_code": "def stop_exclusive(compatible: [])\n        synchronize do\n          raise \"invalid unlock\" if @exclusive_thread != Thread.current\n\n          @exclusive_depth -= 1\n          if @exclusive_depth == 0\n            @exclusive_thread = nil\n\n            if eligible_waiters?(compatible)\n              yield_shares(compatible: compatible, block_share: true) do\n                wait_for(:stop_exclusive) { @exclusive_thread || eligible_waiters?(compatible) }\n              end",
        "comment": "Relinquish the exclusive lock. Must only be called by the thread that called start_exclusive (and currently holds the lock).",
        "label": "How-to-use",
        "id": "14060"
    },
    {
        "raw_code": "def mark_canonical_issue_of_duplicate(duplicate_issue)\n      body = \"marked #{duplicate_issue.to_reference(project)} as a duplicate of this issue\"\n      create_note(NoteSummary.new(noteable, project, author, body, action: 'duplicate'))\n    end",
        "comment": "Called when a Noteable has been marked as the canonical Issue of a duplicate  duplicate_issue - Issue that was a duplicate of this  Example Note text:  \"marked #1234 as a duplicate of this issue\"  \"marked other_project#5678 as a duplicate of this issue\"  Returns the created Note object",
        "label": "How-to-use",
        "id": "5627"
    },
    {
        "raw_code": "def complete_investigation\n        InvestigationReport.new(\n          self, processed_source, @current_offenses || EMPTY_OFFENSES, @current_corrector\n        )\n      ensure\n        reset_investigation\n      end",
        "comment": "Called to complete an investigation",
        "label": "How-to-use",
        "id": "10273"
    },
    {
        "raw_code": "def saved_change_to_attribute?(attr_name, **options)\n        mutations_before_last_save.changed?(attr_name.to_s, **options)\n      end",
        "comment": "Did this attribute change when we last saved?  This method is useful in after callbacks to determine if an attribute was changed during the save that triggered the callbacks to run. It can be invoked as +saved_change_to_name?+ instead of <tt>saved_change_to_attribute?(\"name\")</tt>.  ==== Options  [+from+] When specified, this method will return false unless the original value is equal to the given value.  [+to+] When specified, this method will return false unless the value will be changed to the given value.",
        "label": "How-to-use",
        "id": "12839"
    },
    {
        "raw_code": "def generate_method_list\n  @items = prune_method_listing(Registry.all(:method), false)\n  @items = @items.reject {|m| m.name.to_s =~ /=$/ && m.is_attribute? }\n  @items = @items.sort_by {|m| m.name.to_s }\n  @list_title = \"Method List\"\n  @list_type = \"method\"\n  generate_list_contents\nend",
        "comment": "Generate a searchable method list in the output @see ModuleHelper#prune_method_listing",
        "label": "How-to-use",
        "id": "751"
    },
    {
        "raw_code": "def initialize(*args, **kwargs)\n        super\n\n        @redis = self.class.build_redis(redis: kwargs[:redis])\n      end",
        "comment": "The initialize calls retrieve_pool_options method: https://github.com/rails/rails/blob/v7.1.5.1/activesupport/lib/active_support/cache/redis_cache_store.rb#L149 In Rails 7.1 the method changed and now it always returns something  - https://github.com/rails/rails/blob/v7.0.8.7/activesupport/lib/active_support/cache.rb#L183 - https://github.com/rails/rails/blob/v7.1.5.1/activesupport/lib/active_support/cache.rb#L206  As a result, an unexpected connection pool is initialized. This path always initializes redis without a connection pool, the pool is initialized in a wrapper.",
        "label": "How-to-use",
        "id": "2911"
    },
    {
        "raw_code": "def cancel_auto_merge\n      body = 'canceled the automatic merge'\n\n      create_note(NoteSummary.new(noteable, project, author, body, action: 'merge'))\n    end",
        "comment": "Called when the auto merge is canceled",
        "label": "How-to-use",
        "id": "5634"
    },
    {
        "raw_code": "def klass\n        @klass ||= _klass(class_name)\n      end",
        "comment": "Returns the class for the macro.  <tt>composed_of :balance, class_name: 'Money'</tt> returns the Money class <tt>has_many :clients</tt> returns the Client class  class Company < ActiveRecord::Base has_many :clients end  Company.reflect_on_association(:clients).klass # => Client  <b>Note:</b> Do not call +klass.new+ or +klass.create+ to instantiate a new association object. Use +build_association+ or +create_association+ instead. This allows plugins to hook into association object creation.",
        "label": "How-to-use",
        "id": "12608"
    },
    {
        "raw_code": "def message_id(model)\n    model_name = model.class.model_name.singular_route_key\n    \"<#{model_name}_#{model.id}@#{Gitlab.config.gitlab.host}>\"\n  end",
        "comment": "Return a string suitable for inclusion in the 'Message-Id' mail header.  The message-id is generated from the unique URL to a model object.",
        "label": "How-to-use",
        "id": "6249"
    },
    {
        "raw_code": "def ci_partitioned_foreign_key?(foreign_key)\n    target = foreign_key.to_table.split('.').last\n    schema = Gitlab::Database::GitlabSchema.table_schema!(target)\n    schema == :gitlab_ci &&\n      Array.wrap(foreign_key.column).many? &&\n      foreign_key.column.first.end_with?('partition_id')\n  end",
        "comment": "For partitioned CI references we do not require a composite index starting with `partition_id` as each partition only contains records with a single `partition_id`. As such the index on the other id in the foreign key will be sufficient.",
        "label": "How-to-use",
        "id": "8273"
    },
    {
        "raw_code": "def remove_column(table_name, column_name, type = nil, **options)\n        return if options[:if_exists] == true && !column_exists?(table_name, column_name)\n\n        execute \"ALTER TABLE #{quote_table_name(table_name)} #{remove_column_for_alter(table_name, column_name, type, **options)}\"\n      end",
        "comment": "Removes the column from the table definition.  remove_column(:suppliers, :qualification)  The +type+ and +options+ parameters will be ignored if present. It can be helpful to provide these in a migration's +change+ method so it can be reverted. In that case, +type+ and +options+ will be used by #add_column. Depending on the database you're using, indexes using this column may be automatically removed or modified to remove this column from the index.  If the options provided include an +if_exists+ key, it will be used to check if the column does not exist. This will silently ignore the migration rather than raising if the column was already removed.  remove_column(:suppliers, :qualification, if_exists: true)",
        "label": "How-to-use",
        "id": "13150"
    },
    {
        "raw_code": "def register_preview_interceptors(*interceptors)\n        interceptors.flatten.compact.each { |interceptor| register_preview_interceptor(interceptor) }\n      end",
        "comment": "Register one or more Interceptors which will be called before mail is previewed.",
        "label": "How-to-use",
        "id": "11151"
    },
    {
        "raw_code": "def auth_providers\n        strong_memoize(:auth_providers) do\n          ::AuthenticationEvent.providers\n        end",
        "comment": "rubocop:enable CodeReuse/ActiveRecord rubocop:disable UsageData/LargeTable",
        "label": "How-to-use",
        "id": "1747"
    },
    {
        "raw_code": "def new_notes(notes_batch, notes_ids_map)\n            notes_batch.map do |note|\n              new_discussion_ids[note.discussion_id] ||= Note.new(\n                noteable_id: target_noteable.id,\n                noteable_type: target_noteable.class.base_class\n              ).discussion_id\n\n              note.attributes.tap do |attrs|\n                attrs['id'] = notes_ids_map[note.id]\n                attrs['noteable_id'] = target_noteable.id\n                # we want this if we want to use this also to copy notes when promoting issue to epic\n                attrs['noteable_type'] = target_noteable.class.base_class\n                attrs['discussion_id'] = new_discussion_ids[note.discussion_id]\n                # need to use `try` to be able to handle Issue model and legacy Epic model instances\n                attrs['project_id'] = target_noteable.try(:project_id)\n                attrs['namespace_id'] = target_noteable.try(:namespace_id) || target_noteable.try(:group_id)\n                attrs['imported_from'] = 'none' # maintaining current copy notes implementation\n\n                # this data is not changed, but it is being serialized, and we need it deserialized for bulk inserts\n                attrs['position'] = note.attributes_before_type_cast['position']\n                attrs['original_position'] = note.attributes_before_type_cast['original_position']\n                attrs['change_position'] = note.attributes_before_type_cast['change_position']\n                attrs['st_diff'] = note.attributes_before_type_cast['st_diff']\n                attrs['cached_markdown_version'] = note.cached_markdown_version\n\n                sanitized_note_params = sanitized_note_params(note)\n                attrs['note'] = sanitized_note_params['note']\n                attrs['note_html'] = sanitized_note_params['note_html']\n              end",
        "comment": "rubocop: disable Metrics/AbcSize -- Despite being long, this method is straightforward.",
        "label": "How-to-use",
        "id": "6023"
    },
    {
        "raw_code": "def configure(root_config)\n        end",
        "comment": "Called with the root configuration of the machine so the provisioner can add some configuration on top of the machine.  During this step, and this step only, the provisioner should modify the root machine configuration to add any additional features it may need. Examples include sharing folders, networking, and so on. This step is guaranteed to be called before any of those steps are done so the provisioner may do that.  No return value is expected.",
        "label": "How-to-use",
        "id": "9060"
    },
    {
        "raw_code": "def self.set_expectations_for_validation(validation, error_type, &block_that_sets_validation)\n    if error_type == :confirmation\n      attribute = :title_confirmation\n    else\n      attribute = :title\n    end",
        "comment": "To make things DRY this macro is created to define 3 tests for every validation case.",
        "label": "How-to-use",
        "id": "12337"
    },
    {
        "raw_code": "def usage_path\n          @usage_path = resolve_path(\"USAGE\") unless defined?(@usage_path)\n          @usage_path\n        end",
        "comment": "Path to lookup a USAGE description in a file.",
        "label": "How-to-use",
        "id": "14711"
    },
    {
        "raw_code": "def run(*args)\n        parse_arguments(*args)\n\n        if use_cache\n          Registry.load!\n        elsif parse\n          YARD.parse(files, excluded)\n          Registry.save(use_cache) if save_yardoc\n        end",
        "comment": "Runs the commandline utility, parsing arguments and generating output if set.  @param [Array<String>] args the list of arguments @return [void]",
        "label": "How-to-use",
        "id": "514"
    },
    {
        "raw_code": "def repair!\n      raise NotImplementedError\n    end",
        "comment": "When implemented by a subclass, will attempt to fix the issue automatically",
        "label": "How-to-use",
        "id": "3720"
    },
    {
        "raw_code": "def cfagent_extra_args\n        return \"\" if !@config.extra_agent_args\n        return \" #{@config.extra_agent_args}\"\n      end",
        "comment": "Extra arguments for calles to cf-agent.  @return [String]",
        "label": "How-to-use",
        "id": "9914"
    },
    {
        "raw_code": "def status_tooltip\n          label\n        end",
        "comment": "Hint that appears on all the pipeline graph tooltips and builds on the right sidebar in Job detail view",
        "label": "How-to-use",
        "id": "2549"
    },
    {
        "raw_code": "def symbolize_keys!\n      error_msg = \"Warning: Do not mutate #{self.class} objects: `#{__method__}`\"\n\n      log_and_raise_dev_exception(error_msg, method: __method__)\n\n      to_hash.deep_symbolize_keys\n    end",
        "comment": "Don't alter the internal keys",
        "label": "How-to-use",
        "id": "3523"
    },
    {
        "raw_code": "def will_save_change_to_attribute?(attr_name, **options)\n        mutations_from_database.changed?(attr_name.to_s, **options)\n      end",
        "comment": "Will this attribute change the next time we save?  This method is useful in validations and before callbacks to determine if the next call to +save+ will change a particular attribute. It can be invoked as +will_save_change_to_name?+ instead of <tt>will_save_change_to_attribute?(\"name\")</tt>.  ==== Options  [+from+] When specified, this method will return false unless the original value is equal to the given value.  [+to+] When specified, this method will return false unless the value will be changed to the given value.",
        "label": "How-to-use",
        "id": "12844"
    },
    {
        "raw_code": "def update_highest_role\n    return unless update_highest_role?\n\n    run_after_commit_or_now do\n      lease_key = \"update_highest_role:#{update_highest_role_attribute}\"\n      lease = Gitlab::ExclusiveLease.new(lease_key, timeout: HIGHEST_ROLE_LEASE_TIMEOUT)\n\n      if lease.try_obtain\n        UpdateHighestRoleWorker.perform_in(HIGHEST_ROLE_JOB_DELAY, update_highest_role_attribute)\n      else\n        # use same logging as ExclusiveLeaseGuard\n        Gitlab::AppLogger.error('Cannot obtain an exclusive lease. There must be another instance already in execution.')\n      end",
        "comment": "Schedule a Sidekiq job to update the highest role for a User  The job will be called outside of a transaction in order to ensure the changes to be committed before attempting to update the highest role. The exlusive lease will not be released after completion to prevent multiple jobs being executed during the defined timeout.",
        "label": "How-to-use",
        "id": "7324"
    },
    {
        "raw_code": "def link(target: nil)\n      render(Pajamas::ButtonComponent.new(\n        href: \"https://gitlab.com\",\n        target: target\n      )) do\n        \"This is a link\"\n      end",
        "comment": "The component can also be used to create links that look and feel like buttons. Just provide a `href` and optionally a `target` to create an `<a>` tag. For links with target=\"_blank\", the component automatically adds rel=\"noopener noreferrer\".  @param target select {{ Pajamas::ButtonComponent::TARGET_OPTIONS }}",
        "label": "How-to-use",
        "id": "8213"
    },
    {
        "raw_code": "def after_rollback(*args, &block)\n        set_options_for_callbacks!(args, prepend_option)\n        set_callback(:rollback, :after, *args, &block)\n      end",
        "comment": "This callback is called after a create, update, or destroy are rolled back.  Please check the documentation of #after_commit for options.",
        "label": "How-to-use",
        "id": "12725"
    },
    {
        "raw_code": "def diff_export\n    content = merge_request_diff.cached_external_diff do |file|\n      file.seek(external_diff_offset)\n\n      force_encode_utf8(file.read(external_diff_size))\n    end",
        "comment": "This method is meant to be used during Project Export. It is identical to the behavior in #diff with the only difference of caching externally stored diffs on local disk in temp storage location in order to improve diff export performance.",
        "label": "How-to-use",
        "id": "7009"
    },
    {
        "raw_code": "def deprecate(*method_names, deprecator:, **options)\n    if deprecator.is_a?(ActiveSupport::Deprecation)\n      deprecator.deprecate_methods(self, *method_names, **options)\n    elsif deprecator\n      # we just need any instance to call deprecate_methods, but the deprecation will be emitted by deprecator\n      ActiveSupport.deprecator.deprecate_methods(self, *method_names, **options, deprecator: deprecator)\n    end",
        "comment": "deprecate :foo, deprecator: MyLib.deprecator deprecate :foo, bar: \"warning!\", deprecator: MyLib.deprecator  A deprecator is typically an instance of ActiveSupport::Deprecation, but you can also pass any object that responds to <tt>deprecation_warning(deprecated_method_name, message, caller_backtrace)</tt> where you can implement your custom warning behavior.  class MyLib::Deprecator def deprecation_warning(deprecated_method_name, message, caller_backtrace = nil) message = \"#{deprecated_method_name} is deprecated and will be removed from MyLibrary | #{message}\" Kernel.warn message end end",
        "label": "How-to-use",
        "id": "14274"
    },
    {
        "raw_code": "def message\n        raise NotImplementedError\n      end",
        "comment": "NOTE: Make sure to call `#strip_markup` on any untrusted user input that's added to the string.",
        "label": "How-to-use",
        "id": "7653"
    },
    {
        "raw_code": "def self.add_shebang_option! # :doc:\n          class_option :ruby, type: :string, aliases: \"-r\", default: Thor::Util.ruby_command,\n                              desc: \"Path to the Ruby binary of your choice\", banner: \"PATH\"\n\n          no_tasks {\n            define_method :shebang do\n              @shebang ||= begin\n                command = if options[:ruby] == Thor::Util.ruby_command\n                  \"/usr/bin/env #{File.basename(Thor::Util.ruby_command)}\"\n                else\n                  options[:ruby]\n                end",
        "comment": "Small macro to add ruby as an option to the generator with proper default value plus an instance helper method called shebang.",
        "label": "How-to-use",
        "id": "14777"
    },
    {
        "raw_code": "def remove_internal_trailing_comma(node, corrector)\n          offset = internal_trailing_comma_offset_from_last_arg(node)\n          last_arg_end_pos = node.children.last.source_range.end_pos\n          corrector.remove(range_between(last_arg_end_pos, last_arg_end_pos + offset))\n        end",
        "comment": "Internal trailing comma helpers.",
        "label": "How-to-use",
        "id": "10359"
    },
    {
        "raw_code": "def input_optional_text(value)\n        format_help(\"(enter to #{value ? 'submit' : 'skip'})\")\n      end",
        "comment": "Help text to use with optional, multiline cli#ask prompts. Otherwise, prefer #prompt_for_text.",
        "label": "How-to-use",
        "id": "5338"
    },
    {
        "raw_code": "def initialize(precision: nil, limit: nil, scale: nil)\n        super()\n        @precision = precision\n        @scale = scale\n        @limit = limit\n      end",
        "comment": "Initializes a type with three basic configuration settings: precision, limit, and scale. The Value base class does not define behavior for these settings. It uses them for equality comparison and hash key generation only.",
        "label": "How-to-use",
        "id": "12291"
    },
    {
        "raw_code": "def deliver_mail(mail) # :nodoc:\n        ActiveSupport::Notifications.instrument(\"deliver.action_mailer\") do |payload|\n          set_payload_for_mail(payload, mail)\n          yield # Let Mail do the delivery actions\n        end",
        "comment": "Wraps an email delivery inside of ActiveSupport::Notifications instrumentation.  This method is actually called by the +Mail::Message+ object itself through a callback when you call <tt>:deliver</tt> on the +Mail::Message+, calling +deliver_mail+ directly and passing a +Mail::Message+ will do nothing except tell the logger you sent the email.",
        "label": "How-to-use",
        "id": "11116"
    },
    {
        "raw_code": "def quote_column_name(name) # :nodoc:\n            QUOTED_COLUMN_NAMES[name] ||= PG::Connection.quote_ident(name.to_s).freeze\n          end",
        "comment": "Quotes column names for use in SQL queries.",
        "label": "How-to-use",
        "id": "13214"
    },
    {
        "raw_code": "def env_config\n      @env_config ||= {}\n    end",
        "comment": "Defines additional Rack env configuration that is added on each call.",
        "label": "How-to-use",
        "id": "14667"
    },
    {
        "raw_code": "def on_complete\n      end",
        "comment": "A hook to override that will be called when the job finished iterating. ",
        "label": "How-to-use",
        "id": "5228"
    },
    {
        "raw_code": "def self.add(key, &block)\n      define_method(_render_with_renderer_method_name(key), &block)\n      RENDERERS << key.to_sym\n    end",
        "comment": "Adds a new renderer to call within controller actions. A renderer is invoked by passing its name as an option to AbstractController::Rendering#render. To create a renderer pass it a name and a block. The block takes two arguments, the first is the value paired with its key and the second is the remaining hash of options passed to `render`.  Create a csv renderer:  ActionController::Renderers.add :csv do |obj, options| filename = options[:filename] || 'data' str = obj.respond_to?(:to_csv) ? obj.to_csv : obj.to_s send_data str, type: Mime[:csv], disposition: \"attachment; filename=#{filename}.csv\" end  Note that we used [Mime](:csv) for the csv mime type as it comes with Rails. For a custom renderer, you'll need to register a mime type with `Mime::Type.register`.  To use the csv renderer in a controller action:  def show @csvable = Csvable.find(params[:id]) respond_to do |format| format.html format.csv { render csv: @csvable, filename: @csvable.name } end end",
        "label": "How-to-use",
        "id": "11321"
    },
    {
        "raw_code": "def _prepare_context\n      @view_flow     = OutputFlow.new\n      @output_buffer = ActionView::OutputBuffer.new\n      @virtual_path  = nil\n    end",
        "comment": "Prepares the context by setting the appropriate instance variables.",
        "label": "How-to-use",
        "id": "11713"
    },
    {
        "raw_code": "def restrict_within_concurrent_ruby\n      previous = Thread.current[:restrict_within_concurrent_ruby]\n      Thread.current[:restrict_within_concurrent_ruby] = true\n\n      yield\n    ensure\n      Thread.current[:restrict_within_concurrent_ruby] = previous\n    end",
        "comment": "Use this method to set the `restrict_within_concurrent_ruby` to `true` for the block. `raise_if_concurrent_ruby!` will use this flag to raise an error if it's set to `true`.",
        "label": "How-to-use",
        "id": "1221"
    },
    {
        "raw_code": "def current_home_dir\n      GPGME::Engine.info.first.home_dir || GPGME::Engine.dirinfo('homedir')\n    end",
        "comment": "1. Returns the custom home directory if one has been set by calling `GPGME::Engine.home_dir=` 2. Returns the default home directory otherwise",
        "label": "How-to-use",
        "id": "1717"
    },
    {
        "raw_code": "def _initialize(name, machine)\n          initialize_capabilities!(\n            name.to_sym,\n            { name.to_sym => [Class.new, nil] },\n            Vagrant.plugin(\"2\").manager.provider_capabilities,\n            machine,\n          )\n        end",
        "comment": "This is an internal initialize function that should never be overridden. It is used to initialize some common internal state that is used in a provider.",
        "label": "How-to-use",
        "id": "9058"
    },
    {
        "raw_code": "def from_tar_entry(entry, magic: Magic.open(Magic::MIME))\n      attrs = {\n        size: entry.size,\n        path: entry.full_name,\n        file_mode: entry.header.mode.to_fs(8)\n      }\n\n      if entry.size > SIZE_LIMIT\n        mime = magic.buffer(entry.read(BYTES_FOR_MAGIC_DETECTION))\n        return new(mime:, **attrs)\n      end",
        "comment": "Passing in an existing Magic instance is very important for memory usage. Magic.open(Magic::MIME) opens a new instance for each call and they are very memory heavy.",
        "label": "How-to-use",
        "id": "10003"
    },
    {
        "raw_code": "def format_subheader(subject, item, count = 1, total = 1)\n        formatting_end = \"\\e[0m\"\n        suffix = formatting_end if subject[-formatting_end.length..] == formatting_end\n\n        \"-- #{[subject.chomp(formatting_end), counter(count, total)].compact.join(' ')}:#{suffix} #{item} --\"\n      end",
        "comment": "Used for grouping prompts that occur on the same screen or as part of the same step of a flow.  Counter is exluded if total is 1. The subject's formatting is extended to the counter.  @return [String] ex) -- EATING COOKIES (2/3): Chocolate Chip -- @param subject [String] describes task generically ex) EATING COOKIES @param item [String] describes specific context ex) Chocolate Chip @param count [Integer] ex) 2 @param total [Integer] ex) 3",
        "label": "How-to-use",
        "id": "5350"
    },
    {
        "raw_code": "def init_with_attributes(attributes, new_record = false) # :nodoc:\n      @new_record = new_record\n      @attributes = attributes\n\n      init_internals\n\n      yield self if block_given?\n\n      _run_find_callbacks\n      _run_initialize_callbacks\n\n      self\n    end",
        "comment": " Initialize an empty model object from +attributes+. +attributes+ should be an attributes object, and unlike the `initialize` method, no assignment calls are made per attribute.",
        "label": "How-to-use",
        "id": "12426"
    },
    {
        "raw_code": "def inner_parse text # :nodoc:\n    parser = clone\n\n    parser.setup_parser text, @debug\n\n    parser.peg_parse\n\n    doc = parser.result\n\n    doc.accept @formatter\n\n    doc.parts\n  end",
        "comment": " Parses `text` in a clone of this parser.  This is used for handling nested lists the same way as markdown_parser.",
        "label": "How-to-use",
        "id": "15578"
    },
    {
        "raw_code": "def print_event_filter_header(event, idx, total)\n        cli.say \"\\n\"\n        cli.say format_info(format_subheader('SETTING EVENT FILTERS', event.action, idx, total))\n\n        return unless event.additional_properties&.any?\n\n        event_filter_options = event.additional_properties.map do |property, attrs|\n          \"  #{property}: #{attrs['description']}\\n\"\n        end",
        "comment": "Helper for #prompt_for_event_filters",
        "label": "How-to-use",
        "id": "5320"
    },
    {
        "raw_code": "def around_enqueue(*filters, &blk)\n        set_callback(:enqueue, :around, *filters, &blk)\n      end",
        "comment": "Defines a callback that will get called around the enqueuing of the job.  class VideoProcessJob < ActiveJob::Base queue_as :default  around_enqueue do |job, block| $statsd.time \"video-job.process\" do block.call end end  def perform(video_id) Video.find(video_id).process end end ",
        "label": "How-to-use",
        "id": "12110"
    },
    {
        "raw_code": "def cleanup\n        end",
        "comment": "This is the method called to when the system is being destroyed and allows the provisioners to engage in any cleanup tasks necessary.",
        "label": "How-to-use",
        "id": "8980"
    },
    {
        "raw_code": "def nested_records_changed_for_autosave?\n        @_nested_records_changed_for_autosave_already_called ||= false\n        return false if @_nested_records_changed_for_autosave_already_called\n        begin\n          @_nested_records_changed_for_autosave_already_called = true\n          self.class._reflections.values.any? do |reflection|\n            if reflection.options[:autosave]\n              association = association_instance_get(reflection.name)\n              association && Array.wrap(association.target).any?(&:changed_for_autosave?)\n            end",
        "comment": "Go through nested autosave associations that are loaded in memory (without loading any new ones), and return true if any are changed for autosave. Returns false if already called to prevent an infinite loop.",
        "label": "How-to-use",
        "id": "12384"
    },
    {
        "raw_code": "def process(method, path, params: nil, headers: nil, env: nil, xhr: false, as: nil)\n        request_encoder = RequestEncoder.encoder(as)\n        headers ||= {}\n\n        if method == :get && as == :json && params\n          headers[\"X-Http-Method-Override\"] = \"GET\"\n          method = :post\n        end",
        "comment": "Performs the actual request.  *   `method`: The HTTP method (GET, POST, PATCH, PUT, DELETE, HEAD, OPTIONS) as a symbol. *   `path`: The URI (as a String) on which you want to perform the request. *   `params`: The HTTP parameters that you want to pass. This may be `nil`, a Hash, or a String that is appropriately encoded (`application/x-www-form-urlencoded` or `multipart/form-data`). *   `headers`: Additional headers to pass, as a Hash. The headers will be merged into the Rack env hash. *   `env`: Additional env to pass, as a Hash. The headers will be merged into the Rack env hash. *   `xhr`: Set to `true` if you want to make an Ajax request. Adds request headers characteristic of XMLHttpRequest e.g. HTTP_X_REQUESTED_WITH. The headers will be merged into the Rack env hash. *   `as`: Used for encoding the request with different content type. Supports `:json` by default and will set the appropriate request headers. The headers will be merged into the Rack env hash.   This method is rarely used directly. Use RequestHelpers#get, RequestHelpers#post, or other standard HTTP methods in integration tests. `#process` is only required when using a request method that doesn't have a method defined in the integration tests.  This method returns the response status, after performing the request. Furthermore, if this method was called from an ActionDispatch::IntegrationTest object, then that object's `@response` instance variable will point to a Response object which one can use to inspect the details of the response.  Example: process :get, '/author', params: { since: 201501011400 }",
        "label": "How-to-use",
        "id": "11627"
    },
    {
        "raw_code": "def execute_assignment\n      super if ::Feature.enabled?(feature_flag_name, self, type: :experiment)\n    end",
        "comment": "For assignment we first check to see if our feature flag is enabled for \"self\". This is done by calling `#flipper_id` (used behind the scenes by `Feature`). By default this is our `experiment.id` (or more specifically, the context key, which is an anonymous SHA generated using the details of an experiment.  If the `Feature.enabled?` check is false, we return nil implicitly, which will assign the control. Otherwise we call super, which will assign a variant based on our provided distribution rules. Otherwise we will assign a variant evenly across the behaviours without control.",
        "label": "How-to-use",
        "id": "1722"
    },
    {
        "raw_code": "def self.action_start\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use ConfigValidate\n          b.use BoxCheckOutdated\n          b.use Call, IsRunning do |env, b2|\n            # If the VM is running, run the necessary provisioners\n            if env[:result]\n              b2.use action_provision\n              next\n            end",
        "comment": "This action starts a VM, assuming it is already imported and exists. A precondition of this action is that the VM exists.",
        "label": "How-to-use",
        "id": "9543"
    },
    {
        "raw_code": "def subject(*extra)\n    subject = []\n\n    subject << @project.name if @project\n    subject << @group.name if @group\n    subject << @namespace.name if @namespace && !@project\n    subject.concat(extra) if extra.present?\n\n    EmailsHelper.subject_with_prefix_and_suffix(subject)\n  end",
        "comment": "Formats arguments into a String suitable for use as an email subject  extra - Extra Strings to be inserted into the subject  Examples  >> subject('Lorem ipsum') => \"Lorem ipsum\"  # Automatically inserts Project name when @project is set >> @project = Project.last => #<Project id: 1, name: \"Ruby on Rails\", path: \"ruby_on_rails\", ...> >> subject('Lorem ipsum') => \"Ruby on Rails | Lorem ipsum \"  # Accepts multiple arguments >> subject('Lorem ipsum', 'Dolor sit amet') => \"Lorem ipsum | Dolor sit amet\"",
        "label": "How-to-use",
        "id": "6245"
    },
    {
        "raw_code": "def scope_for_policy_class(policy_class = nil)\n    return if policy_class.blank?\n\n    return unless policy_class.present? && defined?(Admin.const_get(policy_class.to_s)&.const_get(\"Scope\"))\n    policy_class::Scope\n  end",
        "comment": "Fetches the scope for a given policy",
        "label": "How-to-use",
        "id": "10018"
    },
    {
        "raw_code": "def update_latest_released_at!\n        update!(latest_released_at: versions.latest&.released_at)\n      end",
        "comment": "Triggered in Ci::Catalog::Resources::Version and Release model callbacks",
        "label": "How-to-use",
        "id": "7596"
    },
    {
        "raw_code": "def initialize_documents!(ref, content_method, content_field)\n          return unless content_method && ref.respond_to?(content_method)\n\n          ref.documents << {} if ref.documents.empty?\n\n          ref.documents.each do |doc|\n            next if doc.key?(content_field)\n\n            doc[content_field] = ref.send(content_method) # rubocop: disable GitlabSecurity/PublicSend -- method is defined elsewhere\n          end",
        "comment": "Initializes the documents for a reference if they don't exist and populates the content field if a content_method is provided",
        "label": "How-to-use",
        "id": "1163"
    },
    {
        "raw_code": "def render(*args)\n          render_with(:render, *args)\n        end",
        "comment": "Render a given template and return the result. This method optionally takes a block which will be passed the renderer prior to rendering, which allows the caller to set any view variables within the renderer itself.  @return [String] Rendered template",
        "label": "How-to-use",
        "id": "9153"
    },
    {
        "raw_code": "def password_digest(password)\n        remove_instance_variable('@split_encrypted_password') if defined?(@split_encrypted_password)\n\n        encryptor_class.digest(password, encryptor_class::STRETCHES, Devise.friendly_token[0, 16])\n      end",
        "comment": "Used by Devise DatabaseAuthenticatable when setting a password",
        "label": "How-to-use",
        "id": "5242"
    },
    {
        "raw_code": "def to_query(key)\n    \"#{CGI.escape(key.to_param)}=#{CGI.escape(to_param.to_s)}\"\n  end",
        "comment": "Converts an object into a string suitable for use as a URL query string, using the given <tt>key</tt> as the param name.",
        "label": "How-to-use",
        "id": "14324"
    },
    {
        "raw_code": "def build_through_record(record)\n          @through_records[record] ||= begin\n            ensure_mutable\n\n            attributes = through_scope_attributes\n            attributes[source_reflection.name] = record\n\n            through_association.build(attributes).tap do |new_record|\n              new_record.send(\"#{source_reflection.foreign_type}=\", options[:source_type]) if options[:source_type]\n            end",
        "comment": "The through record (built with build_record) is temporarily cached so that it may be reused if insert_record is subsequently called.  However, after insert_record has been called, the cache is cleared in order to allow multiple instances of the same record in an association.",
        "label": "How-to-use",
        "id": "12809"
    },
    {
        "raw_code": "def remove_column_default(table_name, column_name)\n        column = connection.columns(table_name).find { |col| col.name == column_name.to_s }\n\n        if column.default || column.default_function\n          change_column_default(table_name, column_name, to: nil)\n        end",
        "comment": "While it is safe to call `change_column_default` on a column without default it would still require access exclusive lock on the table and for tables with high autovacuum(wraparound prevention) it will fail if their executions overlap. ",
        "label": "How-to-use",
        "id": "3008"
    },
    {
        "raw_code": "def resumes_work_when_interrupted!\n        sidekiq_options max_retries_after_interruption: MAX_RETRIES_AFTER_INTERRUPTION\n      end",
        "comment": "We can increase the number of times a worker is retried after being interrupted if the importer it executes can restart exactly from where it left off.  It is not safe to call this method if the importer loops over its data from the beginning when restarted, even if it skips data that is already imported inside the loop, as there is a possibility the importer will never reach the end of the loop.  Examples of stage workers that call this method are ones that execute services that:  - Continue paging an endpoint from where it left off: https://gitlab.com/gitlab-org/gitlab/-/blob/487521cc/lib/gitlab/github_import/parallel_scheduling.rb#L114-117 - Continue their loop from where it left off: https://gitlab.com/gitlab-org/gitlab/-/blob/024235ec/lib/gitlab/github_import/importer/pull_requests/review_requests_importer.rb#L15",
        "label": "How-to-use",
        "id": "3734"
    },
    {
        "raw_code": "def to_param\n    iid.to_s\n  end",
        "comment": " This automagically enforces all related routes to use `iid` instead of `id` If you want to use `iid` for some routes and `id` for other routes, this module should not to be included, instead you should define `iid` or `id` explicitly at each route generators. e.g. pipeline_path(project.id, pipeline.iid)",
        "label": "How-to-use",
        "id": "7340"
    },
    {
        "raw_code": "def after_deliver(*filters, &blk)\n        set_callback(:deliver, :after, *filters, &blk)\n      end",
        "comment": "Defines a callback that will get called right after the message's delivery method is finished.",
        "label": "How-to-use",
        "id": "11124"
    },
    {
        "raw_code": "def action_raw(name, callable, extra_env={})\n      if !extra_env.is_a?(Hash)\n        extra_env = {}\n      end",
        "comment": "This calls a raw callable in the proper context of the machine using the middleware stack.  @param [Symbol] name Name of the action @param [Proc] callable @param [Hash] extra_env Extra env for the action env. @return [Hash] The resulting env",
        "label": "How-to-use",
        "id": "8779"
    },
    {
        "raw_code": "def initialize(secret, sign_secret = nil, **options)\n      super(**options)\n      @secret = secret\n      @cipher = options[:cipher] || self.class.default_cipher\n      @aead_mode = new_cipher.authenticated?\n      @verifier = if !@aead_mode\n        MessageVerifier.new(sign_secret || secret, **options, serializer: NullSerializer)\n      end",
        "comment": "Initialize a new MessageEncryptor. +secret+ must be at least as long as the cipher key size. For the default 'aes-256-gcm' cipher, this is 256 bits. If you are using a user-entered secret, you can generate a suitable key by using ActiveSupport::KeyGenerator or a similar key derivation function.  The first additional parameter is used as the signature key for MessageVerifier. This allows you to specify keys to encrypt and sign data. Ignored when using an AEAD cipher like 'aes-256-gcm'.  ActiveSupport::MessageEncryptor.new('secret', 'signature_secret')  ==== Options  [+:cipher+] Cipher to use. Can be any cipher returned by +OpenSSL::Cipher.ciphers+. Default is 'aes-256-gcm'.  [+:digest+] Digest used for signing. Ignored when using an AEAD cipher like 'aes-256-gcm'.  [+:serializer+] The serializer used to serialize message data. You can specify any object that responds to +dump+ and +load+, or you can choose from several preconfigured serializers: +:marshal+, +:json_allow_marshal+, +:json+, +:message_pack_allow_marshal+, +:message_pack+.  The preconfigured serializers include a fallback mechanism to support multiple deserialization formats. For example, the +:marshal+ serializer will serialize using +Marshal+, but can deserialize using +Marshal+, ActiveSupport::JSON, or ActiveSupport::MessagePack. This makes it easy to migrate between serializers.  The +:marshal+, +:json_allow_marshal+, and +:message_pack_allow_marshal+ serializers support deserializing using +Marshal+, but the others do not. Beware that +Marshal+ is a potential vector for deserialization attacks in cases where a message signing secret has been leaked. <em>If possible, choose a serializer that does not support +Marshal+.</em>  The +:message_pack+ and +:message_pack_allow_marshal+ serializers use ActiveSupport::MessagePack, which can roundtrip some Ruby types that are not supported by JSON, and may provide improved performance. However, these require the +msgpack+ gem.  When using \\Rails, the default depends on +config.active_support.message_serializer+. Otherwise, the default is +:marshal+.  [+:url_safe+] By default, MessageEncryptor generates RFC 4648 compliant strings which are not URL-safe. In other words, they can contain \"+\" and \"/\". If you want to generate URL-safe strings (in compliance with \"Base 64 Encoding with URL and Filename Safe Alphabet\" in RFC 4648), you can pass +true+.  [+:force_legacy_metadata_serializer+] Whether to use the legacy metadata serializer, which serializes the message first, then wraps it in an envelope which is also serialized. This was the default in \\Rails 7.0 and below.  If you don't pass a truthy value, the default is set using +config.active_support.use_message_serializer_for_metadata+.",
        "label": "How-to-use",
        "id": "13904"
    },
    {
        "raw_code": "def format(key, value)\n          \"#{key}:#{value}\"\n        end",
        "comment": "Formats the key value pairs into a string.",
        "label": "How-to-use",
        "id": "12593"
    },
    {
        "raw_code": "def self.sign(cert:, key:, data:, ca_certs: nil)\n          signed_data = OpenSSL::PKCS7.sign(cert, key, data, Array.wrap(ca_certs), OpenSSL::PKCS7::DETACHED)\n          OpenSSL::PKCS7.write_smime(signed_data)\n        end",
        "comment": "The `ca_certs` parameter, if provided, is an array of CA certificates that will be attached in the signature together with the main `cert`. This will be typically intermediate CAs",
        "label": "How-to-use",
        "id": "3255"
    },
    {
        "raw_code": "def format_message(type, message, **opts)\n        # Get the format of the message before adding color.\n        message = super\n\n        opts = @opts.merge(opts)\n\n        # Special case some colors for certain message types\n        opts[:color] = :red if type == :error\n        opts[:color] = :green if type == :success\n        opts[:color] = :yellow if type == :warn\n\n        # If it is a detail, it is not bold. Every other message type\n        # is bolded.\n        bold  = !!opts[:bold]\n        colorseq = \"#{bold ? 1 : 0 }\"\n        if opts[:color] && opts[:color] != :default\n          color = COLORS[opts[:color]]\n          colorseq += \";#{color}\"\n        end",
        "comment": "This is called by `say` to format the message for output.",
        "label": "How-to-use",
        "id": "8811"
    },
    {
        "raw_code": "def process_decorator(*nodes, &block)\n    opts = nodes.last.is_a?(Hash) ? nodes.pop : {}\n\n    all_nodes = statement.parameters.select do |p|\n      p.is_a? YARD::Parser::Ruby::AstNode\n    end",
        "comment": "@overload process_decorator(*nodes, opts = {}, &block) Takes care of parsing method definitions passed to decorators as parameters, as well as parsing chained decorators.  Use this in a handler's process block.  @yieldparam method [YARD::CodeObjects::MethodObject] Method being decorated. @yieldparam node [YARD::Parser::Ruby::AstNode] AST node of the decorated method. @yieldparam name [Symbol] Name of the decorated method. @return [Array<Hash>] Array of hashes containing :method, :node, :name. See yield params.  @param nodes [YARD::Parser::Ruby::AstNode] AST nodes that refer to decorated methods, like indexes of statement.parameter. Defaults to all parameters. Pass nil to specify zero parameters.  @option opts [:instance, :class] :scope (:instance) Scope to use for each MethodObject.  @option opts [true, false] :transfer_docstring Set false to disable transferring the decorator docstring to method definitions passed to the decorator as parameters.  @option opts [true, false] :transfer_source Set false to disable transferring the decorator source code string to method definitions passed to the decorator as parameters.  @example Basic Usage # Simply pass the method docs through to the method definition. process do process_decorator end  @example Setting a method's visibility to private. process do process_decorator :scope => :class do |method| method.visibility = :private if method.respond_to? :visibility end end",
        "label": "How-to-use",
        "id": "208"
    },
    {
        "raw_code": "def build_matcher\n    @key_paths.reduce(nil) do |matcher, key_path|\n      metric_definition = get_metric_definition(key_path)\n      value_tracker = metric_value_tracker(key_path, metric_definition)\n      change_matcher = yield(value_tracker)\n      chained_matcher = apply_chain_methods(change_matcher, @chained_methods)\n\n      matcher ? matcher.and(chained_matcher) : chained_matcher\n    end",
        "comment": "Builds a single change matcher for verifying all provided metric values, including chained expected counts",
        "label": "How-to-use",
        "id": "8348"
    },
    {
        "raw_code": "def register_observer(observer)\n        Mail.register_observer(observer_class_for(observer))\n      end",
        "comment": "Register an Observer which will be notified when mail is delivered. Either a class, string, or symbol can be passed in as the Observer. If a string or symbol is passed in it will be camelized and constantized.",
        "label": "How-to-use",
        "id": "11110"
    },
    {
        "raw_code": "def help\n            opts = OptionParser.new do |opts|\n              opts.banner = \"Usage: vagrant cloud auth <subcommand> [<args>]\"\n              opts.separator \"\"\n              opts.separator \"Authorization with Vagrant Cloud\"\n              opts.separator \"\"\n              opts.separator \"Available subcommands:\"\n\n              # Add the available subcommands as separators in order to print them\n              # out as well.\n              keys = []\n              @subcommands.each { |key, value| keys << key.to_s }\n\n              keys.sort.each do |key|\n                opts.separator \"     #{key}\"\n              end",
        "comment": "Prints the help out for this command",
        "label": "How-to-use",
        "id": "9766"
    },
    {
        "raw_code": "def cancel_auto_merge(noteable, project, author)\n    ::SystemNotes::MergeRequestsService.new(noteable: noteable, container: project, author: author).cancel_auto_merge\n  end",
        "comment": "Called when 'auto merge' is canceled",
        "label": "How-to-use",
        "id": "5508"
    },
    {
        "raw_code": "def initialize; end\n\n        # Don't implement other required methods\n        def client_klass; end\n        def indexer_klass; end\n      end\n\n      adapter = test_class.new\n      expect { adapter.executor_klass }.to raise_error(NotImplementedError)\n    end\n  end",
        "comment": "Override initialize so it doesn't try to call the methods we're testing",
        "label": "How-to-use",
        "id": "1166"
    },
    {
        "raw_code": "def get_spec_file\n      caller.find do |line|\n        match = line.match(%r{^(.+_spec\\.rb|.+/frontend/fixtures/.+\\.rb):\\d+:in})\n        match[1] if match\n      end",
        "comment": "Determine the spec filename from the current backtrace.",
        "label": "How-to-use",
        "id": "8477"
    },
    {
        "raw_code": "def help\n          opts = OptionParser.new do |o|\n            o.banner = \"Usage: vagrant plugin <command> [<args>]\"\n            o.separator \"\"\n            o.separator \"Available subcommands:\"\n\n            # Add the available subcommands as separators in order to print them\n            # out as well.\n            keys = []\n            @subcommands.each { |key, value| keys << key.to_s }\n\n            keys.sort.each do |key|\n              o.separator \"     #{key}\"\n            end",
        "comment": "Prints the help out for this command",
        "label": "How-to-use",
        "id": "9803"
    },
    {
        "raw_code": "def configure_connection\n          super\n\n          if @config[:encoding]\n            @raw_connection.set_client_encoding(@config[:encoding])\n          end",
        "comment": "Configures the encoding, verbosity, schema search path, and time zone of the connection. This is called by #connect and should not be called manually.",
        "label": "How-to-use",
        "id": "12983"
    },
    {
        "raw_code": "def console(&blk)\n      self.class.console(&blk)\n    end",
        "comment": "Sends any console called in the instance of a new application up to the +console+ method defined in Rails::Railtie.",
        "label": "How-to-use",
        "id": "14639"
    },
    {
        "raw_code": "def remove_branch_with_hooks(project, user, branch)\n      params = {\n        change: {\n          oldrev: project.commit(branch).id,\n          newrev: Gitlab::Git::SHA1_BLANK_SHA,\n          ref: \"refs/heads/#{branch}\"\n        }\n      }\n\n      yield\n\n      Git::BranchPushService.new(project, user, params).execute\n    end",
        "comment": " This is a workaround for problem described in #24543 ",
        "label": "How-to-use",
        "id": "8269"
    },
    {
        "raw_code": "def build_filter_text(pipeline, initial_text)\n    filter_source = {}\n    input_text    = initial_text\n    result        = nil\n\n    pipeline.filters.each do |filter_klass|\n      # store inputs for current filter_klass\n      filter_source[filter_klass] = { input_text: input_text, input_result: result }\n\n      filter = filter_klass.new(input_text, context, result)\n      output = filter.call\n\n      # save these for the next filter_klass\n      input_text = output\n      result = filter.result\n    end",
        "comment": "build up the source text for each filter",
        "label": "How-to-use",
        "id": "8299"
    },
    {
        "raw_code": "def track_unique_action(name, args:, user:, project:)\n          return unless user\n\n          args ||= ''\n          name = prepare_name(name, args)\n\n          if INTERNAL_EVENTS.include?(name)\n            Gitlab::InternalEvents.track_event(\n              \"i_quickactions_#{name}\",\n              user: user,\n              project: project,\n              additional_properties: prepare_additional_properties(name, args)\n            )\n          else\n            # Legacy event implementation. Migrate existing events to internal events.\n            # See implementation of `convert_to_ticket` quickaction and\n            # https://docs.gitlab.com/ee/development/internal_analytics/internal_event_instrumentation/migration.html#backend-1\n            Gitlab::UsageDataCounters::HLLRedisCounter.track_event(:\"i_quickactions_#{name}\", values: user.id)\n          end",
        "comment": "Tracks the quick action with name `name`. `args` is expected to be a single string, will be split internally when necessary.",
        "label": "How-to-use",
        "id": "2678"
    },
    {
        "raw_code": "def self.exclude_from_registry\n        Registry.global.dismiss(self)\n      end",
        "comment": "Call for abstract Cop classes",
        "label": "How-to-use",
        "id": "10249"
    },
    {
        "raw_code": "def prepare_folders_config(config)\n          # Make sure the path is an array\n          config = [config] if !config.is_a?(Array) || config.first.is_a?(Symbol)\n\n          return [] if config.flatten.compact.empty?\n\n          # Make sure all the paths are in the proper format\n          config.map do |path|\n            path = [:host, File.expand_path(path)] if !path.is_a?(Array)\n            path\n          end",
        "comment": "This takes any of the configurations that take a path or array of paths and turns it into the proper format.  @return [Array]",
        "label": "How-to-use",
        "id": "9911"
    },
    {
        "raw_code": "def save_synced_folders(machine, folders, opts={})\n          if opts[:merge]\n            existing = cached_synced_folders(machine)\n            if existing\n              if opts[:vagrantfile]\n                # Go through and find any cached that were from the\n                # Vagrantfile itself. We remove those if it was requested.\n                existing.each do |impl, fs|\n                  fs.each do |id, data|\n                    fs.delete(id) if data[:__vagrantfile]\n                  end",
        "comment": "This saves the synced folders data to the machine data directory. They can then be retrieved again with `synced_folders` by passing the `cached` option to it.  @param [Machine] machine The machine that the folders belong to @param [Hash] folders The result from a {#synced_folders} call.",
        "label": "How-to-use",
        "id": "9330"
    },
    {
        "raw_code": "def data_fields_foreign_key\n        integration.data_fields.class.reflections['integration'].foreign_key\n      end",
        "comment": "service_id or integration_id",
        "label": "How-to-use",
        "id": "5969"
    },
    {
        "raw_code": "def release(entry)\n      @lock.synchronize do\n        unlocked_release(entry.id)\n      end",
        "comment": "Releases an entry, unlocking it.  This is an idempotent operation. It is safe to call this even if you're unsure if an entry is locked or not.  After calling this, the previous entry should no longer be used.  @param [Entry] entry",
        "label": "How-to-use",
        "id": "8758"
    },
    {
        "raw_code": "def expect_vue_tokens(tokens)\n    page.within '.gl-search-box-by-click .gl-filtered-search-scrollable' do\n      token_elements = page.all(:css, '.gl-filtered-search-token')\n\n      tokens.each_with_index do |token, index|\n        el = token_elements[index]\n\n        expect(el.find('.gl-filtered-search-token-type')).to have_content(token[:name])\n        expect(el.find('.gl-filtered-search-token-operator')).to have_content(token[:operator]) if token[:operator].present?\n        expect(el.find('.gl-filtered-search-token-data')).to have_content(token[:value]) if token[:value].present?\n\n        # gl-emoji content is blank when the emoji unicode is not supported\n        if token[:emoji_name].present?\n          selector = %(gl-emoji[data-name=\"#{token[:emoji_name]}\"])\n          expect(el.find('.gl-filtered-search-token-data-content')).to have_css(selector)\n        end",
        "comment": "Same as `expect_tokens` but works with GlFilteredSearch",
        "label": "How-to-use",
        "id": "8455"
    },
    {
        "raw_code": "def statistics\n        response = get(request_url(\"#{api_get_path}?statistics=true\"))\n        data = parse_body(response)\n\n        raise \"Could not get project usage statistics\" unless data.key?(:statistics)\n\n        data[:statistics]\n      end",
        "comment": "Gets project statistics.  @return [Hash] the project usage data including repository size.",
        "label": "How-to-use",
        "id": "4107"
    },
    {
        "raw_code": "def travel(duration, with_usec: false, &block)\n        travel_to Time.now + duration, with_usec: with_usec, &block\n      end",
        "comment": "Changes current time to the time in the future or in the past by a given time difference by stubbing +Time.now+, +Date.today+, and +DateTime.now+. The stubs are automatically removed at the end of the test.  Note that the usec for the resulting time will be set to 0 to prevent rounding errors with external services, like MySQL (which will round instead of floor, leading to off-by-one-second errors), unless the <tt>with_usec</tt> argument is set to <tt>true</tt>.  Time.current     # => Sat, 09 Nov 2013 15:34:49 EST -05:00 travel 1.day Time.current     # => Sun, 10 Nov 2013 15:34:49 EST -05:00 Date.current     # => Sun, 10 Nov 2013 DateTime.current # => Sun, 10 Nov 2013 15:34:49 -0500  This method also accepts a block, which will return the current time back to its original state at the end of the block:  Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00 travel 1.day do User.create.created_at # => Sun, 10 Nov 2013 15:34:49 EST -05:00 end Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00",
        "label": "How-to-use",
        "id": "14550"
    },
    {
        "raw_code": "def cache(&block)\n        pool.enable_query_cache(&block)\n      end",
        "comment": "Enable the query cache within the block.",
        "label": "How-to-use",
        "id": "13081"
    },
    {
        "raw_code": "def strong_memoize_with_expiration(name, expire_in)\n        key = ivar(name)\n        expiration_key = \"#{key}_expired_at\"\n\n        if instance_variable_defined?(expiration_key)\n          expire_at = instance_variable_get(expiration_key)\n          clear_memoization(name) if expire_at.past?\n        end",
        "comment": "Works the same way as \"strong_memoize\" but takes a second argument - expire_in. This allows invalidate the data after specified number of seconds",
        "label": "How-to-use",
        "id": "1237"
    },
    {
        "raw_code": "def global_notification_setting\n    return @global_notification_setting if defined?(@global_notification_setting)\n\n    # lookup in preloaded notification settings first, before making another query\n    if notification_settings.loaded?\n      @global_notification_setting = notification_settings.find do |notification|\n        notification.source_id.nil? && notification.source_type.nil?\n      end",
        "comment": "Lazy load global notification setting Initializes User setting with Participating level if setting not persisted",
        "label": "How-to-use",
        "id": "7094"
    },
    {
        "raw_code": "def on_new_investigation\n        investigate(processed_source) if respond_to?(:investigate)\n        super\n      end",
        "comment": "Called before all on_... have been called",
        "label": "How-to-use",
        "id": "10220"
    },
    {
        "raw_code": "def self.convert_size_vars!(disk_provider_config)\n          if disk_provider_config.key?(:BlockSizeBytes)\n            bytes = Vagrant::Util::Numeric.string_to_bytes(disk_provider_config[:BlockSizeBytes])\n            disk_provider_config[:BlockSizeBytes] = bytes\n          end",
        "comment": "Converts any \"shortcut\" options such as \"123MB\" into its byte form. This is due to what parameter type is expected when calling the `New-VHD` powershell command  @param [Hash] disk_provider_config @return [Hash] disk_provider_config",
        "label": "How-to-use",
        "id": "9708"
    },
    {
        "raw_code": "def send_file(path, opts = {})\n      if opts[:type] || !response['content-type']\n        content_type opts[:type] || File.extname(path), default: 'application/octet-stream'\n      end",
        "comment": "Use the contents of the file at +path+ as the response body.",
        "label": "How-to-use",
        "id": "8557"
    },
    {
        "raw_code": "def initialize_visibility # :nodoc:\n    @document_children   = true\n    @document_self       = true\n    @done_documenting    = false\n    @force_documentation = false\n    @received_nodoc      = false\n    @ignored             = false\n    @suppressed          = false\n    @track_visibility    = true\n  end",
        "comment": " Initializes state for visibility of this CodeObject and its children.",
        "label": "How-to-use",
        "id": "15910"
    },
    {
        "raw_code": "def attribute_in_database(attr_name)\n        mutations_from_database.original_value(attr_name.to_s)\n      end",
        "comment": "Returns the value of an attribute in the database, as opposed to the in-memory value that will be persisted the next time the record is saved.  This method is useful in validations and before callbacks, to see the original value of an attribute prior to any changes about to be saved. It can be invoked as +name_in_database+ instead of <tt>attribute_in_database(\"name\")</tt>.",
        "label": "How-to-use",
        "id": "12846"
    },
    {
        "raw_code": "def collection_method\n        raise NotImplementedError\n      end",
        "comment": "The name of the method to call to retrieve the data to import.",
        "label": "How-to-use",
        "id": "2051"
    },
    {
        "raw_code": "def reset!\n        clear_cache!(new_connection: true)\n        reset_transaction\n        attempt_configure_connection\n      end",
        "comment": "Reset the state of this connection, directing the DBMS to clear transactions and other connection-related server-side state. Usually a database-dependent operation.  If a database driver or protocol does not support such a feature, implementors may alias this to #reconnect!. Otherwise, implementors should call super immediately after resetting the connection (and while still holding @lock).",
        "label": "How-to-use",
        "id": "12929"
    },
    {
        "raw_code": "def log_info(message)\n    Gitlab::AppLogger.info message\n  end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "7088"
    },
    {
        "raw_code": "def to_fs(format = :default)\n      if formatter = RANGE_FORMATS[format]\n        formatter.call(self.begin, self.end)\n      else\n        to_s\n      end",
        "comment": "Convert range to a formatted string. See RANGE_FORMATS for predefined formats.  This method is aliased to <tt>to_formatted_s</tt>.  range = (1..100)           # => 1..100  range.to_s                 # => \"1..100\" range.to_fs(:db)           # => \"BETWEEN '1' AND '100'\"  range = (1..)              # => 1.. range.to_fs(:db)           # => \">= '1'\"  range = (..100)            # => ..100 range.to_fs(:db)           # => \"<= '100'\"  == Adding your own range formats to to_fs You can add your own formats to the Range::RANGE_FORMATS hash. Use the format name as the hash key and a Proc instance.  # config/initializers/range_formats.rb Range::RANGE_FORMATS[:short] = ->(start, stop) { \"Between #{start.to_fs(:db)} and #{stop.to_fs(:db)}\" }",
        "label": "How-to-use",
        "id": "14340"
    },
    {
        "raw_code": "def add_to_transaction(ensure_finalize = true)\n        self.class.with_connection do |connection|\n          connection.add_transaction_record(self, ensure_finalize)\n        end",
        "comment": "Add the record to the current transaction so that the #after_rollback and #after_commit callbacks can be called.",
        "label": "How-to-use",
        "id": "12735"
    },
    {
        "raw_code": "def release_connection(existing_lease = nil)\n        return if self.discarded?\n\n        if conn = connection_lease.release\n          checkin conn\n          return true\n        end",
        "comment": "Signal that the thread is finished with the current connection. #release_connection releases the connection-thread association and returns the connection to the pool.  This method only works for connections that have been obtained through #lease_connection or #with_connection methods, connections obtained through #checkout will not be automatically released.",
        "label": "How-to-use",
        "id": "13016"
    },
    {
        "raw_code": "def preset_root_ancestor_for(groups)\n      return groups if groups.size < 2\n\n      root = groups.first.root_ancestor\n      groups.drop(1).each { |group| group.root_ancestor = root }\n    end",
        "comment": "This method can be used only if all groups have the same top-level group",
        "label": "How-to-use",
        "id": "7011"
    },
    {
        "raw_code": "def _HtmlBlockCloseBlockquote\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseBlockquote = \"<\" Spnl \"/\" (\"blockquote\" | \"BLOCKQUOTE\") Spnl \">\"",
        "label": "How-to-use",
        "id": "15630"
    },
    {
        "raw_code": "def disallow_new_uploads!\n    render_404 if upload_version_at_least?(ID_BASED_UPLOAD_PATH_VERSION)\n  end",
        "comment": "Starting with this version, #show is handled by Banzai::UploadsController#show",
        "label": "How-to-use",
        "id": "6625"
    },
    {
        "raw_code": "def constructor?\n      name == :initialize && scope == :instance && namespace.is_a?(ClassObject)\n    end",
        "comment": "@return whether or not the method is the #initialize constructor method",
        "label": "How-to-use",
        "id": "550"
    },
    {
        "raw_code": "def self.register_db_config_handler(&block)\n      db_config_handlers << block\n    end",
        "comment": "Allows an application to register a custom handler for database configuration objects. This is useful for creating a custom handler that responds to methods your application needs but Active Record doesn't implement. For example if you are using Vitess, you may want your Vitess configurations to respond to `sharded?`. To implement this define the following in an initializer:  ActiveSupport.on_load(:active_record_database_configurations) do ActiveRecord::DatabaseConfigurations.register_db_config_handler do |env_name, name, url, config| next unless config.key?(:vitess) VitessConfig.new(env_name, name, config) end end  Note: applications must handle the condition in which custom config should be created in your handler registration otherwise all objects will use the custom handler.  Then define your +VitessConfig+ to respond to the methods your application needs. It is recommended that you inherit from one of the existing database config classes to avoid having to reimplement all methods. Custom config handlers should only implement methods Active Record does not.  class VitessConfig < ActiveRecord::DatabaseConfigurations::UrlConfig def sharded? configuration_hash.fetch(\"sharded\", false) end end  For configs that have a +:vitess+ key, a +VitessConfig+ object will be created instead of a +UrlConfig+.",
        "label": "How-to-use",
        "id": "12448"
    },
    {
        "raw_code": "def after_accept_invite\n    run_after_commit_or_now { Members::InviteAcceptedMailer.with(member: self).email.deliver_later }\n\n    update_two_factor_requirement\n\n    post_create_member_hook\n  end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "6900"
    },
    {
        "raw_code": "def checkout(checkout_timeout = @checkout_timeout)\n        return checkout_and_verify(acquire_connection(checkout_timeout)) unless @pinned_connection\n\n        @pinned_connection.lock.synchronize do\n          synchronize do\n            # The pinned connection may have been cleaned up before we synchronized, so check if it is still present\n            if @pinned_connection\n              @pinned_connection.verify!\n\n              # Any leased connection must be in @connections otherwise\n              # some methods like #connected? won't behave correctly\n              unless @connections.include?(@pinned_connection)\n                @connections << @pinned_connection\n              end",
        "comment": "Check-out a database connection from the pool, indicating that you want to use it. You should call #checkin when you no longer need this.  This is done by either returning and leasing existing connection, or by creating a new connection and leasing it.  If all connections are leased and the pool is at capacity (meaning the number of currently leased connections is greater than or equal to the size limit set), an ActiveRecord::ConnectionTimeoutError exception will be raised.  Returns: an AbstractAdapter object.  Raises: - ActiveRecord::ConnectionTimeoutError no connection can be obtained from the pool.",
        "label": "How-to-use",
        "id": "13025"
    },
    {
        "raw_code": "def backtrace_matches_caller?(backtrace)\n    backtrace[3..] == caller[1..]\n  end",
        "comment": "This function makes sure that the rest of the stack trace matches in order to avoid missing an exception that was generated by calling #next on another Enumerator inside the Fiber. This might miss some *very* contrived scenarios involving recursion, but exceptions don't provide Fiber information, so it's the best we can do.",
        "label": "How-to-use",
        "id": "1283"
    },
    {
        "raw_code": "def instance_values\n    instance_variables.to_h do |ivar|\n      [ivar[1..-1].freeze, instance_variable_get(ivar)]\n    end",
        "comment": "Returns a hash with string keys that maps instance variable names without \"@\" to their corresponding values.  class C def initialize(x, y) @x, @y = x, y end end  C.new(0, 1).instance_values # => {\"x\" => 0, \"y\" => 1}",
        "label": "How-to-use",
        "id": "14319"
    },
    {
        "raw_code": "def setup_generator(generator_name = @generator_name)\n    @generator = @generators[generator_name]\n\n    unless @generator then\n      raise OptionParser::InvalidArgument,\n            \"Invalid output formatter #{generator_name}\"\n    end",
        "comment": " Set up an output generator for the named +generator_name+.  If the found generator responds to :setup_options it will be called with the options instance.  This allows generators to add custom options or set default options.",
        "label": "How-to-use",
        "id": "15539"
    },
    {
        "raw_code": "def self.latest_cached_markdown_version(local_version:)\n      local_version ||= Gitlab::CurrentSettings.current_application_settings.local_markdown_version\n\n      CACHE_COMMONMARK_VERSION_SHIFTED | local_version\n    end",
        "comment": "We could be called by a method that is inside the Gitlab::CurrentSettings object. In this case we need to pass in the local_markdown_version in order to avoid an infinite loop. See usaage in `app/models/concerns/cache_markdown_field.rb` Otherwise pass in `nil`",
        "label": "How-to-use",
        "id": "1441"
    },
    {
        "raw_code": "def resource(*resources, concerns: nil, **options, &block)\n          if resources.grep(Hash).any? && (deprecated_options = resources.extract_options!)\n            concerns = assign_deprecated_option(deprecated_options, :concerns, :resource) if deprecated_options.key?(:concerns)\n            assign_deprecated_options(deprecated_options, options, :resource)\n          end",
        "comment": "Sometimes, you have a resource that clients always look up without referencing an ID. A common example, /profile always shows the profile of the currently logged in user. In this case, you can use a singular resource to map /profile (rather than /profile/:id) to the show action:  resource :profile  This creates six different routes in your application, all mapping to the `Profiles` controller (note that the controller is named after the plural):  GET       /profile/new GET       /profile GET       /profile/edit PATCH/PUT /profile DELETE    /profile POST      /profile  If you want instances of a model to work with this resource via record identification (e.g. in `form_with` or `redirect_to`), you will need to call [resolve](rdoc-ref:CustomUrls#resolve):  resource :profile resolve('Profile') { [:profile] }  # Enables this to work with singular routes: form_with(model: @profile) {}  ### Options Takes same options as [resources](rdoc-ref:#resources)",
        "label": "How-to-use",
        "id": "11576"
    },
    {
        "raw_code": "def finalize!\n          # Default implementation is to do nothing.\n        end",
        "comment": "This is called as a last-minute hook that allows the configuration object to finalize itself before it will be put into use. This is a useful place to do some defaults in the case the user didn't configure something or so on.  An example of where this sort of thing is used or has been used: the \"vm\" configuration key uses this to make sure that at least one sub-VM has been defined: the default VM.  The configuration object is expected to mutate itself.",
        "label": "How-to-use",
        "id": "9120"
    },
    {
        "raw_code": "def flush_left(text)\n    indent = 9999\n\n    text.each_line do |line|\n      line_indent = line =~ /\\S/ || 9999\n      indent = line_indent if indent > line_indent\n    end",
        "comment": " Flush +text+ left based on the shortest line",
        "label": "How-to-use",
        "id": "15559"
    },
    {
        "raw_code": "def self.[](model_class)\n      @id_types ||= {\n        # WorkItem has a special class as we want to allow IssueID\n        # on WorkItemID while we transition into work items\n        ::WorkItem => ::Types::WorkItemIdType\n      }\n\n      @id_types[model_class] ||= Class.new(self) do\n        model_name = model_class.name\n\n        graphql_name model_name_to_graphql_name(model_name)\n        description <<~MD.strip\n          A `#{graphql_name}` is a global ID. It is encoded as a string.\n\n          An example `#{graphql_name}` is: `\"#{::Gitlab::GlobalId.build(model_name: model_name, id: 1)}\"`.\n          #{\n            if deprecation = Gitlab::GlobalId::Deprecations.deprecation_by(model_name)\n              \"The older format `\\\"#{::Gitlab::GlobalId.build(model_name: deprecation.old_name, id: 1)}\\\"` was deprecated in #{deprecation.milestone}.\"\n            end}\n\n        MD\n\n        define_singleton_method(:to_s) do\n          graphql_name\n        end",
        "comment": "Construct a restricted type, that can only be inhabited by an ID of a given model class.",
        "label": "How-to-use",
        "id": "6210"
    },
    {
        "raw_code": "def format_migration_message(migration)\n        message = \"**#{migration[:batched_background_migration_file]}**: #{migration[:comment]}\"\n\n        if migration[:finalized_migration_file]\n          additional_info = []\n          additional_info << \"Finalized migration: #{migration[:finalized_migration_file]}\"\n          additional_info << \"Finalized migration milestone: #{migration[:finalized_migration_milestone]}\"\n\n          if migration[:current_gitlab_version]\n            additional_info << \"Current GitLab version: #{migration[:current_gitlab_version]}\"\n          end",
        "comment": "Helper method to format a migration message",
        "label": "How-to-use",
        "id": "8158"
    },
    {
        "raw_code": "def on_before_blackout_period(&block)\n          # Defer block execution\n          (@master_blackout_period ||= []) << block\n        end",
        "comment": "Read the config/initializers/cluster_events_before_phased_restart.rb",
        "label": "How-to-use",
        "id": "1969"
    },
    {
        "raw_code": "def discriminate_class_for_record(record)\n          if using_single_table_inheritance?(record)\n            find_sti_class(record[inheritance_column])\n          else\n            super\n          end",
        "comment": "Called by +instantiate+ to decide which class to use for a new record instance. For single-table inheritance, we check the record for a +type+ column and return the corresponding class.",
        "label": "How-to-use",
        "id": "12476"
    },
    {
        "raw_code": "def apply(callback_sequence)\n          compiled.apply(callback_sequence)\n        end",
        "comment": "Wraps code with filter",
        "label": "How-to-use",
        "id": "13769"
    },
    {
        "raw_code": "def detect?(machine)\n          false\n        end",
        "comment": "This method is called when the machine is booted and has communication capabilities in order to detect whether this guest operating system is running within the machine.  @return [Boolean]",
        "label": "How-to-use",
        "id": "9119"
    },
    {
        "raw_code": "def _layout_for(*args, &block)\n        name = args.first\n\n        if block && !name.is_a?(Symbol)\n          capture(*args, &block)\n        else\n          super\n        end",
        "comment": "Overrides _layout_for in the context object so it supports the case a block is passed to a partial. Returns the contents that are yielded to a layout, given a name or a block.  You can think of a layout as a method that is called with a block. If the user calls `yield :some_name`, the block, by default, returns `content_for(:some_name)`. If the user calls simply `yield`, the default block returns `content_for(:layout)`.  The user can override this default by passing a block to the layout:  # The template <%= render layout: \"my_layout\" do %> Content <% end %>  # The layout <html> <%= yield %> </html>  In this case, instead of the default block, which would return `content_for(:layout)`, this method returns the block that was passed in to `render :layout`, and the response would be  <html> Content </html>  Finally, the block can take block arguments, which can be passed in by `yield`:  # The template <%= render layout: \"my_layout\" do |customer| %> Hello <%= customer.name %> <% end %>  # The layout <html> <%= yield Struct.new(:name).new(\"David\") %> </html>  In this case, the layout would receive the block passed into `render :layout`, and the struct specified would be passed into the block as an argument. The result would be  <html> Hello David </html> ",
        "label": "How-to-use",
        "id": "11961"
    },
    {
        "raw_code": "def machine_config(name, provider, boxes, data_path=nil, validate_provider=true)\n      keys = @keys.dup\n\n      sub_machine = @config.vm.defined_vms[name]\n      if !sub_machine\n        raise Errors::MachineNotFound,\n          name: name, provider: provider\n      end",
        "comment": "Returns the configuration for a single machine.  When loading a box Vagrantfile, it will be prepended to the key order specified when initializing this class. Sub-machine and provider-specific overrides are appended at the end. The actual order is:  - box - keys specified for #initialize - sub-machine - provider  The return value is a hash with the following keys (symbols) and values:  - box: the {Box} backing the machine - config: the actual configuration - config_errors: list of errors, if any - config_warnings: list of warnings, if any - provider_cls: class of the provider backing the machine - provider_options: options for the provider  @param [Symbol] name Name of the machine. @param [Symbol] provider The provider the machine should be backed by (required for provider overrides). @param [BoxCollection] boxes BoxCollection to look up the box Vagrantfile. @param [Pathname] data_path Machine data path @return [Hash<Symbol, Object>] Various configuration parameters for a machine. See the main documentation body for more info.",
        "label": "How-to-use",
        "id": "8796"
    },
    {
        "raw_code": "def add_method(method)\n    @display.print_method method\n  end",
        "comment": " Records the parsing of +method+",
        "label": "How-to-use",
        "id": "15986"
    },
    {
        "raw_code": "def cancelable?\n      (active? || created?) && !canceling?\n    end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "7536"
    },
    {
        "raw_code": "def workhorse_finalize(url, file_key:, params:, method: :post, headers: {}, send_rewritten_field: false)\n    workhorse_finalize_with_multiple_files(\n      url,\n      method: method,\n      file_keys: file_key,\n      params: params,\n      headers: headers,\n      send_rewritten_field: send_rewritten_field\n    )\n  end",
        "comment": "workhorse_finalize will transform file_key inside params as if it was the finalize call of an inline object storage upload. note that based on the content of the params it can simulate a disc acceleration or an object storage upload",
        "label": "How-to-use",
        "id": "8437"
    },
    {
        "raw_code": "def size\n      Sidekiq.redis { |con| con.llen(@rname) }\n    end",
        "comment": "The current size of the queue within Redis. This value is real-time and can change between calls.  @return [Integer] the size",
        "label": "How-to-use",
        "id": "5112"
    },
    {
        "raw_code": "def handle_ifdefs_in(body)\n    body.gsub(/^#ifdef HAVE_PROTOTYPES.*?#else.*?\\n(.*?)#endif.*?\\n/m, '\\1')\n  end",
        "comment": " Removes #ifdefs that would otherwise confuse us",
        "label": "How-to-use",
        "id": "16162"
    },
    {
        "raw_code": "def rolledback!(force_restore_state: false, should_run_callbacks: true) # :nodoc:\n      if should_run_callbacks\n        _run_rollback_callbacks\n      end",
        "comment": "Call the #after_rollback callbacks. The +force_restore_state+ argument indicates if the record state should be rolled back to the beginning or just to the last savepoint.",
        "label": "How-to-use",
        "id": "12729"
    },
    {
        "raw_code": "def with_feature(name = nil)\n          @with_feature = name unless name.nil?\n\n          @with_feature\n        end",
        "comment": "Use feature toggle to control whether certain metric is enabled/disabled",
        "label": "How-to-use",
        "id": "2316"
    },
    {
        "raw_code": "def provision\n        end",
        "comment": "This is the method called when the actual provisioning should be done. The communicator is guaranteed to be ready at this point, and any shared folders or networks are already setup.  No return value is expected.",
        "label": "How-to-use",
        "id": "9061"
    },
    {
        "raw_code": "def provide(name, content = nil, &block)\n        content = capture(&block) if block_given?\n        result = @view_flow.append!(name, content) if content\n        result unless content\n      end",
        "comment": "The same as +content_for+ but when used with streaming flushes straight back to the layout. In other words, if you want to concatenate several times to the same buffer when rendering a given template, you should use +content_for+, if not, use +provide+ to tell the layout to stop looking for more contents.  See ActionController::Streaming for more information.",
        "label": "How-to-use",
        "id": "11819"
    },
    {
        "raw_code": "def undo_rename_column_concurrently(table, old, new)\n        trigger_name = rename_trigger_name(table, old, new)\n\n        check_trigger_permissions!(table)\n\n        remove_rename_triggers(table, trigger_name)\n\n        remove_column(table, new)\n      end",
        "comment": "Reverses operations performed by rename_column_concurrently.  This method takes care of removing previously installed triggers as well as removing the new column.  table - The name of the database table. old - The name of the old column. new - The name of the new column.",
        "label": "How-to-use",
        "id": "2981"
    },
    {
        "raw_code": "def complete!\n      complete\n    ensure\n      IsolatedExecutionState.delete(self.class.active_key)\n    end",
        "comment": "Complete this in-flight execution. This method *must* be called exactly once on the result of any call to +run!+.  Where possible, prefer +wrap+.",
        "label": "How-to-use",
        "id": "13864"
    },
    {
        "raw_code": "def accesses?(rhs, lhs)\n            if lhs.method?(:[]=)\n              # FIXME: Workaround `rubocop:disable` comment for JRuby.\n              # rubocop:disable Performance/RedundantEqualityComparisonBlock\n              matching_calls(rhs, lhs.receiver, :[]).any? { |args| args == lhs.arguments }\n              # rubocop:enable Performance/RedundantEqualityComparisonBlock\n            else\n              access_method = lhs.method_name.to_s.chop.to_sym\n              matching_calls(rhs, lhs.receiver, access_method).any?\n            end",
        "comment": "`lhs` is an assignment method call like `obj.attr=` or `ary[idx]=`. Does `rhs` access the same value which is assigned by `lhs`?",
        "label": "How-to-use",
        "id": "10599"
    },
    {
        "raw_code": "def current\n        Gitlab::Cache::Import::Caching.read(cache_key)\n      end",
        "comment": "Get the current value from the cache  @return [String]",
        "label": "How-to-use",
        "id": "2924"
    },
    {
        "raw_code": "def label_ids\n        return if jira_issue.fields['labels'].blank?\n\n        Gitlab::JiraImport::HandleLabelsService.new(project, jira_issue.fields['labels']).execute\n      end",
        "comment": "We already create labels in Gitlab::JiraImport::LabelsImporter stage but there is a possibility it may fail or new labels were created on the Jira in the meantime",
        "label": "How-to-use",
        "id": "1767"
    },
    {
        "raw_code": "def class_methods(&class_methods_module_definition)\n      mod = const_defined?(:ClassMethods, false) ?\n        const_get(:ClassMethods) :\n        const_set(:ClassMethods, Module.new)\n\n      mod.module_eval(&class_methods_module_definition)\n    end",
        "comment": "Define class methods from given block. You can define private class methods as well.  module Example extend ActiveSupport::Concern  class_methods do def foo; puts 'foo'; end  private def bar; puts 'bar'; end end end  class Buzz include Example end  Buzz.foo # => \"foo\" Buzz.bar # => private method 'bar' called for Buzz:Class(NoMethodError)",
        "label": "How-to-use",
        "id": "13779"
    },
    {
        "raw_code": "def _render_template(options)\n        if options.delete(:stream)\n          # It shouldn't be necessary to set this.\n          headers[\"cache-control\"] ||= \"no-cache\"\n\n          view_renderer.render_body(view_context, options)\n        else\n          super\n        end",
        "comment": "Call render_body if we are streaming instead of usual `render`.",
        "label": "How-to-use",
        "id": "11349"
    },
    {
        "raw_code": "def attribute_change_to_be_saved(attr_name)\n        mutations_from_database.change_to_attribute(attr_name.to_s)\n      end",
        "comment": "Returns the change to an attribute that will be persisted during the next save.  This method is useful in validations and before callbacks, to see the change to an attribute that will occur when the record is saved. It can be invoked as +name_change_to_be_saved+ instead of <tt>attribute_change_to_be_saved(\"name\")</tt>.  If the attribute will change, the result will be an array containing the original value and the new value about to be saved.",
        "label": "How-to-use",
        "id": "12845"
    },
    {
        "raw_code": "def to_partial_path\n    'shared/wikis/wiki_directory'\n  end",
        "comment": "Relative path to the partial to be used when rendering collections of this object.",
        "label": "How-to-use",
        "id": "6888"
    },
    {
        "raw_code": "def initialize(departments: [], extra_info: {}, base_dir: Dir.pwd, plugin_name: nil)\n    @departments = departments.map(&:to_sym).sort!\n    @extra_info = extra_info\n    @cops = RuboCop::Cop::Registry.global\n    @config = RuboCop::ConfigLoader.default_configuration\n    # NOTE: For example, this prevents excessive plugin loading before another task executes,\n    # in cases where plugins are already loaded by `internal_investigation`.\n    if plugin_name && @config.loaded_plugins.none? { |plugin| plugin.about.name == plugin_name }\n      RuboCop::Plugin.integrate_plugins(RuboCop::Config.new, [plugin_name])\n    end",
        "comment": "This class will only generate documentation for cops that belong to one of the departments given in the `departments` array. E.g. if we only wanted documentation for Lint cops:  CopsDocumentationGenerator.new(departments: ['Lint']).call  For plugin extensions, specify `:plugin_name` keyword as follows:  CopsDocumentationGenerator.new( departments: ['Performance'], plugin_name: 'rubocop-performance' ).call  You can append additional information:  callback = ->(data) { required_rails_version(data.cop) } CopsDocumentationGenerator.new(extra_info: { ruby_version: callback }).call  This will insert the string returned from the lambda _after_ the section from RuboCop itself. See `CopsDocumentationGenerator::STRUCTURE` for available sections. ",
        "label": "How-to-use",
        "id": "10141"
    },
    {
        "raw_code": "def increment(name, amount = 1, options = nil)\n        options = merged_options(options)\n        key = normalize_key(name, options)\n\n        instrument :increment, key, amount: amount do\n          failsafe :increment do\n            change_counter(key, amount, options)\n          end",
        "comment": "Increment a cached integer value using the Redis incrby atomic operator. Returns the updated value.  If the key is unset or has expired, it will be set to +amount+:  cache.increment(\"foo\") # => 1 cache.increment(\"bar\", 100) # => 100  To set a specific value, call #write passing <tt>raw: true</tt>:  cache.write(\"baz\", 5, raw: true) cache.increment(\"baz\") # => 6  Incrementing a non-numeric value, or a value written without <tt>raw: true</tt>, will fail and return +nil+.  To read the value later, call #read_counter:  cache.increment(\"baz\") # => 7 cache.read_counter(\"baz\") # 7  Failsafe: Raises errors.",
        "label": "How-to-use",
        "id": "14043"
    },
    {
        "raw_code": "def comparable\n        reload! if api_response.nil?\n\n        api_resource.slice(\n          :state,\n          :description,\n          :type,\n          :title,\n          :labels,\n          :milestone,\n          :upvotes,\n          :downvotes,\n          :merge_requests_count,\n          :user_notes_count,\n          :due_date,\n          :has_tasks,\n          :task_status,\n          :confidential,\n          :discussion_locked,\n          :issue_type,\n          :task_completion_status,\n          :closed_at,\n          :created_at\n        )\n      end",
        "comment": "Return subset of fields for comparing issues  @return [Hash]",
        "label": "How-to-use",
        "id": "4141"
    },
    {
        "raw_code": "def self.attribute(key, paths:, type: nil, fallback: -> { nil })\n          define_method(key) do\n            strong_memoize(key) do\n              paths = Array(paths).first.is_a?(String) ? [Array(paths)] : paths\n              value = value_for_paths(paths)\n              value = parse_value(value, type) if value\n\n              value.presence || fallback.call\n            end",
        "comment": "Defines a method which allows access to a given value within an alert payload  @param key [Symbol] Name expected to be used to reference value @param paths [String, Array<String>, Array<Array<String>>,] List of (nested) keys at value can be found, the first to yield a result will be used @param type [Symbol] If value should be converted to another type, that should be specified here @param fallback [Proc] Block to be executed to yield a value if a value cannot be idenitied at any provided paths Example) attribute :title paths: [['title'], ['details', 'title']] fallback: Proc.new { 'New Alert' }  The above sample definition will define a method called #title which will return the value from the payload under the key `title` if available, otherwise looking under `details.title`. If neither returns a value, the return value will be `'New Alert'`",
        "label": "How-to-use",
        "id": "2058"
    },
    {
        "raw_code": "def new\n    if pre_auth.authorizable?\n      if skip_authorization? || (matching_token? && pre_auth.client.application.confidential?)\n        auth = authorization.authorize\n        parsed_redirect_uri = URI.parse(auth.redirect_uri)\n        session.delete(:user_return_to)\n        render \"doorkeeper/authorizations/redirect\", locals: { redirect_uri: parsed_redirect_uri }, layout: false\n      else\n        redirect_uri = URI(authorization.authorize.redirect_uri)\n        allow_redirect_uri_form_action(redirect_uri.scheme)\n\n        render \"doorkeeper/authorizations/new\"\n      end",
        "comment": "Overridden from Doorkeeper::AuthorizationsController to include the call to session.delete",
        "label": "How-to-use",
        "id": "6494"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_blank_line self\n  end",
        "comment": " Calls #accept_blank_line on +visitor+",
        "label": "How-to-use",
        "id": "16288"
    },
    {
        "raw_code": "def granular_update(key, value, operation)\n      full_key = cache_key(key)\n\n      log_records = [\"granular_update\", \"Key: #{key}\", \"Value: #{value}\", \"Operation: #{operation}\"]\n\n      with do |redis|\n        # Watch Redis key to track changes during the update operation.\n        # If watch fails, it means that cache being modified by another process.\n        # Granular update should be cancelled because it might create inconsistencies\n        result = redis.watch(full_key) do |wredis|\n          if redis.exists?(full_key) # rubocop:disable CodeReuse/ActiveRecord -- it's a valid method\n            log_records << \"Key exists!\"\n            wredis.multi do |multi|\n              case operation\n              when :add\n                multi.sadd(full_key, value)\n              when :remove\n                multi.srem(full_key, value)\n              end",
        "comment": "Atomically updates a Redis set cache by adding or removing a single value. This method uses Redis WATCH/MULTI to ensure thread-safe operations and only operates on existing cache keys to avoid creating stale cache entries.  @param key [String] The cache key to update @param value [String] The value to add or remove from the set @param operation [Symbol] Either :add to add the value or :remove to remove it  Example: cache.granular_update('branch_names', 'feature-branch', :add) cache.granular_update('tag_names', 'v1.0.0', :remove)",
        "label": "How-to-use",
        "id": "1439"
    },
    {
        "raw_code": "def self.names_for_ids(plan_ids)\n    self.id_in(plan_ids).pluck(:name)\n  end",
        "comment": "rubocop: enable Database/AvoidUsingPluckWithoutLimit rubocop: disable Database/AvoidUsingPluckWithoutLimit -- This method is prepared for manual usage in Rails console on SaaS. Using pluck without limit in this case should be enough safe.",
        "label": "How-to-use",
        "id": "6878"
    },
    {
        "raw_code": "def test_sequential_maintenance_loop_is_incremental\n        work_queue = []\n        work_collector = Object.new\n        work_collector.define_singleton_method(:post) do |&block|\n          work_queue << block\n        end",
        "comment": "-- This is testing a private method... but testing its public callers would be much more complicated, as well as needing duplicate coverage.",
        "label": "How-to-use",
        "id": "13504"
    },
    {
        "raw_code": "def resolve!(_placeholders = {})\n        self\n      end",
        "comment": "Present for compatibility with license templates, which can replace text like `[fullname]` with a user-specified string. This is a no-op for other templates",
        "label": "How-to-use",
        "id": "2422"
    },
    {
        "raw_code": "def provision_winssh(args)\n        with_script_file do |path|\n          # Upload the script to the machine\n          @machine.communicate.tap do |comm|\n            env = config.env.map{|k,v| comm.generate_environment_export(k, v)}.join(';')\n\n            remote_ext = get_windows_ext(path)\n            remote_path = add_extension(upload_path, remote_ext)\n\n            if remote_ext == \".bat\"\n              command = \"#{env}\\n cmd.exe /c \\\"#{remote_path}\\\" #{args}\"\n            else\n              # Copy powershell_args from configuration\n              shell_args = config.powershell_args\n              # For PowerShell scripts bypass the execution policy unless already specified\n              shell_args += \" -ExecutionPolicy Bypass\" if config.powershell_args !~ /[-\\/]ExecutionPolicy/i\n              # CLIXML output is kinda useless, especially on non-windows hosts\n              shell_args += \" -OutputFormat Text\" if config.powershell_args !~ /[-\\/]OutputFormat/i\n              command = \"#{env}\\npowershell #{shell_args} -file \\\"#{remote_path}\\\"#{args}\"\n            end",
        "comment": "This is the provision method called if Windows OpenSSH is what is running on the remote end, which assumes a non-POSIX-style host.",
        "label": "How-to-use",
        "id": "9865"
    },
    {
        "raw_code": "def valid_password?(password)\n    return false unless password_matches?(password)\n\n    migrate_password!(password)\n  end",
        "comment": "Called by Devise during database authentication. Also migrates the user password to the configured encryption type (BCrypt or PBKDF2+SHA512), if needed.",
        "label": "How-to-use",
        "id": "7228"
    },
    {
        "raw_code": "def close_issue(issue, closed_via: nil, notifications: true, system_note: true, status: nil)\n      if issue.is_a?(ExternalIssue)\n        close_external_issue(issue, closed_via)\n\n        return issue\n      end",
        "comment": "Closes the supplied issue without checking if the user is authorized to do so.  The code calling this method is responsible for ensuring that a user is allowed to close the given issue.",
        "label": "How-to-use",
        "id": "5725"
    },
    {
        "raw_code": "def columns(pool, table_name)\n        if ignored_table?(table_name)\n          raise ActiveRecord::StatementInvalid.new(\"Table '#{table_name}' doesn't exist\", connection_pool: pool)\n        end",
        "comment": "Get the columns for a table",
        "label": "How-to-use",
        "id": "12987"
    },
    {
        "raw_code": "def permissions_policy(**options, &block)\n        before_action(options) do\n          unless request.respond_to?(:permissions_policy)\n            raise \"Cannot override permissions_policy if no global permissions_policy configured.\"\n          end",
        "comment": "Overrides parts of the globally configured `Feature-Policy` header:  class PagesController < ApplicationController permissions_policy do |policy| policy.geolocation \"https://example.com\" end end  Options can be passed similar to `before_action`. For example, pass `only: :index` to override the header on the index action only:  class PagesController < ApplicationController permissions_policy(only: :index) do |policy| policy.camera :self end end  Requires a global policy defined in an initializer, which can be empty:  Rails.application.config.permissions_policy do |policy| # policy.gyroscope :none end",
        "label": "How-to-use",
        "id": "11313"
    },
    {
        "raw_code": "def halted_callback_hook(filter, _)\n        ActiveSupport::Notifications.instrument(\"halted_callback.action_controller\", filter: filter)\n      end",
        "comment": "A hook invoked every time a before callback is halted.",
        "label": "How-to-use",
        "id": "11290"
    },
    {
        "raw_code": "def self.auto_install_local_plugins?\n    if ENV[\"VAGRANT_INSTALL_LOCAL_PLUGINS\"]\n      true\n    else\n      false\n    end",
        "comment": "Automatically install locally defined plugins instead of waiting for user confirmation.  @return [Boolean]",
        "label": "How-to-use",
        "id": "8830"
    },
    {
        "raw_code": "def accept_list_item_start(list_item)\n    if tag = @in_list_entry.last\n      @res << tag\n    end",
        "comment": " Prepares the visitor for consuming +list_item+",
        "label": "How-to-use",
        "id": "16339"
    },
    {
        "raw_code": "def start_accepting\n    @res = [\"\"]\n    @indent = 0\n    @prefix = nil\n\n    @list_index = []\n    @list_type  = []\n    @list_width = []\n  end",
        "comment": " Prepares the visitor for text generation",
        "label": "How-to-use",
        "id": "16211"
    },
    {
        "raw_code": "def name_requirement_reason\n        if metric.filters.assigned?\n          NAME_REQUIREMENT_REASONS[:filters]\n        elsif metric.file_name.length > MAX_FILENAME_LENGTH\n          NAME_REQUIREMENT_REASONS[:length]\n        elsif conflicting_key_path?(metric.key_path)\n          NAME_REQUIREMENT_REASONS[:conflict]\n        end",
        "comment": "Helper for #prompt_for_description",
        "label": "How-to-use",
        "id": "5325"
    },
    {
        "raw_code": "def serialize(arguments)\n      arguments.map { |argument| serialize_argument(argument) }\n    end",
        "comment": "Serializes a set of arguments. Intrinsic types that can safely be serialized without mutation are returned as-is. Arrays/Hashes are serialized element by element. All other types are serialized using GlobalID.",
        "label": "How-to-use",
        "id": "12103"
    },
    {
        "raw_code": "def [](key)\n    send(key) if respond_to?(key) # rubocop:disable GitlabSecurity/PublicSend\n  end",
        "comment": "Used by AR for fetching attributes  Pass it along if we respond to it.",
        "label": "How-to-use",
        "id": "1327"
    },
    {
        "raw_code": "def find_or_init_instance_spy(expected_klass, &)\n    existing_spies = RSpec::Mocks.space.proxies.values.filter_map do |proxy|\n      klass = proxy.instance_variable_get(:@doubled_module)&.send(:object)\n      spy = proxy.instance_variable_get(:@object)\n\n      spy if klass == expected_klass\n    end",
        "comment": "Reuse the same spy instance across any chained matchers so that expected `receive` counts are accurately tracked and reported",
        "label": "How-to-use",
        "id": "8344"
    },
    {
        "raw_code": "def with_output_buffer(buf = nil) # :nodoc:\n        unless buf\n          buf = ActionView::OutputBuffer.new\n          if output_buffer && output_buffer.respond_to?(:encoding)\n            buf.force_encoding(output_buffer.encoding)\n          end",
        "comment": "Use an alternate output buffer for the duration of the block. Defaults to a new empty string.",
        "label": "How-to-use",
        "id": "11821"
    },
    {
        "raw_code": "def initialize(app, env, callable)\n          if !callable.respond_to?(:call)\n            raise TypeError, \"Callable argument is expected to respond to `#call`\"\n          end",
        "comment": "@param [Object] callable The object to call (must respond to #call)",
        "label": "How-to-use",
        "id": "9339"
    },
    {
        "raw_code": "def self.build_route_pairs(organization_routes, global_routes)\n        org_route_names = organization_routes.map(&:name)\n        global_route_names = global_routes.map(&:name)\n\n        # Global route => Organization route\n        org_route_names.each_with_object({}) do |org_route_name, route_pairs|\n          global_route_name = extract_global_route_name(org_route_name)\n          next unless global_route_names.include?(global_route_name)\n\n          route_pairs[global_route_name] = org_route_name\n        end",
        "comment": "Build a Hash of global route => Organization route names.",
        "label": "How-to-use",
        "id": "7852"
    },
    {
        "raw_code": "def first_clean_frame(kind = :silent)\n        caller_location_skipped = false\n\n        Thread.each_caller_location do |location|\n          unless caller_location_skipped\n            caller_location_skipped = true\n            next\n          end",
        "comment": "Returns the first clean frame of the caller's backtrace, or +nil+.  Frames are strings.",
        "label": "How-to-use",
        "id": "13706"
    },
    {
        "raw_code": "def after_bundle(&block) # :doc:\n        @after_bundle_callbacks << block\n      end",
        "comment": "Registers a callback to be executed after bundle binstubs have run.  after_bundle do git add: '.' end",
        "label": "How-to-use",
        "id": "14788"
    },
    {
        "raw_code": "def self.load_plugins\n      load_gem_plugins &&\n        load_autoload_plugins &&\n        load_commandline_plugins ? true : false\n    end",
        "comment": "Loads gems that match the name 'yard-*' (recommended) or 'yard_*' except those listed in +~/.yard/ignored_plugins+. This is called immediately after YARD is loaded to allow plugin support.  @return [Boolean] true if all plugins loaded successfully, false otherwise.",
        "label": "How-to-use",
        "id": "151"
    },
    {
        "raw_code": "def stringify(jsonified)\n        ::Gitlab::Json.dump(jsonified)\n      rescue EncodingError => ex\n        # Raise the same error as the default implementation if we encounter\n        # an error. These are usually related to invalid UTF-8 errors.\n        raise JSON::GeneratorError, ex\n      end",
        "comment": "Rails doesn't provide a way of changing the JSON adapter for render calls in controllers, so here we're overriding the parent class method to use our generator, and it's monkey-patched in config/initializers/active_support_json.rb",
        "label": "How-to-use",
        "id": "1653"
    },
    {
        "raw_code": "def replace_with_partitioned_table(table_name)\n          assert_table_is_allowed(table_name)\n\n          partitioned_table_name = make_partitioned_table_name(table_name)\n          archived_table_name = make_archived_table_name(table_name)\n          primary_key_name = connection.primary_key(table_name)\n\n          replace_table(table_name, partitioned_table_name, archived_table_name, primary_key_name)\n        end",
        "comment": "Replaces a non-partitioned table with its partitioned copy. This is the final step in a partitioning migration, which makes the partitioned table ready for use by the application. The partitioned copy should be replaced with the original table in such a way that it appears seamless to any database clients. The replaced table will be renamed to \"#{replaced_table}_archived\". Partitions and primary key constraints will also be renamed to match the naming scheme of the parent table.  **NOTE** This method should only be used after all other migration steps have completed successfully. There are several limitations to this method that MUST be handled before, or during, the swap migration:  - Secondary indexes and foreign keys are not automatically recreated on the partitioned table. - Some types of constraints (UNIQUE and EXCLUDE) which rely on indexes, will not automatically be recreated on the partitioned table, since the underlying index will not be present. - Foreign keys referencing the original non-partitioned table, would also need to be updated to reference the partitioned table, but unfortunately this is not supported in PG11. - Views referencing the original table will not be automatically updated to reference the partitioned table.  Example:  replace_with_partitioned_table :audit_events ",
        "label": "How-to-use",
        "id": "3055"
    },
    {
        "raw_code": "def register(type_name, klass = nil, &block)\n        registry.register(type_name, klass, &block)\n      end",
        "comment": "Add a new type to the registry, allowing it to be referenced as a symbol by {attribute}[rdoc-ref:Attributes::ClassMethods#attribute].",
        "label": "How-to-use",
        "id": "12262"
    },
    {
        "raw_code": "def encode_utf8_with_escaping!(message)\n      message = force_encode_utf8(message)\n      return message if message.valid_encoding?\n\n      unless message.valid_encoding?\n        message = message.chars.map { |char| char.valid_encoding? ? char : escape_chars(char) }.join\n      end",
        "comment": "This method escapes unsupported UTF-8 characters instead of deleting them",
        "label": "How-to-use",
        "id": "1383"
    },
    {
        "raw_code": "def to_s\n          reconstructed = lines.dup\n\n          annotations.reverse_each do |line_number, annotation|\n            reconstructed.insert(line_number, annotation)\n          end",
        "comment": "Construct annotated source string (like what we parse)  Reconstruct a deterministic annotated source string. This is useful for eliminating semantically irrelevant annotation ordering differences.  @example standardization  source1 = AnnotatedSource.parse(<<-RUBY) line1 ^ Annotation 1 ^^ Annotation 2 RUBY  source2 = AnnotatedSource.parse(<<-RUBY) line1 ^^ Annotation 2 ^ Annotation 1 RUBY  source1.to_s == source2.to_s # => true  @return [String]",
        "label": "How-to-use",
        "id": "10714"
    },
    {
        "raw_code": "def rule(weight)\n    @RM::Rule.new weight\n  end",
        "comment": " Shortcut for RDoc::Markup::Rule.new with +weight+",
        "label": "How-to-use",
        "id": "16881"
    },
    {
        "raw_code": "def initialize(metric_definition)\n            super\n\n            raise ArgumentError, \"options events are required\" unless event_names.present?\n          end",
        "comment": "Usage example  In metric YAML defintion instrumentation_class: RedisHLLMetric events: - g_analytics_valuestream end",
        "label": "How-to-use",
        "id": "1987"
    },
    {
        "raw_code": "def initialize(app, env, callable, *callable_args, &block)\n          raise ArgumentError, \"A block must be given to Call\" if !block\n\n          @app      = app\n          @callable = callable\n          @callable_args = callable_args\n          @block    = block\n          @child_app = nil\n        end",
        "comment": "For documentation, read the description of the {Call} class.  @param [Object] callable A valid middleware runnable object. This can be a class, a lambda, or an object that responds to `call`. @yield [result, builder] This block is expected to build on `builder` which is the next middleware sequence that will be run.",
        "label": "How-to-use",
        "id": "9340"
    },
    {
        "raw_code": "def self.namespace(name = nil)\n        return super if name\n        @namespace ||= super.delete_suffix(\"_generator\").sub(/:generators:/, \":\")\n      end",
        "comment": "Convenience method to get the namespace from the class name. It's the same as Thor default except that the Generator at the end of the class is removed.",
        "label": "How-to-use",
        "id": "14758"
    },
    {
        "raw_code": "def storage_key\n          strong_memoize(:storage_key) do\n            re = /(?<storage>.+)_shard_.+/\n            md = re.match(self.name.demodulize.underscore)\n            (md && md[:storage]) || self.name.demodulize.underscore\n          end",
        "comment": "TODO: To be used by https://gitlab.com/gitlab-com/gl-infra/scalability/-/issues/395 as a 'label' alias. The 2 acceptable formats for a demodulized name are: <storage>_shard_<shard> or <storage>.",
        "label": "How-to-use",
        "id": "1835"
    },
    {
        "raw_code": "def default\n      @options['default']\n    end",
        "comment": "Some configurations use the 'default' key, like: https://gitlab.com/gitlab-org/gitlab/-/blob/c4d5c77c87494bb320fa7fdf19b0e4d7d52af1d1/spec/support/helpers/stub_configuration.rb#L96 But since `default` is also a method in Hash, this can be confusing and raise an exception instead of returning nil, as expected in some places. To avoid that, we use #default always as a possible internal key",
        "label": "How-to-use",
        "id": "3520"
    },
    {
        "raw_code": "def build_selects_from_types(order)\n          select = +\"\"\n          first_visible = order.find { |type| !@options[:\"discard_#{type}\"] }\n          order.reverse_each do |type|\n            separator = separator(type) unless type == first_visible # don't add before first visible field\n            select.insert(0, separator.to_s + public_send(\"select_#{type}\").to_s)\n          end",
        "comment": "Given an ordering of datetime components, create the selection HTML and join them with their appropriate separators.",
        "label": "How-to-use",
        "id": "11856"
    },
    {
        "raw_code": "def discard!\n        # This should be overridden by concrete adapters.\n      end",
        "comment": "Immediately forget this connection ever existed. Unlike disconnect!, this will not communicate with the server.  After calling this method, the behavior of all other methods becomes undefined. This is called internally just before a forked process gets rid of a connection that belonged to its parent.",
        "label": "How-to-use",
        "id": "12928"
    },
    {
        "raw_code": "def local?(_object)\n        raise NotImplementedError\n      end",
        "comment": "Should return true if the object is stored locally",
        "label": "How-to-use",
        "id": "2287"
    },
    {
        "raw_code": "def extract_parameters(superclass)\n    return [] unless superclass.parameters\n    members = superclass.parameters.select {|x| x && x.type == :symbol_literal }\n    members.map! {|x| x.source.strip[1..-1] }\n    members\n  end",
        "comment": "Extract the parameters from the Struct.new or Data.define AST node, returning them as a list of strings  @param [MethodCallNode] superclass the AST node for the Struct.new or Data.define call @return [Array<String>] the member names to generate methods for",
        "label": "How-to-use",
        "id": "207"
    },
    {
        "raw_code": "def signed\n        @signed ||= SignedKeyRotatingCookieJar.new(self)\n      end",
        "comment": "Returns a jar that'll automatically generate a signed representation of cookie value and verify it when reading from the cookie again. This is useful for creating cookies with values that the user is not supposed to change. If a signed cookie was tampered with by the user (or a 3rd party), `nil` will be returned.  This jar requires that you set a suitable secret for the verification on your app's `secret_key_base`.  Example:  cookies.signed[:discount] = 45 # => Set-Cookie: discount=BAhpMg==--2c1c6906c90a3bc4fd54a51ffb41dffa4bf6b5f7; path=/  cookies.signed[:discount] # => 45",
        "label": "How-to-use",
        "id": "11515"
    },
    {
        "raw_code": "def finalize!\n        # Defaults\n        @allowed_synced_folder_types = nil if @allowed_synced_folder_types == UNSET_VALUE\n        @base_mac = nil if @base_mac == UNSET_VALUE\n        @base_address = nil if @base_address == UNSET_VALUE\n        @boot_timeout = 300 if @boot_timeout == UNSET_VALUE\n        @box = nil if @box == UNSET_VALUE\n        @box_architecture = :auto if @box_architecture == UNSET_VALUE\n        # If box architecture value was set, force to string\n        if @box_architecture && @box_architecture != :auto\n          @box_architecture = @box_architecture.to_s\n        end",
        "comment": "------------------------------------------------------------------- Internal methods, don't call these. -------------------------------------------------------------------",
        "label": "How-to-use",
        "id": "9455"
    },
    {
        "raw_code": "def each(&block)\n      available_themes.each(&block)\n    end",
        "comment": "Iterate through each Theme  Yields the Theme object",
        "label": "How-to-use",
        "id": "1353"
    },
    {
        "raw_code": "def resource_usage_throttled?(key, scope:, resource_key:, threshold:, interval:, peek: false)\n        strategy = IncrementResourceUsagePerAction.new(resource_key)\n\n        _throttled?(key, scope: scope, strategy: strategy, threshold: threshold, interval: interval, peek: peek)\n      end",
        "comment": "Increments the resource usage for a given key and returns true if the action should be throttled.  @param key [Symbol] Key attribute registered in `.rate_limits` @param scope [<ActiveRecord>] Array of ActiveRecord models, Strings or Symbols to scope throttling to a specific request (e.g. per user per project) @param resource_key [Symbol] Key attribute in SafeRequestStore @param threshold [Integer] Threshold value to override default one registered in `.rate_limits` @param interval [Integer] Interval value to override default one registered in `.rate_limits`  @return [Boolean] Whether or not a request should be throttled",
        "label": "How-to-use",
        "id": "1579"
    },
    {
        "raw_code": "def self.home_url(context)\n        context => {\n          settings: {\n            vscode_extension_marketplace: Hash => vscode_settings,\n          }\n        }\n\n        item_url = vscode_settings&.fetch(:item_url, nil)\n\n        return \"\" unless item_url\n\n        base_url = ::Gitlab::UrlHelpers.normalized_base_url(item_url)\n\n        # NOTE: It's possible for `normalized_base_url` to return something like `://` so let's go ahead and check\n        #       that we actually start with `http` or `https`.\n        return base_url if /^https?:/.match?(base_url)\n\n        \"\"\n      end",
        "comment": "@param [Hash] context @return [String] The URL to use for the extension marketplace home",
        "label": "How-to-use",
        "id": "3557"
    },
    {
        "raw_code": "def death_handlers\n      @options[:death_handlers]\n    end",
        "comment": " Death handlers are called when all retries for a job have been exhausted and the job dies.  It's the notification to your application that this job will not succeed without manual intervention.  Sidekiq.configure_server do |config| config.death_handlers << ->(job, ex) do end end",
        "label": "How-to-use",
        "id": "5186"
    },
    {
        "raw_code": "def active_record_records_enumerator(relation, cursor:, **options)\n          ActiveRecordEnumerator.new(relation, cursor: cursor, **options).records\n        end",
        "comment": "Builds Enumerator from `ActiveRecord::Relation`. Each Enumerator tick moves the cursor one row forward.  @param relation [ActiveRecord::Relation] relation to iterate @param cursor [Object] offset id to start iteration from @param options [Hash] additional options that will be passed to relevant ActiveRecord batching methods  @return [ActiveRecordEnumerator]  @example def build_enumerator(cursor:) active_record_records_enumerator(User.all, cursor: cursor) end  def each_iteration(user) user.notify_about_something end ",
        "label": "How-to-use",
        "id": "5233"
    },
    {
        "raw_code": "def jira_request(path)\n      yield\n    rescue StandardError => e\n      @error = e\n      log_exception(e, message: 'Error sending message', client_url: client_url, client_path: path,\n        client_status: e.try(:code))\n      nil\n    end",
        "comment": "Handle errors when doing Jira API calls",
        "label": "How-to-use",
        "id": "7642"
    },
    {
        "raw_code": "def initialize(secret, **options)\n      raise ArgumentError, \"Secret should not be nil.\" unless secret\n      super(**options)\n      @secret = secret\n      @digest = options[:digest]&.to_s || \"SHA1\"\n    end",
        "comment": "Initialize a new MessageVerifier with a secret for the signature.  ==== Options  [+:digest+] Digest used for signing. The default is <tt>\"SHA1\"</tt>. See +OpenSSL::Digest+ for alternatives.  [+:serializer+] The serializer used to serialize message data. You can specify any object that responds to +dump+ and +load+, or you can choose from several preconfigured serializers: +:marshal+, +:json_allow_marshal+, +:json+, +:message_pack_allow_marshal+, +:message_pack+.  The preconfigured serializers include a fallback mechanism to support multiple deserialization formats. For example, the +:marshal+ serializer will serialize using +Marshal+, but can deserialize using +Marshal+, ActiveSupport::JSON, or ActiveSupport::MessagePack. This makes it easy to migrate between serializers.  The +:marshal+, +:json_allow_marshal+, and +:message_pack_allow_marshal+ serializers support deserializing using +Marshal+, but the others do not. Beware that +Marshal+ is a potential vector for deserialization attacks in cases where a message signing secret has been leaked. <em>If possible, choose a serializer that does not support +Marshal+.</em>  The +:message_pack+ and +:message_pack_allow_marshal+ serializers use ActiveSupport::MessagePack, which can roundtrip some Ruby types that are not supported by JSON, and may provide improved performance. However, these require the +msgpack+ gem.  When using \\Rails, the default depends on +config.active_support.message_serializer+. Otherwise, the default is +:marshal+.  [+:url_safe+] By default, MessageVerifier generates RFC 4648 compliant strings which are not URL-safe. In other words, they can contain \"+\" and \"/\". If you want to generate URL-safe strings (in compliance with \"Base 64 Encoding with URL and Filename Safe Alphabet\" in RFC 4648), you can pass +true+. Note that MessageVerifier will always accept both URL-safe and URL-unsafe encoded messages, to allow a smooth transition between the two settings.  [+:force_legacy_metadata_serializer+] Whether to use the legacy metadata serializer, which serializes the message first, then wraps it in an envelope which is also serialized. This was the default in \\Rails 7.0 and below.  If you don't pass a truthy value, the default is set using +config.active_support.use_message_serializer_for_metadata+.",
        "label": "How-to-use",
        "id": "13908"
    },
    {
        "raw_code": "def stringify_keys!\n      error_msg = \"Warning: Do not mutate #{self.class} objects: `#{__method__}`\"\n\n      log_and_raise_dev_exception(error_msg, method: __method__)\n\n      to_hash.deep_stringify_keys\n    end",
        "comment": "Don't alter the internal keys",
        "label": "How-to-use",
        "id": "3522"
    },
    {
        "raw_code": "def with_routing(config = nil, &block)\n        old_routes, old_controller = @routes, @controller\n        create_routes(config, &block)\n      ensure\n        reset_routes(old_routes, old_controller)\n      end",
        "comment": "A helper to make it easier to test different route configurations. This method temporarily replaces @routes with a new RouteSet instance.  The new instance is yielded to the passed block. Typically the block will create some routes using `set.draw { match ... }`:  with_routing do |set| set.draw do resources :users end assert_equal \"/users\", users_path end ",
        "label": "How-to-use",
        "id": "11641"
    },
    {
        "raw_code": "def construct_js_keywords(js_files)\n        js_files.map do |js_file|\n          filename = js_file.scan(@first_js_folder_extract_regexp).flatten.first\n          singularize(filename)\n        end.uniq\n      end",
        "comment": "Extract keywords in the JS filenames to be used for searching matching system specs",
        "label": "How-to-use",
        "id": "8097"
    },
    {
        "raw_code": "def help\n      # We use the optionparser for this. Its just easier. We don't use\n      # an optionparser above because I don't think the performance hits\n      # of creating a whole object are worth checking only a couple flags.\n      opts = OptionParser.new do |o|\n        o.banner = \"Usage: vagrant [options] <command> [<args>]\"\n        o.separator \"\"\n        o.on(\"-v\", \"--version\", \"Print the version and exit.\")\n        o.on(\"-h\", \"--help\", \"Print this help.\")\n        o.separator \"\"\n        o.separator \"Common commands:\"\n\n        # Add the available subcommands as separators in order to print them\n        # out as well.\n        commands = {}\n        longest = 0\n        Vagrant.plugin(\"2\").manager.commands.each do |key, data|\n          # Skip non-primary commands. These only show up in extended\n          # help output.\n          next if !data[1][:primary]\n\n          key           = key.to_s\n          klass         = data[0].call\n          commands[key] = klass.synopsis\n          longest       = key.length if key.length > longest\n        end",
        "comment": "This prints out the help for the CLI.",
        "label": "How-to-use",
        "id": "8771"
    },
    {
        "raw_code": "def on_sequence(node)\n            first_child = node.child\n\n            if first_child.type == :node_type\n              children = [first_child.child, *process_children(node, 1..)]\n\n              # The `node_sequence` node contains the `node_type` symbol as its first child,\n              # followed by all the other nodes contained in the `sequence` node.\n              # The location is copied from the sequence, so that the entire sequence can\n              # eventually be corrected in the cop.\n              n(:node_sequence, children, location: node.location)\n            else\n              node.updated(nil, process_children(node))\n            end",
        "comment": "Look for `sequence` and `subsequence` nodes that contain a `node_type` node as their first child. These are rewritten as `node_sequence` nodes so that it is possible to compare nodes while looking for replacement candidates for node groups. This is necessary so that extended patterns can be matched and replaced. ie. `{(send _ :foo ...) (csend _ :foo ...)}` can become `(call _ :foo ...)`",
        "label": "How-to-use",
        "id": "10334"
    },
    {
        "raw_code": "def S(*args)\n          Section.new(*args)\n        end",
        "comment": "Alias for creating a {Section} with arguments @see Section#initialize @since 0.6.0",
        "label": "How-to-use",
        "id": "361"
    },
    {
        "raw_code": "def permission_table_for_reporter_issue_access\n    :public   | :enabled  | :admin      | true  | 1\n    :public   | :enabled  | :admin      | false | 0\n    :public   | :enabled  | :reporter   | nil   | 1\n    :public   | :enabled  | :guest      | nil   | 0\n    :public   | :enabled  | :non_member | nil   | 0\n    :public   | :enabled  | :anonymous  | nil   | 0\n\n    :public   | :private  | :admin      | true  | 1\n    :public   | :private  | :admin      | false | 0\n    :public   | :private  | :reporter   | nil   | 1\n    :public   | :private  | :guest      | nil   | 0\n    :public   | :private  | :non_member | nil   | 0\n    :public   | :private  | :anonymous  | nil   | 0\n\n    :public   | :disabled | :reporter   | nil   | 0\n    :public   | :disabled | :guest      | nil   | 0\n    :public   | :disabled | :non_member | nil   | 0\n    :public   | :disabled | :anonymous  | nil   | 0\n\n    :internal | :enabled  | :admin      | true  | 1\n    :internal | :enabled  | :admin      | false | 0\n    :internal | :enabled  | :reporter   | nil   | 1\n    :internal | :enabled  | :guest      | nil   | 0\n    :internal | :enabled  | :non_member | nil   | 0\n    :internal | :enabled  | :anonymous  | nil   | 0\n\n    :internal | :private  | :admin      | true  | 1\n    :internal | :private  | :admin      | false | 0\n    :internal | :private  | :reporter   | nil   | 1\n    :internal | :private  | :guest      | nil   | 0\n    :internal | :private  | :non_member | nil   | 0\n    :internal | :private  | :anonymous  | nil   | 0\n\n    :internal | :disabled | :reporter   | nil   | 0\n    :internal | :disabled | :guest      | nil   | 0\n    :internal | :disabled | :non_member | nil   | 0\n    :internal | :disabled | :anonymous  | nil   | 0\n\n    :private  | :private  | :admin      | true  | 1\n    :private  | :private  | :admin      | false | 0\n    :private  | :private  | :reporter   | nil   | 1\n    :private  | :private  | :guest      | nil   | 0\n    :private  | :private  | :non_member | nil   | 0\n    :private  | :private  | :anonymous  | nil   | 0\n\n    :private  | :disabled | :reporter   | nil   | 0\n    :private  | :disabled | :guest      | nil   | 0\n    :private  | :disabled | :non_member | nil   | 0\n    :private  | :disabled | :anonymous  | nil   | 0\n  end",
        "comment": "Based on the permission_table_for_reporter_feature_access table, but for issue features where public and internal projects with issues enabled only allow access to reporters and above (excluding admins if admin mode is disabled)  project_level, :feature_access_level, :membership, :admin_mode, :expected_count",
        "label": "How-to-use",
        "id": "8339"
    },
    {
        "raw_code": "def read_using_load_balancer(...)\n          if current_session.use_primary? &&\n              !current_session.use_replicas_for_read_queries?\n            @load_balancer.read_write do |connection|\n              connection.public_send(...)\n            end",
        "comment": "Performs a read using the load balancer.  name - The name of the method to call on a connection object.",
        "label": "How-to-use",
        "id": "3089"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_hard_break self\n  end",
        "comment": " Calls #accept_hard_break on +visitor+",
        "label": "How-to-use",
        "id": "16298"
    },
    {
        "raw_code": "def clear_action_methods!\n        @action_methods = nil\n      end",
        "comment": "action_methods are cached and there is sometimes a need to refresh them. ::clear_action_methods! allows you to do that, so next time you run action_methods, they will be recalculated.",
        "label": "How-to-use",
        "id": "11178"
    },
    {
        "raw_code": "def unlock_merge_requests(merge_requests)\n      errors = Hash.new { |h, k| h[k] = [] }\n\n      merge_requests.each do |mr|\n        mjid = mr.merge_jid\n\n        if mr.unlock_mr\n          mr.remove_from_locked_set\n          next\n        end",
        "comment": "Do not reopen merge requests using direct queries. We rely on state machine callbacks to update head_pipeline_id",
        "label": "How-to-use",
        "id": "5575"
    },
    {
        "raw_code": "def remove_from_maintenance(conn)\n          synchronize do\n            @maintaining -= 1\n            remove conn\n          end",
        "comment": "Remove a connection from the pool after it has been checked out for maintenance. It will be automatically replaced with a new connection if necessary.",
        "label": "How-to-use",
        "id": "13039"
    },
    {
        "raw_code": "def eof?\n        @tempfile.eof?\n      end",
        "comment": "Shortcut for `tempfile.eof?`.",
        "label": "How-to-use",
        "id": "11490"
    },
    {
        "raw_code": "def with(*args)\n      raise ArgumentError, \"ActiveRecord::Relation#with does not accept a block\" if block_given?\n      check_if_method_has_arguments!(__callee__, args)\n      spawn.with!(*args)\n    end",
        "comment": "Add a Common Table Expression (CTE) that you can then reference within another SELECT statement.  Note: CTE's are only supported in MySQL for versions 8.0 and above. You will not be able to use CTE's with MySQL 5.7.  Post.with(posts_with_tags: Post.where(\"tags_count > ?\", 0)) # => ActiveRecord::Relation # WITH posts_with_tags AS ( #   SELECT * FROM posts WHERE (tags_count > 0) # ) # SELECT * FROM posts  You can also pass an array of sub-queries to be joined in a +UNION ALL+.  Post.with(posts_with_tags_or_comments: [Post.where(\"tags_count > ?\", 0), Post.where(\"comments_count > ?\", 0)]) # => ActiveRecord::Relation # WITH posts_with_tags_or_comments AS ( #  (SELECT * FROM posts WHERE (tags_count > 0)) #  UNION ALL #  (SELECT * FROM posts WHERE (comments_count > 0)) # ) # SELECT * FROM posts  Once you define Common Table Expression you can use custom +FROM+ value or +JOIN+ to reference it.  Post.with(posts_with_tags: Post.where(\"tags_count > ?\", 0)).from(\"posts_with_tags AS posts\") # => ActiveRecord::Relation # WITH posts_with_tags AS ( #  SELECT * FROM posts WHERE (tags_count > 0) # ) # SELECT * FROM posts_with_tags AS posts  Post.with(posts_with_tags: Post.where(\"tags_count > ?\", 0)).joins(\"JOIN posts_with_tags ON posts_with_tags.id = posts.id\") # => ActiveRecord::Relation # WITH posts_with_tags AS ( #   SELECT * FROM posts WHERE (tags_count > 0) # ) # SELECT * FROM posts JOIN posts_with_tags ON posts_with_tags.id = posts.id  It is recommended to pass a query as ActiveRecord::Relation. If that is not possible and you have verified it is safe for the database, you can pass it as SQL literal using +Arel+.  Post.with(popular_posts: Arel.sql(\"... complex sql to calculate posts popularity ...\"))  Great caution should be taken to avoid SQL injection vulnerabilities. This method should not be used with unsafe values that include unsanitized input.  To add multiple CTEs just pass multiple key-value pairs  Post.with( posts_with_comments: Post.where(\"comments_count > ?\", 0), posts_with_tags: Post.where(\"tags_count > ?\", 0) )  or chain multiple +.with+ calls  Post .with(posts_with_comments: Post.where(\"comments_count > ?\", 0)) .with(posts_with_tags: Post.where(\"tags_count > ?\", 0))",
        "label": "How-to-use",
        "id": "13395"
    },
    {
        "raw_code": "def checkout_for_maintenance(conn)\n          synchronize do\n            @maintaining += 1\n            @available.delete(conn)\n            conn.lease\n            conn\n          end",
        "comment": "Directly check a specific connection out of the pool. Skips callbacks.  The connection must later either #return_from_maintenance or #remove_from_maintenance, or the pool will hang.",
        "label": "How-to-use",
        "id": "13037"
    },
    {
        "raw_code": "def inflate_query_with_typenames(query, doc: Graphlyte.parse(query))\n    typename_editor.edit(doc)\n\n    doc.to_s\n  end",
        "comment": "Private: Parse a GraphQL query and inflate the fields with a __typename  query - the GraqhQL query to parse",
        "label": "How-to-use",
        "id": "8500"
    },
    {
        "raw_code": "def handle_line_breaks(node)\n        return unless node.content.strip.lines.length > 1\n\n        node.content = \"#{node.content.lines.first.chomp}...\"\n        @truncated = true\n      end",
        "comment": "Handle line breaks within a node",
        "label": "How-to-use",
        "id": "3448"
    },
    {
        "raw_code": "def select_work_item_type(type)\n    select type.to_s.capitalize, from: 'Type'\n  end",
        "comment": "Listbox helpers",
        "label": "How-to-use",
        "id": "8492"
    },
    {
        "raw_code": "def self.reset_pool_repositories!\n        ::Backup::Restore::PoolRepositories.reinitialize_pools! do |pool_result|\n          puts pool_result.to_h.to_json\n        end",
        "comment": "A Backup only includes regular repositories, after a restore we need to reinitialize their respective pools. This process is done by changing its original state to 'none' and scheduling its creation process again",
        "label": "How-to-use",
        "id": "3740"
    },
    {
        "raw_code": "def gitlab_sign_in(user_or_role, **kwargs)\n    user =\n      if user_or_role.is_a?(User)\n        user_or_role\n      else\n        create(user_or_role) # rubocop:disable Rails/SaveBang\n      end",
        "comment": "Internal: Log in as a specific user or a new user of a specific role  user_or_role - User object, or a role to create (e.g., :admin, :user)  Examples:  # Create a user automatically gitlab_sign_in(:user)  # Create an admin automatically gitlab_sign_in(:admin)  # Provide an existing User record user = create(:user) gitlab_sign_in(user)",
        "label": "How-to-use",
        "id": "8488"
    },
    {
        "raw_code": "def after_update_commit(*args, &block)\n        set_options_for_callbacks!(args, on: :update, **prepend_option)\n        set_callback(:commit, :after, *args, &block)\n      end",
        "comment": "Shortcut for <tt>after_commit :hook, on: :update</tt>.",
        "label": "How-to-use",
        "id": "12723"
    },
    {
        "raw_code": "def _bulk_insert_callback_allowed?(name, args)\n        super || (args.first == :after && args.second == :check_partition_cascade_value)\n      end",
        "comment": "Allowing partition callback to be used with BulkInsertSafe",
        "label": "How-to-use",
        "id": "8528"
    },
    {
        "raw_code": "def created_job_ids_in_stage(stage_position)\n          all_jobs_grouped_by_stage_position[stage_position]\n            .to_a\n            .select { |job| job[:status] == 'created' }\n            .map { |job| job[:id] }\n        end",
        "comment": "This methods gets a list of jobs for a given stage",
        "label": "How-to-use",
        "id": "5827"
    },
    {
        "raw_code": "def lock_machine(uuid)\n      lock_path = @data_dir.join(\"#{uuid}.lock\")\n      lock_file = lock_path.open(\"w+\")\n      if lock_file.flock(File::LOCK_EX | File::LOCK_NB) === false\n        lock_file.close\n        lock_file = nil\n      end",
        "comment": "Locks a machine exclusively to us, returning the file handle that holds the lock.  If the lock cannot be acquired, then nil is returned.  This should be called within an index lock.  @return [File]",
        "label": "How-to-use",
        "id": "8762"
    },
    {
        "raw_code": "def mark_for_destruction\n      @marked_for_destruction = true\n    end",
        "comment": "Marks this record to be destroyed as part of the parent's save transaction. This does _not_ actually destroy the record instantly, rather child record will be destroyed when <tt>parent.save</tt> is called.  Only useful if the <tt>:autosave</tt> option on the parent is enabled for this associated model.",
        "label": "How-to-use",
        "id": "12378"
    },
    {
        "raw_code": "def wiki_size\n    super.to_i\n  end",
        "comment": "`wiki_size` and `snippets_size` have no default value in the database and the column can be nil. This means that, when the columns were added, all rows had nil values on them. Therefore, any call to any of those methods will return nil instead of 0.  These two methods provide consistency and avoid returning nil.",
        "label": "How-to-use",
        "id": "7000"
    },
    {
        "raw_code": "def cross_reference(mentioned_in)\n      return if cross_reference_disallowed?(mentioned_in)\n\n      from = noteable.project || noteable.try(:group) || noteable.try(:namespace)\n\n      gfm_reference = mentioned_in.gfm_reference(from)\n      body = cross_reference_note_content(gfm_reference)\n\n      if noteable.is_a?(ExternalIssue)\n        Integrations::CreateExternalCrossReferenceWorker.perform_async(\n          noteable.project_id,\n          noteable.id,\n          mentioned_in.class.name,\n          mentioned_in.id,\n          author.id\n        )\n      else\n        track_cross_reference_action\n\n        created_at = mentioned_in.created_at if USE_COMMIT_DATE_FOR_CROSS_REFERENCE_NOTE && mentioned_in.is_a?(Commit)\n        create_note(NoteSummary.new(noteable, noteable.project, author, body, action: 'cross_reference', created_at: created_at), skip_touch_noteable: true)\n      end",
        "comment": "Called when a Mentionable (the `mentioned_in`) references another Mentionable (the `mentioned`, passed to this service as `noteable`).  Example Note text:  \"mentioned in #1\"  \"mentioned in !2\"  \"mentioned in 54f7727c\"  See cross_reference_note_content.  @param mentioned_in [Mentionable] @return [Note]",
        "label": "How-to-use",
        "id": "5619"
    },
    {
        "raw_code": "def keep_around_commit\n    project.repository.keep_around(self.merge_commit_sha, source: self.class.name)\n  end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "6996"
    },
    {
        "raw_code": "def self.alias_extension(old_ext, new_ext)\n    old_ext = old_ext.sub(/^\\.(.*)/, '\\1')\n    new_ext = new_ext.sub(/^\\.(.*)/, '\\1')\n\n    parser = can_parse_by_name \"xxx.#{old_ext}\"\n    return false unless parser\n\n    RDoc::Parser.parsers.unshift [/\\.#{new_ext}$/, parser]\n\n    true\n  end",
        "comment": " Alias an extension to another extension. After this call, files ending \"new_ext\" will be parsed using the same parser as \"old_ext\"",
        "label": "How-to-use",
        "id": "15545"
    },
    {
        "raw_code": "def scan\n    comment = remove_coding_comment @content\n    comment = remove_private_comment comment\n\n    comment = RDoc::Comment.new comment, @top_level\n\n    @top_level.comment = comment\n    @top_level\n  end",
        "comment": " Extract the file contents and attach them to the TopLevel as a comment",
        "label": "How-to-use",
        "id": "16132"
    },
    {
        "raw_code": "def hello\n        end",
        "comment": "Description of `hello` method.",
        "label": "How-to-use",
        "id": "10800"
    },
    {
        "raw_code": "def render_template(view, template, layout_name = nil, locals = {}) # :nodoc:\n      return [super.body] unless template.supports_streaming?\n\n      locals ||= {}\n      layout   = find_layout(layout_name, locals.keys, [formats.first])\n\n      Body.new do |buffer|\n        delayed_render(buffer, template, layout, view, locals)\n      end",
        "comment": "For streaming, instead of rendering a given a template, we return a Body object that responds to each. This object is initialized with a block that knows how to render the template.",
        "label": "How-to-use",
        "id": "12009"
    },
    {
        "raw_code": "def name\n    return @name if @name\n\n    @name =\n      @call_seq[/^.*?\\.(\\w+)/, 1] ||\n      @call_seq[/^.*?(\\w+)/, 1] ||\n      @call_seq if @call_seq\n  end",
        "comment": " Method name  If the method has no assigned name, it extracts it from #call_seq.",
        "label": "How-to-use",
        "id": "16792"
    },
    {
        "raw_code": "def attributes_at(_ref = nil)\n      info_attributes\n    end",
        "comment": "Override of a method called on Repository instances but sent via method_missing to Gitlab::Git::Repository where it is defined",
        "label": "How-to-use",
        "id": "7685"
    },
    {
        "raw_code": "def self.run(version=\"1\", &block)\n      # Store it for later\n      @last_procs ||= []\n      @last_procs << [version.to_s, block]\n    end",
        "comment": "This is the method which is called by all Vagrantfiles to configure Vagrant. This method expects a block which accepts a single argument representing an instance of the {Config::Top} class.  Note that the block is not run immediately. Instead, it's proc is stored away for execution later.",
        "label": "How-to-use",
        "id": "8883"
    },
    {
        "raw_code": "def initialize(attributes = {})\n      if (!attributes.is_a?(Hash))\n        fail ArgumentError, \"The input argument (attributes) must be a hash in `ErrorTrackingOpenAPI::StatsObjectGroupInner` initialize method\"\n      end",
        "comment": "Initializes the object @param [Hash] attributes Model attributes in the form of hash",
        "label": "How-to-use",
        "id": "970"
    },
    {
        "raw_code": "def para *a\n    @RM::Paragraph.new(*a)\n  end",
        "comment": " Shortcut for RDoc::Markup::Paragraph.new with +contents+",
        "label": "How-to-use",
        "id": "16880"
    },
    {
        "raw_code": "def ignored_columns=(columns)\n        check_model_columns(@only_columns.present?)\n        reload_schema_from_cache\n        @ignored_columns = columns.map(&:to_s).freeze\n      end",
        "comment": "Sets the columns names the model should ignore. Ignored columns won't have attribute accessors defined, and won't be referenced in SQL queries.  A common usage pattern for this method is to ensure all references to an attribute have been removed and deployed, before a migration to drop the column from the database has been deployed and run. Using this two step approach to dropping columns ensures there is no code that raises errors due to having a cached schema in memory at the time the schema migration is run.  For example, given a model where you want to drop the \"category\" attribute, first mark it as ignored:  class Project < ActiveRecord::Base # schema: #   id         :bigint #   name       :string, limit: 255 #   category   :string, limit: 255  self.ignored_columns += [:category] end  The schema still contains \"category\", but now the model omits it, so any meta-driven code or schema caching will not attempt to use the column:  Project.columns_hash[\"category\"] => nil  You will get an error if accessing that attribute directly, so ensure all usages of the column are removed (automated tests can help you find any usages).  user = Project.create!(name: \"First Project\") user.category # => raises NoMethodError",
        "label": "How-to-use",
        "id": "12517"
    },
    {
        "raw_code": "def alert_condition\n            ALERT_CONDITIONS[:above]\n          end",
        "comment": "By default SLIs are expected to be above SLOs, but there can be cases where we want it to be below SLO (eg: WAL rate). For such indicators the sub-class should override this default alert_condition.",
        "label": "How-to-use",
        "id": "3119"
    },
    {
        "raw_code": "def on_match_pattern(node)\n          return if target_ruby_version >= 3.0\n\n          check(node, [:operator].freeze)\n        end",
        "comment": "Handle one-line pattern matching syntax (`in`) with `Parser::Ruby27`.",
        "label": "How-to-use",
        "id": "10355"
    },
    {
        "raw_code": "def indent(amount, indent_string = nil, indent_empty_lines = false)\n    dup.tap { |_| _.indent!(amount, indent_string, indent_empty_lines) }\n  end",
        "comment": "Indents the lines in the receiver:  <<EOS.indent(2) def some_method some_code end EOS # => def some_method some_code end  The second argument, +indent_string+, specifies which indent string to use. The default is +nil+, which tells the method to make a guess by peeking at the first indented line, and fall back to a space if there is none.  \"  foo\".indent(2)        # => \"    foo\" \"foo\\n\\t\\tbar\".indent(2) # => \"\\t\\tfoo\\n\\t\\t\\t\\tbar\" \"foo\".indent(2, \"\\t\")    # => \"\\t\\tfoo\"  While +indent_string+ is typically one space or tab, it may be any string.  The third argument, +indent_empty_lines+, is a flag that says whether empty lines should be indented. Default is false.  \"foo\\n\\nbar\".indent(2)            # => \"  foo\\n\\n  bar\" \"foo\\n\\nbar\".indent(2, nil, true) # => \"  foo\\n  \\n  bar\" ",
        "label": "How-to-use",
        "id": "14361"
    },
    {
        "raw_code": "def convert_to_model(object)\n      object.respond_to?(:to_model) ? object.to_model : object\n    end",
        "comment": "Converts the given object to an Active Model compliant one.",
        "label": "How-to-use",
        "id": "11739"
    },
    {
        "raw_code": "def reset!\n        end",
        "comment": "Reset the communicator. For communicators which establish a persistent connection to the remote machine, this connection should be terminated and re-established. The communicator instance should be in a \"fresh\" state after calling this method.",
        "label": "How-to-use",
        "id": "9139"
    },
    {
        "raw_code": "def to_hash\n      copy = Hash[self]\n      copy.transform_values! { |v| convert_value_to_hash(v) }\n      copy_defaults(copy)\n    end",
        "comment": "Convert to a regular hash with string keys.",
        "label": "How-to-use",
        "id": "13892"
    },
    {
        "raw_code": "def dump_threads\n      signal(\"TTIN\")\n    end",
        "comment": "Signal this process to log backtraces for all threads. Useful if you have a frozen or deadlocked process which is still sending a heartbeat. This method is *asynchronous* and it can take 5-10 seconds.",
        "label": "How-to-use",
        "id": "5152"
    },
    {
        "raw_code": "def find_by_version(version)\n        @migrations[version.to_s]\n      end",
        "comment": "Find a specific migration by version",
        "label": "How-to-use",
        "id": "1116"
    },
    {
        "raw_code": "def columns_hash(pool, table_name)\n        @columns_hash.fetch(table_name) do\n          @columns_hash[deep_deduplicate(table_name)] = columns(pool, table_name).index_by(&:name).freeze\n        end",
        "comment": "Get the columns for a table as a hash, key is the column name value is the column object.",
        "label": "How-to-use",
        "id": "12988"
    },
    {
        "raw_code": "def on_send(node)\n                  return unless bad_method?(node)\n\n                  add_offense(node)\n                end",
        "comment": "Called on every `send` node (method call) while walking the AST. TODO: remove this method if inspecting `send` nodes is unneeded for your cop. By default, this is aliased to `on_csend` as well to handle method calls with safe navigation, remove the alias if this is unnecessary. If kept, ensure your tests cover safe navigation as well!",
        "label": "How-to-use",
        "id": "10228"
    },
    {
        "raw_code": "def quote_table_name_for_assignment(table, attr)\n        quote_table_name(\"#{table}.#{attr}\")\n      end",
        "comment": "Override to return the quoted table name for assignment. Defaults to table quoting.  This works for MySQL where table.column can be used to resolve ambiguity.  We override this in the sqlite3 and postgresql adapters to use only the column name (as per syntax requirements).",
        "label": "How-to-use",
        "id": "13095"
    },
    {
        "raw_code": "def find_or_initialize_by(attributes, &block)\n      find_by(attributes) || new(attributes, &block)\n    end",
        "comment": "Like #find_or_create_by, but calls {new}[rdoc-ref:Core.new] instead of {create}[rdoc-ref:Persistence::ClassMethods#create].",
        "label": "How-to-use",
        "id": "12630"
    },
    {
        "raw_code": "def get_loglevel\n        log_levels = [\"all\", \"garbage\", \"trace\", \"debug\", \"info\", \"warning\", \"error\", \"quiet\"]\n        if log_levels.include? @config.log_level\n          \" --log-level=#{@config.log_level}\"\n        else\n          \" --log-level=debug\"\n        end",
        "comment": "Get log output level option string to pass with the salt command",
        "label": "How-to-use",
        "id": "9876"
    },
    {
        "raw_code": "def timelogs\n    Timelog.in_group(self)\n  end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "7027"
    },
    {
        "raw_code": "def silence(&block)\n        each { |deprecator| deprecator.begin_silence }\n        block.call\n      ensure\n        each { |deprecator| deprecator.end_silence }\n      end",
        "comment": "Silences all deprecators in this collection for the duration of the given block.  See ActiveSupport::Deprecation#silence.",
        "label": "How-to-use",
        "id": "14437"
    },
    {
        "raw_code": "def factory_method_for_directive(directive)\n          @directive_factory_classes[directive]\n        end",
        "comment": "Returns the factory method used to parse the tag text for a specific directive  @param [Symbol] directive the directive name @return [Symbol] the factory method name for the tag @return [Class<Tag>,Symbol] the Tag class to use to parse the tag or the methods to call on the factory class @return [nil] if the tag is freeform text @since 0.8.0",
        "label": "How-to-use",
        "id": "239"
    },
    {
        "raw_code": "def full_paths\n          reset_full_paths unless defined? @cached_included_modules\n          return @full_paths if included_modules == @cached_included_modules\n\n          @cached_included_modules = included_modules\n          @full_paths = included_modules.inject([full_path]) do |paths, mod|\n            paths |= mod.full_paths if mod.respond_to?(:full_paths)\n            paths\n          end",
        "comment": "@return [Array<String>] a list of full paths @note This method caches path results. Paths should not be modified after this method is called; call {#reset_full_paths} to reset cache.",
        "label": "How-to-use",
        "id": "355"
    },
    {
        "raw_code": "def initialize(connection_name)\n      @database_configuration = Backup::DatabaseConfiguration.new(connection_name)\n      @backup_model = backup_model\n      @snapshot_id = nil\n\n      configure_backup_model\n    end",
        "comment": "Initializes a database connection  @param [String] connection_name the key from `database.yml` for multi-database connection configuration",
        "label": "How-to-use",
        "id": "3637"
    },
    {
        "raw_code": "def push(name, manager: Vagrant.plugin(\"2\").manager)\n      @logger.info(\"Getting push: #{name}\")\n\n      name = name.to_sym\n\n      pushes = self.vagrantfile.config.push.__compiled_pushes\n      if !pushes.key?(name)\n        raise Vagrant::Errors::PushStrategyNotDefined,\n          name: name,\n          pushes: pushes.keys\n      end",
        "comment": "This executes the push with the given name, raising any exceptions that occur.  @param name [String] Push plugin name @param manager [Vagrant::Plugin::Manager] Plugin Manager to use, defaults to the primary one registered but parameterized so it can be overridden in server mode  @see VagrantPlugins::CommandServe::Service::PushService Server mode behavior  Precondition: the push is not nil and exists.",
        "label": "How-to-use",
        "id": "8864"
    },
    {
        "raw_code": "def factory_method_for(tag)\n          @factory_methods[tag]\n        end",
        "comment": "Returns the factory method used to parse the tag text for a specific tag  @param [Symbol] tag the tag name @return [Symbol] the factory method name for the tag @return [Class<Tag>,Symbol] the Tag class to use to parse the tag or the method to call on the factory class @return [nil] if the tag is freeform text @since 0.6.0",
        "label": "How-to-use",
        "id": "238"
    },
    {
        "raw_code": "def conflicting_key_path?(key_path)\n        cli.global.metrics.any? do |existing_metric|\n          existing_metric.key_path == key_path\n        end",
        "comment": "Helper for #prompt_for_description",
        "label": "How-to-use",
        "id": "5326"
    },
    {
        "raw_code": "def retry\n      remove_job do |message|\n        msg = Sidekiq.load_json(message)\n        msg[\"retry_count\"] -= 1 if msg[\"retry_count\"]\n        Sidekiq::Client.push(msg)\n      end",
        "comment": "enqueue this job from the retry set so it will be executed at some point in the near future.",
        "label": "How-to-use",
        "id": "5128"
    },
    {
        "raw_code": "def self.action_hook(name, hook_name=nil, &block)\n          # The name is currently not used but we want it for the future.\n          hook_name = hook_name.to_s if hook_name\n\n          hook_name ||= ALL_ACTIONS\n          components.action_hooks[hook_name.to_sym] << block\n        end",
        "comment": "Registers a callback to be called when a specific action sequence is run. This allows plugin authors to hook into things like VM bootup, VM provisioning, etc.  @param [String] name Name of the action. @param [Symbol] hook_name The location to hook. If this isn't set, every middleware action is hooked. @return [Array] List of the hooks for the given action.",
        "label": "How-to-use",
        "id": "9103"
    },
    {
        "raw_code": "def access_level\n    if admin?\n      :admin\n    else\n      :regular\n    end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "7097"
    },
    {
        "raw_code": "def initialize(*args)\n        @name = @filename = @next_data = nil\n        if args.empty?\n          @raw_header = []\n          @header = nil\n          super(\"\")\n        else\n          @raw_header = EmptyRawHeader\n          @header = EmptyHeader\n          super(args.shift)\n          unless args.empty?\n            @next_data = self.class.new(*args)\n          end",
        "comment": " Creates a new FormData object.  +args+ is an Array of form data entries.  One FormData will be created for each entry.  This is called by WEBrick::HTTPUtils.parse_form_data for you",
        "label": "How-to-use",
        "id": "671"
    },
    {
        "raw_code": "def peek_read\n    @read.join('')\n  end",
        "comment": " Peek equivalent for get_tkread",
        "label": "How-to-use",
        "id": "16175"
    },
    {
        "raw_code": "def default_title=(string)\n    @title ||= string\n  end",
        "comment": " Set the title, but only if not already set. Used to set the title from a source file, so that a title set from the command line will have the priority.",
        "label": "How-to-use",
        "id": "15529"
    },
    {
        "raw_code": "def replace_sql(column, pattern, replacement)\n        quoted_pattern = Arel::Nodes::Quoted.new(pattern.to_s)\n        quoted_replacement = Arel::Nodes::Quoted.new(replacement.to_s)\n\n        replace = Arel::Nodes::NamedFunction.new(\n          \"regexp_replace\", [column, quoted_pattern, quoted_replacement]\n        )\n\n        Arel::Nodes::SqlLiteral.new(replace.to_sql)\n      end",
        "comment": "This will replace the first occurrence of a string in a column with the replacement using `regexp_replace`",
        "label": "How-to-use",
        "id": "3005"
    },
    {
        "raw_code": "def self.failure_reasons\n      { unknown_failure: 'The reason for the pipeline failure is unknown.',\n        config_error: 'The pipeline failed due to an error on the CI/CD configuration file.',\n        external_validation_failure: 'The external pipeline validation failed.',\n        user_not_verified: 'The pipeline failed due to the user not being verified.',\n        size_limit_exceeded: 'The pipeline size limit was exceeded.',\n        job_activity_limit_exceeded: 'The pipeline job activity limit was exceeded.',\n        deployments_limit_exceeded: 'The pipeline deployments limit was exceeded.',\n        project_deleted: 'The project associated with this pipeline was deleted.',\n        filtered_by_rules: Ci::Pipeline.rules_failure_message,\n        filtered_by_workflow_rules: Ci::Pipeline.workflow_rules_failure_message,\n        composite_identity_forbidden: 'This pipeline did not run because the code should be reviewed by a non-AI ' \\\n          'user first. Verify that all changes in this merge request are safe before running a new pipeline.',\n        pipeline_ref_creation_failure: 'Failed to create pipeline ref.' }\n    end",
        "comment": "We use a class method here instead of a constant, allowing EE to redefine the returned `Hash` more easily.",
        "label": "How-to-use",
        "id": "5414"
    },
    {
        "raw_code": "def validate_digest_response(request, realm, &password_procedure)\n        secret_key  = secret_token(request)\n        credentials = decode_credentials_header(request)\n        valid_nonce = validate_nonce(secret_key, request, credentials[:nonce])\n\n        if valid_nonce && realm == credentials[:realm] && opaque(secret_key) == credentials[:opaque]\n          password = password_procedure.call(credentials[:username])\n          return false unless password\n\n          method = request.get_header(\"rack.methodoverride.original_method\") || request.get_header(\"REQUEST_METHOD\")\n          uri    = credentials[:uri]\n\n          [true, false].any? do |trailing_question_mark|\n            [true, false].any? do |password_is_ha1|\n              _uri = trailing_question_mark ? uri + \"?\" : uri\n              expected = expected_response(method, _uri, credentials, password, password_is_ha1)\n              expected == credentials[:response]\n            end",
        "comment": "Returns false unless the request credentials response value matches the expected value. First try the password as a ha1 digest password. If this fails, then try it as a plain text password.",
        "label": "How-to-use",
        "id": "11275"
    },
    {
        "raw_code": "def route_params(key = nil)\n      if key\n        env[WebRouter::ROUTE_PARAMS][key]\n      else\n        env[WebRouter::ROUTE_PARAMS]\n      end",
        "comment": "Use like `route_params(:name)` within your action blocks key is required in 8.0, nil is only used for backwards compatibility",
        "label": "How-to-use",
        "id": "5210"
    },
    {
        "raw_code": "def _normalize_callback_options(options)\n        _normalize_callback_option(options, :only, :if)\n        _normalize_callback_option(options, :except, :unless)\n      end",
        "comment": "If `:only` or `:except` are used, convert the options into the `:if` and `:unless` options of ActiveSupport::Callbacks.  The basic idea is that `:only => :index` gets converted to `:if => proc {|c| c.action_name == \"index\" }`.  Note that `:only` has priority over `:if` in case they are used together.  only: :index, if: -> { true } # the :if option will be ignored.  Note that `:if` has priority over `:except` in case they are used together.  except: :index, if: -> { true } # the :except option will be ignored.  #### Options *   `only`   - The callback should be run only for this action. *   `except`  - The callback should be run for all actions except this action. ",
        "label": "How-to-use",
        "id": "11194"
    },
    {
        "raw_code": "def redirect_back(fallback_location:, allow_other_host: _allow_other_host, **args)\n      redirect_back_or_to fallback_location, allow_other_host: allow_other_host, **args\n    end",
        "comment": "Soft deprecated alias for #redirect_back_or_to where the `fallback_location` location is supplied as a keyword argument instead of the first positional argument.",
        "label": "How-to-use",
        "id": "11316"
    },
    {
        "raw_code": "def pick_template_for_etag(options)\n        unless options[:template] == false\n          options[:template] || lookup_context.find_all(action_name, _prefixes).first&.virtual_path\n        end",
        "comment": "Pick the template digest to include in the ETag. If the `:template` option is present, use the named template. If `:template` is `nil` or absent, use the default controller/action template. If `:template` is false, omit the template digest from the ETag.",
        "label": "How-to-use",
        "id": "11262"
    },
    {
        "raw_code": "def tokens_rpn\n            output = []\n            operators = []\n\n            @tokens.each do |token|\n              case token.type\n              when :value\n                output.push(token)\n              when :logical_operator\n                output.push(operators.pop) while token.lexeme.consume?(operators.last&.lexeme)\n\n                operators.push(token)\n              when :parenthesis_open\n                operators.push(token)\n              when :parenthesis_close\n                output.push(operators.pop) while token.lexeme.consume?(operators.last&.lexeme)\n\n                raise ParseError, 'Unmatched parenthesis' unless operators.last\n\n                operators.pop if operators.last.lexeme.type == :parenthesis_open\n              end",
        "comment": "Parse the expression into Reverse Polish Notation (See: Shunting-yard algorithm) Taken from: https://en.wikipedia.org/wiki/Shunting-yard_algorithm#The_algorithm_in_detail",
        "label": "How-to-use",
        "id": "2518"
    },
    {
        "raw_code": "def largest_possible_string(node)\n          # The maximum allowed length of a string value is:\n          # `Max` - end delimiter (quote) - continuation characters (space and slash)\n          max_length = max - 3\n          # If the string doesn't start at the beginning of the line, the max length is offset\n          max_length -= column_offset_between(node.loc, node.parent.loc) if node.parent\n          node.source[0...(max_length)]\n        end",
        "comment": "Find the largest possible substring of a string node to retain before a break",
        "label": "How-to-use",
        "id": "10378"
    },
    {
        "raw_code": "def calls_super # :nodoc:\n    false\n  end",
        "comment": " Attributes never call super.  See RDoc::AnyMethod#calls_super  An RDoc::Attr can show up in the method list in some situations (see Gem::ConfigFile)",
        "label": "How-to-use",
        "id": "16705"
    },
    {
        "raw_code": "def each(&block)\n      @items.each do |key, _|\n        yield key, get(key)\n      end",
        "comment": "Iterate over the keyspace.",
        "label": "How-to-use",
        "id": "8746"
    },
    {
        "raw_code": "def cleanup_concurrent_column_rename(table, old, new)\n        trigger_name = rename_trigger_name(table, old, new)\n\n        check_trigger_permissions!(table)\n\n        remove_rename_triggers(table, trigger_name)\n\n        remove_column(table, old)\n      end",
        "comment": "Cleans up a concurrent column name.  This method takes care of removing previously installed triggers as well as removing the old column.  table - The name of the database table. old - The name of the old column. new - The name of the new column.",
        "label": "How-to-use",
        "id": "2991"
    },
    {
        "raw_code": "def generate\n    setup\n\n    write_style_sheet\n    generate_index\n    generate_class_files\n    generate_file_files\n    generate_table_of_contents\n    @json_index.generate\n    @json_index.generate_gzipped\n\n    copy_static\n\n  rescue => e\n    debug_msg \"%s: %s\\n  %s\" % [\n      e.class.name, e.message, e.backtrace.join(\"\\n  \")\n    ]\n\n    raise\n  end",
        "comment": " Build the initial indices and output objects based on an array of TopLevel objects containing the extracted information.",
        "label": "How-to-use",
        "id": "16457"
    },
    {
        "raw_code": "def all_scenario_classes\n          foss_scenarios = scenario_classes(QA::Scenario::Test)\n          return foss_scenarios unless QA.const_defined?(\"QA::EE\")\n\n          foss_scenarios + scenario_classes(QA::EE::Scenario::Test)\n        end",
        "comment": "Get all defined scenarios  @return [Array<Class>]",
        "label": "How-to-use",
        "id": "4815"
    },
    {
        "raw_code": "def us_zones\n        country_zones(:us)\n      end",
        "comment": "A convenience method for returning a collection of TimeZone objects for time zones in the USA.",
        "label": "How-to-use",
        "id": "14558"
    },
    {
        "raw_code": "def update_all(updates)\n      raise ArgumentError, \"Empty list of attributes to change\" if updates.blank?\n\n      return 0 if @none\n\n      invalid_methods = INVALID_METHODS_FOR_UPDATE_AND_DELETE_ALL.select do |method|\n        value = @values[method]\n        method == :distinct ? value : value&.any?\n      end",
        "comment": "Updates all records in the current relation with details given. This method constructs a single SQL UPDATE statement and sends it straight to the database. It does not instantiate the involved models and it does not trigger Active Record callbacks or validations. However, values passed to #update_all will still go through Active Record's normal type casting and serialization. Returns the number of rows affected.  Note: As Active Record callbacks are not triggered, this method will not automatically update +updated_at+/+updated_on+ columns.  ==== Parameters  * +updates+ - A string, array, or hash representing the SET part of an SQL statement. Any strings provided will be type cast, unless you use +Arel.sql+. (Don't pass user-provided values to +Arel.sql+.)  ==== Examples  # Update all customers with the given attributes Customer.update_all wants_email: true  # Update all books with 'Rails' in their title Book.where('title LIKE ?', '%Rails%').update_all(author: 'David')  # Update all books that match conditions, but limit it to 5 ordered by date Book.where('title LIKE ?', '%Rails%').order(:created_at).limit(5).update_all(author: 'David')  # Update all invoices and set the number column to its id value. Invoice.update_all('number = id')  # Update all books with 'Rails' in their title Book.where('title LIKE ?', '%Rails%').update_all(title: Arel.sql(\"title + ' - volume 1'\"))",
        "label": "How-to-use",
        "id": "12644"
    },
    {
        "raw_code": "def prompt_for_password(message = 'Enter password: ')\n      unless $stdin.tty?\n        print(message)\n        return $stdin.gets.chomp\n      end",
        "comment": "Prompt the user to input a password  message - custom message to display before input",
        "label": "How-to-use",
        "id": "1668"
    },
    {
        "raw_code": "def on_start\n      end",
        "comment": "A hook to override that will be called when the job starts iterating.  It is called only once, for the first time. ",
        "label": "How-to-use",
        "id": "5224"
    },
    {
        "raw_code": "def sections(*args)\n        @sections = Section.new(nil, *args) unless args.empty?\n        @sections\n      end",
        "comment": "Sets the sections (and subsections) to be rendered for the template  @example Sets a set of erb sections sections :a, :b, :c # searches for a.erb, b.erb, c.erb @example Sets a set of method and erb sections sections :a, :b, :c # a is a method, the rest are erb files @example Sections with subsections sections :header, [:name, :children] # the above will call header.erb and only renders the subsections # if they are yielded by the template (see #yieldall) @param [Array<Symbol, String, Template, Array>] args the sections to use to render the template. For symbols and strings, the section will be executed as a method (if one exists), or rendered from the file \"name.erb\" where name is the section name. For templates, they will have {Template::ClassMethods#run} called on them. Any subsections can be yielded to using yield or {#yieldall}",
        "label": "How-to-use",
        "id": "363"
    },
    {
        "raw_code": "def prepare_async_index(table_name, column_name, **options)\n          Gitlab::Database::QueryAnalyzers::RestrictAllowedSchemas.require_ddl_mode!\n\n          if table_partitioned?(table_name)\n            raise ArgumentError, 'prepare_async_index can not be used on a partitioned ' \\\n              'table. Please use prepare_partitioned_async_index on the partitioned table.'\n          end",
        "comment": "Prepares an index for asynchronous creation.  Stores the index information in the postgres_async_indexes table to be created later. The index will be always be created CONCURRENTLY, so that option does not need to be given. If an existing asynchronous definition exists with the same name, the existing entry will be updated with the new definition.  If the requested index has already been created, it is not stored in the table for asynchronous creation.  Note: The `add_index_options` is the same method Rails uses to generate the index creation statements. As such, we can pass index creation options to the method the same as we would standard index creation.  Example usage:  INITIAL_PIPELINE_INDEX = 'tmp_index_vulnerability_occurrences_id_and_initial_pipline_id' INITIAL_PIPELINE_COLUMNS = [:id, :initial_pipeline_id]  prepare_async_index TABLE_NAME, INITIAL_PIPELINE_COLUMNS, name: INITIAL_PIPELINE_INDEX, where: 'initial_pipeline_id IS NULL'",
        "label": "How-to-use",
        "id": "3057"
    },
    {
        "raw_code": "def self.default_cli_options\n    @_default_cli_options = [] if !@_default_cli_options\n    @_default_cli_options.dup\n  end",
        "comment": "Array of default CLI options to automatically add to commands.  @return [Array<Proc>] Default optparse options",
        "label": "How-to-use",
        "id": "8835"
    },
    {
        "raw_code": "def erb(section, &block)\n        method_name = ErbCache.method_for(cache_filename(section)) do\n          erb_with(cache(section), cache_filename(section))\n        end",
        "comment": "@param [String, Symbol] section the section name @yield calls subsections to be rendered @return [String] the contents of the ERB rendered section",
        "label": "How-to-use",
        "id": "367"
    },
    {
        "raw_code": "def on_encrypted_attribute_declared(&block)\n          self.encrypted_attribute_declaration_listeners ||= Concurrent::Array.new\n          self.encrypted_attribute_declaration_listeners << block\n        end",
        "comment": "Register callback to be invoked when an encrypted attribute is declared.  === Example  ActiveRecord::Encryption.on_encrypted_attribute_declared do |klass, attribute_name| ... end",
        "label": "How-to-use",
        "id": "13300"
    },
    {
        "raw_code": "def unique_classes_and_modules\n    @unique_classes + @unique_modules\n  end",
        "comment": " Returns the unique classes and modules discovered by RDoc. ::complete must have been called prior to using this method.",
        "label": "How-to-use",
        "id": "15896"
    },
    {
        "raw_code": "def set(options = {})\n        ConfiguredJob.new(self, options)\n      end",
        "comment": "Creates a job preconfigured with the given options. You can call perform_later with the job arguments to enqueue the job with the preconfigured options  ==== Options * <tt>:wait</tt> - Enqueues the job with the specified delay * <tt>:wait_until</tt> - Enqueues the job at the time specified * <tt>:queue</tt> - Enqueues the job on the specified queue * <tt>:priority</tt> - Enqueues the job with the specified priority  ==== Examples  VideoJob.set(queue: :some_queue).perform_later(Video.last) VideoJob.set(wait: 5.minutes).perform_later(Video.last) VideoJob.set(wait_until: Time.now.tomorrow).perform_later(Video.last) VideoJob.set(queue: :some_queue, wait: 5.minutes).perform_later(Video.last) VideoJob.set(queue: :some_queue, wait_until: Time.now.tomorrow).perform_later(Video.last) VideoJob.set(queue: :some_queue, wait: 5.minutes, priority: 10).perform_later(Video.last)",
        "label": "How-to-use",
        "id": "12113"
    },
    {
        "raw_code": "def initialize(lock, other_cond, preferred_thread)\n            @real_cond = lock.new_cond\n            @other_cond = other_cond\n            @preferred_thread = preferred_thread\n            @num_waiting_on_real_cond = 0\n          end",
        "comment": "semantics of condition variables guarantee that +broadcast+, +broadcast_on_biased+, +signal+ and +wait+ methods are only called while holding a lock",
        "label": "How-to-use",
        "id": "13197"
    },
    {
        "raw_code": "def prepare_statement(sql, binds, conn)\n          sql_key = sql_key(sql)\n          unless @statements.key? sql_key\n            nextkey = @statements.next_key\n            begin\n              conn.prepare nextkey, sql\n            rescue => e\n              raise translate_exception_class(e, sql, binds)\n            end",
        "comment": "Prepare the statement if it hasn't been prepared, return the statement key.",
        "label": "How-to-use",
        "id": "12981"
    },
    {
        "raw_code": "def load_target\n        @target = find_target(async: false) if (@stale_state && stale_target?) || find_target?\n\n        loaded! unless loaded?\n        target\n      rescue ActiveRecord::RecordNotFound\n        reset\n      end",
        "comment": "Loads the \\target if needed and returns it.  This method is abstract in the sense that it relies on +find_target+, which is expected to be provided by descendants.  If the \\target is already \\loaded it is just returned. Thus, you can call +load_target+ unconditionally to get the \\target.  ActiveRecord::RecordNotFound is rescued within the method, and it is not reraised. The proxy is \\reset and +nil+ is the return value.",
        "label": "How-to-use",
        "id": "12753"
    },
    {
        "raw_code": "def generators(&blk)\n      self.class.generators(&blk)\n    end",
        "comment": "Sends any generators called in the instance of a new application up to the +generators+ method defined in Rails::Railtie.",
        "label": "How-to-use",
        "id": "14640"
    },
    {
        "raw_code": "def serialize_value(type:, value:)\n            return value if value.nil?\n\n            case type\n            when :string then serialize_string(value)\n            when :time then serialize_time(value)\n            when :integer then serialize_integer(value)\n            else\n              raise ArgumentError, \"Unknown data type key #{type.inspect} provided when serializing backup metadata\"\n            end",
        "comment": "Given a metadata value, prepare and format the value as a JSON primitive type before serializing  @param [Symbol] type @param [String|Time|Integer] value @return [Integer, String] the converted JSON primitive value",
        "label": "How-to-use",
        "id": "1076"
    },
    {
        "raw_code": "def self.route_key(record_or_class)\n      model_name_from_record_or_class(record_or_class).route_key\n    end",
        "comment": "Returns string to use while generating route names. It differs for namespaced models regarding whether it's inside isolated engine.  # For isolated engine: ActiveModel::Naming.route_key(Blog::Post) # => \"posts\"  # For shared engine: ActiveModel::Naming.route_key(Blog::Post) # => \"blog_posts\"  The route key also considers if the noun is uncountable and, in such cases, automatically appends _index.",
        "label": "How-to-use",
        "id": "12254"
    },
    {
        "raw_code": "def rating?\n    query_attribute :rating\n  end",
        "comment": "Used to test that read and question methods are not generated for these attributes",
        "label": "How-to-use",
        "id": "13582"
    },
    {
        "raw_code": "def fetch_next_page\n      extra_query = { pagelen: max_per_page }\n      extra_query[:page] = page_number if page_number && limit\n\n      parsed_response = connection.get(next_url, extra_query)\n      Page.new(parsed_response, type)\n    end",
        "comment": "Note to self for specs: - Allowed pagelen to be set by limit instead of just using PAGE_LENGTH - Allow specifying a starting page to grab one page at a time, so PageCounter can be used for logging - Added over_limit? to make sure only one page is called.",
        "label": "How-to-use",
        "id": "3361"
    },
    {
        "raw_code": "def parse_raw_content!\n        disallowed = []\n        allowed = []\n\n        @raw_content.each_line.each do |line|\n          if disallow_rule?(line)\n            disallowed << get_disallow_pattern(line)\n          elsif allow_rule?(line)\n            allowed << get_allow_pattern(line)\n          end",
        "comment": "This parser is very basic as it only knows about `Disallow:` and `Allow:` lines, and simply ignores all other lines.  Patterns ending in `$`, and `*` for 0 or more characters are recognized.  It is case insensitive and `Allow` rules takes precedence over `Disallow`.",
        "label": "How-to-use",
        "id": "2906"
    },
    {
        "raw_code": "def fragment_exist?(key, options = nil)\n        return unless cache_configured?\n        key = combined_fragment_cache_key(key)\n\n        instrument_fragment_cache :exist_fragment?, key do\n          cache_store.exist?(key, options)\n        end",
        "comment": "Check if a cached fragment from the location signified by `key` exists (see `expire_fragment` for acceptable formats).",
        "label": "How-to-use",
        "id": "11217"
    },
    {
        "raw_code": "def self.parse(virtual)\n      if nameidx = virtual.rindex(\"/\")\n        prefix = virtual[0, nameidx]\n        name = virtual.from(nameidx + 1)\n        prefix = prefix[1..] if prefix.start_with?(\"/\")\n      else\n        prefix = \"\"\n        name = virtual\n      end",
        "comment": "Build a TemplatePath form a virtual path",
        "label": "How-to-use",
        "id": "11764"
    },
    {
        "raw_code": "def initialize(query_builder:, connection:, min_value: nil, min_max_strategy: :min_max)\n      @query_builder = query_builder\n      @connection = connection\n      @min_value = min_value\n      @min_max_strategy = min_max_strategy\n    end",
        "comment": "rubocop: disable CodeReuse/ActiveRecord -- this is a ClickHouse query builder class usin Arel",
        "label": "How-to-use",
        "id": "3538"
    },
    {
        "raw_code": "def do_something\n        end",
        "comment": "{method} Foo",
        "label": "How-to-use",
        "id": "10813"
    },
    {
        "raw_code": "def define_tag(label, tag, meth = nil)\n          tag_meth = tag_method_name(tag)\n          if meth.is_a?(Class) && Tag > meth\n            class_eval(<<-eof, __FILE__, __LINE__ + 1)\n              def #{tag_meth}(text)\n                #{meth}.new(#{tag.inspect}, text)\n              end\n            eof\n          else\n            class_eval(<<-eof, __FILE__, __LINE__ + 1)\n              begin; undef #{tag_meth}; rescue NameError; end\n              def #{tag_meth}(text)\n                send_to_factory(#{tag.inspect}, #{meth.inspect}, text)\n              end\n            eof\n          end",
        "comment": "Convenience method to define a new tag using one of {Tag}'s factory methods, or the regular {DefaultFactory#parse_tag} factory method if none is supplied.  @!macro [attach] yard.tag @!method $2_tag @!visibility private @yard.tag $2 [$3] $1 @param [#to_s] label the label used when displaying the tag in templates @param [#to_s] tag the tag name to create @param [#to_s, Class<Tag>] meth the {Tag} factory method to call when creating the tag or the name of the class to directly create a tag for",
        "label": "How-to-use",
        "id": "241"
    },
    {
        "raw_code": "def scan(match, count = 100)\n      return to_enum(:scan, match, count) unless block_given?\n\n      match = \"*#{match}*\" unless match.include?(\"*\")\n      Sidekiq.redis do |conn|\n        conn.zscan(name, match: match, count: count) do |entry, score|\n          yield SortedEntry.new(self, score, entry)\n        end",
        "comment": "Scan through each element of the sorted set, yielding each to the supplied block. Please see Redis's <a href=\"https://redis.io/commands/scan/\">SCAN documentation</a> for implementation details.  @param match [String] a snippet or regexp to filter matches. @param count [Integer] number of elements to retrieve at a time, default 100 @yieldparam [Sidekiq::SortedEntry] each entry",
        "label": "How-to-use",
        "id": "5132"
    },
    {
        "raw_code": "def order(*args)\n      check_if_method_has_arguments!(__callee__, args) do\n        sanitize_order_arguments(args)\n      end",
        "comment": "Applies an <code>ORDER BY</code> clause to a query.  #order accepts arguments in one of several formats.  === symbols  The symbol represents the name of the column you want to order the results by.  User.order(:name) # SELECT \"users\".* FROM \"users\" ORDER BY \"users\".\"name\" ASC  By default, the order is ascending. If you want descending order, you can map the column name symbol to +:desc+.  User.order(email: :desc) # SELECT \"users\".* FROM \"users\" ORDER BY \"users\".\"email\" DESC  Multiple columns can be passed this way, and they will be applied in the order specified.  User.order(:name, email: :desc) # SELECT \"users\".* FROM \"users\" ORDER BY \"users\".\"name\" ASC, \"users\".\"email\" DESC  === strings  Strings are passed directly to the database, allowing you to specify simple SQL expressions.  This could be a source of SQL injection, so only strings composed of plain column names and simple <code>function(column_name)</code> expressions with optional +ASC+/+DESC+ modifiers are allowed.  User.order('name') # SELECT \"users\".* FROM \"users\" ORDER BY name  User.order('name DESC') # SELECT \"users\".* FROM \"users\" ORDER BY name DESC  User.order('name DESC, email') # SELECT \"users\".* FROM \"users\" ORDER BY name DESC, email  === Arel  If you need to pass in complicated expressions that you have verified are safe for the database, you can use Arel.  User.order(Arel.sql('end_date - start_date')) # SELECT \"users\".* FROM \"users\" ORDER BY end_date - start_date  Custom query syntax, like JSON columns for PostgreSQL, is supported in this way.  User.order(Arel.sql(\"payload->>'kind'\")) # SELECT \"users\".* FROM \"users\" ORDER BY payload->>'kind'",
        "label": "How-to-use",
        "id": "13404"
    },
    {
        "raw_code": "def _prefixes # :nodoc:\n      self.class._prefixes\n    end",
        "comment": "The prefixes used in render \"foo\" shortcuts.",
        "label": "How-to-use",
        "id": "11776"
    },
    {
        "raw_code": "def standby_team(config)\n      @team_by_config ||= {}.compare_by_identity\n      @team_by_config[config] ||=\n        Cop::Team.mobilize(mobilized_cop_classes(config), config, @options)\n    end",
        "comment": "rubocop:enable Metrics/MethodLength A Cop::Team instance is stateful and may change when inspecting. The \"standby\" team for a given config is an initialized but otherwise dormant team that can be used for config- and option- level caching in ResultCache.",
        "label": "How-to-use",
        "id": "10057"
    },
    {
        "raw_code": "def render(*args)\n      raise ::AbstractController::DoubleRenderError if response_body\n      super\n    end",
        "comment": "Renders a template and assigns the result to `self.response_body`.  If no rendering mode option is specified, the template will be derived from the first argument.  render \"posts/show\" # => renders app/views/posts/show.html.erb  # In a PostsController action... render :show # => renders app/views/posts/show.html.erb  If the first argument responds to `render_in`, the template will be rendered by calling `render_in` with the current view context.  class Greeting def render_in(view_context) view_context.render html: \"<h1>Hello, World</h1>\" end  def format :html end end  render(Greeting.new) # => \"<h1>Hello, World</h1>\"  render(renderable: Greeting.new) # => \"<h1>Hello, World</h1>\"  #### Rendering Mode  `:partial` :   See ActionView::PartialRenderer for details.  render partial: \"posts/form\", locals: { post: Post.new } # => renders app/views/posts/_form.html.erb  `:file` :   Renders the contents of a file. This option should **not** be used with unsanitized user input.  render file: \"/path/to/some/file\" # => renders /path/to/some/file  `:inline` :   Renders an ERB template string.  @name = \"World\" render inline: \"<h1>Hello, <%= @name %>!</h1>\" # => renders \"<h1>Hello, World!</h1>\"  `:body` :   Renders the provided text, and sets the content type as `text/plain`.  render body: \"Hello, World!\" # => renders \"Hello, World!\"  `:plain` :   Renders the provided text, and sets the content type as `text/plain`.  render plain: \"Hello, World!\" # => renders \"Hello, World!\"  `:html` :   Renders the provided HTML string, and sets the content type as `text/html`. If the string is not `html_safe?`, performs HTML escaping on the string before rendering.  render html: \"<h1>Hello, World!</h1>\".html_safe # => renders \"<h1>Hello, World!</h1>\"  render html: \"<h1>Hello, World!</h1>\" # => renders \"&lt;h1&gt;Hello, World!&lt;/h1&gt;\"  `:json` :   Renders the provided object as JSON, and sets the content type as `application/json`. If the object is not a string, it will be converted to JSON by calling `to_json`.  render json: { hello: \"world\" } # => renders \"{\\\"hello\\\":\\\"world\\\"}\"  `:renderable` :   Renders the provided object by calling `render_in` with the current view context. The response format is determined by calling `format` on the renderable if it responds to `format`, falling back to `text/html` by default.  render renderable: Greeting.new # => renders \"<h1>Hello, World</h1>\"   By default, when a rendering mode is specified, no layout template is rendered.  #### Options  `:assigns` :   Hash of instance variable assignments for the template.  render inline: \"<h1>Hello, <%= @name %>!</h1>\", assigns: { name: \"World\" } # => renders \"<h1>Hello, World!</h1>\"  `:locals` :   Hash of local variable assignments for the template.  render inline: \"<h1>Hello, <%= name %>!</h1>\", locals: { name: \"World\" } # => renders \"<h1>Hello, World!</h1>\"  `:layout` :   The layout template to render. Can also be `false` or `true` to disable or (re)enable the default layout template.  render \"posts/show\", layout: \"holiday\" # => renders app/views/posts/show.html.erb with the app/views/layouts/holiday.html.erb layout  render \"posts/show\", layout: false # => renders app/views/posts/show.html.erb with no layout  render inline: \"<h1>Hello, World!</h1>\", layout: true # => renders \"<h1>Hello, World!</h1>\" with the default layout  `:status` :   The HTTP status code to send with the response. Can be specified as a number or as the status name in Symbol form. Defaults to 200.  render \"posts/new\", status: 422 # => renders app/views/posts/new.html.erb with HTTP status code 422  render \"posts/new\", status: :unprocessable_entity # => renders app/views/posts/new.html.erb with HTTP status code 422  `:variants` :  This tells Rails to look for the first template matching any of the variations.  render \"posts/index\", variants: [:mobile] # => renders app/views/posts/index.html+mobile.erb  -- Check for double render errors and set the content_type after rendering.",
        "label": "How-to-use",
        "id": "11325"
    },
    {
        "raw_code": "def load_schema!\n      expect(model).to receive(:load_schema!).and_call_original\n\n      model.new\n    end",
        "comment": "load_schema! is not a documented class method, so use a documented method that we know will call load_schema!",
        "label": "How-to-use",
        "id": "8295"
    },
    {
        "raw_code": "def visibility_level_allowed_as_fork?(level = self.visibility_level)\n    return true unless forked?\n\n    original_project = fork_source\n    return true unless original_project\n\n    level <= original_project.visibility_level\n  end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "6757"
    },
    {
        "raw_code": "def render(*args, &block)\n      options = _normalize_render(*args, &block)\n      rendered_body = render_to_body(options)\n      if options[:html]\n        _set_html_content_type\n      else\n        _set_rendered_content_type rendered_format\n      end",
        "comment": "Normalizes arguments and options, and then delegates to render_to_body and sticks the result in `self.response_body`.  Supported options depend on the underlying `render_to_body` implementation.",
        "label": "How-to-use",
        "id": "11201"
    },
    {
        "raw_code": "def saved_changes?\n        mutations_before_last_save.any_changes?\n      end",
        "comment": "Did the last call to +save+ have any changes to change?",
        "label": "How-to-use",
        "id": "12842"
    },
    {
        "raw_code": "def initialize(app, options = {})\n        @app = app\n        @paths = Array(options[:paths])\n      end",
        "comment": "Initializes the middleware.  @param app [Rack application] The Rack application. @param options [Hash] The options to customize the middleware behavior. @option options [Array<Regexp>] :paths The regular expressions to match against the path when cookies should be deleted.",
        "label": "How-to-use",
        "id": "2030"
    },
    {
        "raw_code": "def collection_select(object, method, collection, value_method, text_method, options = {}, html_options = {})\n        Tags::CollectionSelect.new(object, method, self, collection, value_method, text_method, options, html_options).render\n      end",
        "comment": "Returns <tt><select></tt> and <tt><option></tt> tags for the collection of existing return values of +method+ for +object+'s class. The value returned from calling +method+ on the instance +object+ will be selected. If calling +method+ returns +nil+, no selection is made without including <tt>:prompt</tt> or <tt>:include_blank</tt> in the +options+ hash.  The <tt>:value_method</tt> and <tt>:text_method</tt> parameters are methods to be called on each member of +collection+. The return values are used as the +value+ attribute and contents of each <tt><option></tt> tag, respectively. They can also be any object that responds to +call+, such as a +proc+, that will be called for each member of the +collection+ to retrieve the value/text.  Example object structure for use with this method:  class Post < ActiveRecord::Base belongs_to :author end  class Author < ActiveRecord::Base has_many :posts  def name_with_initial \"#{first_name.first}. #{last_name}\" end end  Sample usage (selecting the associated Author for an instance of Post, <tt>@post</tt>):  collection_select(:post, :author_id, Author.all, :id, :name_with_initial, prompt: true)  If <tt>@post.author_id</tt> is already <tt>1</tt>, this would return: <select name=\"post[author_id]\" id=\"post_author_id\"> <option value=\"\">Please select</option> <option value=\"1\" selected=\"selected\">D. Heinemeier Hansson</option> <option value=\"2\">D. Thomas</option> <option value=\"3\">M. Clark</option> </select>",
        "label": "How-to-use",
        "id": "11899"
    },
    {
        "raw_code": "def delete_all(dependent = nil)\n        if dependent && ![:nullify, :delete_all].include?(dependent)\n          raise ArgumentError, \"Valid values are :nullify or :delete_all\"\n        end",
        "comment": "Removes all records from the association without calling callbacks on the associated records. It honors the +:dependent+ option. However if the +:dependent+ value is +:destroy+ then in that case the +:delete_all+ deletion strategy for the association is applied.  You can force a particular deletion strategy by passing a parameter.  Example:  @author.books.delete_all(:nullify) @author.books.delete_all(:delete_all)  See delete for more info.",
        "label": "How-to-use",
        "id": "12771"
    },
    {
        "raw_code": "def execute(command, opts=nil)\n        end",
        "comment": "Execute a command on the remote machine. The exact semantics of this method are up to the implementor, but in general the users of this class will expect this to be a shell.  This method gives you no way to write data back to the remote machine, so only execute commands that don't expect input.  @param [String] command Command to execute. @yield [type, data] Realtime output of the command being executed. @yieldparam [String] type Type of the output. This can be `:stdout`, `:stderr`, etc. The exact types are up to the implementor. @yieldparam [String] data Data for the given output. @return [Integer] Exit code of the command.",
        "label": "How-to-use",
        "id": "9136"
    },
    {
        "raw_code": "def normalize_expected_order(config_array)\n          expected_positions = []\n\n          EXPECTED_SEQUENCE.each_with_index do |expected, _|\n            config_array.each do |item|\n              item => {\n                kind: String => item_kind,\n                metadata: {\n                  name: String => item_name\n                }\n              }\n\n              expected_positions << \"#{item_kind}/#{item_name}\" if matches?(item_kind, item_name, expected)\n            end",
        "comment": "This method normalizes the expected order of items based on the config array It creates a mapping of expected positions for each kind/name combination  @param [Array] config_array The array of configuration items to normalize @return [Array] An array with expected order of items",
        "label": "How-to-use",
        "id": "3300"
    },
    {
        "raw_code": "def change_host_name(name)\n          raise BaseError, _key: :unsupported_host_name\n        end",
        "comment": "Called to change the hostname of the virtual machine.",
        "label": "How-to-use",
        "id": "9019"
    },
    {
        "raw_code": "def sanitize_sql_for_assignment(assignments, default_table_name = table_name)\n        case assignments\n        when Array; sanitize_sql_array(assignments)\n        when Hash;  sanitize_sql_hash_for_assignment(assignments, default_table_name)\n        else        assignments\n        end",
        "comment": "Accepts an array or hash of SQL conditions and sanitizes them into a valid SQL fragment for a SET clause.  sanitize_sql_for_assignment([\"name=? and group_id=?\", nil, 4]) # => \"name=NULL and group_id=4\"  sanitize_sql_for_assignment([\"name=:name and group_id=:group_id\", name: nil, group_id: 4]) # => \"name=NULL and group_id=4\"  Post.sanitize_sql_for_assignment({ name: nil, group_id: 4 }) # => \"`posts`.`name` = NULL, `posts`.`group_id` = 4\"  This method will NOT sanitize an SQL string since it won't contain any conditions in it and will return the string as is.  sanitize_sql_for_assignment(\"name=NULL and group_id='4'\") # => \"name=NULL and group_id='4'\"  Note that this sanitization method is not schema-aware, hence won't do any type casting and will directly use the database adapter's +quote+ method. For MySQL specifically this means that numeric parameters will be quoted as strings to prevent query manipulation attacks.  sanitize_sql_for_assignment([\"role = ?\", 0]) # => \"role = '0'\"",
        "label": "How-to-use",
        "id": "12677"
    },
    {
        "raw_code": "def patch_fromText(textline)\n    return []  if textline.empty?\n\n    patches = []\n    text = textline.split(\"\\n\")\n    text_pointer = 0\n    patch_header = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/\n    while text_pointer < text.length\n      m = text[text_pointer].match(patch_header)\n      if m.nil?\n        raise ArgumentError.new(\"Invalid patch string: #{text[text_pointer]}\")\n      end",
        "comment": "Parse a textual representation of patches and return a list of patch objects.",
        "label": "How-to-use",
        "id": "5072"
    },
    {
        "raw_code": "def ignore\n    return unless @track_visibility\n\n    @ignored = true\n\n    stop_doc\n  end",
        "comment": " Use this to ignore a CodeObject and all its children until found again (#record_location is called).  An ignored item will not be displayed in documentation.  See github issue #55  The ignored status is temporary in order to allow implementation details to be hidden.  At the end of processing a file RDoc allows all classes and modules to add new documentation to previously created classes.  If a class was ignored (via stopdoc) then reopened later with additional documentation it should be displayed.  If a class was ignored and never reopened it should not be displayed.  The ignore flag allows this to occur.",
        "label": "How-to-use",
        "id": "15920"
    },
    {
        "raw_code": "def initialize(machine)\n        end",
        "comment": "Initialize the provider to represent the given machine.  @param [Vagrant::Machine] machine The machine that this provider is responsible for.",
        "label": "How-to-use",
        "id": "9053"
    },
    {
        "raw_code": "def install_provider(name)\n      host.capability(provider_install_key(name))\n    end",
        "comment": "Installs the provider with the given name.  This will raise an exception if we don't know how to install the provider with the given name. You should guard this call with `can_install_provider?` for added safety.  An exception will be raised if there are any failures installing the provider.",
        "label": "How-to-use",
        "id": "8857"
    },
    {
        "raw_code": "def generate_username(email)\n          return unless valid_email_username_length?(email)\n\n          username = mb_chars_unicode_normalize(email.match(/^[^@]*/)[0])\n          username if valid_email_username_length?(username)\n        end",
        "comment": "Get the first part of the email address (before @) In addition in removes illegal characters Perform length validation twice: - Before normalization to prevent normalizing excessively long strings - After normalization to ensure certain normalized multibyte characters don't exceed length.",
        "label": "How-to-use",
        "id": "2361"
    },
    {
        "raw_code": "def list type = nil, *items\n    @RM::List.new type, *items\n  end",
        "comment": " Shortcut for RDoc::Markup::List.new with +type+ and +items+",
        "label": "How-to-use",
        "id": "16878"
    },
    {
        "raw_code": "def event_action\n      raise NotImplementedError\n    end",
        "comment": "Used to create `Event` records. Must be a valid value for `Event#action`",
        "label": "How-to-use",
        "id": "5975"
    },
    {
        "raw_code": "def check_validity!\n    end",
        "comment": "Hook method that gets called by the initializer allowing verification that the arguments supplied are valid. You could for example raise an +ArgumentError+ when invalid options are supplied.",
        "label": "How-to-use",
        "id": "12283"
    },
    {
        "raw_code": "def log_timed(log_message, start = Time.now)\n        check_timeout_reached\n\n        timed = true\n\n        yield\n\n        append_message(log_message + time_suffix_message(start: start))\n      rescue GRPC::DeadlineExceeded, TimeoutError\n        args = { cancelled: true }\n        args[:start] = start if timed\n\n        append_message(log_message + time_suffix_message(**args))\n\n        raise TimeoutError\n      end",
        "comment": "Adds trace of method being tracked with the correspondent time it took to run it. We make use of the start default argument on unit tests related to this method ",
        "label": "How-to-use",
        "id": "2074"
    },
    {
        "raw_code": "def find_symbol(symbol)\n    find_symbol_module(symbol) || find_local_symbol(symbol)\n  end",
        "comment": " Look up +symbol+, first as a module, then as a local symbol.",
        "label": "How-to-use",
        "id": "16674"
    },
    {
        "raw_code": "def from_rails_enum(enum, description:)\n        enum.each_key do |name|\n          value name.to_s.upcase,\n            value: name,\n            description: format(description, name: name)\n        end",
        "comment": "Helper to define an enum member for each element of a Rails AR enum",
        "label": "How-to-use",
        "id": "6203"
    },
    {
        "raw_code": "def jsonify(value)\n            case value\n            when String, Integer, Symbol, nil, true, false\n              value\n            when Numeric\n              value.as_json\n            when Hash\n              result = {}\n              value.each do |k, v|\n                k = k.to_s unless Symbol === k || String === k\n                result[k] = jsonify(v)\n              end",
        "comment": "Convert an object into a \"JSON-ready\" representation composed of primitives like Hash, Array, String, Symbol, Numeric, and +true+/+false+/+nil+. Recursively calls #as_json to the object to recursively build a fully JSON-ready object.  This allows developers to implement #as_json without having to worry about what base types of objects they are allowed to return or having to remember to call #as_json recursively.  Note: the +options+ hash passed to +object.to_json+ is only passed to +object.as_json+, not any of this method's recursive +#as_json+ calls.",
        "label": "How-to-use",
        "id": "14486"
    },
    {
        "raw_code": "def corrector(node)\n        ->(corrector) do\n          corrector.insert_after(\n            node,\n            \" # rubocop: disable #{cop_name}\"\n          )\n        end",
        "comment": "Automatically correcting these offenses is not always possible, as sometimes code needs to be refactored to make this work. As such, we only allow developers to easily denylist existing offenses.",
        "label": "How-to-use",
        "id": "3903"
    },
    {
        "raw_code": "def upgrade(new)\n        end",
        "comment": "This is called to upgrade this V1 config to V2. The parameter given is the full V2 configuration object, so you can do anything to it that you want.  No return value is expected, modifications should be made directly to the new V2 object.  @param [V2::Root] new",
        "label": "How-to-use",
        "id": "9025"
    },
    {
        "raw_code": "def action(name, opts=nil)\n      @logger.info(\"Calling action: #{name} on provider #{@provider}\")\n\n      opts ||= {}\n\n      # Determine whether we lock or not\n      lock = true\n      lock = opts.delete(:lock) if opts.key?(:lock)\n\n      # Extra env keys are the remaining opts\n      extra_env = opts.dup\n\n      check_cwd # Warns the UI if the machine was last used on a different dir\n\n      # Create a deterministic ID for this machine\n      vf = nil\n      vf = @env.vagrantfile_name[0] if @env.vagrantfile_name\n      id = Digest::MD5.hexdigest(\n        \"#{@env.root_path}#{vf}#{@env.local_data_path}#{@name}\")\n\n      # We only lock if we're not executing an SSH action. In the future\n      # we will want to do more fine-grained unlocking in actions themselves\n      # but for a 1.6.2 release this will work.\n      locker = Proc.new { |*args, &block| block.call }\n      locker = @env.method(:lock) if lock && !name.to_s.start_with?(\"ssh\")\n\n      # Lock this machine for the duration of this action\n      return_env = locker.call(\"machine-action-#{id}\") do\n        # Get the callable from the provider.\n        callable = @provider.action(name)\n\n        # If this action doesn't exist on the provider, then an exception\n        # must be raised.\n        if callable.nil?\n          raise Errors::UnimplementedProviderAction,\n            action: name,\n            provider: @provider.to_s\n        end",
        "comment": "This calls an action on the provider. The provider may or may not actually implement the action.  @param [Symbol] name Name of the action to run. @param [Hash] extra_env This data will be passed into the action runner as extra data set on the environment hash for the middleware runner.",
        "label": "How-to-use",
        "id": "8778"
    },
    {
        "raw_code": "def initialize(**options)\n      @synchronous = options[:synchronous]\n      @mutex = Mutex.new\n    end",
        "comment": "Possible options: - synchronous [Boolean] if true, turns `start` into a blocking call",
        "label": "How-to-use",
        "id": "1509"
    },
    {
        "raw_code": "def self.load_rdoc\n    return if @rdoc_version\n\n    require_relative 'rdoc'\n\n    @rdoc_version = Gem::Version.new ::RDoc::VERSION\n  end",
        "comment": " Loads the RDoc generator",
        "label": "How-to-use",
        "id": "15899"
    },
    {
        "raw_code": "def touch(*names, time: nil)\n      _raise_record_not_touched_error unless persisted?\n      _raise_readonly_record_error if readonly?\n\n      attribute_names = timestamp_attributes_for_update_in_model\n      attribute_names = (attribute_names | names).map! do |name|\n        name = name.to_s\n        name = self.class.attribute_aliases[name] || name\n        verify_readonly_attribute(name)\n        name\n      end",
        "comment": "Saves the record with the updated_at/on attributes set to the current time or the time specified. Please note that no validation is performed and only the +after_touch+, +after_commit+ and +after_rollback+ callbacks are executed.  This method can be passed attribute names and an optional time argument. If attribute names are passed, they are updated along with updated_at/on attributes. If no time argument is passed, the current time is used as default.  product.touch                         # updates updated_at/on with current time product.touch(time: Time.new(2015, 2, 16, 0, 0, 0)) # updates updated_at/on with specified time product.touch(:designed_at)           # updates the designed_at attribute and updated_at/on product.touch(:started_at, :ended_at) # updates started_at, ended_at and updated_at/on attributes  If used along with {belongs_to}[rdoc-ref:Associations::ClassMethods#belongs_to] then +touch+ will invoke +touch+ method on associated object.  class Brake < ActiveRecord::Base belongs_to :car, touch: true end  class Car < ActiveRecord::Base belongs_to :corporation, touch: true end  # triggers @brake.car.touch and @brake.car.corporation.touch @brake.touch  Note that +touch+ must be used on a persisted object, or else an ActiveRecordError will be thrown. For example:  ball = Ball.new ball.touch(:updated_at)   # => raises ActiveRecordError ",
        "label": "How-to-use",
        "id": "12579"
    },
    {
        "raw_code": "def query_api\n        @query_api ||= influx_client.create_query_api\n      end",
        "comment": "Query client  @return [QueryApi]",
        "label": "How-to-use",
        "id": "4564"
    },
    {
        "raw_code": "def perform_housekeeping\n        Runtime::Logger.debug(\"Calling API endpoint #{api_housekeeping_path}\")\n\n        response = post(request_url(api_housekeeping_path), nil)\n\n        return if response.code == HTTP_STATUS_CREATED\n\n        raise(\n          ResourceQueryError,\n          \"Could not perform housekeeping. Request returned (#{response.code}): `#{response.body}`.\"\n        )\n      end",
        "comment": "Calls the API endpoint that triggers the backend service that performs repository housekeeping (garbage collection and similar tasks).",
        "label": "How-to-use",
        "id": "4106"
    },
    {
        "raw_code": "def format_constant(value)\n        # last can return nil, so default to empty string\n        sp = value.split(\"\\n\").last || \"\"\n        sp = sp[/^(\\s+)/, 1]\n        num = sp ? sp.size : 0\n        html_syntax_highlight value.gsub(/^\\s{#{num}}/, '')\n      end",
        "comment": "@return [String] formats source code of a constant value",
        "label": "How-to-use",
        "id": "443"
    },
    {
        "raw_code": "def init_link_notation_regexp_handlings\n    add_regexp_handling_RDOCLINK\n    add_regexp_handling_TIDYLINK\n  end",
        "comment": " Adds regexp handlings about link notations.",
        "label": "How-to-use",
        "id": "16326"
    },
    {
        "raw_code": "def analyze_later\n    if analyzer_class.analyze_later?\n      ActiveStorage::AnalyzeJob.perform_later(self)\n    else\n      analyze\n    end",
        "comment": "Enqueues an ActiveStorage::AnalyzeJob which calls #analyze, or calls #analyze inline based on analyzer class configuration.  This method is automatically called for a blob when it's attached for the first time. You can call it to analyze a blob again (e.g. if you add a new analyzer or modify an existing one).",
        "label": "How-to-use",
        "id": "13648"
    },
    {
        "raw_code": "def initialize(current_user, params = {})\n    @project = params[:project]\n    @current_user = current_user\n    @params = params.dup\n    @target_type = @params[:target_type]\n  end",
        "comment": "Used to filter Notes When used with target_type and target_id this returns notes specifically for the controller  Arguments: current_user - which user check authorizations with project - which project to look for notes on params: target: noteable target_type: string target_id: integer last_fetched_at: time search: string sort: string ",
        "label": "How-to-use",
        "id": "7943"
    },
    {
        "raw_code": "def map_match\n          @map_match ||= map.keys.map {|k| Regexp.quote k }.join('|')\n        end",
        "comment": "@return [Regexp] the full list of separators as a regexp match",
        "label": "How-to-use",
        "id": "608"
    },
    {
        "raw_code": "def legacy_validate(content, dry_run: false, ref: project&.default_branch)\n        if dry_run\n          simulate_pipeline_creation(content, ref)\n        else\n          legacy_static_validation(content)\n        end",
        "comment": "Our goal is to remove the `sha` dependency and the custom `YamlProcessor` usage from the CI linting logic. This legacy method is aimed to be removed with https://gitlab.com/gitlab-org/gitlab/-/issues/543727.",
        "label": "How-to-use",
        "id": "2452"
    },
    {
        "raw_code": "def indirect_caller_locations\n    caller_locations\n  end",
        "comment": "Adds a frame from this file to the call stack.",
        "label": "How-to-use",
        "id": "14599"
    },
    {
        "raw_code": "def self.emoji_pattern\n        @emoji_pattern ||= TanukiEmoji.index.alpha_code_pattern\n      end",
        "comment": "Build a regexp that matches all valid :emoji: names.",
        "label": "How-to-use",
        "id": "3447"
    },
    {
        "raw_code": "def get_feature_category\n        Gitlab::ApplicationContext.current_context_attribute('meta.feature_category') || :not_owned\n      end",
        "comment": "All dummy workers are unowned; get the feature category from the context if available.",
        "label": "How-to-use",
        "id": "2028"
    },
    {
        "raw_code": "def add_to_authorized_keys\n    return unless Gitlab::CurrentSettings.authorized_keys_enabled?\n\n    AuthorizedKeysWorker.perform_async('add_key', shell_id, key)\n  end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "6855"
    },
    {
        "raw_code": "def disabled?\n        @status == :disabled || @status == :todo\n      end",
        "comment": "@api public  @!attribute [r] disabled?  @return [Boolean] whether this offense was locally disabled with a disable or todo where it occurred.",
        "label": "How-to-use",
        "id": "10233"
    },
    {
        "raw_code": "def block_method_name(node)\n            case node.type\n            when :block\n              node.method_name\n            when :block_pass\n              node.parent.method_name\n            end",
        "comment": "Returns the name of the method called with a block if node is a block node, or a block-pass node.",
        "label": "How-to-use",
        "id": "10396"
    },
    {
        "raw_code": "def next_quarter\n      months_since(3)\n    end",
        "comment": "Short-hand for <tt>months_since(3)</tt>.",
        "label": "How-to-use",
        "id": "14156"
    },
    {
        "raw_code": "def apply_to(relation)\n        relation.except(:where)\n          .with\n          .recursive(to_arel)\n          .from(alias_to(relation.model.arel_table))\n      end",
        "comment": "Applies the CTE to the given relation, returning a new one that will query from it.",
        "label": "How-to-use",
        "id": "2858"
    },
    {
        "raw_code": "def initialize(attribute_manager = nil)\n    @attribute_manager = attribute_manager || RDoc::Markup::AttributeManager.new\n    @output = nil\n  end",
        "comment": " Take a block of text and use various heuristics to determine its structure (paragraphs, lists, and so on).  Invoke an event handler as we identify significant chunks.",
        "label": "How-to-use",
        "id": "15950"
    },
    {
        "raw_code": "def before_initialize(&block)\n        ActiveSupport.on_load(:before_initialize, yield: true, &block)\n      end",
        "comment": "Second configurable block to run. Called before frameworks initialize.",
        "label": "How-to-use",
        "id": "14815"
    },
    {
        "raw_code": "def before_configuration(&block)\n        ActiveSupport.on_load(:before_configuration, yield: true, &block)\n      end",
        "comment": "First configurable block to run. Called before any initializers are run.",
        "label": "How-to-use",
        "id": "14813"
    },
    {
        "raw_code": "def explain(*options)\n      ExplainProxy.new(self, options)\n    end",
        "comment": "Runs EXPLAIN on the query or queries triggered by this relation and returns the result as a string. The string is formatted imitating the ones printed by the database shell.  User.all.explain # EXPLAIN SELECT `users`.* FROM `users` # ...  Note that this method actually runs the queries, since the results of some are needed by the next ones when eager loading is going on.  To run EXPLAIN on queries created by +first+, +pluck+ and +count+, call these methods on +explain+:  User.all.explain.count # EXPLAIN SELECT COUNT(*) FROM `users` # ...  The column name can be passed if required:  User.all.explain.maximum(:id) # EXPLAIN SELECT MAX(`users`.`id`) FROM `users` # ...  Please see further details in the {Active Record Query Interface guide}[https://guides.rubyonrails.org/active_record_querying.html#running-explain].",
        "label": "How-to-use",
        "id": "12631"
    },
    {
        "raw_code": "def racc_read_token(t, tok, val)\n      @racc_debug_out.print 'read    '\n      @racc_debug_out.print tok.inspect, '(', racc_token2str(t), ') '\n      @racc_debug_out.puts val.inspect\n      @racc_debug_out.puts\n    end",
        "comment": "For debugging output",
        "label": "How-to-use",
        "id": "16501"
    },
    {
        "raw_code": "def also_reload(*glob)\n        Dir[*glob].each { |path| Watcher::List.for(self).watch_file(path) }\n      end",
        "comment": "Indicates with a +glob+ which files should be reloaded if they have been modified.  It can be called several times.",
        "label": "How-to-use",
        "id": "8646"
    },
    {
        "raw_code": "def self.default_pool_size\n      headroom =\n        (ENV[\"DB_POOL_HEADROOM\"].presence || DEFAULT_POOL_HEADROOM).to_i\n\n      Gitlab::Runtime.max_threads + headroom\n    end",
        "comment": "We configure the database connection pool size automatically based on the configured concurrency. We also add some headroom, to make sure we don't run out of connections when more threads besides the 'user-facing' ones are running.  Read more about this in doc/development/database/client_side_connection_pool.md",
        "label": "How-to-use",
        "id": "1446"
    },
    {
        "raw_code": "def find_caught_up_replica(env)\n          namespaces_and_ids = sticking_namespaces(env)\n\n          namespaces_and_ids.each do |(sticking, namespace, id)|\n            sticking.find_caught_up_replica(namespace, id)\n          end",
        "comment": "Determine if we need to stick based on currently available user data.  Typically this code will only be reachable for Rails requests as Grape data is not yet available at this point.",
        "label": "How-to-use",
        "id": "3103"
    },
    {
        "raw_code": "def connected_to_many(*classes, role:, shard: nil, prevent_writes: false)\n      classes = classes.flatten\n\n      if self != Base || classes.include?(Base)\n        raise NotImplementedError, \"connected_to_many can only be called on ActiveRecord::Base.\"\n      end",
        "comment": "Connects a role and/or shard to the provided connection names. Optionally +prevent_writes+ can be passed to block writes on a connection. +reading+ will automatically set +prevent_writes+ to true.  +connected_to_many+ is an alternative to deeply nested +connected_to+ blocks.  Usage:  ActiveRecord::Base.connected_to_many(AnimalsRecord, MealsRecord, role: :reading) do Dog.first # Read from animals replica Dinner.first # Read from meals replica Person.first # Read from primary writer end",
        "label": "How-to-use",
        "id": "12398"
    },
    {
        "raw_code": "def peek_enabled?\n    Gitlab::PerformanceBar.enabled_for_request?\n  end",
        "comment": "Needed for Peek's routing to work; Peek::ResultsController#restrict_non_access calls this method.",
        "label": "How-to-use",
        "id": "6538"
    },
    {
        "raw_code": "def table_and_attribute_name(node)\n          migration_method = node.children[1]\n          table_name, attribute_name = ''\n\n          if migration_method == :text\n            # We are inside a node in a create/change table block\n            block_node = node.each_ancestor(:block).first\n            create_table_node = block_node\n                                  .children\n                                  .find { |n| TABLE_METHODS.include?(n.children[1]) }\n\n            if create_table_node\n              table_name = table_name_or_const_name(create_table_node.children[2])\n            else\n              # Guard against errors when a new table create/change migration\n              # helper is introduced and warn the author so that it can be\n              # added in TABLE_METHODS\n              table_name = 'unknown'\n              add_offense(\n                block_node.send_node.loc.selector,\n                message: 'Unknown table method. Please tweak `MigrationHelpers::TABLE_METHODS`.'\n              )\n            end",
        "comment": "For a given node, find the table and attribute this node is for  Simple when we have calls to `add_column_XXX` helper methods  A little bit more tricky when we have attributes defined as part of a create/change table block: - The attribute name is available on the node - Finding the table name requires to: * go up * find the first block the attribute def is part of * go back down to find the create_table node * fetch the table name from that node",
        "label": "How-to-use",
        "id": "3916"
    },
    {
        "raw_code": "def self.add_visitor_tests\n    class_eval do\n\n      ##\n      # Calls start_accepting which needs to verify startup state\n\n      def test_start_accepting\n        @to.start_accepting\n\n        start_accepting\n      end\n\n      ##\n      # Calls end_accepting on your test case which needs to call\n      # <tt>@to.end_accepting</tt> and verify document generation\n\n      def test_end_accepting\n        @to.start_accepting\n        @to.res << 'hi'\n\n        end_accepting\n      end\n\n      ##\n      # Calls accept_blank_line\n\n      def test_accept_blank_line\n        @to.start_accepting\n\n        @to.accept_blank_line @RM::BlankLine.new\n\n        accept_blank_line\n      end\n\n      ##\n      # Calls accept_block_quote\n\n      def test_accept_block_quote\n        @to.start_accepting\n\n        @to.accept_block_quote block para 'quote'\n\n        accept_block_quote\n      end\n      ##\n      # Test case that calls <tt>@to.accept_document</tt>\n\n      def test_accept_document\n        @to.start_accepting\n        @to.accept_document @RM::Document.new @RM::Paragraph.new 'hello'\n\n        accept_document\n      end\n\n      ##\n      # Calls accept_heading with a level 5 RDoc::Markup::Heading\n\n      def test_accept_heading\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(5, 'Hello')\n\n        accept_heading\n      end\n\n      ##\n      # Calls accept_heading_1 with a level 1 RDoc::Markup::Heading\n\n      def test_accept_heading_1\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(1, 'Hello')\n\n        accept_heading_1\n      end\n\n      ##\n      # Calls accept_heading_2 with a level 2 RDoc::Markup::Heading\n\n      def test_accept_heading_2\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(2, 'Hello')\n\n        accept_heading_2\n      end\n\n      ##\n      # Calls accept_heading_3 with a level 3 RDoc::Markup::Heading\n\n      def test_accept_heading_3\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(3, 'Hello')\n\n        accept_heading_3\n      end\n\n      ##\n      # Calls accept_heading_4 with a level 4 RDoc::Markup::Heading\n\n      def test_accept_heading_4\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(4, 'Hello')\n\n        accept_heading_4\n      end\n\n      ##\n      # Calls accept_heading_b with a bold level 1 RDoc::Markup::Heading\n\n      def test_accept_heading_b\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(1, '*Hello*')\n\n        accept_heading_b\n      end\n\n      ##\n      # Calls accept_heading_suppressed_crossref with a level 1\n      # RDoc::Markup::Heading containing a suppressed crossref\n\n      def test_accept_heading_suppressed_crossref # HACK to_html_crossref test\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(1, '\\\\Hello')\n\n        accept_heading_suppressed_crossref\n      end\n\n      ##\n      # Calls accept_paragraph\n\n      def test_accept_paragraph\n        @to.start_accepting\n\n        @to.accept_paragraph @RM::Paragraph.new('hi')\n\n        accept_paragraph\n      end\n\n      ##\n      # Calls accept_paragraph_b with a RDoc::Markup::Paragraph containing\n      # bold words\n\n      def test_accept_paragraph_b\n        @to.start_accepting\n\n        @to.accept_paragraph @RM::Paragraph.new('reg <b>bold words</b> reg')\n\n        accept_paragraph_b\n      end\n\n      ##\n      # Calls accept_paragraph_br with a RDoc::Markup::Paragraph containing\n      # a \\<br>\n\n      def test_accept_paragraph_br\n        @to.start_accepting\n\n        @to.accept_paragraph para 'one<br>two'\n\n        accept_paragraph_br\n      end\n\n      ##\n      # Calls accept_paragraph with a Paragraph containing a hard break\n\n      def test_accept_paragraph_break\n        @to.start_accepting\n\n        @to.accept_paragraph para('hello', hard_break, 'world')\n\n        accept_paragraph_break\n      end\n\n      ##\n      # Calls accept_paragraph_i with a RDoc::Markup::Paragraph containing\n      # emphasized words\n\n      def test_accept_paragraph_i\n        @to.start_accepting\n\n        @to.accept_paragraph @RM::Paragraph.new('reg <em>italic words</em> reg')\n\n        accept_paragraph_i\n      end\n\n      ##\n      # Calls accept_paragraph_plus with a RDoc::Markup::Paragraph containing\n      # teletype words\n\n      def test_accept_paragraph_plus\n        @to.start_accepting\n\n        @to.accept_paragraph @RM::Paragraph.new('reg +teletype+ reg')\n\n        accept_paragraph_plus\n      end\n\n      ##\n      # Calls accept_paragraph_star with a RDoc::Markup::Paragraph containing\n      # bold words\n\n      def test_accept_paragraph_star\n        @to.start_accepting\n\n        @to.accept_paragraph @RM::Paragraph.new('reg *bold* reg')\n\n        accept_paragraph_star\n      end\n\n      ##\n      # Calls accept_paragraph_underscore with a RDoc::Markup::Paragraph\n      # containing emphasized words\n\n      def test_accept_paragraph_underscore\n        @to.start_accepting\n\n        @to.accept_paragraph @RM::Paragraph.new('reg _italic_ reg')\n\n        accept_paragraph_underscore\n      end\n\n      ##\n      # Calls accept_verbatim with a RDoc::Markup::Verbatim\n\n      def test_accept_verbatim\n        @to.start_accepting\n\n        @to.accept_verbatim @RM::Verbatim.new(\"hi\\n\", \"  world\\n\")\n\n        accept_verbatim\n      end\n\n      ##\n      # Calls accept_raw with a RDoc::Markup::Raw\n\n      def test_accept_raw\n        @to.start_accepting\n\n        @to.accept_raw @RM::Raw.new(\"<table>\",\n                                    \"<tr><th>Name<th>Count\",\n                                    \"<tr><td>a<td>1\",\n                                    \"<tr><td>b<td>2\",\n                                    \"</table>\")\n\n        accept_raw\n      end\n\n      ##\n      # Calls accept_rule with a RDoc::Markup::Rule\n\n      def test_accept_rule\n        @to.start_accepting\n\n        @to.accept_rule @RM::Rule.new(4)\n\n        accept_rule\n      end\n\n      ##\n      # Calls accept_list_item_start_bullet\n\n      def test_accept_list_item_start_bullet\n        @to.start_accepting\n\n        @to.accept_list_start @bullet_list\n\n        @to.accept_list_item_start @bullet_list.items.first\n\n        accept_list_item_start_bullet\n      end\n\n      ##\n      # Calls accept_list_item_start_label\n\n      def test_accept_list_item_start_label\n        @to.start_accepting\n\n        @to.accept_list_start @label_list\n\n        @to.accept_list_item_start @label_list.items.first\n\n        accept_list_item_start_label\n      end\n\n      ##\n      # Calls accept_list_item_start_lalpha\n\n      def test_accept_list_item_start_lalpha\n        @to.start_accepting\n\n        @to.accept_list_start @lalpha_list\n\n        @to.accept_list_item_start @lalpha_list.items.first\n\n        accept_list_item_start_lalpha\n      end\n\n      ##\n      # Calls accept_list_item_start_note\n\n      def test_accept_list_item_start_note\n        @to.start_accepting\n\n        @to.accept_list_start @note_list\n\n        @to.accept_list_item_start @note_list.items.first\n\n        accept_list_item_start_note\n      end\n\n      ##\n      # Calls accept_list_item_start_note_2\n\n      def test_accept_list_item_start_note_2\n        list = list(:NOTE,\n                 item('<tt>teletype</tt>',\n                   para('teletype description')))\n\n        @to.start_accepting\n\n        list.accept @to\n\n        @to.end_accepting\n\n        accept_list_item_start_note_2\n      end\n\n      ##\n      # Calls accept_list_item_start_note_multi_description\n\n      def test_accept_list_item_start_note_multi_description\n        list = list(:NOTE,\n                 item(%w[label],\n                   para('description one')),\n                 item(nil, para('description two')))\n\n        @to.start_accepting\n\n        list.accept @to\n\n        @to.end_accepting\n\n        accept_list_item_start_note_multi_description\n      end\n\n      ##\n      # Calls accept_list_item_start_note_multi_label\n\n      def test_accept_list_item_start_note_multi_label\n        list = list(:NOTE,\n                 item(%w[one two],\n                   para('two headers')))\n\n        @to.start_accepting\n\n        list.accept @to\n\n        @to.end_accepting\n\n        accept_list_item_start_note_multi_label\n      end\n\n      ##\n      # Calls accept_list_item_start_number\n\n      def test_accept_list_item_start_number\n        @to.start_accepting\n\n        @to.accept_list_start @number_list\n\n        @to.accept_list_item_start @number_list.items.first\n\n        accept_list_item_start_number\n      end\n\n      ##\n      # Calls accept_list_item_start_ualpha\n\n      def test_accept_list_item_start_ualpha\n        @to.start_accepting\n\n        @to.accept_list_start @ualpha_list\n\n        @to.accept_list_item_start @ualpha_list.items.first\n\n        accept_list_item_start_ualpha\n      end\n\n      ##\n      # Calls accept_list_item_end_bullet\n\n      def test_accept_list_item_end_bullet\n        @to.start_accepting\n\n        @to.accept_list_start @bullet_list\n\n        @to.accept_list_item_start @bullet_list.items.first\n\n        @to.accept_list_item_end @bullet_list.items.first\n\n        accept_list_item_end_bullet\n      end\n\n      ##\n      # Calls accept_list_item_end_label\n\n      def test_accept_list_item_end_label\n        @to.start_accepting\n\n        @to.accept_list_start @label_list\n\n        @to.accept_list_item_start @label_list.items.first\n\n        @to.accept_list_item_end @label_list.items.first\n\n        accept_list_item_end_label\n      end\n\n      ##\n      # Calls accept_list_item_end_lalpha\n\n      def test_accept_list_item_end_lalpha\n        @to.start_accepting\n\n        @to.accept_list_start @lalpha_list\n\n        @to.accept_list_item_start @lalpha_list.items.first\n\n        @to.accept_list_item_end @lalpha_list.items.first\n\n        accept_list_item_end_lalpha\n      end\n\n      ##\n      # Calls accept_list_item_end_note\n\n      def test_accept_list_item_end_note\n        @to.start_accepting\n\n        @to.accept_list_start @note_list\n\n        @to.accept_list_item_start @note_list.items.first\n\n        @to.accept_list_item_end @note_list.items.first\n\n        accept_list_item_end_note\n      end\n\n      ##\n      # Calls accept_list_item_end_number\n\n      def test_accept_list_item_end_number\n        @to.start_accepting\n\n        @to.accept_list_start @number_list\n\n        @to.accept_list_item_start @number_list.items.first\n\n        @to.accept_list_item_end @number_list.items.first\n\n        accept_list_item_end_number\n      end\n\n      ##\n      # Calls accept_list_item_end_ualpha\n\n      def test_accept_list_item_end_ualpha\n        @to.start_accepting\n\n        @to.accept_list_start @ualpha_list\n\n        @to.accept_list_item_start @ualpha_list.items.first\n\n        @to.accept_list_item_end @ualpha_list.items.first\n\n        accept_list_item_end_ualpha\n      end\n\n      ##\n      # Calls accept_list_start_bullet\n\n      def test_accept_list_start_bullet\n        @to.start_accepting\n\n        @to.accept_list_start @bullet_list\n\n        accept_list_start_bullet\n      end\n\n      ##\n      # Calls accept_list_start_label\n\n      def test_accept_list_start_label\n        @to.start_accepting\n\n        @to.accept_list_start @label_list\n\n        accept_list_start_label\n      end\n\n      ##\n      # Calls accept_list_start_lalpha\n\n      def test_accept_list_start_lalpha\n        @to.start_accepting\n\n        @to.accept_list_start @lalpha_list\n\n        accept_list_start_lalpha\n      end\n\n      ##\n      # Calls accept_list_start_note\n\n      def test_accept_list_start_note\n        @to.start_accepting\n\n        @to.accept_list_start @note_list\n\n        accept_list_start_note\n      end\n\n      ##\n      # Calls accept_list_start_number\n\n      def test_accept_list_start_number\n        @to.start_accepting\n\n        @to.accept_list_start @number_list\n\n        accept_list_start_number\n      end\n\n      ##\n      # Calls accept_list_start_ualpha\n\n      def test_accept_list_start_ualpha\n        @to.start_accepting\n\n        @to.accept_list_start @ualpha_list\n\n        accept_list_start_ualpha\n      end\n\n      ##\n      # Calls accept_list_end_bullet\n\n      def test_accept_list_end_bullet\n        @to.start_accepting\n\n        @to.accept_list_start @bullet_list\n\n        @to.accept_list_end @bullet_list\n\n        accept_list_end_bullet\n      end\n\n      ##\n      # Calls accept_list_end_label\n\n      def test_accept_list_end_label\n        @to.start_accepting\n\n        @to.accept_list_start @label_list\n\n        @to.accept_list_end @label_list\n\n        accept_list_end_label\n      end\n\n      ##\n      # Calls accept_list_end_lalpha\n\n      def test_accept_list_end_lalpha\n        @to.start_accepting\n\n        @to.accept_list_start @lalpha_list\n\n        @to.accept_list_end @lalpha_list\n\n        accept_list_end_lalpha\n      end\n\n      ##\n      # Calls accept_list_end_number\n\n      def test_accept_list_end_number\n        @to.start_accepting\n\n        @to.accept_list_start @number_list\n\n        @to.accept_list_end @number_list\n\n        accept_list_end_number\n      end\n\n      ##\n      # Calls accept_list_end_note\n\n      def test_accept_list_end_note\n        @to.start_accepting\n\n        @to.accept_list_start @note_list\n\n        @to.accept_list_end @note_list\n\n        accept_list_end_note\n      end\n\n      ##\n      # Calls accept_list_end_ualpha\n\n      def test_accept_list_end_ualpha\n        @to.start_accepting\n\n        @to.accept_list_start @ualpha_list\n\n        @to.accept_list_end @ualpha_list\n\n        accept_list_end_ualpha\n      end\n\n      ##\n      # Calls list_nested with a two-level list\n\n      def test_list_nested\n        doc = @RM::Document.new(\n                @RM::List.new(:BULLET,\n                  @RM::ListItem.new(nil,\n                    @RM::Paragraph.new('l1'),\n                    @RM::List.new(:BULLET,\n                      @RM::ListItem.new(nil,\n                        @RM::Paragraph.new('l1.1')))),\n                  @RM::ListItem.new(nil,\n                    @RM::Paragraph.new('l2'))))\n\n        doc.accept @to\n\n        list_nested\n      end\n\n      ##\n      # Calls list_verbatim with a list containing a verbatim block\n\n      def test_list_verbatim # HACK overblown\n        doc =\n          doc(\n            list(:BULLET,\n              item(nil,\n                para('list stuff'),\n                blank_line,\n                verb(\"* list\\n\",\n                     \"  with\\n\",\n                     \"\\n\",\n                     \"  second\\n\",\n                     \"\\n\",\n                     \"  1. indented\\n\",\n                     \"  2. numbered\\n\",\n                     \"\\n\",\n                     \"  third\\n\",\n                     \"\\n\",\n                     \"* second\\n\"))))\n\n        doc.accept @to\n\n        list_verbatim\n      end\n    end",
        "comment": " Call to add the visitor tests to your test case",
        "label": "How-to-use",
        "id": "16864"
    },
    {
        "raw_code": "def _detected_errors\n          return [] if !@__invalid_methods || @__invalid_methods.empty?\n          return [I18n.t(\"vagrant.config.common.bad_field\",\n                         fields: @__invalid_methods.to_a.sort.join(\", \"))]\n        end",
        "comment": "This returns any automatically detected errors.  @return [Array<String>]",
        "label": "How-to-use",
        "id": "9128"
    },
    {
        "raw_code": "def delete\n      _delete_row if persisted?\n      @destroyed = true\n      @previously_new_record = false\n      freeze\n    end",
        "comment": "Deletes the record in the database and freezes this instance to reflect that no changes should be made (since they can't be persisted). Returns the frozen instance.  The row is simply removed with an SQL +DELETE+ statement on the record's primary key, and no callbacks are executed.  Note that this will also delete records marked as {#readonly?}[rdoc-ref:Core#readonly?].  To enforce the object's +before_destroy+ and +after_destroy+ callbacks or any <tt>:dependent</tt> association options, use #destroy.",
        "label": "How-to-use",
        "id": "12561"
    },
    {
        "raw_code": "def namespace=(namespace)\n        @options[:namespace] = namespace\n      end",
        "comment": "Set the current namespace. Note, this will be ignored if custom options are passed to cache wills with a namespace key.",
        "label": "How-to-use",
        "id": "13752"
    },
    {
        "raw_code": "def __update_callbacks(name) # :nodoc:\n          self.descendants.prepend(self).reverse_each do |target|\n            chain = target.get_callbacks name\n            yield target, chain.dup\n          end",
        "comment": "This is used internally to append, prepend and skip callbacks to the CallbackChain.",
        "label": "How-to-use",
        "id": "13772"
    },
    {
        "raw_code": "def with_retried_nowait_lock\n    # Try at most 0.25 + (1.5 * .25) + (1.5^2 * .25) ... (1.5^5 * .25) = 5.2 s to get the lock\n    Retriable.retriable(on: ActiveRecord::LockWaitTimeout, tries: 6, base_interval: 0.25) do\n      with_lock('FOR UPDATE NOWAIT') do\n        yield\n      end",
        "comment": "If the merge request is idle in transaction or has a SELECT FOR UPDATE, we don't want to block indefinitely or this could cause a queue of SELECT FOR UPDATE calls. Instead, try to get the lock for 5 s before raising an error to the user.",
        "label": "How-to-use",
        "id": "6999"
    },
    {
        "raw_code": "def self.default_attr(key, default)\n      (@defaults ||= {})[key] = default\n      attr_accessor(key)\n    end",
        "comment": "@!macro [attach] yard.default_attr @!attribute $1 Defines an attribute named +key+ and sets a default value for it  @example Defining a default option key default_attr :name, 'Default Name' default_attr :time, lambda { Time.now } @param [Symbol] key the option key name @param [Object, Proc] default the default object value. If the default value is a proc, it is executed upon initialization.",
        "label": "How-to-use",
        "id": "107"
    },
    {
        "raw_code": "def sender(author_id, params = {})\n        author_id\n      end",
        "comment": "this method is implemented in Notify class, we don't need to test it",
        "label": "How-to-use",
        "id": "8329"
    },
    {
        "raw_code": "def hello\n        end",
        "comment": " Description of `hello` method. ",
        "label": "How-to-use",
        "id": "10798"
    },
    {
        "raw_code": "def process_public_network(root_options, net_options, env)\n          if root_options[:name] && validate_network_name!(root_options[:name], env)\n            network_name = root_options[:name]\n          end",
        "comment": "Generate configuration for public network  TODO: When the Vagrant installer upgrades to Ruby 2.5.x, remove all instances of the roundabout way of determining a prefix and instead just use the built-in `.prefix` method  @param [Hash] root_options Root networking options @param [Hash] net_options Docker scoped networking options @param [Hash] env Local call env @return [String, Hash] Network name and updated network_options",
        "label": "How-to-use",
        "id": "9523"
    },
    {
        "raw_code": "def validate_file_name!\n          unless /^[_a-z0-9]+$/.match?(file_name)\n            raise IllegalMigrationNameError.new(file_name)\n          end",
        "comment": "A migration file name can only contain underscores (_), lowercase characters, and numbers 0-9. Any other file name will raise an IllegalMigrationNameError.",
        "label": "How-to-use",
        "id": "13493"
    },
    {
        "raw_code": "def self.add_default_cli_options(block)\n    if !block.is_a?(Proc)\n      raise TypeError,\n        \"Expecting type `Proc` but received `#{block.class}`\"\n    end",
        "comment": "Add a new block of default CLI options which should be automatically added to all commands  @param [Proc] block Proc instance containing OptParser configuration @return [nil]",
        "label": "How-to-use",
        "id": "8834"
    },
    {
        "raw_code": "def legacy_storage?\n    [nil, 0].include?(self.storage_version)\n  end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "6763"
    },
    {
        "raw_code": "def perform_one\n        raise(EmptyQueueError, \"perform_one called with empty job queue\") if jobs.empty?\n        next_job = jobs.first\n        Queues.delete_for(next_job[\"jid\"], next_job[\"queue\"], to_s)\n        process_job(next_job)\n      end",
        "comment": "Pop out a single job and perform it",
        "label": "How-to-use",
        "id": "5165"
    },
    {
        "raw_code": "def markup_class(type = options.markup)\n        load_markup_provider(type)\n        MarkupHelper.markup_cache[type][:class]\n      end",
        "comment": "Gets the markup provider class/module constant for a markup type Call {#load_markup_provider} before using this method.  @param [Symbol] type the markup type (:rdoc, :markdown, etc.) @return [Class] the markup class",
        "label": "How-to-use",
        "id": "383"
    },
    {
        "raw_code": "def reset!\n        @integration_session = create_session(app)\n      end",
        "comment": "Reset the current session. This is useful for testing multiple sessions in a single test case.",
        "label": "How-to-use",
        "id": "11628"
    },
    {
        "raw_code": "def reset!\n          @registered.clear\n        end",
        "comment": "This clears out all the registered plugins. This is only used by unit tests and should not be called directly.",
        "label": "How-to-use",
        "id": "8988"
    },
    {
        "raw_code": "def warn(message = nil, callstack = nil)\n        return if silenced\n\n        callstack ||= caller_locations(2)\n        deprecation_message(callstack, message).tap do |full_message|\n          if deprecation_disallowed?(message)\n            disallowed_behavior.each { |b| b.call(full_message, callstack, self) }\n          else\n            behavior.each { |b| b.call(full_message, callstack, self) }\n          end",
        "comment": "Outputs a deprecation warning to the output configured by ActiveSupport::Deprecation#behavior.  ActiveSupport::Deprecation.new.warn('something broke!') # => \"DEPRECATION WARNING: something broke! (called from your_code.rb:1)\"",
        "label": "How-to-use",
        "id": "14443"
    },
    {
        "raw_code": "def grouped_collection_select(object, method, collection, group_method, group_label_method, option_key_method, option_value_method, options = {}, html_options = {})\n        Tags::GroupedCollectionSelect.new(object, method, self, collection, group_method, group_label_method, option_key_method, option_value_method, options, html_options).render\n      end",
        "comment": "Returns <tt><select></tt>, <tt><optgroup></tt> and <tt><option></tt> tags for the collection of existing return values of +method+ for +object+'s class. The value returned from calling +method+ on the instance +object+ will be selected. If calling +method+ returns +nil+, no selection is made without including <tt>:prompt</tt> or <tt>:include_blank</tt> in the +options+ hash.  Parameters: * +object+ - The instance of the class to be used for the select tag * +method+ - The attribute of +object+ corresponding to the select tag * +collection+ - An array of objects representing the <tt><optgroup></tt> tags. * +group_method+ - The name of a method which, when called on a member of +collection+, returns an array of child objects representing the <tt><option></tt> tags. It can also be any object that responds to +call+, such as a +proc+, that will be called for each member of the +collection+ to retrieve the value. * +group_label_method+ - The name of a method which, when called on a member of +collection+, returns a string to be used as the +label+ attribute for its <tt><optgroup></tt> tag. It can also be any object that responds to +call+, such as a +proc+, that will be called for each member of the +collection+ to retrieve the label. * +option_key_method+ - The name of a method which, when called on a child object of a member of +collection+, returns a value to be used as the +value+ attribute for its <tt><option></tt> tag. * +option_value_method+ - The name of a method which, when called on a child object of a member of +collection+, returns a value to be used as the contents of its <tt><option></tt> tag.  Example object structure for use with this method:  # attributes: id, name class Continent < ActiveRecord::Base has_many :countries end  # attributes: id, name, continent_id class Country < ActiveRecord::Base belongs_to :continent end  # attributes: id, name, country_id class City < ActiveRecord::Base belongs_to :country end  Sample usage:  grouped_collection_select(:city, :country_id, @continents, :countries, :name, :id, :name)  Possible output:  <select name=\"city[country_id]\" id=\"city_country_id\"> <optgroup label=\"Africa\"> <option value=\"1\">South Africa</option> <option value=\"3\">Somalia</option> </optgroup> <optgroup label=\"Europe\"> <option value=\"7\" selected=\"selected\">Denmark</option> <option value=\"2\">Ireland</option> </optgroup> </select>",
        "label": "How-to-use",
        "id": "11900"
    },
    {
        "raw_code": "def validate_dates?\n      new_record? || any_dates_changed?\n    end",
        "comment": "Validate for new records or when any date field has changed",
        "label": "How-to-use",
        "id": "7658"
    },
    {
        "raw_code": "def with_model_for(table_name)\n          model_class = Class.new(::ActiveRecord::Base) do\n            self.table_name = table_name\n\n            def self.name\n              \"ActiveContext::Model::#{table_name.classify}\"\n            end\n\n            def self.to_s\n              name\n            end\n          end",
        "comment": "Creates an ActiveRecord model for a specific table and yields it within the connection context @param table_name [String] The name of the table to create a model for @yield [Class] A dynamically created ActiveRecord model class with the correct connection",
        "label": "How-to-use",
        "id": "1157"
    },
    {
        "raw_code": "def initialize(machine, config)\n          @machine = machine\n          @config  = config\n        end",
        "comment": "Initializes the provisioner with the machine that it will be provisioning along with the provisioner configuration (if there is any).  The provisioner should _not_ do anything at this point except initialize internal state.  @param [Machine] machine The machine that this will be provisioning. @param [Object] config Provisioner configuration, if one was set.",
        "label": "How-to-use",
        "id": "9059"
    },
    {
        "raw_code": "def self.post_process(&block)\n    @post_processors << block\n  end",
        "comment": " Adds a post-process handler for directives.  The handler will be called with the result RDoc::Comment (or text String) and the code object for the comment (if any).",
        "label": "How-to-use",
        "id": "16362"
    },
    {
        "raw_code": "def request_public_gateway(network_options, interface, env)\n          subnet = IPAddr.new(network_options[:subnet])\n          gateway = nil\n          while !gateway\n            gateway = env[:ui].ask(I18n.t(\n              \"docker_provider.network_bridge_gateway_request\",\n              interface: interface,\n              default_gateway: network_options[:gateway]) + \" \",\n              prefix: false\n            ).strip\n            if gateway.empty?\n              gateway = network_options[:gateway]\n            end",
        "comment": "Request the gateway address for the public network  @param [Hash] network_options Docker scoped networking options @param [String] interface The bridge interface used @param [Hash] env Local call env @return [String] Gateway address",
        "label": "How-to-use",
        "id": "9524"
    },
    {
        "raw_code": "def triggered_hooks(hooks_scope, data)\n    triggered = ::Projects::TriggeredHooks.new(hooks_scope, data)\n\n    # By default the webhook resource_access_token_hooks will execute for\n    # seven_days interval but we have a setting to allow webhook execution\n    # for thirty_days and sixty_days interval too.\n    if hooks_scope == :resource_access_token_hooks &&\n        data[:interval] != :seven_days &&\n        !self.extended_prat_expiry_webhooks_execute?\n\n      triggered\n    else\n      triggered.add_hooks(hooks)\n    end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "6749"
    },
    {
        "raw_code": "def http_auth?\n      request_format && super\n    end",
        "comment": "If the request format is not known, send a redirect instead of a 401 response, since this is the outcome we're most likely to want",
        "label": "How-to-use",
        "id": "1501"
    },
    {
        "raw_code": "def rename_column_concurrently(table, old_column, new_column, type: nil, batch_column_name: :id, type_cast_function: nil)\n          Gitlab::Database::QueryAnalyzers::RestrictAllowedSchemas.require_ddl_mode!\n\n          setup_renamed_column(\n            __callee__, table, old_column, new_column,\n            type: type, batch_column_name: batch_column_name, type_cast_function: type_cast_function\n          )\n\n          with_lock_retries do\n            install_bidirectional_triggers(table, old_column, new_column)\n          end",
        "comment": "Renames a column without requiring downtime.  Concurrent renames work by using database triggers to ensure both the old and new column are in sync. However, this method will _not_ remove the triggers or the old column automatically; this needs to be done manually in a post-deployment migration. This can be done using the method `cleanup_concurrent_column_rename`.  table - The name of the database table containing the column. old_column - The old column name. new_column - The new column name. type - The type of the new column. If no type is given the old column's type is used. batch_column_name - option is for tables without primary key, in this case another unique integer column can be used. Example: :user_id",
        "label": "How-to-use",
        "id": "3140"
    },
    {
        "raw_code": "def initialize_copy(copy) # :nodoc:\n    @text = copy.text.dup\n  end",
        "comment": " -- TODO deep copy @document",
        "label": "How-to-use",
        "id": "15956"
    },
    {
        "raw_code": "def authenticate(controller, &login_procedure)\n        token, options = token_and_options(controller.request)\n        unless token.blank?\n          login_procedure.call(token, options)\n        end",
        "comment": "If token Authorization header is present, call the login procedure with the present token and options.  Returns the return value of `login_procedure` if a token is found. Returns `nil` if no token is found.  #### Parameters  *   `controller` - ActionController::Base instance for the current request. *   `login_procedure` - Proc to call if a token is present. The Proc should take two arguments:  authenticate(controller) { |token, options| ... }  ",
        "label": "How-to-use",
        "id": "11283"
    },
    {
        "raw_code": "def setup_heartbeat_timer\n        @heartbeat_timer ||= event_loop.timer(BEAT_INTERVAL) do\n          event_loop.post { connections.each(&:beat) }\n        end",
        "comment": "WebSocket connection implementations differ on when they'll mark a connection as stale. We basically never want a connection to go stale, as you then can't rely on being able to communicate with the connection. To solve this, a 3 second heartbeat runs on all connections. If the beat fails, we automatically disconnect.",
        "label": "How-to-use",
        "id": "11089"
    },
    {
        "raw_code": "def build_cursor_conditions(cursor_data, direction:)\n          sort_field, sort_order = extract_sort_info.values_at(:field, :order)\n          return [] if sort_field != cursor_data['sort_field']\n\n          sort_value = cursor_data['sort_value']\n\n          sort_attr = Arel::Nodes::SqlLiteral.new(sort_field)\n\n          # Start with the primary sort condition\n          or_conditions = [build_primary_sort_condition(sort_attr, sort_value, sort_order, direction)]\n\n          # Add tie-breaking conditions for group fields\n          group_field_conditions = build_group_field_conditions(\n            cursor_data, direction, sort_attr, sort_value, sort_field\n          )\n\n          or_conditions.concat(group_field_conditions)\n\n          # Build nested OR conditions for stable ordering\n          or_conditions.reduce do |accumulated, condition|\n            if Gitlab.next_rails?\n              Arel::Nodes::Or.new([accumulated, condition])\n            else\n              Arel::Nodes::Or.new(accumulated, condition)\n            end",
        "comment": "currently this method supports only one order",
        "label": "How-to-use",
        "id": "2091"
    },
    {
        "raw_code": "def tag(name = nil, options = nil, open = false, escape = true)\n        if name.nil?\n          tag_builder\n        else\n          ensure_valid_html5_tag_name(name)\n          \"<#{name}#{tag_builder.tag_options(options, escape) if options}#{open ? \">\" : \" />\"}\".html_safe\n        end",
        "comment": "Returns an HTML tag.  === Building HTML tags  Builds HTML5 compliant tags with a tag proxy. Every tag can be built with:  tag.<tag name>(optional content, options)  where tag name can be e.g. br, div, section, article, or any tag really.  ==== Passing content  Tags can pass content to embed within it:  tag.h1 'All titles fit to print' # => <h1>All titles fit to print</h1>  tag.div tag.p('Hello world!')  # => <div><p>Hello world!</p></div>  Content can also be captured with a block, which is useful in templates:  <%= tag.p do %> The next great American novel starts here. <% end %> # => <p>The next great American novel starts here.</p>  ==== Options  Use symbol keyed options to add attributes to the generated tag.  tag.section class: %w( kitties puppies ) # => <section class=\"kitties puppies\"></section>  tag.section id: dom_id(@post) # => <section id=\"<generated dom id>\"></section>  Pass +true+ for any attributes that can render with no values, like +disabled+ and +readonly+.  tag.input type: 'text', disabled: true # => <input type=\"text\" disabled=\"disabled\">  HTML5 <tt>data-*</tt> and <tt>aria-*</tt> attributes can be set with a single +data+ or +aria+ key pointing to a hash of sub-attributes.  To play nicely with JavaScript conventions, sub-attributes are dasherized.  tag.article data: { user_id: 123 } # => <article data-user-id=\"123\"></article>  Thus <tt>data-user-id</tt> can be accessed as <tt>dataset.userId</tt>.  Data attribute values are encoded to JSON, with the exception of strings, symbols, and BigDecimals. This may come in handy when using jQuery's HTML5-aware <tt>.data()</tt> from 1.4.3.  tag.div data: { city_state: %w( Chicago IL ) } # => <div data-city-state=\"[&quot;Chicago&quot;,&quot;IL&quot;]\"></div>  The generated tag names and attributes are escaped by default. This can be disabled using +escape+.  tag.img src: 'open & shut.png' # => <img src=\"open &amp; shut.png\">  tag.img src: 'open & shut.png', escape: false # => <img src=\"open & shut.png\">  The tag builder respects {HTML5 void elements}[https://www.w3.org/TR/html5/syntax.html#void-elements] if no content is passed, and omits closing tags for those elements.  # A standard element: tag.div # => <div></div>  # A void element: tag.br  # => <br>  Note that when using the block form options should be wrapped in parenthesis.  <%= tag.a(href: \"/about\", class: \"font-bold\") do %> About the author <% end %> # => <a href=\"/about\" class=\"font-bold\">About the author</a>  === Building HTML attributes  Transforms a Hash into HTML attributes, ready to be interpolated into ERB. Includes or omits boolean attributes based on their truthiness. Transforms keys nested within <tt>aria:</tt> or <tt>data:</tt> objects into <tt>aria-</tt> and <tt>data-</tt> prefixed attributes:  <input <%= tag.attributes(type: :text, aria: { label: \"Search\" }) %>> # => <input type=\"text\" aria-label=\"Search\">  <button <%= tag.attributes id: \"call-to-action\", disabled: false, aria: { expanded: false } %> class=\"primary\">Get Started!</button> # => <button id=\"call-to-action\" aria-expanded=\"false\" class=\"primary\">Get Started!</button>  === Legacy syntax  The following format is for legacy syntax support. It will be deprecated in future versions of \\Rails.  tag(name, options = nil, open = false, escape = true)  It returns an empty HTML tag of type +name+ which by default is XHTML compliant. Set +open+ to true to create an open tag compatible with HTML 4.0 and below. Add HTML attributes by passing an attributes hash to +options+. Set +escape+ to false to disable attribute value escaping.  ==== Options  You can use symbols or strings for the attribute names.  Use +true+ with boolean attributes that can render with no value, like +disabled+ and +readonly+.  HTML5 <tt>data-*</tt> attributes can be set with a single +data+ key pointing to a hash of sub-attributes.  ==== Examples  tag(\"br\") # => <br />  tag(\"br\", nil, true) # => <br>  tag(\"input\", type: 'text', disabled: true) # => <input type=\"text\" disabled=\"disabled\" />  tag(\"input\", type: 'text', class: [\"strong\", \"highlight\"]) # => <input class=\"strong highlight\" type=\"text\" />  tag(\"img\", src: \"open & shut.png\") # => <img src=\"open &amp; shut.png\" />  tag(\"img\", { src: \"open &amp; shut.png\" }, false, false) # => <img src=\"open &amp; shut.png\" />  tag(\"div\", data: { name: 'Stephen', city_state: %w(Chicago IL) }) # => <div data-name=\"Stephen\" data-city-state=\"[&quot;Chicago&quot;,&quot;IL&quot;]\" />  tag(\"div\", class: { highlight: current_user.admin? }) # => <div class=\"highlight\" />",
        "label": "How-to-use",
        "id": "11970"
    },
    {
        "raw_code": "def add_foreign_key(from_table, to_table, **options)\n        return unless use_foreign_keys?\n\n        options = foreign_key_options(from_table, to_table, options)\n        return if options[:if_not_exists] == true && foreign_key_exists?(from_table, to_table, **options.slice(:column, :primary_key))\n\n        at = create_alter_table from_table\n        at.add_foreign_key to_table, options\n\n        execute schema_creation.accept(at)\n      end",
        "comment": "Adds a new foreign key. +from_table+ is the table with the key column, +to_table+ contains the referenced primary key.  The foreign key will be named after the following pattern: <tt>fk_rails_<identifier></tt>. +identifier+ is a 10 character long string which is deterministically generated from the +from_table+ and +column+. A custom name can be specified with the <tt>:name</tt> option.  ====== Creating a simple foreign key  add_foreign_key :articles, :authors  generates:  ALTER TABLE \"articles\" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY (\"author_id\") REFERENCES \"authors\" (\"id\")  ====== Creating a foreign key, ignoring method call if the foreign key exists  add_foreign_key(:articles, :authors, if_not_exists: true)  ====== Creating a foreign key on a specific column  add_foreign_key :articles, :users, column: :author_id, primary_key: \"lng_id\"  generates:  ALTER TABLE \"articles\" ADD CONSTRAINT fk_rails_58ca3d3a82 FOREIGN KEY (\"author_id\") REFERENCES \"users\" (\"lng_id\")  ====== Creating a composite foreign key  Assuming \"carts\" table has \"(shop_id, user_id)\" as a primary key.  add_foreign_key :orders, :carts, primary_key: [:shop_id, :user_id]  generates:  ALTER TABLE \"orders\" ADD CONSTRAINT fk_rails_6f5e4cb3a4 FOREIGN KEY (\"cart_shop_id\", \"cart_user_id\") REFERENCES \"carts\" (\"shop_id\", \"user_id\")  ====== Creating a cascading foreign key  add_foreign_key :articles, :authors, on_delete: :cascade  generates:  ALTER TABLE \"articles\" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY (\"author_id\") REFERENCES \"authors\" (\"id\") ON DELETE CASCADE  The +options+ hash can include the following keys: [<tt>:column</tt>] The foreign key column name on +from_table+. Defaults to <tt>to_table.singularize + \"_id\"</tt>. Pass an array to create a composite foreign key. [<tt>:primary_key</tt>] The primary key column name on +to_table+. Defaults to +id+. Pass an array to create a composite foreign key. [<tt>:name</tt>] The constraint name. Defaults to <tt>fk_rails_<identifier></tt>. [<tt>:on_delete</tt>] Action that happens <tt>ON DELETE</tt>. Valid values are +:nullify+, +:cascade+, and +:restrict+ [<tt>:on_update</tt>] Action that happens <tt>ON UPDATE</tt>. Valid values are +:nullify+, +:cascade+, and +:restrict+ [<tt>:if_not_exists</tt>] Specifies if the foreign key already exists to not try to re-add it. This will avoid duplicate column errors. [<tt>:validate</tt>] (PostgreSQL only) Specify whether or not the constraint should be validated. Defaults to +true+. [<tt>:deferrable</tt>] (PostgreSQL only) Specify whether or not the foreign key should be deferrable. Valid values are booleans or +:deferred+ or +:immediate+ to specify the default behavior. Defaults to +false+.",
        "label": "How-to-use",
        "id": "13164"
    },
    {
        "raw_code": "def patch_toText(patches)\n    patches.join\n  end",
        "comment": "Take a list of patches and return a textual representation",
        "label": "How-to-use",
        "id": "5073"
    },
    {
        "raw_code": "def primary_abstract_class\n        if ActiveRecord.application_record_class && ActiveRecord.application_record_class.name != name\n          raise ArgumentError, \"The `primary_abstract_class` is already set to #{ActiveRecord.application_record_class.inspect}. There can only be one `primary_abstract_class` in an application.\"\n        end",
        "comment": "Sets the application record class for Active Record  This is useful if your application uses a different class than ApplicationRecord for your primary abstract class. This class will share a database connection with Active Record. It is the class that connects to your primary database.",
        "label": "How-to-use",
        "id": "12470"
    },
    {
        "raw_code": "def setup\n    super\n\n    @options = RDoc::Options.new\n\n    @m = @RM.new\n\n    @bullet_list = @RM::List.new(:BULLET,\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l1')),\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l2')))\n\n    @label_list = @RM::List.new(:LABEL,\n      @RM::ListItem.new('cat', @RM::Paragraph.new('cats are cool')),\n      @RM::ListItem.new('dog', @RM::Paragraph.new('dogs are cool too')))\n\n    @lalpha_list = @RM::List.new(:LALPHA,\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l1')),\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l2')))\n\n    @note_list = @RM::List.new(:NOTE,\n      @RM::ListItem.new('cat', @RM::Paragraph.new('cats are cool')),\n      @RM::ListItem.new('dog', @RM::Paragraph.new('dogs are cool too')))\n\n    @number_list = @RM::List.new(:NUMBER,\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l1')),\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l2')))\n\n    @ualpha_list = @RM::List.new(:UALPHA,\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l1')),\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l2')))\n  end",
        "comment": " Call #setup when inheriting from this test case.  Provides the following instance variables:  +@m+::           RDoc::Markup.new +@RM+::          RDoc::Markup # to reduce typing +@bullet_list+:: @RM::List.new :BULLET, # ... +@label_list+::  @RM::List.new :LABEL, # ... +@lalpha_list+:: @RM::List.new :LALPHA, # ... +@note_list+::   @RM::List.new :NOTE, # ... +@number_list+:: @RM::List.new :NUMBER, # ... +@ualpha_list+:: @RM::List.new :UALPHA, # ...",
        "label": "How-to-use",
        "id": "16863"
    },
    {
        "raw_code": "def quote_schema_name(schema_name)\n          quote_column_name(schema_name)\n        end",
        "comment": "Quotes schema names for use in SQL queries.",
        "label": "How-to-use",
        "id": "13219"
    },
    {
        "raw_code": "def expand(target, value, block)\n            [target, block, @method_name]\n          end",
        "comment": "Return the parts needed to make this call, with the given input values.  Returns an array of the form:  [target, block, method, *arguments]  This array can be used as such:  target.send(method, *arguments, &block)  The actual invocation is left up to the caller to minimize call stack pollution.",
        "label": "How-to-use",
        "id": "13770"
    },
    {
        "raw_code": "def ruby_extractors\n        @ruby_extractors ||= [default_ruby_extractor]\n      end",
        "comment": "@return [Array<#call>]",
        "label": "How-to-use",
        "id": "10052"
    },
    {
        "raw_code": "def ci_project_ids_for_project_members(level)\n    project_members.where('access_level >= ?', level).pluck(:source_id)\n  end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "7113"
    },
    {
        "raw_code": "def deprecated_rest_status\n      return :stale if stale?\n\n      if contacted_at.nil?\n        :never_contacted\n      elsif active?\n        online? ? :online : :offline\n      else\n        :paused\n      end",
        "comment": "DEPRECATED TODO Remove in v5 in favor of `status` for REST calls, see https://gitlab.com/gitlab-org/gitlab/-/issues/344648",
        "label": "How-to-use",
        "id": "7525"
    },
    {
        "raw_code": "def variant(transformations)\n    if variable?\n      variant_class.new(self, ActiveStorage::Variation.wrap(transformations).default_to(default_variant_transformations))\n    else\n      raise ActiveStorage::InvariableError, \"Can't transform blob with ID=#{id} and content_type=#{content_type}\"\n    end",
        "comment": "Returns an ActiveStorage::Variant or ActiveStorage::VariantWithRecord instance with the set of +transformations+ provided. This is only relevant for image files, and it allows any image to be transformed for size, colors, and the like. Example:  avatar.variant(resize_to_limit: [100, 100]).processed.url  This will create and process a variant of the avatar blob that's constrained to a height and width of 100px. Then it'll upload said variant to the service according to a derivative key of the blob and the transformations.  Frequently, though, you don't actually want to transform the variant right away. But rather simply refer to a specific variant that can be created by a controller on-demand. Like so:  <%= image_tag Current.user.avatar.variant(resize_to_limit: [100, 100]) %>  This will create a URL for that specific blob with that specific variant, which the ActiveStorage::Representations::ProxyController or ActiveStorage::Representations::RedirectController can then produce on-demand.  Raises ActiveStorage::InvariableError if the variant processor cannot transform the blob. To determine whether a blob is variable, call ActiveStorage::Blob#variable?.  ==== Options  Options are defined by the {image_processing gem}[https://github.com/janko/image_processing], and depend on which variant processor you are using: {Vips}[https://github.com/janko/image_processing/blob/master/doc/vips.md] or {MiniMagick}[https://github.com/janko/image_processing/blob/master/doc/minimagick.md]. However, both variant processors support the following options:  [+:resize_to_limit+] Downsizes the image to fit within the specified dimensions while retaining the original aspect ratio. Will only resize the image if it's larger than the specified dimensions.  user.avatar.variant(resize_to_limit: [100, 100])  [+:resize_to_fit+] Resizes the image to fit within the specified dimensions while retaining the original aspect ratio. Will downsize the image if it's larger than the specified dimensions or upsize if it's smaller.  user.avatar.variant(resize_to_fit: [100, 100])  [+:resize_to_fill+] Resizes the image to fill the specified dimensions while retaining the original aspect ratio. If necessary, will crop the image in the larger dimension.  user.avatar.variant(resize_to_fill: [100, 100])  [+:resize_and_pad+] Resizes the image to fit within the specified dimensions while retaining the original aspect ratio. If necessary, will pad the remaining area with transparent color if source image has alpha channel, black otherwise.  user.avatar.variant(resize_and_pad: [100, 100])  [+:crop+] Extracts an area from an image. The first two arguments are the left and top edges of area to extract, while the last two arguments are the width and height of the area to extract.  user.avatar.variant(crop: [20, 50, 300, 300])  [+:rotate+] Rotates the image by the specified angle.  user.avatar.variant(rotate: 90)  Some options, including those listed above, can accept additional processor-specific values which can be passed as a trailing hash:  <!-- Vips supports configuring `crop` for many of its transformations --> <%= image_tag user.avatar.variant(resize_to_fill: [100, 100, { crop: :centre }]) %>  If migrating an existing application between MiniMagick and Vips, you will need to update processor-specific options:  <!-- MiniMagick --> <%= image_tag user.avatar.variant(resize_to_limit: [100, 100], format: :jpeg, sampling_factor: \"4:2:0\", strip: true, interlace: \"JPEG\", colorspace: \"sRGB\", quality: 80) %>  <!-- Vips --> <%= image_tag user.avatar.variant(resize_to_limit: [100, 100], format: :jpeg, saver: { subsample_mode: \"on\", strip: true, interlace: true, quality: 80 }) %> ",
        "label": "How-to-use",
        "id": "13650"
    },
    {
        "raw_code": "def badge_tooltip\n          subject.status\n        end",
        "comment": "Hint that appears on the build badges",
        "label": "How-to-use",
        "id": "2550"
    },
    {
        "raw_code": "def method_missing(name, *args, **kwargs, &block)\n        application_settings = current_application_settings\n\n        return application_settings.send(name, *args, **kwargs, &block) if application_settings.respond_to?(name)\n\n        if respond_to_organization_setting?(name, false)\n          return ::Organizations::OrganizationSetting.for(::Current.organization.id).send(name, *args, **kwargs, &block)\n        end",
        "comment": "rubocop:disable GitlabSecurity/PublicSend -- Method calls are forwarded to one of the setting classes",
        "label": "How-to-use",
        "id": "1605"
    },
    {
        "raw_code": "def policy_for(user, subject = :global, cache: true)\n      policy_cache = cache ? ::Gitlab::SafeRequestStore.storage : {}\n\n      DeclarativePolicy.policy_for(user, subject, cache: policy_cache)\n    end",
        "comment": "We cache in the request store by default. This can lead to unexpected results if abilities are re-checked after objects are modified and the check depends on the modified attributes. In such cases, you should pass `cache: false` for the second check to ensure all rules get re-evaluated.",
        "label": "How-to-use",
        "id": "6838"
    },
    {
        "raw_code": "def generate_class_list\n  @items = options.objects if options.objects\n  @list_title = \"Class List\"\n  @list_type = \"class\"\n  generate_list_contents\nend",
        "comment": "Generate a searchable class list in the output",
        "label": "How-to-use",
        "id": "752"
    },
    {
        "raw_code": "def resolve_reference\n      loop do\n        return if defined?(@unresolved_reference).nil? || @unresolved_reference.nil?\n        return if CodeObjects::Proxy === @unresolved_reference\n\n        reference = @unresolved_reference\n        @unresolved_reference = nil\n        self.all = [reference.docstring.all, @all].join(\"\\n\")\n      end",
        "comment": "@endgroup Resolves unresolved other docstring reference if there is unresolved reference. Does nothing if there is no unresolved reference.  Normally, you don't need to call this method explicitly. Resolving unresolved reference is done implicitly.  @return [void]",
        "label": "How-to-use",
        "id": "137"
    },
    {
        "raw_code": "def assert_file(relative, *contents)\n          absolute = File.expand_path(relative, destination_root)\n          assert File.exist?(absolute), \"Expected file #{relative.inspect} to exist, but does not\"\n\n          read = File.read(absolute) if block_given? || !contents.empty?\n          assert_nothing_raised { yield read } if block_given?\n\n          contents.each do |content|\n            case content\n            when String\n              assert_equal content, read\n            when Regexp\n              assert_match content, read\n            end",
        "comment": "Asserts a given file exists. You need to supply an absolute path or a path relative to the configured destination:  assert_file \"config/environment.rb\"  You can also give extra arguments. If the argument is a regexp, it will check if the regular expression matches the given file content. If it's a string, it compares the file with the given string:  assert_file \"config/environment.rb\", /initialize/  Finally, when a block is given, it yields the file content:  assert_file \"app/controllers/products_controller.rb\" do |controller| assert_instance_method :index, controller do |index| assert_match(/Product\\.all/, index) end end",
        "label": "How-to-use",
        "id": "14790"
    },
    {
        "raw_code": "def get(path, opts = {}, &block)\n        conditions = @conditions.dup\n        route('GET', path, opts, &block)\n\n        @conditions = conditions\n        route('HEAD', path, opts, &block)\n      end",
        "comment": "Defining a `GET` handler also automatically defines a `HEAD` handler.",
        "label": "How-to-use",
        "id": "8610"
    },
    {
        "raw_code": "def resolvable?\n    potentially_resolvable? && !system?\n  end",
        "comment": "Keep this method in sync with the `resolvable` scope",
        "label": "How-to-use",
        "id": "7372"
    },
    {
        "raw_code": "def write_markdown(filename = 'markdown_spec')\n    File.open(Rails.root.join(\"tmp/capybara/#{filename}.html\"), 'w') do |file|\n      file.puts @html\n    end",
        "comment": "Sometimes it can be useful to see the parsed output of the Markdown document for debugging. Call this method to write the output to `tmp/capybara/<filename>.html`.",
        "label": "How-to-use",
        "id": "8267"
    },
    {
        "raw_code": "def dig(node, *attrs)\n              obj = node\n              attrs.each do |attr|\n                if obj.respond_to?(attr)\n                  obj = obj.public_send(attr) # rubocop:disable GitlabSecurity/PublicSend\n                else\n                  obj = nil\n                  break\n                end",
        "comment": "Like Hash#dig, traverse attributes in sequential order and return the final value. Return nil if any of the fields are not available.",
        "label": "How-to-use",
        "id": "3198"
    },
    {
        "raw_code": "def do_something\n        end",
        "comment": "{method} Foo",
        "label": "How-to-use",
        "id": "10801"
    },
    {
        "raw_code": "def self.register(directive, &block)\n    @registered[directive] = block\n  end",
        "comment": " Registers +directive+ as one handled by RDoc.  If a block is given the directive will be replaced by the result of the block, otherwise the directive will be removed from the processed text.  The block will be called with the directive name and the directive parameter:  RDoc::Markup::PreProcess.register 'my-directive' do |directive, param| # replace text, etc. end",
        "label": "How-to-use",
        "id": "16364"
    },
    {
        "raw_code": "def permission_table_for_guest_feature_access_and_non_private_project_only\n    :public   | :enabled  | :admin      | true  | 1\n    :public   | :enabled  | :admin      | false | 1\n    :public   | :enabled  | :reporter   | nil   | 1\n    :public   | :enabled  | :guest      | nil   | 1\n    :public   | :enabled  | :non_member | nil   | 1\n    :public   | :enabled  | :anonymous  | nil   | 1\n\n    :public   | :private  | :admin      | true  | 1\n    :public   | :private  | :admin      | false | 0\n    :public   | :private  | :reporter   | nil   | 1\n    :public   | :private  | :guest      | nil   | 1\n    :public   | :private  | :non_member | nil   | 0\n    :public   | :private  | :anonymous  | nil   | 0\n\n    :public   | :disabled | :reporter   | nil   | 0\n    :public   | :disabled | :guest      | nil   | 0\n    :public   | :disabled | :non_member | nil   | 0\n    :public   | :disabled | :anonymous  | nil   | 0\n\n    :internal | :enabled  | :admin      | true  | 1\n    :internal | :enabled  | :admin      | false | 1\n    :internal | :enabled  | :reporter   | nil   | 1\n    :internal | :enabled  | :guest      | nil   | 1\n    :internal | :enabled  | :non_member | nil   | 1\n    :internal | :enabled  | :anonymous  | nil   | 0\n\n    :internal | :private  | :admin      | true  | 1\n    :internal | :private  | :admin      | false | 0\n    :internal | :private  | :reporter   | nil   | 1\n    :internal | :private  | :guest      | nil   | 1\n    :internal | :private  | :non_member | nil   | 0\n    :internal | :private  | :anonymous  | nil   | 0\n\n    :internal | :disabled | :reporter   | nil   | 0\n    :internal | :disabled | :guest      | nil   | 0\n    :internal | :disabled | :non_member | nil   | 0\n    :internal | :disabled | :anonymous  | nil   | 0\n\n    :private  | :private  | :admin      | true  | 1\n    :private  | :private  | :admin      | false | 0\n    :private  | :private  | :reporter   | nil   | 1\n    :private  | :private  | :guest      | nil   | 0\n    :private  | :private  | :non_member | nil   | 0\n    :private  | :private  | :anonymous  | nil   | 0\n\n    :private  | :disabled | :reporter   | nil   | 0\n    :private  | :disabled | :guest      | nil   | 0\n    :private  | :disabled | :non_member | nil   | 0\n    :private  | :disabled | :anonymous  | nil   | 0\n  end",
        "comment": "This table is based on permission_table_for_guest_feature_access, but with a slight twist. Some features can be hidden away to GUEST, when project is private. (see ProjectFeature::PRIVATE_FEATURES_MIN_ACCESS_LEVEL_FOR_PRIVATE_PROJECT) This is the table for such features.  e.g. `repository` feature has minimum requirement of GUEST, but a GUEST are prohibited from reading code if project is private.  project_level, :feature_access_level, :membership, :admin_mode, :expected_count",
        "label": "How-to-use",
        "id": "8334"
    },
    {
        "raw_code": "def expect_rendered\n    render\n    expect(rendered)\n  end",
        "comment": "Wraps the `rendered` in `expect` to make it the target of an expectation. Designed to read nicely for one-liners. rubocop:disable RSpec/VoidExpect",
        "label": "How-to-use",
        "id": "8412"
    },
    {
        "raw_code": "def translated_descriptions\n    definition.transform_values { |definition| _(definition[:description]) }\n  end",
        "comment": "Return list of dynamically translated descriptions.  It is required to define descriptions with `N_(...)`.  See https://github.com/grosser/fast_gettext#n_-and-nn_-make-dynamic-translations-available-to-the-parser",
        "label": "How-to-use",
        "id": "1308"
    },
    {
        "raw_code": "def initialize(routing_rules)\n        @rule_evaluators = parse_routing_rules(routing_rules)\n      end",
        "comment": "call-seq: router = WorkerRouter.new([ [\"resource_boundary=cpu\", 'cpu_boundary'], [\"feature_category=pages\", nil], [\"feature_category=source_code_management\", ''], [\"*\", \"default\"] ]) router.route(ACpuBoundaryWorker) # Return \"cpu_boundary\" router.route(JustAPagesWorker)   # Return \"just_a_pages_worker\" router.route(PostReceive)        # Return \"post_receive\" router.route(RandomWorker)       # Return \"default\"  This class is responsible for routing a Sidekiq worker to a certain queue defined in the input routing rules. The input routing rules, as described above, is an order-matter array of tuples [query, queue_name].  - The query syntax follows \"worker matching query\" detailedly denoted in doc/administration/operations/extra_sidekiq_processes.md.  - The queue_name must be a valid Sidekiq queue name. If the queue name is nil, or an empty string, the worker is routed to the queue generated by the name of the worker instead.  Rules are evaluated from first to last, and as soon as we find a match for a given worker we stop processing for that worker (first match wins). If the worker doesn't match any rule, it falls back the queue name generated from the worker name  For further information, please visit: https://gitlab.com/gitlab-com/gl-infra/scalability/-/issues/1016 ",
        "label": "How-to-use",
        "id": "2026"
    },
    {
        "raw_code": "def reset!\n        clear_cache!(new_connection: true)\n        reset_transaction\n        attempt_configure_connection\n      end",
        "comment": "Reset the state of this connection, directing the DBMS to clear transactions and other connection-related server-side state. Usually a database-dependent operation.  If a database driver or protocol does not support such a feature, implementors may alias this to #reconnect!. Otherwise, implementors should call super immediately after resetting the connection (and while still holding @lock).",
        "label": "How-to-use",
        "id": "1170"
    },
    {
        "raw_code": "def set_namespace_context\n      @project ||= Project.find_by_full_path(permitted_params[:project]) if permitted_params[:project].present?\n      @group ||= Group.find_by_full_path(permitted_params[:group]) if permitted_params[:group].present?\n    end",
        "comment": "When `set_current_context` in app/controllers/application_controller.rb calls `to_lazy_hash` on Gitlab::ApplicationContext, the meta fields (meta.project and meta.root_namespace) will be populated using @group or @project variables.",
        "label": "How-to-use",
        "id": "6484"
    },
    {
        "raw_code": "def strip_heredoc\n    gsub(/^#{scan(/^[ \\t]*(?=\\S)/).min}/, \"\").tap do |stripped|\n      stripped.freeze if frozen?\n    end",
        "comment": "Strips indentation in heredocs.  For example in  if options[:usage] puts <<-USAGE.strip_heredoc This command does such and such.  Supported options are: -h         This message ... USAGE end  the user would see the usage message aligned against the left margin.  Technically, it looks for the least indented non-empty line in the whole string, and removes that amount of leading whitespace.",
        "label": "How-to-use",
        "id": "14383"
    },
    {
        "raw_code": "def document(generator, options, destination)\n    generator_name = generator\n\n    options = options.dup\n    options.exclude ||= [] # TODO maybe move to RDoc::Options#finish\n    options.setup_generator generator\n    options.op_dir = destination\n    Dir.chdir @spec.full_gem_path do\n      options.finish\n    end",
        "comment": " Generates documentation using the named +generator+ (\"darkfish\" or \"ri\") and following the given +options+.  Documentation will be generated into +destination+",
        "label": "How-to-use",
        "id": "15902"
    },
    {
        "raw_code": "def print_list(base, namespaces)\n            return if namespaces.empty?\n            puts \"#{base.camelize}:\"\n\n            namespaces.each do |namespace|\n              puts(\"  #{namespace}\")\n            end",
        "comment": "Prints a list of generators.",
        "label": "How-to-use",
        "id": "14716"
    },
    {
        "raw_code": "def unregister_observer(observer)\n        Mail.unregister_observer(observer_class_for(observer))\n      end",
        "comment": "Unregister a previously registered Observer. Either a class, string, or symbol can be passed in as the Observer. If a string or symbol is passed in it will be camelized and constantized.",
        "label": "How-to-use",
        "id": "11111"
    },
    {
        "raw_code": "def format_help(string)\n        pastel.bright_black(string)\n      end",
        "comment": "When to format as \"help\": - To format supplemental information on how to interact with prompts. This should always be in parenthesis. - To indicate disabled or unavailable menu options. - To indicate meta-information in menu options or informational text.",
        "label": "How-to-use",
        "id": "5345"
    },
    {
        "raw_code": "def call(request)\n          self.request = request\n          self.path ||= request.path_info[1..-1]\n          self.headers = {'Content-Type' => 'text/html'}\n          self.body = ''\n          self.status = 200\n          add_cache_control\n          begin\n            run\n          rescue FinishRequest\n            nil # noop\n          rescue NotFoundError => e\n            self.body = e.message if e.message != e.class.to_s\n            not_found\n          end",
        "comment": "The main method called by a router with a request object.  @note This command should not be overridden by subclasses. Implement the callback method {#run} instead. @param [Adapter Dependent] request the request object @return [Array(Numeric,Hash,Array<String>)] a Rack-style response of status, headers, and body wrapped in an array.",
        "label": "How-to-use",
        "id": "700"
    },
    {
        "raw_code": "def to_normalized_s\n          self.class.new(*to_a).to_s.downcase\n        end",
        "comment": " Return the DN as an escaped and normalized string.",
        "label": "How-to-use",
        "id": "2350"
    },
    {
        "raw_code": "def find_lineno_offset(compiled, source_lines, highlight, error_lineno)\n          first_index = error_lineno - 1 - compiled.size + source_lines.size\n          first_index = 0 if first_index < 0\n\n          last_index = error_lineno - 1\n          last_index = source_lines.size - 1 if last_index >= source_lines.size\n\n          last_index.downto(first_index) do |line_index|\n            next unless source_lines[line_index].include?(highlight)\n            return error_lineno - 1 - line_index\n          end",
        "comment": "Return the offset between the error lineno and the source lineno. Searches in reverse from the backtrace lineno so we have a better chance of finding the correct line  The compiled template is likely to be longer than the source. Use the difference between the compiled and source sizes to determine the earliest line that could contain the highlight.",
        "label": "How-to-use",
        "id": "12024"
    },
    {
        "raw_code": "def hello\n        end",
        "comment": " Description of `hello` method. ",
        "label": "How-to-use",
        "id": "10799"
    },
    {
        "raw_code": "def permission_table_for_notes_feature_access\n    :public   | :enabled  | :admin      | true  | 2\n    :public   | :enabled  | :admin      | false | 1\n    :public   | :enabled  | :reporter   | nil   | 2\n    :public   | :enabled  | :guest      | nil   | 1\n    :public   | :enabled  | :non_member | nil   | 1\n    :public   | :enabled  | :anonymous  | nil   | 1\n\n    :public   | :private  | :admin      | true  | 2\n    :public   | :private  | :admin      | false | 0\n    :public   | :private  | :reporter   | nil   | 2\n    :public   | :private  | :guest      | nil   | 1\n    :public   | :private  | :non_member | nil   | 0\n    :public   | :private  | :anonymous  | nil   | 0\n\n    :public   | :disabled | :reporter   | nil   | 0\n    :public   | :disabled | :guest      | nil   | 0\n    :public   | :disabled | :non_member | nil   | 0\n    :public   | :disabled | :anonymous  | nil   | 0\n\n    :internal | :enabled  | :admin      | true  | 2\n    :internal | :enabled  | :admin      | false | 1\n    :internal | :enabled  | :reporter   | nil   | 2\n    :internal | :enabled  | :guest      | nil   | 1\n    :internal | :enabled  | :non_member | nil   | 1\n    :internal | :enabled  | :anonymous  | nil   | 0\n\n    :internal | :private  | :admin      | true  | 2\n    :internal | :private  | :admin      | false | 0\n    :internal | :private  | :reporter   | nil   | 2\n    :internal | :private  | :guest      | nil   | 1\n    :internal | :private  | :non_member | nil   | 0\n    :internal | :private  | :anonymous  | nil   | 0\n\n    :internal | :disabled | :reporter   | nil   | 0\n    :internal | :disabled | :guest      | nil   | 0\n    :internal | :disabled | :non_member | nil   | 0\n    :internal | :disabled | :anonymous  | nil   | 0\n\n    :private  | :private  | :admin      | true  | 2\n    :private  | :private  | :admin      | false | 0\n    :private  | :private  | :reporter   | nil   | 2\n    :private  | :private  | :guest      | nil   | 1\n    :private  | :private  | :non_member | nil   | 0\n    :private  | :private  | :anonymous  | nil   | 0\n\n    :private  | :disabled | :reporter   | nil   | 0\n    :private  | :disabled | :guest      | nil   | 0\n    :private  | :disabled | :non_member | nil   | 0\n    :private  | :disabled | :anonymous  | nil   | 0\n  end",
        "comment": "This table is based on permission_table_for_guest_feature_access, but takes into account note confidentiality. It is required on the context to have one regular note and one confidential note.  project_level, :feature_access_level, :membership, :admin_mode, :expected_count",
        "label": "How-to-use",
        "id": "8333"
    },
    {
        "raw_code": "def display_version_info\n        server_version = ServerInfo.new.version_info\n        return server_version if server_version&.valid?\n        return version_info_from_file if version_info_from_file.valid?\n\n        Gitlab.version_info\n      end",
        "comment": "Return GitLab KAS version info for display This is the version that is displayed on the `frontend`. This is also used to check if the version of an existing agent does not match the latest agent version. If the getServerInfo RPC call fails, we fallback to GITLAB_KAS_VERSION file; If the GITLAB_KAS_VERSION file contains a SHA, we defer instead to the Gitlab version.  For further details, see: https://gitlab.com/gitlab-org/gitlab/-/merge_requests/149794  @return [Gitlab::VersionInfo] version_info",
        "label": "How-to-use",
        "id": "1619"
    },
    {
        "raw_code": "def fallback_to_replicas_for_ambiguous_queries\n          previous_flag = @fallback_to_replicas_for_ambiguous_queries\n          @fallback_to_replicas_for_ambiguous_queries = true\n          yield\n        ensure\n          @fallback_to_replicas_for_ambiguous_queries = previous_flag\n        end",
        "comment": "Indicate that the ambiguous SQL statements from anywhere inside this block should use a replica. The ambiguous statements include: - Transactions. - Custom queries (via exec_query, execute, etc.) - In-flight connection configuration change (SET LOCAL statement_timeout = 5000)  This is a weak enforcement. This helper incorporates well with primary stickiness: - If the queries are about to write - The current session already performed writes - It prefers to use primary, aka, use_primary or use_primary! were called",
        "label": "How-to-use",
        "id": "3085"
    },
    {
        "raw_code": "def valid_raw_connection\n          (@verified && @raw_connection) ||\n            # `allow_retry: false`, to force verification: the block won't\n            # raise, so a retry wouldn't help us get the valid connection we\n            # need.\n            with_raw_connection(allow_retry: false, materialize_transactions: false) { |conn| conn }\n        end",
        "comment": "Similar to any_raw_connection, but ensures it is validated and connected. Any method called on this result still needs to be independently thread-safe, so it probably shouldn't talk to the server... but some drivers fail if they know the connection has gone away.",
        "label": "How-to-use",
        "id": "12941"
    },
    {
        "raw_code": "def relation(**)\n          base_relation\n        end",
        "comment": "Implement this one if you want to filter the relation",
        "label": "How-to-use",
        "id": "2102"
    },
    {
        "raw_code": "def arguments_range(node)\n        node.first_argument.source_range.join(node.last_argument.source_range)\n      end",
        "comment": "A range containing the first to the last argument of a method call or method definition. def foo(a, b:) ^^^^^ bar(1, 2, 3, &blk) ^^^^^^^^^^^^^ baz { |x, y:, z:| } ^^^^^^^^^",
        "label": "How-to-use",
        "id": "10440"
    },
    {
        "raw_code": "def call(severity, timestamp, progname, msg)\n        \"#{String === msg ? msg : msg.inspect}\\n\"\n      end",
        "comment": "This method is invoked when a log event occurs",
        "label": "How-to-use",
        "id": "13899"
    },
    {
        "raw_code": "def initialize(group_path:, seed_count:, publish:)\n            @group = Group.find_by_full_path(group_path)\n            @seed_count = seed_count\n            @publish = publish\n            @current_user = @group&.first_owner\n          end",
        "comment": "Initializes the class  @param [String] Path of the group to find @param [Integer] Number of resources to create @param[Boolean] If the created resources should be published or not, defaults to false",
        "label": "How-to-use",
        "id": "2666"
    },
    {
        "raw_code": "def execute(*command, &block)\n          # Get the options hash if it exists\n          opts = {}\n          opts = command.pop if command.last.is_a?(Hash)\n\n          tries = 0\n          tries = 3 if opts[:retryable]\n\n          # Variable to store our execution result\n          r = nil\n\n          retryable(on: Vagrant::Errors::VBoxManageError, tries: tries, sleep: 1) do\n            # If there is an error with VBoxManage, this gets set to true\n            errored = false\n\n            # Execute the command\n            r = raw(*command, &block)\n\n            # If the command was a failure, then raise an exception that is\n            # nicely handled by Vagrant.\n            if r.exit_code != 0\n              if @interrupted\n                @logger.info(\"Exit code != 0, but interrupted. Ignoring.\")\n              elsif r.exit_code == 126\n                # This exit code happens if VBoxManage is on the PATH,\n                # but another executable it tries to execute is missing.\n                # This is usually indicative of a corrupted VirtualBox install.\n                raise Vagrant::Errors::VBoxManageNotFoundError\n              else\n                errored = true\n              end",
        "comment": "Execute the given subcommand for VBoxManage and return the output.",
        "label": "How-to-use",
        "id": "9602"
    },
    {
        "raw_code": "def lease_connection\n        lease = connection_lease\n        lease.connection ||= checkout\n        lease.sticky = true\n        lease.connection\n      end",
        "comment": "Retrieve the connection associated with the current thread, or call #checkout to obtain one if necessary.  #lease_connection can be called any number of times; the connection is held in a cache keyed by a thread.",
        "label": "How-to-use",
        "id": "13014"
    },
    {
        "raw_code": "def initialize\n    @current       = nil\n    @generator     = nil\n    @last_modified = {}\n    @old_siginfo   = nil\n    @options       = nil\n    @stats         = nil\n    @store         = nil\n  end",
        "comment": " Creates a new RDoc::RDoc instance.  Call #document to parse files and generate documentation.",
        "label": "How-to-use",
        "id": "16006"
    },
    {
        "raw_code": "def to_fs(format = :default)\n    if formatter = DATE_FORMATS[format]\n      if formatter.respond_to?(:call)\n        formatter.call(self).to_s\n      else\n        strftime(formatter)\n      end",
        "comment": "Convert to a formatted string. See DATE_FORMATS for predefined formats.  This method is aliased to <tt>to_formatted_s</tt>.  date = Date.new(2007, 11, 10)       # => Sat, 10 Nov 2007  date.to_fs(:db)                     # => \"2007-11-10\" date.to_formatted_s(:db)            # => \"2007-11-10\"  date.to_fs(:short)         # => \"10 Nov\" date.to_fs(:number)        # => \"20071110\" date.to_fs(:long)          # => \"November 10, 2007\" date.to_fs(:long_ordinal)  # => \"November 10th, 2007\" date.to_fs(:rfc822)        # => \"10 Nov 2007\" date.to_fs(:rfc2822)       # => \"10 Nov 2007\" date.to_fs(:iso8601)       # => \"2007-11-10\"  == Adding your own date formats to to_fs You can add your own formats to the Date::DATE_FORMATS hash. Use the format name as the hash key and either a strftime string or Proc instance that takes a date argument as the value.  # config/initializers/date_formats.rb Date::DATE_FORMATS[:month_and_year] = '%B %Y' Date::DATE_FORMATS[:short_ordinal] = ->(date) { date.strftime(\"%B #{date.day.ordinalize}\") }",
        "label": "How-to-use",
        "id": "14126"
    },
    {
        "raw_code": "def job_version\n        @job_version ||= self.class.version\n      end",
        "comment": "Version is not set if `new.perform` is called directly, and in that case we fallback to latest version",
        "label": "How-to-use",
        "id": "2905"
    },
    {
        "raw_code": "def perform_request(http_method, path, options, &block)\n          raise_if_options_are_invalid(options)\n          raise_if_blocked_by_silent_mode(http_method) if options.delete(:silent_mode_enabled)\n\n          log_info = options.delete(:extra_log_info)\n          async = options.delete(:async)\n\n          options_with_timeouts =\n            if !options.has_key?(:timeout)\n              options.with_defaults(DEFAULT_TIMEOUT_OPTIONS)\n            else\n              options\n            end",
        "comment": "TODO: This overwrites a method implemented by `HTTPParty` The calls to `get/...` will call this method instead of `httparty_perform_request`",
        "label": "How-to-use",
        "id": "1197"
    },
    {
        "raw_code": "def self.similarity_function_call(search, column)\n        Arel::Nodes::NamedFunction.new(SIMILARITY_FUNCTION_CALL_WITH_ANNOTATION, [column, Arel.sql(search)])\n      end",
        "comment": "SIMILARITY(COALESCE(column, ''), 'search_string')",
        "label": "How-to-use",
        "id": "3019"
    },
    {
        "raw_code": "def change_task_status(new_task)\n      status_label = new_task.complete? ? Taskable::COMPLETED : Taskable::INCOMPLETE\n      body = \"marked the checklist item **#{new_task.source}** as #{status_label}\"\n\n      track_issue_event(:track_issue_description_changed_action)\n\n      create_note(NoteSummary.new(noteable, project, author, body, action: 'task'))\n    end",
        "comment": "Called when the status of a Task has changed  new_task  - TaskList::Item object.  Example Note text:  \"marked the checklist item Whatever as completed.\"  Returns the created Note object",
        "label": "How-to-use",
        "id": "5621"
    },
    {
        "raw_code": "def first?\n      index == 0\n    end",
        "comment": "Check if this is the first iteration of the partial.",
        "label": "How-to-use",
        "id": "12003"
    },
    {
        "raw_code": "def progress_bar(current_title, titles = [])\n        step = titles.index(current_title)\n        total = titles.length - 1\n\n        raise ArgumentError, \"Invalid selection #{current_title} in progress bar\" unless step\n\n        status = \" Step #{step} / #{total} : #{titles.join(' > ')}\"\n        status.gsub!(current_title, format_selection(current_title))\n\n        total_length = window_size - 4\n        step_length = step / total.to_f * total_length\n\n        incomplete = '-' * [(total_length - step_length - 1), 0].max\n        complete = '=' * [(step_length - 1), 0].max\n\n        \"#{status}\\n|==#{complete}>#{incomplete}|\\n\"\n      end",
        "comment": "Prints a progress bar on the screen at the current location @param current_title [String] title to highlight @param titles [Array<String>] progression to follow; -> first element is expected to be a title for the entire flow",
        "label": "How-to-use",
        "id": "5352"
    },
    {
        "raw_code": "def id\n        return super unless object.is_a?(SyntheticNote)\n\n        # object is a presenter, so object.object returns the concrete note object.\n        ::Gitlab::GlobalId.build(object, model_name: object.object.class.to_s, id: object.discussion_id)\n      end",
        "comment": "We now support also SyntheticNote notes as a NoteType, but SyntheticNote does not have a real note ID, as SyntheticNote is generated dynamically from a ResourceEvent instance.",
        "label": "How-to-use",
        "id": "6224"
    },
    {
        "raw_code": "def callback_url\n        full_host + callback_path\n      end",
        "comment": "NOTE: Overriding the callback_url method since in certain cases IDP doesn't return the correct ACS URL for us to validate See: https://gitlab.com/gitlab-org/gitlab/-/issues/491634",
        "label": "How-to-use",
        "id": "1268"
    },
    {
        "raw_code": "def path\n    \"#{@parent.path}##{aref}\"\n  end",
        "comment": " Path to this method for use with HTML generator output.",
        "label": "How-to-use",
        "id": "16830"
    },
    {
        "raw_code": "def token_to_str(t)\n      self.class::Racc_token_to_s_table[t]\n    end",
        "comment": "Convert internal ID of token symbol to the string.",
        "label": "How-to-use",
        "id": "16534"
    },
    {
        "raw_code": "def expression_column_name?(column_name)\n          column_name.is_a?(String) && /\\W/.match?(column_name)\n        end",
        "comment": "Try to identify whether the given column name is an expression",
        "label": "How-to-use",
        "id": "13181"
    },
    {
        "raw_code": "def search_truncate(source)\n    Truncato.truncate(\n      source,\n      count_tags: false,\n      count_tail: false,\n      filtered_tags: %w[img],\n      max_length: 200\n    )\n  end",
        "comment": "Sanitize a HTML field for search display. Most tags are stripped out and the maximum length is set to 200 characters.",
        "label": "How-to-use",
        "id": "7744"
    },
    {
        "raw_code": "def notice\n        self[:notice]\n      end",
        "comment": "Convenience accessor for `flash[:notice]`.",
        "label": "How-to-use",
        "id": "11532"
    },
    {
        "raw_code": "def authsources\n          @authsources ||= begin\n            authsources_filename = \"simplesamlphp_authsources.php\"\n            authsources_file = ERB.new(read_fixture('saml', \"#{authsources_filename}.erb\")).result(binding)\n            # On ci when using gitlab-qa gem, tests run in a separate container which uses it's own copy of `qa` code\n            # This makes mounting files with DinD setup impossible because docker commands are running on separate\n            #  docker service container which only has access to the checked out code at `ci_project_dir` location.\n            # Test container started by gitlab-qa shares a common folder with job environment via `rspec` folder so to\n            #  correctly mount it, the mount path needs to be changed to one docker will have access to\n            # This still won't work when running gitlab-qa locally because by default gitlab-qa does not have a volume\n            #  that allows to share files between host and test container yet it will mount docker socket by default\n            if Runtime::Env.running_in_ci? && Runtime::Path.qa_root == \"/home/gitlab/qa\"\n              ::File.join(Runtime::Path.qa_root, \"rspec\", authsources_filename).then do |path|\n                ::File.write(path, authsources_file)\n                path.gsub(Runtime::Path.qa_root, \"#{Runtime::Env.ci_project_dir}/qa\")\n              end",
        "comment": "Creates an authsources file in qa root in `tmp` or `rspec` directory (for ci) from a template at `qa/qa/fixtures/saml/simplesamlphp_authsources.php.erb` with group sync permitted by inserting the value of `@group` as the groups attribute and `@users` as the users attribute in the template This allows generating users for saml tests dynamically See: https://docs.gitlab.com/ee/user/group/saml_sso/group_sync.html#configure-saml-group-sync",
        "label": "How-to-use",
        "id": "4225"
    },
    {
        "raw_code": "def original_total_time_spent\n    @original_total_time_spent ||= total_time_spent\n  end",
        "comment": "we need to cache the total time spent so multiple calls to #valid? doesn't give a false error",
        "label": "How-to-use",
        "id": "7278"
    },
    {
        "raw_code": "def execute(recheck: false, retry_lease: true)\n      return service_error if service_error\n\n      in_write_lock(retry_lease: retry_lease) do |retried|\n        # When multiple calls are waiting for the same lock (retry_lease),\n        # it's possible that when granted, the MR status was already updated for\n        # that object, therefore we reset if there was a lease retry.\n        merge_request.reset if retried\n\n        check_mergeability(recheck)\n      end",
        "comment": "Updates the MR merge_status. Whenever it switches to a can_be_merged state, the merge-ref is refreshed.  recheck - When given, it'll enforce a merge-ref refresh if the current merge_status is can_be_merged or cannot_be_merged and merge-ref is outdated. Given MergeRequests::RefreshService is called async, it might happen that the target branch gets updated, but the MergeRequest#merge_status lags behind. So in scenarios where we need the current state of the merge ref in repository, the `recheck` argument is required.  retry_lease - Concurrent calls wait for at least 10 seconds until the lease is granted (other process finishes running). Returns an error ServiceResponse if the lease is not granted during this time.  Returns a ServiceResponse indicating merge_status is/became can_be_merged and the merge-ref is synced. Success in case of being/becoming mergeable, error otherwise.",
        "label": "How-to-use",
        "id": "5578"
    },
    {
        "raw_code": "def session_token\n          @session_token ||= `echo '#{@password}' | op account add --address #{@address} --email #{@email} --secret-key #{@secret} --signin --raw`\n        end",
        "comment": "OP session tokens are valid for 30 minutes. We are caching the session token here and this is fine currently as we just have one test that is not expected to go over 30 minutes. But note that if we add more tests that use this class, we might need to add a mechanism to invalidate the cache after 30 minutes or if the session_token is rejected by op CLI.",
        "label": "How-to-use",
        "id": "4353"
    },
    {
        "raw_code": "def email_action(url)\n    name = action_title(url)\n    return unless name\n\n    gmail_goto_action(name, url)\n  end",
        "comment": "Google Actions https://developers.google.com/gmail/markup/reference/go-to-action",
        "label": "How-to-use",
        "id": "7712"
    },
    {
        "raw_code": "def technical_description\n      event_name = actions.first if events.length == 1 && !filtered?\n      event_name ||= 'the selected events'\n      [\n        (time_frame.description if time_frame.single?),\n        (operator.description if event_metric?),\n        ((identifier.description % event_name).to_s if event_metric?)\n      ].compact.join(' ').capitalize\n    end",
        "comment": "Provides simplified but technically accurate description to be used before the user has provided a description",
        "label": "How-to-use",
        "id": "5306"
    },
    {
        "raw_code": "def initialize_capabilities!(host, hosts, capabilities, *args)\n      @cap_logger = Log4r::Logger.new(\n        \"vagrant::capability_host::#{self.class.to_s.downcase}\")\n\n      if host && !hosts[host]\n        raise Errors::CapabilityHostExplicitNotDetected, value: host.to_s\n      end",
        "comment": "Initializes the capability system by detecting the proper capability host to execute on and building the chain of capabilities to execute.  @param [Symbol] host The host to use for the capabilities, or nil if we should auto-detect it. @param [Hash<Symbol, Array<Class, Symbol>>] hosts Potential capability hosts. The key is the name of the host, value[0] is a class that implements `#detect?` and value[1] is a parent host (if any). @param [Hash<Symbol, Hash<Symbol, Class>>] capabilities The capabilities that are supported. The key is the host of the capability. Within that is a hash where the key is the name of the capability and the value is the class/module implementing it.",
        "label": "How-to-use",
        "id": "8772"
    },
    {
        "raw_code": "def organizations(user = nil, options = {})\n        paginate \"#{User.path user}/orgs\", options\n      end",
        "comment": "Get organizations for a user.  Nonauthenticated calls to this method will return organizations that the user is a public member.  Use an authenticated client to get both public and private organizations for a user.  Calling this method on a `@client` will return that users organizations. Private organizations are included only if the `@client` is authenticated.  @param user [Integer, String] GitHub user login or id of the user to get list of organizations. @return [Array<Sawyer::Resource>] Array of hashes representing organizations. @see https://developer.github.com/v3/orgs/#list-your-organizations @see https://developer.github.com/v3/orgs/#list-user-organizations @example Octokit.organizations('pengwynn') @example @client.organizations('pengwynn') @example Octokit.orgs('pengwynn') @example Octokit.list_organizations('pengwynn') @example Octokit.list_orgs('pengwynn') @example @client.organizations",
        "label": "How-to-use",
        "id": "15418"
    },
    {
        "raw_code": "def etag=(weak_validators)\n          self.weak_etag = weak_validators\n        end",
        "comment": "This method sets a weak ETag validator on the response so browsers and proxies may cache the response, keyed on the ETag. On subsequent requests, the `If-None-Match` header is set to the cached ETag. If it matches the current ETag, we can return a `304 Not Modified` response with no body, letting the browser or proxy know that their cache is current. Big savings in request time and network bandwidth.  Weak ETags are considered to be semantically equivalent but not byte-for-byte identical. This is perfect for browser caching of HTML pages where we don't care about exact equality, just what the user is viewing.  Strong ETags are considered byte-for-byte identical. They allow a browser or proxy cache to support `Range` requests, useful for paging through a PDF file or scrubbing through a video. Some CDNs only support strong ETags and will ignore weak ETags entirely.  Weak ETags are what we almost always need, so they're the default. Check out #strong_etag= to provide a strong ETag validator.",
        "label": "How-to-use",
        "id": "11413"
    },
    {
        "raw_code": "def begin_db_transaction()    end\n\n      def begin_deferred_transaction(isolation_level = nil) # :nodoc:\n        if isolation_level\n          begin_isolated_db_transaction(isolation_level)\n        else\n          begin_db_transaction\n        end\n      end",
        "comment": "Begins the transaction (and turns off auto-committing).",
        "label": "How-to-use",
        "id": "13069"
    },
    {
        "raw_code": "def message_chained_with_dot?(node)\n          return false if node.root?\n\n          parent = node.parent\n          return false if !parent.call_type? || parent.children.first != node\n\n          parent.dot? || parent.safe_navigation?\n        end",
        "comment": "Check if the node is a receiver and receives a message with dot syntax.",
        "label": "How-to-use",
        "id": "10497"
    },
    {
        "raw_code": "def qparams(options)\n      stringified_options = options.transform_keys(&:to_s)\n\n      to_query_string(params.merge(stringified_options))\n    end",
        "comment": "Merge options with current params, filter safe params, and stringify to query string",
        "label": "How-to-use",
        "id": "5216"
    },
    {
        "raw_code": "def self.shutdown\n        Templates::Template.extra_includes -= [YARD::Server::DocServerHelper]\n        Templates::Engine.template_paths -= [File.dirname(__FILE__) + '/templates']\n      end",
        "comment": "Performs any global shutdown procedures for the adapter. @note If you subclass this method, make sure to call +super+. @return [void]",
        "label": "How-to-use",
        "id": "649"
    },
    {
        "raw_code": "def dig(*keys)\n      convert_hashes_to_parameters(keys.first, @parameters[keys.first])\n      @parameters.dig(*keys)\n    end",
        "comment": "Extracts the nested parameter from the given `keys` by calling `dig` at each step. Returns `nil` if any intermediate step is `nil`.  params = ActionController::Parameters.new(foo: { bar: { baz: 1 } }) params.dig(:foo, :bar, :baz) # => 1 params.dig(:foo, :zot, :xyz) # => nil  params2 = ActionController::Parameters.new(foo: [10, 11, 12]) params2.dig(:foo, 1) # => 11",
        "label": "How-to-use",
        "id": "11369"
    },
    {
        "raw_code": "def do_worker_start\n          call(:worker_start_hooks, @worker_start_hooks)\n        end",
        "comment": " Lifecycle integration methods (called from puma.rb, etc.) ",
        "label": "How-to-use",
        "id": "1971"
    },
    {
        "raw_code": "def locking_enabled?\n            lock_optimistically && columns_hash[locking_column]\n          end",
        "comment": "Returns true if the +lock_optimistically+ flag is set to true (which it is, by default) and the table includes the +locking_column+ column (defaults to +lock_version+).",
        "label": "How-to-use",
        "id": "13327"
    },
    {
        "raw_code": "def gitlab_config\n    Gitlab.config.gitlab\n  end",
        "comment": "shortcut for gitlab config",
        "label": "How-to-use",
        "id": "7721"
    },
    {
        "raw_code": "def delegated_type(role, types:, **options)\n      belongs_to role, options.delete(:scope), **options, polymorphic: true\n      define_delegated_type_methods role, types: types, options: options\n    end",
        "comment": "Defines this as a class that'll delegate its type for the passed +role+ to the class references in +types+. That'll create a polymorphic +belongs_to+ relationship to that +role+, and it'll add all the delegated type convenience methods:  class Entry < ApplicationRecord delegated_type :entryable, types: %w[ Message Comment ], dependent: :destroy end  @entry.entryable_class # => Message or Comment @entry.entryable_name  # => \"message\" or \"comment\" Entry.messages         # => Entry.where(entryable_type: \"Message\") @entry.message?        # => true when entryable_type == \"Message\" @entry.message         # => returns the message record, when entryable_type == \"Message\", otherwise nil @entry.message_id      # => returns entryable_id, when entryable_type == \"Message\", otherwise nil Entry.comments         # => Entry.where(entryable_type: \"Comment\") @entry.comment?        # => true when entryable_type == \"Comment\" @entry.comment         # => returns the comment record, when entryable_type == \"Comment\", otherwise nil @entry.comment_id      # => returns entryable_id, when entryable_type == \"Comment\", otherwise nil  You can also declare namespaced types:  class Entry < ApplicationRecord delegated_type :entryable, types: %w[ Message Comment Access::NoticeMessage ], dependent: :destroy end  Entry.access_notice_messages @entry.access_notice_message @entry.access_notice_message?  ==== Options  The +options+ are passed directly to the +belongs_to+ call, so this is where you declare +dependent+ etc. The following options can be included to specialize the behavior of the delegated type convenience methods.  [+:foreign_key+] Specify the foreign key used for the convenience methods. By default this is guessed to be the passed +role+ with an \"_id\" suffix. So a class that defines a <tt>delegated_type :entryable, types: %w[ Message Comment ]</tt> association will use \"entryable_id\" as the default <tt>:foreign_key</tt>. [+:foreign_type+] Specify the column used to store the associated object's type. By default this is inferred to be the passed +role+ with a \"_type\" suffix. A class that defines a <tt>delegated_type :entryable, types: %w[ Message Comment ]</tt> association will use \"entryable_type\" as the default <tt>:foreign_type</tt>. [+:primary_key+] Specify the method that returns the primary key of associated object used for the convenience methods. By default this is +id+.  Option examples: class Entry < ApplicationRecord delegated_type :entryable, types: %w[ Message Comment ], primary_key: :uuid, foreign_key: :entryable_uuid end  @entry.message_uuid # => returns entryable_uuid, when entryable_type == \"Message\", otherwise nil @entry.comment_uuid # => returns entryable_uuid, when entryable_type == \"Comment\", otherwise nil",
        "label": "How-to-use",
        "id": "12454"
    },
    {
        "raw_code": "def diff_prettyHtml(diffs)\n    diffs.map do |op, data|\n      text = data.gsub('&', '&amp;').gsub('<', '&lt;').gsub('>', '&gt;').gsub('\\n', '&para;<br>')\n      case op\n        when :insert\n          \"<ins style=\\\"background:#e6ffe6;\\\">#{text}</ins>\"\n        when :delete\n          \"<del style=\\\"background:#ffe6e6;\\\">#{text}</del>\"\n        when :equal\n          \"<span>#{text}</span>\"\n      end",
        "comment": "Convert a diff array into a pretty HTML report.",
        "label": "How-to-use",
        "id": "5063"
    },
    {
        "raw_code": "def input_required_text\n        format_help(\"(leave blank for help)\")\n      end",
        "comment": "Help text to use with required, multiline cli#ask prompts. Otherwise, prefer #prompt_for_text.",
        "label": "How-to-use",
        "id": "5337"
    },
    {
        "raw_code": "def create_scan_primary_identifiers\n            return unless scan_data.is_a?(Hash) && scan_data['primary_identifiers']\n\n            scan_data['primary_identifiers'].map do |identifier|\n              ::Gitlab::Ci::Reports::Security::Identifier.new(\n                external_type: identifier['type'],\n                external_id: identifier['value'],\n                name: identifier['name'],\n                url: identifier['url'])\n            end",
        "comment": "TODO: primary_identifiers should be initialized on the scan itself but we do not currently parse scans through `MergeReportsService`",
        "label": "How-to-use",
        "id": "2542"
    },
    {
        "raw_code": "def add_column(table_name, column_name, type, **options)\n        add_column_def = build_add_column_definition(table_name, column_name, type, **options)\n        return unless add_column_def\n\n        execute schema_creation.accept(add_column_def)\n      end",
        "comment": "Add a new +type+ column named +column_name+ to +table_name+.  See {ActiveRecord::ConnectionAdapters::TableDefinition.column}[rdoc-ref:ActiveRecord::ConnectionAdapters::TableDefinition#column].  The +type+ parameter is normally one of the migration's native types, which is one of the following: <tt>:primary_key</tt>, <tt>:string</tt>, <tt>:text</tt>, <tt>:integer</tt>, <tt>:bigint</tt>, <tt>:float</tt>, <tt>:decimal</tt>, <tt>:numeric</tt>, <tt>:datetime</tt>, <tt>:time</tt>, <tt>:date</tt>, <tt>:binary</tt>, <tt>:blob</tt>, <tt>:boolean</tt>.  You may use a type not in this list as long as it is supported by your database (for example, \"polygon\" in MySQL), but this will not be database agnostic and should usually be avoided.  Available options are (none of these exists by default): * <tt>:comment</tt> - Specifies the comment for the column. This option is ignored by some backends. * <tt>:collation</tt> - Specifies the collation for a <tt>:string</tt> or <tt>:text</tt> column. If not specified, the column will have the same collation as the table. * <tt>:default</tt> - The column's default value. Use +nil+ for +NULL+. * <tt>:limit</tt> - Requests a maximum column length. This is the number of characters for a <tt>:string</tt> column and number of bytes for <tt>:text</tt>, <tt>:binary</tt>, <tt>:blob</tt>, and <tt>:integer</tt> columns. This option is ignored by some backends. * <tt>:null</tt> - Allows or disallows +NULL+ values in the column. * <tt>:precision</tt> - Specifies the precision for the <tt>:decimal</tt>, <tt>:numeric</tt>, <tt>:datetime</tt>, and <tt>:time</tt> columns. * <tt>:scale</tt> - Specifies the scale for the <tt>:decimal</tt> and <tt>:numeric</tt> columns. * <tt>:if_not_exists</tt> - Specifies if the column already exists to not try to re-add it. This will avoid duplicate column errors.  Note: The precision is the total number of significant digits, and the scale is the number of digits that can be stored following the decimal point. For example, the number 123.45 has a precision of 5 and a scale of 2. A decimal with a precision of 5 and a scale of 2 can range from -999.99 to 999.99.  Please be aware of different RDBMS implementations behavior with <tt>:decimal</tt> columns: * The SQL standard says the default scale should be 0, <tt>:scale</tt> <= <tt>:precision</tt>, and makes no comments about the requirements of <tt>:precision</tt>. * MySQL: <tt>:precision</tt> [1..65], <tt>:scale</tt> [0..30]. Default is (10,0). * PostgreSQL: <tt>:precision</tt> [1..infinity], <tt>:scale</tt> [0..infinity]. No default. * SQLite3: No restrictions on <tt>:precision</tt> and <tt>:scale</tt>, but the maximum supported <tt>:precision</tt> is 16. No default. * Oracle: <tt>:precision</tt> [1..38], <tt>:scale</tt> [-84..127]. Default is (38,0). * SqlServer: <tt>:precision</tt> [1..38], <tt>:scale</tt> [0..38]. Default (38,0).  == Examples  add_column(:users, :picture, :binary, limit: 2.megabytes) # ALTER TABLE \"users\" ADD \"picture\" blob(2097152)  add_column(:articles, :status, :string, limit: 20, default: 'draft', null: false) # ALTER TABLE \"articles\" ADD \"status\" varchar(20) DEFAULT 'draft' NOT NULL  add_column(:answers, :bill_gates_money, :decimal, precision: 15, scale: 2) # ALTER TABLE \"answers\" ADD \"bill_gates_money\" decimal(15,2)  add_column(:measurements, :sensor_reading, :decimal, precision: 30, scale: 20) # ALTER TABLE \"measurements\" ADD \"sensor_reading\" decimal(30,20)  # While :scale defaults to zero on most databases, it # probably wouldn't hurt to include it. add_column(:measurements, :huge_integer, :decimal, precision: 30) # ALTER TABLE \"measurements\" ADD \"huge_integer\" decimal(30)  # Defines a column that stores an array of a type. add_column(:users, :skills, :text, array: true) # ALTER TABLE \"users\" ADD \"skills\" text[]  # Defines a column with a database-specific type. add_column(:shapes, :triangle, 'polygon') # ALTER TABLE \"shapes\" ADD \"triangle\" polygon  # Ignores the method call if the column exists add_column(:shapes, :triangle, 'polygon', if_not_exists: true)",
        "label": "How-to-use",
        "id": "13147"
    },
    {
        "raw_code": "def test_structure_dump\n      assert_equal \"\", File.read(@filename)\n\n      config = @configuration.dup\n      config[\"database\"] = ARTest.config[\"connections\"][\"postgresql\"][\"arunit\"][\"database\"]\n\n      ActiveRecord::Tasks::DatabaseTasks.structure_dump(config, @filename)\n\n      assert File.read(@filename).include?(\"PostgreSQL database dump complete\")\n    end",
        "comment": "This test actually runs a dump so we can ensure all the arguments are parsed correctly. All other tests in this class just mock the call (using assert_called_with) to make the tests quicker.",
        "label": "How-to-use",
        "id": "13538"
    },
    {
        "raw_code": "def unscope(*args)\n      check_if_method_has_arguments!(__callee__, args)\n      spawn.unscope!(*args)\n    end",
        "comment": "Removes an unwanted relation that is already defined on a chain of relations. This is useful when passing around chains of relations and would like to modify the relations without reconstructing the entire chain.  User.order('email DESC').unscope(:order) == User.all  The method arguments are symbols which correspond to the names of the methods which should be unscoped. The valid arguments are given in VALID_UNSCOPING_VALUES. The method can also be called with multiple arguments. For example:  User.order('email DESC').select('id').where(name: \"John\") .unscope(:order, :select, :where) == User.all  One can additionally pass a hash as an argument to unscope specific +:where+ values. This is done by passing a hash with a single key-value pair. The key should be +:where+ and the value should be the where value to unscope. For example:  User.where(name: \"John\", active: true).unscope(where: :name) == User.where(active: true)  This method is similar to #except, but unlike #except, it persists across merges:  User.order('email').merge(User.except(:order)) == User.order('email')  User.order('email').merge(User.unscope(:order)) == User.all  This means it can be used in association definitions:  has_many :comments, -> { unscope(where: :trashed) } ",
        "label": "How-to-use",
        "id": "13409"
    },
    {
        "raw_code": "def acts_like?(duck)\n    case duck\n    when :time\n      respond_to? :acts_like_time?\n    when :date\n      respond_to? :acts_like_date?\n    when :string\n      respond_to? :acts_like_string?\n    else\n      respond_to? :\"acts_like_#{duck}?\"\n    end",
        "comment": "Provides a way to check whether some class acts like some other class based on the existence of an appropriately-named marker method.  A class that provides the same interface as <tt>SomeClass</tt> may define a marker method named <tt>acts_like_some_class?</tt> to signal its compatibility to callers of <tt>acts_like?(:some_class)</tt>.  For example, Active Support extends <tt>Date</tt> to define an <tt>acts_like_date?</tt> method, and extends <tt>Time</tt> to define <tt>acts_like_time?</tt>. As a result, developers can call <tt>x.acts_like?(:time)</tt> and <tt>x.acts_like?(:date)</tt> to test duck-type compatibility, and classes that are able to act like <tt>Time</tt> can also define an <tt>acts_like_time?</tt> method to interoperate.  Note that the marker method is only expected to exist. It isn't called, so its body or return value are irrelevant.  ==== Example: A class that provides the same interface as <tt>String</tt>  This class may define:  class Stringish def acts_like_string? end end  Then client code can query for duck-type-safeness this way:  Stringish.new.acts_like?(:string) # => true ",
        "label": "How-to-use",
        "id": "14299"
    },
    {
        "raw_code": "def self.get_request_count\n      get_call_count(\"gitaly_call_actual\")\n    end",
        "comment": "Returns the of the number of Gitaly calls made for this request",
        "label": "How-to-use",
        "id": "1371"
    },
    {
        "raw_code": "def add_class(class_type, given_name, superclass = '::Object')\n    # superclass +nil+ is passed by the C parser in the following cases:\n    # - registering Object in 1.8 (correct)\n    # - registering BasicObject in 1.9 (correct)\n    # - registering RubyVM in 1.9 in iseq.c (incorrect: < Object in vm.c)\n    #\n    # If we later find a superclass for a registered class with a nil\n    # superclass, we must honor it.\n\n    # find the name & enclosing context\n    if given_name =~ /^:+(\\w+)$/ then\n      full_name = $1\n      enclosing = top_level\n      name = full_name.split(/:+/).last\n    else\n      full_name = child_name given_name\n\n      if full_name =~ /^(.+)::(\\w+)$/ then\n        name = $2\n        ename = $1\n        enclosing = @store.classes_hash[ename] || @store.modules_hash[ename]\n        # HACK: crashes in actionpack/lib/action_view/helpers/form_helper.rb (metaprogramming)\n        unless enclosing then\n          # try the given name at top level (will work for the above example)\n          enclosing = @store.classes_hash[given_name] ||\n                      @store.modules_hash[given_name]\n          return enclosing if enclosing\n          # not found: create the parent(s)\n          names = ename.split('::')\n          enclosing = self\n          names.each do |n|\n            enclosing = enclosing.classes_hash[n] ||\n                        enclosing.modules_hash[n] ||\n                        enclosing.add_module(RDoc::NormalModule, n)\n          end",
        "comment": " Adds a class named +given_name+ with +superclass+.  Both +given_name+ and +superclass+ may contain '::', and are interpreted relative to the +self+ context. This allows handling correctly examples like these: class RDoc::Gauntlet < Gauntlet module Mod class Object   # implies < ::Object class SubObject < Object  # this is _not_ ::Object  Given <tt>class Container::Item</tt> RDoc assumes +Container+ is a module unless it later sees <tt>class Container</tt>.  +add_class+ automatically upgrades +given_name+ to a class in this case.",
        "label": "How-to-use",
        "id": "16638"
    },
    {
        "raw_code": "def route_docs(library, paths)\n        return route_index if library.nil?\n        case paths.first\n        when \"frames\"\n          paths.shift\n          cmd = DisplayObjectCommand\n        when \"file\"\n          paths.shift\n          cmd = DisplayFileCommand\n        else\n          cmd = DisplayObjectCommand\n        end",
        "comment": "Routes requests from {#docs_prefix} and calls the appropriate command @param [LibraryVersion] library the library to route for @param [Array<String>] paths path components (split by '/') @return (see #route)",
        "label": "How-to-use",
        "id": "657"
    },
    {
        "raw_code": "def value\n            with_prometheus_client(verify: false, fallback: FALLBACK) do |client|\n              self.class.metric_value.call(client)\n            end",
        "comment": "Usage example  class GitalyApdexMetric < PrometheusMetric value do result = client.query('avg_over_time(gitlab_usage_ping:gitaly_apdex:ratio_avg_over_time_5m[1w])').first  break FALLBACK unless result  result['value'].last.to_f end end",
        "label": "How-to-use",
        "id": "1988"
    },
    {
        "raw_code": "def render_with(method, template, data={})\n          renderer = new(template, data)\n          yield renderer if block_given?\n          renderer.send(method.to_sym)\n        end",
        "comment": "Method used internally to DRY out the other renderers. This method creates and sets up the renderer before calling a specified method on it.",
        "label": "How-to-use",
        "id": "9155"
    },
    {
        "raw_code": "def stream_from(broadcasting, callback = nil, coder: nil, &block)\n        return if unsubscribed?\n\n        broadcasting = String(broadcasting)\n\n        # Don't send the confirmation until pubsub#subscribe is successful\n        defer_subscription_confirmation!\n\n        # Build a stream handler by wrapping the user-provided callback with a decoder\n        # or defaulting to a JSON-decoding retransmitter.\n        handler = worker_pool_stream_handler(broadcasting, callback || block, coder: coder)\n        streams[broadcasting] = handler\n\n        connection.server.event_loop.post do\n          pubsub.subscribe(broadcasting, handler, lambda do\n            ensure_confirmation_sent\n            logger.info \"#{self.class.name} is streaming from #{broadcasting}\"\n          end)\n        end",
        "comment": "Start streaming from the named `broadcasting` pubsub queue. Optionally, you can pass a `callback` that'll be used instead of the default of just transmitting the updates straight to the subscriber. Pass `coder: ActiveSupport::JSON` to decode messages as JSON before passing to the callback. Defaults to `coder: nil` which does no decoding, passes raw messages.",
        "label": "How-to-use",
        "id": "11046"
    },
    {
        "raw_code": "def array_end\n        @depth -= 1\n        array = @stack.pop\n        @array_counts.delete(array.object_id)\n\n        @result = array if @stack.empty?\n\n        array\n      end",
        "comment": "Called when an array ends",
        "label": "How-to-use",
        "id": "1964"
    },
    {
        "raw_code": "def <<(*records)\n        proxy_association.concat(records) && self\n      end",
        "comment": "Adds one or more +records+ to the collection by setting their foreign keys to the association's primary key. Since <tt><<</tt> flattens its argument list and inserts each record, +push+ and +concat+ behave identically. Returns +self+ so several appends may be chained together.  class Person < ActiveRecord::Base has_many :pets end  person.pets.size # => 0 person.pets << Pet.new(name: 'Fancy-Fancy') person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')] person.pets.size # => 3  person.id # => 1 person.pets # => [ #      #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #      #<Pet id: 2, name: \"Spook\", person_id: 1>, #      #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]",
        "label": "How-to-use",
        "id": "12802"
    },
    {
        "raw_code": "def cleanup_design_versions\n          work_item.design_versions.each_batch(of: BATCH_SIZE) do |design_versions|\n            design_versions.delete_all\n          end",
        "comment": "cleanup all design versions for the work item, we can safely use delete_all as there are no associated records or callbacks",
        "label": "How-to-use",
        "id": "6030"
    },
    {
        "raw_code": "def preload_commit_authors\n          @pipeline.commit.try(:lazy_author)\n        end",
        "comment": "This also preloads the author of every commit. We're using \"lazy_author\" here since \"author\" immediately loads the data on the first call.",
        "label": "How-to-use",
        "id": "2507"
    },
    {
        "raw_code": "def set_request_format_from_path_extension\n    path = request.headers['action_dispatch.original_path'] || request.headers['PATH_INFO']\n    match = path&.match(/\\.(\\w+)\\z/)\n    return unless match\n\n    format = Mime[match.captures.first]\n\n    return if format.blank?\n\n    request.format = CUSTOM_REQUEST_FORMAT_MAPPING[format.symbol] || format.symbol\n  end",
        "comment": "Based on ActionDispatch::Http::MimeNegotiation. We have an initializer that monkey-patches this method out (so that repository paths don't guess a format based on extension), but we do want this behavior when serving uploads.",
        "label": "How-to-use",
        "id": "6550"
    },
    {
        "raw_code": "def message\n      @_message\n    end",
        "comment": "Access the message instance.",
        "label": "How-to-use",
        "id": "11136"
    },
    {
        "raw_code": "def initialize(vm)\n          @vm = vm\n        end",
        "comment": "Initializes the system. Any subclasses MUST make sure this method is called on the parent. Therefore, if a subclass overrides `initialize`, then you must call `super`.",
        "label": "How-to-use",
        "id": "9013"
    },
    {
        "raw_code": "def initialize(column, value)\n          @column = column\n          @value = value\n        end",
        "comment": "This class builds the WHERE conditions for the keyset pagination library. It produces WHERE conditions for one column at a time.  Requisite 1: Only the last column (columns.last) is non-nullable and distinct. Requisite 2: Only one column is distinct and non-nullable.  Scenario: We want to order by columns named X, Y and Z and build the conditions used in the WHERE clause of a pagination query using a set of cursor values. X is the column definition for a nullable column Y is the column definition for a non-nullable but not distinct column Z is the column definition for a distinct, non-nullable column used as a tie breaker.  Then the method is initially invoked with these arguments: columns = [ColumnDefinition for X, ColumnDefinition for Y, ColumnDefinition for Z] values = { X: x, Y: y, Z: z } => these represent cursor values for pagination (x could be nil since X is nullable) current_conditions is initialized to [] to store the result during the iteration calls invoked within the Order#build_where_values method.  The elements of current_conditions are instances of Arel::Nodes and - will be concatenated using OR or UNION to be used in the WHERE clause.  Example: Let's say we want to build WHERE clause conditions for ORDER BY X DESC NULLS LAST, Y ASC, Z DESC  Iteration 1: columns = [X, Y, Z] At the end, current_conditions should be: [(Z < z)]  Iteration 2: columns = [X, Y] At the end, current_conditions should be: [(Y > y) OR (Y = y AND Z < z)]  Iteration 3: columns = [X] At the end, current_conditions should be: [((X IS NOT NULL AND Y > y) OR (X IS NOT NULL AND Y = y AND Z < z)) OR ((x IS NULL) OR (X IS NULL))]  Parameters:  - columns: instance of ColumnOrderDefinition - value: cursor value for the column",
        "label": "How-to-use",
        "id": "1998"
    },
    {
        "raw_code": "def initialize(name = :rdoc) # :yield: self\n    defaults\n\n    check_names name\n\n    @name = name\n\n    yield self if block_given?\n\n    define\n  end",
        "comment": " Create an RDoc task with the given name. See the RDoc::Task class overview for documentation.",
        "label": "How-to-use",
        "id": "15515"
    },
    {
        "raw_code": "def server(&blk)\n      self.class.server(&blk)\n    end",
        "comment": "Sends any server called in the instance of a new application up to the +server+ method defined in Rails::Railtie.",
        "label": "How-to-use",
        "id": "14641"
    },
    {
        "raw_code": "def check_captcha\n    return unless user_params[:password].present?\n    return unless captcha_enabled? || captcha_on_login_required?\n    return unless Gitlab::Recaptcha.load_configurations!\n\n    if verify_recaptcha\n      increment_successful_login_captcha_counter\n    else\n      increment_failed_login_captcha_counter\n\n      self.resource = resource_class.new\n      flash[:alert] = _('There was an error with the reCAPTCHA. Please solve the reCAPTCHA again.')\n      flash.delete :recaptcha_error\n\n      add_gon_variables\n\n      respond_with_navigational(resource) { render :new }\n    end",
        "comment": "From https://github.com/plataformatec/devise/wiki/How-To:-Use-Recaptcha-with-Devise#devisepasswordscontroller",
        "label": "How-to-use",
        "id": "6421"
    },
    {
        "raw_code": "def self.automatic_reindexing(maximum_records: DEFAULT_INDEXES_PER_INVOCATION)\n        # Cleanup leftover temporary indexes from previous, possibly aborted runs (if any)\n        cleanup_leftovers!\n\n        # Consume from the explicit reindexing queue first\n        done_counter = perform_from_queue(maximum_records: maximum_records)\n\n        return if done_counter >= maximum_records\n\n        # Execute reindexing based on bloat heuristic\n        perform_with_heuristic(maximum_records: maximum_records - done_counter)\n      end",
        "comment": "Performs automatic reindexing for a limited number of indexes per call 1. Consume from the explicit reindexing queue 2. Apply bloat heuristic to find most bloated indexes and reindex those",
        "label": "How-to-use",
        "id": "3013"
    },
    {
        "raw_code": "def serialize(value)\n        value\n      end",
        "comment": "Casts a value from the ruby type to a type that the database knows how to understand. The returned value from this method should be a +String+, +Numeric+, +Date+, +Time+, +Symbol+, +true+, +false+, or +nil+.",
        "label": "How-to-use",
        "id": "12296"
    },
    {
        "raw_code": "def latest_report_artifacts\n      ::Gitlab::SafeRequestStore.fetch(\"pipeline:#{self.id}:latest_report_artifacts\") do\n        ::Ci::JobArtifact.where(\n          id: job_artifacts.all_reports\n            .select(\"max(#{Ci::JobArtifact.quoted_table_name}.id) as id\")\n            .group(:file_type)\n        )\n          .preload(:job)\n          .group_by(&:file_type)\n      end",
        "comment": "This batch loads the latest reports for each CI job artifact type (e.g. sast, dast, etc.) in a single SQL query to eliminate the need to do N different `job_artifacts.where(file_type: X).last` calls.  Return a hash of file type => array of 1 job artifact",
        "label": "How-to-use",
        "id": "7560"
    },
    {
        "raw_code": "def key_generator(secret_key_base = self.secret_key_base)\n      # number of iterations selected based on consultation with the google security\n      # team. Details at https://github.com/rails/rails/pull/6952#issuecomment-7661220\n      @key_generators[secret_key_base] ||= ActiveSupport::CachingKeyGenerator.new(\n        ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000)\n      )\n    end",
        "comment": "Returns a key generator (ActiveSupport::CachingKeyGenerator) for a specified +secret_key_base+. The return value is memoized, so additional calls with the same +secret_key_base+ will return the same key generator instance.",
        "label": "How-to-use",
        "id": "14630"
    },
    {
        "raw_code": "def gitattribute(path, name)\n      attributes(path)[name]\n    end",
        "comment": "Override of a method called on Repository instances but sent via method_missing to Gitlab::Git::Repository where it is defined",
        "label": "How-to-use",
        "id": "7684"
    },
    {
        "raw_code": "def match(chrs, op = \"\")\n        D_DETAIL.print \"match>: \", chrs, \"op:\", op, \"\\n\"\n        if chrs.empty?\n          if @preproc.nil? || @preproc.call(op, chrs)\n            DOUT.printf(D_DETAIL, \"op1: %s\\n\", op)\n            @postproc.call(op, chrs)\n          else\n            nil\n          end",
        "comment": " chrs: String character array io must have getc()/ungetc(); and ungetc() must be able to be called arbitrary number of times. ",
        "label": "How-to-use",
        "id": "352"
    },
    {
        "raw_code": "def polymorphic_url(record_or_hash_or_array, options = {})\n        if Hash === record_or_hash_or_array\n          options = record_or_hash_or_array.merge(options)\n          record  = options.delete :id\n          return polymorphic_url record, options\n        end",
        "comment": "Constructs a call to a named RESTful route for the given record and returns the resulting URL string. For example:  # calls post_url(post) polymorphic_url(post) # => \"http://example.com/posts/1\" polymorphic_url([blog, post]) # => \"http://example.com/blogs/1/posts/1\" polymorphic_url([:admin, blog, post]) # => \"http://example.com/admin/blogs/1/posts/1\" polymorphic_url([user, :blog, post]) # => \"http://example.com/users/1/blog/posts/1\" polymorphic_url(Comment) # => \"http://example.com/comments\"  #### Options  *   `:action` - Specifies the action prefix for the named route: `:new` or `:edit`. Default is no prefix. *   `:routing_type` - Allowed values are `:path` or `:url`. Default is `:url`.   Also includes all the options from `url_for`. These include such things as `:anchor` or `:trailing_slash`. Example usage is given below:  polymorphic_url([blog, post], anchor: 'my_anchor') # => \"http://example.com/blogs/1/posts/1#my_anchor\" polymorphic_url([blog, post], anchor: 'my_anchor', script_name: \"/my_app\") # => \"http://example.com/my_app/blogs/1/posts/1#my_anchor\"  For all of these options, see the documentation for [url_for](rdoc-ref:ActionDispatch::Routing::UrlFor).  #### Functionality  # an Article record polymorphic_url(record)  # same as article_url(record)  # a Comment record polymorphic_url(record)  # same as comment_url(record)  # it recognizes new records and maps to the collection record = Comment.new polymorphic_url(record)  # same as comments_url()  # the class of a record will also map to the collection polymorphic_url(Comment) # same as comments_url() ",
        "label": "How-to-use",
        "id": "11588"
    },
    {
        "raw_code": "def select_tokens(*args, submit: false, search_token: false, input_text: 'Search')\n    within '[data-testid=\"filtered-search-input\"]' do\n      find_field(input_text).click\n\n      args.each do |token|\n        # Move mouse away to prevent invoking tooltips on usernames, which blocks the search input\n        find_button('Search').hover\n\n        if search_token\n          find_by_testid('filtered-search-token-segment-input').send_keys token.to_s\n        end",
        "comment": " For use with gl-filtered-search",
        "label": "How-to-use",
        "id": "8456"
    },
    {
        "raw_code": "def create_trigger(command, block, extra_cfg=nil)\n        trigger = VagrantConfigTrigger.new(command)\n        if block.is_a?(Hash)\n          trigger.set_options(block)\n        else\n          block.call(trigger, VagrantConfigTrigger)\n          trigger.set_options(extra_cfg) if extra_cfg\n        end",
        "comment": "------------------------------------------------------------------- Internal methods, don't call these. ------------------------------------------------------------------- Creates a new trigger config. If a block is given, parse that block by calling it with the created trigger. Otherwise set the options if it's a hash.  @param [Symbol] command Vagrant command to create trigger on @param [Block] block The defined config block @param [Hash] extra_cfg Extra configurations for a block defined trigger (Optional) @return [VagrantConfigTrigger]",
        "label": "How-to-use",
        "id": "9435"
    },
    {
        "raw_code": "def create!(attributes = nil, &block)\n      if attributes.is_a?(Array)\n        attributes.collect { |attr| create!(attr, &block) }\n      else\n        block = current_scope_restoring_block(&block)\n        scoping { _create!(attributes, &block) }\n      end",
        "comment": "Similar to #create, but calls {create!}[rdoc-ref:Persistence::ClassMethods#create!] on the base class. Raises an exception if a validation error occurs.  Expects arguments in the same format as {ActiveRecord::Base.create!}[rdoc-ref:Persistence::ClassMethods#create!].",
        "label": "How-to-use",
        "id": "12625"
    },
    {
        "raw_code": "def by_email(email, *additional_keys, expires_in: DEFAULT_EXPIRY)\n        key = email_key(email)\n        subkey = additional_keys.join(\":\")\n\n        Gitlab::SafeRequestStore.fetch([key, subkey]) do\n          with do |redis|\n            # Look for existing cache value\n            cached = redis.hget(key, subkey)\n\n            # Return the cached entry if set\n            break cached unless cached.nil?\n\n            # Otherwise, call the block to get the value\n            to_cache = yield(email, *additional_keys).to_s\n\n            # Set it in the cache\n            redis.hset(key, subkey, to_cache)\n\n            # Update the expiry time\n            redis.expire(key, expires_in)\n\n            # Return this new value\n            break to_cache\n          end",
        "comment": "Look up cached avatar data by email address. This accepts a block to provide the value to be cached in the event nothing is found.  Multiple calls in the same request will be served from the request store.  @param email [String] @param additional_keys [*Object] all must respond to `#to_s` @param expires_in [ActiveSupport::Duration, Integer] @yield [email, *additional_keys] yields the supplied params back to the block @return [String]",
        "label": "How-to-use",
        "id": "1584"
    },
    {
        "raw_code": "def allow_browser(versions:, block: -> { render file: Rails.root.join(\"public/406-unsupported-browser.html\"), layout: false, status: :not_acceptable }, **options)\n        before_action -> { allow_browser(versions: versions, block: block) }, **options\n      end",
        "comment": "Specify the browser versions that will be allowed to access all actions (or some, as limited by `only:` or `except:`). Only browsers matched in the hash or named set passed to `versions:` will be blocked if they're below the versions specified. This means that all other browsers, as well as agents that aren't reporting a user-agent header, will be allowed access.  A browser that's blocked will by default be served the file in public/406-unsupported-browser.html with an HTTP status code of \"406 Not Acceptable\".  In addition to specifically named browser versions, you can also pass `:modern` as the set to restrict support to browsers natively supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has. This includes Safari 17.2+, Chrome 120+, Firefox 121+, Opera 106+.  You can use https://caniuse.com to check for browser versions supporting the features you use.  You can use `ActiveSupport::Notifications` to subscribe to events of browsers being blocked using the `browser_block.action_controller` event name.  Examples:  class ApplicationController < ActionController::Base # Allow only browsers natively supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has allow_browser versions: :modern end  class ApplicationController < ActionController::Base # Allow only browsers natively supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has allow_browser versions: :modern, block: :handle_outdated_browser  private def handle_outdated_browser render file: Rails.root.join(\"public/custom-error.html\"), status: :not_acceptable end end  class ApplicationController < ActionController::Base # All versions of Chrome and Opera will be allowed, but no versions of \"internet explorer\" (ie). Safari needs to be 16.4+ and Firefox 121+. allow_browser versions: { safari: 16.4, firefox: 121, ie: false } end  class MessagesController < ApplicationController # In addition to the browsers blocked by ApplicationController, also block Opera below 104 and Chrome below 119 for the show action. allow_browser versions: { opera: 104, chrome: 119 }, only: :show end",
        "label": "How-to-use",
        "id": "11248"
    },
    {
        "raw_code": "def prompt_for_copying_event_properties\n        shared_values = collect_values_for_shared_event_properties\n        defaults = shared_values.except(:stage, :section)\n\n        return {} if shared_values.none?\n\n        return shared_values if defaults.none?\n\n        new_page!(on_step: 'Defaults', steps: STEPS)\n\n        cli.say <<~TEXT\n          #{format_info('Convenient! We can copy these attributes from the event definition(s):')}\n\n          #{defaults.compact.transform_keys(&:to_s).to_yaml(line_width: 150)}\n          #{format_info('If any of these attributes are incorrect, you can also change them manually from your text editor later.')}\n\n        TEXT\n\n        cli.select('What would you like to do?', **select_opts) do |menu|\n          menu.enum '.'\n          menu.choice 'Copy & continue', -> { bulk_assign(defaults) }\n          menu.choice 'Modify attributes'\n        end",
        "comment": "Check existing event files for attributes to copy over",
        "label": "How-to-use",
        "id": "5318"
    },
    {
        "raw_code": "def set_appearance\n    @appearance = Appearance.current || Appearance.new\n  end",
        "comment": "Use callbacks to share common setup or constraints between actions.",
        "label": "How-to-use",
        "id": "6475"
    },
    {
        "raw_code": "def self.execute(*command, &block)\n        new(*command).execute(&block)\n      end",
        "comment": "Convenience method for executing a method.",
        "label": "How-to-use",
        "id": "9287"
    },
    {
        "raw_code": "def method_missing(method, *arguments, &block)\n            if xhtml_block?(method, arguments)\n              @xml.__send__(method, *arguments) do\n                @xml.div(xmlns: \"http://www.w3.org/1999/xhtml\") do |xhtml|\n                  block.call(xhtml)\n                end",
        "comment": "Delegate to XML Builder, first wrapping the element in an XHTML namespaced div element if the method and arguments indicate that an xhtml_block? is desired.",
        "label": "How-to-use",
        "id": "11807"
    },
    {
        "raw_code": "def format_heading(string)\n        [divider, pastel.cyan(string), divider].join(\"\\n\")\n      end",
        "comment": "When to format as \"heading\": - At the beginning or end of complete flows, to create visual separation and indicate logical breakpoints.",
        "label": "How-to-use",
        "id": "5349"
    },
    {
        "raw_code": "def upload(from, to)\n        end",
        "comment": "Upload a file to the remote machine.  @param [String] from Path of the file locally to upload. @param [String] to Path of where to save the file on the remote machine.",
        "label": "How-to-use",
        "id": "9135"
    },
    {
        "raw_code": "def batch(repository, blob_references, blob_size_limit: MAX_DATA_DISPLAY_SIZE)\n          blob_references.each_slice(BATCH_SIZE).flat_map do |refs|\n            repository.gitaly_blob_client.get_blobs(refs, blob_size_limit).to_a\n          end",
        "comment": "Returns an array of Blob instances, specified in blob_references as [[commit_sha, path], [commit_sha, path], ...]. If blob_size_limit < 0 then the full blob contents are returned. If blob_size_limit >= 0 then each blob will contain no more than limit bytes in its data attribute.  Keep in mind that this method may allocate a lot of memory. It is up to the caller to limit the number of blobs and blob_size_limit. ",
        "label": "How-to-use",
        "id": "2603"
    },
    {
        "raw_code": "def change_branch(noteable, project, author, branch_type, event_type, old_branch, new_branch)\n    ::SystemNotes::MergeRequestsService.new(noteable: noteable, container: project, author: author)\n      .change_branch(branch_type, event_type, old_branch, new_branch)\n  end",
        "comment": "Called when a branch in Noteable is changed  noteable    - Noteable object container   - Project or Namespace(Group or ProjectNamespace) owning noteable author      - User performing the change branch_type - 'source' or 'target' event_type  - the source of event: 'update' or 'delete' old_branch  - old branch name new_branch  - new branch name  Example Note text is based on event_type:  update: \"changed target branch from `Old` to `New`\" delete: \"deleted the `Old` branch. This merge request now targets the `New` branch\"  Returns the created Note object",
        "label": "How-to-use",
        "id": "5510"
    },
    {
        "raw_code": "def identified_by(*identifiers)\n          Array(identifiers).each { |identifier| attr_accessor identifier }\n          self.identifiers += identifiers\n        end",
        "comment": "Mark a key as being a connection identifier index that can then be used to find the specific connection again later. Common identifiers are current_user and current_account, but could be anything, really.  Note that anything marked as an identifier will automatically create a delegate by the same name on any channel instances created off the connection.",
        "label": "How-to-use",
        "id": "11076"
    },
    {
        "raw_code": "def has_changes_to_save?\n        mutations_from_database.any_changes?\n      end",
        "comment": "Will the next call to +save+ have any changes to persist?",
        "label": "How-to-use",
        "id": "12847"
    },
    {
        "raw_code": "def representation_type\n        raise NotImplementedError\n      end",
        "comment": "The name of the method to call to retrieve the representation object",
        "label": "How-to-use",
        "id": "2052"
    },
    {
        "raw_code": "def find_visibility_end(node)\n        possible_visibilities = VISIBILITY_SCOPES - ::Set[node_visibility(node)]\n        right = node.right_siblings\n        right.find do |child_node|\n          possible_visibilities.include?(node_visibility(child_node))\n        end || right.last\n      end",
        "comment": "Navigate to find the last protected method",
        "label": "How-to-use",
        "id": "10418"
    },
    {
        "raw_code": "def run(*args)\n        log.show_progress = true\n        if args.empty? || !args.first.nil?\n          # fail early if arguments are not valid\n          return unless parse_arguments(*args)\n        end",
        "comment": "Runs the commandline utility, parsing arguments and generating output if set.  @param [Array<String>] args the list of arguments. If the list only contains a single nil value, skip calling of {#parse_arguments} @return [void]",
        "label": "How-to-use",
        "id": "527"
    },
    {
        "raw_code": "def project_autocomplete\n    if @project && @project.repository.root_ref\n      ref = @ref || @project.repository.root_ref\n\n      result = []\n\n      if can?(current_user, :read_code, @project)\n        result.concat([\n          { category: \"In this project\", label: _(\"Files\"),          url: project_tree_path(@project, ref) },\n          { category: \"In this project\", label: _(\"Commits\"),        url: project_commits_path(@project, ref) }\n        ])\n      end",
        "comment": "Autocomplete results for the current project, if it's defined",
        "label": "How-to-use",
        "id": "7741"
    },
    {
        "raw_code": "def follow_redirect!(headers: {}, **args)\n        raise \"not a redirect! #{status} #{status_message}\" unless redirect?\n\n        method =\n          if [307, 308].include?(response.status)\n            request.method.downcase\n          else\n            :get\n          end",
        "comment": "Follow a single redirect response. If the last response was not a redirect, an exception will be raised. Otherwise, the redirect is performed on the location header. If the redirection is a 307 or 308 redirect, the same HTTP verb will be used when redirecting, otherwise a GET request will be performed. Any arguments are passed to the underlying request.  The HTTP_REFERER header will be set to the previous url.",
        "label": "How-to-use",
        "id": "11620"
    },
    {
        "raw_code": "def self.action_hook(name, &block)\n          # Get the list of hooks for the given hook name\n          data[:action_hooks] ||= {}\n          hooks = data[:action_hooks][name.to_sym] ||= []\n\n          # Return the list if we don't have a block\n          return hooks if !block_given?\n\n          # Otherwise add the block to the list of hooks for this action.\n          hooks << block\n        end",
        "comment": "Registers a callback to be called when a specific action sequence is run. This allows plugin authors to hook into things like VM bootup, VM provisioning, etc.  @param [Symbol] name Name of the action. @return [Array] List of the hooks for the given action.",
        "label": "How-to-use",
        "id": "9003"
    },
    {
        "raw_code": "def init(&prepare_block)\n          new.tap(&prepare_block)\n        end",
        "comment": "Initialize new instance of class without fabrication  @yieldparam [self] instance of page object @return [self]",
        "label": "How-to-use",
        "id": "4127"
    },
    {
        "raw_code": "def uncacheable!\n        raise UncacheableFragmentError, \"can't be fragment cached\" if caching?\n      end",
        "comment": "Raises UncacheableFragmentError when called from within a +cache+ block.  Useful to denote helper methods that can't participate in fragment caching:  def project_name_with_time(project) uncacheable! \"#{project.name} - #{Time.now}\" end  # Which will then raise if used within a `cache` block: <% cache project do %> <%= project_name_with_time(project) %> <% end %>",
        "label": "How-to-use",
        "id": "11813"
    },
    {
        "raw_code": "def register_parser(format, callable = nil, &block)\n          parser = callable || block || :itself.to_proc\n          content_class.redefine_method(format) do\n            parser.call(to_s)\n          end",
        "comment": "Register a callable to parse rendered content for a given template format.  Each registered parser will also define a +#rendered.[FORMAT]+ helper method, where +[FORMAT]+ corresponds to the value of the +format+ argument.  By default, ActionView::TestCase defines parsers for:  * +:html+ - returns an instance of +Nokogiri::XML::Node+ * +:json+ - returns an instance of ActiveSupport::HashWithIndifferentAccess  These pre-registered parsers also define corresponding helpers:  * +:html+ - defines +rendered.html+ * +:json+ - defines +rendered.json+  ==== Parameters  [+format+] The name (as a +Symbol+) of the format used to render the content.  [+callable+] The parser. A callable object that accepts the rendered string as its sole argument. Alternatively, the parser can be specified as a block.  ==== Examples  test \"renders HTML\" do article = Article.create!(title: \"Hello, world\")  render partial: \"articles/article\", locals: { article: article }  assert_pattern { rendered.html.at(\"main h1\") => { content: \"Hello, world\" } } end  test \"renders JSON\" do article = Article.create!(title: \"Hello, world\")  render formats: :json, partial: \"articles/article\", locals: { article: article }  assert_pattern { rendered.json => { title: \"Hello, world\" } } end  To parse the rendered content into RSS, register a call to +RSS::Parser.parse+:  register_parser :rss, -> rendered { RSS::Parser.parse(rendered) }  test \"renders RSS\" do article = Article.create!(title: \"Hello, world\")  render formats: :rss, partial: article  assert_equal \"Hello, world\", rendered.rss.items.last.title end  To parse the rendered content into a +Capybara::Simple::Node+, re-register an +:html+ parser with a call to +Capybara.string+:  register_parser :html, -> rendered { Capybara.string(rendered) }  test \"renders HTML\" do article = Article.create!(title: \"Hello, world\")  render partial: article  rendered.html.assert_css \"h1\", text: \"Hello, world\" end ",
        "label": "How-to-use",
        "id": "11766"
    },
    {
        "raw_code": "def message_verifiers\n      @message_verifiers ||=\n        ActiveSupport::MessageVerifiers.new do |salt, secret_key_base: self.secret_key_base|\n          key_generator(secret_key_base).generate_key(salt)\n        end.rotate_defaults\n    end",
        "comment": "Returns a message verifier factory (ActiveSupport::MessageVerifiers). This factory can be used as a central point to configure and create message verifiers (ActiveSupport::MessageVerifier) for your application.  By default, message verifiers created by this factory will generate messages using the default ActiveSupport::MessageVerifier options. You can override these options with a combination of ActiveSupport::MessageVerifiers#clear_rotations and ActiveSupport::MessageVerifiers#rotate. However, this must be done prior to building any message verifier instances. For example, in a +before_initialize+ block:  # Use `url_safe: true` when generating messages config.before_initialize do |app| app.message_verifiers.clear_rotations app.message_verifiers.rotate(url_safe: true) end  Message verifiers created by this factory will always use a secret derived from #secret_key_base when generating messages. +clear_rotations+ will not affect this behavior. However, older +secret_key_base+ values can be rotated for verifying messages:  # Fall back to old `secret_key_base` when verifying messages config.before_initialize do |app| app.message_verifiers.rotate(secret_key_base: \"old secret_key_base\") end ",
        "label": "How-to-use",
        "id": "14631"
    },
    {
        "raw_code": "def override_omniauth(provider, controller, path_prefix = '/users/auth')\n  match \"#{path_prefix}/#{provider}/callback\",\n    to: \"#{controller}##{provider}\",\n    as: \"#{provider}_omniauth_callback\",\n    via: [:get, :post]\nend",
        "comment": "Allows individual providers to be directed to a chosen controller Call from inside devise_scope",
        "label": "How-to-use",
        "id": "1269"
    },
    {
        "raw_code": "def get_pillar\n        if !@config.pillar_data.empty?\n          if @machine.config.vm.communicator == :winrm\n            # ' doesn't have any special behavior on the command prompt,\n            # so '{\"x\":\"y\"}' becomes '{x:y}' with literal single quotes.\n            # However, \"\"\" will become \" , and \\\\\"\"\" will become \\\" .\n            # Use \\\\\"\" instead of \\\\\"\"\" for literal inner-value quotes\n            # to avoid issue with odd number of quotes.\n            # --% disables special PowerShell parsing on the rest of the line.\n            \" --% pillar=#{@config.pillar_data.to_json.gsub(/(?<!\\\\)\\\"/, '\"\"\"').gsub(/\\\\\\\"/, %q(\\\\\\\\\\\"\"))}\"\n          else\n            \" pillar='#{@config.pillar_data.to_json}'\"\n          end",
        "comment": "Actions Get pillar string to pass with the salt command",
        "label": "How-to-use",
        "id": "9874"
    },
    {
        "raw_code": "def download!\n        # This variable can contain the proc that'll be sent to\n        # the subprocess execute.\n        data_proc = nil\n\n        extra_subprocess_opts = {}\n        if @ui\n          # If we're outputting progress, then setup the subprocess to\n          # tell us output so we can parse it out.\n          extra_subprocess_opts[:notify] = :stderr\n\n          data_proc = Vagrant::Util::CurlHelper.capture_output_proc(@logger, @ui, @source)\n        end",
        "comment": "This executes the actual download, downloading the source file to the destination with the given options used to initialize this class.  If this method returns without an exception, the download succeeded. An exception will be raised if the download failed.",
        "label": "How-to-use",
        "id": "9165"
    },
    {
        "raw_code": "def initialize(env)\n        @logger = Log4r::Logger.new(\"vagrant::cloud::client\")\n        @env    = env\n        if !defined?(@@client)\n          @@client = VagrantCloud::Client.new(\n            access_token: token,\n            url_base: api_server_url\n          )\n        end",
        "comment": "Initializes a login client with the given Vagrant::Environment.  @param [Vagrant::Environment] env",
        "label": "How-to-use",
        "id": "9774"
    },
    {
        "raw_code": "def before_check(policy, ability, user, subject, opts)\n      # See Support::AbilityCheck and Support::PermissionsCheck.\n    end",
        "comment": "Hook call right before ability check.",
        "label": "How-to-use",
        "id": "6837"
    },
    {
        "raw_code": "def define_attribute_methods(*attr_names)\n        ActiveSupport::CodeGenerator.batch(generated_attribute_methods, __FILE__, __LINE__) do |owner|\n          attr_names.flatten.each do |attr_name|\n            define_attribute_method(attr_name, _owner: owner)\n            aliases_by_attribute_name[attr_name.to_s].each do |aliased_name|\n              generate_alias_attribute_methods owner, aliased_name, attr_name\n            end",
        "comment": "Declares the attributes that should be prefixed and suffixed by +ActiveModel::AttributeMethods+.  To use, pass attribute names (as strings or symbols). Be sure to declare +define_attribute_methods+ after you define any prefix, suffix, or affix methods, or they will not hook in.  class Person include ActiveModel::AttributeMethods  attr_accessor :name, :age, :address attribute_method_prefix 'clear_'  # Call to define_attribute_methods must appear after the # attribute_method_prefix, attribute_method_suffix or # attribute_method_affix declarations. define_attribute_methods :name, :age, :address  private def clear_attribute(attr) send(\"#{attr}=\", nil) end end",
        "label": "How-to-use",
        "id": "12181"
    },
    {
        "raw_code": "def present_carrierwave_file!(file, supports_direct_download: true, content_disposition: nil, content_type: nil, extra_response_headers: {}, extra_send_url_params: {})\n      return not_found! unless file&.exists?\n\n      if content_disposition\n        response_disposition = ActionDispatch::Http::ContentDisposition.format(disposition: content_disposition, filename: file.filename)\n      end",
        "comment": "Return back the given file depending on the object storage configuration. For disabled mode, the disk file is returned. For enabled mode, the response depends on the direct download support: * direct download supported by the uploader class: a redirect to the file signed url is returned. * direct download not supported: a workhorse send_url response is returned.  Params: @file the carrierwave file. @supports_direct_download set to false to force a workhorse send_url response. true by default. @content_disposition controls the Content-Disposition response header. nil by default. Forced to attachment for object storage disabled mode. @content_type controls the Content-Type response header. By default, it will rely on the 'application/octet-stream' value or the content type detected by carrierwave. @extra_response_headers. Set additional response headers. Not used in the direct download supported case. @extra_send_url_params. Additional parameters to send to workhorse send_url call. See Gitlab::Workhorse.send_url for more information",
        "label": "How-to-use",
        "id": "3792"
    },
    {
        "raw_code": "def log_resolving_alert(monitoring_tool)\n      body = \"logged a recovery alert from **#{monitoring_tool}**\"\n\n      create_note(NoteSummary.new(noteable, project, Users::Internal.alert_bot, body, action: 'new_alert_added'))\n    end",
        "comment": "Called when an alert is resolved due to received resolving alert payload  alert - AlertManagement::Alert object.  Example Note text:  \"changed the status to Resolved by closing issue #17\"  Returns the created Note object",
        "label": "How-to-use",
        "id": "5632"
    },
    {
        "raw_code": "def filter!(type, base = settings, &block)\n      filter!(type, base.superclass, &block) if base.superclass.respond_to?(:filters)\n      base.filters[type].each do |args|\n        result = process_route(*args)\n        block.call(result) if block_given?\n      end",
        "comment": "Run filters defined on the class and all superclasses. Accepts an optional block to call after each filter is applied.",
        "label": "How-to-use",
        "id": "8583"
    },
    {
        "raw_code": "def guest_paths(folders)\n          folders.map { |parts| parts[2] }\n        end",
        "comment": "Extracts only the remote paths from a list of folders",
        "label": "How-to-use",
        "id": "9897"
    },
    {
        "raw_code": "def write_metadata_json\n          meta_path = File.join(@env[\"package.directory\"], \"metadata.json\")\n          return if File.exist?(meta_path)\n\n          if @env[:machine] && @env[:machine].provider_name\n            provider_name = @env[:machine].provider_name\n          elsif @env[:env] && @env[:env].default_provider\n            provider_name = @env[:env].default_provider\n          else\n            return\n          end",
        "comment": "Write the metadata file into the box so that the provider can be automatically detected when adding the box",
        "label": "How-to-use",
        "id": "9324"
    },
    {
        "raw_code": "def release!\n          FileUtils.rm_rf(workdir)\n        end",
        "comment": "At the end of a successful backup, call this to release temporary resources",
        "label": "How-to-use",
        "id": "1026"
    },
    {
        "raw_code": "def redefine_method(method, &block)\n    visibility = method_visibility(method)\n    silence_redefinition_of_method(method)\n    define_method(method, &block)\n    send(visibility, method)\n  end",
        "comment": "Replaces the existing method definition, if there is one, with the passed block as its body.",
        "label": "How-to-use",
        "id": "14279"
    },
    {
        "raw_code": "def accept_list_start(list)\n    @list << list.type\n    @res << html_list_name(list.type, true)\n    @in_list_entry.push ''\n  end",
        "comment": " Prepares the visitor for consuming +list+",
        "label": "How-to-use",
        "id": "16405"
    },
    {
        "raw_code": "def null_filter(text, context = {})\n    reference_pipeline(filter: nil, **context).to_document(text)\n  end",
        "comment": "Use to test no-ops",
        "label": "How-to-use",
        "id": "8448"
    },
    {
        "raw_code": "def self.build(middleware, *args, **keywords, &block)\n        new.use(middleware, *args, **keywords, &block)\n      end",
        "comment": "This is a shortcut for a middleware sequence with only one item in it. For a description of the arguments and the documentation, please see {#use} instead.  @return [Builder]",
        "label": "How-to-use",
        "id": "9300"
    },
    {
        "raw_code": "def emphasis text\n    if text =~ /\\A[a-z\\d.\\/]+\\z/i then\n      \"_#{text}_\"\n    else\n      \"<em>#{text}</em>\"\n    end",
        "comment": " Wraps `text` in emphasis for rdoc inline formatting",
        "label": "How-to-use",
        "id": "15575"
    },
    {
        "raw_code": "def replace(content, parse = true)\n      content = content.join(\"\\n\") if content.is_a?(Array)\n      @tags = []\n      @ref_tags = []\n      if parse\n        super(parse_comments(content))\n      else\n        @all = content\n        @unresolved_reference = nil\n        super(content)\n      end",
        "comment": "Replaces the docstring with new raw content. Called by {#all=}. @param [String] content the raw comments to be parsed",
        "label": "How-to-use",
        "id": "125"
    },
    {
        "raw_code": "def serialize_string(value)\n            value.to_s\n          end",
        "comment": "Serialize the String value  @return [String]",
        "label": "How-to-use",
        "id": "1078"
    },
    {
        "raw_code": "def job_artifacts\n      Ci::JobArtifact.none\n    end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "7588"
    },
    {
        "raw_code": "def gfm_reference(from = nil)\n    # \"MergeRequest\" > \"merge_request\" > \"Merge request\" > \"merge request\"\n    friendly_name = self.class.to_s.underscore.humanize.downcase\n\n    \"#{friendly_name} #{to_reference(from)}\"\n  end",
        "comment": "Returns the text used as the body of a Note when this object is referenced  By default this will be the class name and the result of calling `to_reference` on the object.",
        "label": "How-to-use",
        "id": "7231"
    },
    {
        "raw_code": "def accept_list_start(list)\n    @list << list.type\n    @res << html_list_name(list.type, true)\n    @in_list_entry.push false\n  end",
        "comment": " Prepares the visitor for consuming +list+",
        "label": "How-to-use",
        "id": "16337"
    },
    {
        "raw_code": "def month_field(object_name, method, options = {})\n        Tags::MonthField.new(object_name, method, self, options).render\n      end",
        "comment": "Returns a text_field of type \"month\".  month_field(\"user\", \"born_on\") # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"month\" />  The default value is generated by trying to call +strftime+ with \"%Y-%m\" on the object's value, which makes it behave as expected for instances of DateTime and ActiveSupport::TimeWithZone.  @user.born_on = Date.new(1984, 1, 27) month_field(\"user\", \"born_on\") # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"date\" value=\"1984-01\" /> ",
        "label": "How-to-use",
        "id": "11880"
    },
    {
        "raw_code": "def change(column_name, type, **options)\n        raise_on_if_exist_options(options)\n        @base.change_column(name, column_name, type, **options)\n      end",
        "comment": "Changes the column's definition according to the new options.  t.change(:name, :string, limit: 80) t.change(:description, :text)  See TableDefinition#column for details of the options you can use.",
        "label": "How-to-use",
        "id": "13110"
    },
    {
        "raw_code": "def description\n    markup @comment_location\n  end",
        "comment": " Handy wrapper for marking up this class or module's comment",
        "label": "How-to-use",
        "id": "16485"
    },
    {
        "raw_code": "def set_options(options)\n          options.each do |key, value|\n            send(\"#{key}=\", value)\n          end",
        "comment": "Allows setting options from a hash. By default this simply calls the `#{key}=` method on the config class with the value, which is the expected behavior most of the time.  This is expected to mutate itself.  @param [Hash] options A hash of options to set on this configuration key.",
        "label": "How-to-use",
        "id": "9022"
    },
    {
        "raw_code": "def each_object_to_import\n        repo = project.import_source\n\n        # URL to resume the pagination from in case the job is interrupted.\n        resume_url = page_keyset.current\n\n        client.each_page(collection_method, resume_url, repo, collection_options) do |page|\n          page.objects.each do |object|\n            object = object.to_h\n\n            next if already_imported?(object)\n\n            if increment_object_counter?(object)\n              Gitlab::GithubImport::ObjectCounter.increment(project, object_type, :fetched)\n            end",
        "comment": "The method that will be called for traversing through all the objects to import, yielding them to the supplied block.",
        "label": "How-to-use",
        "id": "2129"
    },
    {
        "raw_code": "def repository_template_names(project)\n          template_names_by_category(self.all(project))\n        end",
        "comment": "`repository_template_names` - reads through Gitaly the actual templates names within a given project's repository. This is only used by issue and merge request templates, that need to call this once and then cache the returned value.  `template_names` - is an alias to `repository_template_names`. It would read through Gitaly the actual template names within a given project's repository for all file templates other than `issue` and `merge request` description templates, which would instead overwrite the `template_names` method to return a redis cached version, by reading cached values from `repository.issue_template_names_hash` and `repository.merge_request_template_names_hash` methods.",
        "label": "How-to-use",
        "id": "2425"
    },
    {
        "raw_code": "def initialize(gdk_folder: nil)\n        @gdk_folder = gdk_folder\n      end",
        "comment": "@param gdk_folder [string] path to the folder for the running GDK instance, used to determine if running locally",
        "label": "How-to-use",
        "id": "4481"
    },
    {
        "raw_code": "def accept_list_item_start(list_item)\n    type = @list_type.last\n\n    case type\n    when :NOTE, :LABEL then\n      bullets = Array(list_item.label).map do |label|\n        attributes(label).strip\n      end.join \"\\n\"\n\n      bullets << \":\\n\" unless bullets.empty?\n\n      @prefix = ' ' * @indent\n      @indent += 2\n      @prefix << bullets + (' ' * @indent)\n    else\n      bullet = type == :BULLET ? '*' :  @list_index.last.to_s + '.'\n      @prefix = (' ' * @indent) + bullet.ljust(bullet.length + 1)\n      width = bullet.length + 1\n      @indent += width\n    end",
        "comment": " Prepares the visitor for consuming +list_item+",
        "label": "How-to-use",
        "id": "16217"
    },
    {
        "raw_code": "def inherited(klass)\n            GitlabSchema.lazy_resolve(klass, :load)\n          end",
        "comment": "Automatically register the inheriting classes to GitlabSchema as lazy objects.",
        "label": "How-to-use",
        "id": "2100"
    },
    {
        "raw_code": "def not_nullable_conditions(current_conditions)\n          tie_break_conds = current_conditions.map do |conditional|\n            Arel::Nodes::And.new([column_equals_to_value, conditional])\n          end",
        "comment": "WHEN THE COLUMN IS NON-NULLABLE AND DISTINCT Per Assumption 1, only the last column can be non-nullable and distinct (column Z is non-nullable/distinct and comes last in the example). So the Order#build_where_conditions is being called for the first time with current_conditions = [].  At the end of the call, we should expect: current_conditions should be [(Z < z)]  WHEN THE COLUMN IS NON-NULLABLE BUT NOT DISTINCT Let's say Z has been processed and we are about to process the column Y next. (per requisite 1, if a non-nullable but not distinct column is being processed, at the least, the conditional for the non-nullable/distinct column exists)  At the start of the method call: current_conditions = [(Z < z)] comparison_node = (Y < y) eqaulity_node = (Y = y)  We should add a comparison node for the next column Y, (Y < y) then break a tie using the previous conditionals, (Y = y AND Z < z)  At the end of the call, we should expect: current_conditions = [(Y < y), (Y = y AND Z < z)]",
        "label": "How-to-use",
        "id": "1999"
    },
    {
        "raw_code": "def status_of_jobs(names)\n          jobs = all_jobs_by_name.slice(*names)\n\n          status_for_array(jobs.values, dag: true)\n        end",
        "comment": "This methods gets composite status for jobs with given names",
        "label": "How-to-use",
        "id": "5825"
    },
    {
        "raw_code": "def machine_id_changed\n        end",
        "comment": "This method is called if the underlying machine ID changes. Providers can use this method to load in new data for the actual backing machine or to realize that the machine is now gone (the ID can become `nil`). No parameters are given, since the underlying machine is simply the machine instance given to this object. And no return value is necessary.",
        "label": "How-to-use",
        "id": "8974"
    },
    {
        "raw_code": "def url_for(options = nil)\n        full_url_for(options)\n      end",
        "comment": "Generate a URL based on the options provided, `default_url_options`, and the routes defined in `config/routes.rb`. The following options are supported:  *   `:only_path` - If true, the relative URL is returned. Defaults to `false`. *   `:protocol` - The protocol to connect to. Defaults to `\"http\"`. *   `:host` - Specifies the host the link should be targeted at. If `:only_path` is false, this option must be provided either explicitly, or via `default_url_options`. *   `:subdomain` - Specifies the subdomain of the link, using the `tld_length` to split the subdomain from the host. If false, removes all subdomains from the host part of the link. *   `:domain` - Specifies the domain of the link, using the `tld_length` to split the domain from the host. *   `:tld_length` - Number of labels the TLD id composed of, only used if `:subdomain` or `:domain` are supplied. Defaults to `ActionDispatch::Http::URL.tld_length`, which in turn defaults to 1. *   `:port` - Optionally specify the port to connect to. *   `:anchor` - An anchor name to be appended to the path. *   `:params` - The query parameters to be appended to the path. *   `:path_params` - The query parameters that will only be used for the named dynamic segments of path. If unused, they will be discarded. *   `:trailing_slash` - If true, adds a trailing slash, as in `\"/archive/2009/\"`. *   `:script_name` - Specifies application path relative to domain root. If provided, prepends application path.   Any other key (`:controller`, `:action`, etc.) given to `url_for` is forwarded to the Routes module.  url_for controller: 'tasks', action: 'testing', host: 'somehost.org', port: '8080' # => 'http://somehost.org:8080/tasks/testing' url_for controller: 'tasks', action: 'testing', host: 'somehost.org', anchor: 'ok', only_path: true # => '/tasks/testing#ok' url_for controller: 'tasks', action: 'testing', trailing_slash: true # => 'http://somehost.org/tasks/testing/' url_for controller: 'tasks', action: 'testing', host: 'somehost.org', number: '33' # => 'http://somehost.org/tasks/testing?number=33' url_for controller: 'tasks', action: 'testing', host: 'somehost.org', script_name: \"/myapp\" # => 'http://somehost.org/myapp/tasks/testing' url_for controller: 'tasks', action: 'testing', host: 'somehost.org', script_name: \"/myapp\", only_path: true # => '/myapp/tasks/testing'  Missing routes keys may be filled in from the current request's parameters (e.g. `:controller`, `:action`, `:id`, and any other parameters that are placed in the path). Given that the current action has been reached through `GET /users/1`:  url_for(only_path: true)                        # => '/users/1' url_for(only_path: true, action: 'edit')        # => '/users/1/edit' url_for(only_path: true, action: 'edit', id: 2) # => '/users/2/edit'  Notice that no `:id` parameter was provided to the first `url_for` call and the helper used the one from the route's path. Any path parameter implicitly used by `url_for` can always be overwritten like shown on the last `url_for` calls.",
        "label": "How-to-use",
        "id": "11605"
    },
    {
        "raw_code": "def define_set_operator(operator)\n    method_name = \"from_#{operator.name.demodulize.downcase}\"\n    method_name = method_name.to_sym\n\n    raise \"Trying to redefine method '#{method(method_name)}'\" if methods.include?(method_name)\n\n    define_method(method_name) do |*members, remove_duplicates: true, remove_order: true, alias_as: table_name|\n      members = flatten_ar_array(members)\n\n      operator_sql =\n        if members.any?\n          operator.new(members, remove_duplicates: remove_duplicates, remove_order: remove_order).to_sql\n        else\n          where(\"1=0\").to_sql\n        end",
        "comment": "Define a high level method to more easily work with the SQL set operations of UNION, INTERSECT, and EXCEPT as defined by Gitlab::SQL::Union, Gitlab::SQL::Intersect, and Gitlab::SQL::Except respectively.",
        "label": "How-to-use",
        "id": "7273"
    },
    {
        "raw_code": "def on_investigation_end\n        investigate_post_walk(processed_source) if respond_to?(:investigate_post_walk)\n        super\n      end",
        "comment": "Called after all on_... have been called",
        "label": "How-to-use",
        "id": "10221"
    },
    {
        "raw_code": "def gc_time\n        (@gc_time_finish - @gc_time_start) / 1_000_000.0\n      end",
        "comment": "Returns the time spent in GC (in milliseconds) between the call to #start! and the call to #finish!",
        "label": "How-to-use",
        "id": "14516"
    },
    {
        "raw_code": "def has_job_class_name_argument?(class_name)\n        ast.each_descendant(:send).any? do |node|\n          node.arguments.any? do |arg|\n            next false unless arg.type == :hash\n\n            arg.pairs.any? do |pair|\n              key_node, value_node = pair.children\n              key_node.type == :sym &&\n                key_node.value == JOB_CLASS_NAME_KEY &&\n                value_node.type == :str &&\n                value_node.str_content == class_name\n            end",
        "comment": "Check if a method is called with job_class_name: 'ClassName' argument",
        "label": "How-to-use",
        "id": "8166"
    },
    {
        "raw_code": "def find_or_create_by!(attributes, &block)\n      find_by(attributes) || create_or_find_by!(attributes, &block)\n    end",
        "comment": "Like #find_or_create_by, but calls {create!}[rdoc-ref:Persistence::ClassMethods#create!] so an exception is raised if the created record is invalid.",
        "label": "How-to-use",
        "id": "12627"
    },
    {
        "raw_code": "def test_model_naming\n        assert_respond_to model.class, :model_name\n        model_name = model.class.model_name\n        assert_respond_to model_name, :to_str\n        assert_respond_to model_name.human, :to_str\n        assert_respond_to model_name.singular, :to_str\n        assert_respond_to model_name.plural, :to_str\n\n        assert_respond_to model, :model_name\n        assert_equal model.model_name, model.class.model_name\n      end",
        "comment": "Passes if the object's model responds to <tt>model_name</tt> both as an instance method and as a class method, and if calling this method returns a string with some convenience methods: <tt>:human</tt>, <tt>:singular</tt> and <tt>:plural</tt>.  Check ActiveModel::Naming for more information.",
        "label": "How-to-use",
        "id": "12245"
    },
    {
        "raw_code": "def route_for(name, *args)\n        public_send(:\"#{name}_url\", *args)\n      end",
        "comment": "Allows calling direct or regular named route.  resources :buckets  direct :recordable do |recording| route_for(:bucket, recording.bucket) end  direct :threadable do |threadable| route_for(:recordable, threadable.parent) end  This maintains the context of the original caller on whether to return a path or full URL, e.g:  threadable_path(threadable)  # => \"/buckets/1\" threadable_url(threadable)   # => \"http://example.com/buckets/1\" ",
        "label": "How-to-use",
        "id": "11606"
    },
    {
        "raw_code": "def update_file(path, &block)\n    original_mtime = File.exist?(path) ? File.mtime(path) : Time.at(0)\n    new_time = original_mtime + 1\n    File.open(path, 'w', &block)\n    File.utime(new_time, new_time, path)\n  end",
        "comment": "It calls <tt>File.open(path, 'w', &block)</tt> all the times needed to change the file's mtime.",
        "label": "How-to-use",
        "id": "8693"
    },
    {
        "raw_code": "def self.after_parse_callbacks\n      @after_parse_callbacks ||= []\n    end",
        "comment": "@return [Array<Proc>] the {after_parse} callback proc objects",
        "label": "How-to-use",
        "id": "84"
    },
    {
        "raw_code": "def delete_all(dependent = nil)\n        @association.delete_all(dependent).tap { reset_scope }\n      end",
        "comment": "Deletes all the records from the collection according to the strategy specified by the +:dependent+ option. If no +:dependent+ option is given, then it will follow the default strategy.  For <tt>has_many :through</tt> associations, the default deletion strategy is +:delete_all+.  For +has_many+ associations, the default deletion strategy is +:nullify+. This sets the foreign keys to +NULL+.  class Person < ActiveRecord::Base has_many :pets # dependent: :nullify option by default end  person.pets.size # => 3 person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.delete_all # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.size # => 0 person.pets      # => []  Pet.find(1, 2, 3) # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: nil>, #       #<Pet id: 2, name: \"Spook\", person_id: nil>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: nil> #    ]  Both +has_many+ and <tt>has_many :through</tt> dependencies default to the +:delete_all+ strategy if the +:dependent+ option is set to +:destroy+. Records are not instantiated and callbacks will not be fired.  class Person < ActiveRecord::Base has_many :pets, dependent: :destroy end  person.pets.size # => 3 person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.delete_all  Pet.find(1, 2, 3) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)  If it is set to <tt>:delete_all</tt>, all the objects are deleted *without* calling their +destroy+ method.  class Person < ActiveRecord::Base has_many :pets, dependent: :delete_all end  person.pets.size # => 3 person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.delete_all  Pet.find(1, 2, 3) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)",
        "label": "How-to-use",
        "id": "12790"
    },
    {
        "raw_code": "def cache_action(key, **custom_cache_opts)\n        cache_opts = apply_default_cache_options(custom_cache_opts)\n\n        json, cached_headers = cache.fetch(key, **cache_opts) do\n          response = yield\n\n          cached_body = response.is_a?(Gitlab::Json::PrecompiledJson) ? response.to_s : Gitlab::Json.dump(response.as_json)\n          cached_headers = header.slice(*PAGINATION_HEADERS)\n\n          [cached_body, cached_headers]\n        end",
        "comment": "Action caching implementation  This allows you to wrap an entire API endpoint call in a cache, useful for short TTL caches to effectively rate-limit an endpoint. The block will be converted to JSON and cached, and returns a `Gitlab::Json::PrecompiledJson` object which will be exported without secondary conversion.  @param key [Object] any object that can be converted into a cache key @param expires_in [ActiveSupport::Duration, Integer] an expiry time for the cache entry @return [Gitlab::Json::PrecompiledJson]",
        "label": "How-to-use",
        "id": "3839"
    },
    {
        "raw_code": "def perform_async(*args)\n        # rubocop:disable Gitlab/ModuleWithInstanceVariables -- @klass is present in the class we are patching\n\n        route_with_klass = @klass\n\n        # If an ActiveJob JobWrapper is pushed, check the arg hash's job_class for routing decisions.\n        #\n        # See https://github.com/rails/rails/blob/v7.1.0/activejob/lib/active_job/queue_adapters/sidekiq_adapter.rb#L21\n        # `job.serialize` would return a hash containing `job_class` set in\n        # https://github.com/rails/rails/blob/v7.1.0/activejob/lib/active_job/core.rb#L110\n        #\n        # In the GitLab Rails application, this only applies to ActionMailer::MailDeliveryJob\n        # but routing using the `job_class` keeps the option of using ActiveJob available for us.\n        #\n        if @klass == ActiveJob::QueueAdapters::SidekiqAdapter::JobWrapper &&\n            args.first.is_a?(Hash) &&\n            args.first['job_class']\n          route_with_klass = args.first['job_class'].to_s.safe_constantize\n        end",
        "comment": "Sidekiq::Job::Setter's .perform_in and .perform_async indirectly calls perform_async so we only need to patch 1 method.",
        "label": "How-to-use",
        "id": "2916"
    },
    {
        "raw_code": "def expected_order\n          cop_config['ExpectedOrder']\n        end",
        "comment": "Load expected order from `ExpectedOrder` config. Define new terms in the expected order by adding new {categories}.",
        "label": "How-to-use",
        "id": "10383"
    },
    {
        "raw_code": "def collection_method\n        raise NotImplementedError\n      end",
        "comment": "The name of the method to call to retrieve the data to import.",
        "label": "How-to-use",
        "id": "2136"
    },
    {
        "raw_code": "def head(level, text)\n    @RM::Heading.new level, text\n  end",
        "comment": " Shortcut for RDoc::Markup::Heading.new with +level+ and +text+",
        "label": "How-to-use",
        "id": "16876"
    },
    {
        "raw_code": "def self.data\n          @data ||= {}\n        end",
        "comment": "Returns the internal data associated with this plugin. This should NOT be called by the general public.  @return [Hash]",
        "label": "How-to-use",
        "id": "9117"
    },
    {
        "raw_code": "def disable(*opts)\n        opts.each { |key| set(key, false) }\n      end",
        "comment": "Same as calling `set :option, false` for each of the given options.",
        "label": "How-to-use",
        "id": "8598"
    },
    {
        "raw_code": "def member_idx(idx)\n    ::Arel::Nodes::SqlLiteral.new(idx.to_s).as('union_member_idx')\n  end",
        "comment": "rubocop: enable Graphql/Descriptions",
        "label": "How-to-use",
        "id": "6184"
    },
    {
        "raw_code": "def on_match_pattern_p(node)\n          check(node, [:operator].freeze)\n        end",
        "comment": "Handle one-line pattern matching syntax (`in`) with `Parser::Ruby30`.",
        "label": "How-to-use",
        "id": "10356"
    },
    {
        "raw_code": "def extract_commit_id_from_ref(ref)\n        return ref if Gitlab::Git.commit_id?(ref)\n\n        tag = find_tag(ref)\n        return tag.dereferenced_target.sha if tag\n\n        branch = find_branch(ref)\n        return branch.dereferenced_target.sha if branch\n\n        ref\n      end",
        "comment": "The order is based on git priority to resolve ambiguous references  `git show <ref>`  In case of name clashes, it uses this order: 1. Commit 2. Tag 3. Branch",
        "label": "How-to-use",
        "id": "2660"
    },
    {
        "raw_code": "def __getobj__ # :nodoc:\n      @mail_message ||= processed_mailer.message\n    end",
        "comment": "Method calls are delegated to the Mail::Message that's ready to deliver.",
        "label": "How-to-use",
        "id": "11141"
    },
    {
        "raw_code": "def close(unlink_now = false)\n        @tempfile.close(unlink_now)\n      end",
        "comment": "Shortcut for `tempfile.close`.",
        "label": "How-to-use",
        "id": "11485"
    },
    {
        "raw_code": "def superclass=(superclass)\n    raise NoMethodError, \"#{full_name} is a module\" if module?\n    case superclass\n    when RDoc::ClassModule\n      @superclass = superclass.full_name\n    when nil, String\n      @superclass = superclass\n    else\n      raise TypeError, \"superclass must be a String or RDoc::ClassModule, not #{superclass.class}\"\n    end",
        "comment": " Set the superclass of this class to +superclass+  where +superclass+ is one of:  - +nil+ - a String containing the full name of the superclass - the RDoc::ClassModule representing the superclass",
        "label": "How-to-use",
        "id": "16764"
    },
    {
        "raw_code": "def configure(service_name, configurations)\n        Configurator.build(service_name, configurations)\n      end",
        "comment": "Configure an Active Storage service by name from a set of configurations, typically loaded from a YAML file. The Active Storage engine uses this to set the global Active Storage service when the app boots.",
        "label": "How-to-use",
        "id": "13668"
    },
    {
        "raw_code": "def initialize(text, name, singleton: false)\n    super()\n\n    @text = text\n    @name = name\n\n    @aliases      = []\n    @is_alias_for = nil\n    @parent_name  = nil\n    @singleton    = singleton\n    @visibility   = :public\n    @see = false\n\n    @arglists     = nil\n    @block_params = nil\n    @call_seq     = nil\n    @params       = nil\n  end",
        "comment": " Creates a new MethodAttr from token stream +text+ and method or attribute name +name+.  Usually this is called by super from a subclass.",
        "label": "How-to-use",
        "id": "16815"
    },
    {
        "raw_code": "def self.measure_thread_memory_allocations(previous)\n        return unless available?\n        return unless previous\n\n        current = Thread.current.memory_allocations\n        return unless current\n\n        # calculate difference in a memory allocations\n        result = previous.to_h do |key, value|\n          [KEY_MAPPING.fetch(key), current[key].to_i - value]\n        end",
        "comment": "This method returns a hash with the following keys: - mem_objects:     number of allocated heap slots (as reflected by GC) - mem_mallocs:     number of malloc calls - mem_bytes:       number of bytes allocated by malloc for objects that did not fit into a heap slot - mem_total_bytes: number of bytes allocated for both objects consuming an object slot and objects that required a malloc (mem_malloc_bytes)",
        "label": "How-to-use",
        "id": "1877"
    },
    {
        "raw_code": "def deprecate_methods(target_module, *method_names)\n        options = method_names.extract_options!\n        deprecator = options.delete(:deprecator) || self\n        method_names += options.keys\n        mod = nil\n\n        method_names.each do |method_name|\n          message = options[method_name]\n          if target_module.method_defined?(method_name) || target_module.private_method_defined?(method_name)\n            method = target_module.instance_method(method_name)\n            target_module.module_eval do\n              redefine_method(method_name) do |*args, &block|\n                deprecator.deprecation_warning(method_name, message)\n                method.bind_call(self, *args, &block)\n              end",
        "comment": "Declare that a method has been deprecated.  class Fred def aaa; end def bbb; end def ccc; end def ddd; end def eee; end end  deprecator = ActiveSupport::Deprecation.new('next-release', 'MyGem')  deprecator.deprecate_methods(Fred, :aaa, bbb: :zzz, ccc: 'use Bar#ccc instead') # => Fred  Fred.new.aaa # DEPRECATION WARNING: aaa is deprecated and will be removed from MyGem next-release. (called from irb_binding at (irb):10) # => nil  Fred.new.bbb # DEPRECATION WARNING: bbb is deprecated and will be removed from MyGem next-release (use zzz instead). (called from irb_binding at (irb):11) # => nil  Fred.new.ccc # DEPRECATION WARNING: ccc is deprecated and will be removed from MyGem next-release (use Bar#ccc instead). (called from irb_binding at (irb):12) # => nil",
        "label": "How-to-use",
        "id": "14439"
    },
    {
        "raw_code": "def gen_const_table(file_content)\n    table = {}\n    @content.scan(%r{\n      (?<doc>(?>^\\s*/\\*.*?\\*/\\s+))\n        rb_define_(?<type>\\w+)\\(\\s*(?:\\w+),\\s*\n                           \"(?<name>\\w+)\"\\s*,\n                           .*?\\)\\s*;\n    | (?<doc>(?>^\\s*/\\*.*?\\*/\\s+))\n        rb_define_global_(?<type>const)\\(\\s*\n                           \"(?<name>\\w+)\"\\s*,\n                           .*?\\)\\s*;\n    |  (?<doc>(?>^\\s*/\\*.*?\\*/\\s+))\n        rb_file_(?<type>const)\\(\\s*\n                           \"(?<name>\\w+)\"\\s*,\n                           .*?\\)\\s*;\n    |  (?<doc>(?>^\\s*/\\*.*?\\*/\\s+))\n        rb_curses_define_(?<type>const)\\(\\s*\n                           (?<name>\\w+)\n                           \\s*\\)\\s*;\n    | Document-(?:const|global|variable):\\s\n        (?<name>(?:\\w+::)*\\w+)\n        \\s*?\\n(?<doc>(?>.*?\\*/))\n    }mxi) do\n      name, doc, type = $~.values_at(:name, :doc, :type)\n      if type\n        table[[type, name]] = doc\n      else\n        table[name] = \"/*\\n\" + doc\n      end",
        "comment": " Generate a const table",
        "label": "How-to-use",
        "id": "16155"
    },
    {
        "raw_code": "def undo_change_column_type_concurrently(table, column)\n        temp_column = \"#{column}_for_type_change\"\n\n        undo_rename_column_concurrently(table, column, temp_column)\n      end",
        "comment": "Reverses operations performed by change_column_type_concurrently.  table - The table containing the column. column - The name of the column to change.",
        "label": "How-to-use",
        "id": "2988"
    },
    {
        "raw_code": "def decrement!(attribute, by = 1, touch: nil)\n      increment!(attribute, -by, touch: touch)\n    end",
        "comment": "Wrapper around #decrement that writes the update to the database. Only +attribute+ is updated; the record itself is not saved. This means that any other modified attributes will still be dirty. Validations and callbacks are skipped. Supports the +touch+ option from +update_counters+, see that for more. Returns +self+.",
        "label": "How-to-use",
        "id": "12575"
    },
    {
        "raw_code": "def self.to_prepare(*args, &block)\n      set_callback(:prepare, *args, &block)\n    end",
        "comment": "Registers a callback that will run once at application startup and every time the code is reloaded.",
        "label": "How-to-use",
        "id": "13929"
    },
    {
        "raw_code": "def self.before_class_unload(*args, &block)\n      set_callback(:class_unload, *args, &block)\n    end",
        "comment": "Registers a callback that will run immediately before the classes are unloaded.",
        "label": "How-to-use",
        "id": "13930"
    },
    {
        "raw_code": "def to_docstring\n      Docstring.new!(text, tags, object, raw_text, reference)\n    end",
        "comment": "@return [Docstring] translates parsed text into a Docstring object.",
        "label": "How-to-use",
        "id": "75"
    },
    {
        "raw_code": "def initialize(app)\n        super()\n        @app = app\n\n        reset!\n      end",
        "comment": "Create and initialize a new Session instance.",
        "label": "How-to-use",
        "id": "11623"
    },
    {
        "raw_code": "def requests_remaining?\n        if requests_limit == SEARCH_MAX_REQUESTS_PER_MINUTE\n          return remaining_requests > SEARCH_RATE_LIMIT_THRESHOLD\n        end",
        "comment": "Returns `true` if we're still allowed to perform API calls. Search API has rate limit of 30, use lowered threshold when search is used.",
        "label": "How-to-use",
        "id": "2168"
    },
    {
        "raw_code": "def cursor_for(node)\n            order = Gitlab::Pagination::Keyset::Order.extract_keyset_order_object(items)\n            encode(order.cursor_attributes_for_node(node).to_json)\n          end",
        "comment": "rubocop: enable Naming/PredicateName",
        "label": "How-to-use",
        "id": "2093"
    },
    {
        "raw_code": "def self.with_read_consistency(&block)\n        ::Gitlab::Database::LoadBalancing::SessionMap\n          .with_sessions(Gitlab::Database::LoadBalancing.base_models)\n          .use_primary(&block)\n      end",
        "comment": " Within the block, disable the database load balancing for calls that require read consistency after recent writes. ",
        "label": "How-to-use",
        "id": "3021"
    },
    {
        "raw_code": "def scope; :class end\n\n    # Sets up a delegate for {MethodObject} obj.\n    #\n    # @param [MethodObject] obj the instance method to treat as a mixed in\n    #   class method on another namespace.\n    def initialize(obj) @del = obj end\n\n    # Sends all methods to the {MethodObject} assigned in {#initialize}\n    # @see #initialize\n    # @see MethodObject\n    def method_missing(sym, *args, &block) @del.__send__(sym, *args, &block) end\n  end\nend",
        "comment": "@return [Symbol] always +:class+",
        "label": "How-to-use",
        "id": "595"
    },
    {
        "raw_code": "def attributes(text)\n    flow = @am.flow text.dup\n    convert_flow flow\n  end",
        "comment": " Applies attribute-specific markup to +text+ using RDoc::AttributeManager",
        "label": "How-to-use",
        "id": "16207"
    },
    {
        "raw_code": "def route_list(library, paths)\n        return if paths.empty?\n        ListCommand.new(final_options(library, paths)).call(request)\n      end",
        "comment": "Routes requests from {#list_prefix} and calls the appropriate command @param (see #route_docs) @return (see #route_docs)",
        "label": "How-to-use",
        "id": "659"
    },
    {
        "raw_code": "def swap(klass, new_values)\n      old_values = {}\n      new_values.each do |key, value|\n        old_values[key] = klass.public_send key\n        klass.public_send :\"#{key}=\", value\n      end",
        "comment": "Execute the block setting the given values and restoring old values after the block is executed.",
        "label": "How-to-use",
        "id": "11174"
    },
    {
        "raw_code": "def append(key, value)\n      @content[key] << value.to_s\n    end",
        "comment": "Called by content_for",
        "label": "How-to-use",
        "id": "11719"
    },
    {
        "raw_code": "def self.escape(text, quote)\n        text.gsub(/#{quote}/) do |m|\n          \"#{m}\\\\#{m}#{m}\"\n        end",
        "comment": "This will auto-escape the text with the given quote mark type.  @param [String] text Text to escape @param [String] quote The quote character, such as \"",
        "label": "How-to-use",
        "id": "9292"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_rule self\n  end",
        "comment": " Calls #accept_rule on +visitor+",
        "label": "How-to-use",
        "id": "16296"
    },
    {
        "raw_code": "def api_only!\n        hide_namespaces \"assets\", \"helper\", \"css\", \"js\"\n\n        options[:rails].merge!(\n          api: true,\n          assets: false,\n          helper: false,\n          template_engine: nil\n        )\n\n        options[:mailer] ||= {}\n        options[:mailer][:template_engine] ||= :erb\n      end",
        "comment": "Configure generators for API only applications. It basically hides everything that is usually browser related, such as assets and session migration generators, and completely disable helpers and assets so generators such as scaffold won't create them.",
        "label": "How-to-use",
        "id": "14673"
    },
    {
        "raw_code": "def source_path\n        @source_path ||= load_source_path\n      end",
        "comment": "@return [String] the location of the source code for a library. This value is filled by calling +#source_path_for_SOURCE+ on this class. @return [nil] if there is no source code @see LibraryVersion LibraryVersion documentation for \"Implementing a Custom Library Source\"",
        "label": "How-to-use",
        "id": "640"
    },
    {
        "raw_code": "def diffable_merge_ref?\n    open? && merge_head_diff.present? && can_be_merged?\n  end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "6975"
    },
    {
        "raw_code": "def cache(key, options = {}, &block) # :doc:\n        if cache_configured?\n          cache_store.fetch(ActiveSupport::Cache.expand_cache_key(key, :controller), options, &block)\n        else\n          yield\n        end",
        "comment": "Convenience accessor.",
        "label": "How-to-use",
        "id": "11193"
    },
    {
        "raw_code": "def parse_comment_attr(container, type, name, comment) # :nodoc:\n    return if name.empty?\n\n    rw = case type\n         when 'attr_reader' then 'R'\n         when 'attr_writer' then 'W'\n         else 'RW'\n         end",
        "comment": " Parse a comment that is describing an attribute in +container+ with the given +name+ and +comment+.",
        "label": "How-to-use",
        "id": "16091"
    },
    {
        "raw_code": "def connected_to_all_shards(role: nil, prevent_writes: false, &blk)\n      shard_keys.map do |shard|\n        connected_to(shard: shard, role: role, prevent_writes: prevent_writes, &blk)\n      end",
        "comment": "Passes the block to +connected_to+ for every +shard+ the model is configured to connect to (if any), and returns the results in an array.  Optionally, +role+ and/or +prevent_writes+ can be passed which will be forwarded to each +connected_to+ call.",
        "label": "How-to-use",
        "id": "12399"
    },
    {
        "raw_code": "def new_issue_branch(issue, project, author, branch, branch_project: nil)\n    ::SystemNotes::MergeRequestsService.new(noteable: issue, container: project, author: author).new_issue_branch(branch, branch_project: branch_project)\n  end",
        "comment": "Called when a branch is created from the 'new branch' button on a issue Example note text:  \"created branch `201-issue-branch-button`\"",
        "label": "How-to-use",
        "id": "5512"
    },
    {
        "raw_code": "def init_tags\n    add_tag :BOLD, \"<b>\", \"</b>\"\n    add_tag :TT,   \"<tt>\", \"</tt>\"\n    add_tag :EM,   \"<em>\", \"</em>\"\n  end",
        "comment": " Maps attributes to HTML sequences",
        "label": "How-to-use",
        "id": "16193"
    },
    {
        "raw_code": "def init_tags\n    add_tag :BOLD, \"<strong>\", \"</strong>\"\n    add_tag :TT,   \"<code>\",   \"</code>\"\n    add_tag :EM,   \"<em>\",     \"</em>\"\n  end",
        "comment": " Maps attributes to HTML tags",
        "label": "How-to-use",
        "id": "16348"
    },
    {
        "raw_code": "def key_matcher(pattern, options) # :doc:\n          prefix = options[:namespace].is_a?(Proc) ? options[:namespace].call : options[:namespace]\n          if prefix\n            source = pattern.source\n            if source.start_with?(\"^\")\n              source = source[1, source.length]\n            else\n              source = \".*#{source[0, source.length]}\"\n            end",
        "comment": "Adds the namespace defined in the options to a pattern designed to match keys. Implementations that support delete_matched should call this method to translate a pattern that matches names into one that matches namespaced keys.",
        "label": "How-to-use",
        "id": "13753"
    },
    {
        "raw_code": "def self.after_class_unload(*args, &block)\n      set_callback(:class_unload, :after, *args, &block)\n    end",
        "comment": "Registers a callback that will run immediately after the classes are unloaded.",
        "label": "How-to-use",
        "id": "13931"
    },
    {
        "raw_code": "def enqueue_in(interval, klass, *args)\n        klass.perform_in(interval, *args)\n      end",
        "comment": "Example usage: Sidekiq::Client.enqueue_in(3.minutes, MyJob, 'foo', 1, :bat => 'bar') ",
        "label": "How-to-use",
        "id": "5099"
    },
    {
        "raw_code": "def register_interceptors(*interceptors)\n        interceptors.flatten.compact.each { |interceptor| register_interceptor(interceptor) }\n      end",
        "comment": "Register one or more Interceptors which will be called before mail is sent.",
        "label": "How-to-use",
        "id": "11108"
    },
    {
        "raw_code": "def on_investigation_end\n        # Typically do nothing here\n      end",
        "comment": "Called after all on_... have been called When refining this method, always call `super`",
        "label": "How-to-use",
        "id": "10255"
    },
    {
        "raw_code": "def touch_noteable\n    # Commits are not stored in the DB so we can't touch them.\n    # Vulnerabilities should not be touched as they are tracked in the same manner as other issuable types\n    return if for_vulnerability? || for_commit?\n\n    assoc = association(:noteable)\n\n    noteable_object =\n      if assoc.loaded?\n        noteable\n      else\n        # If the object is not loaded (e.g. when notes are loaded async) we\n        # _only_ want the data we actually need.\n        assoc.scope.select(:id, :updated_at).take\n      end",
        "comment": "By default Rails will issue an \"SELECT *\" for the relation, which is overkill for just updating the timestamps. To work around this we manually touch the data so we can SELECT only the columns we need.",
        "label": "How-to-use",
        "id": "6937"
    },
    {
        "raw_code": "def __internal_state\n          {\n            \"config_map\"        => @config_map,\n            \"keys\"              => @keys,\n            \"missing_key_calls\" => @missing_key_calls\n          }\n        end",
        "comment": "Returns the internal state of the root object. This is used by outside classes when merging, and shouldn't be called directly. Note the strange method name is to attempt to avoid any name clashes with potential configuration keys.",
        "label": "How-to-use",
        "id": "8932"
    },
    {
        "raw_code": "def construct(*args)\n    \"#{prefix}#{braces(*args)}\\n#{suffix}\"\n  end",
        "comment": "Construct a piece of source code for brace layout testing. This farms out most of the work to `#braces` but it also includes a prefix and suffix.",
        "label": "How-to-use",
        "id": "11024"
    },
    {
        "raw_code": "def method_call_data\n          @method_calls ||= Hash.new { |hsh, key| hsh[key] = [] }\n        end",
        "comment": "Recorded method calls  @return [Hash]",
        "label": "How-to-use",
        "id": "4548"
    },
    {
        "raw_code": "def serialize(object, data) end\n\n      # The serialized path of an object\n      #\n      # @abstract This method should return the path of the object on the\n      #   endpoint. For instance, for a file serializer, this should return\n      #   the filename that represents the object on disk.\n      # @param [CodeObjects::Base] object the object to return a path for\n      # @return [String] the serialized path of an object\n      def serialized_path(object) end\n\n      # Returns whether an object has been serialized\n      #\n      # @abstract This method should return whether the endpoint already exists.\n      #   For instance, a file system serializer would check if the file exists\n      #   on disk. You will most likely use +#basepath+ and {#serialized_path} to\n      #   get the endpoint's location.\n      # @param [CodeObjects::Base] object the object to check existence of\n      # @return [Boolean] whether the endpoint exists.\n      # @since 0.6.0\n      def exists?(object) # rubocop:disable Lint/UnusedMethodArgument\n        false\n      end\n\n      # @group Callbacks\n\n      # Called before serialization.\n      #\n      # @abstract Should run code before serialization. Should return false\n      #   if serialization should not occur.\n      # @return [Boolean] whether or not serialization should occur\n      def before_serialize; end\n\n      # Called after serialization.\n      #\n      # @abstract Should run code after serialization.\n      # @param [String] data the data that was serialized.\n      # @return [void]\n      def after_serialize(data); end\n    end\n  end\nend",
        "comment": "@group Serializing an Object Serializes an object.  @abstract This method should implement the logic that serializes +data+ to the respective endpoint. This method should also call the before and after callbacks {#before_serialize} and {#after_serialize} @param [CodeObjects::Base, String] object the object to serialize the data for. The object can also be a string (for non-object serialization) @param [String] data the contents that should be serialized",
        "label": "How-to-use",
        "id": "463"
    },
    {
        "raw_code": "def accept_list_end(list)\n    @list_type.pop\n  end",
        "comment": " Pops the list type for +list+ from #list_type",
        "label": "How-to-use",
        "id": "16255"
    },
    {
        "raw_code": "def excerpt(comment)\n    text = case comment\n    when RDoc::Comment\n      comment.text\n    else\n      comment\n    end",
        "comment": ":startdoc: Returns an excerpt of the comment for usage in meta description tags",
        "label": "How-to-use",
        "id": "16474"
    },
    {
        "raw_code": "def content_mime_type\n        fetch_header(\"action_dispatch.request.content_type\") do |k|\n          v = if get_header(\"CONTENT_TYPE\") =~ /^([^,;]*)/\n            Mime::Type.lookup($1.strip.downcase)\n          else\n            nil\n          end",
        "comment": "The MIME type of the HTTP request, such as [Mime](:xml).",
        "label": "How-to-use",
        "id": "11431"
    },
    {
        "raw_code": "def get(key)\n      return nil if !@items.key?(key)\n      return @results_cache[key] if @results_cache.key?(key)\n      @results_cache[key] = @items[key].call\n    end",
        "comment": "Get a value by the given key.  This will evaluate the block given to `register` and return the resulting value.",
        "label": "How-to-use",
        "id": "8743"
    },
    {
        "raw_code": "def community_forum\n    ApplicationHelper.community_forum\n  end",
        "comment": "Convenient method for Rails helper",
        "label": "How-to-use",
        "id": "7726"
    },
    {
        "raw_code": "def handle_regexp_RDOCLINK(target)\n    url = target.text\n\n    case url\n    when /\\Ardoc-ref:/\n      cross_reference $', rdoc_ref: true\n    else\n      super\n    end",
        "comment": " +target+ is an rdoc-schemed link that will be converted into a hyperlink. For the rdoc-ref scheme the cross-reference will be looked up and the given name will be used.  All other contents are handled by {the superclass}[rdoc-ref:RDoc::Markup::ToHtml#handle_regexp_RDOCLINK]",
        "label": "How-to-use",
        "id": "16249"
    },
    {
        "raw_code": "def history(session_name = nil)\n          query_params = session_name ? build_params(session: get_session_id(session_name)) : ''\n          response = get(\"#{admin_url}/history?#{query_params}\")\n          body = parse_body(response)\n\n          raise body[:message] unless body.is_a?(Array)\n\n          body.map do |entry|\n            HistoryResponse.new(entry)\n          end",
        "comment": "Fetches call history for a mock  @param session_name [String] the session name for the mock @return [Array<HistoryResponse>]",
        "label": "How-to-use",
        "id": "4346"
    },
    {
        "raw_code": "def try!(*, &)\n    nil\n  end",
        "comment": "Calling +try!+ on +nil+ always returns +nil+.  nil.try!(:name) # => nil",
        "label": "How-to-use",
        "id": "14333"
    },
    {
        "raw_code": "def help(shell, *) # :nodoc:\n          super\n          shell.say class_usage if class_usage\n        end",
        "comment": "Override Thor's class-level help to also show the USAGE.",
        "label": "How-to-use",
        "id": "14708"
    },
    {
        "raw_code": "def extract_skippables!(field)\n      list = field.split(',').uniq\n\n      extract_skippable_operations!(list)\n      extract_skippable_tasks(list)\n    end",
        "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity Extract skippables from provided data field Current callers will provide either ENV['SKIP'] or backup_information[:skipped] content  The first time the method is executed it will setup `true` or `false` to each field subsequent executions will preserve `true` values and evaluate again only when previously set to `false`  @param [String] field contains a list separated by comma without surrounding spaces",
        "label": "How-to-use",
        "id": "3636"
    },
    {
        "raw_code": "def initialize(usernames, ids)\n      # rubocop:disable CodeReuse/ActiveRecord\n      @usernames = Array(usernames).map(&:to_s).uniq.take(MAX_FILTER_ELEMENTS)\n      @ids = Array(ids).uniq.take(MAX_FILTER_ELEMENTS)\n      # rubocop:enable CodeReuse/ActiveRecord\n    end",
        "comment": "Initialize the finder  @param [Array<String>] usernames @param [Array<Integers>] ids",
        "label": "How-to-use",
        "id": "7958"
    },
    {
        "raw_code": "def self.home\n    rdoc_dir = begin\n                File.expand_path('~/.rdoc')\n              rescue ArgumentError\n              end",
        "comment": " Searches and returns the directory for settings.  1. <tt>$HOME/.rdoc</tt> directory, if it exists. 2. The +rdoc+ directory under the path specified by the +XDG_DATA_HOME+ environment variable, if it is set. 3. <tt>$HOME/.local/share/rdoc</tt> directory.  Other than the home directory, the containing directory will be created automatically.",
        "label": "How-to-use",
        "id": "15501"
    },
    {
        "raw_code": "def register_preview_interceptor(interceptor)\n        preview_interceptor = interceptor_class_for(interceptor)\n\n        unless preview_interceptors.include?(preview_interceptor)\n          preview_interceptors << preview_interceptor\n        end",
        "comment": "Register an Interceptor which will be called before mail is previewed. Either a class or a string can be passed in as the Interceptor. If a string is passed in it will be constantized.",
        "label": "How-to-use",
        "id": "11153"
    },
    {
        "raw_code": "def hash_set(hash, key, value)\n        increment_element_count!\n\n        current_size = @hash_counts[hash.object_id] || 0 # rubocop:disable Lint/HashCompareByIdentity -- We want to track by object ID\n        check_hash_size!(current_size)\n\n        hash[key] = value\n        new_size = current_size + 1\n        @hash_counts[hash.object_id] = new_size # rubocop:disable Lint/HashCompareByIdentity -- We want to track by object ID\n        @max_hash_count = [@max_hash_count, new_size].max\n      end",
        "comment": "Called when a key/value pair is complete",
        "label": "How-to-use",
        "id": "1962"
    },
    {
        "raw_code": "def init\n      end",
        "comment": "Initialization called on the template. Override this in a 'setup.rb' file in the template's path to implement a template  @example A default set of sections def init sections :section1, :section2, [:subsection1, :etc] end @see #sections",
        "label": "How-to-use",
        "id": "364"
    },
    {
        "raw_code": "def call?\n          false\n        end",
        "comment": "@return [Boolean] whether the node is a method call",
        "label": "How-to-use",
        "id": "315"
    },
    {
        "raw_code": "def lazy_ref_commit\n      BatchLoader.for(ref).batch(key: project.id) do |refs, loader|\n        next unless project.repository_exists?\n\n        project.repository.list_commits_by_ref_name(refs).then do |commits|\n          commits.each { |key, commit| loader.call(key, commits[key]) }\n        end",
        "comment": "rubocop: enable CodeReuse/ServiceClass",
        "label": "How-to-use",
        "id": "7559"
    },
    {
        "raw_code": "def excluding(*records)\n      relations = records.extract! { |element| element.is_a?(Relation) }\n      records.flatten!(1)\n      records.compact!\n\n      unless records.all?(model) && relations.all? { |relation| relation.model == model }\n        raise ArgumentError, \"You must only pass a single or collection of #{model.name} objects to ##{__callee__}.\"\n      end",
        "comment": "Excludes the specified record (or collection of records) from the resulting relation. For example:  Post.excluding(post) # SELECT \"posts\".* FROM \"posts\" WHERE \"posts\".\"id\" != 1  Post.excluding(post_one, post_two) # SELECT \"posts\".* FROM \"posts\" WHERE \"posts\".\"id\" NOT IN (1, 2)  Post.excluding(Post.drafts) # SELECT \"posts\".* FROM \"posts\" WHERE \"posts\".\"id\" NOT IN (3, 4, 5)  This can also be called on associations. As with the above example, either a single record of collection thereof may be specified:  post = Post.find(1) comment = Comment.find(2) post.comments.excluding(comment) # SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"post_id\" = 1 AND \"comments\".\"id\" != 2  This is short-hand for <tt>.where.not(id: post.id)</tt> and <tt>.where.not(id: [post_one.id, post_two.id])</tt>.  An <tt>ArgumentError</tt> will be raised if either no records are specified, or if any of the records in the collection (if a collection is passed in) are not instances of the same model that the relation is scoping.",
        "label": "How-to-use",
        "id": "13435"
    },
    {
        "raw_code": "def cycle(first_value, *values)\n        options = values.extract_options!\n        name = options.fetch(:name, \"default\")\n\n        values.unshift(*first_value)\n\n        cycle = get_cycle(name)\n        unless cycle && cycle.values == values\n          cycle = set_cycle(name, Cycle.new(*values))\n        end",
        "comment": "Creates a Cycle object whose +to_s+ method cycles through elements of an array every time it is called. This can be used for example, to alternate classes for table rows. You can use named cycles to allow nesting in loops. Passing a Hash as the last parameter with a <tt>:name</tt> key will create a named cycle. The default name for a cycle without a +:name+ key is <tt>\"default\"</tt>. You can manually reset a cycle by calling reset_cycle and passing the name of the cycle. The current cycle string can be obtained anytime using the current_cycle method.  <%# Alternate CSS classes for even and odd numbers... %> <% @items = [1,2,3,4] %> <table> <% @items.each do |item| %> <tr class=\"<%= cycle(\"odd\", \"even\") -%>\"> <td><%= item %></td> </tr> <% end %> </table>   <%# Cycle CSS classes for rows, and text colors for values within each row %> <% @items = [ { first: \"Robert\", middle: \"Daniel\", last: \"James\" }, { first: \"Emily\", middle: \"Shannon\", maiden: \"Pike\", last: \"Hicks\" }, { first: \"June\", middle: \"Dae\", last: \"Jones\" }, ] %> <% @items.each do |item| %> <tr class=\"<%= cycle(\"odd\", \"even\", name: \"row_class\") -%>\"> <td> <% item.values.each do |value| %> <%# Create a named cycle \"colors\" %> <span style=\"color:<%= cycle(\"red\", \"green\", \"blue\", name: \"colors\") -%>\"> <%= value %> </span> <% end %> <% reset_cycle(\"colors\") %> </td> </tr> <% end %>",
        "label": "How-to-use",
        "id": "11982"
    },
    {
        "raw_code": "def help\n            opts = OptionParser.new do |opts|\n              opts.banner = \"Usage: vagrant cloud provider <subcommand> [<args>]\"\n              opts.separator \"\"\n              opts.separator \"For various provider actions with Vagrant Cloud\"\n              opts.separator \"\"\n              opts.separator \"Available subcommands:\"\n\n              # Add the available subcommands as separators in order to print them\n              # out as well.\n              keys = []\n              @subcommands.each { |key, value| keys << key.to_s }\n\n              keys.sort.each do |key|\n                opts.separator \"     #{key}\"\n              end",
        "comment": "Prints the help out for this command",
        "label": "How-to-use",
        "id": "9782"
    },
    {
        "raw_code": "def build_download_options(parser, options)\n        # Add the options\n        parser.on(\"--insecure\", \"Do not validate SSL certificates\") do |i|\n          options[:insecure] = i\n        end",
        "comment": "This adds common download command line flags to the given OptionParser, storing the result in the `options` dictionary.  @param [OptionParser] parser @param [Hash] options",
        "label": "How-to-use",
        "id": "9814"
    },
    {
        "raw_code": "def pick_from_old_menus(old_menus)\n        old_menus.select! do |menu|\n          next true unless menu.pick_into_super_sidebar?\n\n          add_menu(menu)\n          false\n        end",
        "comment": "Picks menus from a list and adds them to the current menu list if they should be picked into the super sidebar",
        "label": "How-to-use",
        "id": "3687"
    },
    {
        "raw_code": "def execute_mr_web_hooks(merge_request)\n      execute_hooks(merge_request, 'update', old_rev: @push.oldrev)\n    end",
        "comment": "Call merge request webhook with update branches",
        "label": "How-to-use",
        "id": "5553"
    },
    {
        "raw_code": "def object_hierarchy(options = {})\n      ::Gitlab::Ci::PipelineObjectHierarchy\n        .new(self.class.unscoped.where(id: id), options: options)\n    end",
        "comment": "Without using `unscoped`, caller scope is also included into the query. Using `unscoped` here will be redundant after Rails 6.1",
        "label": "How-to-use",
        "id": "7583"
    },
    {
        "raw_code": "def deserialize(hash)\n        raise NotImplementedError, \"#{self.class.name} should implement a public #deserialize(hash) method\"\n      end",
        "comment": "Deserializes an argument from a JSON primitive type.",
        "label": "How-to-use",
        "id": "12164"
    },
    {
        "raw_code": "def hash_key(key)\n        increment_element_count!\n\n        key\n      end",
        "comment": "Called for each key in a hash",
        "label": "How-to-use",
        "id": "1961"
    },
    {
        "raw_code": "def fetch_multi(*names)\n        raise ArgumentError, \"Missing block: `Cache#fetch_multi` requires a block.\" unless block_given?\n        return {} if names.empty?\n\n        options = names.extract_options!\n        options = merged_options(options)\n        keys    = names.map { |name| normalize_key(name, options) }\n        writes  = {}\n        ordered = instrument_multi :read_multi, keys, options do |payload|\n          if options[:force]\n            reads = {}\n          else\n            reads = read_multi_entries(names, **options)\n          end",
        "comment": "Fetches data from the cache, using the given keys. If there is data in the cache with the given keys, then that data is returned. Otherwise, the supplied block is called for each key for which there was no data, and the result will be written to the cache and returned. Therefore, you need to pass a block that returns the data to be written to the cache. If you do not want to write the cache when the cache is not found, use #read_multi.  Returns a hash with the data for each of the names. For example:  cache.write(\"bim\", \"bam\") cache.fetch_multi(\"bim\", \"unknown_key\") do |key| \"Fallback value for key: #{key}\" end # => { \"bim\" => \"bam\", #      \"unknown_key\" => \"Fallback value for key: unknown_key\" }  You may also specify additional options via the +options+ argument. See #fetch for details. Other options are passed to the underlying cache implementation. For example:  cache.fetch_multi(\"fizz\", expires_in: 5.seconds) do |key| \"buzz\" end # => {\"fizz\"=>\"buzz\"} cache.read(\"fizz\") # => \"buzz\" sleep(6) cache.read(\"fizz\") # => nil",
        "label": "How-to-use",
        "id": "13739"
    },
    {
        "raw_code": "def self.max_call_count\n      return 0 unless Gitlab::SafeRequestStore.active?\n\n      stack_counter = Gitlab::SafeRequestStore[:stack_counter]\n      return 0 unless stack_counter\n\n      stack_counter.values.max\n    end",
        "comment": "Returns a count for the stack which called Gitaly the most times. Used for n+1 detection",
        "label": "How-to-use",
        "id": "1374"
    },
    {
        "raw_code": "def find_partials(file)\n        partial_paths = find_pattern_in_file(file, RAILS_PARTIAL_INVOCATION_REGEXP)\n        partial_paths.flat_map do |partial_path|\n          view_file_folder        = File.dirname(file)\n          partial_relative_folder = File.dirname(partial_path)\n\n          dirname =\n            if partial_relative_folder == '.' # The partial is in the same folder as the HTML file\n              view_file_folder\n            else\n              File.join(view_file_folder, partial_relative_folder)\n            end",
        "comment": "Note: We only search for partials with depth 1. We don't do recursive search, as it is probably not necessary for a first iteration.",
        "label": "How-to-use",
        "id": "8104"
    },
    {
        "raw_code": "def mb_chars\n    ActiveSupport.deprecator.warn(\n      \"String#mb_chars is deprecated and will be removed in Rails 8.2. \" \\\n      \"Use normal string methods instead.\"\n    )\n\n    if ActiveSupport::Multibyte.proxy_class == ActiveSupport::Multibyte::Chars\n      ActiveSupport::Multibyte::Chars.new(self, deprecation: false)\n    else\n      ActiveSupport::Multibyte.proxy_class.new(self)\n    end",
        "comment": "== Multibyte proxy  +mb_chars+ is a multibyte safe proxy for string methods.  It creates and returns an instance of the ActiveSupport::Multibyte::Chars class which encapsulates the original string. A Unicode safe version of all the String methods are defined on this proxy class. If the proxy class doesn't respond to a certain method, it's forwarded to the encapsulated string.  >> \"\u01c9\".mb_chars.upcase.to_s # => \"\u01c7\"  NOTE: Ruby 2.4 and later support native Unicode case mappings:  >> \"\u01c9\".upcase # => \"\u01c7\"  == \\Method chaining  All the methods on the Chars proxy which normally return a string will return a Chars object. This allows method chaining on the result of any of these methods.  name.mb_chars.reverse.length # => 12  == Interoperability and configuration  The Chars object tries to be as interchangeable with String objects as possible: sorting and comparing between String and Char work like expected. The bang! methods change the internal string representation in the Chars object. Interoperability problems can be resolved easily with a +to_s+ call.  For more information about the methods defined on the Chars proxy see ActiveSupport::Multibyte::Chars. For information about how to change the default Multibyte behavior see ActiveSupport::Multibyte.",
        "label": "How-to-use",
        "id": "14380"
    },
    {
        "raw_code": "def stop(notification)\n          return log(:warn, \"Missing run_type, skipping metrics export!\") unless run_type\n\n          parse_execution_data(notification.examples)\n\n          export_test_metrics\n          save_test_metrics\n        end",
        "comment": "Finish test execution  @param [RSpec::Core::Notifications::ExamplesNotification] notification @return [void]",
        "label": "How-to-use",
        "id": "4615"
    },
    {
        "raw_code": "def diff(from, to, options = {}, *paths)\n        iterator = gitaly_commit_client.diff(from, to, options.merge(paths: paths))\n\n        Gitlab::Git::DiffCollection.new(iterator, options)\n      end",
        "comment": "Return an array of Diff objects that represent the diff between +from+ and +to+.  See Diff::filter_diff_options for the allowed diff options.  The +options+ hash can also include :break_rewrites to split larger rewrites into delete/add pairs.",
        "label": "How-to-use",
        "id": "2637"
    },
    {
        "raw_code": "def click_on_prometheus_integration\n            click_element('prometheus-link')\n          end",
        "comment": "rubocop:enable QA/ElementWithPattern",
        "label": "How-to-use",
        "id": "4264"
    },
    {
        "raw_code": "def set_callback(name, *filter_list, &block)\n        options = filter_list.extract_options!\n        filter_list << options\n\n        if name.in?([:commit, :rollback]) && options[:on]\n          fire_on = Array(options[:on])\n          assert_valid_transaction_action(fire_on)\n          options[:if] = [\n            -> { transaction_include_any_action?(fire_on) },\n            *options[:if]\n          ]\n        end",
        "comment": "Similar to ActiveSupport::Callbacks::ClassMethods#set_callback, but with support for options available on #after_commit and #after_rollback callbacks.",
        "label": "How-to-use",
        "id": "12726"
    },
    {
        "raw_code": "def each_batch_count(of: 1000, column: :id, last_count: 0, last_value: nil)\n      arel_table = self.arel_table\n      window = Arel::Nodes::Window.new.order(arel_table[column])\n      last_value_column = Arel::Nodes::NamedFunction\n        .new('LAST_VALUE', [arel_table[column]])\n        .over(window)\n        .as(column.to_s)\n\n      loop do\n        count_column = Arel::Nodes::Addition\n          .new(Arel::Nodes::NamedFunction.new('ROW_NUMBER', []).over(window), last_count)\n          .as('count')\n\n        projections = [count_column, last_value_column]\n        scope = limit(1).offset(of - 1)\n        scope = scope.where(arel_table[column].gt(last_value)) if last_value\n        new_count, last_value = scope.pick(*projections)\n\n        # When reaching the last batch the offset query might return no data, to address this\n        # problem, we invoke a specialized query that takes the last row out of the resultset.\n        # We could do this for each batch, however it would add unnecessary overhead to all\n        # queries.\n        if new_count.nil?\n          inner_query = scope\n            .select(*projections)\n            .limit(nil)\n            .offset(nil)\n            .arel\n            .as(quoted_table_name)\n\n          new_count, last_value =\n            unscoped\n            .from(inner_query)\n            .unscope(where: :type)\n            .order(count: :desc)\n            .limit(1)\n            .pick(:count, column)\n\n          last_count = new_count if new_count\n          last_value = nil\n          break\n        end",
        "comment": "Iterates over the relation and counts the rows. The counting logic is combined with the iteration query which saves one query compared to a standard each_batch approach.  Basic usage: count, _last_value = Project.each_batch_count  The counting can be stopped by passing a block and making the last statement true. Example:  query_count = 0 count, last_value = Project.each_batch_count do query_count += 1 query_count == 5 # stop counting after 5 loops end  Resume where the previous counting has stopped:  count, last_value = Project.each_batch_count(last_count: count, last_value: last_value)  Another example, counting issues in project:  project = Project.find(1) count, _ = project.issues.each_batch_count(column: :iid)",
        "label": "How-to-use",
        "id": "7353"
    },
    {
        "raw_code": "def mark_as_recursive_call\n      @recursive_call = true\n    end",
        "comment": "We use this to mark recursive calls made to this service from within the same service. We do this so as to help us run some tasks that needs to be run only once per hierarchy, and not recursively.",
        "label": "How-to-use",
        "id": "6111"
    },
    {
        "raw_code": "def supervise(pid_or_pids, &on_process_death)\n      @pids = Array(pid_or_pids).to_set\n      @on_process_death = on_process_death\n\n      trap_signals!\n\n      start\n    end",
        "comment": "Starts a supervision loop for the given process ID(s).  If any or all processes go away, the IDs of any dead processes will be yielded to the given block, so callers can act on them.  If the block returns a non-empty list of IDs, the supervisor will start observing those processes instead. Otherwise it will shut down.",
        "label": "How-to-use",
        "id": "1345"
    },
    {
        "raw_code": "def auto_merge?\n        (mr_iid && approver_user_valid?).tap do |auto_merge|\n          logger.warn(\"Auto merge will not be performed!\") unless auto_merge\n        end",
        "comment": "Attempt to automatically merge created mr  @return [Boolean]",
        "label": "How-to-use",
        "id": "4716"
    },
    {
        "raw_code": "def tag_commit(tag_name)\n      link = url_helpers.project_tag_path(project, id: tag_name)\n      body = \"tagged commit #{noteable.sha} to [`#{tag_name}`](#{link})\"\n\n      create_note(NoteSummary.new(noteable, project, author, body, action: 'tag'))\n    end",
        "comment": "Called when a commit was tagged  tag_name  - The created tag name  Returns the created Note object",
        "label": "How-to-use",
        "id": "5604"
    },
    {
        "raw_code": "def to_sql(arel_or_sql_string, binds = [])\n        sql, _ = to_sql_and_binds(arel_or_sql_string, binds)\n        sql\n      end",
        "comment": "Converts an arel AST to SQL",
        "label": "How-to-use",
        "id": "13050"
    },
    {
        "raw_code": "def enqueue_to_in(queue, interval, klass, *args)\n        int = interval.to_f\n        now = Time.now.to_f\n        ts = ((int < 1_000_000_000) ? now + int : int)\n\n        item = {\"class\" => klass, \"args\" => args, \"at\" => ts, \"queue\" => queue}\n        item.delete(\"at\") if ts <= now\n\n        klass.client_push(item)\n      end",
        "comment": "Example usage: Sidekiq::Client.enqueue_to_in(:queue_name, 3.minutes, MyJob, 'foo', 1, :bat => 'bar') ",
        "label": "How-to-use",
        "id": "5098"
    },
    {
        "raw_code": "def on_new_investigation\n          super\n\n          return if self.class.feature_flags_already_tracked\n\n          self.class.feature_flags_already_tracked = true\n        end",
        "comment": "Called before all on_... have been called When refining this method, always call `super`",
        "label": "How-to-use",
        "id": "3905"
    },
    {
        "raw_code": "def placeholder_record\n          model.new(reflection.active_record_primary_key => 0)\n        end",
        "comment": "This will only work for HasMany and HasOne associations for now",
        "label": "How-to-use",
        "id": "2103"
    },
    {
        "raw_code": "def self.wrap(**kwargs)\n      return yield if active?\n\n      executor.wrap(**kwargs) do\n        instance = run!\n        begin\n          yield\n        ensure\n          instance.complete!\n        end",
        "comment": "Run the supplied block as a work unit, reloading code as needed",
        "label": "How-to-use",
        "id": "13933"
    },
    {
        "raw_code": "def to_fs(format = :default)\n    if formatter = DATE_FORMATS[format]\n      formatter.respond_to?(:call) ? formatter.call(self).to_s : strftime(formatter)\n    else\n      to_s\n    end",
        "comment": "Converts to a formatted string. See DATE_FORMATS for built-in formats.  This method is aliased to <tt>to_formatted_s</tt>.  time = Time.now                    # => 2007-01-18 06:10:17 -06:00  time.to_fs(:time)                  # => \"06:10\" time.to_formatted_s(:time)         # => \"06:10\"  time.to_fs(:db)           # => \"2007-01-18 06:10:17\" time.to_fs(:number)       # => \"20070118061017\" time.to_fs(:short)        # => \"18 Jan 06:10\" time.to_fs(:long)         # => \"January 18, 2007 06:10\" time.to_fs(:long_ordinal) # => \"January 18th, 2007 06:10\" time.to_fs(:rfc822)       # => \"Thu, 18 Jan 2007 06:10:17 -0600\" time.to_fs(:rfc2822)       # => \"Thu, 18 Jan 2007 06:10:17 -0600\" time.to_fs(:iso8601)      # => \"2007-01-18T06:10:17-06:00\"  == Adding your own time formats to +to_fs+ You can add your own formats to the Time::DATE_FORMATS hash. Use the format name as the hash key and either a strftime string or Proc instance that takes a time argument as the value.  # config/initializers/time_formats.rb Time::DATE_FORMATS[:month_and_year] = '%B %Y' Time::DATE_FORMATS[:short_ordinal]  = ->(time) { time.strftime(\"%B #{time.day.ordinalize}\") }",
        "label": "How-to-use",
        "id": "14416"
    },
    {
        "raw_code": "def run!(*args)\n        if settings.reloader?\n          super unless running?\n        else\n          super\n        end",
        "comment": "Protects Sinatra::Base.run! from being called more than once.",
        "label": "How-to-use",
        "id": "8637"
    },
    {
        "raw_code": "def s(*args)\n        type = Symbol === args.first ? args.shift : :list\n        opts = Hash === args.last ? args.pop : {}\n        AstNode.node_class_for(type).new(type, args, opts)\n      end",
        "comment": "Builds and s-expression by creating {AstNode} objects with the type provided by the first argument.  @example An implicit list of keywords ast = s(s(:kw, \"if\"), s(:kw, \"else\")) ast.type # => :list @example A method call s(:command, s(:var_ref, \"mymethod\"))  @overload s(*nodes, opts = {}) @param [Array<AstNode>] nodes a list of nodes. @param [Hash] opts any extra options (docstring, file, source) to set on the object @return [AstNode] an implicit node where node.type == +:list+ @overload s(type, *children, opts = {}) @param [Symbol] type the node type @param [Array<AstNode>] children any child nodes inside this one @param [Hash] opts any extra options to set on the object @return [AstNode] a node of type +type+. @see AstNode#initialize",
        "label": "How-to-use",
        "id": "299"
    },
    {
        "raw_code": "def self.model_path_segment(model)\n    case model\n    when Storage::Hashed then model.disk_path\n    else\n      model.hashed_storage?(:attachments) ? model.disk_path : model.full_path\n    end",
        "comment": "Returns the part of `store_dir` that can change based on the model's current path  This is used to build Upload paths dynamically based on the model's current namespace and path, allowing us to ignore renames or transfers.  model - Object that responds to `full_path` and `disk_path`  Returns a String without a trailing slash",
        "label": "How-to-use",
        "id": "8066"
    },
    {
        "raw_code": "def preload\n    nil\n  end",
        "comment": "Override to specify preloads for each query",
        "label": "How-to-use",
        "id": "6180"
    },
    {
        "raw_code": "def self.build_expression(search:, rules:)\n        return EXPRESSION_ON_INVALID_INPUT if search.blank? || rules.empty?\n\n        quoted_search = ApplicationRecord.connection.quote(search.to_s)\n\n        first_expression, *expressions = rules.map do |rule|\n          rule_to_arel(quoted_search, rule)\n        end",
        "comment": "This method returns an Arel expression that can be used in an ActiveRecord query to order the resultset by similarity.  Note: Calculating similarity score for large volume of records is inefficient. use SimilarityScore only for smaller resultset which is already filtered by other conditions (< 10_000 records).  ==== Parameters * +search+ - [String] the user provided search string * +rules+ - [{ column: COLUMN, multiplier: 1 }, { column: COLUMN_2, multiplier: 0.5 }] rules for the scoring. * +column+ - Arel column expression, example: Project.arel_table[\"name\"] * +multiplier+ - Integer or Float to increase or decrease the score (optional, defaults to 1)  ==== Use case  We'd like to search for projects by path, name and description. We want to rank higher the path and name matches, since it's more likely that the user was remembering the path or the name of the project.  Rules: [ { column: Project.arel_table['path'], multiplier: 1 }, { column: Project.arel_table['name'], multiplier: 1 }, { column: Project.arel_table['description'], multiplier: 0.5 } ]  ==== Examples  Similarity calculation based on one column:  Gitlab::Database::SimilarityScore.build_expession(search: 'my input', rules: [{ column: Project.arel_table['name'] }])  Similarity calculation based on two column, where the second column has lower priority:  Gitlab::Database::SimilarityScore.build_expession(search: 'my input', rules: [ { column: Project.arel_table['name'], multiplier: 1 }, { column: Project.arel_table['description'], multiplier: 0.5 } ])  Integration with an ActiveRecord query:  table = Project.arel_table  order_expression = Gitlab::Database::SimilarityScore.build_expession(search: 'input', rules: [ { column: table['name'], multiplier: 1 }, { column: table['description'], multiplier: 0.5 } ])  Project.where(\"name LIKE ?\", '%' + 'input' + '%').order(order_expression.desc)  The expression can be also used in SELECT:  results = Project.select(order_expression.as('similarity')).where(\"name LIKE ?\", '%' + 'input' + '%').order(similarity: :desc) puts results.map(&:similarity) ",
        "label": "Property",
        "id": "3016"
    },
    {
        "raw_code": "def partition_names\n        Array.new(@number_of_partitions) do |i|\n          generate_partition_name(i)\n        end",
        "comment": "Returns list of all partition names for this collection",
        "label": "Property",
        "id": "1118"
    },
    {
        "raw_code": "def commit_person_link(commit, options = {})\n    user = commit.public_send(options[:source]) # rubocop:disable GitlabSecurity/PublicSend\n\n    source_name = clean(commit.public_send(:\"#{options[:source]}_name\")) # rubocop:disable GitlabSecurity/PublicSend\n    source_email = clean(commit.public_send(:\"#{options[:source]}_email\")) # rubocop:disable GitlabSecurity/PublicSend\n\n    person_name = user.try(:name) || source_name\n\n    text =\n      if options[:avatar]\n        content_tag(:span, person_name, class: \"commit-#{options[:source]}-name\")\n      else\n        person_name\n      end",
        "comment": "Private: Returns a link to a person. If the person has a matching user and is a member of the current @project it will link to the team member page. Otherwise it will link to the person email as specified in the commit.  options: source: one of :author or :committer avatar: true will prepend the avatar image size:   size of the avatar image in px",
        "label": "Property",
        "id": "7758"
    },
    {
        "raw_code": "def name_regexp(name)\n    klass, type, name = parse_name name\n\n    case type\n    when '#', '::' then\n      /^#{klass}#{type}#{Regexp.escape name}$/\n    else\n      /^#{klass}(#|::)#{Regexp.escape name}$/\n    end",
        "comment": " Returns a regular expression for +name+ that will match an RDoc::AnyMethod's name.",
        "label": "Property",
        "id": "16614"
    },
    {
        "raw_code": "def extract_domain(host, tld_length)\n          extract_domain_from(host, tld_length) if named_host?(host)\n        end",
        "comment": "Returns the domain part of a host given the domain level.  # Top-level domain example extract_domain('www.example.com', 1) # => \"example.com\" # Second-level domain example extract_domain('dev.www.example.co.uk', 2) # => \"example.co.uk\"",
        "label": "Property",
        "id": "11493"
    },
    {
        "raw_code": "def assert_enqueued_email_with(mailer, method, params: nil, args: nil, queue: nil, &block)\n      if mailer.is_a? ActionMailer::Parameterized::Mailer\n        params = mailer.instance_variable_get(:@params)\n        mailer = mailer.instance_variable_get(:@mailer)\n      end",
        "comment": "Asserts that a specific email has been enqueued, optionally matching arguments and/or params.  def test_email ContactMailer.welcome.deliver_later assert_enqueued_email_with ContactMailer, :welcome end  def test_email_with_parameters ContactMailer.with(greeting: \"Hello\").welcome.deliver_later assert_enqueued_email_with ContactMailer, :welcome, args: { greeting: \"Hello\" } end  def test_email_with_arguments ContactMailer.welcome(\"Hello\", \"Goodbye\").deliver_later assert_enqueued_email_with ContactMailer, :welcome, args: [\"Hello\", \"Goodbye\"] end  def test_email_with_named_arguments ContactMailer.welcome(greeting: \"Hello\", farewell: \"Goodbye\").deliver_later assert_enqueued_email_with ContactMailer, :welcome, args: [{ greeting: \"Hello\", farewell: \"Goodbye\" }] end  def test_email_with_parameters_and_arguments ContactMailer.with(greeting: \"Hello\").welcome(\"Cheers\", \"Goodbye\").deliver_later assert_enqueued_email_with ContactMailer, :welcome, params: { greeting: \"Hello\" }, args: [\"Cheers\", \"Goodbye\"] end  def test_email_with_parameters_and_named_arguments ContactMailer.with(greeting: \"Hello\").welcome(farewell: \"Goodbye\").deliver_later assert_enqueued_email_with ContactMailer, :welcome, params: { greeting: \"Hello\" }, args: [{farewell: \"Goodbye\"}] end  def test_email_with_parameterized_mailer ContactMailer.with(greeting: \"Hello\").welcome.deliver_later assert_enqueued_email_with ContactMailer.with(greeting: \"Hello\"), :welcome end  def test_email_with_matchers ContactMailer.with(greeting: \"Hello\").welcome(\"Cheers\", \"Goodbye\").deliver_later assert_enqueued_email_with ContactMailer, :welcome, params: ->(params) { /hello/i.match?(params[:greeting]) }, args: ->(args) { /cheers/i.match?(args[0]) } end  If a block is passed, that block should cause the specified email to be enqueued.  def test_email_in_block assert_enqueued_email_with ContactMailer, :welcome do ContactMailer.welcome.deliver_later end end  If +args+ is provided as a Hash, a parameterized email is matched.  def test_parameterized_email assert_enqueued_email_with ContactMailer, :welcome, args: {email: 'user@example.com'} do ContactMailer.with(email: 'user@example.com').welcome.deliver_later end end",
        "label": "Property",
        "id": "11168"
    },
    {
        "raw_code": "def event\n      ActiveSupport.event_reporter\n    end",
        "comment": "Returns the ActiveSupport::EventReporter of the current \\Rails project, otherwise it returns +nil+ if there is no project.  Rails.event.notify(\"my_event\", { message: \"Hello, world!\" })",
        "label": "Property",
        "id": "14622"
    },
    {
        "raw_code": "def ssh_info\n        # If the VM is not running that we can't possibly SSH into it\n        return nil if state.id != :running\n\n        # Return what we know. The host is always \"127.0.0.1\" because\n        # VirtualBox VMs are always local. The port we try to discover\n        # by reading the forwarded ports.\n        return {\n          host: \"127.0.0.1\",\n          port: @driver.ssh_port(@machine.config.ssh.guest_port)\n        }\n      end",
        "comment": "Returns the SSH info for accessing the VirtualBox VM.",
        "label": "Property",
        "id": "9529"
    },
    {
        "raw_code": "def order_by_without_table_references\n            order.column_definitions.each_with_index.map do |column_definition, i|\n              \"#{i + 1} #{column_definition.order_direction_as_sql_string}\"\n            end.join(\", \")\n          end",
        "comment": "Generates an ORDER BY clause by using the column position index and the original order clauses. This method is used to sort the collected arrays in SQL. Example: \"issues\".created_at DESC , \"issues\".id ASC => 1 DESC, 2 ASC",
        "label": "Property",
        "id": "2023"
    },
    {
        "raw_code": "def disabled\n          if defined\n            pastel.bold(format_help(\"(already defined)\"))\n          elsif !supported\n            pastel.bold(format_help(\"(#{identifier.value} unavailable)\"))\n          end",
        "comment": "Returns the string to include at the end of disabled menu items. Nil if menu item shouldn't be disabled",
        "label": "Property",
        "id": "5370"
    },
    {
        "raw_code": "def select_minute(datetime, options = {}, html_options = {})\n        DateTimeSelector.new(datetime, options, html_options).select_minute\n      end",
        "comment": "Returns a select tag with options for each of the minutes 0 through 59 with the current minute selected. Also can return a select tag with options by <tt>minute_step</tt> from 0 through 59 with the 00 minute selected. The <tt>datetime</tt> can be either a +Time+ or +DateTime+ object or an integer. Override the field name using the <tt>:field_name</tt> option, 'minute' by default.  my_time = Time.now + 10.minutes  # Generates a select field for minutes that defaults to the minutes for the time in my_time. select_minute(my_time)  # Generates a select field for minutes that defaults to the number given. select_minute(14)  # Generates a select field for minutes that defaults to the minutes for the time in my_time # that is named 'moment' rather than 'minute'. select_minute(my_time, field_name: 'moment')  # Generates a select field for minutes with a custom prompt. Use <tt>prompt: true</tt> for a # generic prompt. select_minute(14, prompt: 'Choose minutes')",
        "label": "Property",
        "id": "11834"
    },
    {
        "raw_code": "def method_symbol\n      HTTP_METHOD_LOOKUP[method]\n    end",
        "comment": "Returns a symbol form of the #method.",
        "label": "Property",
        "id": "11452"
    },
    {
        "raw_code": "def parallelize_teardown(&block)\n        ActiveSupport::Testing::Parallelization.run_cleanup_hook(&block)\n      end",
        "comment": "Clean up hook for parallel testing. This can be used to drop databases if your app uses multiple write/read databases or other clean up before the tests finish. This runs before the forked process is closed.  Note: this feature is not available with the threaded parallelization.  In your +test_helper.rb+ add the following:  class ActiveSupport::TestCase parallelize_teardown do # drop databases end end",
        "label": "Property",
        "id": "13954"
    },
    {
        "raw_code": "def read_attribute_for_database(attr_name)\n        name = attr_name.to_s\n        name = self.class.attribute_aliases[name] || name\n\n        attribute_for_database(name)\n      end",
        "comment": "Returns the value of the attribute identified by +attr_name+ after serialization.  class Book < ActiveRecord::Base enum :status, { draft: 1, published: 2 } end  book = Book.new(status: \"published\") book.read_attribute(:status)              # => \"published\" book.read_attribute_for_database(:status) # => 2",
        "label": "Property",
        "id": "12828"
    },
    {
        "raw_code": "def _HtmlBlockClosePre\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockClosePre = \"<\" Spnl \"/\" (\"pre\" | \"PRE\") Spnl \">\"",
        "label": "Property",
        "id": "15684"
    },
    {
        "raw_code": "def attributes_for_create(attribute_names)\n        attribute_names &= self.class.column_names\n        attribute_names.delete_if do |name|\n          (pk_attribute?(name) && id.nil?) ||\n            column_for_attribute(name).virtual?\n        end",
        "comment": "Filters out the virtual columns and also primary keys, from the attribute names, when the primary key is to be generated (e.g. the id attribute has no value).",
        "label": "Property",
        "id": "12375"
    },
    {
        "raw_code": "def self.safe_chdir(dir)\n        lock = @@chdir_lock\n\n        begin\n          @@chdir_lock.synchronize {}\n        rescue ThreadError\n          # If we already hold the lock, just create a new lock so we\n          # definitely don't block and don't get an error.\n          lock = Mutex.new\n        end",
        "comment": "Safely changes directory of this process by putting a lock around it so that it is thread safe. This will yield a block and when the block exits it changes back to the original directory.  @param [String] dir Dir to change to temporarily",
        "label": "Property",
        "id": "9236"
    },
    {
        "raw_code": "def self.has_database?(database_name)\n      db_config = ::Gitlab::Database.database_base_models[database_name]&.connection_db_config\n      db_config.present? && db_config_share_with(db_config).nil?\n    end",
        "comment": "Database configured. Returns false if the database is shared",
        "label": "Property",
        "id": "1450"
    },
    {
        "raw_code": "def to(position)\n    position += size if position < 0\n    self[0, position + 1] || +\"\"\n  end",
        "comment": "Returns a substring from the beginning of the string to the given position. If the position is negative, it is counted from the end of the string.  str = \"hello\" str.to(0)  # => \"h\" str.to(3)  # => \"hell\" str.to(-2) # => \"hell\"  You can mix it with +from+ method and do fun things like:  str = \"hello\" str.from(0).to(-1) # => \"hello\" str.from(1).to(-2) # => \"ell\"",
        "label": "Property",
        "id": "14345"
    },
    {
        "raw_code": "def distinct(value = true)\n      spawn.distinct!(value)\n    end",
        "comment": "Specifies whether the records should be unique or not. For example:  User.select(:name) # Might return two records with the same name  User.select(:name).distinct # Returns 1 record per distinct name  User.select(:name).distinct.distinct(false) # You can also remove the uniqueness",
        "label": "Property",
        "id": "13427"
    },
    {
        "raw_code": "def before?(date_or_time)\n      self < date_or_time\n    end",
        "comment": "Returns true if the date/time falls before <tt>date_or_time</tt>.",
        "label": "Property",
        "id": "14139"
    },
    {
        "raw_code": "def workhorse_authorize(\n        has_length:,\n        maximum_size: nil,\n        use_final_store_path: false,\n        final_store_path_config: {})\n        {}.tap do |hash|\n          if self.direct_upload_to_object_store?\n            hash[:RemoteObject] = workhorse_remote_upload_options(\n              has_length: has_length,\n              maximum_size: maximum_size,\n              use_final_store_path: use_final_store_path,\n              final_store_path_config: final_store_path_config\n            )\n          else\n            hash[:TempPath] = workhorse_local_upload_path\n          end",
        "comment": "final_store_path_config is only used if use_final_store_path is set to true Two keys are available: - :root_hash. The root hash used in Gitlab::HashedPath for the path generation. - :override_path. If set, the path generation is skipped and this value is used instead. Make sure that this value is unique for each upload.",
        "label": "Property",
        "id": "8040"
    },
    {
        "raw_code": "def clear_multiple(raw_keys)\n          return [] if raw_keys.empty?\n\n          keys = raw_keys.map { |id| cache_key_for(id) }\n\n          with_redis do |redis|\n            Gitlab::Instrumentation::RedisClusterValidator.allow_cross_slot_commands do\n              if Gitlab::Redis::ClusterUtil.cluster?(redis)\n                Gitlab::Redis::ClusterUtil.batch_unlink(keys, redis)\n              else\n                redis.del(keys)\n              end",
        "comment": "Clears multiple cache keys at once.  raw_keys - An Array of unique cache keys, without namespaces.  It returns the number of cache keys cleared. Ex.: 42",
        "label": "Property",
        "id": "1831"
    },
    {
        "raw_code": "def months_since(months)\n      advance(months: months)\n    end",
        "comment": "Returns a new date/time the specified number of months in the future.",
        "label": "Property",
        "id": "14146"
    },
    {
        "raw_code": "def _RefTitle\n\n    _save = self.pos\n    while true # choice\n      _tmp = apply(:_RefTitleSingle)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_RefTitleDouble)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_RefTitleParens)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_EmptyTitle)\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_RefTitle unless _tmp\n    return _tmp\n  end",
        "comment": "RefTitle = (RefTitleSingle | RefTitleDouble | RefTitleParens | EmptyTitle)",
        "label": "Property",
        "id": "15779"
    },
    {
        "raw_code": "def self.snapshot_list(machine)\n        return [] if machine.id.nil?\n        machine.provider.driver.list_snapshots(machine.id)\n      end",
        "comment": "Returns a list of the snapshots that are taken on this machine.  @return [Array<String>] Snapshot Name",
        "label": "Property",
        "id": "9551"
    },
    {
        "raw_code": "def self.slow_requests!\n        @@slow_requests.value = true\n      end",
        "comment": "Slows down incoming requests (useful for race conditions).",
        "label": "Property",
        "id": "2744"
    },
    {
        "raw_code": "def read_storage_controllers\n          vm_info = show_vm_info\n          count = vm_info.count { |key, value| key.match(/^storagecontrollername\\d+$/) }\n          all_disks = list_hdds\n\n          storage_controllers = Model::StorageControllerArray.new\n\n          (0..count - 1).each do |n|\n            # basic controller metadata\n            name = vm_info[\"storagecontrollername#{n}\"]\n            type = vm_info[\"storagecontrollertype#{n}\"]\n            maxportcount = vm_info[\"storagecontrollermaxportcount#{n}\"].to_i\n\n            # build attachments array\n            attachments = []\n            vm_info.each do |k, v|\n              if /^#{name}-ImageUUID-(\\d+)-(\\d+)$/ =~ k\n                port = $1.to_s\n                device = $2.to_s\n                uuid = v\n                location = vm_info[\"#{name}-#{port}-#{device}\"]\n\n                extra_disk_data = all_disks.detect { |d| d[\"UUID\"] == uuid }\n\n                attachment = { port: port,\n                               device: device,\n                               uuid: uuid,\n                               location: location }\n\n                extra_disk_data&.each do |dk,dv|\n                  # NOTE: We convert the keys from VirtualBox to symbols\n                  # to be consistent with the other keys\n                  attachment[dk.downcase.gsub(' ', '_').to_sym] = dv\n                end",
        "comment": "Helper method to get a list of storage controllers added to the current VM  @return [VagrantPlugins::ProviderVirtualBox::Model::StorageControllerArray]",
        "label": "Property",
        "id": "9617"
    },
    {
        "raw_code": "def self.version\n    gem_version\n  end",
        "comment": "Returns the currently loaded version of Action Mailer as a +Gem::Version+.",
        "label": "Property",
        "id": "11172"
    },
    {
        "raw_code": "def prepare_attributes\n          attributes\n        end",
        "comment": "attributes wrapped in a method to be adjusted in sub-class if needed",
        "label": "Property",
        "id": "2834"
    },
    {
        "raw_code": "def in_graphql_directory?(node, directory)\n      in_app_directory?(node, \"graphql/#{directory}\") ||\n        in_app_directory?(node, \"graphql/ee/#{directory}\")\n    end",
        "comment": "Returns true if the given node resides in app/graphql/{directory}, ee/app/graphql/{directory}, or ee/app/graphql/ee/{directory}.",
        "label": "Property",
        "id": "3895"
    },
    {
        "raw_code": "def tidy_bytes(string, force = false)\n        return string if string.empty? || string.ascii_only?\n        return recode_windows1252_chars(string) if force\n        string.scrub { |bad| recode_windows1252_chars(bad) }\n      end",
        "comment": "Replaces all ISO-8859-1 or CP1252 characters by their UTF-8 equivalent resulting in a valid UTF-8 string.  Passing +true+ will forcibly tidy all bytes, assuming that the string's encoding is entirely CP1252 or ISO-8859-1.",
        "label": "Property",
        "id": "14505"
    },
    {
        "raw_code": "def get_controller(name)\n          controller = detect { |c| c.name == name }\n          if !controller\n            raise Vagrant::Errors::VirtualBoxDisksControllerNotFound, name: name\n          end",
        "comment": "Returns a storage controller with the given name. Raises an exception if a matching controller can't be found.  @param [String] name - The name of the storage controller @return [VagrantPlugins::ProviderVirtualBox::Model::StorageController]",
        "label": "Property",
        "id": "9654"
    },
    {
        "raw_code": "def self.raw_path(system, site, home, gems, *extra_dirs)\n    path = []\n\n    each(system, site, home, gems, *extra_dirs) do |dir, type|\n      path << dir\n    end",
        "comment": " Returns selected documentation directories including nonexistent directories.  See also ::each",
        "label": "Property",
        "id": "16563"
    },
    {
        "raw_code": "def resolve(name, text)\n    return @seen[name] if @seen.include? name\n\n    ref = case name\n          when /^\\\\(#{CLASS_REGEXP_STR})$/o then\n            @context.find_symbol $1\n          else\n            @context.find_symbol name\n          end",
        "comment": " Returns a reference to +name+.  If the reference is found and +name+ is not documented +text+ will be returned.  If +name+ is escaped +name+ is returned.  If +name+ is not found +text+ is returned.",
        "label": "Property",
        "id": "15514"
    },
    {
        "raw_code": "def not_found_response\n        go_help_page_url = Rails.application.routes.url_helpers.help_page_url('user/project/use_project_as_go_package.md')\n        not_found_message = \"Go package not found or access denied. If you are trying to access a private project, ensure your ~/.netrc file has credentials so the go toolchain can authenticate. See #{go_help_page_url} for details.\"\n\n        [404, { 'Content-Type' => 'text/plain' }, [not_found_message]]\n      end",
        "comment": "not_found_response returns a message that the go cli toolchain displays directly.",
        "label": "Property",
        "id": "2034"
    },
    {
        "raw_code": "def commit_status\n      GenericCommitStatus.new(\n        user: build.user,\n        ci_stage: stage,\n        name: 'pages:deploy',\n        stage_idx: stage.position\n      )\n    end",
        "comment": "Create status notifying the deployment of pages",
        "label": "Property",
        "id": "5922"
    },
    {
        "raw_code": "def run_generator(args = default_arguments, config = {})\n          args += [\"--skip-bundle\"] unless args.include?(\"--no-skip-bundle\") || args.include?(\"--dev\")\n          args += [\"--skip-bootsnap\"] unless args.include?(\"--no-skip-bootsnap\") || args.include?(\"--skip-bootsnap\")\n\n          if ENV[\"RAILS_LOG_TO_STDOUT\"] == \"true\"\n            generator_class.start(args, config.reverse_merge(destination_root: destination_root))\n          else\n            capture(:stdout) do\n              generator_class.start(args, config.reverse_merge(destination_root: destination_root))\n            end",
        "comment": "Runs the generator configured for this class. The first argument is an array like command line arguments:  class AppGeneratorTest < Rails::Generators::TestCase tests AppGenerator destination File.expand_path(\"../tmp\", __dir__) setup :prepare_destination  test \"database.yml is not created when skipping Active Record\" do run_generator %w(myapp --skip-active-record) assert_no_file \"config/database.yml\" end end  You can provide a configuration hash as second argument. This method returns the output printed by the generator.",
        "label": "Property",
        "id": "14802"
    },
    {
        "raw_code": "def remove_dhcp_server(network_name)\n        end",
        "comment": "Removes the DHCP server identified by the provided network name.  @param [String] network_name The the full network name associated with the DHCP server to be removed, e.g. \"HostInterfaceNetworking-vboxnet0\"",
        "label": "Property",
        "id": "9591"
    },
    {
        "raw_code": "def self.responder_for(build)\n        response_url = build.pipeline.chat_data&.response_url\n        return unless response_url\n\n        if response_url.start_with?('https://hooks.slack.com/')\n          Gitlab::Chat::Responder::Slack.new(build)\n        else\n          Gitlab::Chat::Responder::Mattermost.new(build)\n        end",
        "comment": "Returns an instance of the responder to use for generating chat responses.  This method will return `nil` if no formatter is available for the given build.  build - A `Ci::Build` that executed a chat command.",
        "label": "Property",
        "id": "2435"
    },
    {
        "raw_code": "def next_token # :nodoc:\n  # preprocessing\n  # if it is not in RD part\n  # => method\n  while @in_part != \"rd\"\n    line = @src[@i]\n    @i += 1 # next line\n\n    case line\n    # src end\n    when false\n      return [false, false]\n    # RD part begin\n    when /^=begin\\s*(?:\\bRD\\b.*)?\\s*$/\n      if @in_part # if in non-RD part\n        @part_content.push(line)\n      else\n        @in_part = \"rd\"\n        return [:WHITELINE, \"=begin\\n\"] # <= for textblockand\n      end",
        "comment": " Returns the next token from the document",
        "label": "Property",
        "id": "16505"
    },
    {
        "raw_code": "def author_id_for(object, author_key: :author)\n        user_info = case author_key\n                    when :actor\n                      object[:actor]\n                    when :review_requester\n                      object[:review_requester]\n                    else\n                      object ? object[:author] : nil\n                    end",
        "comment": "Returns the GitLab user ID of an object's author.  If the object has no author ID we'll use the ID of the GitLab ghost user. object - An instance of `Hash` or a `Github::Representer`",
        "label": "Property",
        "id": "2143"
    },
    {
        "raw_code": "def registered; @@registered; end\n      end",
        "comment": "Helper method to get access to the class variable. This is mostly exposed for tests. This shouldn't be mucked with directly, since it's structure may change at any time.",
        "label": "Property",
        "id": "9286"
    },
    {
        "raw_code": "def down\n    remove_column :ssh_signatures, :author_email if column_exists?(:ssh_signatures, :author_email)\n  end",
        "comment": "rubocop:enable Migration/AddLimitToTextColumns",
        "label": "Property",
        "id": "5019"
    },
    {
        "raw_code": "def network(type, **options)\n        options = options.dup\n        options[:protocol] ||= \"tcp\"\n\n        # Convert to symbol to allow strings\n        type = type.to_sym\n\n        if !options[:id]\n          default_id = nil\n\n          if type == :forwarded_port\n            # For forwarded ports, set the default ID to be the\n            # concat of host_ip, proto and host_port. This would ensure Vagrant\n            # caters for port forwarding in an IP aliased environment where\n            # different host IP addresses are to be listened on the same port.\n            default_id = \"#{options[:host_ip]}#{options[:protocol]}#{options[:host]}\"\n          end",
        "comment": "Define a way to access the machine via a network. This exposes a high-level abstraction for networking that may not directly map 1-to-1 for every provider. For example, AWS has no equivalent to \"port forwarding.\" But most providers will attempt to implement this in a way that behaves similarly.  `type` can be one of:  * `:forwarded_port` - A port that is accessible via localhost that forwards into the machine. * `:private_network` - The machine gets an IP that is not directly publicly accessible, but ideally accessible from this machine. * `:public_network` - The machine gets an IP on a shared network.  @param [Symbol] type Type of network @param [Hash] options Options for the network.",
        "label": "Property",
        "id": "9450"
    },
    {
        "raw_code": "def word_wrap(text, _length = 80)\n        # See ruby-talk/10655 / Ernest Ellingson\n        text.gsub(/\\t/, \"     \").gsub(/.{1,50}(?:\\s|\\Z)/) do\n          ($& + 5.chr).gsub(/\\n\\005/, \"\\n\").gsub(/\\005/, \"\\n\")\n        end",
        "comment": "Wraps text to a specific column length  @param [String] text the text to wrap @param [Fixnum] _length the column length to wrap to @return [String] the wrapped text",
        "label": "Property",
        "id": "475"
    },
    {
        "raw_code": "def self.verify_signature(signed_data:, ca_certs: nil)\n          store = OpenSSL::X509::Store.new\n          store.set_default_paths\n          Array.wrap(ca_certs).compact.each { |ca_cert| store.add_cert(ca_cert) }\n\n          signed_smime = OpenSSL::PKCS7.read_smime(signed_data)\n\n          # The S/MIME certificate(s) are included in the message and the trusted\n          # CAs are in the store parameter, so we pass no certs as parameters\n          # to `PKCS7.verify`\n          # See https://www.openssl.org/docs/manmaster/man3/PKCS7_verify.html\n          signed_smime if signed_smime.verify(nil, store)\n        end",
        "comment": "Return nil if data cannot be verified, otherwise the signed content data  Be careful with the `ca_certs` parameter, it will implicitly trust all the CAs in the array by creating a trusted store, stopping validation at the first match This is relevant when using intermediate CAs, `ca_certs` should only include the trusted, root CA",
        "label": "Property",
        "id": "3256"
    },
    {
        "raw_code": "def css(document, query, reference_options = {})\n      # When using \"a.foo\" Nokogiri compiles this to \"//a[...]\" but\n      # \"descendant::a[...]\" is quite a bit faster and achieves the same result.\n      xpath = Nokogiri::CSS.xpath_for(query)[0].gsub(%r{^//}, 'descendant::')\n      xpath = restrict_to_p_nodes_at_root(xpath) if filter_nodes_at_beginning?(reference_options)\n      nodes = document.xpath(xpath)\n\n      filter_nodes(nodes, reference_options)\n    end",
        "comment": "Searches a Nokogiri document using a CSS query, optionally optimizing it whenever possible.  document          - A document/element to search. query             - The CSS query to use. reference_options - A hash with nodes filter options  Returns an array of Nokogiri::XML::Element objects if location is specified in reference_options. Otherwise it would a Nokogiri::XML::NodeSet.",
        "label": "Property",
        "id": "3391"
    },
    {
        "raw_code": "def self.error_for_401(headers)\n      # rubocop:enbale Naming/VariableNumber\n      if Octokit::OneTimePasswordRequired.required_header(headers)\n        Octokit::OneTimePasswordRequired\n      else\n        Octokit::Unauthorized\n      end",
        "comment": "Returns most appropriate error for 401 HTTP status code @private rubocop:disable Naming/VariableNumber",
        "label": "Property",
        "id": "14857"
    },
    {
        "raw_code": "def self.acceptable_attributes\n      attribute_map.values\n    end",
        "comment": "Returns all the JSON keys this model knows about",
        "label": "Property",
        "id": "932"
    },
    {
        "raw_code": "def assert_field_type(attribute_type, field_type)\n          assert_equal(field_type, create_generated_attribute(attribute_type).field_type)\n        end",
        "comment": "Asserts the given attribute type gets translated to a field type properly:  assert_field_type :date, :date_select",
        "label": "Property",
        "id": "14796"
    },
    {
        "raw_code": "def report\n    if @coverage_level > 0 then\n      extend RDoc::Text\n    end",
        "comment": " Returns a report on which items are not documented",
        "label": "Property",
        "id": "15996"
    },
    {
        "raw_code": "def self.sessions_from_ids(session_ids)\n    return [] if session_ids.empty?\n\n    Gitlab::Redis::Sessions.with do |redis|\n      session_keys = rack_session_keys(session_ids)\n\n      session_keys.each_slice(SESSION_BATCH_SIZE).flat_map do |session_keys_batch|\n        Gitlab::Instrumentation::RedisClusterValidator.allow_cross_slot_commands do\n          raw_sessions = if Gitlab::Redis::ClusterUtil.cluster?(redis)\n                           Gitlab::Redis::ClusterUtil.batch_get(session_keys_batch, redis)\n                         else\n                           redis.mget(session_keys_batch)\n                         end",
        "comment": "Lists the session Hash objects for the given session IDs.  session_ids - An array of strings  Returns an array of ActiveSession objects",
        "label": "Property",
        "id": "6892"
    },
    {
        "raw_code": "def inherited_constants\n      inheritance_tree[1..-1].inject([]) do |list, superclass|\n        if superclass.is_a?(Proxy)\n          list\n        else\n          list += superclass.constants.reject do |o|\n            child(:name => o.name) || list.find {|o2| o2.name == o.name }\n          end",
        "comment": "Returns only the constants that were inherited.  @return [Array<ConstantObject>] the list of inherited constant objects",
        "label": "Property",
        "id": "592"
    },
    {
        "raw_code": "def add_filter(type, path = /.*/, **options, &block)\n        filters[type] << compile!(type, path, block, **options)\n      end",
        "comment": "add a filter",
        "label": "Property",
        "id": "8608"
    },
    {
        "raw_code": "def to_s\n      to_hash.to_s\n    end",
        "comment": "Returns the string representation of the object @return [String] String presentation of the object",
        "label": "Property",
        "id": "910"
    },
    {
        "raw_code": "def self.internal_poststart_command_start_sshd_script\n          read_file(\"workspace_operations/create/bm_internal_poststart_command_start_sshd.sh\")\n        end",
        "comment": "@return [String] content of the file",
        "label": "Property",
        "id": "3313"
    },
    {
        "raw_code": "def formatted_offset(colon = true, alternate_utc_string = nil)\n    utc? && alternate_utc_string || ActiveSupport::TimeZone.seconds_to_utc_offset(utc_offset, colon)\n  end",
        "comment": "Returns a formatted string of the offset from UTC, or an alternative string if the time zone is already UTC.  Time.local(2000).formatted_offset        # => \"-06:00\" Time.local(2000).formatted_offset(false) # => \"-0600\"",
        "label": "Property",
        "id": "14417"
    },
    {
        "raw_code": "def self.build_from_hash(attributes)\n      new.build_from_hash(attributes)\n    end",
        "comment": "Builds the object from hash @param [Hash] attributes Model attributes in the form of hash @return [Object] Returns the model itself",
        "label": "Property",
        "id": "889"
    },
    {
        "raw_code": "def delete(name, options = nil)\n        options = merged_options(options)\n        key = normalize_key(name, options)\n\n        instrument(:delete, key, options) do\n          delete_entry(key, **options)\n        end",
        "comment": "Deletes an entry in the cache. Returns +true+ if an entry is deleted and +false+ otherwise.  Options are passed to the underlying cache implementation.",
        "label": "Property",
        "id": "13741"
    },
    {
        "raw_code": "def create_dhcp_server(*_, **_)\n          super if !use_host_only_nets?\n        end",
        "comment": "Disabled when host only nets are in use since the host only nets will provide the dhcp server",
        "label": "Property",
        "id": "9559"
    },
    {
        "raw_code": "def %(other)\n      if Duration === other || Scalar === other\n        Duration.build(value % other.value)\n      elsif Numeric === other\n        Duration.build(value % other)\n      else\n        raise_type_error(other)\n      end",
        "comment": "Returns the modulo of this Duration by another Duration or Numeric. Numeric values are treated as seconds.",
        "label": "Property",
        "id": "13816"
    },
    {
        "raw_code": "def to_s\n      Encoder.new(self).encode\n    end",
        "comment": "Returns a string representation of the package URL. Package URL representations are created according to the instructions from https://github.com/package-url/purl-spec/blob/0b1559f76b79829e789c4f20e6d832c7314762c5/PURL-SPECIFICATION.rst#how-to-build-purl-string-from-its-components.",
        "label": "Property",
        "id": "3747"
    },
    {
        "raw_code": "def dup\n      copy_defaults(self.class.new(self))\n    end",
        "comment": "Returns a shallow copy of the hash.  hash = ActiveSupport::HashWithIndifferentAccess.new({ a: { b: 'b' } }) dup  = hash.dup dup[:a][:c] = 'c'  hash[:a][:c] # => \"c\" dup[:a][:c]  # => \"c\"",
        "label": "Property",
        "id": "13885"
    },
    {
        "raw_code": "def _HtmlBlockOpenUl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenUl = \"<\" Spnl (\"ul\" | \"UL\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "15689"
    },
    {
        "raw_code": "def initialize(delim, subtype)\n            @delim   = delim\n            @subtype = subtype\n          end",
        "comment": "+delim+ corresponds to the `typdelim` column in the pg_types table.  +subtype+ is derived from the `typelem` column in the pg_types table.",
        "label": "Property",
        "id": "13280"
    },
    {
        "raw_code": "def self.register_static_path(path)\n      static_paths = Commands::StaticFileCommand::STATIC_PATHS\n      static_paths.push(path) unless static_paths.include?(path)\n    end",
        "comment": "Registers a static path to be used in static asset lookup. @param [String] path the pathname to register @return [void] @since 0.6.2",
        "label": "Property",
        "id": "164"
    },
    {
        "raw_code": "def inspect\n      inspect_with_attributes(attributes_for_inspect)\n    end",
        "comment": "Returns the attributes of the record as a nicely formatted string.  Post.first.inspect #=> \"#<Post id: 1, title: \"Hello, World!\", published_at: \"2023-10-23 14:28:11 +0000\">\"  The attributes can be limited by setting <tt>.attributes_for_inspect</tt>.  Post.attributes_for_inspect = [:id, :title] Post.first.inspect #=> \"#<Post id: 1, title: \"Hello, World!\">\"",
        "label": "Property",
        "id": "12440"
    },
    {
        "raw_code": "def primary_machine_name\n      vagrantfile.primary_machine_name\n    end",
        "comment": "This returns the name of the machine that is the \"primary.\" In the case of  a single-machine environment, this is just the single machine name. In the case of a multi-machine environment, then this can potentially be nil if no primary machine is specified.  @return [Symbol]",
        "label": "Property",
        "id": "8869"
    },
    {
        "raw_code": "def changed_attributes\n      mutations_from_database.changed_values\n    end",
        "comment": "Returns a hash of the attributes with unsaved changes indicating their original values like <tt>attr => original value</tt>.  person.name # => \"bob\" person.name = 'robert' person.changed_attributes # => {\"name\" => \"bob\"}",
        "label": "Property",
        "id": "12206"
    },
    {
        "raw_code": "def parse_condition\n    condition = nil\n\n    # Right now we can handle very simple unary conditions like:\n    #   if true\n    #   if false\n    #   if 0\n    #   if 100 (not 0)\n    #   if defined? SOME_CONSTANT\n    #\n    # The last case will do a lookup in the registry and then one\n    # in the Ruby world (using eval).\n    case statement.condition.type\n    when :int\n      condition = statement.condition[0] != \"0\"\n    when :defined\n      # defined? keyword used, let's see if we can look up the name\n      # in the registry, then we'll try using Ruby's powers. eval() is not\n      # *too* dangerous here since code is not actually executed.\n      arg = statement.condition.first\n\n      if arg.type == :var_ref\n        name = arg.source\n        obj = YARD::Registry.resolve(namespace, name, true)\n\n        begin\n          condition = true if obj || (name && Object.instance_eval(\"defined? #{name}\"))\n        rescue SyntaxError, NameError\n          condition = false\n        end",
        "comment": "Parses the condition part of the if/unless statement  @return [true, false, nil] true if the condition can be definitely parsed to true, false if not, and nil if the condition cannot be parsed with certainty (it's dynamic)",
        "label": "Property",
        "id": "190"
    },
    {
        "raw_code": "def serialize_items_for_super_sidebar\n      # All renderable menu entries\n      renderable_items.map do |entry|\n        entry.serialize_for_super_sidebar.tap do |item|\n          active_routes = item.delete(:active_routes)\n          item[:is_active] = active_routes ? @context.route_is_active.call(active_routes) : false\n        end",
        "comment": "Returns an array of renderable menu entries, with additional information on whether the item has an active route",
        "label": "Property",
        "id": "3681"
    },
    {
        "raw_code": "def javascript_include_tag(*sources)\n        options = sources.extract_options!.stringify_keys\n        path_options = options.extract!(\"protocol\", \"extname\", \"host\", \"skip_pipeline\").symbolize_keys\n        preload_links = []\n        use_preload_links_header = options[\"preload_links_header\"].nil? ? preload_links_header : options.delete(\"preload_links_header\")\n        nopush = options[\"nopush\"].nil? || options.delete(\"nopush\")\n        crossorigin = options.delete(\"crossorigin\")\n        crossorigin = \"anonymous\" if crossorigin == true\n        integrity = options[\"integrity\"]\n        rel = options[\"type\"] == \"module\" || options[\"type\"] == :module ? \"modulepreload\" : \"preload\"\n\n        sources_tags = sources.uniq.map { |source|\n          href = path_to_javascript(source, path_options)\n          if use_preload_links_header && !options[\"defer\"] && href.present? && !href.start_with?(\"data:\")\n            preload_link = \"<#{href}>; rel=#{rel}; as=script\"\n            preload_link += \"; crossorigin=#{crossorigin}\" unless crossorigin.nil?\n            preload_link += \"; integrity=#{integrity}\" unless integrity.nil?\n            preload_link += \"; nonce=#{content_security_policy_nonce}\" if options[\"nonce\"] == true\n            preload_link += \"; nopush\" if nopush\n            preload_links << preload_link\n          end",
        "comment": "Returns an HTML script tag for each of the +sources+ provided.  Sources may be paths to JavaScript files. Relative paths are assumed to be relative to <tt>assets/javascripts</tt>, full paths are assumed to be relative to the document root. Relative paths are idiomatic, use absolute paths only when needed.  When passing paths, the \".js\" extension is optional. If you do not want \".js\" appended to the path <tt>extname: false</tt> can be set on the options.  You can modify the HTML attributes of the script tag by passing a hash as the last argument.  When the Asset Pipeline is enabled, you can pass the name of your manifest as source, and include other JavaScript or CoffeeScript files inside the manifest.  If the server supports HTTP Early Hints, and the +defer+ option is not enabled, \\Rails will push a <tt>103 Early Hints</tt> response that links to the assets.  ==== Options  When the last parameter is a hash you can add HTML attributes using that parameter. This includes but is not limited to the following options:  * <tt>:extname</tt>  - Append an extension to the generated URL unless the extension already exists. This only applies for relative URLs. * <tt>:protocol</tt>  - Sets the protocol of the generated URL. This option only applies when a relative URL and +host+ options are provided. * <tt>:host</tt>  - When a relative URL is provided the host is added to the that path. * <tt>:skip_pipeline</tt>  - This option is used to bypass the asset pipeline when it is set to true. * <tt>:nonce</tt>  - When set to true, adds an automatic nonce value if you have Content Security Policy enabled. * <tt>:async</tt>  - When set to +true+, adds the +async+ HTML attribute, allowing the script to be fetched in parallel to be parsed and evaluated as soon as possible. * <tt>:defer</tt>  - When set to +true+, adds the +defer+ HTML attribute, which indicates to the browser that the script is meant to be executed after the document has been parsed. Additionally, prevents sending the Preload Links header. * <tt>:nopush</tt>  - Specify if the use of server push is not desired for the script. Defaults to +true+.  Any other specified options will be treated as HTML attributes for the +script+ tag.  For more information regarding how the <tt>:async</tt> and <tt>:defer</tt> options affect the <tt><script></tt> tag, please refer to the {MDN docs}[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script].  ==== Examples  javascript_include_tag \"xmlhr\" # => <script src=\"/assets/xmlhr.debug-1284139606.js\"></script>  javascript_include_tag \"xmlhr\", host: \"localhost\", protocol: \"https\" # => <script src=\"https://localhost/assets/xmlhr.debug-1284139606.js\"></script>  javascript_include_tag \"template.jst\", extname: false # => <script src=\"/assets/template.debug-1284139606.jst\"></script>  javascript_include_tag \"xmlhr.js\" # => <script src=\"/assets/xmlhr.debug-1284139606.js\"></script>  javascript_include_tag \"common.javascript\", \"/elsewhere/cools\" # => <script src=\"/assets/common.javascript.debug-1284139606.js\"></script> #    <script src=\"/elsewhere/cools.debug-1284139606.js\"></script>  javascript_include_tag \"http://www.example.com/xmlhr\" # => <script src=\"http://www.example.com/xmlhr\"></script>  javascript_include_tag \"http://www.example.com/xmlhr.js\" # => <script src=\"http://www.example.com/xmlhr.js\"></script>  javascript_include_tag \"http://www.example.com/xmlhr.js\", nonce: true # => <script src=\"http://www.example.com/xmlhr.js\" nonce=\"...\"></script>  javascript_include_tag \"http://www.example.com/xmlhr.js\", async: true # => <script src=\"http://www.example.com/xmlhr.js\" async=\"async\"></script>  javascript_include_tag \"http://www.example.com/xmlhr.js\", defer: true # => <script src=\"http://www.example.com/xmlhr.js\" defer=\"defer\"></script>",
        "label": "Property",
        "id": "11780"
    },
    {
        "raw_code": "def file(basename, allow_inherited = false)\n        file = self.class.find_file(basename)\n        raise ArgumentError, \"no file for '#{basename}' in #{self.class.path}\" unless file\n\n        data = IO.read(file)\n        if allow_inherited\n          superfile = self.class.find_nth_file(basename, 2)\n          data.gsub!('{{{__super__}}}', superfile ? IO.read(superfile) : \"\")\n        end",
        "comment": "Returns the contents of a file. If +allow_inherited+ is set to +true+, use +{{{__super__}}}+ inside the file contents to insert the contents of the file from an inherited template. For instance, if +templates/b+ inherits from +templates/a+ and file \"test.css\" exists in both directories, both file contents can be retrieved by having +templates/b/test.css+ look like:  {{{__super__}}} ... body { css styles here } p.class { other styles }  @param [String] basename the name of the file @param [Boolean] allow_inherited whether inherited templates can be inserted with +{{{__super__}}}+ @return [String] the contents of a file identified by +basename+. All template paths (including any mixed in templates) are searched for the file @see ClassMethods#find_file @see ClassMethods#find_nth_file",
        "label": "Property",
        "id": "368"
    },
    {
        "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
        "comment": "Returns the currently loaded version of Action Mailbox as a +Gem::Version+.",
        "label": "Property",
        "id": "11098"
    },
    {
        "raw_code": "def _mime_type\n      if defined? @_mime_type\n        @_mime_type\n      else\n        guesses = ::MIME::Types.type_for(extname.to_s)\n\n        # Prefer text mime types over binary\n        @_mime_type = guesses.detect { |type| type.ascii? } || guesses.first\n      end",
        "comment": "Internal: Lookup mime type for extension.  Returns a MIME::Type rubocop:disable Gitlab/ModuleWithInstanceVariables",
        "label": "Property",
        "id": "1562"
    },
    {
        "raw_code": "def _HtmlBlockCloseFrameset\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseFrameset = \"<\" Spnl \"/\" (\"frameset\" | \"FRAMESET\") Spnl \">\"",
        "label": "Property",
        "id": "15699"
    },
    {
        "raw_code": "def variant(transformations)\n    transformations = transformations_by_name(transformations)\n    blob.variant(transformations)\n  end",
        "comment": "Returns an ActiveStorage::Variant or ActiveStorage::VariantWithRecord instance for the attachment with the set of +transformations+ provided. Example:  avatar.variant(resize_to_limit: [100, 100]).processed.url  or if you are using pre-defined variants:  avatar.variant(:thumb).processed.url  See ActiveStorage::Blob::Representable#variant for more information.  Raises an +ArgumentError+ if +transformations+ is a +Symbol+ which is an unknown pre-defined variant of the attachment.",
        "label": "Property",
        "id": "13595"
    },
    {
        "raw_code": "def get_attributes(element)\n        attribute_hash = {}\n        attributes = element.attributes\n        (0...attributes.length).each do |i|\n          attribute_hash[CONTENT_KEY] ||= \"\"\n          attribute_hash[attributes.item(i).name] = attributes.item(i).value\n        end",
        "comment": "Converts the attributes array of an XML element into a hash. Returns an empty Hash if node has no attributes.  element:: XML element to extract attributes from.",
        "label": "Property",
        "id": "14585"
    },
    {
        "raw_code": "def self.container_keepalive_command_args\n          read_file(\"workspace_operations/create/bm_container_keepalive_command_args.sh\")\n        end",
        "comment": "@return [String] content of the file",
        "label": "Property",
        "id": "3310"
    },
    {
        "raw_code": "def self.fullpath(output)\n          File.expand_path(output, Dir.pwd)\n        end",
        "comment": "Calculate the full path of the given path, relative to the current working directory (where the command was run).  @param [String] output the relative path",
        "label": "Property",
        "id": "9320"
    },
    {
        "raw_code": "def exclude_filter_identifier?(identifier)\n          return false if identifier.nil? || Metric::Identifier.new(identifier).default?\n\n          filter_options.empty?\n        end",
        "comment": "Whether none of the events have additional properties and the given identifier is an additional property. In this case, it makes sense to exclude these from the menu to keep the flow simple when the use-case is simple",
        "label": "Property",
        "id": "5364"
    },
    {
        "raw_code": "def current_database\n          query_value(\"SELECT current_database()\", \"SCHEMA\")\n        end",
        "comment": "Returns the current database name.",
        "label": "Property",
        "id": "13240"
    },
    {
        "raw_code": "def location_fingerprint\n            location_fingerprints.first\n          end",
        "comment": "Returns either the max priority signature hex or the location fingerprint",
        "label": "Property",
        "id": "2547"
    },
    {
        "raw_code": "def port_string\n        standard_port? ? \"\" : \":#{port}\"\n      end",
        "comment": "Returns a string port suffix, including colon, like \":8080\" if the port number of this request is not the default HTTP port 80 or HTTPS port 443.  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:80' req.port_string # => \"\"  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080' req.port_string # => \":8080\"",
        "label": "Property",
        "id": "11505"
    },
    {
        "raw_code": "def perform(project_id)\n        info(project_id, message: 'starting stage')\n\n        return unless (project = find_project(project_id))\n\n        Import::RefreshImportJidWorker.perform_in_the_future(project_id, jid)\n\n        import(project)\n\n        info(project_id, message: 'stage finished')\n      rescue StandardError => e\n        Gitlab::Import::ImportFailureService.track(\n          project_id: project_id,\n          exception: e,\n          error_source: self.class.name,\n          fail_import: abort_on_failure\n        )\n\n        raise(e)\n      end",
        "comment": "project_id - The ID of the GitLab project to import the data into.",
        "label": "Property",
        "id": "6354"
    },
    {
        "raw_code": "def parse src\n  @src = src\n  @src.push false\n\n  @footnotes = []\n  @labels    = {}\n\n  # @i: index(line no.) of src\n  @i = 0\n\n  # stack for current indentation\n  @indent_stack = []\n\n  # how indented.\n  @current_indent = @indent_stack.join(\"\")\n\n  # RDoc::RD::BlockParser for tmp src\n  @subparser = nil\n\n  # which part is in now\n  @in_part = nil\n  @part_content = []\n\n  @in_verbatim = false\n\n  @yydebug = true\n\n  document = do_parse\n\n  unless @footnotes.empty? then\n    blankline = document.parts.pop\n\n    document.parts << RDoc::Markup::Rule.new(1)\n    document.parts.concat @footnotes\n\n    document.parts.push blankline\n  end",
        "comment": " Parses +src+ and returns an RDoc::Markup::Document.",
        "label": "Property",
        "id": "16504"
    },
    {
        "raw_code": "def register_path; @register_path ||= nil; end\n\n      # Indicates an extension is being registered.\n      def start_registering_extension\n        @register_path = caller_files[2]\n      end\n\n      # Indicates the extension has already been registered.\n      def stop_registering_extension\n        @register_path = nil\n      end\n\n      # Indicates whether or not an extension is being registered.\n      def registering_extension?\n        !register_path.nil?\n      end\n\n      # Builds a Watcher::Element from +type+ and +representation+ and\n      # tells the Watcher::List for the current application to watch it\n      # in the file located at +path+.\n      #\n      # If an extension is being registered, it also tells the list to\n      # watch it in the file where the extension has been registered.\n      # This prevents the duplication of the elements added by the\n      # extension in its +registered+ method with every reload.\n      def watch_element(path, type, representation = nil)\n        list = Watcher::List.for(self)\n        element = Watcher::Element.new(type, representation)\n        list.watch(path, element)\n        list.watch(register_path, element) if registering_extension?\n      end\n    end",
        "comment": "attr_reader :register_path warn on -w (private attribute)",
        "label": "Property",
        "id": "8648"
    },
    {
        "raw_code": "def scopes_registered_for_endpoint\n        @scopes_registered_for_endpoint ||=\n          begin\n            endpoint_classes = [options[:for].presence, ::API::API].compact\n            endpoint_classes.reduce([]) do |memo, endpoint|\n              if endpoint.respond_to?(:allowed_scopes)\n                memo.concat(endpoint.allowed_scopes)\n              else\n                memo\n              end",
        "comment": "An array of scopes that were registered (using `allow_access_with_scope`) for the current endpoint class. It also returns scopes registered on `API::API`, since these are meant to apply to all API routes.",
        "label": "Property",
        "id": "3760"
    },
    {
        "raw_code": "def valid?\n      true\n    end",
        "comment": "Check to see if the all the properties in the model are valid @return true if the model is valid",
        "label": "Property",
        "id": "920"
    },
    {
        "raw_code": "def self.values_from_set(raw_key)\n          key = cache_key_for(raw_key)\n\n          with_redis do |redis|\n            redis.smembers(key)\n          end",
        "comment": "Returns the values of the given set.  raw_key - The key of the set to check.",
        "label": "Property",
        "id": "1946"
    },
    {
        "raw_code": "def assert_emails(number, &block)\n      if block_given?\n        diff = capture_emails(&block).length\n        assert_equal number, diff, \"#{number} emails expected, but #{diff} were sent\"\n      else\n        assert_equal number, ActionMailer::Base.deliveries.size\n      end",
        "comment": "Asserts that the number of emails sent matches the given number.  def test_emails assert_emails 0 ContactMailer.welcome.deliver_now assert_emails 1 ContactMailer.welcome.deliver_now assert_emails 2 end  If a block is passed, that block should cause the specified number of emails to be sent.  def test_emails_again assert_emails 1 do ContactMailer.welcome.deliver_now end  assert_emails 2 do ContactMailer.welcome.deliver_now ContactMailer.welcome.deliver_later end end",
        "label": "Property",
        "id": "11165"
    },
    {
        "raw_code": "def to_i\n      @value.to_i\n    end",
        "comment": "Returns the number of seconds that this Duration represents.  1.minute.to_i   # => 60 1.hour.to_i     # => 3600 1.day.to_i      # => 86400  Note that this conversion makes some assumptions about the duration of some periods, e.g. months are always 1/12 of year and years are 365.2425 days:  # equivalent to (1.year / 12).to_i 1.month.to_i    # => 2629746  # equivalent to 365.2425.days.to_i 1.year.to_i     # => 31556952  In such cases, Ruby's core Date[https://docs.ruby-lang.org/en/master/Date.html] and Time[https://docs.ruby-lang.org/en/master/Time.html] should be used for precision date and time arithmetic.",
        "label": "Property",
        "id": "13819"
    },
    {
        "raw_code": "def ruby(&block)\n        @ruby_block = block\n      end",
        "comment": "Config option `ruby` for a trigger which reads in a ruby block and sets it to be evaluated when the configured trigger fires. This method is only invoked when the regular \"block\" syntax is used. Otherwise the proc is set through the attr_accessor if the hash syntax is used.  @param [Proc] block",
        "label": "Property",
        "id": "9442"
    },
    {
        "raw_code": "def lock_exclusively!(max_run_time, worker)\n          now = self.class.db_time_now\n          if locked_by != worker\n            # We don't own this job so we will update the locked_by name and the locked_at\n            self.locked_at = now\n            self.locked_by = worker\n          end",
        "comment": "Lock this job for this worker. Returns true if we have the lock, false otherwise.",
        "label": "Property",
        "id": "12165"
    },
    {
        "raw_code": "def dir_name(name)\n      name = name.dup\n      name.gsub!(\":\", VAGRANT_COLON) if Util::Platform.windows?\n      name.gsub!(\"/\", VAGRANT_SLASH)\n      name\n    end",
        "comment": "Returns the directory name for the box of the given name.  @param [String] name @return [String]",
        "label": "Property",
        "id": "8735"
    },
    {
        "raw_code": "def self.limit_to_todo_authors(user: nil, with_todos: false, todo_state: nil)\n    if user && with_todos\n      where(id: Todo.where(user: user, state: todo_state).select(:author_id))\n    else\n      all\n    end",
        "comment": "Limits the users to those that have TODOs, optionally in the given state.  user - The user to get the todos for.  with_todos - If we should limit the result set to users that are the authors of todos.  todo_state - An optional state to require the todos to be in.",
        "label": "Property",
        "id": "7049"
    },
    {
        "raw_code": "def for_enabled_cop(cop)\n      cop_enabled?(cop) ? for_cop(cop) : EMPTY_CONFIG\n    end",
        "comment": "@return [Config, Hash] for the given cop / cop name. If the given cop is enabled, returns its configuration hash. Otherwise, returns an empty hash.",
        "label": "Property",
        "id": "10170"
    },
    {
        "raw_code": "def routes(&block)\n      @routes ||= config.route_set_class.new_with_config(config)\n      @routes.append(&block) if block_given?\n      @routes\n    end",
        "comment": "Defines the routes for this engine. If a block is given to routes, it is appended to the engine.",
        "label": "Property",
        "id": "14668"
    },
    {
        "raw_code": "def expand_when_branches(when_branches)\n          when_branches.map(&:body)\n        end",
        "comment": "`when` nodes contain the entire branch including the condition. We only need the contents of the branch, not the condition.",
        "label": "Property",
        "id": "10539"
    },
    {
        "raw_code": "def memory_usage_rss(pid: 'self')\n        results = { total: 0, anon: 0, file: 0 }\n\n        safe_yield_procfile(PROC_STATUS_PATH % pid) do |io|\n          io.each_line do |line|\n            if (value = parse_metric_value(line, RSS_TOTAL_PATTERN)) > 0\n              results[:total] = value.kilobytes\n            elsif (value = parse_metric_value(line, RSS_ANON_PATTERN)) > 0\n              results[:anon] = value.kilobytes\n            elsif (value = parse_metric_value(line, RSS_FILE_PATTERN)) > 0\n              results[:file] = value.kilobytes\n            end",
        "comment": "Returns the given process' RSS (resident set size) in bytes.",
        "label": "Property",
        "id": "1229"
    },
    {
        "raw_code": "def importer_class\n        raise NotImplementedError\n      end",
        "comment": "Returns the class to use for importing the object.",
        "label": "Property",
        "id": "6360"
    },
    {
        "raw_code": "def output_summary(summary)\n        output.puts '# SUMMARY BEGIN'\n        output.puts colorize_summary(summary)\n        output.puts '# SUMMARY END'\n      end",
        "comment": "The BEGIN/END comments are used by `spec_runner.rake` to determine what output goes where in the final parallelized output, and should not be removed!",
        "label": "Property",
        "id": "10706"
    },
    {
        "raw_code": "def within_interpolation?(node, child)\n          parse_tree_child_loc = child.expression\n\n          interpolation_locs(node).any? { |il| il.overlaps?(parse_tree_child_loc) }\n        end",
        "comment": "Since we blank interpolations with a space for every char of the interpolation, we would mark every space (except the first) as duplicate if we do not skip regexp_parser nodes that are within an interpolation.",
        "label": "Property",
        "id": "10639"
    },
    {
        "raw_code": "def import(project)\n          placeholder_reference_store = project.placeholder_reference_store\n\n          if placeholder_reference_store&.any?\n            info(\n              project.id,\n              message: 'Delaying finalization as placeholder references are pending',\n              placeholder_store_count: placeholder_reference_store.count\n            )\n\n            reschedule(project)\n\n            return\n          end",
        "comment": "@param project [Project]",
        "label": "Property",
        "id": "6302"
    },
    {
        "raw_code": "def forty_two\n      find_nth 41\n    end",
        "comment": "Find the forty-second record. Also known as accessing \"the reddit\". If no order is defined it will order by primary key.  Person.forty_two # returns the forty-second object fetched by SELECT * FROM people Person.offset(3).forty_two # returns the forty-second object from OFFSET 3 (which is OFFSET 44) Person.where([\"user_name = :u\", { u: user_name }]).forty_two",
        "label": "Property",
        "id": "13381"
    },
    {
        "raw_code": "def glob?(path)\n      path.match?(/[*{\\[?]/)\n    end",
        "comment": "Returns true for a glob",
        "label": "Property",
        "id": "10122"
    },
    {
        "raw_code": "def internal?(uri)\n          check_uri(uri, Gitlab::HTTP_V2.configuration.allowed_internal_uris)\n        end",
        "comment": "Allow url from the GitLab instance itself but only for the configured hostname and ports",
        "label": "Property",
        "id": "1205"
    },
    {
        "raw_code": "def marked_for_destruction?\n      @marked_for_destruction\n    end",
        "comment": "Returns whether or not this record will be destroyed as part of the parent's save transaction.  Only useful if the <tt>:autosave</tt> option on the parent is enabled for this associated model.",
        "label": "Property",
        "id": "12379"
    },
    {
        "raw_code": "def self.body_classes\n      available_schemes.collect(&:css_class).uniq.join(' ')\n    end",
        "comment": "Convenience method to get a space-separated String of all the color scheme classes that might be applied to a code block.  Returns a String",
        "label": "Property",
        "id": "1673"
    },
    {
        "raw_code": "def init\n  sections :header, [T('docstring')], :children, :includes, :extends,\n    :class_meths_list, :instance_meths_list\nend",
        "comment": "frozen_string_literal: true",
        "label": "Property",
        "id": "740"
    },
    {
        "raw_code": "def gen_url(url, text)\n    if url =~ /^rdoc-label:([^:]*)(?::(.*))?/ then\n      type = \"link\"\n    elsif url =~ /([A-Za-z]+):(.*)/ then\n      type = $1\n    else\n      type = \"http\"\n    end",
        "comment": " Returns just the text of +link+, +url+ is only used to determine the link type.",
        "label": "Property",
        "id": "16411"
    },
    {
        "raw_code": "def find_for_paths(paths, absolute_path = false)\n          return [] if paths.empty?\n\n          if Gitlab::SafeRequestStore.active?\n            cached_objects_for_paths(paths, absolute_path)\n          else\n            objects_for_paths(paths, absolute_path)\n          end",
        "comment": "Returns projects for the given paths.",
        "label": "Property",
        "id": "3481"
    },
    {
        "raw_code": "def erubi?\n      @current_engine == :erubi or\n        (erb? && Tilt[:erb] == Tilt::ErubiTemplate)\n    end",
        "comment": "Returns true if the current engine is `:erubi`, or `Tilt[:erb]` is set to Tilt::ErubiTemplate.  @return [Boolean] Returns true if current engine is `:erubi`.",
        "label": "Property",
        "id": "8670"
    },
    {
        "raw_code": "def list_methods_matching(name)\n    found = []\n\n    find_methods name do |store, klass, ancestor, types, method|\n      if types == :instance or types == :both then\n        methods = store.instance_methods[ancestor]\n\n        if methods then\n          matches = methods.grep(/^#{Regexp.escape method.to_s}/)\n\n          matches = matches.map do |match|\n            \"#{klass}##{match}\"\n          end",
        "comment": " Returns an Array of methods matching +name+",
        "label": "Property",
        "id": "16608"
    },
    {
        "raw_code": "def rfc3339(str)\n      parts = Date._rfc3339(str)\n\n      raise ArgumentError, \"invalid date\" if parts.empty?\n\n      time = Time.new(\n        parts.fetch(:year),\n        parts.fetch(:mon),\n        parts.fetch(:mday),\n        parts.fetch(:hour),\n        parts.fetch(:min),\n        parts.fetch(:sec) + parts.fetch(:sec_fraction, 0),\n        parts.fetch(:offset)\n      )\n\n      TimeWithZone.new(time.utc, self)\n    end",
        "comment": "\\Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from an RFC 3339 string.  Time.zone = 'Hawaii'                     # => \"Hawaii\" Time.zone.rfc3339('2000-01-01T00:00:00Z') # => Fri, 31 Dec 1999 14:00:00 HST -10:00  If the time or zone components are missing then an +ArgumentError+ will be raised. This is much stricter than either +parse+ or +iso8601+ which allow for missing components.  Time.zone = 'Hawaii'            # => \"Hawaii\" Time.zone.rfc3339('1999-12-31') # => ArgumentError: invalid date",
        "label": "Property",
        "id": "14572"
    },
    {
        "raw_code": "def default_provider(**opts)\n      opts[:exclude]       = Set.new(opts[:exclude]) if opts[:exclude]\n      opts[:force_default] = true if !opts.key?(:force_default)\n      opts[:check_usable] = true if !opts.key?(:check_usable)\n\n      # Implement the algorithm from\n      # https://www.vagrantup.com/docs/providers/basic_usage.html#default-provider\n      # with additional steps 2.5 and 3.5 from\n      # https://bugzilla.redhat.com/show_bug.cgi?id=1444492\n      # to allow system-configured provider priorities.\n      #\n      # 1. The --provider flag on a vagrant up is chosen above all else, if it is\n      #    present.\n      #\n      # (Step 1 is done by the caller; this method is only called if --provider\n      # wasn't given.)\n      #\n      # 2. If the VAGRANT_DEFAULT_PROVIDER environmental variable is set, it\n      #    takes next priority and will be the provider chosen.\n\n      default = ENV[\"VAGRANT_DEFAULT_PROVIDER\"].to_s\n      if default.empty?\n        default = nil\n      else\n        default = default.to_sym\n        @logger.debug(\"Default provider: `#{default}`\")\n      end",
        "comment": "This returns the provider name for the default provider for this environment.  @param check_usable [Boolean] (true) whether to filter for `.usable?` providers @param exclude [Array<Symbol>] ([]) list of provider names to exclude from consideration @param force_default [Boolean] (true) whether to prefer the value of VAGRANT_DEFAULT_PROVIDER over other strategies if it is set @param machine [Symbol] (nil) a machine name to scope this lookup @return [Symbol] Name of the default provider.",
        "label": "Property",
        "id": "8855"
    },
    {
        "raw_code": "def verbose\n      if block_given?\n        initial_state = @verbose\n        @verbose = true\n        yield\n        @verbose = initial_state\n      else\n        @verbose = true\n      end",
        "comment": "During the duration of the yielded block, Bundler loud output is enabled.",
        "label": "Property",
        "id": "8903"
    },
    {
        "raw_code": "def interval_with_jitter\n        sleep_s + rand(sleep_max_delta_s)\n      end",
        "comment": "Returns the sleep interval with a random adjustment. The random adjustment is put in place to ensure continued availability.",
        "label": "Property",
        "id": "1878"
    },
    {
        "raw_code": "def full_inspect\n      inspect_with_attributes(all_attributes_for_inspect)\n    end",
        "comment": "Returns all attributes of the record as a nicely formatted string, ignoring <tt>.attributes_for_inspect</tt>.  Post.first.full_inspect #=> \"#<Post id: 1, title: \"Hello, World!\", published_at: \"2023-10-23 14:28:11 +0000\">\" ",
        "label": "Property",
        "id": "12441"
    },
    {
        "raw_code": "def accessed_fields\n      @attributes.accessed\n    end",
        "comment": "Returns the name of all database fields which have been read from this model. This can be useful in development mode to determine which fields need to be selected. For performance critical pages, selecting only the required fields can be an easy performance win (assuming you aren't using all of the fields on the model).  For example:  class PostsController < ActionController::Base after_action :print_accessed_fields, only: :index  def index @posts = Post.all end  private def print_accessed_fields p @posts.first.accessed_fields end end  Which allows you to quickly change your code to:  class PostsController < ActionController::Base def index @posts = Post.select(:id, :title, :author_id, :updated_at) end end",
        "label": "Property",
        "id": "12373"
    },
    {
        "raw_code": "def block?(hook)\n          # If a request UUID has not been set then we know the request was not\n          # made by a webhook, and no recursion is possible.\n          return false unless UUID.instance.request_uuid\n\n          cache_key = cache_key_for_hook(hook)\n\n          ::Gitlab::Redis::SharedState.with do |redis|\n            redis.sismember(cache_key, hook.id) ||\n              redis.scard(cache_key) >= COUNT_LIMIT\n          end",
        "comment": "Returns true if the webhook ID is present in the cache, or if the number of IDs in the cache exceeds the limit (see `#cache_key_for_hook` for details of the cache).",
        "label": "Property",
        "id": "2802"
    },
    {
        "raw_code": "def foo; end\n        RUBY\n      end",
        "comment": "{access_modifier}",
        "label": "Property",
        "id": "10875"
    },
    {
        "raw_code": "def self.cascading_with_parent_namespace(attribute)\n    define_method(\"#{attribute}?\") do |inherit_group_setting: false|\n      self.public_send(attribute) # rubocop:disable GitlabSecurity/PublicSend\n    end",
        "comment": "Define two instance methods:  - [attribute]?(inherit_group_setting) Returns the final value after inheriting the parent group - [attribute]_locked?                 Returns true if the value is inherited from the parent group  These functions will be overridden in EE to make sense afterwards",
        "label": "Property",
        "id": "6724"
    },
    {
        "raw_code": "def disconnect_network(network, cid)\n        command = ['docker', 'network', 'disconnect', network, cid, \"--force\"]\n        output = execute(*command)\n        output\n      end",
        "comment": "@param [String] network - name of network to disconnect container from @param [String] cid - container id",
        "label": "Property",
        "id": "9488"
    },
    {
        "raw_code": "def validate(machine)\n        errors = _detected_errors\n\n        if @type && !VALID_TRIGGER_TYPES.include?(@type)\n          errors << I18n.t(\"vagrant.config.triggers.bad_trigger_type\",\n                           type: @type,\n                           trigger: @command,\n                           types: VALID_TRIGGER_TYPES.join(', '))\n        end",
        "comment": "@return [Array] array of strings of error messages from config option validation",
        "label": "Property",
        "id": "9443"
    },
    {
        "raw_code": "def host\n          request_cache[CACHE_KEY] ||= @host_list.next\n        end",
        "comment": "Returns a host to use for queries.  Hosts are scoped per thread so that multiple threads don't accidentally re-use the same host + connection.",
        "label": "Property",
        "id": "3094"
    },
    {
        "raw_code": "def initialize(host, user:, password:, port: nil)\n          @host = host\n          @user = user\n          @password = password\n          @port = port\n          @cookies = {}\n        end",
        "comment": "@param host [String] the ip or hostname of the jenkins server @param user [String] the Jenkins admin user @param password [String] the Jenkins admin password @param port [Integer] the port that Jenkins is serving on",
        "label": "Property",
        "id": "4314"
    },
    {
        "raw_code": "def comment(connection)\n          if cache_query_log_tags\n            self.cached_comment ||= uncached_comment(connection)\n          else\n            uncached_comment(connection)\n          end",
        "comment": "Returns an SQL comment +String+ containing the query log tags. Sets and returns a cached comment if <tt>cache_query_log_tags</tt> is +true+.",
        "label": "Property",
        "id": "12592"
    },
    {
        "raw_code": "def rooms(auth)\n      res = Clients::HTTP.get(\"/rooms.json\", base_uri: base_uri, **auth)\n      res.code == 200 ? res[\"rooms\"] : []\n    end",
        "comment": "Returns a list of rooms, or []. https://github.com/basecamp/campfire-api/blob/master/sections/rooms.md#get-rooms",
        "label": "Property",
        "id": "7649"
    },
    {
        "raw_code": "def which(filename)\n      ENV['PATH']&.split(File::PATH_SEPARATOR)&.each do |path|\n        full_path = File.join(path, filename)\n        return full_path if File.executable?(full_path)\n      end",
        "comment": "Behaves like `which` on Linux machines: given PATH, try to resolve the given executable name to an absolute path, or return nil.  which('ruby') #=> /usr/bin/ruby",
        "label": "Property",
        "id": "1214"
    },
    {
        "raw_code": "def foo(a) end\n      eof\n    end",
        "comment": "@param a foo @param a foo",
        "label": "Property",
        "id": "761"
    },
    {
        "raw_code": "def truncate_if_block(node)\n        return if truncated\n        return unless node.element? && (node.description&.block? || node.matches?(MATCH_CODE))\n\n        node.inner_html = \"#{node.inner_html}...\" if node.next_sibling\n        @truncated = true\n      end",
        "comment": "If `node` is the first block element, and the text hasn't already been truncated, then append \"...\" to the node contents and return true.  Otherwise return false.",
        "label": "Property",
        "id": "3449"
    },
    {
        "raw_code": "def email_format_path\n      nil\n    end",
        "comment": "When overridden this mthod should return a path to view diffs in an email-friendly format.",
        "label": "Property",
        "id": "6579"
    },
    {
        "raw_code": "def success?\n      results.all?\n    end",
        "comment": "Returns true if all steps were successful.",
        "label": "Property",
        "id": "13787"
    },
    {
        "raw_code": "def assert_has_stream(stream)\n          assert subscription.streams.include?(stream), \"Stream #{stream} has not been started\"\n        end",
        "comment": "Asserts that the specified stream has been started.  def test_assert_started_stream subscribe assert_has_stream 'messages' end ",
        "label": "Property",
        "id": "11063"
    },
    {
        "raw_code": "def url\n      \"#{Octokit.web_endpoint}#{slug}\"\n    end",
        "comment": "Repository URL based on {Octokit::Client#web_endpoint} @return [String]",
        "label": "Property",
        "id": "14922"
    },
    {
        "raw_code": "def find_template_paths(from_template, path)\n          paths = template_paths.dup\n          paths = from_template.full_paths + paths if from_template\n\n          paths.inject([]) do |acc, tp|\n            full_path = File.cleanpath(File.join(tp, path))\n            acc.unshift(full_path) if File.directory?(full_path)\n            acc\n          end.uniq\n        end",
        "comment": "Searches through the registered {template_paths} and returns all full directories that have the +path+ within them on disk.  @param [Template] from_template if provided, allows a relative path to be specified from this template's full path. @param [String] path the path component to search for in the {template_paths} @return [Array<String>] a list of full paths that are existing candidates for a template module",
        "label": "Property",
        "id": "377"
    },
    {
        "raw_code": "def seconds_until_end_of_day\n    end_of_day.to_i - to_i\n  end",
        "comment": "Returns the number of seconds until 23:59:59.  Time.new(2012, 8, 29,  0,  0,  0).seconds_until_end_of_day # => 86399 Time.new(2012, 8, 29, 12, 34, 56).seconds_until_end_of_day # => 41103 Time.new(2012, 8, 29, 23, 59, 59).seconds_until_end_of_day # => 0",
        "label": "Property",
        "id": "14393"
    },
    {
        "raw_code": "def permitted?\n      @permitted\n    end",
        "comment": "Returns `true` if the parameter is permitted, `false` otherwise.  params = ActionController::Parameters.new params.permitted? # => false params.permit! params.permitted? # => true",
        "label": "Property",
        "id": "11360"
    },
    {
        "raw_code": "def execute(label)\n      params[:name] = params.delete(:new_name) if params.key?(:new_name)\n      params[:color] = convert_color_name_to_hex if params[:color].present?\n      params.delete(:lock_on_merge) unless allow_lock_on_merge?(label)\n\n      label.update(params)\n      label\n    end",
        "comment": "returns the updated label",
        "label": "Property",
        "id": "6058"
    },
    {
        "raw_code": "def test_generate_message_empty_with_default_message\n    assert_equal \"can't be empty\", @person.errors.generate_message(:title, :empty)\n  end",
        "comment": "add_on_empty: generate_message(attr, :empty, message: custom_message)",
        "label": "Property",
        "id": "12330"
    },
    {
        "raw_code": "def cache_version(timestamp_column = :updated_at)\n      if model.collection_cache_versioning\n        @cache_versions ||= {}\n        @cache_versions[timestamp_column] ||= compute_cache_version(timestamp_column)\n      end",
        "comment": "Returns a cache version that can be used together with the cache key to form a recyclable caching scheme. The cache version is built with the number of records matching the query, and the timestamp of the last updated record. When a new record comes to match the query, or any of the existing records is updated or deleted, the cache version changes.  If the collection is loaded, the method will iterate through the records to generate the timestamp, otherwise it will trigger one SQL query like:  SELECT COUNT(*), MAX(\"products\".\"updated_at\") FROM \"products\" WHERE (name like '%Cosmic Encounter%')",
        "label": "Property",
        "id": "12641"
    },
    {
        "raw_code": "def to_sql\n      @to_sql ||= if eager_loading?\n        apply_join_dependency do |relation, join_dependency|\n          relation = join_dependency.apply_column_aliases(relation)\n          relation.to_sql\n        end",
        "comment": "Returns sql statement for the relation.  User.where(name: 'Oscar').to_sql # SELECT \"users\".* FROM \"users\"  WHERE \"users\".\"name\" = 'Oscar'",
        "label": "Property",
        "id": "12663"
    },
    {
        "raw_code": "def _to_hash(value)\n      if value.is_a?(Array)\n        value.compact.map { |v| _to_hash(v) }\n      elsif value.is_a?(Hash)\n        {}.tap do |hash|\n          value.each { |k, v| hash[k] = _to_hash(v) }\n        end",
        "comment": "Outputs non-array value in the form of hash For object, use to_hash. Otherwise, just return the value @param [Object] value Any valid value @return [Hash] Returns the value in the form of hash",
        "label": "Property",
        "id": "878"
    },
    {
        "raw_code": "def me; \"VALUE\" end\n          end",
        "comment": "Docstring Docstring2",
        "label": "Property",
        "id": "775"
    },
    {
        "raw_code": "def upload_recipe\n          # Write the raw recipe contents to a tempfile and upload\n          Tempfile.open([\"vagrant-chef-apply\", \".rb\"]) do |f|\n            f.binmode\n            f.write(config.recipe)\n            f.fsync\n            f.close\n\n            # Upload the tempfile to the guest\n            @machine.communicate.upload(f.path, target_recipe_path)\n          end",
        "comment": "Write the raw recipe contents to a tempfile and upload that to the machine.",
        "label": "Property",
        "id": "9900"
    },
    {
        "raw_code": "def partition_id\n      pipeline.partition_id\n    end",
        "comment": "All the partitionable entities connected to a pipeline belong to the same partition where the pipeline is.",
        "label": "Property",
        "id": "5799"
    },
    {
        "raw_code": "def add_default_paths\n        @search_paths.concat(DEFAULT_SEARCH_PATHS)\n        return unless File.file?(SEARCH_PATHS_FILE)\n        paths = File.readlines(SEARCH_PATHS_FILE).map(&:strip)\n        @search_paths.concat(paths)\n      end",
        "comment": "Adds paths in {SEARCH_PATHS_FILE} @since 0.5.1",
        "label": "Property",
        "id": "497"
    },
    {
        "raw_code": "def initialize(\n      compact: false,\n      title: nil,\n      svg_path: nil,\n      primary_button_text: nil,\n      primary_button_link: nil,\n      primary_button_options: {},\n      secondary_button_text: nil,\n      secondary_button_link: nil,\n      secondary_button_options: {},\n      empty_state_options: {}\n    )\n      @compact = compact\n      @title = title\n      @svg_path = svg_path.to_s\n      @primary_button_text = primary_button_text\n      @primary_button_link = primary_button_link\n      @primary_button_options = primary_button_options\n      @secondary_button_text = secondary_button_text\n      @secondary_button_link = secondary_button_link\n      @secondary_button_options = secondary_button_options\n      @empty_state_options = empty_state_options\n    end",
        "comment": "@param [Boolean] compact @param [String] title @param [String] svg_path @param [String] primary_button_text @param [String] primary_button_link @param [Hash] primary_button_options @param [String] secondary_button_text @param [String] secondary_button_link @param [Hash] secondary_button_options @param [Hash] empty_state_options",
        "label": "Property",
        "id": "5388"
    },
    {
        "raw_code": "def test; end\n          end",
        "comment": "{access_modifier}",
        "label": "Property",
        "id": "10846"
    },
    {
        "raw_code": "def summary\n      resolve_reference\n      return @summary if defined?(@summary) && @summary\n      stripped = gsub(/[\\r\\n](?![\\r\\n])/, ' ').strip\n      num_parens = 0\n      idx = length.times do |index|\n        case stripped[index, 1]\n        when \".\"\n          next_char = stripped[index + 1, 1].to_s\n          break index - 1 if num_parens <= 0 && next_char =~ /^\\s*$/\n        when \"\\r\", \"\\n\"\n          next_char = stripped[index + 1, 1].to_s\n          if next_char =~ /^\\s*$/\n            break stripped[index - 1, 1] == '.' ? index - 2 : index - 1\n          end",
        "comment": "Gets the first line of a docstring to the period or the first paragraph. @return [String] The first line or paragraph of the docstring; always ends with a period.",
        "label": "Property",
        "id": "128"
    },
    {
        "raw_code": "def self.data\n        {\n          sast: {\n            name: _('Static Application Security Testing (SAST)'),\n            short_name: _('SAST'),\n            description: _('Analyze your source code for vulnerabilities.'),\n            help_path: Gitlab::Routing.url_helpers.help_page_path('user/application_security/sast/_index.md'),\n            configuration_help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/sast/_index.md', anchor: 'configuration'),\n            type: 'sast'\n          },\n          sast_advanced: {\n            name: _('GitLab Advanced SAST'),\n            short_name: _('Advanced SAST'),\n            description: _('Analyze your source code for vulnerabilities with the GitLab Advanced SAST analyzer.'),\n            help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/sast/gitlab_advanced_sast.md'),\n            configuration_help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/sast/gitlab_advanced_sast.md',\n              anchor: 'configuration'),\n            type: 'sast_advanced'\n          },\n          sast_iac: {\n            name: _('Infrastructure as Code (IaC) Scanning'),\n            short_name: s_('ciReport|SAST IaC'),\n            description: _('Analyze your infrastructure as code configuration files for known vulnerabilities.'),\n            help_path: Gitlab::Routing.url_helpers.help_page_path('user/application_security/iac_scanning/_index.md'),\n            configuration_help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/iac_scanning/_index.md',\n              anchor: 'configuration'),\n            type: 'sast_iac'\n          },\n          dast: {\n            badge: {\n              text: _('Available on demand'),\n              tooltip_text: _(\n                'On-demand scans run outside of the DevOps cycle and find vulnerabilities in your projects'),\n              variant: 'neutral'\n            },\n            secondary: {\n              type: 'dast_profiles',\n              name: _('DAST profiles'),\n              description: s_('SecurityConfiguration|Manage profiles for use by DAST scans.'),\n              configuration_text: s_('SecurityConfiguration|Manage profiles')\n            },\n            name: _('Dynamic Application Security Testing (DAST)'),\n            short_name: s_('ciReport|DAST'),\n            description: s_('ciReport|Analyze a deployed version of your web application for known ' \\\n                            'vulnerabilities by examining it from the outside in. DAST works ' \\\n                            'by simulating external attacks on your application while it is running.'),\n            help_path: Gitlab::Routing.url_helpers.help_page_path('user/application_security/dast/_index.md'),\n            configuration_help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/dast/_index.md', anchor: 'enable-automatic-dast-run'),\n            type: 'dast',\n            anchor: 'dast'\n          },\n          dependency_scanning: {\n            name: _('Dependency Scanning'),\n            description: _('Analyze your dependencies for known vulnerabilities.'),\n            help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/dependency_scanning/_index.md'),\n            configuration_help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/dependency_scanning/_index.md', anchor: 'configuration'),\n            type: 'dependency_scanning',\n            anchor: 'dependency-scanning'\n          },\n          container_scanning: {\n            name: _('Container Scanning'),\n            description: _('Check your Docker images for known vulnerabilities.'),\n            help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/container_scanning/_index.md'),\n            configuration_help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/container_scanning/_index.md', anchor: 'configuration'),\n            type: 'container_scanning'\n          },\n          container_scanning_for_registry: {\n            name: _('Container Scanning For Registry'),\n            description: _('Run container scanning job whenever a container image with the latest tag is pushed.'),\n            help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/container_scanning/_index.md', anchor: 'container-scanning-for-registry'),\n            type: 'container_scanning_for_registry'\n          },\n          license_information_source: {\n            name: _('License information source'),\n            description: _('Define the preferred source for license information.'),\n            help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/compliance/license_scanning_of_cyclonedx_files/_index.md',\n              anchor: 'use-cyclonedx-report-as-a-source-of-license-information'),\n            type: 'license_information_source'\n          },\n          secret_push_protection: {\n            name: _('Secret push protection'),\n            description: _('Block secrets such as keys and API tokens from being pushed to your repositories. ' \\\n                           'Secret push protection is triggered when commits are pushed to a repository. ' \\\n                           'If any secrets are detected, the push is blocked.'),\n            help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/secret_detection/secret_push_protection/_index.md'),\n            type: 'secret_push_protection'\n          },\n          secret_detection: {\n            name: _('Pipeline Secret Detection'),\n            description: _('Analyze your source code and Git history for secrets by using CI/CD pipelines.'),\n            help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/secret_detection/pipeline/_index.md'),\n            configuration_help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/secret_detection/pipeline/_index.md', anchor: 'configuration'),\n            type: 'secret_detection'\n          },\n          api_fuzzing: {\n            name: _('API Fuzzing'),\n            description: _('Find bugs in your code with API fuzzing.'),\n            help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/api_fuzzing/_index.md'),\n            type: 'api_fuzzing'\n          },\n          coverage_fuzzing: {\n            name: _('Coverage Fuzzing'),\n            description: _('Find bugs in your code with coverage-guided fuzzing.'),\n            help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/coverage_fuzzing/_index.md'),\n            configuration_help_path: Gitlab::Routing.url_helpers.help_page_path(\n              'user/application_security/coverage_fuzzing/_index.md', anchor: 'enable-coverage-guided-fuzz-testing'),\n            type: 'coverage_fuzzing',\n            secondary: {\n              type: 'corpus_management',\n              name: _('Corpus Management'),\n              description: s_('SecurityConfiguration|Manage corpus files used as seed ' \\\n                              'inputs with coverage-guided fuzzing.'),\n              configuration_text: s_('SecurityConfiguration|Manage corpus')\n            }\n          }\n        }.freeze\n      end",
        "comment": "rubocop: disable Metrics/AbcSize -- Generate dynamic translation as per https://docs.gitlab.com/ee/development/i18n/externalization.html#keep-translations-dynamic",
        "label": "Property",
        "id": "2123"
    },
    {
        "raw_code": "def self.render(pdf, data: {})\n          new(pdf, data).render\n        end",
        "comment": "rubocop:enable  Layout/LineLength",
        "label": "Property",
        "id": "2417"
    },
    {
        "raw_code": "def initialize(text, author = nil, exists = false, project: nil, client: nil)\n        @text = text\n        @author = author\n        @exists = exists\n        @project = project\n        @web_endpoint = client&.web_endpoint || ::Octokit::Default.web_endpoint\n      end",
        "comment": "text - The Markdown text as a String. author - An instance of `Gitlab::GithubImport::Representation::User` exists - Boolean that indicates the user exists in the GitLab database. project - An instance of `Project`.",
        "label": "Property",
        "id": "2160"
    },
    {
        "raw_code": "def _HtmlBlockOpenP\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenP = \"<\" Spnl (\"p\" | \"P\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "15680"
    },
    {
        "raw_code": "def asset(generator_name, req, res)\n    asset_dir = @asset_dirs[generator_name]\n\n    asset_path = File.join asset_dir, req.path\n\n    if_modified_since req, res, asset_path\n\n    res.body = File.read asset_path\n\n    res.content_type = case req.path\n                       when /\\.css\\z/ then 'text/css'\n                       when /\\.js\\z/  then 'application/javascript'\n                       else                'application/octet-stream'\n                       end",
        "comment": " Serves the asset at the path in +req+ for +generator_name+ via +res+.",
        "label": "Property",
        "id": "15934"
    },
    {
        "raw_code": "def -(other)\n      if other.acts_like?(:time)\n        getutc - other.getutc\n      elsif duration_of_variable_length?(other)\n        method_missing(:-, other)\n      else\n        result = utc - other\n        result.in_time_zone(time_zone)\n      end",
        "comment": "Subtracts an interval of time and returns a new TimeWithZone object unless the other value +acts_like?+ time. In which case, it will subtract the other time and return the difference in seconds as a Float.  Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)' now = Time.zone.now # => Mon, 03 Nov 2014 00:26:28.725182881 EST -05:00 now - 1000          # => Mon, 03 Nov 2014 00:09:48.725182881 EST -05:00  If subtracting a Duration of variable length (i.e., years, months, days), move backward from #time, otherwise move backward from #utc, for accuracy when moving across DST boundaries.  For instance, a time - 24.hours will go subtract exactly 24 hours, while a time - 1.day will subtract 23-25 hours, depending on the day.  now - 24.hours      # => Sun, 02 Nov 2014 01:26:28.725182881 EDT -04:00 now - 1.day         # => Sun, 02 Nov 2014 00:26:28.725182881 EDT -04:00  If both the TimeWithZone object and the other value act like Time, a Float will be returned.  Time.zone.now - 1.day.ago # => 86399.999967 ",
        "label": "Property",
        "id": "13983"
    },
    {
        "raw_code": "def serialize\n        parts = normalize\n        return \"PT0S\" if parts.empty?\n\n        output = +\"P\"\n        output << \"#{parts[:years]}Y\"   if parts.key?(:years)\n        output << \"#{parts[:months]}M\"  if parts.key?(:months)\n        output << \"#{parts[:days]}D\"    if parts.key?(:days)\n        output << \"#{parts[:weeks]}W\"   if parts.key?(:weeks)\n        time = +\"\"\n        time << \"#{parts[:hours]}H\"     if parts.key?(:hours)\n        time << \"#{parts[:minutes]}M\"   if parts.key?(:minutes)\n        if parts.key?(:seconds)\n          time << \"#{format_seconds(parts[:seconds])}S\"\n        end",
        "comment": "Builds and returns output string.",
        "label": "Property",
        "id": "14449"
    },
    {
        "raw_code": "def open_merge_requests_refs\n      strong_memoize(:open_merge_requests_refs) do\n        # We ensure that triggering user can actually read the pipeline\n        related_merge_requests\n          .opened\n          .limit(MAX_OPEN_MERGE_REQUESTS_REFS)\n          .order(id: :desc)\n          .preload(:target_project)\n          .select { |mr| can?(user, :read_merge_request, mr) }\n          .map { |mr| mr.to_reference(project, full: true) }\n      end",
        "comment": "We cannot use `all_merge_requests`, due to race condition This returns a list of at most 4 open MRs",
        "label": "Property",
        "id": "7568"
    },
    {
        "raw_code": "def blank?\n    false\n  end",
        "comment": "No number is blank:  1.blank? # => false 0.blank? # => false  @return [false]",
        "label": "Property",
        "id": "14307"
    },
    {
        "raw_code": "def unsafe_import_url\n    if import_data && import_url.present?\n      Gitlab::UrlSanitizer.new(import_url, credentials: import_data.credentials).full_url\n    else\n      import_url\n    end",
        "comment": "WARNING - This method returns sensitive userinfo credentials of the import URL. Use `#safe_import_url` instead unless it is necessary to include sensitive credentials.  Builds an import URL including userinfo credentials from the `import_url` attribute and the encrypted `ProjectImportData#credentials`.  @see #safe_import_url  @example project.unsafe_import_url #=> \"https://user:secretpassword@example.com\"  @return [String] Unsanitized import URL.",
        "label": "Property",
        "id": "6738"
    },
    {
        "raw_code": "def preload_link_tag(source, options = {})\n        href = path_to_asset(source, skip_pipeline: options.delete(:skip_pipeline))\n        extname = File.extname(source).downcase.delete(\".\")\n        mime_type = options.delete(:type) || Template::Types[extname]&.to_s\n        as_type = options.delete(:as) || resolve_link_as(extname, mime_type)\n        crossorigin = options.delete(:crossorigin)\n        crossorigin = \"anonymous\" if crossorigin == true || (crossorigin.blank? && as_type == \"font\")\n        integrity = options[:integrity]\n        fetchpriority = options.delete(:fetchpriority)\n        nopush = options.delete(:nopush) || false\n        rel = mime_type == \"module\" || mime_type == :module ? \"modulepreload\" : \"preload\"\n        add_nonce = content_security_policy_nonce &&\n          respond_to?(:request) &&\n          request.content_security_policy_nonce_directives&.include?(\"#{as_type}-src\")\n\n        if add_nonce\n          options[:nonce] = content_security_policy_nonce\n        end",
        "comment": "Returns a link tag that browsers can use to preload the +source+. The +source+ can be the path of a resource managed by asset pipeline, a full path, or an URI.  ==== Options  * <tt>:type</tt>  - Override the auto-generated mime type, defaults to the mime type for +source+ extension. * <tt>:as</tt>  - Override the auto-generated value for as attribute, calculated using +source+ extension and mime type. * <tt>:crossorigin</tt>  - Specify the crossorigin attribute, required to load cross-origin resources. * <tt>:nopush</tt>  - Specify if the use of server push is not desired for the resource. Defaults to +false+. * <tt>:integrity</tt> - Specify the integrity attribute.  ==== Examples  preload_link_tag(\"custom_theme.css\") # => <link rel=\"preload\" href=\"/assets/custom_theme.css\" as=\"style\" type=\"text/css\" />  preload_link_tag(\"/videos/video.webm\") # => <link rel=\"preload\" href=\"/videos/video.mp4\" as=\"video\" type=\"video/webm\" />  preload_link_tag(post_path(format: :json), as: \"fetch\") # => <link rel=\"preload\" href=\"/posts.json\" as=\"fetch\" type=\"application/json\" />  preload_link_tag(\"worker.js\", as: \"worker\") # => <link rel=\"preload\" href=\"/assets/worker.js\" as=\"worker\" type=\"text/javascript\" />  preload_link_tag(\"//example.com/font.woff2\") # => <link rel=\"preload\" href=\"//example.com/font.woff2\" as=\"font\" type=\"font/woff2\" crossorigin=\"anonymous\"/>  preload_link_tag(\"//example.com/font.woff2\", crossorigin: \"use-credentials\") # => <link rel=\"preload\" href=\"//example.com/font.woff2\" as=\"font\" type=\"font/woff2\" crossorigin=\"use-credentials\" />  preload_link_tag(\"/media/audio.ogg\", nopush: true) # => <link rel=\"preload\" href=\"/media/audio.ogg\" as=\"audio\" type=\"audio/ogg\" /> ",
        "label": "Property",
        "id": "11784"
    },
    {
        "raw_code": "def enabled?\n        ::Labkit::FIPS.enabled?\n      end",
        "comment": "Returns whether we should be running in FIPS mode or not  @return [Boolean]",
        "label": "Property",
        "id": "1331"
    },
    {
        "raw_code": "def end_accepting\n    @res\n  end",
        "comment": " Returns the table of contents",
        "label": "Property",
        "id": "16356"
    },
    {
        "raw_code": "def self.default\n      by_id(Gitlab::CurrentSettings.default_syntax_highlighting_theme)\n    end",
        "comment": "Get the default Scheme  Returns a Scheme",
        "label": "Property",
        "id": "1676"
    },
    {
        "raw_code": "def ==(other_aggregation)\n        super ||\n          other_aggregation.kind_of?(self.class) &&\n          name == other_aggregation.name &&\n          !other_aggregation.options.nil? &&\n          active_record == other_aggregation.active_record\n      end",
        "comment": "Returns +true+ if +self+ and +other_aggregation+ have the same +name+ attribute, +active_record+ attribute, and +other_aggregation+ has an options hash assigned to it.",
        "label": "Property",
        "id": "12609"
    },
    {
        "raw_code": "def initialize(attributes)\n          @attributes = attributes\n        end",
        "comment": "attributes - A Hash containing the raw Protection details. The keys of this Hash (and any nested hashes) must be symbols.",
        "label": "Property",
        "id": "2248"
    },
    {
        "raw_code": "def initialize(item, alt: nil, class: \"\", size: 64, avatar_options: {})\n      @item = item\n      @alt = alt\n      @class = binding.local_variable_get(:class)\n      @size = filter_attribute(size.to_i, SIZE_OPTIONS, default: 64)\n      @avatar_options = avatar_options\n    end",
        "comment": "@param item [User, Project, Group, AvatarEmail, String] @param alt [String] text for the alt attribute @param class [String] custom CSS class(es) @param size [Integer] size in pixel @param [Hash] avatar_options",
        "label": "Property",
        "id": "5389"
    },
    {
        "raw_code": "def index_uuid\n      return nil if !@index_uuid_file\n      return @index_uuid_file.read.chomp if @index_uuid_file.file?\n      return nil\n    end",
        "comment": "Returns the UUID associated with this machine in the machine index. We only have a UUID if an ID has been set.  @return [String] UUID or nil if we don't have one yet.",
        "label": "Property",
        "id": "8783"
    },
    {
        "raw_code": "def klass\n        reflection.klass\n      end",
        "comment": "Returns the class of the target. belongs_to polymorphic overrides this to look at the polymorphic_type field on the owner.",
        "label": "Property",
        "id": "12752"
    },
    {
        "raw_code": "def all_week(start_day = Date.beginning_of_week)\n      beginning_of_week(start_day)..end_of_week(start_day)\n    end",
        "comment": "Returns a Range representing the whole week of the current date/time. Week starts on start_day, default is <tt>Date.beginning_of_week</tt> or <tt>config.beginning_of_week</tt> when set.",
        "label": "Property",
        "id": "14170"
    },
    {
        "raw_code": "def to_i\n      utc.to_i\n    end",
        "comment": "Returns the object's date and time as an integer number of seconds since the Epoch (January 1, 1970 00:00 UTC).  Time.zone.now.to_i # => 1417709320",
        "label": "Property",
        "id": "13989"
    },
    {
        "raw_code": "def build_url_hash\n          if url.nil? || url.start_with?(\"jdbc:\", \"http:\", \"https:\")\n            { url: url }\n          else\n            ConnectionUrlResolver.new(url).to_hash\n          end",
        "comment": "Return a Hash that can be merged into the main config that represents the passed in url",
        "label": "Property",
        "id": "13296"
    },
    {
        "raw_code": "def self.metrics_pid_file\n          @metrics_pid_file ||= File.join(config_dir, \"collector.pid\")\n        end",
        "comment": "Background process PID file for metrics collector  @return [String]",
        "label": "Property",
        "id": "4077"
    },
    {
        "raw_code": "def irrelevant_line(source_line)\n        source_line.blank? || (!count_comments? && comment_line?(source_line))\n      end",
        "comment": "Returns true for lines that shall not be included in the count.",
        "label": "Property",
        "id": "10421"
    },
    {
        "raw_code": "def symbolize_keys\n    transform_keys { |key| key.to_sym rescue key }\n  end",
        "comment": "Returns a new hash with all keys converted to symbols, as long as they respond to +to_sym+.  hash = { 'name' => 'Rob', 'age' => '28' }  hash.symbolize_keys # => {:name=>\"Rob\", :age=>\"28\"}",
        "label": "Property",
        "id": "14234"
    },
    {
        "raw_code": "def self.slower_app_requires\n    require 'active_support/all'\n    require 'pry'\n\n    nil\n  end",
        "comment": "@return [void]",
        "label": "Property",
        "id": "8171"
    },
    {
        "raw_code": "def filter_diff_options(options, default_options = {})\n          allowed_options = [:ignore_whitespace_change, :max_files, :max_lines,\n                             :limits, :expanded, :collect_all_paths, :generated_files, :offset_index]\n\n          if default_options\n            actual_defaults = default_options.dup\n            actual_defaults.keep_if do |key|\n              allowed_options.include?(key)\n            end",
        "comment": "Return a copy of the +options+ hash containing only recognized keys. Allowed options are:  :ignore_whitespace_change :: If true, changes in amount of whitespace will be ignored.  :max_files :: Limit how many files will patches be allowed for before collapsing  :max_lines :: Limit how many patch lines (across all files) will be allowed for before collapsing  :limits :: A hash with additional limits to check before collapsing patches. Allowed keys are: `max_bytes`, `safe_max_files`, `safe_max_lines` and `safe_max_bytes`  :expanded :: If false, patch raw data will not be included in the diff after `max_files`, `max_lines` or any of the limits in `limits` are exceeded :generated_files :: If the list of generated files is given, those files will be marked as generated.",
        "label": "Property",
        "id": "2661"
    },
    {
        "raw_code": "def to_lazy_hash\n      {}.tap do |hash|\n        assign_hash_if_value(hash, :caller_id)\n        assign_hash_if_value(hash, :root_caller_id)\n        assign_hash_if_value(hash, :remote_ip)\n        assign_hash_if_value(hash, :related_class)\n        assign_hash_if_value(hash, :feature_category)\n        assign_hash_if_value(hash, :artifact_used_cdn)\n        assign_hash_if_value(hash, :artifacts_dependencies_size)\n        assign_hash_if_value(hash, :artifacts_dependencies_count)\n        assign_hash_if_value(hash, :merge_action_status)\n        assign_hash_if_value(hash, :bulk_import_entity_id)\n        assign_hash_if_value(hash, :sidekiq_destination_shard_redis)\n        assign_hash_if_value(hash, :auth_fail_reason)\n        assign_hash_if_value(hash, :auth_fail_token_id)\n        assign_hash_if_value(hash, :auth_fail_requested_scopes)\n        assign_hash_if_value(hash, :http_router_rule_action)\n        assign_hash_if_value(hash, :http_router_rule_type)\n        assign_hash_if_value(hash, :bulk_import_entity_id)\n\n        hash[:user] = -> { username } if include_user?\n        hash[:user_id] = -> { user_id } if include_user?\n        hash[:scoped_user] = -> { scoped_user&.username } if include_scoped_user?\n        hash[:scoped_user_id] = -> { scoped_user&.id } if include_scoped_user?\n        hash[:project] = -> { project_path } if include_project?\n        hash[:organization_id] = -> { organization&.id } if set_values.include?(:organization)\n        hash[:root_namespace] = -> { root_namespace_path } if include_namespace?\n        hash[:client_id] = -> { client } if include_client?\n        hash[:pipeline_id] = -> { job&.pipeline_id } if set_values.include?(:job)\n        hash[:job_id] = -> { job&.id } if set_values.include?(:job)\n        hash[:artifact_size] = -> { artifact&.size } if set_values.include?(:artifact)\n        hash[:kubernetes_agent_id] = -> { kubernetes_agent&.id } if set_values.include?(:kubernetes_agent)\n      end",
        "comment": "rubocop: disable Metrics/AbcSize rubocop: disable Metrics/CyclomaticComplexity -- inherently leads to higher cyclomatic due to all the conditional assignments, the added complexity from adding more abstractions like `assign_hash_if_value` is not worth the tradeoff. rubocop: disable Metrics/PerceivedComplexity -- same as above",
        "label": "Property",
        "id": "1333"
    },
    {
        "raw_code": "def rescue_with_handler(exception, object: self, visited_exceptions: [])\n        visited_exceptions << exception\n\n        if handler = handler_for_rescue(exception, object: object)\n          handler.call exception\n          exception\n        elsif exception\n          if visited_exceptions.include?(exception.cause)\n            nil\n          else\n            rescue_with_handler(exception.cause, object: object, visited_exceptions: visited_exceptions)\n          end",
        "comment": "Matches an exception to a handler based on the exception class.  If no handler matches the exception, check for a handler matching the (optional) +exception.cause+. If no handler matches the exception or its cause, this returns +nil+, so you can deal with unhandled exceptions. Be sure to re-raise unhandled exceptions if this is what you expect.  begin # ... rescue => exception rescue_with_handler(exception) || raise end  Returns the exception if it was handled and +nil+ if it was not.",
        "label": "Property",
        "id": "13937"
    },
    {
        "raw_code": "def parameterize(separator: \"-\", preserve_case: false, locale: nil)\n    ActiveSupport::Inflector.parameterize(self, separator: separator, preserve_case: preserve_case, locale: locale)\n  end",
        "comment": "Replaces special characters in a string so that it may be used as part of a 'pretty' URL.  If the optional parameter +locale+ is specified, the word will be parameterized as a word of that language. By default, this parameter is set to <tt>nil</tt> and it will use the configured <tt>I18n.locale</tt>.  class Person def to_param \"#{id}-#{name.parameterize}\" end end  @person = Person.find(1) # => #<Person id: 1, name: \"Donald E. Knuth\">  <%= link_to(@person.name, person_path) %> # => <a href=\"/person/1-donald-e-knuth\">Donald E. Knuth</a>  To preserve the case of the characters in a string, use the +preserve_case+ argument.  class Person def to_param \"#{id}-#{name.parameterize(preserve_case: true)}\" end end  @person = Person.find(1) # => #<Person id: 1, name: \"Donald E. Knuth\">  <%= link_to(@person.name, person_path) %> # => <a href=\"/person/1-Donald-E-Knuth\">Donald E. Knuth</a>  See ActiveSupport::Inflector.parameterize.",
        "label": "Property",
        "id": "14372"
    },
    {
        "raw_code": "def parse_remaining_files\n        if globals.ordered_parser\n          globals.ordered_parser.parse\n          log.debug(\"Re-processing #{@file}...\")\n        end",
        "comment": "Continue parsing the remainder of the files in the +globals.ordered_parser+ object. After the remainder of files are parsed, processing will continue on the current file.  @return [void] @see Parser::OrderedParser",
        "label": "Property",
        "id": "182"
    },
    {
        "raw_code": "def comparable\n        reload! if api_response.nil?\n\n        api_resource.slice(\n          :name,\n          :path,\n          :description,\n          :tag_list,\n          :archived,\n          :issues_enabled,\n          :merge_request_enabled,\n          :wiki_enabled,\n          :jobs_enabled,\n          :snippets_enabled,\n          :shared_runners_enabled,\n          :request_access_enabled,\n          :avatar_url,\n          :created_at\n        )\n      end",
        "comment": "Return subset of fields for comparing projects  @return [Hash]",
        "label": "Property",
        "id": "4108"
    },
    {
        "raw_code": "def machine_names\n      vagrantfile.machine_names\n    end",
        "comment": "This returns a list of the configured machines for this environment. Each of the names returned by this method is valid to be used with the {#machine} method.  @return [Array<Symbol>] Configured machine names.",
        "label": "Property",
        "id": "8868"
    },
    {
        "raw_code": "def to_unsafe_h\n      convert_parameters_to_hashes(@parameters, :to_unsafe_h)\n    end",
        "comment": "Returns an unsafe, unfiltered ActiveSupport::HashWithIndifferentAccess representation of the parameters.  params = ActionController::Parameters.new({ name: \"Senjougahara Hitagi\", oddity: \"Heavy stone crab\" }) params.to_unsafe_h # => {\"name\"=>\"Senjougahara Hitagi\", \"oddity\" => \"Heavy stone crab\"}",
        "label": "Property",
        "id": "11355"
    },
    {
        "raw_code": "def count_online_runners\n            within_element(\"runner-stats-online\") do\n              find_element(\"non-animated-value\").text.to_i\n            end",
        "comment": "Returns count of online runners  @return [Integer]",
        "label": "Property",
        "id": "4295"
    },
    {
        "raw_code": "def ancestor_clusters\n    strong_memoize(:ancestor_clusters) do\n      Clusters::Cluster.ancestor_clusters_for_clusterable(clusterable)\n    end",
        "comment": "This unfortunately returns an Array, not a Relation!",
        "label": "Property",
        "id": "7929"
    },
    {
        "raw_code": "def fullpath\n      @fullpath ||= super\n    end",
        "comment": "Returns the `String` full path including params of the last URL requested.  # get \"/articles\" request.fullpath # => \"/articles\"  # get \"/articles?page=2\" request.fullpath # => \"/articles?page=2\"",
        "label": "Property",
        "id": "11456"
    },
    {
        "raw_code": "def escape_bytea(value)\n          valid_raw_connection.escape_bytea(value) if value\n        end",
        "comment": "Escapes binary strings for bytea input to the database.",
        "label": "Property",
        "id": "13216"
    },
    {
        "raw_code": "def gcs_bucket\n          @gcs_bucket ||= ENV['QA_METRICS_GCS_BUCKET_NAME'] ||\n            raise('Missing QA_METRICS_GCS_BUCKET_NAME env variable')\n        end",
        "comment": "Get GCS Bucket Name or raise error if missing  @return [String]",
        "label": "Property",
        "id": "4797"
    },
    {
        "raw_code": "def submodule_urls_for(ref)\n        wrapped_gitaly_errors do\n          gitaly_submodule_urls_for(ref)\n        end",
        "comment": "Returns path to url mappings for submodules  Ex. @repository.submodule_urls_for('master') # => { 'rack' => 'git@localhost:rack.git' } ",
        "label": "Property",
        "id": "2641"
    },
    {
        "raw_code": "def group(*args)\n      check_if_method_has_arguments!(__callee__, args)\n      spawn.group!(*args)\n    end",
        "comment": "Allows to specify a group attribute:  User.group(:name) # SELECT \"users\".* FROM \"users\" GROUP BY name  Returns an array with distinct records based on the +group+ attribute:  User.select([:id, :name]) # => [#<User id: 1, name: \"Oscar\">, #<User id: 2, name: \"Oscar\">, #<User id: 3, name: \"Foo\">]  User.group(:name) # => [#<User id: 3, name: \"Foo\", ...>, #<User id: 2, name: \"Oscar\", ...>]  User.group('name AS grouped_name, age') # => [#<User id: 3, name: \"Foo\", age: 21, ...>, #<User id: 2, name: \"Oscar\", age: 21, ...>, #<User id: 5, name: \"Foo\", age: 23, ...>]  Passing in an array of attributes to group by is also supported.  User.select([:id, :first_name]).group(:id, :first_name).first(3) # => [#<User id: 1, first_name: \"Bill\">, #<User id: 2, first_name: \"Earl\">, #<User id: 3, first_name: \"Beto\">]",
        "label": "Property",
        "id": "13401"
    },
    {
        "raw_code": "def success?\n            @result&.status&.success? || false\n          end",
        "comment": "Return whether the execution was a success or not  @return [Boolean] whether the execution was a success",
        "label": "Property",
        "id": "1059"
    },
    {
        "raw_code": "def _ListBlock\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = _BlankLine()\n      _tmp = _tmp ? nil : true\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ListBlock = !@BlankLine Line:a ListBlockLine*:c { [a, *c] }",
        "label": "Property",
        "id": "15618"
    },
    {
        "raw_code": "def safe_model?(model, excluded_attributes, parent)\n    excluded_attributes += associations_for(model)\n    parsed_model_attributes = parsed_attributes(model.name.underscore, model.attribute_names)\n\n    (parsed_model_attributes - parent.keys - excluded_attributes).empty?\n  end",
        "comment": "Compares model attributes with those found in the hash and returns true if there is a match, ignoring some excluded attributes.",
        "label": "Property",
        "id": "8360"
    },
    {
        "raw_code": "def self.attribute_map\n      {\n        :'project_id' => :'projectId',\n        :'event_id' => :'eventId',\n        :'timestamp' => :'timestamp',\n        :'level' => :'level',\n        :'message' => :'message',\n        :'release' => :'release',\n        :'environment' => :'environment',\n        :'platform' => :'platform'\n      }\n    end",
        "comment": "Attribute mapping from ruby-style variable name to JSON key.",
        "label": "Property",
        "id": "862"
    },
    {
        "raw_code": "def generate_random_key(length: key_length)\n        SecureRandom.random_bytes(length)\n      end",
        "comment": "Returns a random key. The key will have a size in bytes of +:length+ (configured +Cipher+'s length by default)",
        "label": "Property",
        "id": "13318"
    },
    {
        "raw_code": "def compact_blank!\n    # use delete_if rather than reject! because it always returns self even if nothing changed\n    delete_if { |_k, v| v.blank? }\n  end",
        "comment": "Removes all blank values from the +Hash+ in place and returns self. Uses Object#blank? for determining if a value is blank.  h = { a: \"\", b: 1, c: nil, d: [], e: false, f: true } h.compact_blank! # => { b: 1, f: true }",
        "label": "Property",
        "id": "14079"
    },
    {
        "raw_code": "def synced_folder_capabilities\n          results = Hash.new { |h, k| h[k] = Registry.new }\n\n          @registered.each do |plugin|\n            plugin.components.synced_folder_capabilities.each do |synced_folder, caps|\n              results[synced_folder].merge!(caps)\n            end",
        "comment": "This returns all the registered synced folder capabilities.  @return [Hash]",
        "label": "Property",
        "id": "9081"
    },
    {
        "raw_code": "def self.parse(code)\n    lex = self.new(code)\n    tokens = []\n    begin\n      while tk = lex.get_squashed_tk\n        tokens.push tk\n      end",
        "comment": "Returns tokens parsed from +code+.",
        "label": "Property",
        "id": "16137"
    },
    {
        "raw_code": "def deterministic_encrypted_attributes\n          @deterministic_encrypted_attributes ||= encrypted_attributes&.find_all do |attribute_name|\n            type_for_attribute(attribute_name).deterministic?\n          end",
        "comment": "Returns the list of deterministic encryptable attributes in the model class.",
        "label": "Property",
        "id": "13306"
    },
    {
        "raw_code": "def wsl_path?(path)\n          wsl? && !path.to_s.downcase.start_with?(\"/mnt/\")\n        end",
        "comment": "Determine if given path is within the WSL rootfs. Returns true if within the subsystem, or false if outside the subsystem.  @param [String] path Path to check @return [Boolean] path is within subsystem",
        "label": "Property",
        "id": "9206"
    },
    {
        "raw_code": "def parse_file(filename)\n    encoding = @options.encoding\n    filename = filename.encode encoding\n\n    @stats.add_file filename\n\n    return if RDoc::Parser.binary? filename\n\n    content = RDoc::Encoding.read_file filename, encoding\n\n    return unless content\n\n    filename_path = Pathname(filename).expand_path\n    begin\n      relative_path = filename_path.relative_path_from @options.root\n    rescue ArgumentError\n      relative_path = filename_path\n    end",
        "comment": " Parses +filename+ and returns an RDoc::TopLevel",
        "label": "Property",
        "id": "16017"
    },
    {
        "raw_code": "def self.openapi_nullable\n      Set.new([\n      ])\n    end",
        "comment": "List of attributes with nullable: true",
        "label": "Property",
        "id": "899"
    },
    {
        "raw_code": "def accepts\n        fetch_header(\"action_dispatch.request.accepts\") do |k|\n          header = get_header(\"HTTP_ACCEPT\").to_s.strip\n\n          v = if header.empty?\n            [content_mime_type]\n          else\n            Mime::Type.parse(header)\n          end",
        "comment": "Returns the accepted MIME type for the request.",
        "label": "Property",
        "id": "11432"
    },
    {
        "raw_code": "def flush(minimum_idle = @idle_timeout)\n        return if minimum_idle.nil?\n\n        removed_connections = synchronize do\n          return if self.discarded?\n\n          idle_connections = @connections.select do |conn|\n            !conn.in_use? && conn.seconds_idle >= minimum_idle\n          end.sort_by { |conn| -conn.seconds_idle } # sort longest idle first\n\n          # Don't go below our configured pool minimum unless we're flushing\n          # everything\n          idles_to_retain =\n            if minimum_idle > 0\n              @min_connections - (@connections.size - idle_connections.size)\n            else\n              0\n            end",
        "comment": "Disconnect all connections that have been idle for at least +minimum_idle+ seconds. Connections currently checked out, or that were checked in less than +minimum_idle+ seconds ago, are unaffected.",
        "label": "Property",
        "id": "13029"
    },
    {
        "raw_code": "def references_in(text, pattern = object_class.reference_pattern)\n          Gitlab::Utils::Gsub.gsub_with_limit(text, pattern, limit: Banzai::Filter::FILTER_ITEM_LIMIT) do |match_data|\n            if ident = identifier(match_data)\n              yield match_data[0], ident, match_data.named_captures['project'], match_data.named_captures['namespace'],\n                match_data\n            else\n              match_data[0]\n            end",
        "comment": "Public: Find references in text (like `!123` for merge requests)  references_in(text) do |match, id, project_ref, matches| object = find_object(project_ref, id) \"<a href=...>#{object.to_reference}</a>\" end  text - String text to search.  Yields the String match, the Integer referenced object ID, an optional String of the external project reference, and all of the matchdata.  Returns a String replaced with the return of the block.",
        "label": "Property",
        "id": "3482"
    },
    {
        "raw_code": "def initialize(project)\n        @project = project\n\n        @page_counter = Gitlab::Import::PageCounter.new(project, collection_method, 'bitbucket-server-importer')\n        @already_processed_cache_key =\n          format(ALREADY_PROCESSED_CACHE_KEY, project: project.id, collection: collection_method)\n        @job_waiter_cache_key =\n          format(JOB_WAITER_CACHE_KEY, project: project.id, collection: collection_method)\n        @job_waiter_remaining_cache_key = format(JOB_WAITER_REMAINING_CACHE_KEY, project: project.id,\n          collection: collection_method)\n\n        # The enqueued job counter is used to calculate job delays and distribute\n        # them over time. When the stage worker restarts, the counter resets to\n        # prevent jobs from being queued too far into the future. Such logic may\n        # result in more jobs being executed when the stage worker resumes. An\n        # alternative solution would complicate the delay logic, so for simplicity\n        # we accept more jobs being executed.\n        @enqueued_job_counter = 0\n      end",
        "comment": "project - An instance of `Project`.",
        "label": "Property",
        "id": "1816"
    },
    {
        "raw_code": "def self.description(value=UNSET_VALUE)\n          get_or_set(:description, value)\n        end",
        "comment": "Sets a human-friendly description of the plugin.  @param [String] value Description of the plugin. @return [String] Description of the plugin.",
        "label": "Property",
        "id": "9102"
    },
    {
        "raw_code": "def saved_changes\n        mutations_before_last_save.changes\n      end",
        "comment": "Returns a hash containing all the changes that were just saved.",
        "label": "Property",
        "id": "12843"
    },
    {
        "raw_code": "def ensure_token!(token_owner_record)\n        reset_token!(token_owner_record) unless token_set?(token_owner_record)\n        get_token(token_owner_record)\n      end",
        "comment": "Returns a token, but only saves when the database is in read & write mode",
        "label": "Property",
        "id": "3855"
    },
    {
        "raw_code": "def valid?\n      true\n    end",
        "comment": "Check to see if the all the properties in the model are valid @return true if the model is valid",
        "label": "Property",
        "id": "885"
    },
    {
        "raw_code": "def member_tag_for_member(klass, member, type = :read)\n    specific_tag = type == :read ? :attr_reader : :attr_writer\n    (klass.tags(specific_tag) + klass.tags(:attr)).find {|tag| tag.name == member }\n  end",
        "comment": "Extracts the user's defined @member tag for a given class and its member. Returns nil if the user did not define a @member tag for this struct entry.  @param [ClassObject] klass the class whose tags we're searching @param [String] member the name of the struct member we need @param [Symbol] type reader method, or writer method? @return [Tags::Tag, nil] the tag matching the request, or nil if not found",
        "label": "Property",
        "id": "197"
    },
    {
        "raw_code": "def to_s\n      to_hash.to_s\n    end",
        "comment": "Returns the string representation of the object @return [String] String presentation of the object",
        "label": "Property",
        "id": "858"
    },
    {
        "raw_code": "def file_fixture(fixture_name)\n        path = Pathname.new(File.join(file_fixture_path, fixture_name))\n\n        if path.exist?\n          path\n        else\n          msg = \"the directory '%s' does not contain a file named '%s'\"\n          raise ArgumentError, msg % [file_fixture_path, fixture_name]\n        end",
        "comment": "Returns a +Pathname+ to the fixture file named +fixture_name+.  Raises +ArgumentError+ if +fixture_name+ can't be found.",
        "label": "Property",
        "id": "14537"
    },
    {
        "raw_code": "def self.each_response_header(sock)\n      start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n      key = value = nil\n      while true\n        uses_buffered_io = sock.is_a?(Gitlab::HTTP_V2::BufferedIo)\n\n        line = uses_buffered_io ? sock.readuntil(\"\\n\", true, start_time) : sock.readuntil(\"\\n\", true)\n        line = line.sub(/\\s{0,10}\\z/, '')\n        break if line.empty?\n        if line[0] == ?\\s or line[0] == ?\\t and value\n          # rubocop:disable Gitlab/NoCodeCoverageComment\n          # :nocov:\n          value << ' ' unless value.empty?\n          value << line.strip\n          # :nocov:\n          # rubocop:enable Gitlab/NoCodeCoverageComment\n        else\n          yield key, value if key\n          key, value = line.strip.split(/\\s{0,10}:\\s{0,10}/, 2)\n          raise Net::HTTPBadResponse, 'wrong header line format' if value.nil?\n        end",
        "comment": "rubocop: disable Cop/LineBreakAfterGuardClauses rubocop: disable Cop/LineBreakAroundConditionalBlock rubocop: disable Layout/EmptyLineAfterGuardClause rubocop: disable Style/AndOr rubocop: disable Style/CharacterLiteral rubocop: disable Style/InfiniteLoop Original method: https://github.com/ruby/ruby/blob/v2_7_5/lib/net/http/response.rb#L54-L69  Our changes: - Pass along the `start_time` to `Gitlab::HTTP_V2::BufferedIo`, so we can raise a timeout if reading the headers takes too long. - Limit the regexes to avoid ReDoS attacks.",
        "label": "Property",
        "id": "1207"
    },
    {
        "raw_code": "def supports_streaming?\n      handler.respond_to?(:supports_streaming?) && handler.supports_streaming?\n    end",
        "comment": "Returns whether the underlying handler supports streaming. If so, a streaming buffer *may* be passed when it starts rendering.",
        "label": "Property",
        "id": "11754"
    },
    {
        "raw_code": "def nonexistent_integration_types_for(\n          scope,\n          include_group_specific: false,\n          include_instance_specific: false)\n          # Using #map instead of #pluck to save one query count. This is because\n          # ActiveRecord loaded the object here, so we don't need to query again later.\n          available_integration_types(\n            include_project_specific: false,\n            include_group_specific: include_group_specific,\n            include_instance_specific: include_instance_specific\n          ) - scope.map(&:type)\n        end",
        "comment": "Returns a list of integration types that do not exist in the given scope. Example: [\"AsanaService\", ...]",
        "label": "Property",
        "id": "7460"
    },
    {
        "raw_code": "def host_keys_changed?\n    cleanup(known_hosts) != cleanup(compare_host_keys)\n  end",
        "comment": "Returns true if the known_hosts data differs from the version passed in at initialization as `compare_host_keys`. Comments, ordering, etc, is ignored",
        "label": "Property",
        "id": "6791"
    },
    {
        "raw_code": "def down\n    create_table TABLE_NAME do |t|\n      t.timestamps_with_timezone null: false\n      t.float :threshold, null: false\n      t.integer :operator, null: false\n      t.bigint :environment_id, null: false\n      t.bigint :project_id, null: false\n      t.bigint :prometheus_metric_id, null: false\n      t.text :runbook_url, limit: 255\n\n      t.index [:project_id, :prometheus_metric_id, :environment_id], name: UNIQUE_INDEX_NAME, unique: true\n      t.index :environment_id, name: ENVIRONMENT_INDEX_NAME\n      t.index :prometheus_metric_id, name: METRIC_INDEX_NAME\n    end",
        "comment": "Original SQL:  CREATE TABLE prometheus_alerts ( id bigint NOT NULL, created_at timestamp with time zone NOT NULL, updated_at timestamp with time zone NOT NULL, threshold double precision NOT NULL, operator integer NOT NULL, environment_id bigint NOT NULL, project_id bigint NOT NULL, prometheus_metric_id bigint NOT NULL, runbook_url text, CONSTRAINT check_cb76d7e629 CHECK ((char_length(runbook_url) <= 255)) );  CREATE SEQUENCE prometheus_alerts_id_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1;  ALTER SEQUENCE prometheus_alerts_id_seq OWNED BY prometheus_alerts.id;  CREATE UNIQUE INDEX index_prometheus_alerts_metric_environment ON prometheus_alerts USING btree (project_id, prometheus_metric_id, environment_id);  CREATE INDEX index_prometheus_alerts_on_environment_id ON prometheus_alerts USING btree (environment_id);  CREATE INDEX index_prometheus_alerts_on_prometheus_metric_id ON prometheus_alerts USING btree (prometheus_metric_id); ",
        "label": "Property",
        "id": "4919"
    },
    {
        "raw_code": "def import(branch, run_type, bucket: DEFAULT_BUCKET, file_name: DEFAULT_FILE_NAME)\n          prefix = \"#{branch}/#{run_type}/#{file_name}\"\n\n          filename = code_paths_mapping_file(prefix, bucket)\n\n          logger.info(\"The mapping file fetched in import: #{filename}\")\n          file = client.get_object(bucket, filename)\n          JSON.parse(file[:body])\n        rescue StandardError => e\n          logger.error(\"Failed to download code paths mapping from GCS. Error: #{e}\")\n          logger.error(\"Backtrace: #{e.backtrace}\")\n          nil # Ensure it returns nil in case of GCS errors\n        end",
        "comment": "Import code path mappings from GCP  @param [String] branch - branch name @param [String] run_type - run type @param [String] bucket - custom bucket name (optional) @param [String] file_name - custom file name base (optional) @return [Hash]",
        "label": "Property",
        "id": "4821"
    },
    {
        "raw_code": "def select_rows(arel, name = nil, binds = [], async: false)\n        select_all(arel, name, binds, async: async).then(&:rows)\n      end",
        "comment": "Returns an array of arrays containing the field values. Order is the same as that returned by +columns+.",
        "label": "Property",
        "id": "13056"
    },
    {
        "raw_code": "def polymorphic_name\n        store_full_class_name ? base_class.name : base_class.name.demodulize\n      end",
        "comment": "Returns the value to be stored in the polymorphic type column for Polymorphic Associations.",
        "label": "Property",
        "id": "12473"
    },
    {
        "raw_code": "def destroyed_by_association\n      @destroyed_by_association\n    end",
        "comment": "Returns the association for the parent being destroyed.  Used to avoid updating the counter cache unnecessarily.",
        "label": "Property",
        "id": "12381"
    },
    {
        "raw_code": "def self.count\n      available_schemes.size\n    end",
        "comment": "Returns the number of defined Schemes",
        "label": "Property",
        "id": "1675"
    },
    {
        "raw_code": "def self.set_includes?(raw_key, value)\n          validate_redis_value!(value)\n\n          key = cache_key_for(raw_key)\n\n          with_redis do |redis|\n            redis.sismember(key, value || value.to_s)\n          end",
        "comment": "Returns true if the given value is present in the set.  raw_key - The key of the set to check. value - The value to check for.",
        "label": "Property",
        "id": "1944"
    },
    {
        "raw_code": "def with_statement_timeout(timeout, connection:)\n      # Force a positive value and a minimum of 1ms for very small values.\n      timeout = (timeout * 1000).abs.ceil\n\n      raise ArgumentError, 'Using a timeout of `0` means to disable statement timeout.' if timeout == 0\n\n      previous_timeout = connection.select_value('SHOW statement_timeout')\n\n      connection.execute(format(%(SET LOCAL statement_timeout = '%s'), timeout))\n\n      yield\n    ensure\n      begin\n        connection.execute(format(%(SET LOCAL statement_timeout = '%s'), previous_timeout))\n      rescue ActiveRecord::StatementInvalid\n        # After a transaction was canceled/aborted due to e.g. a statement\n        # timeout commands are ignored and will raise in PG::InFailedSqlTransaction.\n        # We can safely ignore this error because the statement timeout was set\n        # for the currrent transaction which will be closed anyway.\n      end",
        "comment": "Set statement timeout temporarily. Useful when testing query timeouts.  Note that this method cannot restore the timeout if a query was canceled due to e.g. a statement timeout. Refrain from using this transaction in these situations.  @param timeout - Statement timeout in seconds  Example:  with_statement_timeout(0.1) do model.select('pg_sleep(0.11)') end",
        "label": "Property",
        "id": "8532"
    },
    {
        "raw_code": "def recover_machine(state)\n      entry = @env.machine_index.get(index_uuid)\n      if entry\n        @env.machine_index.release(entry)\n        return entry\n      end",
        "comment": "Returns the state of this machine. The state is queried from the backing provider, so it can be any arbitrary symbol.  @param [Symbol] state of machine @return [Entry] entry of recovered machine",
        "label": "Property",
        "id": "8788"
    },
    {
        "raw_code": "def self.in_use?\n      transaction { exists? }\n    rescue ActiveRecord::StatementInvalid\n      false\n    end",
        "comment": "Returns true if there are any replication slots in use. PostgreSQL-compatible databases such as Aurora don't support replication slots, so this will return false as well.",
        "label": "Property",
        "id": "7666"
    },
    {
        "raw_code": "def self.cleanup_disks(machine, defined_disks, disk_meta_file)\n          return if disk_meta_file.values.flatten.empty?\n\n          handle_cleanup_disk(machine, defined_disks, disk_meta_file[\"disk\"])\n          handle_cleanup_dvd(machine, defined_disks, disk_meta_file[\"dvd\"])\n          # TODO: Floppy disks\n        end",
        "comment": "@param [Vagrant::Machine] machine @param [VagrantPlugins::Kernel_V2::VagrantConfigDisk] defined_disks @param [Hash] disk_meta_file - A hash of all the previously defined disks from the last configure_disk action",
        "label": "Property",
        "id": "9621"
    },
    {
        "raw_code": "def remote_ip\n      @remote_ip ||= (get_header(\"action_dispatch.remote_ip\") || ip).to_s\n    end",
        "comment": "Returns the IP address of client as a `String`, usually set by the RemoteIp middleware.",
        "label": "Property",
        "id": "11462"
    },
    {
        "raw_code": "def self.build_from_hash(attributes)\n      new.build_from_hash(attributes)\n    end",
        "comment": "Builds the object from hash @param [Hash] attributes Model attributes in the form of hash @return [Object] Returns the model itself",
        "label": "Property",
        "id": "907"
    },
    {
        "raw_code": "def full_name\n    @relative_name\n  end",
        "comment": " Returns the relative name of this file",
        "label": "Property",
        "id": "16724"
    },
    {
        "raw_code": "def execute(issue, commit: nil, notifications: true, system_note: true, skip_authorization: false, status: nil)\n      unless can_close?(issue, skip_authorization: skip_authorization)\n        log_failed_auth(issue, commit)\n        return issue\n      end",
        "comment": "Closes the supplied issue if the current user is able to do so.",
        "label": "Property",
        "id": "5724"
    },
    {
        "raw_code": "def module?\n    true\n  end",
        "comment": " This is a module, returns true",
        "label": "Property",
        "id": "16778"
    },
    {
        "raw_code": "def track_record_deletions_override_table_name(table_identifier, parent_table = nil)\n          table_name = table_identifier.to_s.split('.').last\n          parent_table ||= table_name\n\n          execute(<<~SQL.squish)\n            CREATE TRIGGER #{record_deletion_trigger_name(table_name)}\n            AFTER DELETE ON #{table_identifier} REFERENCING OLD TABLE AS old_table\n            FOR EACH STATEMENT\n            EXECUTE FUNCTION\n            #{INSERT_FUNCTION_NAME_OVERRIDE_TABLE}(#{connection.quote(parent_table)});\n          SQL\n        end",
        "comment": "This is used to track deletions on partitioned tables and their partitions. parent_table is the table name that is insert into loose_foreign_keys_deleted_records table it defaults to the table_name, and that's for when we track deletions on partitioned (parent) tables.",
        "label": "Property",
        "id": "3130"
    },
    {
        "raw_code": "def lock\n        if lock_file.flock(File::LOCK_EX|File::LOCK_NB) === false\n          raise Errors::VagrantLocked, lock_file_path: @mutex_path\n        end",
        "comment": "Attempt to acquire the lock",
        "label": "Property",
        "id": "9181"
    },
    {
        "raw_code": "def gcs_bucket\n          @gcs_bucket ||= ENV['QA_METRICS_GCS_BUCKET_NAME'] ||\n            raise('Missing QA_METRICS_GCS_BUCKET_NAME env variable')\n        end",
        "comment": "Get GCS Bucket Name or raise error if missing  @return [String]",
        "label": "Property",
        "id": "4627"
    },
    {
        "raw_code": "def _to_hash(value)\n      if value.is_a?(Array)\n        value.compact.map { |v| _to_hash(v) }\n      elsif value.is_a?(Hash)\n        {}.tap do |hash|\n          value.each { |k, v| hash[k] = _to_hash(v) }\n        end",
        "comment": "Outputs non-array value in the form of hash For object, use to_hash. Otherwise, just return the value @param [Object] value Any valid value @return [Hash] Returns the value in the form of hash",
        "label": "Property",
        "id": "965"
    },
    {
        "raw_code": "def prev_month(months = 1)\n    advance(months: -months)\n  end",
        "comment": "Returns a new time the specified number of months ago.",
        "label": "Property",
        "id": "14411"
    },
    {
        "raw_code": "def installed_plugins\n        system = {}\n        if @system_file\n          @system_file.installed_plugins.each do |k, v|\n            system[k] = v.merge(\"system\" => true)\n          end",
        "comment": "This returns the list of plugins that should be enabled.  @return [Hash]",
        "label": "Property",
        "id": "8959"
    },
    {
        "raw_code": "def in_milliseconds\n    self * 1000\n  end",
        "comment": "Returns the number of milliseconds equivalent to the seconds provided. Used with the standard time durations.  2.in_milliseconds # => 2000 1.hour.in_milliseconds # => 3600000",
        "label": "Property",
        "id": "14298"
    },
    {
        "raw_code": "def id?\n        _query_attribute(@primary_key)\n      end",
        "comment": "Queries the primary key column's value. If the primary key is composite, all primary key column values must be queryable.",
        "label": "Property",
        "id": "12854"
    },
    {
        "raw_code": "def yesterday\n      today - 1\n    end",
        "comment": "Returns the previous date in this time zone.",
        "label": "Property",
        "id": "14577"
    },
    {
        "raw_code": "def in_finder?(node)\n      in_app_directory?(node, 'finders')\n    end",
        "comment": "Returns true if the given node resides in app/finders or ee/app/finders.",
        "label": "Property",
        "id": "3883"
    },
    {
        "raw_code": "def register(key, &block)\n      raise ArgumentError, \"block required\" if !block_given?\n      @items[key] = block\n    end",
        "comment": "Register a key with a lazy-loaded value.  If a key with the given name already exists, it is overwritten.",
        "label": "Property",
        "id": "8742"
    },
    {
        "raw_code": "def set_context(...)\n      ActiveSupport::ExecutionContext.set(...)\n    end",
        "comment": "Update the execution context that is accessible to error subscribers. Any context passed to #handle, #record, or #report will be merged with the context set here.  Rails.error.set_context(section: \"checkout\", user_id: @user.id) ",
        "label": "Property",
        "id": "13845"
    },
    {
        "raw_code": "def reference_pattern\n      raise NotImplementedError, \"#{self} does not implement #{__method__}\"\n    end",
        "comment": "Regexp pattern used to match references to this object  This must be overridden by the including class.  Returns a Regexp",
        "label": "Property",
        "id": "7258"
    },
    {
        "raw_code": "def filter_negated_items(items)\n    items = by_negated_milestone(items)\n    items = by_negated_release(items)\n    items = by_negated_my_reaction_emoji(items)\n    by_negated_iids(items)\n  end",
        "comment": "Negates all params found in `negatable_params`",
        "label": "Property",
        "id": "7903"
    },
    {
        "raw_code": "def slice!(*keys)\n      @parameters.slice!(*keys)\n      self\n    end",
        "comment": "Returns the current `ActionController::Parameters` instance which contains only the given `keys`.",
        "label": "Property",
        "id": "11371"
    },
    {
        "raw_code": "def comparable\n        reload! unless api_response\n\n        api_response.slice(\n          :name,\n          :description,\n          :description_html,\n          :color,\n          :text_color,\n          :subscribed\n        )\n      end",
        "comment": "Return subset of fields for comparing labels  @return [Hash]",
        "label": "Property",
        "id": "4148"
    },
    {
        "raw_code": "def encoding\n          query_value(\"SELECT pg_encoding_to_char(encoding) FROM pg_database WHERE datname = current_database()\", \"SCHEMA\")\n        end",
        "comment": "Returns the current database encoding format.",
        "label": "Property",
        "id": "13243"
    },
    {
        "raw_code": "def order_votes(emoji_name, direction, base_class_name = base_class.name, awardable_id_column = :id)\n      awardable_table = self.arel_table\n      awards_table = AwardEmoji.arel_table\n\n      join_clause = awardable_table\n        .join(awards_table, Arel::Nodes::OuterJoin)\n        .on(awards_table[:awardable_id].eq(awardable_table[awardable_id_column])\n              .and(awards_table[:awardable_type].eq(base_class_name).and(awards_table[:name].eq(emoji_name))))\n        .join_sources\n\n      joins(join_clause).group(awardable_table[:id]).reorder(\n        Arel.sql(\"COUNT(award_emoji.id) #{direction}\")\n      )\n    end",
        "comment": "Order votes by emoji, optional sort order param `descending` defaults to true",
        "label": "Property",
        "id": "7259"
    },
    {
        "raw_code": "def initialize(resource_name, key, data)\n            super(resource_name)\n\n            @key = key\n            @data = data\n          end",
        "comment": "Generic kubernetes secret resource  @param [String] resource_name @param [String] key @param [String] data",
        "label": "Property",
        "id": "3977"
    },
    {
        "raw_code": "def valid_brackets?(string = '', allow_nested: true)\n      # remove everything except brackets\n      brackets = string.remove(/[^\\[\\]]/)\n\n      return true if brackets.empty?\n      # balanced counts check\n      return false if brackets.size.odd?\n\n      unless allow_nested\n        # nested brackets check\n        return false if brackets.include?('[[') || brackets.include?(']]') # rubocop:disable Style/SoleNestedConditional\n      end",
        "comment": "Check for valid brackets (`[` and `]`) in a string using this aspects: * open brackets count == closed brackets count * (optionally) reject nested brackets via `allow_nested: false` * open / close brackets coherence, eg. ][[] -> invalid",
        "label": "Property",
        "id": "1220"
    },
    {
        "raw_code": "def extract_subdomains(host, tld_length)\n          if named_host?(host)\n            extract_subdomains_from(host, tld_length)\n          else\n            []\n          end",
        "comment": "Returns the subdomains of a host as an Array given the domain level.  # Top-level domain example extract_subdomains('www.example.com', 1) # => [\"www\"] # Second-level domain example extract_subdomains('dev.www.example.co.uk', 2) # => [\"dev\", \"www\"]",
        "label": "Property",
        "id": "11494"
    },
    {
        "raw_code": "def block *contents\n    @RM::BlockQuote.new(*contents)\n  end",
        "comment": " Shortcut for RDoc::Markup::BlockQuote.new with +contents+",
        "label": "Property",
        "id": "16872"
    },
    {
        "raw_code": "def success_mark\n          @success_mark ||= colorize(TTY::Spinner::TICK, :green)\n        end",
        "comment": "Success mark  @return [String]",
        "label": "Property",
        "id": "4057"
    },
    {
        "raw_code": "def suppress_messages\n      save, self.verbose = verbose, false\n      yield\n    ensure\n      self.verbose = save\n    end",
        "comment": "Takes a block as an argument and suppresses any output generated by the block.",
        "label": "Property",
        "id": "12497"
    },
    {
        "raw_code": "def already_restored?(relation_item)\n          !relation_item.is_a?(Hash)\n        end",
        "comment": "Since we update the data hash in place as we restore relation items, and since we also de-duplicate items, we might encounter items that have already been restored in a previous iteration.",
        "label": "Property",
        "id": "2846"
    },
    {
        "raw_code": "def add_file(absolute_name, relative_name: absolute_name, parser: nil)\n    unless top_level = @files_hash[relative_name] then\n      top_level = RDoc::TopLevel.new absolute_name, relative_name\n      top_level.parser = parser if parser\n      top_level.store = self\n      @files_hash[relative_name] = top_level\n      @text_files_hash[relative_name] = top_level if top_level.text?\n    end",
        "comment": " Adds the file with +name+ as an RDoc::TopLevel to the store.  Returns the created RDoc::TopLevel.",
        "label": "Property",
        "id": "15844"
    },
    {
        "raw_code": "def parse_arguments(*args)\n        super(*args)\n\n        # Last minute modifications\n        self.files = Parser::SourceParser::DEFAULT_PATH_GLOB if files.empty?\n        files.delete_if {|x| x =~ /\\A\\s*\\Z/ } # remove empty ones\n        readme = Dir.glob('README{,*[^~]}').\n          select {|f| extra_file_valid?(f)}.\n          sort_by {|r| [r.count('.'), r.index('.'), r] }.first\n        readme ||= Dir.glob(files.first).first if options.onefile && !files.empty?\n        options.readme ||= CodeObjects::ExtraFileObject.new(readme) if readme && extra_file_valid?(readme)\n        options.files.unshift(options.readme).uniq! if options.readme\n\n        Tags::Library.visible_tags -= hidden_tags\n        add_visibility_verifier\n        add_api_verifier\n\n        apply_locale\n\n        # US-ASCII is invalid encoding for onefile\n        if defined?(::Encoding) && options.onefile\n          if ::Encoding.default_internal == ::Encoding::US_ASCII\n            log.warn \"--one-file is not compatible with US-ASCII encoding, using ASCII-8BIT\"\n            ::Encoding.default_external, ::Encoding.default_internal = ['ascii-8bit'] * 2\n          end",
        "comment": "Parses commandline arguments @param [Array<String>] args the list of arguments @return [Boolean] whether or not arguments are valid @since 0.5.6",
        "label": "Property",
        "id": "528"
    },
    {
        "raw_code": "def key_for(source, seed = name)\n    # If FIPS is enabled, we simply call the method available in the gem, which\n    # uses SHA2.\n    return super if Gitlab::FIPS.enabled?\n\n    # If FIPS isn't enabled, we use the legacy MD5 logic to keep existing\n    # experiment events working.\n    source = source.keys + source.values if source.is_a?(Hash)\n    Digest::MD5.hexdigest(Array(source).map { |v| identify(v) }.unshift(seed).join('|'))\n  end",
        "comment": "This is deprecated logic as of v0.6.0 and should eventually be removed, but needs to stay intact for actively running experiments. The new strategy utilizes Digest::SHA2, a secret seed, and generates a 64-byte string.  https://gitlab.com/gitlab-org/gitlab/-/issues/334590  @deprecated",
        "label": "Property",
        "id": "6266"
    },
    {
        "raw_code": "def subdomain(tld_length = @@tld_length)\n        ActionDispatch::Http::URL.extract_subdomain(host, tld_length)\n      end",
        "comment": "Returns all the subdomains as a string, so `\"dev.www\"` would be returned for \"dev.www.rubyonrails.org\". You can specify a different `tld_length`, such as 2 to catch `\"www\"` instead of `\"www.rubyonrails\"` in \"www.rubyonrails.co.uk\".",
        "label": "Property",
        "id": "11509"
    },
    {
        "raw_code": "def remove_outside_collaborator(org, user, options = {})\n        boolean_from_response :delete, \"#{Organization.path org}/outside_collaborators/#{user}\", options\n      end",
        "comment": "Remove outside collaborator from an organization  Requires authenticated organization members.  @param org [String, Integer] Organization GitHub login or id. @param user [String] GitHub username to be removed as outside collaborator @return [Boolean] Return true if outside collaborator removed from organization, false otherwise. @see https://developer.github.com/v3/orgs/outside-collaborators/#remove-outside-collaborator  @example @client.remove_outside_collaborator('github', 'lizzhale')",
        "label": "Property",
        "id": "15427"
    },
    {
        "raw_code": "def self.generate_config_file(rdp_info)\n          opts   = {\n            \"drivestoredirect:s\"       => \"*\",\n            \"full address:s\"           => \"#{rdp_info[:host]}:#{rdp_info[:port]}\",\n            \"prompt for credentials:i\" => \"1\",\n            \"username:s\"               => rdp_info[:username],\n          }\n\n          # Create the \".rdp\" file\n          t = ::Tempfile.new([\"vagrant-rdp\", \".rdp\"]).tap do |f|\n            f.binmode\n\n            opts.each do |k, v|\n              f.puts(\"#{k}:#{v}\")\n            end",
        "comment": "Generates an RDP connection file and returns the resulting path. @return [String]",
        "label": "Property",
        "id": "9718"
    },
    {
        "raw_code": "def parse_sourcepos(sourcepos)\n          start_pos, end_pos = sourcepos&.split('-')\n          start_row, start_col = start_pos&.split(':')\n          end_row, end_col = end_pos&.split(':')\n\n          return unless start_row && start_col && end_row && end_col\n\n          {\n            start: { row: [1, start_row.to_i].max - 1, col: [1, start_col.to_i].max - 1 },\n            end: { row: [1, end_row.to_i].max - 1, col: [1, end_col.to_i].max - 1 }\n          }\n        end",
        "comment": "Parses string representing a sourcepos in format \"start_row:start_column-end_row:end_column\" into 0-based attributes. For example, \"1:10-14:1\" becomes { start: { row: 0, col: 9 }, end: { row: 13, col: 0 } }",
        "label": "Property",
        "id": "3440"
    },
    {
        "raw_code": "def fresh?(response)\n          if Request.strict_freshness\n            if if_none_match\n              etag_matches?(response.etag)\n            elsif if_modified_since\n              not_modified?(response.last_modified)\n            else\n              false\n            end",
        "comment": "Check response freshness (`Last-Modified` and `ETag`) against request `If-Modified-Since` and `If-None-Match` conditions. If both headers are supplied, based on configuration, either `ETag` is preferred over `Last-Modified` or both are considered equally. You can adjust the preference with `config.action_dispatch.strict_freshness`. Reference: http://tools.ietf.org/html/rfc7232#section-6",
        "label": "Property",
        "id": "11406"
    },
    {
        "raw_code": "def get_visibility_information(tk, single) # :nodoc:\n    vis_type  = tk[:text]\n    singleton = single == SINGLE\n\n    vis =\n      case vis_type\n      when 'private'   then :private\n      when 'protected' then :protected\n      when 'public'    then :public\n      when 'private_class_method' then\n        singleton = true\n        :private\n      when 'public_class_method' then\n        singleton = true\n        :public\n      when 'module_function' then\n        singleton = true\n        :public\n      else\n        raise RDoc::Error, \"Invalid visibility: #{tk.name}\"\n      end",
        "comment": " Extracts the visibility information for the visibility token +tk+ and +single+ class type identifier.  Returns the visibility type (a string), the visibility (a symbol) and +singleton+ if the methods following should be converted to singleton methods.",
        "label": "Property",
        "id": "16063"
    },
    {
        "raw_code": "def call(worker, job, _queue)\n        # ActiveJobs have wrapped class stored in 'wrapped' key\n        resolved_class = job['wrapped']&.safe_constantize || worker.class\n        if drop_job?(resolved_class)\n          # no-op, drop the job entirely\n          drop_job!(job, worker)\n          return\n        elsif !!defer_job?(resolved_class, job)\n          defer_job!(job, worker)\n          return\n        end",
        "comment": "This middleware decides whether a job is dropped, deferred or runs normally. In short: - `drop_sidekiq_jobs_#{worker_name}` FF enabled (disabled by default) --> drops the job - `run_sidekiq_jobs_#{worker_name}` FF disabled (enabled by default) --> defers the job  DROPPING JOBS A job is dropped when `drop_sidekiq_jobs_#{worker_name}` FF is enabled. This FF is disabled by default for all workers. Dropped jobs are completely ignored and not requeued for future processing.  DEFERRING JOBS Deferred jobs are rescheduled to perform in the future. There are 2 scenarios under which this middleware defers a job: 1. When run_sidekiq_jobs_#{worker_name} FF is disabled. This FF is enabled by default for all workers. 2. Gitlab::Database::HealthStatus, on evaluating the db health status if it returns any indicator with stop signal, the jobs will be delayed by 'x' seconds (set in worker).  Dropping jobs takes higher priority over deferring jobs. For example, when `drop_sidekiq_jobs` is enabled and `run_sidekiq_jobs` is disabled, it results to jobs being dropped.",
        "label": "Property",
        "id": "2759"
    },
    {
        "raw_code": "def with_readonly_pipeline\n        raise NestedReadonlyPipelineError if readonly_pipeline?\n\n        Thread.current[:readonly_pipeline] = true\n\n        yield\n      ensure\n        Thread.current[:readonly_pipeline] = false\n      end",
        "comment": "Pipelines are sent to both instances by default since they could execute both read and write commands.  But for pipelines that only consists of read commands, this method can be used to scope the pipeline and send it only to the default store.",
        "label": "Property",
        "id": "1898"
    },
    {
        "raw_code": "def columns(table_name)\n        table_name = table_name.to_s\n        definitions = column_definitions(table_name)\n        definitions.map do |field|\n          new_column_from_field(table_name, field, definitions)\n        end",
        "comment": "Returns an array of +Column+ objects for the table specified by +table_name+.",
        "label": "Property",
        "id": "13136"
    },
    {
        "raw_code": "def clean(plugins, **opts)\n      @logger.debug(\"Cleaning Vagrant plugins of stale gems.\")\n      # Generate dependencies for all registered plugins\n      plugin_deps = plugins.map do |name, info|\n        gem_version = info['installed_gem_version']\n        gem_version = info['gem_version'] if gem_version.to_s.empty?\n        gem_version = \"> 0\" if gem_version.to_s.empty?\n        Gem::Dependency.new(name, gem_version)\n      end",
        "comment": "Clean removes any unused gems.",
        "label": "Property",
        "id": "8902"
    },
    {
        "raw_code": "def initialize(context)\n      @context = context\n    end",
        "comment": "context - An instance of `Banzai::RenderContext`.",
        "label": "Property",
        "id": "3409"
    },
    {
        "raw_code": "def integration_type_to_model(type)\n          type.constantize\n        end",
        "comment": "Returns the model for the given STI type. Example: \"Integrations::Asana\" => Integrations::Asana",
        "label": "Property",
        "id": "7466"
    },
    {
        "raw_code": "def log(start: 0)\n          @client.last_build_log(@name, start)\n        end",
        "comment": "Returns the jobs last log  @param start [Integer] the log offset to query",
        "label": "Property",
        "id": "4331"
    },
    {
        "raw_code": "def by_any_email(emails, confirmed: false)\n      return none if Array(emails).all?(&:nil?)\n\n      from_users = by_user_email(emails)\n      from_users = from_users.confirmed if confirmed\n\n      from_emails = by_emails(emails).merge(Email.confirmed)\n      from_emails = from_emails.confirmed if confirmed\n\n      items = [from_users, from_emails]\n\n      # TODO: https://gitlab.com/gitlab-org/gitlab/-/issues/461885\n      # What about private commit emails with capitalized username, we'd never find them and\n      # since the private_commit_email derives from the username, it can\n      # be uppercase in parts. So we'll never find an existing user during the invite\n      # process by email if that is true as we are case sensitive in this case.\n      user_ids = Gitlab::PrivateCommitEmail.user_ids_for_emails(Array(emails).map(&:downcase))\n      items << where(id: user_ids) if user_ids.present?\n\n      from_union(items)\n    end",
        "comment": "Returns a relation containing all found users by their primary email or any associated confirmed secondary email  @param emails [String, Array<String>] email addresses to check @param confirmed [Boolean] Only return users where the primary email is confirmed",
        "label": "Property",
        "id": "7055"
    },
    {
        "raw_code": "def self.feature_enabled_from_application_settings?\n      Gitlab::CurrentSettings.vscode_extension_marketplace_enabled?\n    end",
        "comment": "Returns true if the ExtensionMarketplace feature is enabled from application settings  @return [Boolean]",
        "label": "Property",
        "id": "3550"
    },
    {
        "raw_code": "def initialize(event, push_data)\n    @event = event\n    @push_data = push_data\n  end",
        "comment": "event - The event this push payload belongs to. push_data - A Hash produced by `Gitlab::DataBuilder::Push.build` to use for building the push payload.",
        "label": "Property",
        "id": "5425"
    },
    {
        "raw_code": "def projects_api_project_id_store_post(project_id, opts = {})\n      data, _status_code, _headers = projects_api_project_id_store_post_with_http_info(project_id, opts)\n      data\n    end",
        "comment": "Ingestion endpoint for error events sent from client SDKs @param project_id [Integer] ID of the project where the error was created @param [Hash] opts the optional parameters @return [ErrorEvent]",
        "label": "Property",
        "id": "1016"
    },
    {
        "raw_code": "def alias_to(alias_table)\n        Arel::Nodes::As.new(table, Arel::Table.new(alias_table.name.tr('.', '_')))\n      end",
        "comment": "Returns an \"AS\" statement that aliases the CTE name as the given table name. This allows one to trick ActiveRecord into thinking it's selecting from an actual table, when in reality it's selecting from a CTE.  alias_table - The Arel table to use as the alias.",
        "label": "Property",
        "id": "2857"
    },
    {
        "raw_code": "def monday\n      beginning_of_week(:monday)\n    end",
        "comment": "Returns Monday of this week assuming that week starts on Monday. +DateTime+ objects have their time set to 0:00.",
        "label": "Property",
        "id": "14164"
    },
    {
        "raw_code": "def assert_no_notifications(pattern = nil, &block)\n        notifications = capture_notifications(pattern, &block)\n        error_message = if pattern\n          \"Expected no notifications for #{pattern} but found #{notifications.size}\"\n        else\n          \"Expected no notifications but found #{notifications.size}\"\n        end",
        "comment": "Assert no notifications were emitted for a given +pattern+.  You can assert no notifications were emitted by passing a pattern, which accepts either a string or regexp, and a block. While the block is executed, if no matching notifications are emitted, the assertion will pass.  assert_no_notifications(\"post.submitted\") do post.destroy # => emits non-matching notification end ",
        "label": "Property",
        "id": "14541"
    },
    {
        "raw_code": "def compute_type(type_name)\n          if type_name.start_with?(\"::\")\n            # If the type is prefixed with a scope operator then we assume that\n            # the type_name is an absolute reference.\n            type_name.constantize\n          else\n            type_candidate = @_type_candidates_cache[type_name]\n            if type_candidate && type_constant = type_candidate.safe_constantize\n              return type_constant\n            end",
        "comment": "Returns the class type of the record using the current module as a prefix. So descendants of MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.",
        "label": "Property",
        "id": "12475"
    },
    {
        "raw_code": "def default_synced_folder_type(machine, plugins)\n          ordered = []\n\n          # First turn the plugins into an array\n          plugins.each do |key, data|\n            impl     = data[0]\n            priority = data[1]\n\n            ordered << [priority, key, impl]\n          end",
        "comment": "This goes over all the registered synced folder types and returns the highest priority implementation that is usable for this machine.",
        "label": "Property",
        "id": "9327"
    },
    {
        "raw_code": "def target_gem_version(gem_name)\n        @config.gem_versions_in_target && @config.gem_versions_in_target[gem_name]\n      end",
        "comment": "Returns a gems locked versions (i.e. from Gemfile.lock or gems.locked) @returns [Gem::Version | nil] The locked gem version, or nil if the gem is not present.",
        "label": "Property",
        "id": "10262"
    },
    {
        "raw_code": "def to_hash\n      hash = {}\n      self.class.attribute_map.each_pair do |attr, param|\n        value = self.send(attr)\n        if value.nil?\n          is_nullable = self.class.openapi_nullable.include?(attr)\n          next if !is_nullable || (is_nullable && !instance_variable_defined?(:\"@#{attr}\"))\n        end",
        "comment": "Returns the object in the form of hash @return [Hash] Returns the object in the form of hash",
        "label": "Property",
        "id": "981"
    },
    {
        "raw_code": "def datetime_with_timezone(column_name, **options)\n        column(column_name, :datetime_with_timezone, **options)\n      end",
        "comment": "Adds specified column with appropriate timestamp type  It is used in table creation like: create_table 'users' do |t| t.datetime_with_timezone :did_something_at end",
        "label": "Property",
        "id": "1285"
    },
    {
        "raw_code": "def execute(commits)\n      mapping = {}\n      shas = commits.map(&:id)\n\n      # To include merge requests by the merged/merge/squash SHA, we don't need\n      # to go through any diff rows.\n      #\n      # We can't squeeze all this into a single query, as the diff based data\n      # relies on a GROUP BY. On the other hand, retrieving MRs by their merge\n      # SHAs separately is much easier, and plenty fast.\n      @project\n        .merge_requests\n        .preload_target_project\n        .by_merged_or_merge_or_squash_commit_sha(shas)\n        .each do |mr|\n          # SHAs for merge commits, squash commits, and rebased source SHAs,\n          # can't be in the merge request source branch. It _is_ possible a\n          # newer merge request includes the commit, but in that case we still\n          # want the oldest merge request.\n          #\n          # It's also possible that a merge request produces both a squashed\n          # commit and a merge commit. In that case we want to store the mapping\n          # for both the SHAs.\n          mapping[mr.squash_commit_sha] = mr if mr.squash_commit_sha\n          mapping[mr.merge_commit_sha] = mr if mr.merge_commit_sha\n          mapping[mr.merged_commit_sha] = mr if mr.merged_commit_sha\n        end",
        "comment": "Returns a Hash that maps a commit ID to the oldest merge request that introduced that commit.",
        "label": "Property",
        "id": "7957"
    },
    {
        "raw_code": "def timestamps_with_timezone(**options)\n        options[:null] = false if options[:null].nil?\n\n        [:created_at, :updated_at].each do |column_name|\n          column(column_name, :datetime_with_timezone, **options)\n        end",
        "comment": "Appends columns `created_at` and `updated_at` to a table.  It is used in table creation like: create_table 'users' do |t| t.timestamps_with_timezone end",
        "label": "Property",
        "id": "1284"
    },
    {
        "raw_code": "def linked?(file)\n          stat = to_file_stat(file)\n\n          stat.symlink? || shares_hard_link?(stat)\n        end",
        "comment": "Returns true if: - File or directory is a symlink. - File shares a hard link.",
        "label": "Property",
        "id": "1856"
    },
    {
        "raw_code": "def nodes_user_can_reference(user, nodes)\n        nodes\n      end",
        "comment": "Returns all the nodes containing references that the user can refer to.",
        "label": "Property",
        "id": "3423"
    },
    {
        "raw_code": "def self.build_from_hash(attributes)\n      new.build_from_hash(attributes)\n    end",
        "comment": "Builds the object from hash @param [Hash] attributes Model attributes in the form of hash @return [Object] Returns the model itself",
        "label": "Property",
        "id": "872"
    },
    {
        "raw_code": "def check_names(names)\n    return unless Hash === names\n\n    invalid_options =\n      names.keys.map { |k| k.to_sym } - [:rdoc, :clobber_rdoc, :rerdoc]\n\n    unless invalid_options.empty? then\n      raise ArgumentError, \"invalid options: #{invalid_options.join ', '}\"\n    end",
        "comment": " Ensures that +names+ only includes names for the :rdoc, :clobber_rdoc and :rerdoc.  If other names are given an ArgumentError is raised.",
        "label": "Property",
        "id": "15516"
    },
    {
        "raw_code": "def merge_requests\n      @merge_requests ||= MergeRequest.from_project(target_project)\n                                      .opened\n                                      .from_source_branches(branches)\n                                      .index_by(&:source_branch)\n    end",
        "comment": "Returns a Hash of branch => MergeRequest",
        "label": "Property",
        "id": "5559"
    },
    {
        "raw_code": "def max_stale_unlimited?\n            @max_stale == true\n          end",
        "comment": "Returns true if max-stale directive is present without a value (unlimited staleness)",
        "label": "Property",
        "id": "11412"
    },
    {
        "raw_code": "def self.protected_paths_enabled?\n      self.settings.throttle_protected_paths_enabled?\n    end",
        "comment": "Returns true if we should use the Admin area protected paths throttle",
        "label": "Property",
        "id": "1636"
    },
    {
        "raw_code": "def old_version_migration_class?(class_node)\n          parent_class_node = class_node.parent_class\n          return false if parent_class_node.nil?\n          return false unless parent_class_node.send_type? && parent_class_node.last_argument.float_type?\n          return false unless parent_class_node.children[0].const_name == GITLAB_MIGRATION_CLASS\n\n          parent_class_node.first_argument.value < CURRENT_MIGRATION_VERSION\n        end",
        "comment": "Returns true for any parent class of format Gitlab::Database::Migration[version] if version < current_version",
        "label": "Property",
        "id": "3915"
    },
    {
        "raw_code": "def to_param\n    self\n  end",
        "comment": "Returns +self+.",
        "label": "Property",
        "id": "14328"
    },
    {
        "raw_code": "def safe_format(format, *args)\n    args = args.inject({}, &:merge)\n\n    # Use `Kernel.format` to avoid conflicts with ViewComponent's `format`.\n    Kernel.format(\n      ERB::Util.html_escape_once(format),\n      args.transform_values { |value| ERB::Util.html_escape(value) }\n    ).html_safe\n  end",
        "comment": "Returns a HTML-safe String.  @param [String] format is escaped via `ERB::Util.html_escape_once` @param [Array<Hash>] args are escaped via `ERB::Util.html_escape` if they are not marked as HTML-safe  @example safe_format('See %{user_input}', user_input: '<b>bold</b>') # => \"See &lt;b&gt;bold&lt;/b&gt\"  safe_format('In &lt; hour & more') # => \"In &lt; hour &amp; more\"  @example With +tag_pair+ support safe_format('Some %{open}bold%{close} text.', tag_pair(tag.strong, :open, :close)) # => \"Some <strong>bold</strong> text.\" safe_format('Some %{open}bold%{close} %{italicStart}text%{italicEnd}.', tag_pair(tag.strong, :open, :close), tag_pair(tag.i, :italicStart, :italicEnd)) # => \"Some <strong>bold</strong> <i>text</i>.",
        "label": "Property",
        "id": "7746"
    },
    {
        "raw_code": "def inspect\n        to_obj ? to_obj.inspect : \"P(#{path})\"\n      end",
        "comment": "Returns a text representation of the Proxy @return [String] the object's #inspect method or P(OBJECTPATH)",
        "label": "Property",
        "id": "629"
    },
    {
        "raw_code": "def select_values(arel, name = nil, binds = [])\n        select_rows(arel, name, binds).map(&:first)\n      end",
        "comment": "Returns an array of the values of the first column in a select: select_values(\"SELECT id FROM companies LIMIT 3\") => [1,2,3]",
        "label": "Property",
        "id": "13055"
    },
    {
        "raw_code": "def except(*keys)\n      new_instance_with_inherited_permitted_status(@parameters.except(*keys))\n    end",
        "comment": "Returns a new `ActionController::Parameters` instance that filters out the given `keys`.  params = ActionController::Parameters.new(a: 1, b: 2, c: 3) params.except(:a, :b) # => #<ActionController::Parameters {\"c\"=>3} permitted: false> params.except(:d)     # => #<ActionController::Parameters {\"a\"=>1, \"b\"=>2, \"c\"=>3} permitted: false>",
        "label": "Property",
        "id": "11372"
    },
    {
        "raw_code": "def _to_hash(value)\n      if value.is_a?(Array)\n        value.compact.map { |v| _to_hash(v) }\n      elsif value.is_a?(Hash)\n        {}.tap do |hash|\n          value.each { |k, v| hash[k] = _to_hash(v) }\n        end",
        "comment": "Outputs non-array value in the form of hash For object, use to_hash. Otherwise, just return the value @param [Object] value Any valid value @return [Hash] Returns the value in the form of hash",
        "label": "Property",
        "id": "982"
    },
    {
        "raw_code": "def url(expires_in: ActiveStorage.service_urls_expire_in, disposition: :inline, filename: nil, **options)\n    service.url key, expires_in: expires_in, filename: ActiveStorage::Filename.wrap(filename || self.filename),\n      content_type: content_type_for_serving, disposition: forced_disposition_for_serving || disposition, **options\n  end",
        "comment": "Returns the URL of the blob on the service. This returns a permanent URL for public files, and returns a short-lived URL for private files. Private files are signed, and not for public use. Instead, the URL should only be exposed as a redirect from a stable, possibly authenticated URL. Hiding the URL behind a redirect also allows you to change services without updating all URLs.",
        "label": "Property",
        "id": "13613"
    },
    {
        "raw_code": "def all_objects\n      ancestors = base_and_ancestors_cte\n      descendants = base_and_descendants_cte\n\n      ancestors_table = ancestors.alias_to(objects_table)\n      descendants_table = descendants.alias_to(objects_table)\n\n      ancestors_scope = unscoped_model.from(ancestors_table)\n      descendants_scope = unscoped_model.from(descendants_table)\n\n      relation = unscoped_model\n        .with\n        .recursive(ancestors.to_arel, descendants.to_arel)\n        .from_union([\n          ancestors_scope,\n          descendants_scope\n        ])\n\n      read_only(relation)\n    end",
        "comment": "Returns a relation that includes the base objects, their ancestors, and the descendants of the base objects.  The resulting query will roughly look like the following:  WITH RECURSIVE ancestors AS ( ... ), descendants AS ( ... ) SELECT * FROM ( SELECT * FROM ancestors namespaces  UNION  SELECT * FROM descendants namespaces ) groups;  Using this approach allows us to further add criteria to the relation with Rails thinking it's selecting data the usual way.  If nested objects are not supported, ancestors_base is returned. rubocop: disable CodeReuse/ActiveRecord",
        "label": "Property",
        "id": "1427"
    },
    {
        "raw_code": "def iterating_method?(name)\n            KNOWN_ITERATING_METHODS.include? name\n          end",
        "comment": "Returns true iff name is a known iterating type (e.g. :each, :transform_values)",
        "label": "Property",
        "id": "10397"
    },
    {
        "raw_code": "def end_accepting\n    @res.join\n  end",
        "comment": " Returns the generated output",
        "label": "Property",
        "id": "16332"
    },
    {
        "raw_code": "def _HtmlBlockOpenTfoot\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenTfoot = \"<\" Spnl (\"tfoot\" | \"TFOOT\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "15710"
    },
    {
        "raw_code": "def assert_in_body(text)\n        assert_match(/#{Regexp.escape(text)}/, @response.body)\n      end",
        "comment": "Asserts that the given +text+ is present somewhere in the response body.  assert_in_body fixture(:name).description",
        "label": "Property",
        "id": "11637"
    },
    {
        "raw_code": "def alpine_image\n      @alpine_image ||= docker_image_with_digest(cng_versions[\"ALPINE_IMAGE\"])\n    end",
        "comment": "Alpine image with digest  @return [String]",
        "label": "Property",
        "id": "5271"
    },
    {
        "raw_code": "def refresh!\n    raise 'source index not created from disk' if @spec_dirs.nil?\n    load_gems_in(*@spec_dirs)\n  end",
        "comment": " Replaces the gems in the source index from specifications in the directories this source index was created from.  Raises an exception if this source index wasn't created from a directory (via from_gems_in or from_installed_gems, or having spec_dirs set).",
        "label": "Property",
        "id": "277"
    },
    {
        "raw_code": "def self.mask(content, by_key: [], by_value: [], mask: '****')\n          new(by_key: by_key, by_value: by_value, mask: mask).mask(content)\n        end",
        "comment": "Returns the content with secrets masked.  @param [Object] content the content to mask @param [Array<Symbol>] by_key the keys of the content whose values will be masked @param [Array<String>] by_value the content to be masked. Masks whole- or sub-strings @param [String] mask the string used to replace secrets (default '****') @return [Object] the content with the specified secrets replaced with the mask",
        "label": "Property",
        "id": "4647"
    },
    {
        "raw_code": "def association_valid?(association, record)\n        return true if record.destroyed? || (association.options[:autosave] && record.marked_for_destruction?)\n\n        context = validation_context if custom_validation_context?\n        return true if record.valid?(context)\n\n        if context || record.changed_for_autosave?\n          associated_errors = record.errors.objects\n        else\n          # If there are existing invalid records in the DB, we should still be able to reference them.\n          # Unless a record (no matter where in the association chain) is invalid and is being changed.\n          associated_errors = record.errors.objects.select { |error| error.is_a?(Associations::NestedError) }\n        end",
        "comment": "Returns whether or not the association is valid and applies any errors to the parent, <tt>self</tt>, if it wasn't. Skips any <tt>:autosave</tt> enabled records if they're marked_for_destruction? or destroyed.",
        "label": "Property",
        "id": "12388"
    },
    {
        "raw_code": "def initialize(parameters = {}, logging_context = {})\n      parameters.each_key do |key|\n        unless key.is_a?(String) || key.is_a?(Symbol)\n          raise InvalidParameterKey, \"all keys must be Strings or Symbols, got: #{key.class}\"\n        end",
        "comment": "Returns a new `ActionController::Parameters` instance. Also, sets the `permitted` attribute to the default value of `ActionController::Parameters.permit_all_parameters`.  class Person < ActiveRecord::Base end  params = ActionController::Parameters.new(name: \"Francesco\") params.permitted?  # => false Person.new(params) # => ActiveModel::ForbiddenAttributesError  ActionController::Parameters.permit_all_parameters = true  params = ActionController::Parameters.new(name: \"Francesco\") params.permitted?  # => true Person.new(params) # => #<Person id: nil, name: \"Francesco\">",
        "label": "Property",
        "id": "11350"
    },
    {
        "raw_code": "def visibility=(visibility)\n    case visibility\n    when :all\n      @visibility = :private\n    else\n      @visibility = visibility\n    end",
        "comment": "Sets the minimum visibility of a documented method.  Accepts +:public+, +:protected+, +:private+, +:nodoc+, or +:all+.  When +:all+ is passed, visibility is set to +:private+, similarly to RDOCOPT=\"--all\", see #visibility for more information.",
        "label": "Property",
        "id": "15541"
    },
    {
        "raw_code": "def say_with_time(message)\n      say(message)\n      result = nil\n      time_elapsed = ActiveSupport::Benchmark.realtime { result = yield }\n      say \"%.4fs\" % time_elapsed, :subitem\n      say(\"#{result} rows\", :subitem) if result.is_a?(Integer)\n      result\n    end",
        "comment": "Outputs text along with how long it took to run its block. If the block returns an integer it assumes it is the number of rows affected.",
        "label": "Property",
        "id": "12496"
    },
    {
        "raw_code": "def video_tag(*sources)\n        options = sources.extract_options!.symbolize_keys\n        public_poster_folder = options.delete(:poster_skip_pipeline)\n        sources << options\n        multiple_sources_tag_builder(\"video\", sources) do |tag_options|\n          tag_options[:poster] = path_to_image(tag_options[:poster], skip_pipeline: public_poster_folder) if tag_options[:poster]\n          tag_options[:width], tag_options[:height] = extract_dimensions(tag_options.delete(:size)) if tag_options[:size]\n        end",
        "comment": "Returns an HTML video tag for the +sources+. If +sources+ is a string, a single video tag will be returned. If +sources+ is an array, a video tag with nested source tags for each source will be returned. The +sources+ can be full paths, files that exist in your public videos directory, or Active Storage attachments.  ==== Options  When the last parameter is a hash you can add HTML attributes using that parameter. The following options are supported:  * <tt>:poster</tt> - Set an image (like a screenshot) to be shown before the video loads. The path is calculated like the +src+ of +image_tag+. * <tt>:size</tt> - Supplied as <tt>\"#{width}x#{height}\"</tt> or <tt>\"#{number}\"</tt>, so <tt>\"30x45\"</tt> becomes <tt>width=\"30\" height=\"45\"</tt>, and <tt>\"50\"</tt> becomes <tt>width=\"50\" height=\"50\"</tt>. <tt>:size</tt> will be ignored if the value is not in the correct format. * <tt>:poster_skip_pipeline</tt> will bypass the asset pipeline when using the <tt>:poster</tt> option instead using an asset in the public folder.  ==== Examples  video_tag(\"trailer\") # => <video src=\"/videos/trailer\"></video> video_tag(\"trailer.ogg\") # => <video src=\"/videos/trailer.ogg\"></video> video_tag(\"trailer.ogg\", controls: true, preload: 'none') # => <video preload=\"none\" controls=\"controls\" src=\"/videos/trailer.ogg\"></video> video_tag(\"trailer.m4v\", size: \"16x10\", poster: \"screenshot.png\") # => <video src=\"/videos/trailer.m4v\" width=\"16\" height=\"10\" poster=\"/assets/screenshot.png\"></video> video_tag(\"trailer.m4v\", size: \"16x10\", poster: \"screenshot.png\", poster_skip_pipeline: true) # => <video src=\"/videos/trailer.m4v\" width=\"16\" height=\"10\" poster=\"screenshot.png\"></video> video_tag(\"/trailers/hd.avi\", size: \"16x16\") # => <video src=\"/trailers/hd.avi\" width=\"16\" height=\"16\"></video> video_tag(\"/trailers/hd.avi\", size: \"16\") # => <video height=\"16\" src=\"/trailers/hd.avi\" width=\"16\"></video> video_tag(\"/trailers/hd.avi\", height: '32', width: '32') # => <video height=\"32\" src=\"/trailers/hd.avi\" width=\"32\"></video> video_tag(\"trailer.ogg\", \"trailer.flv\") # => <video><source src=\"/videos/trailer.ogg\" /><source src=\"/videos/trailer.flv\" /></video> video_tag([\"trailer.ogg\", \"trailer.flv\"]) # => <video><source src=\"/videos/trailer.ogg\" /><source src=\"/videos/trailer.flv\" /></video> video_tag([\"trailer.ogg\", \"trailer.flv\"], size: \"160x120\") # => <video height=\"120\" width=\"160\"><source src=\"/videos/trailer.ogg\" /><source src=\"/videos/trailer.flv\" /></video>  Active Storage blobs (videos that are uploaded by the users of your app):  video_tag(user.intro_video) # => <video src=\"/rails/active_storage/blobs/.../intro_video.mp4\"></video>",
        "label": "Property",
        "id": "11787"
    },
    {
        "raw_code": "def self.db_spin(duration_s, interval_s)\n      expected_end_time = Time.now + duration_s\n\n      while Time.now < expected_end_time\n        ApplicationRecord.connection.execute(\"SELECT 1\")\n\n        end_interval_time = Time.now + [duration_s, interval_s].min\n        rand while Time.now < end_interval_time\n      end",
        "comment": "db_spin will query the database in a tight loop for the specified duration",
        "label": "Property",
        "id": "1342"
    },
    {
        "raw_code": "def primary_key(table_name)\n        pk = primary_keys(table_name)\n        pk = pk.first unless pk.size > 1\n        pk\n      end",
        "comment": "Returns just a table's primary key",
        "label": "Property",
        "id": "13138"
    },
    {
        "raw_code": "def url_for_frameset\n        url_for_file(\"frames.html\")\n      end",
        "comment": "Returns the URL for the frameset page  @return [String] the URL pointing to the frames page @since 0.8.0",
        "label": "Property",
        "id": "412"
    },
    {
        "raw_code": "def self.map_to_command_options(map, cmd_flag=\"--\")\n        opt_list = []\n        if map == nil\n          return opt_list\n        end",
        "comment": "Given a hash map of user specified argments, will generate a list. Set the key to the command flag, and the value to it's value. If the value is boolean (true), only the flag is added. eg. {a: \"opt-a\", b: true} -> [\"--a\", \"opt-a\", \"--b\"]  @param [Hash]   map of commands @param [String] string prepended to cmd line flags (keys)  @return[Array<String>] commands in list form",
        "label": "Property",
        "id": "9193"
    },
    {
        "raw_code": "def attribute_value(attribute)\n          attributes = Array(config.attributes[attribute.to_s])\n          selected_attr = attributes.find { |attr| entry.respond_to?(attr) }\n\n          return unless selected_attr\n\n          entry.public_send(selected_attr) # rubocop:disable GitlabSecurity/PublicSend\n        end",
        "comment": "Using the LDAP attributes configuration, find and return the first attribute with a value. For example, by default, when given 'email', this method looks for 'mail', 'email' and 'userPrincipalName' and returns the first with a value.",
        "label": "Property",
        "id": "2357"
    },
    {
        "raw_code": "def available_public_keys\n        strong_memoize(:available_public_keys) do\n          DeployKey.are_public.with_projects - enabled_keys\n        end",
        "comment": "It includes: - Instance-level public deploy keys. It excludes: - The deploy keys enabled in the project.",
        "label": "Property",
        "id": "5419"
    },
    {
        "raw_code": "def scheduled_output\n          # We return an empty message so that Slack still shows the input\n          # command, without polluting the channel with standard \"The job has\n          # been scheduled\" (or similar) responses.\n          { text: '' }\n        end",
        "comment": "Returns the output to send back after a command has been scheduled.",
        "label": "Property",
        "id": "2445"
    },
    {
        "raw_code": "def parse_text(parent, indent) # :nodoc:\n    paragraph = build_paragraph indent\n\n    if false == @seen_returns and 'Returns' == @section then\n      @seen_returns = true\n      parent << RDoc::Markup::Heading.new(3, 'Returns')\n      parent << RDoc::Markup::BlankLine.new\n    end",
        "comment": " Detects a section change to \"Returns\" and adds a heading",
        "label": "Property",
        "id": "15510"
    },
    {
        "raw_code": "def max_index_name_size\n        62\n      end",
        "comment": "Returns the maximum length of an index name in bytes.",
        "label": "Property",
        "id": "13179"
    },
    {
        "raw_code": "def decrement_counter(counter_name, id, by: 1, touch: nil)\n        update_counters(id, counter_name => -by, touch: touch)\n      end",
        "comment": "Decrement a numeric field by one, via a direct SQL update.  This works the same as #increment_counter but reduces the column value by 1 instead of increasing it.  ==== Parameters  * +counter_name+ - The name of the field that should be decremented. * +id+ - The id of the object that should be decremented or an array of ids. * <tt>:by</tt> - The amount by which to decrement the value. Defaults to +1+. * <tt>:touch</tt> - Touch timestamp columns when updating. Pass +true+ to touch +updated_at+ and/or +updated_on+. Pass a symbol to touch that column or an array of symbols to touch just those ones.  ==== Examples  # Decrement the posts_count column for the record with an id of 5 DiscussionBoard.decrement_counter(:posts_count, 5)  # Decrement the posts_count column for the record with an id of 5 by a specific amount. DiscussionBoard.decrement_counter(:posts_count, 5, by: 3)  # Decrement the posts_count column for the record with an id of 5 # and update the updated_at value. DiscussionBoard.decrement_counter(:posts_count, 5, touch: true)",
        "label": "Property",
        "id": "12447"
    },
    {
        "raw_code": "def singularize(locale = :en)\n    ActiveSupport::Inflector.singularize(self, locale)\n  end",
        "comment": "The reverse of +pluralize+, returns the singular form of a word in a string.  If the optional parameter +locale+ is specified, the word will be singularized as a word of that language. By default, this parameter is set to <tt>:en</tt>. You must define your own inflection rules for languages other than English.  'posts'.singularize            # => \"post\" 'octopi'.singularize           # => \"octopus\" 'sheep'.singularize            # => \"sheep\" 'word'.singularize             # => \"word\" 'the blue mailmen'.singularize # => \"the blue mailman\" 'CamelOctopi'.singularize      # => \"CamelOctopus\" 'leyes'.singularize(:es)       # => \"ley\"  See ActiveSupport::Inflector.singularize.",
        "label": "Property",
        "id": "14363"
    },
    {
        "raw_code": "def storage_validation_error(message)\n  raise \"#{message}. Please fix this in your gitlab.yml before starting GitLab.\"\nend",
        "comment": "frozen_string_literal: true",
        "label": "Property",
        "id": "1271"
    },
    {
        "raw_code": "def self.version\n    gem_version\n  end",
        "comment": "Returns the currently loaded version of Active Job as a +Gem::Version+.",
        "label": "Property",
        "id": "12148"
    },
    {
        "raw_code": "def all\n      results = []\n\n      with_collection_lock do\n        @logger.debug(\"Finding all boxes in: #{@directory}\")\n        @directory.children(true).each do |child|\n          # Ignore non-directories, since files are not interesting to\n          # us in our folder structure.\n          next if !child.directory?\n\n          box_name = undir_name(child.basename.to_s)\n\n          # Otherwise, traverse the subdirectories and see what versions\n          # we have.\n          child.children(true).each do |versiondir|\n            next if !versiondir.directory?\n            next if versiondir.basename.to_s.start_with?(\".\")\n\n            version = versiondir.basename.to_s\n            # Ensure version of box is correct before continuing\n            if !Gem::Version.correct?(version)\n              ui = Vagrant::UI::Prefixed.new(Vagrant::UI::Colored.new, \"vagrant\")\n              ui.warn(I18n.t(\"vagrant.box_version_malformed\",\n                             version: version, box_name: box_name))\n              @logger.debug(\"Invalid version #{version} for box #{box_name}\")\n              next\n            end",
        "comment": "This returns an array of all the boxes on the system, given by their name and their provider.  @return [Array] Array of `[name, version, provider, architecture]` of the boxes installed on this system.",
        "label": "Property",
        "id": "8731"
    },
    {
        "raw_code": "def image?\n    content_type.start_with?(\"image\")\n  end",
        "comment": "Returns true if the content_type of this blob is in the image range, like image/png.",
        "label": "Property",
        "id": "13609"
    },
    {
        "raw_code": "def port\n        @port ||= if raw_host_with_port =~ /:(\\d+)$/\n          $1.to_i\n        else\n          standard_port\n        end",
        "comment": "Returns the port number of this request as an integer.  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com' req.port # => 80  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080' req.port # => 8080",
        "label": "Property",
        "id": "11501"
    },
    {
        "raw_code": "def single_user?\n      User.non_internal.limit(2).count == 1\n    end",
        "comment": "Return true if there is only single non-internal user in the deployment, ghost user is ignored.",
        "label": "Property",
        "id": "7063"
    },
    {
        "raw_code": "def self_deletion_scheduled?\n      self_deletion_scheduled_deletion_created_on.present?\n    end",
        "comment": "Returns true if the record is scheduled for deletion.",
        "label": "Property",
        "id": "7420"
    },
    {
        "raw_code": "def with_target_vms(names=nil, options=nil)\n          # Using VMs requires a Vagrant environment to be properly setup\n          raise Errors::NoEnvironmentError if !@env.root_path\n\n          # Setup the options hash\n          options ||= {}\n\n          # Require that names be an array\n          names ||= []\n          names = [names] if !names.is_a?(Array)\n\n          # First determine the proper array of VMs.\n          vms = []\n          if names.length > 0\n            names.each do |name|\n              if pattern = name[/^\\/(.+?)\\/$/, 1]\n                # This is a regular expression name, so we convert to a regular\n                # expression and allow that sort of matching.\n                regex = Regexp.new(pattern)\n\n                @env.vms.each do |name, vm|\n                  vms << vm if name =~ regex\n                end",
        "comment": "Yields a VM for each target VM for the command.  This is a convenience method for easily implementing methods that take a target VM (in the case of multi-VM) or every VM if no specific VM name is specified.  @param [String] name The name of the VM. Nil if every VM. @param [Boolean] single_target If true, then an exception will be raised if more than one target is found.",
        "label": "Property",
        "id": "8992"
    },
    {
        "raw_code": "def load\n          case reflection.macro\n          when :has_many\n            relation_proxy\n          when :has_one\n            relation_proxy.last\n          else\n            raise 'Not supported association type!'\n          end",
        "comment": "Returns an instance of `RelationProxy` for the object (parent model). The returned object behaves like an Active Record relation to support keyset pagination.",
        "label": "Property",
        "id": "2101"
    },
    {
        "raw_code": "def derive_key_from(password, length: key_length)\n        ActiveSupport::KeyGenerator.new(password, hash_digest_class: hash_digest_class)\n          .generate_key(key_derivation_salt, length)\n      end",
        "comment": "Derives a key from the given password. The key will have a size in bytes of +:length+ (configured +Cipher+'s length by default)  The generated key will be salted with the value of +ActiveRecord::Encryption.key_derivation_salt+",
        "label": "Property",
        "id": "13320"
    },
    {
        "raw_code": "def to_missing_attachable_partial_path\n        ActionText::Attachables::MissingAttachable::DEFAULT_PARTIAL_PATH\n      end",
        "comment": "Returns the path to the partial that is used for rendering missing attachables. Defaults to \"action_text/attachables/missing_attachable\".  Override to render a different partial:  class User < ApplicationRecord def self.to_missing_attachable_partial_path \"users/missing_attachable\" end end",
        "label": "Property",
        "id": "11684"
    },
    {
        "raw_code": "def read_multi(*names)\n        return {} if names.empty?\n\n        options = names.extract_options!\n        options = merged_options(options)\n        keys    = names.map { |name| normalize_key(name, options) }\n\n        instrument_multi :read_multi, keys, options do |payload|\n          read_multi_entries(names, **options, event: payload).tap do |results|\n            payload[:hits] = results.keys.map { |name| normalize_key(name, options) }\n          end",
        "comment": "Reads multiple values at once from the cache. Options can be passed in the last argument.  Some cache implementation may optimize this method.  Returns a hash mapping the names provided to the values found.",
        "label": "Property",
        "id": "13737"
    },
    {
        "raw_code": "def to_hash\n      hash = {}\n      self.class.attribute_map.each_pair do |attr, param|\n        value = self.send(attr)\n        if value.nil?\n          is_nullable = self.class.openapi_nullable.include?(attr)\n          next if !is_nullable || (is_nullable && !instance_variable_defined?(:\"@#{attr}\"))\n        end",
        "comment": "Returns the object in the form of hash @return [Hash] Returns the object in the form of hash",
        "label": "Property",
        "id": "894"
    },
    {
        "raw_code": "def item label = nil, *parts\n    @RM::ListItem.new label, *parts\n  end",
        "comment": " Shortcut for RDoc::Markup::ListItem.new with +label+ and +parts+",
        "label": "Property",
        "id": "16877"
    },
    {
        "raw_code": "def last_build_log(job_name, start = 0)\n          get(\n            path: \"/job/#{job_name}/#{last_build_id(job_name)}/logText/progressiveText\",\n            params: { start: start }\n          ).body\n        end",
        "comment": "Latest build log for a job  @param job_name [String] the name of the job @param start [Integer] the log offset to return @return [String] the latest Jenkins log/output for this job",
        "label": "Property",
        "id": "4320"
    },
    {
        "raw_code": "def self_deletion_scheduled_deletion_created_on\n      marked_for_deletion_on if respond_to?(:marked_for_deletion_on)\n    end",
        "comment": "Returns the date when the scheduled deletion was created.",
        "label": "Property",
        "id": "7419"
    },
    {
        "raw_code": "def ==(other)\n      if other.respond_to?(:permitted?)\n        permitted? == other.permitted? && parameters == other.parameters\n      else\n        super\n      end",
        "comment": "Returns true if another `Parameters` object contains the same content and permitted flag.",
        "label": "Property",
        "id": "11351"
    },
    {
        "raw_code": "def correct_reassignment(corrector, node, offending_name, preferred_name)\n          correct_node(corrector, node.rhs, offending_name, preferred_name)\n        end",
        "comment": "rubocop:enable Metrics/MethodLength If the exception variable is reassigned, that assignment needs to be corrected. Further `lvar` nodes will not be corrected though since they now refer to a different variable.",
        "label": "Property",
        "id": "10343"
    },
    {
        "raw_code": "def self.config_sources\n        {\n          unknown_source: nil,\n          repository_source: 1,\n          auto_devops_source: 2,\n          webide_source: 3,\n          remote_source: 4,\n          external_project_source: 5,\n          bridge_source: 6,\n          parameter_source: 7,\n          compliance_source: 8,\n          security_policies_default_source: 9,\n          pipeline_execution_policy_forced: 10\n        }\n      end",
        "comment": "Returns the `Hash` to use for creating the `config_sources` enum for `Ci::Pipeline`.",
        "label": "Property",
        "id": "7433"
    },
    {
        "raw_code": "def find_by_id(id)\n        diff_files_indexed_by_id[id]\n      end",
        "comment": "Returns a Gitlab::Diff::File with the given ID (`unique_identifier` in Gitlab::Diff::File).",
        "label": "Property",
        "id": "1832"
    },
    {
        "raw_code": "def self.attribute_map\n      {\n        :'frequency' => :'frequency'\n      }\n    end",
        "comment": "Attribute mapping from ruby-style variable name to JSON key.",
        "label": "Property",
        "id": "983"
    },
    {
        "raw_code": "def commit\n        return unless sha\n\n        @commit ||= @repository.commit_by(oid: sha)\n      end",
        "comment": "Returns the merge base as a Gitlab::Git::Commit",
        "label": "Property",
        "id": "2574"
    },
    {
        "raw_code": "def up\n    validate_foreign_key(:work_item_colors, :namespace_id, name: NEW_FK_NAME)\n  end",
        "comment": "foreign key added in FixWorkItemColorsCascadeOptionOnFkToNamespaceId",
        "label": "Property",
        "id": "4995"
    },
    {
        "raw_code": "def self.init\n          new_root_object\n        end",
        "comment": "Returns a bare empty configuration object.  @return [V1::Root]",
        "label": "Property",
        "id": "8925"
    },
    {
        "raw_code": "def scss?\n      @current_engine == :scss\n    end",
        "comment": "@return [Boolean] Returns true if current engine is `:scss`.",
        "label": "Property",
        "id": "8673"
    },
    {
        "raw_code": "def self.each system = true, site = true, home = true, gems = :latest, *extra_dirs # :yields: directory, type\n    return enum_for __method__, system, site, home, gems, *extra_dirs unless\n      block_given?\n\n    extra_dirs.each do |dir|\n      yield dir, :extra\n    end",
        "comment": ":startdoc:  Iterates over each selected path yielding the directory and type.  Yielded types: :system:: Where Ruby's ri data is stored.  Yielded when +system+ is true :site:: Where ri for installed libraries are stored.  Yielded when +site+ is true.  Normally no ri data is stored here. :home:: ~/.rdoc.  Yielded when +home+ is true. :gem:: ri data for an installed gem.  Yielded when +gems+ is true. :extra:: ri data directory from the command line.  Yielded for each entry in +extra_dirs+",
        "label": "Property",
        "id": "16558"
    },
    {
        "raw_code": "def charset\n        show_variable \"character_set_database\"\n      end",
        "comment": "Returns the database character set.",
        "label": "Property",
        "id": "12952"
    },
    {
        "raw_code": "def self.dark_for_user(user)\n      if user && !user.dark_color_scheme_id.nil?\n        by_id(user.dark_color_scheme_id)\n      else\n        default_dark\n      end",
        "comment": "Get the dark Scheme for the specified user, or the default  user - User record  Returns a Scheme",
        "label": "Property",
        "id": "1681"
    },
    {
        "raw_code": "def select_month(date, options = {}, html_options = {})\n        DateTimeSelector.new(date, options, html_options).select_month\n      end",
        "comment": "Returns a select tag with options for each of the months January through December with the current month selected. The month names are presented as keys (what's shown to the user) and the month numbers (1-12) are used as values (what's submitted to the server). It's also possible to use month numbers for the presentation instead of names -- set the <tt>:use_month_numbers</tt> key in +options+ to true for this to happen. If you want both numbers and names, set the <tt>:add_month_numbers</tt> key in +options+ to true. If you would prefer to show month names as abbreviations, set the <tt>:use_short_month</tt> key in +options+ to true. If you want to use your own month names, set the <tt>:use_month_names</tt> key in +options+ to an array of 12 month names. If you want to display months with a leading zero set the <tt>:use_two_digit_numbers</tt> key in +options+ to true. Override the field name using the <tt>:field_name</tt> option, 'month' by default.  # Generates a select field for months that defaults to the current month that # will use keys like \"January\", \"March\". select_month(Date.today)  # Generates a select field for months that defaults to the current month that # is named \"start\" rather than \"month\". select_month(Date.today, field_name: 'start')  # Generates a select field for months that defaults to the current month that # will use keys like \"1\", \"3\". select_month(Date.today, use_month_numbers: true)  # Generates a select field for months that defaults to the current month that # will use keys like \"1 - January\", \"3 - March\". select_month(Date.today, add_month_numbers: true)  # Generates a select field for months that defaults to the current month that # will use keys like \"Jan\", \"Mar\". select_month(Date.today, use_short_month: true)  # Generates a select field for months that defaults to the current month that # will use keys like \"Januar\", \"Marts.\" select_month(Date.today, use_month_names: %w(Januar Februar Marts ...))  # Generates a select field for months that defaults to the current month that # will use keys with two digit numbers like \"01\", \"03\". select_month(Date.today, use_two_digit_numbers: true)  # Generates a select field for months with a custom prompt. Use <tt>prompt: true</tt> for a # generic prompt. select_month(14, prompt: 'Choose month')",
        "label": "Property",
        "id": "11837"
    },
    {
        "raw_code": "def with_encryption_context(properties)\n          self.custom_contexts ||= []\n          self.custom_contexts << default_context.dup\n          properties.each do |key, value|\n            self.current_custom_context.send(\"#{key}=\", value)\n          end",
        "comment": "Configures a custom encryption context to use when running the provided block of code.  It supports overriding all the properties defined in +Context+.  Example:  ActiveRecord::Encryption.with_encryption_context(encryptor: ActiveRecord::Encryption::NullEncryptor.new) do ... end  Encryption contexts can be nested.",
        "label": "Property",
        "id": "13301"
    },
    {
        "raw_code": "def api_key_with_prefix(param_name, param_alias = nil)\n      key = @api_key[param_name]\n      key = @api_key.fetch(param_alias, key) unless param_alias.nil?\n      if @api_key_prefix[param_name]\n        \"#{@api_key_prefix[param_name]} #{key}\"\n      else\n        key\n      end",
        "comment": "Gets API key (with prefix if set). @param [String] param_name the parameter name of API key auth",
        "label": "Property",
        "id": "821"
    },
    {
        "raw_code": "def fq_path\n          @fq_path ||= ENV[\"RSPEC_FAST_QUARANTINE_PATH\"] = File.join(Runtime::Path.qa_root, \"tmp\", fq_filename)\n        end",
        "comment": "Force path to be relative to ruby process in order to avoid issues when dealing with different execution contexts of qa docker container and CI runner environment",
        "label": "Property",
        "id": "4427"
    },
    {
        "raw_code": "def with_markdown_cache\n    Commit.preload_markdown_cache!(commits)\n\n    self\n  end",
        "comment": "Returns the collection with markdown fields preloaded.  Get the markdown cache from redis using pipeline to prevent n+1 requests when rendering the markdown of an attribute (e.g. title, full_title, description).",
        "label": "Property",
        "id": "6701"
    },
    {
        "raw_code": "def http_cache_forever(public: false)\n      expires_in 100.years, public: public, immutable: true\n\n      yield if stale?(etag: request.fullpath,\n                      last_modified: Time.new(2011, 1, 1).utc,\n                      public: public)\n    end",
        "comment": "Cache or yield the block. The cache is supposed to never expire.  You can use this method when you have an HTTP response that never changes, and the browser and proxies should cache it indefinitely.  *   `public`: By default, HTTP responses are private, cached only on the user's web browser. To allow proxies to cache the response, set `true` to indicate that they can serve the cached response to all users.",
        "label": "Property",
        "id": "11254"
    },
    {
        "raw_code": "def merge_base(...)\n        wrapped_gitaly_errors do\n          gitaly_repository_client.find_merge_base(...)\n        end",
        "comment": "Returns the SHA of the most recent common ancestor of +from+ and +to+",
        "label": "Property",
        "id": "2633"
    },
    {
        "raw_code": "def projects_api_project_id_envelope_post(project_id, opts = {})\n      data, _status_code, _headers = projects_api_project_id_envelope_post_with_http_info(project_id, opts)\n      data\n    end",
        "comment": "Ingestion endpoint for error events sent from client SDKs @param project_id [Integer] ID of the project where the error was created @param [Hash] opts the optional parameters @return [ErrorEvent]",
        "label": "Property",
        "id": "1014"
    },
    {
        "raw_code": "def instance\n        current_instances[current_instances_key] ||= new\n      end",
        "comment": "Returns singleton instance for this class in this thread. If none exists, one is created.",
        "label": "Property",
        "id": "13792"
    },
    {
        "raw_code": "def max_descendants_depth\n      base_and_descendants(with_depth: true).maximum(DEPTH_COLUMN)\n    end",
        "comment": "Returns the maximum depth starting from the base A base object with no children has a maximum depth of `1`",
        "label": "Property",
        "id": "1422"
    },
    {
        "raw_code": "def to_fs(format = nil, options = nil)\n      return to_s if format.nil?\n\n      case format\n      when Integer, String\n        to_s(format)\n      when :phone\n        ActiveSupport::NumberHelper.number_to_phone(self, options || {})\n      when :currency\n        ActiveSupport::NumberHelper.number_to_currency(self, options || {})\n      when :percentage\n        ActiveSupport::NumberHelper.number_to_percentage(self, options || {})\n      when :delimited\n        ActiveSupport::NumberHelper.number_to_delimited(self, options || {})\n      when :rounded\n        ActiveSupport::NumberHelper.number_to_rounded(self, options || {})\n      when :human\n        ActiveSupport::NumberHelper.number_to_human(self, options || {})\n      when :human_size\n        ActiveSupport::NumberHelper.number_to_human_size(self, options || {})\n      when Symbol\n        to_s\n      else\n        to_s(format)\n      end",
        "comment": "\\Numeric With Format  Provides options for converting numbers into formatted strings. Options are provided for phone numbers, currency, percentage, precision, positional notation, file size, and pretty printing.  This method is aliased to <tt>to_formatted_s</tt>.  ==== Options  For details on which formats use which options, see ActiveSupport::NumberHelper  ==== Examples  Phone Numbers: 5551234.to_fs(:phone)                                     # => \"555-1234\" 1235551234.to_fs(:phone)                                  # => \"123-555-1234\" 1235551234.to_fs(:phone, area_code: true)                 # => \"(123) 555-1234\" 1235551234.to_fs(:phone, delimiter: ' ')                  # => \"123 555 1234\" 1235551234.to_fs(:phone, area_code: true, extension: 555) # => \"(123) 555-1234 x 555\" 1235551234.to_fs(:phone, country_code: 1)                 # => \"+1-123-555-1234\" 1235551234.to_fs(:phone, country_code: 1, extension: 1343, delimiter: '.') # => \"+1.123.555.1234 x 1343\"  Currency: 1234567890.50.to_fs(:currency)                     # => \"$1,234,567,890.50\" 1234567890.506.to_fs(:currency)                    # => \"$1,234,567,890.51\" 1234567890.506.to_fs(:currency, precision: 3)      # => \"$1,234,567,890.506\" 1234567890.506.to_fs(:currency, round_mode: :down) # => \"$1,234,567,890.50\" 1234567890.506.to_fs(:currency, locale: :fr)       # => \"1 234 567 890,51 \u20ac\" -1234567890.50.to_fs(:currency, negative_format: '(%u%n)') # => \"($1,234,567,890.50)\" 1234567890.50.to_fs(:currency, unit: '&pound;', separator: ',', delimiter: '') # => \"&pound;1234567890,50\" 1234567890.50.to_fs(:currency, unit: '&pound;', separator: ',', delimiter: '', format: '%n %u') # => \"1234567890,50 &pound;\"  Percentage: 100.to_fs(:percentage)                                  # => \"100.000%\" 100.to_fs(:percentage, precision: 0)                    # => \"100%\" 1000.to_fs(:percentage, delimiter: '.', separator: ',') # => \"1.000,000%\" 302.24398923423.to_fs(:percentage, precision: 5)        # => \"302.24399%\" 302.24398923423.to_fs(:percentage, round_mode: :down)   # => \"302.243%\" 1000.to_fs(:percentage, locale: :fr)                    # => \"1 000,000%\" 100.to_fs(:percentage, format: '%n  %')                 # => \"100.000  %\"  Delimited: 12345678.to_fs(:delimited)                     # => \"12,345,678\" 12345678.05.to_fs(:delimited)                  # => \"12,345,678.05\" 12345678.to_fs(:delimited, delimiter: '.')     # => \"12.345.678\" 12345678.to_fs(:delimited, delimiter: ',')     # => \"12,345,678\" 12345678.05.to_fs(:delimited, separator: ' ')  # => \"12,345,678 05\" 12345678.05.to_fs(:delimited, locale: :fr)     # => \"12 345 678,05\" 98765432.98.to_fs(:delimited, delimiter: ' ', separator: ',') # => \"98 765 432,98\"  Rounded: 111.2345.to_fs(:rounded)                                      # => \"111.235\" 111.2345.to_fs(:rounded, precision: 2)                        # => \"111.23\" 111.2345.to_fs(:rounded, precision: 2, round_mode: :up)       # => \"111.24\" 13.to_fs(:rounded, precision: 5)                              # => \"13.00000\" 389.32314.to_fs(:rounded, precision: 0)                       # => \"389\" 111.2345.to_fs(:rounded, significant: true)                   # => \"111\" 111.2345.to_fs(:rounded, precision: 1, significant: true)     # => \"100\" 13.to_fs(:rounded, precision: 5, significant: true)           # => \"13.000\" 111.234.to_fs(:rounded, locale: :fr)                          # => \"111,234\" 13.to_fs(:rounded, precision: 5, significant: true, strip_insignificant_zeros: true) # => \"13\" 389.32314.to_fs(:rounded, precision: 4, significant: true)    # => \"389.3\" 1111.2345.to_fs(:rounded, precision: 2, separator: ',', delimiter: '.') # => \"1.111,23\"  Human-friendly size in Bytes: 123.to_fs(:human_size)                                    # => \"123 Bytes\" 1234.to_fs(:human_size)                                   # => \"1.21 KB\" 12345.to_fs(:human_size)                                  # => \"12.1 KB\" 1234567.to_fs(:human_size)                                # => \"1.18 MB\" 1234567890.to_fs(:human_size)                             # => \"1.15 GB\" 1234567890123.to_fs(:human_size)                          # => \"1.12 TB\" 1234567890123456.to_fs(:human_size)                       # => \"1.1 PB\" 1234567890123456789.to_fs(:human_size)                    # => \"1.07 EB\" 1234567.to_fs(:human_size, precision: 2)                  # => \"1.2 MB\" 1234567.to_fs(:human_size, precision: 2, round_mode: :up) # => \"1.3 MB\" 483989.to_fs(:human_size, precision: 2)                   # => \"470 KB\" 1234567.to_fs(:human_size, precision: 2, separator: ',')  # => \"1,2 MB\" 1234567890123.to_fs(:human_size, precision: 5)            # => \"1.1228 TB\" 524288000.to_fs(:human_size, precision: 5)                # => \"500 MB\"  Human-friendly format: 123.to_fs(:human)                                       # => \"123\" 1234.to_fs(:human)                                      # => \"1.23 Thousand\" 12345.to_fs(:human)                                     # => \"12.3 Thousand\" 1234567.to_fs(:human)                                   # => \"1.23 Million\" 1234567890.to_fs(:human)                                # => \"1.23 Billion\" 1234567890123.to_fs(:human)                             # => \"1.23 Trillion\" 1234567890123456.to_fs(:human)                          # => \"1.23 Quadrillion\" 1234567890123456789.to_fs(:human)                       # => \"1230 Quadrillion\" 489939.to_fs(:human, precision: 2)                      # => \"490 Thousand\" 489939.to_fs(:human, precision: 2, round_mode: :down)   # => \"480 Thousand\" 489939.to_fs(:human, precision: 4)                      # => \"489.9 Thousand\" 1234567.to_fs(:human, precision: 4, significant: false)                             # => \"1.2346 Million\" 1234567.to_fs(:human, precision: 1, separator: ',', significant: false)                             # => \"1,2 Million\"",
        "label": "Property",
        "id": "14291"
    },
    {
        "raw_code": "def plugins\n          @plugins ||= Vagrant.plugin(\"2\").manager.synced_folders\n        end",
        "comment": "This returns the available synced folder implementations. This is a separate method so that it can be easily stubbed by tests.",
        "label": "Property",
        "id": "9329"
    },
    {
        "raw_code": "def attribute_names_for_serialization\n    attributes.keys\n  end",
        "comment": "Use attributes.keys instead of attribute_names to filter out the fields that are skipped during export:  - note_html - cached_markdown_version  Note: This method is an override of an existing private ActiveRecord method",
        "label": "Property",
        "id": "6940"
    },
    {
        "raw_code": "def names_from_tree(project_tree)\n    project_tree.map do |branch_or_model|\n      branch_or_model = branch_or_model.to_s if branch_or_model.is_a?(Symbol)\n\n      branch_or_model.is_a?(String) ? branch_or_model : names_from_tree(branch_or_model)\n    end",
        "comment": "Returns a list of models from hashes/arrays contained in +project_tree+",
        "label": "Property",
        "id": "8361"
    },
    {
        "raw_code": "def observability_url\n      return ENV['OVERRIDE_OBSERVABILITY_QUERY_URL'] if ENV['OVERRIDE_OBSERVABILITY_QUERY_URL']\n      # TODO Make observability URL configurable https://gitlab.com/gitlab-org/opstrace/opstrace-ui/-/issues/80\n      # Dev, test and staging instances can all point to `observe.staging.gitlab.com` by default\n      return 'https://observe.staging.gitlab.com' if Gitlab.staging? || Gitlab.dev_or_test_env?\n\n      'https://observe.gitlab.com'\n    end",
        "comment": "Returns the GitLab Observability URL ",
        "label": "Property",
        "id": "1583"
    },
    {
        "raw_code": "def build(attributes = nil, &block)\n        if attributes.is_a?(Array)\n          attributes.collect { |attr| build(attr, &block) }\n        else\n          new(attributes, &block)\n        end",
        "comment": "Builds an object (or multiple objects) and returns either the built object or a list of built objects.  The +attributes+ parameter can be either a Hash or an Array of Hashes. These Hashes describe the attributes on the objects that are to be built.  ==== Examples # Build a single new object User.build(first_name: 'Jamie')  # Build an Array of new objects User.build([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }])  # Build a single object and pass it into a block to set other attributes. User.build(first_name: 'Jamie') do |u| u.is_admin = false end  # Building an Array of new objects using a block, where the block is executed for each object: User.build([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }]) do |u| u.is_admin = false end",
        "label": "Property",
        "id": "12545"
    },
    {
        "raw_code": "def add_check_constraint(table_name, expression, if_not_exists: false, **options)\n        return unless supports_check_constraints?\n\n        options = check_constraint_options(table_name, expression, options)\n        return if if_not_exists && check_constraint_exists?(table_name, **options)\n\n        at = create_alter_table(table_name)\n        at.add_check_constraint(expression, options)\n\n        execute schema_creation.accept(at)\n      end",
        "comment": "Adds a new check constraint to the table. +expression+ is a String representation of verifiable boolean condition.  add_check_constraint :products, \"price > 0\", name: \"price_check\"  generates:  ALTER TABLE \"products\" ADD CONSTRAINT price_check CHECK (price > 0)  The +options+ hash can include the following keys: [<tt>:name</tt>] The constraint name. Defaults to <tt>chk_rails_<identifier></tt>. [<tt>:if_not_exists</tt>] Silently ignore if the constraint already exists, rather than raise an error. [<tt>:validate</tt>] (PostgreSQL only) Specify whether or not the constraint should be validated. Defaults to +true+.",
        "label": "Property",
        "id": "13168"
    },
    {
        "raw_code": "def export_service_for(relation)\n        if tree_relation?(relation)\n          ::BulkImports::TreeExportService\n        elsif file_relation?(relation)\n          ::BulkImports::FileExportService\n        else\n          raise ::BulkImports::Error, 'Unsupported export relation'\n        end",
        "comment": "Returns an export service class for the given relation. @return TreeExportService if a relation is serializable and is listed in import_export.yml @return FileExportService if a relation is a file (uploads, lfs objects, git repository, etc.)",
        "label": "Property",
        "id": "7621"
    },
    {
        "raw_code": "def attach(attachable)\n      record.public_send(\"#{name}=\", attachable)\n      if record.persisted? && !record.changed?\n        return if !record.save\n      end",
        "comment": "Attaches an +attachable+ to the record.  If the record is persisted and unchanged, the attachment is saved to the database immediately. Otherwise, it'll be saved to the DB when the record is next saved.  person.avatar.attach(params[:avatar]) # ActionDispatch::Http::UploadedFile object person.avatar.attach(params[:signed_blob_id]) # Signed reference to blob from direct upload person.avatar.attach(io: File.open(\"/path/to/face.jpg\"), filename: \"face.jpg\", content_type: \"image/jpeg\") person.avatar.attach(avatar_blob) # ActiveStorage::Blob object",
        "label": "Property",
        "id": "13690"
    },
    {
        "raw_code": "def sort_title_created_date\n    s_('SortOptions|Created date')\n  end",
        "comment": "Titles.",
        "label": "Property",
        "id": "7777"
    },
    {
        "raw_code": "def to_hash\n      hash = {}\n      self.class.attribute_map.each_pair do |attr, param|\n        value = self.send(attr)\n        if value.nil?\n          is_nullable = self.class.openapi_nullable.include?(attr)\n          next if !is_nullable || (is_nullable && !instance_variable_defined?(:\"@#{attr}\"))\n        end",
        "comment": "Returns the object in the form of hash @return [Hash] Returns the object in the form of hash",
        "label": "Property",
        "id": "877"
    },
    {
        "raw_code": "def cvs_url\n    url = @store.options.webcvs\n\n    if /%s/ =~ url then\n      url % @relative_name\n    else\n      url + @relative_name\n    end",
        "comment": " Returns a URL for this source file on some web repository.  Use the -W command line option to set.",
        "label": "Property",
        "id": "16486"
    },
    {
        "raw_code": "def negotiate_mime(order)\n        formats.each do |priority|\n          if priority == Mime::ALL\n            return order.first\n          elsif order.include?(priority)\n            return priority\n          end",
        "comment": "Returns the first MIME type that matches the provided array of MIME types.",
        "label": "Property",
        "id": "11437"
    },
    {
        "raw_code": "def create_jira_cloud_integration!\n      integration = Integration.find_or_initialize_non_project_specific_integration(\n        'jira_cloud_app',\n        group_id: namespace.id\n      )\n\n      return unless integration\n\n      Integrations::JiraCloudApp.transaction do\n        integration.inherit_from_id = nil\n        integration.activate!\n\n        Integration.descendants_from_self_or_ancestors_from(integration).each_batch(of: BATCH_SIZE) do |records|\n          records.update!(active: true)\n        end",
        "comment": "We must make all GitLab for Jira app integrations active (or inactive in the DestroyService) regardless of whether those integration inherit, or have defined their own custom settings. Unless the group namespace is linked in Jira, the project integrations do not work, even if they are non-inheriting.  Using Integration.descendants_from_self_or_ancestors_from we update all integrations of all subgroups and sub projects to be active.  We keep their inherit_from_id intact, as they might have custom service_ids fields. We also still queue a PropagateIntegrationWorker in order to create integrations (the Integration.descendants_from_self_or_ancestors_from only updates existing ones).",
        "label": "Property",
        "id": "5676"
    },
    {
        "raw_code": "def compared_with(new_value)\n        delta  = new_value - @value\n        @value = new_value\n\n        delta\n      end",
        "comment": "new_value - The value to compare with as a Numeric.  Returns a new Numeric (depending on the type of `new_value`).",
        "label": "Property",
        "id": "2291"
    },
    {
        "raw_code": "def attribute_alias(name)\n        attribute_aliases[name.to_s]\n      end",
        "comment": "Returns the original name for the alias +name+",
        "label": "Property",
        "id": "12180"
    },
    {
        "raw_code": "def item_ids\n        group? ? group_ids_for(group) : []\n      end",
        "comment": "normally an array of item ids would be returned, however for this spec just return the group ids",
        "label": "Property",
        "id": "8539"
    },
    {
        "raw_code": "def local?\n      @local\n    end",
        "comment": "Returns true if we're in the development or test environment.",
        "label": "Property",
        "id": "13838"
    },
    {
        "raw_code": "def concurrent_foreign_key_name(table, column, prefix: 'fk_')\n        identifier = \"#{table}_#{multiple_columns(column, separator: '_')}_fk\"\n        hashed_identifier = Digest::SHA256.hexdigest(identifier).first(10)\n\n        \"#{prefix}#{hashed_identifier}\"\n      end",
        "comment": "Returns the name for a concurrent foreign key.  PostgreSQL constraint names have a limit of 63 bytes. The logic used here is based on Rails' foreign_key_name() method, which unfortunately is private so we can't rely on it directly.  prefix: - The default prefix is `fk_` for backward compatibility with the existing concurrent foreign key helpers. - For standard rails foreign keys the prefix is `fk_rails_` ",
        "label": "Property",
        "id": "2978"
    },
    {
        "raw_code": "def subject_snippets_path(subject = nil, opts = nil)\n    if subject.is_a?(Project)\n      project_snippets_path(subject, opts)\n    else # assume subject === User\n      dashboard_snippets_path(opts)\n    end",
        "comment": "Return the path of a snippets index for a user or for a project  @returns String, path to snippet index",
        "label": "Property",
        "id": "7749"
    },
    {
        "raw_code": "def parse(project, payload, monitoring_tool: nil, integration: nil)\n          payload_class = payload_class_for(monitoring_tool: monitoring_tool || payload&.dig('monitoring_tool'))\n\n          payload_class.new(project: project, payload: payload, integration: integration)\n        end",
        "comment": "Instantiates an instance of a subclass of Gitlab::AlertManagement::Payload::Base. This can be used to create new alerts or read content from the payload of an existing AlertManagement::Alert  @param project [Project] @param payload [Hash] @param monitoring_tool [String] @param integration [AlertManagement::HttpIntegration]",
        "label": "Property",
        "id": "2057"
    },
    {
        "raw_code": "def readonly!\n      @readonly = true\n    end",
        "comment": "Prevents records from being written to the database:  customer = Customer.new customer.readonly! customer.save # raises ActiveRecord::ReadOnlyRecord  customer = Customer.first customer.readonly! customer.update(name: 'New Name') # raises ActiveRecord::ReadOnlyRecord  Read-only records cannot be deleted from the database either:  customer = Customer.first customer.readonly! customer.destroy # raises ActiveRecord::ReadOnlyRecord  Please, note that the objects themselves are still mutable in memory:  customer = Customer.new customer.readonly! customer.name = 'New Name' # OK  but you won't be able to persist the changes.",
        "label": "Property",
        "id": "12439"
    },
    {
        "raw_code": "def put(key, value)\n      if key == ''\n        @object_types[:root] = [:root]\n        @store[:root] = value\n      else\n        @notfound.delete(key.to_sym)\n        (@object_types[value.type] ||= []) << key.to_s\n        if @store[key.to_sym]\n          @object_types[@store[key.to_sym].type].delete(key.to_s)\n        end",
        "comment": "Associates an object with a path @param [String, Symbol] key the path name (:root or '' for root object) @param [CodeObjects::Base] value the object to store @return [CodeObjects::Base] returns +value+",
        "label": "Property",
        "id": "96"
    },
    {
        "raw_code": "def references_in(text, pattern = object_reference_pattern)\n          case pattern\n          when Regexp\n            Gitlab::Utils::Gsub.gsub_with_limit(text, pattern, limit: Banzai::Filter::FILTER_ITEM_LIMIT) do |match_data|\n              yield match_data[0], match_data[:issue]\n            end",
        "comment": "Public: Find `JIRA-123` issue references in text  references_in(text, pattern) do |match, issue| \"<a href=...>##{issue}</a>\" end  text - String text to search.  Yields the String match and the String issue reference.  Returns a String replaced with the return of the block.",
        "label": "Property",
        "id": "3505"
    },
    {
        "raw_code": "def valid?\n      true\n    end",
        "comment": "Check to see if the all the properties in the model are valid @return true if the model is valid",
        "label": "Property",
        "id": "868"
    },
    {
        "raw_code": "def fallbacks\n        @fallbacks ||= {}\n      end",
        "comment": "Hold configured generators fallbacks. If a plugin developer wants a generator group to fall back to another group in case of missing generators, they can add a fallback.  For example, shoulda is considered a +test_framework+ and is an extension of +test_unit+. However, most part of shoulda generators are similar to +test_unit+ ones.  Shoulda then can tell generators to search for +test_unit+ generators when some of them are not available by adding a fallback:  Rails::Generators.fallbacks[:shoulda] = :test_unit",
        "label": "Property",
        "id": "14672"
    },
    {
        "raw_code": "def self.real_time\n      Time.at(Process.clock_gettime(Process::CLOCK_REALTIME))\n    end",
        "comment": "For some time related tasks we can't rely on `Time.now` since it will be affected by Timecop in some tests, and the clock of some gitaly-related components (grpc's c-core and gitaly server) use system time instead of timecop's time, so tests will fail. `Time.at(Process.clock_gettime(Process::CLOCK_REALTIME))` will circumvent timecop.",
        "label": "Property",
        "id": "1366"
    },
    {
        "raw_code": "def driver\n        if !@driver\n          if @machine.provider_config.compose\n            @driver = Driver::Compose.new(@machine)\n          else\n            @driver = Driver.new\n          end",
        "comment": "Returns the driver instance for this provider.",
        "label": "Property",
        "id": "9466"
    },
    {
        "raw_code": "def on_bad_each_with_object(_node)\n        raise NotImplementedError\n      end",
        "comment": "@abstract Implemented with `def_node_matcher`",
        "label": "Property",
        "id": "10444"
    },
    {
        "raw_code": "def test_should_destroy_a_parent_association_as_part_of_the_save_transaction_if_it_was_marked_for_destruction\n    assert_not_predicate @ship.pirate, :marked_for_destruction?\n\n    @ship.pirate.mark_for_destruction\n    id = @ship.pirate.id\n\n    assert_predicate @ship.pirate, :marked_for_destruction?\n    assert Pirate.find_by_id(id)\n\n    @ship.save\n    assert_nil @ship.reload.pirate\n    assert_nil Pirate.find_by_id(id)\n  end",
        "comment": "belongs_to",
        "label": "Property",
        "id": "13499"
    },
    {
        "raw_code": "def transform_move_actions(actions)\n      actions.map do |action|\n        action[:infer_content] = true if action[:content].nil?\n\n        action\n      end",
        "comment": "When moving a file, `content: nil` means \"use the contents of the previous file\", while `content: ''` means \"move the file and set it to empty\"",
        "label": "Property",
        "id": "5697"
    },
    {
        "raw_code": "def test; end\n              }\n            RUBY\n          end",
        "comment": "{access_modifier}",
        "label": "Property",
        "id": "10845"
    },
    {
        "raw_code": "def self.light_for_user(user)\n      if user\n        by_id(user.color_scheme_id)\n      else\n        default\n      end",
        "comment": "Get the light Scheme for the specified user, or the default  user - User record  Returns a Scheme",
        "label": "Property",
        "id": "1680"
    },
    {
        "raw_code": "def integration_name_to_type(name)\n          name = name.to_s\n          if all_integration_names.include?(name)\n            \"Integrations::#{name.camelize}\"\n          else\n            Gitlab::ErrorTracking.track_and_raise_for_dev_exception(UnknownType.new(name.inspect))\n          end",
        "comment": "Returns the STI type for the given integration name. Example: \"asana\" => \"Integrations::Asana\"",
        "label": "Property",
        "id": "7465"
    },
    {
        "raw_code": "def readonly_attributes\n        _attr_readonly\n      end",
        "comment": "Returns an array of all the attributes that have been specified as readonly.",
        "label": "Property",
        "id": "12595"
    },
    {
        "raw_code": "def on_bad_map_to_h(_node)\n        raise NotImplementedError\n      end",
        "comment": "@abstract Implemented with `def_node_matcher`",
        "label": "Property",
        "id": "10446"
    },
    {
        "raw_code": "def classes_and_includes_and_extends_for(name)\n    klasses = []\n    extends = []\n    includes = []\n\n    found = @stores.map do |store|\n      begin\n        klass = store.load_class name\n        klasses  << klass\n        extends  << [klass.extends,  store] if klass.extends\n        includes << [klass.includes, store] if klass.includes\n        [store, klass]\n      rescue RDoc::Store::MissingFileError\n      end",
        "comment": " Returns the stores wherein +name+ is found along with the classes, extends and includes that match it",
        "label": "Property",
        "id": "16591"
    },
    {
        "raw_code": "def days_since(days)\n      advance(days: days)\n    end",
        "comment": "Returns a new date/time the specified number of days in the future.",
        "label": "Property",
        "id": "14142"
    },
    {
        "raw_code": "def execute_query(query_type = Types::QueryType, schema: empty_schema, graphql: query_string, raise_on_error: false, variables: {})\n    schema.query(query_type)\n\n    r = schema.execute(\n      graphql,\n      context: { current_user: user },\n      variables: variables\n    )\n\n    if raise_on_error && r.to_h['errors'].present?\n      raise NoData, r.to_h['errors']\n    end",
        "comment": "assumes query_string and user to be let-bound in the current context",
        "label": "Property",
        "id": "8408"
    },
    {
        "raw_code": "def modified_paths\n      strong_memoize(:modified_paths) do\n        if merge_request?\n          merge_request.modified_paths\n        elsif branch_updated?\n          push_details.modified_paths\n        elsif external_pull_request?\n          external_pull_request.modified_paths\n        end",
        "comment": "Returns the modified paths.  The returned value is * Array: List of modified paths that should be evaluated * nil: Modified path can not be evaluated",
        "label": "Property",
        "id": "7579"
    },
    {
        "raw_code": "def self.cpu_spin(duration_s)\n      return unless Gitlab::Metrics::System.thread_cpu_time\n\n      expected_end_time = Gitlab::Metrics::System.thread_cpu_time + duration_s\n\n      rand while Gitlab::Metrics::System.thread_cpu_time < expected_end_time\n    end",
        "comment": "cpu_spin will consume all CPU on a single core for the specified duration",
        "label": "Property",
        "id": "1341"
    },
    {
        "raw_code": "def utc\n    utc = new_offset(0)\n\n    Time.utc(\n      utc.year, utc.month, utc.day,\n      utc.hour, utc.min, utc.sec + utc.sec_fraction\n    )\n  end",
        "comment": "Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.  DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24))     # => Mon, 21 Feb 2005 10:11:12 -0600 DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc # => Mon, 21 Feb 2005 16:11:12 UTC",
        "label": "Property",
        "id": "14197"
    },
    {
        "raw_code": "def to_s(options = {})\n        s = +\"[#{line.to_s.rjust(options[:indent])}] \"\n        s << \"[#{tag}] \" if options[:tag]\n        s << text\n      end",
        "comment": "Returns a representation of the annotation that looks like this:  [126] [TODO] This algorithm is simple and clearly correct, make it faster.  If +options+ has a flag <tt>:tag</tt> the tag is shown as in the example above. Otherwise the string contains just line and text.",
        "label": "Property",
        "id": "14689"
    },
    {
        "raw_code": "def up\n    add_concurrent_index :application_settings, :workspaces_oauth_application_id, name: INDEX_NAME\n    add_concurrent_foreign_key :application_settings, :oauth_applications,\n      column: :workspaces_oauth_application_id,\n      on_delete: :nullify\n  end",
        "comment": "@return [void]",
        "label": "Property",
        "id": "4975"
    },
    {
        "raw_code": "def link_include_file(file)\n      File.read(file)\n    end",
        "comment": "Include a file as a docstring in output @since 0.7.0 @param [String] file the filename to include @return [String] the file's contents",
        "label": "Property",
        "id": "430"
    },
    {
        "raw_code": "def version\n            version = Shell::Command.new(cmd, '--version').capture.stdout.dup\n            version.force_encoding('locale').split(\"\\n\").first\n          end",
        "comment": "Returns the version of tar command available  @return [String] the first line of `--version` output",
        "label": "Property",
        "id": "1050"
    },
    {
        "raw_code": "def self.populate_scheduling_type!\n      needs = Ci::BuildNeed.scoped_build.select(1)\n      where(scheduling_type: nil).update_all(\n        \"scheduling_type = CASE WHEN (EXISTS (#{needs.to_sql}))\n         THEN #{scheduling_types[:dag]}\n         ELSE #{scheduling_types[:stage]}\n         END\"\n      )\n    end",
        "comment": "Old processables may have scheduling_type as nil, so we need to ensure the data exists before using it.",
        "label": "Property",
        "id": "7546"
    },
    {
        "raw_code": "def scsi?\n          @storage_bus == :scsi\n        end",
        "comment": "Returns true if the storage controller is a SCSI type controller.  @return [Boolean]",
        "label": "Property",
        "id": "9664"
    },
    {
        "raw_code": "def sanitize_filename(filename)\n      filename.gsub(/.*[\\/\\\\]/, '')\n    end",
        "comment": "Sanitize filename by removing path. e.g. ../../sun.gif becomes sun.gif  @param [String] filename the filename to be sanitized @return [String] the sanitized filename",
        "label": "Property",
        "id": "836"
    },
    {
        "raw_code": "def iso8601(precision: nil)\n      ISO8601Serializer.new(self, precision: precision).serialize\n    end",
        "comment": "Build ISO 8601 Duration string for this duration. The +precision+ parameter can be used to limit seconds' precision of duration.",
        "label": "Property",
        "id": "13829"
    },
    {
        "raw_code": "def charset\n        has_encoding = defined?(::Encoding)\n        if defined?(@file) && @file && has_encoding\n          lang = @file.contents.encoding.to_s\n        else\n          return 'utf-8' unless has_encoding || ENV['LANG']\n          lang =\n            if has_encoding\n              ::Encoding.default_external.name.downcase\n            else\n              ENV['LANG'].downcase.split('.').last\n            end",
        "comment": "@group Getting the Character Encoding Returns the current character set. The default value can be overridden by setting the +LANG+ environment variable or by overriding this method. In Ruby 1.9 you can also modify this value by setting +Encoding.default_external+.  @return [String] the current character set @since 0.5.4",
        "label": "Property",
        "id": "419"
    },
    {
        "raw_code": "def ensure_proper_type\n        klass = self.class\n        if klass.finder_needs_type_condition?\n          _write_attribute(klass.inheritance_column, klass.sti_name)\n        end",
        "comment": "Sets the attribute used for single table inheritance to this class name if this is not the ActiveRecord::Base descendant. Considering the hierarchy Reply < Message < ActiveRecord::Base, this makes it possible to do Reply.new without having to set <tt>Reply[Reply.inheritance_column] = \"Reply\"</tt> yourself. No such attribute would be set for objects of the Message class in that example.",
        "label": "Property",
        "id": "12478"
    },
    {
        "raw_code": "def self.action(name)\n      app = lambda { |env|\n        req = ActionDispatch::Request.new(env)\n        res = make_response! req\n        new.dispatch(name, req, res)\n      }\n\n      if middleware_stack.any?\n        middleware_stack.build(name, app)\n      else\n        app\n      end",
        "comment": "Returns a Rack endpoint for the given action name.",
        "label": "Property",
        "id": "11232"
    },
    {
        "raw_code": "def list_messages(project_id, opts = {})\n      data, _status_code, _headers = list_messages_with_http_info(project_id, opts)\n      data\n    end",
        "comment": "List of messages @param project_id [Integer] ID of the project where the message was created @param [Hash] opts the optional parameters @option opts [Integer] :limit Number of entries to return (default to 20) @return [Array<MessageEvent>]",
        "label": "Property",
        "id": "1008"
    },
    {
        "raw_code": "def self.permanent_connection_checkout=(value)\n    unless [true, :deprecated, :disallowed].include?(value)\n      raise ArgumentError, \"permanent_connection_checkout must be one of: `true`, `:deprecated` or `:disallowed`\"\n    end",
        "comment": "Defines whether +ActiveRecord::Base.connection+ is allowed, deprecated, or entirely disallowed.",
        "label": "Property",
        "id": "12341"
    },
    {
        "raw_code": "def scope\n        @scope ||= @association.scope\n      end",
        "comment": "Returns a Relation object for the records in this association",
        "label": "Property",
        "id": "12799"
    },
    {
        "raw_code": "def to_arel\n        sql = Arel::Nodes::SqlLiteral.new(Union.new(@queries, **@union_args).to_sql)\n\n        Arel::Nodes::As.new(table, Arel::Nodes::Grouping.new(sql))\n      end",
        "comment": "Returns the Arel relation for this CTE.",
        "label": "Property",
        "id": "2856"
    },
    {
        "raw_code": "def assert_generates(expected_path, options, defaults = {}, extras = {}, message = nil)\n        if expected_path.include?(\"://\")\n          fail_on(URI::InvalidURIError, message) do\n            uri = URI.parse(expected_path)\n            expected_path = uri.path.to_s.empty? ? \"/\" : uri.path\n          end",
        "comment": "Asserts that the provided options can be used to generate the provided path. This is the inverse of `assert_recognizes`. The `extras` parameter is used to tell the request the names and values of additional request parameters that would be in a query string. The `message` parameter allows you to specify a custom error message for assertion failures.  The `defaults` parameter is unused.  # Asserts that the default action is generated for a route with no action assert_generates \"/items\", controller: \"items\", action: \"index\"  # Tests that the list action is properly routed assert_generates \"/items/list\", controller: \"items\", action: \"list\"  # Tests the generation of a route with a parameter assert_generates \"/items/list/1\", { controller: \"items\", action: \"list\", id: \"1\" }  # Asserts that the generated route gives us our custom route assert_generates \"changesets/12\", { controller: 'scm', action: 'show_diff', revision: \"12\" }",
        "label": "Property",
        "id": "11643"
    },
    {
        "raw_code": "def assert_field_default_value(attribute_type, value)\n          if value.nil?\n            assert_nil(create_generated_attribute(attribute_type).default)\n          else\n            assert_equal(value, create_generated_attribute(attribute_type).default)\n          end",
        "comment": "Asserts the given attribute type gets a proper default value:  assert_field_default_value :string, \"MyString\"",
        "label": "Property",
        "id": "14797"
    },
    {
        "raw_code": "def register(id)\n        @messages[id] ||= Message.new(id)\n      end",
        "comment": "Registers a {Message}, the message ID of which is +id+. If corresponding +Message+ is already registered, the previously registered object is returned.  @param [String] id the ID of the message to be registered. @return [Message] the registered +Message+.",
        "label": "Property",
        "id": "727"
    },
    {
        "raw_code": "def self.filter_by_feature_visibility(feature, user)\n    with_feature_available_for_user(feature, user)\n      .public_or_visible_to_user(\n        user,\n        ProjectFeature.required_minimum_access_level_for_private_project(feature)\n      )\n  end",
        "comment": "This scope returns projects where user has access to both the project and the feature.",
        "label": "Property",
        "id": "6725"
    },
    {
        "raw_code": "def self.spec_requires_and_configuration\n    require 'gitlab/rspec/next_instance_of'\n    require 'hashdiff'\n    require_relative 'support/patches/rspec_mocks_doubles_fast_spec_helper_patch'\n    require_relative 'support/matchers/result_matchers'\n    require_relative 'support/railway_oriented_programming'\n    require_relative 'simplecov_env'\n\n    # NOTE: Consider making any common RSpec configuration tweaks in `spec/support/rspec.rb` instead of here,\n    # because it is also used by `spec/spec_helper.rb`.\n    RSpec.configure do |config|\n      config.include NextInstanceOf\n      config.disable_monkey_patching! # Enable zero monkey patching mode before loading any other RSpec code.\n      config.mock_with :rspec do |mocks|\n        mocks.verify_doubled_constant_names = false # Allow mocking of non-lib module/class names from Rails\n      end",
        "comment": "@return [void]",
        "label": "Property",
        "id": "8174"
    },
    {
        "raw_code": "def typecast_output!(output)\n            case output\n            # Matches an array with a path followed by 'read,write' flag and permissions bit\n            # E.g. [Pathname.new('/tmp/file'), 'w', 0o600] OR\n            # Matches an array with a path followed by bit based flag and permissions bit\n            # E.g. [Pathname.new('/tmp/file'), File::WRONLY|File::CREAT, 0o600]\n            in [Pathname, String, Integer] | [Pathname, Integer, Integer]\n              output[0] = output[0].to_s\n              output\n            in Pathname\n              output.to_s\n            else\n              output\n            end",
        "comment": "When providing an output to Open3.pipeline / spawn, we can't pass a Pathname. It needs to be converted to a string, otherwise we get an error",
        "label": "Property",
        "id": "1046"
    },
    {
        "raw_code": "def online?\n          # Avoid using a discarded connection pool because attempting\n          # to use it will fail. After the main process forks, all of\n          # its connection pools are discarded from Rails' ForkTracker.\n          return false if discarded?\n          return @online unless check_replica_status?\n\n          was_online = @online\n          refresh_status\n\n          # Log that the host came back online if it was previously offline\n          if @online && !was_online\n            ::Gitlab::Database::LoadBalancing::Logger.info(\n              event: :host_online,\n              message: 'Host is online after replica status check',\n              db_host: @host,\n              db_port: @port,\n              lag_time: @lag_time,\n              lag_size: @lag_size\n            )\n          # Always log if the host goes offline\n          elsif !@online\n            ::Gitlab::Database::LoadBalancing::Logger.warn(\n              event: :host_offline,\n              message: 'Host is offline after replica status check',\n              db_host: @host,\n              db_port: @port,\n              lag_time: @lag_time,\n              lag_size: @lag_size\n            )\n          end",
        "comment": "Returns true if the host is online.",
        "label": "Property",
        "id": "3070"
    },
    {
        "raw_code": "def rerun_workflow_run(repo, id, options = {})\n        boolean_from_response :post, \"#{Repository.path repo}/actions/runs/#{id}/rerun\", options\n      end",
        "comment": "Re-runs a workflow run  @param repo [Integer, String, Repository, Hash] A GitHub repository @param id [Integer] Id of a workflow run  @return [Boolean] Returns true if the re-run request was accepted @see https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow",
        "label": "Property",
        "id": "15117"
    },
    {
        "raw_code": "def _HtmlBlockOpenHead\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenHead = \"<\" Spnl (\"head\" | \"HEAD\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "15725"
    },
    {
        "raw_code": "def matched_attribute_method(method_name)\n        matches = self.class.send(:attribute_method_patterns_matching, method_name)\n        matches.detect { |match| attribute_method?(match.attr_name) }\n      end",
        "comment": "Returns a struct representing the matching attribute method. The struct's attributes are prefix, base and suffix.",
        "label": "Property",
        "id": "12188"
    },
    {
        "raw_code": "def changed_for_autosave?\n      new_record? || has_changes_to_save? || marked_for_destruction? || nested_records_changed_for_autosave?\n    end",
        "comment": "Returns whether or not this record has been changed in any way (including whether any of its nested autosave associations are likewise changed)",
        "label": "Property",
        "id": "12382"
    },
    {
        "raw_code": "def _HtmlBlockOpenH3\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenH3 = \"<\" Spnl (\"h3\" | \"H3\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "15656"
    },
    {
        "raw_code": "def ancestors\n    includes.map { |i| i.module }.reverse\n  end",
        "comment": " Ancestors list for this ClassModule: the list of included modules (classes will add their superclass if any).  Returns the included classes or modules, not the includes themselves. The returned values are either String or RDoc::NormalModule instances (see RDoc::Include#module).  The values are returned in reverse order of their inclusion, which is the order suitable for searching methods/attributes in the ancestors. The superclass, if any, comes last.",
        "label": "Property",
        "id": "16737"
    },
    {
        "raw_code": "def load_methods_matching(name)\n    found = []\n\n    find_methods name do |store, klass, ancestor, types, method|\n      methods = []\n\n      methods << load_method(store, :class_methods, ancestor, '::',  method) if\n        [:class, :both].include? types\n\n      methods << load_method(store, :instance_methods, ancestor, '#',  method) if\n        [:instance, :both].include? types\n\n      found << [store, methods.compact]\n    end",
        "comment": " Returns an Array of RI data for methods matching +name+",
        "label": "Property",
        "id": "16610"
    },
    {
        "raw_code": "def insert_and_return_id(attributes, relation)\n        # We use bulk_insert here so we can bypass any queries executed by\n        # callbacks or validation rules, as doing this wouldn't scale when\n        # importing very large projects.\n        result = ApplicationRecord # rubocop:disable Gitlab/BulkInsert\n                 .legacy_bulk_insert(relation.table_name, [attributes], return_ids: true)\n\n        result.first\n      end",
        "comment": "Inserts a raw row and returns the ID of the inserted row.  attributes - The attributes/columns to set. relation - An ActiveRecord::Relation to use for finding the table name",
        "label": "Property",
        "id": "2918"
    },
    {
        "raw_code": "def path\n        @path ||= if parent && !parent.root?\n                    [parent.path, name.to_s].join(sep)\n                  else\n                    name.to_s\n                  end",
        "comment": "Represents the unique path of the object. The default implementation joins the path of {#namespace} with {#name} via the value of {#sep}. Custom code objects should ensure that the path is unique to the code object by either overriding {#sep} or this method.  @example The path of an instance method MethodObject.new(P(\"A::B\"), :c).path # => \"A::B#c\" @return [String] the unique path of the object @see #sep",
        "label": "Property",
        "id": "579"
    },
    {
        "raw_code": "def options\n        # Build the list of parameters to execute with cURL\n        options = [\n          \"--fail\",\n          \"--location\",\n          \"--max-redirs\", \"10\", \"--verbose\",\n          \"--user-agent\", USER_AGENT,\n        ]\n\n        options += [\"--cacert\", @ca_cert] if @ca_cert\n        options += [\"--capath\", @ca_path] if @ca_path\n        options += [\"--continue-at\", \"-\"] if @continue\n        options << \"--insecure\" if @insecure\n        options << \"--cert\" << @client_cert if @client_cert\n        options << \"-u\" << @auth if @auth\n        options << \"--location-trusted\" if @location_trusted\n        options << \"--ssl-revoke-best-effort\" if @ssl_revoke_best_effort\n\n        options.concat(@extra_download_options)\n\n        if @headers\n          Array(@headers).each do |header|\n            options << \"-H\" << header\n          end",
        "comment": "Returns the various cURL and subprocess options.  @return [Array<Array, Hash>]",
        "label": "Property",
        "id": "9168"
    },
    {
        "raw_code": "def automatic_update_check_allowed?\n      check_path = directory.join(\"box_update_check\")\n      if check_path.exist?\n        last_check_span = Time.now.to_i - check_path.mtime.to_i\n        if last_check_span < BOX_UPDATE_CHECK_INTERVAL\n          @logger.info(\"box update check is under the interval threshold\")\n          return false\n        end",
        "comment": "Check if a box update check is allowed. Uses a file in the box data directory to track when the last auto update check was performed and returns true if the BOX_UPDATE_CHECK_INTERVAL has passed.  @return [Boolean]",
        "label": "Property",
        "id": "8726"
    },
    {
        "raw_code": "def alias_to(alias_table)\n        Arel::Nodes::As.new(table, alias_table)\n      end",
        "comment": "Returns an \"AS\" statement that aliases the CTE name as the given table name. This allows one to trick ActiveRecord into thinking it's selecting from an actual table, when in reality it's selecting from a CTE.  alias_table - The Arel table to use as the alias.",
        "label": "Property",
        "id": "2850"
    },
    {
        "raw_code": "def scheduled?\n      !!@future_result\n    end",
        "comment": "Returns <tt>true</tt> if the relation was scheduled on the background thread pool.",
        "label": "Property",
        "id": "12660"
    },
    {
        "raw_code": "def releases_by_minor\n        return unless releases\n\n        @releases_by_minor ||= releases.group_by(&:without_patch).transform_values(&:max)\n      end",
        "comment": "Returns a hash with the latest runner version per minor release ",
        "label": "Property",
        "id": "2456"
    },
    {
        "raw_code": "def assoc(key)\n      super(convert_key(key))\n    end",
        "comment": "Same as <tt>Hash#assoc</tt> where the key passed as argument can be either a string or a symbol:  counters = ActiveSupport::HashWithIndifferentAccess.new counters[:foo] = 1  counters.assoc('foo') # => [\"foo\", 1] counters.assoc(:foo)  # => [\"foo\", 1] counters.assoc(:zoo)  # => nil",
        "label": "Property",
        "id": "13879"
    },
    {
        "raw_code": "def self.version\n    gem_version\n  end",
        "comment": "Returns the currently loaded version of Action Mailbox as a +Gem::Version+.",
        "label": "Property",
        "id": "11105"
    },
    {
        "raw_code": "def diff_blobs_with_raw_info(...)\n        wrapped_gitaly_errors do\n          gitaly_diff_client.diff_blobs_with_raw_info(...)\n        end",
        "comment": "Returns an array of DiffBlob objects that represent diffs between pairs of blobs in a repository using raw changed path information. More efficient for large batches of files compared to diff_blobs.",
        "label": "Property",
        "id": "2636"
    },
    {
        "raw_code": "def self.exec(ssh_info, opts={})\n        # Ensure the platform supports ssh. On Windows there are several programs which\n        # include ssh, notably git, mingw and cygwin, but make sure ssh is in the path!\n\n        # First try using the original path provided\n        if ENV[\"VAGRANT_PREFER_SYSTEM_BIN\"] != \"0\"\n          ssh_path = Which.which(\"ssh\", original_path: true)\n        end",
        "comment": "Halts the running of this process and replaces it with a full-fledged SSH shell into a remote machine.  Note: This method NEVER returns. The process ends after this.  @param [Hash] ssh_info This is the SSH information. For the keys required please see the documentation of {Machine#ssh_info}. @param [Hash] opts These are additional options that are supported by exec.",
        "label": "Property",
        "id": "9247"
    },
    {
        "raw_code": "def push_reference_with_composite_key(project, record, attribute, composite_key, source_user_identifier)\n        return unless allowed_to_push?(project, source_user_identifier)\n\n        source_user = source_user_mapper(project).find_source_user(source_user_identifier)\n\n        # Do not create a reference if the object is already associated with a real user.\n        return if source_user_mapped_to_human?(record, attribute, source_user)\n\n        ::Import::PlaceholderReferences::PushService.new(\n          import_source: import_type,\n          import_uid: project.import_state.id,\n          source_user_id: source_user.id,\n          source_user_namespace_id: source_user.namespace_id,\n          model: record.class,\n          user_reference_column: attribute,\n          composite_key: composite_key\n        ).execute\n      end",
        "comment": "Pushes a placeholder reference using a composite key. This is used when the record requires a composite key for the reference.",
        "label": "Property",
        "id": "3737"
    },
    {
        "raw_code": "def synced_folders(machine, **opts)\n          return cached_synced_folders(machine) if opts[:cached]\n\n          config = opts[:config]\n          root   = false\n          if !config\n            config = machine.config.vm\n            root   = true\n          end",
        "comment": "This returns the set of shared folders that should be done for this machine. It returns the folders in a hash keyed by the implementation class for the synced folders.  @return [Hash<Symbol, Hash<String, Hash>>]",
        "label": "Property",
        "id": "9331"
    },
    {
        "raw_code": "def self.civil_from_format(utc_or_local, year, month = 1, day = 1, hour = 0, min = 0, sec = 0)\n    if utc_or_local.to_sym == :local\n      offset = ::Time.local(year, month, day).utc_offset.to_r / 86400\n    else\n      offset = 0\n    end",
        "comment": "Returns DateTime with local offset for given year if format is local else offset is zero.  DateTime.civil_from_format :local, 2012 # => Sun, 01 Jan 2012 00:00:00 +0300 DateTime.civil_from_format :local, 2012, 12, 17 # => Mon, 17 Dec 2012 00:00:00 +0000",
        "label": "Property",
        "id": "14205"
    },
    {
        "raw_code": "def [](arg)\n        case arg\n        when self\n          arg\n        when String\n          begin\n            @lazy_zones_map[arg] ||= create(arg)\n          rescue TZInfo::InvalidTimezoneIdentifier\n            nil\n          end",
        "comment": "Locate a specific time zone object. If the argument is a string, it is interpreted to mean the name of the timezone to locate. If it is a numeric value it is either the hour offset, or the second offset, of the timezone to find. (The first one with that offset will be returned.) Returns +nil+ if no such time zone is known to the system.",
        "label": "Property",
        "id": "14557"
    },
    {
        "raw_code": "def diff_blobs(\n        blob_pairs, diff_mode: DIFF_MODES[:unspecified], whitespace_changes: WHITESPACE_CHANGES[:unspecified],\n        patch_bytes_limit: 0\n      )\n        request = Gitaly::DiffBlobsRequest.new(\n          repository: @gitaly_repo,\n          blob_pairs: blob_pairs,\n          diff_mode: diff_mode,\n          whitespace_changes: whitespace_changes,\n          patch_bytes_limit: patch_bytes_limit\n        )\n\n        response = gitaly_client_call(@storage, :diff_service, :diff_blobs, request,\n          timeout: GitalyClient.medium_timeout)\n\n        GitalyClient::DiffBlobsStitcher.new(response)\n      end",
        "comment": "Requests diffs between blob pairs via Gitaly's DiffBlobs RPC using blob_pairs field.  @param blob_pairs [Array<Gitaly::DiffBlobsRequest::BlobPair>] Array of blob ID pairs to diff @param diff_mode [Symbol] Diff output mode (:unspecified, :word) @param whitespace_changes [Symbol] Whitespace handling (:unspecified, :ignore_spaces, :ignore_all_spaces) @param patch_bytes_limit [Integer] Maximum patch size in bytes (0 = unlimited) @return [GitalyClient::DiffBlobsStitcher] Streamed diff responses from Gitaly",
        "label": "Property",
        "id": "1810"
    },
    {
        "raw_code": "def https!(flag = true)\n        @https = flag\n      end",
        "comment": "Specify whether or not the session should mimic a secure HTTPS request.  session.https! session.https!(false)",
        "label": "Property",
        "id": "11625"
    },
    {
        "raw_code": "def available?\n          !@@gettext_version.nil?\n        end",
        "comment": "@return [Boolean] true if gettext is available, false otherwise.",
        "label": "Property",
        "id": "716"
    },
    {
        "raw_code": "def without_format(path)\n    path.split('(', 2)[0]\n  end",
        "comment": "Pass in a full path to remove the format segment: `/ci/lint(.:format)` -> `/ci/lint`",
        "label": "Property",
        "id": "8223"
    },
    {
        "raw_code": "def base_dir\n      namespace.full_path\n    end",
        "comment": "Base directory  @return [String] directory where repository is stored",
        "label": "Property",
        "id": "7212"
    },
    {
        "raw_code": "def read_host_only_interfaces\n        end",
        "comment": "Returns a list of available host only interfaces.  Each interface is represented as a Hash with the following details:  { :name         => String, # interface name, e.g. \"vboxnet0\" :ip           => String, # IP address of the interface, e.g. \"172.28.128.1\" :netmask      => String, # netmask associated with the interface, e.g. \"255.255.255.0\" :status       => String, # status of the interface, e.g. \"Up\", \"Down\" :display_name => String, # user friendly display name if available }  @return [Array<Hash>] See comment above for details",
        "label": "Property",
        "id": "9583"
    },
    {
        "raw_code": "def next_batch_count\n      limit = batch_limit - pipeline_tracker.batches.in_progress.limit(batch_limit).count\n      [limit, 0].max\n    end",
        "comment": "Calculate the number of batches, up to `batch_limit`, to process in the next round.",
        "label": "Property",
        "id": "6378"
    },
    {
        "raw_code": "def changes\n      mutations_from_database.changes\n    end",
        "comment": "Returns a hash of changed attributes indicating their original and new values like <tt>attr => [original value, new value]</tt>.  person.changes # => {} person.name = 'bob' person.changes # => { \"name\" => [\"bill\", \"bob\"] }",
        "label": "Property",
        "id": "12207"
    },
    {
        "raw_code": "def get_port_and_device(disk_uuid)\n          disk = {}\n\n          storage_controllers = read_storage_controllers\n          storage_controllers.each do |controller|\n            controller.attachments.each do |attachment|\n              if disk_uuid == attachment[:uuid]\n                disk[:port] = attachment[:port]\n                disk[:device] = attachment[:device]\n                return disk\n              end",
        "comment": "Returns port and device for an attached disk given a disk uuid. Returns empty hash if disk is not attachd to guest  @param [String] disk_uuid - the UUID for the disk we are searching for @return [Hash] disk_info - Contains a device and port number",
        "label": "Property",
        "id": "9613"
    },
    {
        "raw_code": "def assigned?(node)\n          return false unless (parent = node.parent)&.assignment?\n\n          lhs, _method, _rhs = *parent\n          node == lhs\n        end",
        "comment": "The following are allowed cases:  - `ENV['key']` is a receiver of `||=`, e.g. `ENV['X'] ||= y`. - `ENV['key']` is a receiver of `&&=`, e.g. `ENV['X'] &&= y`.",
        "label": "Property",
        "id": "10499"
    },
    {
        "raw_code": "def _HtmlBlockOpenTd\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenTd = \"<\" Spnl (\"td\" | \"TD\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "15707"
    },
    {
        "raw_code": "def parse_node(node)\n            return unless node\n\n            case node.node\n            when :constraint\n              parse_node(node.constraint.raw_expr)\n            when :partition_elem\n              node.partition_elem.name\n            when :func_call\n              \"#{parse_node(node.func_call.funcname.first)}()\"\n            when :a_const\n              parse_a_const(node.a_const)\n            when :type_cast\n              value = parse_node(node.type_cast.arg)\n              type = type(node.type_cast.type_name)\n              separator = MAPPINGS.key?(value) ? '' : \"::#{type}\"\n\n              [MAPPINGS.fetch(value, \"'#{value}'\"), separator].compact.join\n            else\n              get_value_from_key(node, key: node.node)\n            end",
        "comment": "Parses PGQuery nodes recursively  :constraint:: nodes that groups column default info :partition_elem:: node that store partition key info :func_cal:: nodes that stores functions, like +now()+ :a_const:: nodes that stores constant values, like +t+, +f+, +0.0.0.0+, +255+, +1.0+ :type_cast:: nodes that stores casting values, like +'name'::text+, +'0.0.0.0'::inet+ else:: extract node values in the last iteration of the recursion, like +int4+, +1.0+, +now+, +255+  @note boolean types types are mapped from +t+, +f+ to +true+, +false+",
        "label": "Property",
        "id": "1180"
    },
    {
        "raw_code": "def default_sequence_name(table_name, pk = \"id\") # :nodoc:\n          return nil if pk.is_a?(Array)\n\n          result = serial_sequence(table_name, pk)\n          return nil unless result\n          Utils.extract_schema_qualified_name(result).to_s\n        rescue ActiveRecord::StatementInvalid\n          PostgreSQL::Name.new(nil, \"#{table_name}_#{pk}_seq\").to_s\n        end",
        "comment": "Returns the sequence name for a table's primary key or some other specified key.",
        "label": "Property",
        "id": "13254"
    },
    {
        "raw_code": "def base_dir\n            \"#{@prefix}/#{disk_hash[0..1]}/#{disk_hash[2..3]}\" if disk_hash\n          end",
        "comment": "Base directory  @return [String] directory where repository is stored",
        "label": "Property",
        "id": "1104"
    },
    {
        "raw_code": "def invalid_target?\n        @target_version && @target_version != 0 && !target\n      end",
        "comment": "Return true if a valid version is not provided.",
        "label": "Property",
        "id": "12506"
    },
    {
        "raw_code": "def cvs_url(url, full_path)\n    if /%s/ =~ url then\n      sprintf url, full_path\n    else\n      url + full_path\n    end",
        "comment": " Build a webcvs URL starting for the given +url+ with +full_path+ appended as the destination path.  If +url+ contains '%s' +full_path+ will be will replace the %s using sprintf on the +url+.",
        "label": "Property",
        "id": "16481"
    },
    {
        "raw_code": "def has_user?(user)\n    return false unless user\n\n    group_members.non_invite.exists?(user: user)\n  end",
        "comment": "Only for direct and not requested members with higher access level than MIMIMAL_ACCESS It returns true for non-active users",
        "label": "Property",
        "id": "7021"
    },
    {
        "raw_code": "def list\n        ret = []\n        each_data{|data|\n          ret << data.to_s\n        }\n        ret\n      end",
        "comment": " Returns all the FormData as an Array",
        "label": "Property",
        "id": "676"
    },
    {
        "raw_code": "def sandbox(*values)\n      if values.empty?\n        @directives[\"sandbox\"] = true\n      elsif values.first\n        @directives[\"sandbox\"] = values\n      else\n        @directives.delete(\"sandbox\")\n      end",
        "comment": "Specify whether a [sandbox](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/sandbox) should be enabled for the requested resource:  policy.sandbox  Values can be passed as arguments:  policy.sandbox \"allow-scripts\", \"allow-modals\"  Pass `false` to disable the sandbox:  policy.sandbox false ",
        "label": "Property",
        "id": "11418"
    },
    {
        "raw_code": "def gather_references(nodes, ids_only: false)\n        nodes = nodes_user_can_reference(current_user, nodes)\n        visible = nodes_visible_to_user(current_user, nodes)\n\n        { visible: referenced_by(visible, ids_only: ids_only), nodes: nodes, visible_nodes: visible }\n      end",
        "comment": "Gathers the references for the given HTML nodes.  Returns visible references and a list of nodes which are not visible to the user",
        "label": "Property",
        "id": "3433"
    },
    {
        "raw_code": "def foo(a, b, c)\n          source_code_here\n        end",
        "comment": "A docstring @return [String] a tag",
        "label": "Property",
        "id": "814"
    },
    {
        "raw_code": "def self.build_from_hash(attributes)\n      new.build_from_hash(attributes)\n    end",
        "comment": "Builds the object from hash @param [Hash] attributes Model attributes in the form of hash @return [Object] Returns the model itself",
        "label": "Property",
        "id": "942"
    },
    {
        "raw_code": "def read\n      super\n    rescue ActiveSupport::EncryptedFile::MissingContentError\n      # Allow a config to be started without a file present\n      \"\"\n    end",
        "comment": "Reads the file and returns the decrypted content. See EncryptedFile#read.",
        "label": "Property",
        "id": "13833"
    },
    {
        "raw_code": "def values_at(*keys)\n      keys.map! { |key| convert_key(key) }\n      super\n    end",
        "comment": "Returns an array of the values at the specified indices:  hash = ActiveSupport::HashWithIndifferentAccess.new hash[:a] = 'x' hash[:b] = 'y' hash.values_at('a', 'b') # => [\"x\", \"y\"]",
        "label": "Property",
        "id": "13883"
    },
    {
        "raw_code": "def serialize(argument)\n        serializer = @serializers_index[argument.class] || serializers.find { |s| s.serialize?(argument) }\n        raise SerializationError.new(\"Unsupported argument type: #{argument.class.name}\") unless serializer\n        serializer.serialize(argument)\n      end",
        "comment": "Returns serialized representative of the passed object. Will look up through all known serializers. Raises ActiveJob::SerializationError if it can't find a proper serializer.",
        "label": "Property",
        "id": "12136"
    },
    {
        "raw_code": "def nfs_export(id, ip, folders)\n        end",
        "comment": "Exports the given hash of folders via NFS.  @param [String] id A unique ID that is guaranteed to be unique to match these sets of folders. @param [String] ip IP of the guest machine. @param [Hash] folders Shared folders to sync.",
        "label": "Property",
        "id": "8998"
    },
    {
        "raw_code": "def exists?\n      Gitlab::Redis::SharedState.with do |redis|\n        redis.exists?(@redis_shared_state_key) # rubocop:disable CodeReuse/ActiveRecord\n      end",
        "comment": "Returns true if the key for this lease is set.",
        "label": "Property",
        "id": "1762"
    },
    {
        "raw_code": "def self.current_role\n        connected_to_stack.reverse_each do |hash|\n          return hash[:role] if hash[:role] && hash[:klasses].include?(Base)\n          return hash[:role] if hash[:role] && hash[:klasses].include?(connection_class_for_self)\n        end",
        "comment": "Returns the symbol representing the current connected role.  ActiveRecord::Base.connected_to(role: :writing) do ActiveRecord::Base.current_role #=> :writing end  ActiveRecord::Base.connected_to(role: :reading) do ActiveRecord::Base.current_role #=> :reading end",
        "label": "Property",
        "id": "12416"
    },
    {
        "raw_code": "def initialize(filename)\n      @filename = filename\n    end",
        "comment": "Create a new rotator. +filename+ is used to store values by +calculate!+, and to update the database with new and old values in +apply!+ and +rollback!+, respectively.",
        "label": "Property",
        "id": "1477"
    },
    {
        "raw_code": "def label(method, text = nil, options = {}, &block)\n        @template.label(@object_name, method, text, objectify_options(options), &block)\n      end",
        "comment": "Returns a label tag tailored for labelling an input field for a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). The text of label will default to the attribute name unless a translation is found in the current I18n locale (through <tt>helpers.label.<modelname>.<attribute></tt>) or you specify it explicitly. Additional options on the label tag can be passed as a hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example shown, except for the <tt>:value</tt> option, which is designed to target labels for radio_button tags (where the value is used in the ID of the input tag).  ==== Examples label(:title) # => <label for=\"article_title\">Title</label>  You can localize your labels based on model and attribute names. For example you can define the following in your locale (e.g. en.yml)  helpers: label: article: body: \"Write your entire text here\"  Which then will result in  label(:body) # => <label for=\"article_body\">Write your entire text here</label>  Localization can also be based purely on the translation of the attribute-name (if you are using ActiveRecord):  activerecord: attributes: article: cost: \"Total cost\"  <code></code>  label(:cost) # => <label for=\"article_cost\">Total cost</label>  label(:title, \"A short title\") # => <label for=\"article_title\">A short title</label>  label(:title, \"A short title\", class: \"title_label\") # => <label for=\"article_title\" class=\"title_label\">A short title</label>  label(:privacy, \"Public Article\", value: \"public\") # => <label for=\"article_privacy_public\">Public Article</label>  label(:cost) do |translation| content_tag(:span, translation, class: \"cost_label\") end # => <label for=\"article_cost\"><span class=\"cost_label\">Total cost</span></label>  label(:cost) do |builder| content_tag(:span, builder.translation, class: \"cost_label\") end # => <label for=\"article_cost\"><span class=\"cost_label\">Total cost</span></label>  label(:cost) do |builder| content_tag(:span, builder.translation, class: [ \"cost_label\", (\"error_label\" if builder.object.errors.include?(:cost)) ]) end # => <label for=\"article_cost\"><span class=\"cost_label error_label\">Total cost</span></label>  label(:terms) do raw('Accept <a href=\"/terms\">Terms</a>.') end # => <label for=\"article_terms\">Accept <a href=\"/terms\">Terms</a>.</label>",
        "label": "Property",
        "id": "11891"
    },
    {
        "raw_code": "def fetch(*key)\n      @cache.fetch(key) do\n        @cache[key] = yield\n      end",
        "comment": "Caches a value for key, or returns the previously cached value. If a value has been previously cached for key then it is returned. Otherwise, block is yielded to and its return value which may be nil, is cached under key and returned.",
        "label": "Property",
        "id": "8575"
    },
    {
        "raw_code": "def synced_folders\n      self.class.synced_folders(self)\n    end",
        "comment": "This returns the set of shared folders that should be done for this machine. It returns the folders in a hash keyed by the implementation class for the synced folders.  @return [Hash<Symbol, Hash<String, Hash>>]",
        "label": "Property",
        "id": "8791"
    },
    {
        "raw_code": "def select_day(date, options = {}, html_options = {})\n        DateTimeSelector.new(date, options, html_options).select_day\n      end",
        "comment": "Returns a select tag with options for each of the days 1 through 31 with the current day selected. The <tt>date</tt> can also be substituted for a day number. If you want to display days with a leading zero set the <tt>:use_two_digit_numbers</tt> key in +options+ to true. Override the field name using the <tt>:field_name</tt> option, 'day' by default.  my_date = Time.now + 2.days  # Generates a select field for days that defaults to the day for the date in my_date. select_day(my_date)  # Generates a select field for days that defaults to the number given. select_day(5)  # Generates a select field for days that defaults to the number given, but displays it with two digits. select_day(5, use_two_digit_numbers: true)  # Generates a select field for days that defaults to the day for the date in my_date # that is named 'due' rather than 'day'. select_day(my_date, field_name: 'due')  # Generates a select field for days with a custom prompt. Use <tt>prompt: true</tt> for a # generic prompt. select_day(5, prompt: 'Choose day')",
        "label": "Property",
        "id": "11836"
    },
    {
        "raw_code": "def self.system_plugins_file\n        dir = Vagrant.installer_embedded_dir\n        return nil if !dir\n        Pathname.new(dir).join(\"plugins.json\")\n      end",
        "comment": "Returns the path to the [StateFile] for system plugins.",
        "label": "Property",
        "id": "8950"
    },
    {
        "raw_code": "def resolve_relative_path(path, base_path)\n        p = Pathname(base_path)\n        p = p.dirname unless p.extname.empty?\n        p += path\n\n        p.cleanpath.to_s\n      end",
        "comment": "Resolves the given relative path of file in repository into canonical path based on the specified base_path.  Examples:  # File in the same directory as the current path resolve_relative_path(\"users.adoc\", \"doc/api/README.adoc\") # => \"doc/api/users.adoc\"  # File in the same directory, which is also the current path resolve_relative_path(\"users.adoc\", \"doc/api\") # => \"doc/api/users.adoc\"  # Going up one level to a different directory resolve_relative_path(\"../update/7.14-to-8.0.adoc\", \"doc/api/README.adoc\") # => \"doc/update/7.14-to-8.0.adoc\"  Returns a String",
        "label": "Property",
        "id": "3442"
    },
    {
        "raw_code": "def speak(room_name, message, auth)\n      room = rooms(auth).find { |r| r[\"name\"] == room_name }\n      return unless room\n\n      path = \"/room/#{room['id']}/speak.json\"\n      body = {\n        body: {\n          message: {\n            type: 'TextMessage',\n            body: message\n          }\n        }\n      }\n      res = Clients::HTTP.post(path, base_uri: base_uri, **auth.merge(body))\n      res.code == 201 ? res : nil\n    end",
        "comment": "Post a message into a room, returns the message Hash in case of success. Returns nil otherwise. https://github.com/basecamp/campfire-api/blob/master/sections/messages.md#create-message",
        "label": "Property",
        "id": "7648"
    },
    {
        "raw_code": "def documentation_source(path)\n    _, source_name, path = path.split '/', 3\n\n    store = @stores[source_name]\n    return store, path if store\n\n    store = store_for source_name\n\n    store.load_all\n\n    @stores[source_name] = store\n\n    return store, path\n  end",
        "comment": " Returns the RDoc::Store and path relative to +mount_path+ for documentation at +path+.",
        "label": "Property",
        "id": "15938"
    },
    {
        "raw_code": "def breadcrumb(page_slug)\n    page_slug.split('/')\n      .map { |dir_or_page| WikiPage.unhyphenize(dir_or_page).capitalize }\n      .join(' / ')\n  end",
        "comment": "Produces a pure text breadcrumb for a given page.  page_slug - The slug of a WikiPage object.  Returns a String composed of the capitalized name of each directory and the capitalized name of the page itself.",
        "label": "Property",
        "id": "7809"
    },
    {
        "raw_code": "def weak_for_user?(password, user)\n        user_info_in_password?(password, user) || common_phrases_in_password?(password)\n      end",
        "comment": "Returns true when the password is on a list of weak passwords, or contains predictable substrings derived from user attributes. Case insensitive.",
        "label": "Property",
        "id": "3548"
    },
    {
        "raw_code": "def outdated\n    outdateds = []\n\n    latest_specs.each do |local|\n      dependency = Gem::Dependency.new local.name, \">= #{local.version}\"\n\n      fetcher = Gem::SpecFetcher.fetcher\n      remotes = fetcher.find_matching dependency\n      remotes = remotes.map {|(_, version, _), _| version }\n\n      latest = remotes.sort.last\n\n      outdateds << local.name if latest && local.version < latest\n    end",
        "comment": " Returns an Array of Gem::Specifications that are not up to date.",
        "label": "Property",
        "id": "278"
    },
    {
        "raw_code": "def create_local_report!(example_data)\n        logger.info(\"Creating knapsack report from runtime data\")\n        report_path = File.join(BASE_PATH, report_name)\n        knapsack_report = knapsack_report(example_data)\n        File.write(report_path, knapsack_report.to_json)\n        ENV[\"KNAPSACK_REPORT_PATH\"] = report_path\n\n        knapsack_report\n      rescue StandardError => e\n        ENV[\"KNAPSACK_REPORT_PATH\"] = FALLBACK_REPORT\n        logger.warn(\"Failed to create knapsack report: #{e}\")\n        logger.warn(\"Falling back to '#{FALLBACK_REPORT}'\")\n      end",
        "comment": "Create local knapsack report based on example runtime data and configure it to be used by knapsack  Passing list of examples allows to craft a more precise report that will not have runtime data for examples that will actually be skipped due to dynamic metadata which can cause uneven test distribution  @param example_data [Hash<String, String>] example id list to be included in the report @return [Hash<String, Number>]",
        "label": "Property",
        "id": "4532"
    },
    {
        "raw_code": "def text?\n    content_type.start_with?(\"text\")\n  end",
        "comment": "Returns true if the content_type of this blob is in the text range, like text/plain.",
        "label": "Property",
        "id": "13612"
    },
    {
        "raw_code": "def future?\n      self > self.class.current\n    end",
        "comment": "Returns true if the date/time is in the future.",
        "label": "Property",
        "id": "14136"
    },
    {
        "raw_code": "def compact_array(arr)\n          return \"\" if arr.empty?\n\n          range = \"\"\n          prev = nil\n          arr.each do |i|\n            if prev.nil?\n              range += i.to_s\n            elsif prev + 1 < i\n              range += \"-#{prev},#{i}\"\n            end",
        "comment": "compact_array converts an array of integers into a range string e.g. [0, 1, 2, 4, 5, 6] to \"0-2,4-6\"",
        "label": "Property",
        "id": "1839"
    },
    {
        "raw_code": "def perform_before_hooks\n          log_browser_versions\n\n          # Perform app readiness check before continuing with the whole test suite\n          Tools::ReadinessCheck.perform(wait: 180)\n\n          # Initialize global api admin client\n          initialize_admin_api_client!\n          # Initialize global test user and it's api client\n          initialize_test_user!\n\n          if Runtime::Env.rspec_retried?\n            Runtime::Logger.info('Skipping further global hooks due to retry process')\n            return false\n          end",
        "comment": "Perform global setup  @return [Boolean] returns true if hooks were performed successfully",
        "label": "Property",
        "id": "4090"
    },
    {
        "raw_code": "def to_hash\n      hash = {}\n      self.class.attribute_map.each_pair do |attr, param|\n        value = self.send(attr)\n        if value.nil?\n          is_nullable = self.class.openapi_nullable.include?(attr)\n          next if !is_nullable || (is_nullable && !instance_variable_defined?(:\"@#{attr}\"))\n        end",
        "comment": "Returns the object in the form of hash @return [Hash] Returns the object in the form of hash",
        "label": "Property",
        "id": "947"
    },
    {
        "raw_code": "def enable_index(table_name, index_name)\n        raise NotImplementedError, \"#{self.class} does not support enabling indexes\"\n      end",
        "comment": "Enables an index to be used by queries.  enable_index(:users, :email)",
        "label": "Property",
        "id": "13176"
    },
    {
        "raw_code": "def context\n    api_user = !!sessionless_user?\n    @context ||= {\n      current_user: current_user,\n      is_sessionless_user: api_user,\n      current_organization: Current.organization,\n      request: request,\n      scope_validator: ::Gitlab::Auth::ScopeValidator.new(api_user, request_authenticator),\n      remove_deprecated: Gitlab::Utils.to_boolean(permitted_params[:remove_deprecated], default: false)\n    }\n  end",
        "comment": "When modifying the context, also update GraphqlChannel#context if needed so that we have similar context when executing queries, mutations, and subscriptions",
        "label": "Property",
        "id": "6427"
    },
    {
        "raw_code": "def invertible_for?(record)\n          foreign_key_for?(record) && inverse_reflection_for(record)\n        end",
        "comment": "Returns true if inverse association on the given record needs to be set. This method is redefined by subclasses.",
        "label": "Property",
        "id": "12762"
    },
    {
        "raw_code": "def foo; end\n            end",
        "comment": "{access_modifier}",
        "label": "Property",
        "id": "10879"
    },
    {
        "raw_code": "def ref_names\n        branch_names + tag_names\n      end",
        "comment": "Returns an Array of branch and tag names",
        "label": "Property",
        "id": "2623"
    },
    {
        "raw_code": "def _HtmlUnclosed\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlUnclosed = \"<\" Spnl HtmlUnclosedType Spnl HtmlAttribute* Spnl \">\"",
        "label": "Property",
        "id": "15730"
    },
    {
        "raw_code": "def self.fetch_relative_path\n      return unless Gitlab::SafeRequestStore.active?\n      return if Gitlab::SafeRequestStore[:gitlab_git_relative_path].blank?\n\n      Gitlab::SafeRequestStore.fetch(:gitlab_git_relative_path)\n    end",
        "comment": "The GitLab `internal/allowed/` API sets the :gitlab_git_relative_path variable. This provides the repository relative path which can be used to locate snapshot repositories in Gitaly which act as a quarantine repository until a transaction is committed.",
        "label": "Property",
        "id": "1367"
    },
    {
        "raw_code": "def list_errors_with_http_info(project_id, opts = {})\n      if @api_client.config.debugging\n        @api_client.config.logger.debug 'Calling API: ErrorsApi.list_errors ...'\n      end",
        "comment": "List of errors @param project_id [Integer] ID of the project where the error was created @param [Hash] opts the optional parameters @option opts [String] :sort  (default to 'last_seen_desc') @option opts [String] :status  (default to 'unresolved') @option opts [String] :query @option opts [String] :cursor Base64 encoded information for pagination @option opts [Integer] :limit Number of entries to return (default to 20) @option opts [String] :stats_period  (default to '24h') @option opts [String] :query_period  (default to '30d') @return [Array<(Array<Error>, Integer, Hash)>] Array<Error> data, response status code and response headers",
        "label": "Property",
        "id": "1003"
    },
    {
        "raw_code": "def self.database_base_models_using_load_balancing\n      @database_base_models_using_load_balancing ||=\n        all_database_connections\n          .select { |_, db| db.uses_load_balancing? }\n          .transform_values(&:connection_class)\n          .compact.with_indifferent_access.freeze\n    end",
        "comment": "This returns a list of databases whose connection supports database load balancing. We can't reuse the database_base_models since not all connections do support load balancing.",
        "label": "Property",
        "id": "1443"
    },
    {
        "raw_code": "def id=(value)\n        if self.class.composite_primary_key?\n          raise TypeError, \"Expected value matching #{self.class.primary_key.inspect}, got #{value.inspect}.\" unless value.is_a?(Enumerable)\n          @primary_key.zip(value) { |attr, value| _write_attribute(attr, value) }\n        else\n          super\n        end",
        "comment": "Sets the primary key column's value. If the primary key is composite, raises TypeError when the set value not enumerable.",
        "label": "Property",
        "id": "12833"
    },
    {
        "raw_code": "def production_domain(tld)\n          return 'gitlab' unless GitlabEdition.jh?\n          return 'gitlab' if tld == 'hk' || tld == 'cn'\n          return 'jihulab' if tld == 'com'\n        end",
        "comment": "Get production domain value based on GitLab edition and URI's top level domain  @param tld [String] top level domain, e.g. 'hk', 'com' @return [String] 'gitlab' or 'jihulab'",
        "label": "Property",
        "id": "4424"
    },
    {
        "raw_code": "def initialize(context)\n      @context = context\n    end",
        "comment": "context - An instance of Banzai::RenderContext.",
        "label": "Property",
        "id": "3407"
    },
    {
        "raw_code": "def expire_caches_before_rename(old_path)\n    project_repo = Repository.new(old_path, self, shard: repository_storage)\n    wiki_repo = Repository.new(\"#{old_path}#{Gitlab::GlRepository::WIKI.path_suffix}\", self, shard: repository_storage, repo_type: Gitlab::GlRepository::WIKI)\n    design_repo = Repository.new(\"#{old_path}#{Gitlab::GlRepository::DESIGN.path_suffix}\", self, shard: repository_storage, repo_type: Gitlab::GlRepository::DESIGN)\n\n    [project_repo, wiki_repo, design_repo].each do |repo|\n      repo.before_delete if repo.exists?\n    end",
        "comment": "Expires various caches before a project is renamed.",
        "label": "Property",
        "id": "6750"
    },
    {
        "raw_code": "def self.kubernetes_legacy_poststart_hook_command\n          read_file(\"workspace_operations/create/desired_config/bm_kubernetes_legacy_poststart_hook_command.sh\")\n        end",
        "comment": "@return [String] content of the file",
        "label": "Property",
        "id": "3308"
    },
    {
        "raw_code": "def verified_by_gitlab?\n        signer == :SIGNER_SYSTEM\n      end",
        "comment": "If a commit is signed by Gitaly, the Gitaly returns `SIGNER_SYSTEM` as a signer In order to calculate it, the signature is Verified using the Gitaly's public key: https://gitlab.com/gitlab-org/gitaly/-/blob/v16.2.0-rc2/internal/gitaly/service/commit/commit_signatures.go#L63  It is safe to skip verification step if the commit has been signed by Gitaly",
        "label": "Property",
        "id": "2908"
    },
    {
        "raw_code": "def redact_documents(documents)\n      redactor = ReferenceRedactor.new(context)\n\n      redactor.redact(documents)\n    end",
        "comment": "Redacts the list of documents.  Returns an Array containing the redacted documents.",
        "label": "Property",
        "id": "3403"
    },
    {
        "raw_code": "def self.build_hierarchy(descendants, hierarchy_top = nil, opts = {})\n    descendants = Array.wrap(descendants).uniq\n    return [] if descendants.empty?\n\n    unless descendants.all?(GroupDescendant)\n      raise ArgumentError, _('element is not a hierarchy')\n    end",
        "comment": "Merges all hierarchies of the given groups or projects into an array of hashes. All ancestors need to be loaded into the given `descendants` to avoid queries down the line.  Options: upto_preloaded_ancestors_only: boolean - When `true`, the hierarchy expansions stops at the highest level preloaded ancestor. The hierarchy isn't guaranteed to reach the `hierarchy_top`.  > GroupDescendant.merge_hierarchy([project, child_group, child_group2, parent]) => { parent => [{ child_group => project}, child_group2] }",
        "label": "Property",
        "id": "7293"
    },
    {
        "raw_code": "def search(query, include_parents: false, use_minimum_char_limit: true, exact_matches_first: false)\n      if include_parents\n        route_columns = [Route.arel_table[:path], Route.arel_table[:name]]\n        namespaces = without_project_namespaces\n          .where(id: Route.for_routable_type(Namespace.name)\n          .allow_cross_joins_across_databases(url: \"https://gitlab.com/gitlab-org/gitlab/-/issues/420046\")\n            .fuzzy_search(query, route_columns,\n              use_minimum_char_limit: use_minimum_char_limit)\n            .select(:source_id))\n\n        if exact_matches_first\n          namespaces = namespaces\n            .joins(:route)\n            .allow_cross_joins_across_databases(url: \"https://gitlab.com/gitlab-org/gitlab/-/issues/420046\")\n            .order(exact_matches_first_sql(query, route_columns))\n        end",
        "comment": "Searches for namespaces matching the given query.  This method uses ILIKE on PostgreSQL.  query - The search query as a String.  Returns an ActiveRecord::Relation.",
        "label": "Property",
        "id": "6686"
    },
    {
        "raw_code": "def publicly_visible?\n    resource_parent.public? && resource_parent.feature_available?(:issues, nil) &&\n      !confidential? && !hidden? && !::Gitlab::ExternalAuthorization.enabled?\n  end",
        "comment": "Returns `true` if this Issue is visible to everybody.",
        "label": "Property",
        "id": "6820"
    },
    {
        "raw_code": "def send_to_constant?(node)\n      node.type == :send && node.children&.first&.type == :const\n    end",
        "comment": "Returns true for a `(send const ...)` node.",
        "label": "Property",
        "id": "3879"
    },
    {
        "raw_code": "def INVALID_CODE; end\n          RUBY\n        end",
        "comment": "frozen_string_literal: true",
        "label": "Property",
        "id": "10763"
    },
    {
        "raw_code": "def gdk_so_ver\n    \"2.0\"\n  end",
        "comment": "gdk-pixbuf has an internal version number separate from the overall version number that specifies the location of its module and cache files, this will need to be updated if that internal version number is ever changed (as evidenced by the location no longer existing)",
        "label": "Property",
        "id": "9"
    },
    {
        "raw_code": "def sequence_name=(value)\n        @sequence_name          = value.to_s\n        @explicit_sequence_name = true\n      end",
        "comment": "Sets the name of the sequence to use when generating ids to the given value, or (if the value is +nil+ or +false+) to the value returned by the given block. This is required for Oracle and is useful for any database which relies on sequences for primary key generation.  If a sequence name is not explicitly set when using Oracle, it will default to the commonly used pattern of: #{table_name}_seq  If a sequence name is not explicitly set when using PostgreSQL, it will discover the sequence corresponding to your primary key for you.  class Project < ActiveRecord::Base self.sequence_name = \"projectseq\"   # default would have been \"project_seq\" end",
        "label": "Property",
        "id": "12518"
    },
    {
        "raw_code": "def tokens_to_s\n    (token_stream or return '').compact.map { |token| token[:text] }.join ''\n  end",
        "comment": " Returns a string representation of the token stream",
        "label": "Property",
        "id": "15979"
    },
    {
        "raw_code": "def liquid?\n      @current_engine == :liquid\n    end",
        "comment": "@return [Boolean] Returns true if current engine is `:liquid`.",
        "label": "Property",
        "id": "8675"
    },
    {
        "raw_code": "def count_all_runners\n            find_element(\"runner-count-all\").text.to_i\n          end",
        "comment": "Returns total count of all runner types  @return [Integer]",
        "label": "Property",
        "id": "4292"
    },
    {
        "raw_code": "def between(repo, base, head, limit: nil)\n          # In either of these cases, we are guaranteed to return no commits, so\n          # shortcut the RPC call\n          return [] if Gitlab::Git.blank_ref?(base) || Gitlab::Git.blank_ref?(head)\n\n          wrapped_gitaly_errors do\n            revisions = [head, \"^#{base}\"] # base..head\n            client = repo.gitaly_commit_client\n\n            # We must return the commits in chronological order but using both\n            # limit and reverse in the Gitaly RPC would return the oldest N,\n            # rather than newest N, commits, so reorder in Ruby with limit\n            if limit\n              client.list_commits(revisions, pagination_params: { limit: limit }).reverse!\n            else\n              client.list_commits(revisions, reverse: true)\n            end",
        "comment": "Get commits between two revspecs See also #repository.commits_between  Ex. Commit.between(repo, '29eda46b', 'master') # all commits, ordered oldest to newest Commit.between(repo, '29eda46b', 'master', limit: 100) # 100 newest commits, ordered oldest to newest ",
        "label": "Property",
        "id": "2591"
    },
    {
        "raw_code": "def to_body\n      to_hash\n    end",
        "comment": "to_body is an alias to to_hash (backward compatibility) @return [Hash] Returns the object in the form of hash",
        "label": "Property",
        "id": "997"
    },
    {
        "raw_code": "def protected_days\n    days = (updated_at - 101.days.ago).to_i / 1.day\n    days.positive? ? days : 0\n  end",
        "comment": "returns days left before the reserved namespace will be released 100 + 1 days are added so that last_protected_day / 1.day = 1",
        "label": "Property",
        "id": "9987"
    },
    {
        "raw_code": "def track_event(event_name, values:, property_name: nil, time: Time.current)\n          track(values, event_name, property_name: property_name, time: time)\n        end",
        "comment": "Track unique events  event_name - The event name. values - One or multiple values counted. property_name - Name of the values counted. time - Time of the action, set to Time.current.",
        "label": "Property",
        "id": "2676"
    },
    {
        "raw_code": "def converted_arrays\n      @converted_arrays ||= Set.new\n    end",
        "comment": "Attribute that keeps track of converted arrays, if any, to avoid double looping in the common use case permit + mass-assignment. Defined in a method to instantiate it only if needed.  Testing membership still loops, but it's going to be faster than our own loop that converts values. Also, we are not going to build a new array object per fetch.",
        "label": "Property",
        "id": "11359"
    },
    {
        "raw_code": "def related_merge_requests\n      if merge_request?\n        # We look for all other MRs that this branch might be pointing to\n        MergeRequest.where(\n          source_project_id: merge_request.source_project_id,\n          source_branch: merge_request.source_branch)\n      else\n        MergeRequest.where(\n          source_project_id: project_id,\n          source_branch: ref)\n      end",
        "comment": "This returns a list of MRs that point to the same source project/branch",
        "label": "Property",
        "id": "7567"
    },
    {
        "raw_code": "def has_constant_assignment?(string_value)\n        ast.each_descendant(:casgn).any? do |node|\n          value_node = node.children[2]\n          value_node&.type == :str && value_node.str_content == string_value\n        end",
        "comment": "Check if a constant is assigned the specified string value ex. MIGRATION = 'ClassName'",
        "label": "Property",
        "id": "8165"
    },
    {
        "raw_code": "def build_from_hash(attributes)\n      return nil unless attributes.is_a?(Hash)\n      attributes = attributes.transform_keys(&:to_sym)\n      self.class.openapi_types.each_pair do |key, type|\n        if attributes[self.class.attribute_map[key]].nil? && self.class.openapi_nullable.include?(key)\n          self.send(\"#{key}=\", nil)\n        elsif type =~ /\\AArray<(.*)>/i\n          # check to ensure the input is an array given that the attribute\n          # is documented as an array but the input is not\n          if attributes[self.class.attribute_map[key]].is_a?(Array)\n            self.send(\"#{key}=\", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })\n          end",
        "comment": "Builds the object from hash @param [Hash] attributes Model attributes in the form of hash @return [Object] Returns the model itself",
        "label": "Property",
        "id": "873"
    },
    {
        "raw_code": "def migrations(versions_only: false)\n        migrations = @migrations.sort_by { |version, _| version }\n\n        migrations.map { |m| versions_only ? m.first : m.last }\n      end",
        "comment": "Returns all migrations sorted by version",
        "label": "Property",
        "id": "1115"
    },
    {
        "raw_code": "def self.singular_route_key(record_or_class)\n      model_name_from_record_or_class(record_or_class).singular_route_key\n    end",
        "comment": "Returns string to use while generating route names. It differs for namespaced models regarding whether it's inside isolated engine.  # For isolated engine: ActiveModel::Naming.singular_route_key(Blog::Post) # => \"post\"  # For shared engine: ActiveModel::Naming.singular_route_key(Blog::Post) # => \"blog_post\"",
        "label": "Property",
        "id": "12253"
    },
    {
        "raw_code": "def caching?\n        CachingRegistry.caching?\n      end",
        "comment": "Returns whether the current view fragment is within a +cache+ block.  Useful when certain fragments aren't cacheable:  <% cache project do %> <% raise StandardError, \"Caching private data!\" if caching? %> <% end %>",
        "label": "Property",
        "id": "11812"
    },
    {
        "raw_code": "def effective_column(range)\n        if range.line == 1 && @processed_source.raw_source.codepoints.first == BYTE_ORDER_MARK\n          range.column - 1\n        else\n          range.column\n        end",
        "comment": "Helpers for above range methods. Do not use inside Cops. Returns the column attribute of the range, except if the range is on the first line and there's a byte order mark at the beginning of that line, in which case 1 is subtracted from the column value. This gives the column as it appears when viewing the file in an editor.",
        "label": "Property",
        "id": "10441"
    },
    {
        "raw_code": "def children(node, filter: DEFAULT_FIELD_FILTER, &_blk)\n              attributes = case node\n                           when Google::Protobuf::MessageExts\n                             descriptor_fields(node.class.descriptor)\n                           when Google::Protobuf::RepeatedField\n                             node.count.times.to_a\n                           end",
        "comment": "Interface with a PgQuery result as though it was a tree node. All elements in a PgQuery result are ancestors of Google::Protobuf::AbstractMessage  Based off PgQuery's treewalker https://github.com/pganalyze/pg_query/blob/main/lib/pg_query/treewalker.rb",
        "label": "Property",
        "id": "3199"
    },
    {
        "raw_code": "def to_trix_content_attachment_partial_path\n      to_partial_path\n    end",
        "comment": "Returns the path to the partial that is used for rendering the attachable in Trix. Defaults to `to_partial_path`.  Override to render a different partial:  class User < ApplicationRecord def to_trix_content_attachment_partial_path \"users/trix_content_attachment\" end end",
        "label": "Property",
        "id": "11686"
    },
    {
        "raw_code": "def self.user_id(user)\n      user_id = user&.id\n\n      return UNKNOWN_ID unless user_id\n      raise ArgumentError, 'must pass a user instance' unless user.is_a?(User)\n\n      Gitlab::CryptoHelper.sha256(\"#{instance_id}#{user_id}\")\n    end",
        "comment": "Generates a globally unique user_id. This allows us to anonymously identify even self-managed users and instances that make requests into GitLab infrastructure.",
        "label": "Property",
        "id": "1682"
    },
    {
        "raw_code": "def self.init\n          new_root_object\n        end",
        "comment": "Returns a bare empty configuration object.  @return [V2::Root]",
        "label": "Property",
        "id": "8933"
    },
    {
        "raw_code": "def to_body\n      to_hash\n    end",
        "comment": "to_body is an alias to to_hash (backward compatibility) @return [Hash] Returns the object in the form of hash",
        "label": "Property",
        "id": "946"
    },
    {
        "raw_code": "def update_all(updates)\n        sum do |relation|\n          relation.update_all(updates)\n        end",
        "comment": "Updates records in batches. Returns the total number of rows affected.  Person.in_batches.update_all(\"age = age + 1\")  See Relation#update_all for details of how each batch is updated.",
        "label": "Property",
        "id": "13444"
    },
    {
        "raw_code": "def deep_transform_values(&block)\n    _deep_transform_values_in_object(self, &block)\n  end",
        "comment": "Returns a new hash with all values converted by the block operation. This includes the values from the root hash and from all nested hashes and arrays.  hash = { person: { name: 'Rob', age: '28' } }  hash.deep_transform_values{ |value| value.to_s.upcase } # => {person: {name: \"ROB\", age: \"28\"}}",
        "label": "Property",
        "id": "14227"
    },
    {
        "raw_code": "def current\n      ::Time.zone ? ::Time.zone.now.to_datetime : ::Time.now.to_datetime\n    end",
        "comment": "Returns <tt>Time.zone.now.to_datetime</tt> when <tt>Time.zone</tt> or <tt>config.time_zone</tt> are set, otherwise returns <tt>Time.now.to_datetime</tt>.",
        "label": "Property",
        "id": "14181"
    },
    {
        "raw_code": "def scoped_user_id_attribute\n            user_identity = ::Gitlab::Auth::Identity.fabricate(@pipeline.user)\n\n            return {} unless user_identity&.composite? && user_identity.linked?\n\n            attrs = { scoped_user_id: user_identity.scoped_user.id }\n\n            if Feature.enabled?(:stop_writing_builds_metadata, @pipeline.project)\n              attrs\n            else\n              attrs.merge(options: attrs)\n            end",
        "comment": "Scoped user is present when the user creating the pipeline supports composite identity. For example: a service account like GitLab Duo. The scoped user is used to further restrict the permissions of the CI job token associated to the `job.user`.",
        "label": "Property",
        "id": "2520"
    },
    {
        "raw_code": "def sender(sender_id, send_from_user_email: false, sender_name: nil, sender_email: nil)\n    return unless sender = User.find(sender_id)\n\n    address = default_sender_address\n    address.display_name = sender_name.presence || \"#{sender.name} (#{sender.to_reference})\"\n\n    if sender_email\n      address.address = sender_email\n    elsif send_from_user_email && can_send_from_user_email?(sender)\n      address.address = sender.email\n    end",
        "comment": "Return an email address that displays the name of the sender. Override sender_email if you want to hard replace the sender address (e.g. custom email for Service Desk)",
        "label": "Property",
        "id": "6247"
    },
    {
        "raw_code": "def watcher_for(path)\n          @path_watcher_map[File.expand_path(path)]\n        end",
        "comment": "Adds a +Watcher+ for the file located at +path+ to the +List+, if it isn't already there.",
        "label": "Property",
        "id": "8625"
    },
    {
        "raw_code": "def self.for(app)\n          @app_list_map[app]\n        end",
        "comment": "Returns the +List+ for the application +app+.",
        "label": "Property",
        "id": "8621"
    },
    {
        "raw_code": "def topology_instance_service_memory(instance, instance_data_by_type)\n        result = {}\n        instance_data_by_type.each do |memory_type, instance_data|\n          topology_data_for_instance(instance, instance_data).each do |metric, memory_bytes|\n            job = metric['job']\n            key = \"process_memory_#{memory_type}\".to_sym\n\n            result[job] ||= {}\n            result[job][key] ||= memory_bytes\n          end",
        "comment": "Given a hash mapping memory set types to Prometheus response data, returns a hash mapping instance/node names to services and their respective memory use in bytes",
        "label": "Property",
        "id": "1874"
    },
    {
        "raw_code": "def assert_hard_link(filename)\n    assert_file filename\n\n    src = @g.template_dir + '_head.rhtml'\n    dst = File.join @tmpdir, 'hardlinktest'\n\n    begin\n      FileUtils.ln src, dst\n      nlink = File.stat(dst).nlink if File.identical? src, dst\n      FileUtils.rm dst\n      return if nlink == 1\n    rescue SystemCallError\n      return\n    end",
        "comment": " Asserts that +filename+ has a link count greater than 1 if hard links to @tmpdir are supported.",
        "label": "Property",
        "id": "16845"
    },
    {
        "raw_code": "def _HtmlBlockOpenTh\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenTh = \"<\" Spnl (\"th\" | \"TH\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "15713"
    },
    {
        "raw_code": "def build_relative_path(path, request_path)\n        return request_path if path.empty?\n        return path unless request_path\n        return path[1..] if path.start_with?('/')\n\n        parts = request_path.split('/')\n\n        parts.pop if uri_type(request_path) != :tree\n\n        path.delete_prefix!('./')\n\n        while path.start_with?('../')\n          parts.pop\n          path.sub!('../', '')\n        end",
        "comment": "Convert a relative path into its correct location based on the currently requested path  path         - Relative path String request_path - Currently-requested path String  Examples:  # File in the same directory as the current path build_relative_path(\"users.md\", \"doc/api/README.md\") # => \"doc/api/users.md\"  # File in the same directory, which is also the current path build_relative_path(\"users.md\", \"doc/api\") # => \"doc/api/users.md\"  # Going up one level to a different directory build_relative_path(\"../update/7.14-to-8.0.md\", \"doc/api/README.md\") # => \"doc/update/7.14-to-8.0.md\"  Returns a String",
        "label": "Property",
        "id": "3453"
    },
    {
        "raw_code": "def id_for_already_processed_cache(object)\n        raise NotImplementedError\n      end",
        "comment": "Returns the ID to use for the cache used for checking if an object has already been processed or not.  object - The object we may want to import.",
        "label": "Property",
        "id": "1817"
    },
    {
        "raw_code": "def app_file_path\n    File.join(tmp_dir, \"example_app_#{$example_app_counter}.rb\")\n  end",
        "comment": "Returns the path of the Sinatra application file created by +setup_example_app+.",
        "label": "Property",
        "id": "8689"
    },
    {
        "raw_code": "def token_valid?(token_to_check)\n      HMACToken.new(actor, container).token_valid?(token_to_check) && valid_user?\n    end",
        "comment": "When the token is an lfs one and the actor is blocked or the password has been changed, the token is no longer valid",
        "label": "Property",
        "id": "1493"
    },
    {
        "raw_code": "def self.logger(*args, **kwargs)\n      new ActiveSupport::Logger.new(*args, **kwargs)\n    end",
        "comment": "Returns an `ActiveSupport::Logger` that has already been wrapped with tagged logging concern.",
        "label": "Property",
        "id": "13947"
    },
    {
        "raw_code": "def model_name\n      @_model_name ||= begin\n        namespace = module_parents.detect do |n|\n          n.respond_to?(:use_relative_model_naming?) && n.use_relative_model_naming?\n        end",
        "comment": "Returns an ActiveModel::Name object for module. It can be used to retrieve all kinds of naming-related information (See ActiveModel::Name for more information).  class Person extend ActiveModel::Naming end  Person.model_name.name     # => \"Person\" Person.model_name.class    # => ActiveModel::Name Person.model_name.singular # => \"person\" Person.model_name.plural   # => \"people\"",
        "label": "Property",
        "id": "12249"
    },
    {
        "raw_code": "def avatar_icon_for(user = nil, email = nil, size = nil, scale = 2, only_path: true)\n    if user\n      avatar_icon_for_user(user, size, scale, only_path: only_path)\n    elsif email\n      avatar_icon_for_email(email, size, scale, only_path: only_path)\n    else\n      default_avatar\n    end",
        "comment": "Takes both user and email and returns the avatar_icon by user (preferred) or email.",
        "label": "Property",
        "id": "7714"
    },
    {
        "raw_code": "def change\n    add_column :users, :last_access_from_pipl_country_at, :datetime_with_timezone, if_not_exists: true\n  end",
        "comment": "This column prevents additional queries (e.g. 'SELECT ... FROM country_access_logs ...') when checking if the user's access from a specific country should be tracked (insert/update to country_access_logs table). rubocop:disable Migration/PreventAddingColumns -- see previous lines",
        "label": "Property",
        "id": "4994"
    },
    {
        "raw_code": "def _HtmlBlockOpenLi\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenLi = \"<\" Spnl (\"li\" | \"LI\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "15701"
    },
    {
        "raw_code": "def raw_size\n    if stored_externally?\n      external_size\n    else\n      size\n    end",
        "comment": "Returns the size of the file that this blob represents. If this blob is an LFS pointer, this is the size of the file stored in LFS. Otherwise, this is the size of the blob itself.",
        "label": "Property",
        "id": "7006"
    },
    {
        "raw_code": "def consecutive_comment(line_no)\n    if @unprocessed_comments.first&.first == line_no\n      @unprocessed_comments.shift.last\n    end",
        "comment": "Returns consecutive comment linked to the given line number",
        "label": "Property",
        "id": "16035"
    },
    {
        "raw_code": "def javascript_tag(content_or_options_with_block = nil, html_options = {}, &block)\n        content =\n          if block_given?\n            html_options = content_or_options_with_block if content_or_options_with_block.is_a?(Hash)\n            capture(&block)\n          else\n            content_or_options_with_block\n          end",
        "comment": "Returns a JavaScript tag with the +content+ inside. Example: javascript_tag \"alert('All is good')\"  Returns: <script> //<![CDATA[ alert('All is good') //]]> </script>  +html_options+ may be a hash of attributes for the <tt>\\<script></tt> tag.  javascript_tag \"alert('All is good')\", type: 'application/javascript'  Returns: <script type=\"application/javascript\"> //<![CDATA[ alert('All is good') //]]> </script>  Instead of passing the content as an argument, you can also use a block in which case, you pass your +html_options+ as the first parameter.  <%= javascript_tag type: 'application/javascript' do -%> alert('All is good') <% end -%>  If you have a content security policy enabled then you can add an automatic nonce value by passing <tt>nonce: true</tt> as part of +html_options+. Example:  <%= javascript_tag nonce: true do -%> alert('All is good') <% end -%>",
        "label": "Property",
        "id": "11949"
    },
    {
        "raw_code": "def id_before_type_cast\n        attribute_before_type_cast(@primary_key)\n      end",
        "comment": "Returns the primary key column's value before type cast. If the primary key is composite, returns an array of primary key column values before type cast.",
        "label": "Property",
        "id": "12855"
    },
    {
        "raw_code": "def to_s\n      to_hash.to_s\n    end",
        "comment": "Returns the string representation of the object @return [String] String presentation of the object",
        "label": "Property",
        "id": "996"
    },
    {
        "raw_code": "def already_imported_ids\n        Gitlab::Cache::Import::Caching.values_from_set(already_imported_cache_key)\n      end",
        "comment": "Returns the set used to track \"already imported\" objects. Items are the values returned by `#id_for_already_imported_cache`.",
        "label": "Property",
        "id": "2138"
    },
    {
        "raw_code": "def extract_subdomain(host, tld_length)\n          extract_subdomains(host, tld_length).join(\".\")\n        end",
        "comment": "Returns the subdomains of a host as a String given the domain level.  # Top-level domain example extract_subdomain('www.example.com', 1) # => \"www\" # Second-level domain example extract_subdomain('dev.www.example.co.uk', 2) # => \"dev.www\"",
        "label": "Property",
        "id": "11495"
    },
    {
        "raw_code": "def triggered_by_merge_request\n      Ci::Pipeline.triggered_by_merge_request(merge_request)\n    end",
        "comment": "NOTE: this method returns only parent merge request pipelines. Child merge request pipelines have a different source.",
        "label": "Property",
        "id": "8017"
    },
    {
        "raw_code": "def from_xml(xml, disallowed_types = nil)\n      ActiveSupport::XMLConverter.new(xml, disallowed_types).to_h\n    end",
        "comment": "Returns a Hash containing a collection of pairs when the key is the node name and the value is its content  xml = <<-XML <?xml version=\"1.0\" encoding=\"UTF-8\"?> <hash> <foo type=\"integer\">1</foo> <bar type=\"integer\">2</bar> </hash> XML  hash = Hash.from_xml(xml) # => {\"hash\"=>{\"foo\"=>1, \"bar\"=>2}}  +DisallowedType+ is raised if the XML contains attributes with <tt>type=\"yaml\"</tt> or <tt>type=\"symbol\"</tt>. Use <tt>Hash.from_trusted_xml</tt> to parse this XML.  Custom +disallowed_types+ can also be passed in the form of an array.  xml = <<-XML <?xml version=\"1.0\" encoding=\"UTF-8\"?> <hash> <foo type=\"integer\">1</foo> <bar type=\"string\">\"David\"</bar> </hash> XML  hash = Hash.from_xml(xml, ['integer']) # => ActiveSupport::XMLConverter::DisallowedType: Disallowed type attribute: \"integer\"  Note that passing custom disallowed types will override the default types, which are Symbol and YAML.",
        "label": "Property",
        "id": "14224"
    },
    {
        "raw_code": "def module_parents\n    parents = []\n    if module_parent_name\n      parts = module_parent_name.split(\"::\")\n      until parts.empty?\n        parents << ActiveSupport::Inflector.constantize(parts * \"::\")\n        parts.pop\n      end",
        "comment": "Returns all the parents of this module according to its name, ordered from nested outwards. The receiver is not contained within the result.  module M module N end end X = M::N  M.module_parents    # => [Object] M::N.module_parents # => [M, Object] X.module_parents    # => [M, Object]",
        "label": "Property",
        "id": "14277"
    },
    {
        "raw_code": "def touch_all(...)\n        sum do |relation|\n          relation.touch_all(...)\n        end",
        "comment": "Touches records in batches. Returns the total number of rows affected.  Person.in_batches.touch_all  See Relation#touch_all for details of how each batch is touched.",
        "label": "Property",
        "id": "13445"
    },
    {
        "raw_code": "def emoji_name_element_unicode_filter(text)\n        Gitlab::Utils::Gsub\n          .gsub_with_limit(text, emoji_pattern, limit: Banzai::Filter::FILTER_ITEM_LIMIT) do |match_data|\n          emoji = TanukiEmoji.find_by_alpha_code(match_data[0])\n\n          process_emoji_tag(emoji, match_data[0])\n        end",
        "comment": "Replace :emoji: with corresponding gl-emoji unicode.  text - String text to replace :emoji: in.  Returns a String with :emoji: replaced with gl-emoji unicode.",
        "label": "Property",
        "id": "3445"
    },
    {
        "raw_code": "def extract_group_member_ids(username_param)\n      filter_param = Array(username_param)\n      return unless username_param_is_a_group_handle?(filter_param)\n\n      reference_extractor = ::Gitlab::ReferenceExtractor.new(nil, current_user)\n      reference_extractor.analyze(filter_param.first, { skip_project_check: true })\n\n      # Extract references when group is readable by user\n      group = reference_extractor.references(:mentioned_group).first # rubocop: disable CodeReuse/ActiveRecord -- not an ActiveRecord model\n      return unless group\n\n      # Limit the filtering only for groups with less than 100 members\n      # to avoid database performance issues\n      if group.group_members.limit(MAX_GROUP_MEMBERS_COUNT + 1).count > MAX_GROUP_MEMBERS_COUNT\n        raise TooManyGroupMembersError,\n          \"Group has too many members (limit is #{MAX_GROUP_MEMBERS_COUNT}).\"\n      end",
        "comment": "Returns active record relation if search parameter is a group handle, eg '@group/subgroup'",
        "label": "Property",
        "id": "7974"
    },
    {
        "raw_code": "def noteable_id\n    merge_request_id\n  end",
        "comment": "noteable_id and noteable_type methods are used to generate discussion_id on Discussion.discussion_id",
        "label": "Property",
        "id": "6783"
    },
    {
        "raw_code": "def bitmap_for(name)\n    bitmap = @name_to_bitmap.assoc name\n\n    unless bitmap then\n      bitmap = @next_bitmap\n      @next_bitmap <<= 1\n      @name_to_bitmap << [name, bitmap]\n    else\n      bitmap = bitmap.last\n    end",
        "comment": " Returns a unique bit for +name+",
        "label": "Property",
        "id": "16373"
    },
    {
        "raw_code": "def _HtmlBlockOpenFrameset\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenFrameset = \"<\" Spnl (\"frameset\" | \"FRAMESET\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "15698"
    },
    {
        "raw_code": "def rake(command, options = {})\n        execute_command :rake, command, options\n      end",
        "comment": "Runs the specified Rake task.  rake \"db:migrate\" rake \"db:migrate\", env: \"production\" rake \"db:migrate\", abort_on_failure: true rake \"stats\", capture: true rake \"gems:install\", sudo: true  ==== Options  [+:env+] The \\Rails environment in which to run the task. Defaults to <tt>ENV[\"RAILS_ENV\"] || \"development\"</tt>.  [+:abort_on_failure+] Whether to halt the generator if the task exits with a non-success exit status.  [+:capture+] Whether to capture and return the output of the task.  [+:sudo+] Whether to run the task using +sudo+.",
        "label": "Property",
        "id": "14737"
    },
    {
        "raw_code": "def sidekiq_options(opts = {})\n        super\n      end",
        "comment": " Allows customization for this type of Job. Legal options:  queue - use a named queue for this Job, default 'default' retry - enable the RetryJobs middleware for this Job, *true* to use the default or *Integer* count backtrace - whether to save any error backtrace in the retry payload to display in web UI, can be true, false or an integer number of lines to save, default *false* pool - use the given Redis connection pool to push this type of job to a given shard.  In practice, any option is allowed.  This is the main mechanism to configure the options for a specific job.",
        "label": "Property",
        "id": "5179"
    },
    {
        "raw_code": "def reduce_sub_batch_size!\n          raise ReduceSubBatchSizeError, 'Only sub_batch_size of failed jobs can be reduced' unless failed?\n\n          return if sub_batch_exceeds_threshold?\n\n          with_lock do\n            actual_sub_batch_size = sub_batch_size\n            reduced_sub_batch_size = (sub_batch_size * SUB_BATCH_SIZE_REDUCE_FACTOR).to_i.clamp(1, batch_size)\n\n            update!(sub_batch_size: reduced_sub_batch_size)\n\n            Gitlab::AppLogger.warn(\n              message: 'Sub batch size reduced due to timeout',\n              batched_job_id: id,\n              sub_batch_size: actual_sub_batch_size,\n              reduced_sub_batch_size: reduced_sub_batch_size,\n              attempts: attempts,\n              batched_migration_id: batched_migration.id,\n              job_class_name: migration_job_class_name,\n              job_arguments: migration_job_arguments\n            )\n          end",
        "comment": "It reduces the size of +sub_batch_size+ by 25%",
        "label": "Property",
        "id": "3222"
    },
    {
        "raw_code": "def email_field(object_name, method, options = {})\n        Tags::EmailField.new(object_name, method, self, options).render\n      end",
        "comment": "Returns a text_field of type \"email\".  email_field(\"user\", \"address\") # => <input id=\"user_address\" name=\"user[address]\" type=\"email\" /> ",
        "label": "Property",
        "id": "11883"
    },
    {
        "raw_code": "def in_serializer?(node)\n      in_app_directory?(node, 'serializers')\n    end",
        "comment": "Returns true if the given node resides in app/serializers or ee/app/serializers.",
        "label": "Property",
        "id": "3887"
    },
    {
        "raw_code": "def last(n = nil)\n      n ? hash_rows.last(n) : hash_rows.last\n    end",
        "comment": "Returns the last record from the rows collection.",
        "label": "Property",
        "id": "12674"
    },
    {
        "raw_code": "def acceptable_error?\n          ACCEPTABLE_ERROR_CODES.include?(code)\n        end",
        "comment": "In some cases, we treat error response as acceptable:  A GPG key that wasn't issued by BeyondIdentity returns 404 status code but users should be able to add those GPG keys to their profile.",
        "label": "Property",
        "id": "2056"
    },
    {
        "raw_code": "def test; end\n          end",
        "comment": "{access_modifier}",
        "label": "Property",
        "id": "10855"
    },
    {
        "raw_code": "def test; end\n              end",
        "comment": "{access_modifier}",
        "label": "Property",
        "id": "10841"
    },
    {
        "raw_code": "def list_errors_v2(project, group_id, opts = {})\n      data, _status_code, _headers = list_errors_v2_with_http_info(project, group_id, opts)\n      data\n    end",
        "comment": "List of errors(V2) @param project [Array<Integer>] ID of the project where the error was created @param group_id [Integer] ID of the group @param [Hash] opts the optional parameters @option opts [String] :status  (default to 'unresolved') @option opts [String] :query @option opts [String] :start Optional start of the stat period in format 2006-01-02T15:04:05 @option opts [String] :_end Optional end of the stat period in format 2006-01-02T15:04:05 @option opts [String] :environment @option opts [Integer] :limit Number of entries to return (default to 20) @option opts [String] :sort Optional sorting column of the entries (default to 'date') @return [Array<ErrorV2>]",
        "label": "Property",
        "id": "1020"
    },
    {
        "raw_code": "def strict_loading(value = true)\n      spawn.strict_loading!(value)\n    end",
        "comment": "Sets the returned relation to strict_loading mode. This will raise an error if the record tries to lazily load an association.  user = User.strict_loading.first user.comments.to_a # => ActiveRecord::StrictLoadingViolationError",
        "label": "Property",
        "id": "13424"
    },
    {
        "raw_code": "def blank?\n    respond_to?(:empty?) ? !!empty? : false\n  end",
        "comment": "An object is blank if it's false, empty, or a whitespace string. For example, +nil+, '', '   ', [], {}, and +false+ are all blank.  This simplifies  !address || address.empty?  to  address.blank?  @return [true, false]",
        "label": "Property",
        "id": "14300"
    },
    {
        "raw_code": "def bulk_insert!(\n      items,\n      validate: true,\n      skip_duplicates: false,\n      returns: nil,\n      unique_by: nil,\n      batch_size: DEFAULT_BATCH_SIZE,\n      &handle_attributes\n    )\n      _bulk_insert_all!(\n        items,\n        validate: validate,\n        on_duplicate: skip_duplicates ? :skip : :raise,\n        returns: returns,\n        unique_by: unique_by,\n        batch_size: batch_size,\n        &handle_attributes\n      )\n    end",
        "comment": "Inserts the given ActiveRecord [items] to the table mapped to this class. Items will be inserted in batches of a given size, where insertion semantics are \"atomic across all batches\".  @param [Boolean] validate          Whether validations should run on [items] @param [Integer] batch_size        How many items should at most be inserted at once @param [Boolean] skip_duplicates   Marks duplicates as allowed, and skips inserting them @param [Symbol]  returns           Pass :ids to return an array with the primary key values for all inserted records or nil to omit the underlying RETURNING SQL clause entirely. @param [Symbol/Array] unique_by    Defines index or columns to use to consider item duplicate @param [Proc]    handle_attributes Block that will receive each item attribute hash prior to insertion for further processing  Unique indexes can be identified by columns or name: - unique_by: :isbn - unique_by: %i[ author_id name ] - unique_by: :index_books_on_isbn  Note that this method will throw on the following occasions: - [PrimaryKeySetError]            when primary keys are set on entities prior to insertion - [ActiveRecord::RecordInvalid]   on entity validation failures - [ActiveRecord::RecordNotUnique] on duplicate key errors  @return true if operation succeeded, throws otherwise. ",
        "label": "Property",
        "id": "7250"
    },
    {
        "raw_code": "def render_error\n      nil\n    end",
        "comment": "We can always render a static viewer, even if the blob is too large.",
        "label": "Property",
        "id": "7636"
    },
    {
        "raw_code": "def foreign_key_for?(record)\n          foreign_key = Array(reflection.foreign_key)\n          foreign_key.all? { |key| record._has_attribute?(key) }\n        end",
        "comment": "Returns true if record contains the foreign_key",
        "label": "Property",
        "id": "12763"
    },
    {
        "raw_code": "def concurrent_partitioned_foreign_key_name(table, column, prefix: 'fk_rails_')\n          identifier = \"#{table}_#{column}_fk\"\n          hashed_identifier = Digest::SHA256.hexdigest(identifier).first(10)\n\n          \"#{prefix}#{hashed_identifier}\"\n        end",
        "comment": "Returns the name for a concurrent partitioned foreign key.  Similar to concurrent_foreign_key_name (Gitlab::Database::MigrationHelpers) we just keep a separate method in case we want a different behavior for partitioned tables ",
        "label": "Property",
        "id": "3047"
    },
    {
        "raw_code": "def shareable_constant_value\n      extract_shareable_constant_value\n    end",
        "comment": "Expose the `shareable_constant_value` value coerced to a boolean if possible.  @return [String] for shareable_constant_value config",
        "label": "Property",
        "id": "10157"
    },
    {
        "raw_code": "def queue_adapter_name\n        self.queue_adapter = :async if _queue_adapter_name.nil?\n        _queue_adapter_name\n      end",
        "comment": "Returns string denoting the name of the configured queue adapter. By default returns <tt>\"async\"</tt>.",
        "label": "Property",
        "id": "12129"
    },
    {
        "raw_code": "def default(\n      title: \"This state is empty\",\n      description: \"The title and message should be clear, concise, and explain why the user is seeing this screen.\n        The actions should help the user on what to do to get the real feature.\",\n      compact: false,\n      svg_path: \"illustrations/empty-state/empty-projects-deleted-md.svg\",\n      primary_button_text: \"Do primary action\",\n      primary_button_link: \"#learn-more-primary\",\n      secondary_button_text: \"Do secondary action\",\n      secondary_button_link: \"#learn-more-secondary\")\n      render(Pajamas::EmptyStateComponent.new(\n        title: title,\n        svg_path: svg_path,\n        primary_button_text: primary_button_text,\n        primary_button_link: primary_button_link,\n        secondary_button_text: secondary_button_text,\n        secondary_button_link: secondary_button_link,\n        compact: compact\n      )) do |c|\n        c.with_description { description } if description\n      end",
        "comment": "@param title text @param description textarea @param compact toggle @param svg_path text @param primary_button_text text @param primary_button_link text @param secondary_button_text text @param secondary_button_link text",
        "label": "Property",
        "id": "8204"
    },
    {
        "raw_code": "def generator_descriptions\n    lengths = []\n\n    generators = RDoc::RDoc::GENERATORS.map do |name, generator|\n      lengths << name.length\n\n      description = generator::DESCRIPTION if\n        generator.const_defined? :DESCRIPTION\n\n      [name, description]\n    end",
        "comment": " Returns a properly-space list of generators and their descriptions.",
        "label": "Property",
        "id": "15534"
    },
    {
        "raw_code": "def self.kind\n      @kind ||= name.split(\"::\").last.underscore.chomp(\"_validator\").to_sym unless anonymous?\n    end",
        "comment": "Returns the kind of the validator.  PresenceValidator.kind   # => :presence AcceptanceValidator.kind # => :acceptance",
        "label": "Property",
        "id": "12276"
    },
    {
        "raw_code": "def assert_no_performed_jobs(only: nil, except: nil, queue: nil, &block)\n      require_active_job_test_adapter!(\"assert_no_performed_jobs\")\n\n      assert_performed_jobs 0, only: only, except: except, queue: queue, &block\n    end",
        "comment": "Asserts that no jobs have been performed.  def test_jobs assert_no_performed_jobs  perform_enqueued_jobs do HelloJob.perform_later('matthew') assert_performed_jobs 1 end end  If a block is passed, asserts that the block will not cause any job to be performed.  def test_jobs_again assert_no_performed_jobs do # No job should be performed from this block end end  The block form supports filtering. If the +:only+ option is specified, then only the listed job(s) will not be performed.  def test_no_logging assert_no_performed_jobs only: LoggingJob do HelloJob.perform_later('jeremy') end end  Also if the +:except+ option is specified, then the job(s) except specific class will not be performed.  def test_no_logging assert_no_performed_jobs except: HelloJob do HelloJob.perform_later('jeremy') end end  +:only+ and +:except+ options accept Class, Array of Class, or Proc. When passed a Proc, an instance of the job will be passed as argument.  If the +:queue+ option is specified, then only the job(s) enqueued to a specific queue will not be performed.  def test_assert_no_performed_jobs_with_queue_option assert_no_performed_jobs queue: :some_queue do HelloJob.set(queue: :other_queue).perform_later(\"jeremy\") end end  Note: This assertion is simply a shortcut for:  assert_performed_jobs 0, &block",
        "label": "Property",
        "id": "12143"
    },
    {
        "raw_code": "def archive_file_path(storage_path, sha, name, format = \"tar.gz\")\n        # Build file path\n        return unless name\n\n        extension =\n          case format\n          when \"tar.bz2\", \"tbz\", \"tbz2\", \"tb2\", \"bz2\"\n            \"tar.bz2\"\n          when \"tar\"\n            \"tar\"\n          when \"zip\"\n            \"zip\"\n          else\n            # everything else should fall back to tar.gz\n            \"tar.gz\"\n          end",
        "comment": "The full path on disk where the archive should be stored. This is used to cache the archive between requests.  The path is a global namespace, so needs to be globally unique. This is achieved by including `gl_repository` in the path.  Archives relating to a particular ref when the SHA is not present in the filename must be invalidated when the ref is updated to point to a new SHA. This is achieved by including the SHA in the path.  As this is a full path on disk, it is not \"cloud native\". This should be resolved by either removing the cache, or moving the implementation into Gitaly and removing the ArchivePath parameter from the git-archive senddata response.",
        "label": "Property",
        "id": "2625"
    },
    {
        "raw_code": "def invalidate_reference(reference)\n    case reference\n    when /\\A(.+)?[^\\d]\\d+\\z/\n      # Integer-based reference with optional project prefix\n      reference.gsub(/\\d+\\z/) { |i| i.to_i + 10_000 }\n    when /\\A\\[\\w+:\\d+\\]\\z/\n      # Integer-based reference with [type:number] syntax\n      reference.gsub(/\\d+\\]\\z/) { |i| \"#{i[0..-2].to_i + 10_000}]\" }\n    when /\\A(.+@)?(#{Gitlab::Git::Commit::RAW_SHA_PATTERN}\\z)/o\n      # SHA-based reference with optional prefix\n      reference.gsub(/#{Gitlab::Git::Commit::RAW_SHA_PATTERN}\\z/o) { |v| v.reverse }\n    else\n      reference.gsub(/\\w+\\z/) { |v| v.reverse }\n    end",
        "comment": "Modify a String reference to make it invalid  Commit SHAs get reversed, IDs get incremented by 1, all other Strings get their word characters reversed.  reference - String reference to modify  Returns a String",
        "label": "Property",
        "id": "8449"
    },
    {
        "raw_code": "def test; end\n          end",
        "comment": "{access_modifier}",
        "label": "Property",
        "id": "10848"
    },
    {
        "raw_code": "def ensure_array_from_string(string_or_array)\n      return string_or_array if string_or_array.is_a?(Array)\n\n      string_or_array.split(',').map(&:strip)\n    end",
        "comment": "Used in EE Accepts either an Array or a String and returns an array",
        "label": "Property",
        "id": "1215"
    },
    {
        "raw_code": "def readable_project_ids_for(user)\n        @project_ids_by_user ||= {}\n        @project_ids_by_user[user] ||=\n          Project.public_or_visible_to_user(user).where(projects: { id: @projects_for_nodes.values.map(&:id) }).pluck(:id)\n      end",
        "comment": "Returns an Array of Project ids that can be read by the given user.  user - The User for which to check the projects",
        "label": "Property",
        "id": "3415"
    },
    {
        "raw_code": "def source_user(user)\n        source_user = source_user_mapper.find_source_user(user[:id])\n\n        return source_user if source_user\n\n        source_user_mapper.find_or_create_source_user(\n          source_name: fetch_source_name_from_github(user[:login]),\n          source_username: user[:login],\n          source_user_identifier: user[:id]\n        )\n      end",
        "comment": "Returns the GitLab user ID from placeholder or reassigned_to user.",
        "label": "Property",
        "id": "2145"
    },
    {
        "raw_code": "def all(*types)\n        if types.empty?\n          thread_local_store.values.select {|obj| obj != root }\n        else\n          list = []\n          types.each do |type|\n            list += thread_local_store.values_for_type(type)\n          end",
        "comment": "Returns all objects in the registry that match one of the types provided in the +types+ list (if +types+ is provided).  @example Returns all objects Registry.all @example Returns all classes and modules Registry.all(:class, :module) @param [Array<Symbol>] types an optional list of types to narrow the objects down by. Equivalent to performing a select: +Registry.all.select {|o| types.include(o.type) }+ @return [Array<CodeObjects::Base>] the list of objects found @see CodeObjects::Base#type",
        "label": "Property",
        "id": "71"
    },
    {
        "raw_code": "def delete_all\n        sum(&:delete_all)\n      end",
        "comment": "Deletes records in batches. Returns the total number of rows affected.  Person.in_batches.delete_all  See Relation#delete_all for details of how each batch is deleted.",
        "label": "Property",
        "id": "13443"
    },
    {
        "raw_code": "def previous=(previous_schemes_properties)\n        previous_schemes_properties.each do |properties|\n          add_previous_scheme(**properties)\n        end",
        "comment": "Configure previous encryption schemes.  config.active_record.encryption.previous = [ { key_provider: MyOldKeyProvider.new } ]",
        "label": "Property",
        "id": "13299"
    },
    {
        "raw_code": "def parse_identifier(container, single, tk, comment) # :nodoc:\n    case tk[:text]\n    when 'private', 'protected', 'public', 'private_class_method',\n         'public_class_method', 'module_function' then\n      parse_visibility container, single, tk\n      return true\n    when 'private_constant', 'public_constant'\n      parse_constant_visibility container, single, tk\n      return true\n    when 'attr' then\n      parse_attr container, single, tk, comment\n    when /^attr_(reader|writer|accessor)$/ then\n      parse_attr_accessor container, single, tk, comment\n    when 'alias_method' then\n      parse_alias container, single, tk, comment\n    when 'require', 'include' then\n      # ignore\n    else\n      if comment.text =~ /\\A#\\#$/ then\n        case comment.text\n        when /^# +:?attr(_reader|_writer|_accessor)?:/ then\n          parse_meta_attr container, single, tk, comment\n        else\n          method = parse_meta_method container, single, tk, comment\n          method.params = container.params if\n            container.params\n          method.block_params = container.block_params if\n            container.block_params\n        end",
        "comment": " Parses identifiers that can create new methods or change visibility.  Returns true if the comment was not consumed.",
        "label": "Property",
        "id": "16095"
    },
    {
        "raw_code": "def ==(other)\n      if Duration === other\n        other.value == value\n      else\n        other == value\n      end",
        "comment": "Returns +true+ if +other+ is also a Duration instance with the same +value+, or if <tt>other == value</tt>.",
        "label": "Property",
        "id": "13817"
    },
    {
        "raw_code": "def internal_trailing_comma_offset_from_last_arg(node)\n          source_after_last_arg = range_between(\n            node.children.last.source_range.end_pos,\n            node.loc.end.begin_pos\n          ).source\n\n          first_comma_offset = source_after_last_arg.index(',')\n          first_new_line_offset = source_after_last_arg.index(\"\\n\")\n          return if first_comma_offset.nil?\n          return if first_new_line_offset.nil?\n          return if first_comma_offset > first_new_line_offset\n\n          first_comma_offset + 1\n        end",
        "comment": "Returns nil if no trailing internal comma.",
        "label": "Property",
        "id": "10360"
    },
    {
        "raw_code": "def get_database_version # :nodoc:\n        with_raw_connection do |conn|\n          version = conn.server_version\n          if version == 0\n            raise ActiveRecord::ConnectionNotEstablished, \"Could not determine PostgreSQL version\"\n          end",
        "comment": "Returns the version of the connected PostgreSQL server.",
        "label": "Property",
        "id": "12977"
    },
    {
        "raw_code": "def summary\n    calculate\n\n    num_width = [@num_files, @num_items].max.to_s.length\n    undoc_width = [\n      @undoc_attributes,\n      @undoc_classes,\n      @undoc_constants,\n      @undoc_items,\n      @undoc_methods,\n      @undoc_modules,\n      @undoc_params,\n    ].max.to_s.length\n\n    report = RDoc::Markup::Verbatim.new\n\n    report << \"Files:      %*d\\n\" % [num_width, @num_files]\n\n    report << \"\\n\"\n\n    report << \"Classes:    %*d (%*d undocumented)\\n\" % [\n      num_width, @num_classes, undoc_width, @undoc_classes]\n    report << \"Modules:    %*d (%*d undocumented)\\n\" % [\n      num_width, @num_modules, undoc_width, @undoc_modules]\n    report << \"Constants:  %*d (%*d undocumented)\\n\" % [\n      num_width, @num_constants, undoc_width, @undoc_constants]\n    report << \"Attributes: %*d (%*d undocumented)\\n\" % [\n      num_width, @num_attributes, undoc_width, @undoc_attributes]\n    report << \"Methods:    %*d (%*d undocumented)\\n\" % [\n      num_width, @num_methods, undoc_width, @undoc_methods]\n    report << \"Parameters: %*d (%*d undocumented)\\n\" % [\n      num_width, @num_params, undoc_width, @undoc_params] if\n        @coverage_level > 0\n\n    report << \"\\n\"\n\n    report << \"Total:      %*d (%*d undocumented)\\n\" % [\n      num_width, @num_items, undoc_width, @undoc_items]\n\n    report << \"%6.2f%% documented\\n\" % percent_doc\n    report << \"\\n\"\n    report << \"Elapsed: %0.1fs\\n\" % (Time.now - @start)\n\n    RDoc::Markup::Document.new report\n  end",
        "comment": " Returns a summary of the collected statistics.",
        "label": "Property",
        "id": "16001"
    },
    {
        "raw_code": "def column_defaults\n        load_schema\n        @column_defaults ||= _default_attributes.deep_dup.to_hash.freeze\n      end",
        "comment": "Returns a hash where the keys are column names and the values are default values when instantiating the Active Record object for this table.",
        "label": "Property",
        "id": "12523"
    },
    {
        "raw_code": "def pretty_name\n    \"#{name_prefix}#{@name}\"\n  end",
        "comment": " Method/attribute name with class/instance indicator",
        "label": "Property",
        "id": "16828"
    },
    {
        "raw_code": "def config\n        base_config = {\n          group: {\n            pipeline: BulkImports::Groups::Pipelines::GroupPipeline,\n            stage: 0\n          },\n          group_attributes: {\n            pipeline: BulkImports::Groups::Pipelines::GroupAttributesPipeline,\n            stage: 1\n          },\n          namespace_settings: {\n            pipeline: BulkImports::Groups::Pipelines::NamespaceSettingsPipeline,\n            stage: 1,\n            minimum_source_version: '15.0.0'\n          },\n          labels: {\n            pipeline: BulkImports::Common::Pipelines::LabelsPipeline,\n            stage: 1\n          },\n          milestones: {\n            pipeline: BulkImports::Common::Pipelines::MilestonesPipeline,\n            stage: 1\n          },\n          badges: {\n            pipeline: BulkImports::Common::Pipelines::BadgesPipeline,\n            stage: 1\n          },\n          boards: {\n            pipeline: BulkImports::Common::Pipelines::BoardsPipeline,\n            stage: 2\n          },\n          uploads: {\n            pipeline: BulkImports::Common::Pipelines::UploadsPipeline,\n            stage: 2\n          },\n          subgroups: {\n            pipeline: BulkImports::Groups::Pipelines::SubgroupEntitiesPipeline,\n            stage: 3 # SubGroup Entities must be imported in later stage\n            # to Project Entities to avoid `full_path` naming conflicts.\n          },\n          finisher: {\n            pipeline: BulkImports::Common::Pipelines::EntityFinisher,\n            stage: 4\n          }\n        }\n\n        base_config\n          .merge(project_entities_pipeline)\n          .merge(members_pipeline)\n      end",
        "comment": "To skip the execution of a pipeline in a specific source instance version, define the attributes `minimum_source_version` and `maximum_source_version`.  Use the `minimum_source_version` to inform that the pipeline needs to run when importing from source instances version greater than or equal to the specified minimum source version. For example, if the `minimum_source_version` is equal to 15.1.0, the pipeline will be executed when importing from source instances running versions 15.1.0, 15.1.1, 15.2.0, 16.0.0, etc. And it won't be executed when the source instance version is 15.0.1, 15.0.0, 14.10.0, etc.  Use the `maximum_source_version` to inform that the pipeline needs to run when importing from source instance versions less than or equal to the specified maximum source version. For example, if the `maximum_source_version` is equal to 15.1.0, the pipeline will be executed when importing from source instances running versions 15.1.1 (patch), 15.1.0, 15.0.1, 15.0.0, 14.10.0, etc. And it won't be executed when the source instance version is 15.2.0, 15.2.1, 16.0.0, etc.  SubGroup Entities must be imported in later stage than Project Entities to avoid `full_path` naming conflicts.",
        "label": "Property",
        "id": "3606"
    },
    {
        "raw_code": "def self.clear\n      unload_interlock do\n        _autoloaded_tracked_classes.clear\n        autoloader.reload\n      end",
        "comment": "Private method that reloads constants autoloaded by the main autoloader.  Rails.application.reloader.reload! is the public interface for application reload. That involves more things, like deleting unloaded classes from the internal state of the descendants tracker, or reloading routes.",
        "label": "Property",
        "id": "13804"
    },
    {
        "raw_code": "def locale=(locale)\n      @locale = locale\n      @parsed = false\n    end",
        "comment": "@param [String] locale the locale name to be translated. @return [void] @since 0.8.3",
        "label": "Property",
        "id": "617"
    },
    {
        "raw_code": "def default_scoped(scope = relation, all_queries: nil)\n          build_default_scope(scope, all_queries: all_queries) || scope\n        end",
        "comment": "Returns a scope for the model with default scopes.",
        "label": "Property",
        "id": "13455"
    },
    {
        "raw_code": "def partition_by_older_than(tags)\n        return [tags, []] unless older_than\n\n        older_than_timestamp = older_than_in_seconds.ago\n\n        tags.partition do |tag|\n          timestamp = pushed_at(tag)\n\n          timestamp && timestamp < older_than_timestamp\n        end",
        "comment": "Should return [tags_to_delete, tags_to_keep]",
        "label": "Property",
        "id": "5946"
    },
    {
        "raw_code": "def update_error(id, status:)\n        strategy.update_error(id, status: status)\n      end",
        "comment": "Updates attributes of an error.  @param id [Integer, String] unique error identifier @param status [String] error status  @return [true, false] if update was successful  @raise [DatabaseError] if generic error occurred",
        "label": "Property",
        "id": "2783"
    },
    {
        "raw_code": "def random_start_id\n      range_start = min_id\n      range_end = [min_id, max_id - Gitlab::Database::ConsistencyChecker::BATCH_SIZE].max\n      rand(range_start..range_end)\n    end",
        "comment": "This returns some random start_id, so that we don't always start checking from the start of the table, in case we lose the cursor in Redis.",
        "label": "Property",
        "id": "6131"
    },
    {
        "raw_code": "def print(msg = '')\n      clear_line\n      io.write(msg)\n    end",
        "comment": "Displays an unformatted line to the logger output stream. @param [String] msg the message to display @return [void] @since 0.8.2",
        "label": "Property",
        "id": "144"
    },
    {
        "raw_code": "def self.without_existing_merge_requests\n    existing_mrs = MergeRequest.except(:order, :where)\n      .select(1)\n      .where('merge_requests.source_project_id = events.project_id')\n      .where('merge_requests.source_branch = push_event_payloads.ref')\n      .with_state(:opened)\n\n    # For reasons unknown the use of #eager_load will result in the\n    # \"push_event_payload\" association not being set. Because of this we're\n    # using \"joins\" here, which does mean an additional query needs to be\n    # executed in order to retrieve the \"push_event_association\" when the\n    # returned PushEvent is used.\n    joins(:push_event_payload)\n      .where('NOT EXISTS (?)', existing_mrs)\n      .created_or_pushed\n      .branch_events\n  end",
        "comment": "Returns PushEvent instances for which no merge requests have been created.",
        "label": "Property",
        "id": "6945"
    },
    {
        "raw_code": "def beginning_of_week\n      ::ActiveSupport::IsolatedExecutionState[:beginning_of_week] || beginning_of_week_default || :monday\n    end",
        "comment": "Returns the week start (e.g. +:monday+) for the current request, if this has been set (via Date.beginning_of_week=). If <tt>Date.beginning_of_week</tt> has not been set for the current request, returns the week start specified in <tt>config.beginning_of_week</tt>. If no +config.beginning_of_week+ was specified, returns +:monday+.",
        "label": "Property",
        "id": "14112"
    },
    {
        "raw_code": "def self.global_executor_concurrency=(global_executor_concurrency)\n    if self.async_query_executor.nil? || self.async_query_executor == :multi_thread_pool\n      raise ArgumentError, \"`global_executor_concurrency` cannot be set when the executor is nil or set to `:multi_thread_pool`. For multiple thread pools, please set the concurrency in your database configuration.\"\n    end",
        "comment": "Set the +global_executor_concurrency+. This configuration value can only be used with the global thread pool async query executor.",
        "label": "Property",
        "id": "12340"
    },
    {
        "raw_code": "def value(name_to_display = nil)\n        [\n          operator.verb,\n          identifier&.key_path(operator),\n          name_to_display || name_for_events,\n          time_frame&.key_path\n        ].compact.join('_')\n      end",
        "comment": "@param name_to_display [String] return the key with the provided name instead of a list of event names",
        "label": "Property",
        "id": "5314"
    },
    {
        "raw_code": "def configure_static_interface(nic_index, net_connection_id, ip, netmask)\n        @logger.info(\"Configuring NIC #{net_connection_id} using static ip #{ip}\")\n        #netsh interface ip set address \"Local Area Connection 2\" static 192.168.33.10 255.255.255.0\n        netsh = \"netsh interface ip set address \\\"#{net_connection_id}\\\" static #{ip} #{netmask}\"\n        @communicator.execute(netsh)\n      end",
        "comment": "Configures the specified interface using a static address  @param [Integer] The interface index. @param [String] The unique name of the NIC, such as 'Local Area Connection'. @param [String] The static IP address to assign to the specified NIC. @param [String] The network mask to use with the static IP.",
        "label": "Property",
        "id": "9847"
    },
    {
        "raw_code": "def _wrapper_key\n        _wrapper_options.name\n      end",
        "comment": "Returns the wrapper key which will be used to store wrapped parameters.",
        "label": "Property",
        "id": "11309"
    },
    {
        "raw_code": "def validate(machine)\n        errors = _detected_errors\n\n        if @type && @type != DEFAULT_CONFIG_TYPE\n          errors << I18n.t(\"vagrant.cloud_init.incorrect_type_set\",\n                           type: @type,\n                           machine: machine.name,\n                           default_type: DEFAULT_CONFIG_TYPE)\n        end",
        "comment": "@return [Array] array of strings of error messages from config option validation",
        "label": "Property",
        "id": "9460"
    },
    {
        "raw_code": "def wrap(text, col = 72)\n          text.gsub(/(.{1,#{col}})( +|$\\n?)|(.{1,#{col}})/, \"\\\\1\\\\3\\n\")\n        end",
        "comment": "@return [String] wraps text at +col+ columns.",
        "label": "Property",
        "id": "450"
    },
    {
        "raw_code": "def instance_variables_hash\n          instance_variables.inject({}) do |acc, iv|\n            acc[iv.to_s[1..-1]] = instance_variable_get(iv)\n            acc\n          end",
        "comment": "Returns the instance variables as a hash of key-value pairs.",
        "label": "Property",
        "id": "9126"
    },
    {
        "raw_code": "def open?\n      !closed?\n    end",
        "comment": "Returns true if the transaction exists and isn't finalized yet.",
        "label": "Property",
        "id": "12713"
    },
    {
        "raw_code": "def machine(name, provider, refresh=false)\n      @logger.info(\"Getting machine: #{name} (#{provider})\")\n\n      # Compose the cache key of the name and provider, and return from\n      # the cache if we have that.\n      cache_key = [name, provider]\n      @machines ||= {}\n      if refresh\n        @logger.info(\"Refreshing machine (busting cache): #{name} (#{provider})\")\n        @machines.delete(cache_key)\n      end",
        "comment": "This returns a machine with the proper provider for this environment. The machine named by `name` must be in this environment.  @param [Symbol] name Name of the machine (as configured in the Vagrantfile). @param [Symbol] provider The provider that this machine should be backed by. @param [Boolean] refresh If true, then if there is a cached version it is reloaded. @return [Machine]",
        "label": "Property",
        "id": "8866"
    },
    {
        "raw_code": "def queues_cmd\n      if @strictly_ordered_queues\n        @queues\n      else\n        permute = @queues.shuffle\n        permute.uniq!\n        permute\n      end",
        "comment": "Creating the Redis#brpop command takes into account any configured queue weights. By default Redis#brpop returns data from the first queue that has pending elements. We recreate the queue command each time we invoke Redis#brpop to honor weights and avoid queue starvation.",
        "label": "Property",
        "id": "5191"
    },
    {
        "raw_code": "def merge(headers_or_env)\n        headers = @req.dup.headers\n        headers.merge!(headers_or_env)\n        headers\n      end",
        "comment": "Returns a new Http::Headers instance containing the contents of `headers_or_env` and the original instance.",
        "label": "Property",
        "id": "11429"
    },
    {
        "raw_code": "def handler_base_class\n        handler_base_namespace.const_get(:Base)\n      end",
        "comment": "Returns the handler base class @return [Base] the base class",
        "label": "Property",
        "id": "184"
    },
    {
        "raw_code": "def up\n    remove_foreign_key_if_exists(\n      :epics,\n      :issues,\n      column: :issue_id,\n      on_delete: :nullify,\n      name: OLD_FK_NAME,\n      reverse_lock_order: true\n    )\n  end",
        "comment": "new foreign key added in FixEpicsCascadeOptionOnFkToIssueId and validated in FixEpicsCascadeOptionOnFkToIssueId",
        "label": "Property",
        "id": "5007"
    },
    {
        "raw_code": "def take(limit = nil)\n        load_target if find_from_target?\n        super\n      end",
        "comment": "Gives a record (or N records if a parameter is supplied) from the collection using the same rules as ActiveRecord::FinderMethods.take.  class Person < ActiveRecord::Base has_many :pets end  person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.take # => #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>  person.pets.take(2) # => [ #      #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #      #<Pet id: 2, name: \"Spook\", person_id: 1> #    ]  another_person_without.pets         # => [] another_person_without.pets.take    # => nil another_person_without.pets.take(2) # => []",
        "label": "Property",
        "id": "12785"
    },
    {
        "raw_code": "def batch_blobs(items, blob_size_limit: Gitlab::Git::Blob::MAX_DATA_DISPLAY_SIZE)\n        Gitlab::Git::Blob.batch(self, items, blob_size_limit: blob_size_limit)\n      end",
        "comment": "Items should be of format [[commit_id, path], [commit_id1, path1]]",
        "label": "Property",
        "id": "2654"
    },
    {
        "raw_code": "def do_something\n            end",
        "comment": "{access_modifier}",
        "label": "Property",
        "id": "10836"
    },
    {
        "raw_code": "def slug\n      \"#{@owner}/#{@name}\"\n    end",
        "comment": "Repository owner/name @return [String]",
        "label": "Property",
        "id": "14917"
    },
    {
        "raw_code": "def routing_queues\n        @routing_queues ||= workers.map do |worker|\n          if worker.klass.is_a?(Gitlab::SidekiqConfig::DummyWorker)\n            worker.queue\n          else\n            ::Gitlab::SidekiqConfig::WorkerRouter.global.route(worker.klass)\n          end",
        "comment": "Get the list of queues from all available workers following queue routing rules. Sidekiq::Queue.all fetches the list of queues from Redis. It may contain some redundant, obsolete queues from previous iterations of GitLab.",
        "label": "Property",
        "id": "1419"
    },
    {
        "raw_code": "def to_partial_path\n      self.class._to_partial_path\n    end",
        "comment": "Returns a +string+ identifying the path associated with the object. ActionPack uses this to find a suitable partial to represent the object.  class Person include ActiveModel::Conversion end  person = Person.new person.to_partial_path # => \"people/person\"",
        "label": "Property",
        "id": "12195"
    },
    {
        "raw_code": "def ordinal(number)\n      I18n.translate(\"number.nth.ordinals\", number: number)\n    end",
        "comment": "Returns the suffix that should be added to a number to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.  ordinal(1)     # => \"st\" ordinal(2)     # => \"nd\" ordinal(1002)  # => \"nd\" ordinal(1003)  # => \"rd\" ordinal(-11)   # => \"th\" ordinal(-1021) # => \"st\"",
        "label": "Property",
        "id": "14476"
    },
    {
        "raw_code": "def id_in_database\n        if self.class.composite_primary_key?\n          @primary_key.map { |col| attribute_in_database(col) }\n        else\n          super\n        end",
        "comment": "Returns the primary key column's value from the database. If the primary key is composite, returns an array of primary key column values from database.",
        "label": "Property",
        "id": "12837"
    },
    {
        "raw_code": "def namespace_id\n        @namespace_id ||= ENV[\"CI_PROJECT_NAMESPACE_ID\"].to_i\n      end",
        "comment": "Project namespace ID  @return [Integer]",
        "label": "Property",
        "id": "8110"
    },
    {
        "raw_code": "def number_to_human_size(number, options = {})\n      NumberToHumanSizeConverter.convert(number, options)\n    end",
        "comment": "Formats +number+ as bytes into a more human-friendly representation. Useful for reporting file sizes to users.  number_to_human_size(123)                 # => \"123 Bytes\" number_to_human_size(1234)                # => \"1.21 KB\" number_to_human_size(12345)               # => \"12.1 KB\" number_to_human_size(1234567)             # => \"1.18 MB\" number_to_human_size(1234567890)          # => \"1.15 GB\" number_to_human_size(1234567890123)       # => \"1.12 TB\" number_to_human_size(1234567890123456)    # => \"1.1 PB\" number_to_human_size(1234567890123456789) # => \"1.07 EB\"  See #number_to_human if you want to pretty-print a generic number.  ==== Options  [+:locale+] The locale to use for formatting. Defaults to the current locale.  [+:precision+] The level of precision. Defaults to 3.  number_to_human_size(123456, precision: 2)  # => \"120 KB\" number_to_human_size(1234567, precision: 2) # => \"1.2 MB\"  [+:round_mode+] Specifies how rounding is performed. See +BigDecimal.mode+. Defaults to +:default+.  number_to_human_size(123456, precision: 2, round_mode: :up) # => \"130 KB\"  [+:significant+] Whether +:precision+ should be applied to significant digits instead of fractional digits. Defaults to true.  [+:separator+] The decimal separator. Defaults to <tt>\".\"</tt>.  number_to_human_size(1234567, separator: \",\") # => \"1,18 MB\"  [+:delimiter+] The thousands delimiter. Defaults to <tt>\",\"</tt>.  [+:strip_insignificant_zeros+] Whether to remove insignificant zeros after the decimal separator. Defaults to true. ",
        "label": "Property",
        "id": "13922"
    },
    {
        "raw_code": "def delete(target)\n      middlewares.reject! { |m| m.name == target.name }\n    end",
        "comment": "Deletes a middleware from the middleware stack.  Returns the array of middlewares not including the deleted item, or returns nil if the target is not found.",
        "label": "Property",
        "id": "11539"
    },
    {
        "raw_code": "def extract!\n      qualified_id, @ref, @path = extract_ref_path\n      @id = @override_id || qualified_id\n      @repo = repository_container.repository\n      raise InvalidPathError if @ref.match?(/\\s/)\n\n      return unless @ref.present?\n\n      @commit = if ref_type\n                  @fully_qualified_ref = self.class.qualify_ref(@ref, ref_type)\n                  @repo.commit(@fully_qualified_ref)\n                else\n                  @repo.commit(@ref)\n                end",
        "comment": "Extracts common variables for views working with Git tree-ish objects  Assignments are:  - @id     - A string representing the joined ref and path Assigns @override_id if it is present. - @ref    - A string representing the ref (e.g., the branch, tag, or commit SHA) - @path   - A string representing the filesystem path - @commit - A Commit representing the commit from the given ref - @fully_qualified_ref - A string representing the fully qualifed ref (e.g., refs/tags/v1.1)  If the :id parameter appears to be requesting a specific response format, that will be handled as well.",
        "label": "Property",
        "id": "3852"
    },
    {
        "raw_code": "def human_name\n        Base.human_attribute_name(@name)\n      end",
        "comment": "Returns the human name of the column name.  ===== Examples Column.new('sales_stage', ...).human_name # => 'Sales stage'",
        "label": "Property",
        "id": "12961"
    },
    {
        "raw_code": "def self.extension_versions(env)\n      plugins = config_for_pwd(env).loaded_plugins\n      plugin_versions = plugins.filter_map do |plugin|\n        next if Plugin::BUILTIN_INTERNAL_PLUGINS.key?(plugin.about.name)\n        next unless (plugin_name = plugin.about.name)\n\n        \"  - #{plugin_name} #{plugin.about.version}\"\n      end",
        "comment": "@api private rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength, Metrics/PerceivedComplexity",
        "label": "Property",
        "id": "10083"
    },
    {
        "raw_code": "def plain_paginate(items)\n    render \"layouts/plain_paginate\", items: items\n  end",
        "comment": "replacement for Kaminari::ActionViewExtension#paginate only shows `next` and `prev` links and not page numbers, saving a COUNT(DISTINCT ..) query",
        "label": "Property",
        "id": "9972"
    },
    {
        "raw_code": "def select_datetime(datetime = Time.current, options = {}, html_options = {})\n        DateTimeSelector.new(datetime, options, html_options).select_datetime\n      end",
        "comment": "Returns a set of HTML select-tags (one for year, month, day, hour, minute, and second) pre-selected with the +datetime+. It's also possible to explicitly set the order of the tags using the <tt>:order</tt> option with an array of symbols <tt>:year</tt>, <tt>:month</tt> and <tt>:day</tt> in the desired order. If you do not supply a Symbol, it will be appended onto the <tt>:order</tt> passed in. You can also add <tt>:date_separator</tt>, <tt>:datetime_separator</tt> and <tt>:time_separator</tt> keys to the +options+ to control visual display of the elements.  If anything is passed in the html_options hash it will be applied to every select tag in the set.  my_date_time = Time.now + 4.days  # Generates a datetime select that defaults to the datetime in my_date_time (four days after today). select_datetime(my_date_time)  # Generates a datetime select that defaults to today (no specified datetime) select_datetime()  # Generates a datetime select that defaults to the datetime in my_date_time (four days after today) # with the fields ordered year, month, day rather than month, day, year. select_datetime(my_date_time, order: [:year, :month, :day])  # Generates a datetime select that defaults to the datetime in my_date_time (four days after today) # with a '/' between each date field. select_datetime(my_date_time, date_separator: '/')  # Generates a datetime select that defaults to the datetime in my_date_time (four days after today) # with a date fields separated by '/', time fields separated by '' and the date and time fields # separated by a comma (','). select_datetime(my_date_time, date_separator: '/', time_separator: '', datetime_separator: ',')  # Generates a datetime select that discards the type of the field and defaults to the datetime in # my_date_time (four days after today) select_datetime(my_date_time, discard_type: true)  # Generate a datetime field with hours in the AM/PM format select_datetime(my_date_time, ampm: true)  # Generates a datetime select that defaults to the datetime in my_date_time (four days after today) # prefixed with 'payday' rather than 'date' select_datetime(my_date_time, prefix: 'payday')  # Generates a datetime select with a custom prompt. Use <tt>prompt: true</tt> for generic prompts. select_datetime(my_date_time, prompt: { day: 'Choose day', month: 'Choose month', year: 'Choose year' }) select_datetime(my_date_time, prompt: { hour: true }) # generic prompt for hours select_datetime(my_date_time, prompt: true) # generic prompts for all",
        "label": "Property",
        "id": "11830"
    },
    {
        "raw_code": "def haml?\n      @current_engine == :haml\n    end",
        "comment": "@return [Boolean] Returns true if current engine is `:haml`.",
        "label": "Property",
        "id": "8671"
    },
    {
        "raw_code": "def patterns\n        @patterns ||= parse_data\n      end",
        "comment": "Returns a Hash containing the file patterns and their attributes.",
        "label": "Property",
        "id": "2581"
    },
    {
        "raw_code": "def halt(*response)\n      response = response.first if response.length == 1\n      throw :halt, response\n    end",
        "comment": "Exit the current block, halts any further processing of the request, and returns the specified response.",
        "label": "Property",
        "id": "8580"
    },
    {
        "raw_code": "def execute(oids)\n        return [] unless project&.lfs_enabled?\n\n        validate!(oids)\n\n        yield if block_given?\n\n        # Search and link existing LFS Object\n        link_existing_lfs_objects(oids)\n      end",
        "comment": "Accept an array of oids to link  Returns an array with the oid of the existent lfs objects",
        "label": "Property",
        "id": "5942"
    },
    {
        "raw_code": "def attributes\n      @attributes.to_hash\n    end",
        "comment": "Returns a hash of all the attributes with their names as keys and the values of the attributes as values.  class Person < ActiveRecord::Base end  person = Person.create(name: 'Francesco', age: 22) person.attributes # => {\"id\"=>3, \"created_at\"=>Sun, 21 Oct 2012 04:53:04, \"updated_at\"=>Sun, 21 Oct 2012 04:53:04, \"name\"=>\"Francesco\", \"age\"=>22}",
        "label": "Property",
        "id": "12368"
    },
    {
        "raw_code": "def _ListItemTight\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_Bullet)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_Enumerator)\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ListItemTight = (Bullet | Enumerator) ListBlock:a (!@BlankLine ListContinuationBlock:b { a.push(*b) })* !ListContinuationBlock { list_item_from a }",
        "label": "Property",
        "id": "15617"
    },
    {
        "raw_code": "def initialize(attributes)\n          @attributes = attributes\n        end",
        "comment": "attributes - A Hash containing the user details. The keys of this Hash (and any nested hashes) must be symbols.",
        "label": "Property",
        "id": "2251"
    },
    {
        "raw_code": "def to_s\n      to_hash.to_s\n    end",
        "comment": "Returns the string representation of the object @return [String] String presentation of the object",
        "label": "Property",
        "id": "875"
    },
    {
        "raw_code": "def source_attribute_from_preserved_attribute(attribute_name)\n          attribute_name.to_s.sub(ORIGINAL_ATTRIBUTE_PREFIX, \"\") if attribute_name.start_with?(ORIGINAL_ATTRIBUTE_PREFIX)\n        end",
        "comment": "Given a attribute name, it returns the name of the source attribute when it's a preserved one.",
        "label": "Property",
        "id": "13307"
    },
    {
        "raw_code": "def waiting?\n      !try_obtain\n    end",
        "comment": "This lease is waiting to obtain",
        "label": "Property",
        "id": "1760"
    },
    {
        "raw_code": "def begin_fast_destroy\n      raise NotImplementedError\n    end",
        "comment": " This method returns identifiers to delete associated external data (e.g. file paths, redis keys)  This method must be defined in fast destroyable model",
        "label": "Property",
        "id": "7301"
    },
    {
        "raw_code": "def valparse(ts)\n    if ts.length < 0\n      raise Error, 'empty'\n    end",
        "comment": "Parses a \"value\" in the sense of RFC 4627. Returns the parsed value and any trailing tokens.",
        "label": "Property",
        "id": "8697"
    },
    {
        "raw_code": "def title\n    return full_title if full_title.length < 100\n\n    # Use three dots instead of the ellipsis Unicode character because\n    # some clients show the raw Unicode value in the merge commit.\n    full_title.truncate(81, separator: ' ', omission: '...')\n  end",
        "comment": "Returns the commits title.  Usually, the commit title is the first line of the commit message. In case this first line is longer than 100 characters, it is cut off after 80 characters + `...`",
        "label": "Property",
        "id": "6921"
    },
    {
        "raw_code": "def object_link_filter(text, pattern, link_content: nil, link_reference: false)\n          references_in(text, pattern) do |match, id, project_ref, namespace_ref, matches|\n            parent_path = if parent_type == :group\n                            reference_cache.full_group_path(namespace_ref)\n                          elsif parent_type == :namespace\n                            reference_cache.full_namespace_path(matches)\n                          else\n                            reference_cache.full_project_path(namespace_ref, project_ref, matches)\n                          end",
        "comment": "Replace references (like `!123` for merge requests) in text with links to the referenced object's details page.  text - String text to replace references in. pattern - Reference pattern to match against. link_content - Original content of the link being replaced. link_reference - True if this was using the link reference pattern, false otherwise.  Returns a String with references replaced with links. All links have `gfm` and `gfm-OBJECT_NAME` class names attached for styling.",
        "label": "Property",
        "id": "3488"
    },
    {
        "raw_code": "def queue_with_priority(priority = nil, &block)\n        if block_given?\n          self.priority = block\n        else\n          self.priority = priority\n        end",
        "comment": "Specifies the priority of the queue to create the job with.  class PublishToFeedJob < ActiveJob::Base queue_with_priority 50  def perform(post) post.to_feed! end end  Can be given a block that will evaluate in the context of the job so that a dynamic priority can be applied:  class PublishToFeedJob < ApplicationJob queue_with_priority do post = self.arguments.first  if post.paid? 10 else 50 end end  def perform(post) post.to_feed! end end",
        "label": "Property",
        "id": "12134"
    },
    {
        "raw_code": "def store(key, value, convert_value: true)\n      value = convert_value(value, conversion: :assignment) if convert_value\n      regular_writer(convert_key(key), value)\n    end",
        "comment": "Assigns a new value to the hash:  hash = ActiveSupport::HashWithIndifferentAccess.new hash[:key] = 'value'  This value can be later fetched using either +:key+ or <tt>'key'</tt>.  If the value is a Hash or contains one or multiple Hashes, they will be converted to +HashWithIndifferentAccess+. unless `convert_value: false` is set.",
        "label": "Property",
        "id": "13875"
    },
    {
        "raw_code": "def create_entries(entries)\n      # git log entries have no strictly itemized style like the old\n      # style, just assume Markdown.\n      entries.map do |commit, entry|\n        LogEntry.new(@base_url, commit, *entry)\n      end",
        "comment": " Returns a list of ChangeLog entries as RDoc::Parser::ChangeLog::Git::LogEntry list for the given +entries+.",
        "label": "Property",
        "id": "16059"
    },
    {
        "raw_code": "def get_address_info(uri)\n          Timeout.timeout(GETADDRINFO_TIMEOUT_SECONDS) do\n            Addrinfo.getaddrinfo(uri.hostname, get_port(uri), nil, :STREAM).map do |addr|\n              addr.ipv6_v4mapped? ? addr.ipv6_to_ipv4 : addr\n            end",
        "comment": "Returns addrinfo object for the URI.  @param uri [Addressable::URI]  @raise [Gitlab::HTTP_V2::UrlBlocker::BlockedUrlError, ArgumentError] raised if host is too long.  @return [Array<Addrinfo>]",
        "label": "Property",
        "id": "1202"
    },
    {
        "raw_code": "def paginate_with_strategies(relation, request_scope = nil, paginator_params: {})\n        paginator = paginator(relation, request_scope)\n\n        result = if block_given?\n                   yield(paginator.paginate(relation, **paginator_params))\n                 else\n                   paginator.paginate(relation, **paginator_params)\n                 end",
        "comment": "paginator_params are only currently supported with offset pagination",
        "label": "Property",
        "id": "3828"
    },
    {
        "raw_code": "def assert_enqueued_with(job: nil, args: nil, at: nil, queue: nil, priority: nil, &block)\n      require_active_job_test_adapter!(\"assert_enqueued_with\")\n\n      expected = { job: job, args: args, at: at, queue: queue, priority: priority }.compact\n      expected_args = prepare_args_for_assertion(expected)\n      potential_matches = []\n\n      if block_given?\n        original_enqueued_jobs = enqueued_jobs.dup\n\n        _assert_nothing_raised_or_warn(\"assert_enqueued_with\", &block)\n\n        jobs = enqueued_jobs - original_enqueued_jobs\n      else\n        jobs = enqueued_jobs\n      end",
        "comment": "Asserts that the job has been enqueued with the given arguments.  def test_assert_enqueued_with MyJob.perform_later(1,2,3) assert_enqueued_with(job: MyJob, args: [1,2,3])  MyJob.set(wait_until: Date.tomorrow.noon, queue: \"my_queue\").perform_later assert_enqueued_with(at: Date.tomorrow.noon, queue: \"my_queue\") end  For keyword arguments, specify them as a hash inside an array:  def test_assert_enqueued_with_keyword_arguments MyJob.perform_later(arg1: 'value1', arg2: 'value2') assert_enqueued_with(job: MyJob, args: [{ arg1: 'value1', arg2: 'value2' }]) end  The given arguments may also be specified as matcher procs that return a boolean value indicating whether a job's attribute meets certain criteria.  For example, a proc can be used to match a range of times:  def test_assert_enqueued_with at_matcher = ->(job_at) { (Date.yesterday..Date.tomorrow).cover?(job_at) }  MyJob.set(wait_until: Date.today.noon).perform_later  assert_enqueued_with(job: MyJob, at: at_matcher) end  A proc can also be used to match a subset of a job's args:  def test_assert_enqueued_with args_matcher = ->(job_args) { job_args[0].key?(:foo) }  MyJob.perform_later(foo: \"bar\", other_arg: \"No need to check in the test\")  assert_enqueued_with(job: MyJob, args: args_matcher) end  If a block is passed, asserts that the block will cause the job to be enqueued with the given arguments.  def test_assert_enqueued_with assert_enqueued_with(job: MyJob, args: [1,2,3]) do MyJob.perform_later(1,2,3) end  assert_enqueued_with(job: MyJob, at: Date.tomorrow.noon) do MyJob.set(wait_until: Date.tomorrow.noon).perform_later end end",
        "label": "Property",
        "id": "12144"
    },
    {
        "raw_code": "def reset\n        proxy_association.reset\n        proxy_association.reset_scope\n        reset_scope\n      end",
        "comment": "Unloads the association. Returns +self+.  class Person < ActiveRecord::Base has_many :pets end  person.pets # fetches pets from the database # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]  person.pets # uses the pets cache # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]  person.pets.reset # clears the pets cache  person.pets  # fetches pets from the database # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]",
        "label": "Property",
        "id": "12805"
    },
    {
        "raw_code": "def merge_requests_for(source_branch, mr_states: [:opened])\n      @project.source_of_merge_requests\n        .with_state(mr_states)\n        .where(source_branch: source_branch)\n        .preload(:source_project) # we don't need #includes since we're just preloading for the #select\n        .select(&:source_project)\n    end",
        "comment": "Returns all origin and fork merge requests from `@project` satisfying passed arguments. rubocop: disable CodeReuse/ActiveRecord",
        "label": "Property",
        "id": "5582"
    },
    {
        "raw_code": "def to_body\n      to_hash\n    end",
        "comment": "to_body is an alias to to_hash (backward compatibility) @return [Hash] Returns the object in the form of hash",
        "label": "Property",
        "id": "876"
    },
    {
        "raw_code": "def presence(obj)\n        if present?(obj)\n          obj\n        else\n          false\n        end",
        "comment": "Returns the presence of the object. If the object is {present?}, it is returned. Otherwise `false` is returned.  @return [Object, false]",
        "label": "Property",
        "id": "9185"
    },
    {
        "raw_code": "def not(opts, *rest)\n        where_clause = @scope.send(:build_where_clause, opts, rest)\n\n        @scope.where_clause += where_clause.invert\n\n        @scope\n      end",
        "comment": "Returns a new relation expressing WHERE + NOT condition according to the conditions in the arguments.  #not accepts conditions as a string, array, or hash. See QueryMethods#where for more details on each format.  User.where.not(\"name = 'Jon'\") # SELECT * FROM users WHERE NOT (name = 'Jon')  User.where.not([\"name = ?\", \"Jon\"]) # SELECT * FROM users WHERE NOT (name = 'Jon')  User.where.not(name: \"Jon\") # SELECT * FROM users WHERE name != 'Jon'  User.where.not(name: nil) # SELECT * FROM users WHERE name IS NOT NULL  User.where.not(name: %w(Ko1 Nobu)) # SELECT * FROM users WHERE name NOT IN ('Ko1', 'Nobu')  User.where.not(name: \"Jon\", role: \"admin\") # SELECT * FROM users WHERE NOT (name = 'Jon' AND role = 'admin')  If there is a non-nil condition on a nullable column in the hash condition, the records that have nil values on the nullable column won't be returned. User.create!(nullable_country: nil) User.where.not(nullable_country: \"UK\") # SELECT * FROM users WHERE NOT (nullable_country = 'UK') # => []",
        "label": "Property",
        "id": "13392"
    },
    {
        "raw_code": "def banzai_render_context(field)\n    raise ArgumentError, \"Unknown field: #{field.inspect}\" unless\n      cached_markdown_fields.key?(field)\n\n    # Always include a project key, or Banzai complains\n    project = self.project if self.respond_to?(:project)\n    group   = self.group if self.respond_to?(:group)\n    context = cached_markdown_fields[field].merge(project: project, group: group)\n\n    # Banzai is less strict about authors, so don't always have an author key\n    context[:author] = self.author if self.respond_to?(:author)\n\n    context[:user] = self.parent_user if Feature.enabled?(:personal_snippet_reference_filters, context[:author])\n\n    context\n  end",
        "comment": "Returns the default Banzai render context for the cached markdown field.",
        "label": "Property",
        "id": "7380"
    },
    {
        "raw_code": "def all_autoload_paths # :nodoc:\n        autoload_paths + paths.autoload_paths\n      end",
        "comment": "Private method that adds custom autoload paths to the ones defined by +paths+.",
        "label": "Property",
        "id": "14724"
    },
    {
        "raw_code": "def [](state)\n      state = state.to_sym if cast_state_to_symbol?(state)\n\n      cache_for_finder[state] || 0\n    end",
        "comment": "Returns the count for the given state.  state - The name of the state as either a String or a Symbol.  Returns an Integer.",
        "label": "Property",
        "id": "1487"
    },
    {
        "raw_code": "def all_members\n      GroupMember.from_union([\n        members_from_self_and_ancestors,\n        members_from_self_and_ancestor_group_shares\n      ])\n    end",
        "comment": "Returns all members for group and parents, with no filters",
        "label": "Property",
        "id": "7699"
    },
    {
        "raw_code": "def blobs(revisions, with_paths: false, dynamic_timeout: nil)\n        revisions = revisions.reject { |rev| rev.blank? || Gitlab::Git.blank_ref?(rev) }\n\n        return [] if revisions.blank?\n\n        wrapped_gitaly_errors do\n          gitaly_blob_client.list_blobs(revisions, limit: REV_LIST_COMMIT_LIMIT,\n            with_paths: with_paths, dynamic_timeout: dynamic_timeout)\n        end",
        "comment": "List blobs reachable via a set of revisions. Supports the pseudo-revisions `--not` and `--all`. Uses the minimum of GitalyClient.medium_timeout and dynamic timeout if the dynamic timeout is set, otherwise it'll always use the medium timeout.",
        "label": "Property",
        "id": "2630"
    },
    {
        "raw_code": "def zone\n      ::ActiveSupport::IsolatedExecutionState[:time_zone] || zone_default\n    end",
        "comment": "Returns the TimeZone for the current request, if this has been set (via Time.zone=). If <tt>Time.zone</tt> has not been set for the current request, returns the TimeZone specified in <tt>config.time_zone</tt>.",
        "label": "Property",
        "id": "14418"
    },
    {
        "raw_code": "def set_signature_error(error)\n        @invalid_signature_error ||= error.is_a?(SnippetRepository::InvalidSignatureError)\n      end",
        "comment": "We sometimes receive invalid signature from Gitaly if the commit author name or email is invalid to create the commit signature. In this situation, we set the error and use the migration_bot since the information used to build it is valid",
        "label": "Property",
        "id": "3285"
    },
    {
        "raw_code": "def bounds\n        start = comment.source_range.begin_pos + margin.length\n        length = [keyword, colon, space].reduce(0) { |len, elem| len + elem.to_s.length }\n        [start, start + length]\n      end",
        "comment": "Returns the range bounds for just the annotation",
        "label": "Property",
        "id": "10468"
    },
    {
        "raw_code": "def design_version_added(version)\n    ::SystemNotes::DesignManagementService.new(noteable: version.issue, container: version.issue.project, author: version.author).design_version_added(version)\n  end",
        "comment": "Parameters: - version [DesignManagement::Version]  Example Note text:  \"added [1 designs](link-to-version)\" \"changed [2 designs](link-to-version)\"  Returns [Array<Note>]: the created Note objects",
        "label": "Property",
        "id": "5513"
    },
    {
        "raw_code": "def separator(type)\n          return \"\" if @options[:use_hidden]\n\n          case type\n          when :year, :month, :day\n            @options[:\"discard_#{type}\"] ? \"\" : @options[:date_separator]\n          when :hour\n            (@options[:discard_year] && @options[:discard_day]) ? \"\" : @options[:datetime_separator]\n          when :minute, :second\n            @options[:\"discard_#{type}\"] ? \"\" : @options[:time_separator]\n          end",
        "comment": "Returns the separator for a given datetime component.",
        "label": "Property",
        "id": "11857"
    },
    {
        "raw_code": "def self.force_encoding(data, encoding = default_encoding)\n      return if data == settings || data.is_a?(Tempfile)\n\n      if data.respond_to? :force_encoding\n        data.force_encoding(encoding).encode!\n      elsif data.respond_to? :each_value\n        data.each_value { |v| force_encoding(v, encoding) }\n      elsif data.respond_to? :each\n        data.each { |v| force_encoding(v, encoding) }\n      end",
        "comment": "Force data to specified encoding. It defaults to settings.default_encoding which is UTF-8 by default",
        "label": "Property",
        "id": "8613"
    },
    {
        "raw_code": "def _HtmlBlockOpenDl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenDl = \"<\" Spnl (\"dl\" | \"DL\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "15641"
    },
    {
        "raw_code": "def self.foo\n            'foo'\n          end",
        "comment": "{'private' unless visibility.to_sym == :private} != visibility",
        "label": "Property",
        "id": "767"
    },
    {
        "raw_code": "def format_box_results(box, env, options={})\n        if box.is_a?(VagrantCloud::Box)\n          info = box_info(box, options)\n        elsif box.is_a?(VagrantCloud::Box::Version)\n          info = version_info(box)\n        else\n          info = provider_info(box)\n        end",
        "comment": "Output box details result from Vagrant Cloud  @param [VagrantCloud::Box, VagrantCloud::Box::Version] box Box or box version to display @param [Vagrant::Environment] env Current Vagrant environment @return [nil]",
        "label": "Property",
        "id": "9745"
    },
    {
        "raw_code": "def exported_members_email_map\n        @exported_members_email_map ||= begin\n          result = {}\n          @exported_members.each do |member|\n            email = get_email(member)\n\n            next unless email\n\n            result[member.dig('user', 'id')] = email\n          end",
        "comment": "Returns {user_id => email} hash where user_id is an ID at source \"old\" instance",
        "label": "Property",
        "id": "2823"
    },
    {
        "raw_code": "def supports_operations?(identifier)\n          operable_identifiers.include?(identifier)\n        end",
        "comment": "Whether the given identifier is available for all events and can be used as a uniqueness constraint",
        "label": "Property",
        "id": "5361"
    },
    {
        "raw_code": "def supported_types\n          StorageController::SATA_CONTROLLER_TYPES + StorageController::IDE_CONTROLLER_TYPES +\n            StorageController::SCSI_CONTROLLER_TYPES\n        end",
        "comment": "Returns a list of all the supported controller types.  @return [Array<String>]",
        "label": "Property",
        "id": "9659"
    },
    {
        "raw_code": "def initialize(wiki_content)\n        @wiki_content = wiki_content\n      end",
        "comment": "@param [String] wiki_content",
        "label": "Property",
        "id": "2796"
    },
    {
        "raw_code": "def instrumentation\n            metric_queries = IMPORTS_METRICS.map do |metric|\n              \"(#{metric.new(time_frame: time_frame).instrumentation})\"\n            end.join(' + ')\n\n            \"SELECT #{metric_queries}\"\n          end",
        "comment": "overwriting instrumentation to generate the appropriate sql query",
        "label": "Property",
        "id": "1991"
    },
    {
        "raw_code": "def appender_proc(data)\n    Proc.new { |env| env[:data] << data }\n  end",
        "comment": "This returns a proc that can be used with the builder that simply appends data to an array in the env.",
        "label": "Property",
        "id": "9939"
    },
    {
        "raw_code": "def to_r\n      utc.to_r\n    end",
        "comment": "Returns the object's date and time as a rational number of seconds since the Epoch (January 1, 1970 00:00 UTC).  Time.zone.now.to_r # => (708854548642709/500000)",
        "label": "Property",
        "id": "13990"
    },
    {
        "raw_code": "def timestamps(**options)\n        raise_on_if_exist_options(options)\n        @base.add_timestamps(name, **options)\n      end",
        "comment": "Adds timestamps (+created_at+ and +updated_at+) columns to the table.  t.timestamps(null: false)  See {connection.add_timestamps}[rdoc-ref:SchemaStatements#add_timestamps]",
        "label": "Property",
        "id": "13109"
    },
    {
        "raw_code": "def up\n    with_lock_retries do\n      add_column :users, :organization_id, :bigint, default: DEFAULT_ORGANIZATION_ID, null: false\n    end",
        "comment": "rubocop:disable Migration/PreventAddingColumns, Migration/PreventIndexCreation -- required for sharding",
        "label": "Property",
        "id": "5011"
    },
    {
        "raw_code": "def prepopulate\n        need_new_connections = nil\n\n        synchronize do\n          return if self.discarded?\n\n          # We don't want to start prepopulating until we know the pool is wanted,\n          # so we can avoid maintaining full pools in one-off scripts etc.\n          return unless @activated\n\n          need_new_connections = @connections.size < @min_connections\n        end",
        "comment": "Ensure that the pool contains at least the configured minimum number of connections.",
        "label": "Property",
        "id": "13031"
    },
    {
        "raw_code": "def emails\n        public_instance_methods(false).map(&:to_s).sort\n      end",
        "comment": "Returns all of the available email previews.",
        "label": "Property",
        "id": "11157"
    },
    {
        "raw_code": "def reportable_changes\n    reportable_changes_store.clone\n  end",
        "comment": "Returns a hash of attributes that were changed between when the object was initially loaded from persistence (or newly created) and its most recent save. This is in constrast to ActiveModel::Dirty#previous_changes which resets the change state after every save.  person = Person.find_by_name(\"bob\") person.name # => \"bob\"  person.name = \"robert\" person.save person.previous_changes   # => {\"name\" => [\"bob\", \"robert\"]} person.reportable_changes # => {\"name\" => [\"bob\", \"robert\"]}  person.title = \"mr\" person.save person.previous_changes   # => {\"title\" => [nil, \"mr\"]} person.reportable_changes # => {\"name\" => [\"bob\", \"robert\"], \"title\" => [nil, \"mr\"]}  person.name = \"rob\" person.save person.previous_changes   # => {\"name\" => [\"robert\", \"rob\"]} person.reportable_changes # => {\"name\" => [\"bob\", \"rob\"], \"title\" => [nil, \"mr\"]}",
        "label": "Property",
        "id": "7345"
    },
    {
        "raw_code": "def admin_create_params\n      [\n        :access_level,\n        :admin,\n        :avatar,\n        :bio,\n        :bot_namespace,\n        :can_create_group,\n        :color_mode_id,\n        :color_scheme_id,\n        :discord,\n        :email,\n        :external,\n        :force_random_password,\n        :hide_no_password,\n        :hide_no_ssh_key,\n        :linkedin,\n        :location,\n        :name,\n        :note,\n        :user_detail_organization,\n        :password,\n        :password_automatically_set,\n        :password_expires_at,\n        :private_profile,\n        :projects_limit,\n        :public_email,\n        :remember_me,\n        :skip_confirmation,\n        :theme_id,\n        :twitter,\n        :user_type,\n        :username,\n        :view_diffs_file_by_file,\n        :website_url,\n        :github\n      ]\n    end",
        "comment": "Allowed params for creating a user (admins only)",
        "label": "Property",
        "id": "5999"
    },
    {
        "raw_code": "def build_from_hash(attributes)\n      return nil unless attributes.is_a?(Hash)\n      attributes = attributes.transform_keys(&:to_sym)\n      self.class.openapi_types.each_pair do |key, type|\n        if attributes[self.class.attribute_map[key]].nil? && self.class.openapi_nullable.include?(key)\n          self.send(\"#{key}=\", nil)\n        elsif type =~ /\\AArray<(.*)>/i\n          # check to ensure the input is an array given that the attribute\n          # is documented as an array but the input is not\n          if attributes[self.class.attribute_map[key]].is_a?(Array)\n            self.send(\"#{key}=\", attributes[self.class.attribute_map[key]].map { |v| _deserialize($1, v) })\n          end",
        "comment": "Builds the object from hash @param [Hash] attributes Model attributes in the form of hash @return [Object] Returns the model itself",
        "label": "Property",
        "id": "908"
    },
    {
        "raw_code": "def formatted_source_branch\n          if cross_project? && source_repository_owner\n            \"github/fork/#{source_repository_owner}/#{source_branch}\"\n          elsif source_branch == target_branch\n            # Sometimes the source and target branch are the same, but GitLab\n            # doesn't support this. This can happen when both the user and\n            # source repository have been deleted, and the PR was submitted from\n            # the fork's master branch.\n            \"#{source_branch}-#{iid}\"\n          else\n            source_branch\n          end",
        "comment": "Returns a formatted source branch.  For cross-project pull requests the branch name will be in the format `github/fork/owner-name/branch-name`.",
        "label": "Property",
        "id": "2264"
    },
    {
        "raw_code": "def _RawNoteBlock\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _StartList()\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "RawNoteBlock = @StartList:a (!@BlankLine !RawNoteReference OptionallyIndentedLine:l { a << l })+ < @BlankLine* > { a << text } { a }",
        "label": "Property",
        "id": "15826"
    },
    {
        "raw_code": "def merge!(headers_or_env)\n        headers_or_env.each do |key, value|\n          @req.set_header env_name(key), value\n        end",
        "comment": "Adds the contents of `headers_or_env` to original instance entries; duplicate keys are overwritten with the values from `headers_or_env`.",
        "label": "Property",
        "id": "11430"
    },
    {
        "raw_code": "def show_medium_info(disk_type, disk_uuid_or_file)\n          disk = {}\n          execute('showmediuminfo', disk_type, disk_uuid_or_file, retryable: true).split(\"\\n\").each do |line|\n            parts = line.partition(\":\")\n            key = parts.first.strip\n            value = parts.last.strip\n            disk[key] = value\n\n            if key == \"Location\"\n              disk[\"Disk Name\"] = File.basename(value, \".*\")\n            end",
        "comment": "Returns information for a given disk  @param [String] disk_type - can be \"disk\", \"dvd\", or \"floppy\" @param [String] disk_uuid_or_file @return [Hash] disk",
        "label": "Property",
        "id": "9614"
    },
    {
        "raw_code": "def self.help_url\n        ::Gitlab::Routing.url_helpers.help_page_url('user/project/web_ide/_index.md', anchor: 'extension-marketplace')\n      end",
        "comment": "rubocop:enable Lint/UnusedMethodArgument Returns help url for Web IDE extensions marketplace  @return [String]",
        "label": "Property",
        "id": "3563"
    },
    {
        "raw_code": "def send_early_hints(links)\n      env[\"rack.early_hints\"]&.call(links)\n    end",
        "comment": "Early Hints is an HTTP/2 status code that indicates hints to help a client start making preparations for processing the final response.  If the env contains `rack.early_hints` then the server accepts HTTP2 push for link headers.  The `send_early_hints` method accepts a hash of links as follows:  send_early_hints(\"link\" => \"</style.css>; rel=preload; as=style,</script.js>; rel=preload\")  If you are using {javascript_include_tag}[rdoc-ref:ActionView::Helpers::AssetTagHelper#javascript_include_tag] or {stylesheet_link_tag}[rdoc-ref:ActionView::Helpers::AssetTagHelper#stylesheet_link_tag] the Early Hints headers are included by default if supported.",
        "label": "Property",
        "id": "11454"
    },
    {
        "raw_code": "def to_body\n      to_hash\n    end",
        "comment": "to_body is an alias to to_hash (backward compatibility) @return [Hash] Returns the object in the form of hash",
        "label": "Property",
        "id": "963"
    },
    {
        "raw_code": "def scheduled_output\n          {\n            response_type: :ephemeral,\n            text: \"Your ChatOps job #{build_ref} has been created!\"\n          }\n        end",
        "comment": "Returns the output to send back after a command has been scheduled.",
        "label": "Property",
        "id": "2449"
    },
    {
        "raw_code": "def route_uri_pattern\n      unless pattern = get_header(\"action_dispatch.route_uri_pattern\")\n        route = get_header(\"action_dispatch.route\")\n        return if route.nil?\n        pattern = route.path.spec.to_s\n        set_header(\"action_dispatch.route_uri_pattern\", pattern)\n      end",
        "comment": "Returns the URI pattern of the matched route for the request, using the same format as `bin/rails routes`:  request.route_uri_pattern # => \"/:controller(/:action(/:id))(.:format)\"",
        "label": "Property",
        "id": "11449"
    },
    {
        "raw_code": "def wrap(txt, line_len = 76)\n    res = []\n    sp = 0\n    ep = txt.length\n\n    while sp < ep\n      # scan back for a space\n      p = sp + line_len - 1\n      if p >= ep\n        p = ep\n      else\n        while p > sp and txt[p] != ?\\s\n          p -= 1\n        end",
        "comment": " Wraps +txt+ to +line_len+",
        "label": "Property",
        "id": "15568"
    },
    {
        "raw_code": "def _implied_layout_name\n          controller_path\n        end",
        "comment": "If no layout is supplied, look for a template named the return value of this method.  ==== Returns * <tt>String</tt> - A template name",
        "label": "Property",
        "id": "11727"
    },
    {
        "raw_code": "def fog_public\n      nil\n    end",
        "comment": "Set ACL of uploaded objects to not-public (fog-aws)[1] or no ACL at all (fog-google).  Value is ignored by fog-aliyun [1]: https://github.com/fog/fog-aws/blob/daa50bb3717a462baf4d04d0e0cbfc18baacb541/lib/fog/aws/models/storage/file.rb#L152-L159",
        "label": "Property",
        "id": "8047"
    },
    {
        "raw_code": "def invalid_target?\n        return unless @target_version\n        return if @target_version == 0\n\n        !target\n      end",
        "comment": "Return true if a valid version is not provided.",
        "label": "Property",
        "id": "3541"
    },
    {
        "raw_code": "def calculate_from_blob_line!\n        return unless unfold_required?\n\n        from = comment_position - UNFOLD_CONTEXT_SIZE\n\n        prev_line_number =\n          if bottom?\n            last_line.old_pos\n          else\n            # There's no line before the match if it's in the top-most\n            # position.\n            line_before_unfold_position&.old_pos || 0\n          end",
        "comment": "Returns the first line position that should be extracted from `blob_lines`.",
        "label": "Property",
        "id": "2705"
    },
    {
        "raw_code": "def markdown?\n      @current_engine == :markdown\n    end",
        "comment": "@return [Boolean] Returns true if current engine is `:markdown`.",
        "label": "Property",
        "id": "8676"
    },
    {
        "raw_code": "def category_choices(groups)\n        options = []\n\n        # List likeliest categories for group as the first options\n        Array(groups).compact.uniq.flat_map do |group|\n          divider = select_option_divider(\"Categories for #{group}\")\n          categories = (find_categories(group) || []) & KNOWN_CATEGORIES\n\n          options.push(divider, *categories.sort) if categories.any?\n        end",
        "comment": "Returns the list of product category options for use in select menu. Prioritizes categories from related groups.",
        "label": "Property",
        "id": "5340"
    },
    {
        "raw_code": "def self.openapi_nullable\n      Set.new([\n      ])\n    end",
        "comment": "List of attributes with nullable: true",
        "label": "Property",
        "id": "847"
    },
    {
        "raw_code": "def _to_hash(value)\n      if value.is_a?(Array)\n        value.compact.map { |v| _to_hash(v) }\n      elsif value.is_a?(Hash)\n        {}.tap do |hash|\n          value.each { |k, v| hash[k] = _to_hash(v) }\n        end",
        "comment": "Outputs non-array value in the form of hash For object, use to_hash. Otherwise, just return the value @param [Object] value Any valid value @return [Hash] Returns the value in the form of hash",
        "label": "Property",
        "id": "948"
    },
    {
        "raw_code": "def tags(limit: 100)\n    strong_memoize_with(:tag, limit) do\n      project.repository.refs_by_oid(oid: sha, limit: limit, ref_patterns: [Gitlab::Git::TAG_REF_PREFIX])\n    end",
        "comment": "default tag limit is 100, 0 means no limit when refs_by_oid is passed an SHA, returns refs for that commit",
        "label": "Property",
        "id": "6684"
    },
    {
        "raw_code": "def labels_str(label_refs, prefix: '')\n    existing_refs = label_refs.select(&:present?)\n    refs_str = existing_refs.empty? ? nil : existing_refs.join(' ')\n\n    deleted = label_refs.count - existing_refs.count\n    deleted_str = deleted == 0 ? nil : \"#{deleted} deleted\"\n\n    return unless refs_str || deleted_str\n\n    label_list_str = [refs_str, deleted_str].compact.join(' + ')\n    suffix = ' label'.pluralize(deleted > 0 ? deleted : existing_refs.count)\n\n    \"#{prefix} #{label_list_str} #{suffix.squish}\"\n  end",
        "comment": "returns string containing added/removed labels including count of deleted labels:  added ~1 ~2 + 1 deleted label added 3 deleted labels added ~1 ~2 labels",
        "label": "Property",
        "id": "6798"
    },
    {
        "raw_code": "def group_pages(pages, templates: false)\n      # Build a hash to map paths to created WikiDirectory objects,\n      # and recursively create them for each level of the path.\n      # For the toplevel directory we use '' as path, as that's what WikiPage#directory returns.\n      directories = Hash.new do |_, path|\n        directories[path] = new(path).tap do |directory|\n          if path.present?\n            parent = File.dirname(path)\n            parent = '' if parent == '.'\n            directories[parent].entries << directory\n            directories[parent].entries.delete_if do |item|\n              item.is_a?(WikiPage) && item.slug.casecmp?(directory.slug)\n            end",
        "comment": "Groups a list of wiki pages into a nested collection of WikiPage and WikiDirectory objects, preserving the order of the passed pages.  Returns an array with all entries for the toplevel directory.  @param [Array<WikiPage>] pages @return [Array<WikiPage, WikiDirectory>] ",
        "label": "Property",
        "id": "6887"
    },
    {
        "raw_code": "def perform(lease_key, project_id, statistics = [])\n    return unless Gitlab::ExclusiveLease\n      .new(lease_key, timeout: ProjectCacheWorker::LEASE_TIMEOUT)\n      .try_obtain\n\n    project = Project.find_by_id(project_id)\n\n    Projects::UpdateStatisticsService.new(project, nil, statistics: statistics).execute\n  end",
        "comment": "lease_key     - The exclusive lease key to take project_id    - The ID of the project for which to flush the cache. statistics    - An Array containing columns from ProjectStatistics to refresh, if empty all columns will be refreshed",
        "label": "Property",
        "id": "6295"
    },
    {
        "raw_code": "def parallel_jobs\n        api_get(\"projects/#{project_id}/pipelines/#{pipeline_id}/jobs?per_page=100\")\n          .select { |job| job[:stage] == stage_name && job[:name].match?(PARALLEL_JOB_NAME_PATTERN) }\n          .map { |job| job[:name].gsub(%r{ \\d+/\\d+}, \"\") }\n          .uniq\n      end",
        "comment": "Parallel job list  @return [Array<String>]",
        "label": "Property",
        "id": "4525"
    },
    {
        "raw_code": "def failed_step_up_auth_flows(session, scope: STEP_UP_AUTH_SCOPE_ADMIN_MODE)\n            (step_up_auth_flows(session) || []).select do |flow|\n              flow.enabled_by_config? &&\n                flow.failed? &&\n                flow.scope.to_s == scope.to_s\n            end",
        "comment": "Returns step-up authentication flows that have failed  @param session [Hash] the session hash containing authentication state @param scope [Symbol] the scope to check (default: :admin_mode) @return [Array<StepUpAuthenticationFlow>] list of failed authentication flows",
        "label": "Property",
        "id": "2372"
    },
    {
        "raw_code": "def emoji_unicode_element_unicode_filter(text)\n        Gitlab::Utils::Gsub\n          .gsub_with_limit(text, emoji_unicode_pattern, limit: Banzai::Filter::FILTER_ITEM_LIMIT) do |match_data|\n          if ignore_emoji?(match_data[0])\n            match_data[0]\n          else\n            emoji = TanukiEmoji.find_by_codepoints(match_data[0])\n\n            process_emoji_tag(emoji, match_data[0])\n          end",
        "comment": "Replace unicode emoji with corresponding gl-emoji unicode.  text - String text to replace unicode emoji in.  Returns a String with unicode emoji replaced with gl-emoji unicode.",
        "label": "Property",
        "id": "3446"
    },
    {
        "raw_code": "def dst?\n      period.dst?\n    end",
        "comment": "Returns true if the current time is within Daylight Savings \\Time for the specified time zone.  Time.zone = 'Eastern Time (US & Canada)'    # => 'Eastern Time (US & Canada)' Time.zone.parse(\"2012-5-30\").dst?           # => true Time.zone.parse(\"2012-11-30\").dst?          # => false",
        "label": "Property",
        "id": "13961"
    },
    {
        "raw_code": "def resolve(lookahead:, first: nil, last: nil, after: nil, before: nil)\n      default_value = default_value_for(first: first, last: last, after: after, before: before)\n      BatchLoader::GraphQL.for(package.id)\n                          .batch(default_value: default_value) do |package_ids, loader|\n        build_infos = ::Packages::BuildInfosFinder.new(\n          package_ids,\n          first: first,\n          last: last,\n          after: decode_cursor(after),\n          before: decode_cursor(before),\n          max_page_size: MAX_PAGE_SIZE,\n          support_next_page: lookahead.selects?(:page_info)\n        ).execute\n\n        build_infos.each do |build_info|\n          loader.call(build_info.package_id) do |connection|\n            connection.items << lazy_load_pipeline(build_info.pipeline_id)\n            connection\n          end",
        "comment": "This returns a promise for a connection of promises for pipelines: Lazy[Connection[Lazy[Pipeline]]] structure",
        "label": "Property",
        "id": "6176"
    },
    {
        "raw_code": "def signature_hexes\n            return [] unless @vulnerability_finding_signatures_enabled && signatures.present?\n\n            signatures.sort_by { |sig| -sig.priority }.map(&:signature_hex)\n          end",
        "comment": "Returns the signature hexes in reverse priority order",
        "label": "Property",
        "id": "2548"
    },
    {
        "raw_code": "def type\n      end",
        "comment": "Returns the unique type name as a Symbol. Subclasses should override this method.",
        "label": "Property",
        "id": "12293"
    },
    {
        "raw_code": "def ordered_railties # :nodoc:\n      @ordered_railties ||= begin\n        order = config.railties_order.map do |railtie|\n          if railtie == :main_app\n            self\n          elsif railtie.respond_to?(:instance)\n            railtie.instance\n          else\n            railtie\n          end",
        "comment": "Returns the ordered railties for this application considering railties_order.",
        "label": "Property",
        "id": "14651"
    },
    {
        "raw_code": "def bar(varOne, varTwo)\n            varOne + varTwo\n          end",
        "comment": "frozen_string_literal: true",
        "label": "Property",
        "id": "10986"
    },
    {
        "raw_code": "def label(object_name, method, content_or_options = nil, options = nil, &block)\n        Tags::Label.new(object_name, method, self, content_or_options, options).render(&block)\n      end",
        "comment": "Returns a label tag tailored for labelling an input field for a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). The text of label will default to the attribute name unless a translation is found in the current I18n locale (through <tt>helpers.label.<modelname>.<attribute></tt>) or you specify it explicitly. Additional options on the label tag can be passed as a hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example shown, except for the <tt>:value</tt> option, which is designed to target labels for radio_button tags (where the value is used in the ID of the input tag).  ==== Examples label(:article, :title) # => <label for=\"article_title\">Title</label>  You can localize your labels based on model and attribute names. For example you can define the following in your locale (e.g. en.yml)  helpers: label: article: body: \"Write your entire text here\"  Which then will result in  label(:article, :body) # => <label for=\"article_body\">Write your entire text here</label>  Localization can also be based purely on the translation of the attribute-name (if you are using ActiveRecord):  activerecord: attributes: article: cost: \"Total cost\"  <code></code>  label(:article, :cost) # => <label for=\"article_cost\">Total cost</label>  label(:article, :title, \"A short title\") # => <label for=\"article_title\">A short title</label>  label(:article, :title, \"A short title\", class: \"title_label\") # => <label for=\"article_title\" class=\"title_label\">A short title</label>  label(:article, :privacy, \"Public Article\", value: \"public\") # => <label for=\"article_privacy_public\">Public Article</label>  label(:article, :cost) do |translation| content_tag(:span, translation, class: \"cost_label\") end # => <label for=\"article_cost\"><span class=\"cost_label\">Total cost</span></label>  label(:article, :cost) do |builder| content_tag(:span, builder.translation, class: \"cost_label\") end # => <label for=\"article_cost\"><span class=\"cost_label\">Total cost</span></label>  label(:article, :terms) do raw('Accept <a href=\"/terms\">Terms</a>.') end # => <label for=\"article_terms\">Accept <a href=\"/terms\">Terms</a>.</label>",
        "label": "Property",
        "id": "11866"
    },
    {
        "raw_code": "def gitaly_ref_exists?(ref_name)\n        gitaly_ref_client.ref_exists?(ref_name)\n      end",
        "comment": "Returns true if the given ref name exists  Ref names must start with `refs/`.",
        "label": "Property",
        "id": "2659"
    },
    {
        "raw_code": "def behavior\n        @behavior ||= [DEFAULT_BEHAVIORS[:stderr]]\n      end",
        "comment": "Returns the current behavior or if one isn't set, defaults to +:stderr+.",
        "label": "Property",
        "id": "14424"
    },
    {
        "raw_code": "def indentation # :doc:\n          \"  \" * @indentation\n        end",
        "comment": "Returns a string corresponding to the current indentation level (i.e. 2 * <code>@indentation</code> spaces). See also #with_indentation, which can be used to manage the indentation level.",
        "label": "Property",
        "id": "14745"
    },
    {
        "raw_code": "def self.server_url(config_server_url=nil)\n    result = ENV[\"VAGRANT_SERVER_URL\"]\n    result = config_server_url if result == \"\" or result == nil\n    result || DEFAULT_SERVER_URL\n  end",
        "comment": "Returns the URL prefix to the server.  @return [String]",
        "label": "Property",
        "id": "8824"
    },
    {
        "raw_code": "def types(select_stmt)\n              # Forward through any errors when the column refers to a part of the SQL query that is known to include\n              # errors. For example, the column may refer to a column from a CTE that was invalid.\n              return Set.new([Type::INVALID]) if References.errors?(select_stmt.all_references)\n\n              types = Set.new\n\n              # Resolve the type of reference for each target in the select statement.\n              target_list = select_stmt.node.target_list\n              targets = target_list.map(&:res_target)\n              targets.each do |target|\n                target_type = get_target_type(target, select_stmt)\n\n                # A NULL target is of the form:\n                # SELECT NULL::namespaces FROM namespaces\n                types += if Targets.null?(target)\n                           # Maintain any errors but otherwise ignore this target.\n                           target_type & [Type::INVALID]\n                         else\n                           target_type\n                         end",
        "comment": "Determine the type of each column in the select statement. Returns a Set object containing a Types enum. When an error is found parsing will return immediately.",
        "label": "Property",
        "id": "3190"
    },
    {
        "raw_code": "def to_time\n    preserve_timezone ? self : getlocal\n  end",
        "comment": "Either return +self+ or the time in the local system timezone depending on the setting of +ActiveSupport.to_time_preserves_timezone+.",
        "label": "Property",
        "id": "14415"
    },
    {
        "raw_code": "def in_weeks\n      in_seconds / SECONDS_PER_WEEK.to_f\n    end",
        "comment": "Returns the amount of weeks a duration covers as a float  2.months.in_weeks # => 8.696",
        "label": "Property",
        "id": "13823"
    },
    {
        "raw_code": "def parse_url(url)\n    case url\n    when /^rdoc-label:([^:]*)(?::(.*))?/ then\n      scheme = 'link'\n      path   = \"##{$1}\"\n      id     = \" id=\\\"#{$2}\\\"\" if $2\n    when /([A-Za-z]+):(.*)/ then\n      scheme = $1.downcase\n      path   = $2\n    when /^#/ then\n    else\n      scheme = 'http'\n      path   = url\n      url    = url\n    end",
        "comment": " Extracts and a scheme, url and an anchor id from +url+ and returns them.",
        "label": "Property",
        "id": "16285"
    },
    {
        "raw_code": "def diff_from_parent(options = {})\n        @repository.gitaly_commit_client.diff_from_parent(self, options)\n      end",
        "comment": "Returns a diff object for the changes from this commit's first parent. If there is no parent, then the diff is between this commit and an empty repo. See Repository#diff for keys allowed in the +options+ hash.",
        "label": "Property",
        "id": "2596"
    },
    {
        "raw_code": "def sti_name\n        store_full_sti_class && store_full_class_name ? name : name.demodulize\n      end",
        "comment": "Returns the value to be stored in the inheritance column for STI.",
        "label": "Property",
        "id": "12471"
    },
    {
        "raw_code": "def find_beginning_of_week!(week_start)\n      raise ArgumentError, \"Invalid beginning of week: #{week_start}\" unless ::Date::DAYS_INTO_WEEK.key?(week_start)\n      week_start\n    end",
        "comment": "Returns week start day symbol (e.g. +:monday+), or raises an +ArgumentError+ for invalid day symbol.",
        "label": "Property",
        "id": "14114"
    },
    {
        "raw_code": "def seconds_until_end_of_day\n    end_of_day.to_i - to_i\n  end",
        "comment": "Returns the number of seconds until 23:59:59.  DateTime.new(2012, 8, 29,  0,  0,  0).seconds_until_end_of_day # => 86399 DateTime.new(2012, 8, 29, 12, 34, 56).seconds_until_end_of_day # => 41103 DateTime.new(2012, 8, 29, 23, 59, 59).seconds_until_end_of_day # => 0",
        "label": "Property",
        "id": "14183"
    },
    {
        "raw_code": "def self.open!(file, *args, &block)\n    dir = dirname(file)\n    FileUtils.mkdir_p(dir) unless directory?(dir)\n    open(file, *args, &block)\n  end",
        "comment": "@group Reading Files Forces opening a file (for writing) by first creating the file's directory @param [String] file the filename to open @since 0.5.2",
        "label": "Property",
        "id": "487"
    },
    {
        "raw_code": "def condition?\n          false\n        end",
        "comment": "@return [Boolean] whether the node is a if/elsif/else condition",
        "label": "Property",
        "id": "317"
    },
    {
        "raw_code": "def inspect\n        # We check defined?(@attributes) not to issue warnings if the object is\n        # allocated but not initialized.\n        inspection = if defined?(@attributes) && @attributes\n                       attribute_names.filter_map do |name|\n                         \"#{name}: #{_read_attribute(name)}\" if @attributes.key?(name)\n                       end.join(\", \")\n                     else\n                       \"not initialized\"\n                     end",
        "comment": "Returns the contents of the record as a nicely formatted string.",
        "label": "Property",
        "id": "9976"
    },
    {
        "raw_code": "def gitlab_api_url\n    ENV.fetch('CI_API_V4_URL', 'https://gitlab.com/api/v4')\n  end",
        "comment": "GitLab API URL",
        "label": "Property",
        "id": "5288"
    },
    {
        "raw_code": "def route_event\n      return SlackEvents::UrlVerificationService.new(params).execute if route_in_request?\n\n      SlackEventWorker.perform_async(slack_event: slack_event, params: params)\n\n      {}\n    end",
        "comment": "Returns a payload for the service response.",
        "label": "Property",
        "id": "5967"
    },
    {
        "raw_code": "def class\n        target.class\n      end",
        "comment": "Returns the class of the new constant.  PLANETS_POST_2006 = %w(mercury venus earth mars jupiter saturn uranus neptune) PLANETS = ActiveSupport::Deprecation::DeprecatedConstantProxy.new('PLANETS', 'PLANETS_POST_2006') PLANETS.class # => Array",
        "label": "Property",
        "id": "14442"
    },
    {
        "raw_code": "def allowed_arguments?(arguments)\n          return false if arguments.empty?\n\n          arguments.each_child_node(:restarg).any? &&\n            arguments.each_child_node(:kwarg, :kwoptarg, :kwrestarg).none?\n        end",
        "comment": "`ruby2_keywords` is only allowed if there's a `restarg` and no keyword arguments",
        "label": "Property",
        "id": "10638"
    },
    {
        "raw_code": "def normalized_version_name(name)\n        name = name.capitalize.delete_prefix('V')\n\n        first_part, *other_parts = name.split(/([-,+])/)\n        dot_count = first_part.count('.')\n\n        return name unless dot_count != 2 && /^[\\d.]+$/.match?(first_part)\n\n        if dot_count < 2\n          add_zeroes = '.0' * (2 - dot_count)\n\n          [first_part, add_zeroes, *other_parts].join\n        else\n          # Assuming the format is 1.2.3.4, we only want to keep the first 3 digits.\n          truncated_first_part = first_part.split(/([.])/)[0..4]\n\n          [truncated_first_part, *other_parts].join\n        end",
        "comment": "Removes `v` prefix and converts partial or extended semver numbers into a normalized format. Examples:  1         => 1.0.0 v1.2      => 1.2.0 1.2-alpha => 1.2.0-alpha 1.0+123   => 1.0.0+123 1.2.3.4   => 1.2.3 ",
        "label": "Property",
        "id": "3287"
    },
    {
        "raw_code": "def total_concurrency\n      sum { |x| x[\"concurrency\"].to_i }\n    end",
        "comment": "Total number of threads available to execute jobs. For Sidekiq Enterprise customers this number (in production) must be less than or equal to your licensed concurrency. @return [Integer] the sum of process concurrency",
        "label": "Property",
        "id": "5146"
    },
    {
        "raw_code": "def read_attribute(attr_name, &block)\n        name = attr_name.to_s\n        name = self.class.attribute_aliases[name] || name\n\n        @attributes.fetch_value(name, &block)\n      end",
        "comment": "Returns the value of the attribute identified by +attr_name+ after it has been type cast. For example, a date attribute will cast \"2004-12-12\" to <tt>Date.new(2004, 12, 12)</tt>. (For information about specific type casting behavior, see the types under ActiveModel::Type.)",
        "label": "Property",
        "id": "12862"
    },
    {
        "raw_code": "def _HtmlBlockCloseFieldset\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseFieldset = \"<\" Spnl \"/\" (\"fieldset\" | \"FIELDSET\") Spnl \">\"",
        "label": "Property",
        "id": "15645"
    },
    {
        "raw_code": "def target_branch\n        target_repository.root_ref || Gitlab::DefaultBranch.value(object: target_project)\n      end",
        "comment": "Designs are being copied over to a target repository. Target repository's default branch can be different from source repository. E.g. we have some old projects where `master` is still the default branch, whereas newer projects have `main` as repository default branch.  So we need to make sure we lookup the correct merge branch based on target repository",
        "label": "Property",
        "id": "6082"
    },
    {
        "raw_code": "def error?\n      @broadcasts.any? { |logger| logger.error? }\n    end",
        "comment": "True if the log level allows entries with severity +Logger::ERROR+ to be written to at least one broadcast. False otherwise.",
        "label": "Property",
        "id": "13725"
    },
    {
        "raw_code": "def rate_limit\n        rate_limiter.limit\n      end",
        "comment": "@return [Integer] The rate limit for the WebHook. `0` for no limit.",
        "label": "Property",
        "id": "7496"
    },
    {
        "raw_code": "def param_encoding(action, param, encoding)\n        @_parameter_encodings[action.to_s][param.to_s] = encoding\n      end",
        "comment": "Specify the encoding for a parameter on an action. If not specified the default is UTF-8.  You can specify a binary (ASCII_8BIT) parameter with:  class RepositoryController < ActionController::Base # This specifies that file_path is not UTF-8 and is instead ASCII_8BIT param_encoding :show, :file_path, Encoding::ASCII_8BIT  def show @repo = Repository.find_by_filesystem_path params[:file_path]  # params[:repo_name] remains UTF-8 encoded @repo_name = params[:repo_name] end  def index @repositories = Repository.all end end  The file_path parameter on the show action would be encoded as ASCII-8BIT, but all other arguments will remain UTF-8 encoded. This is useful in the case where an application must handle data but encoding of the data is unknown, like file system data.",
        "label": "Property",
        "id": "11304"
    },
    {
        "raw_code": "def self.handle_interruptions_exhausted(msg); end\n        end",
        "comment": "mock method to test interruptions exhausted behavior",
        "label": "Property",
        "id": "5043"
    },
    {
        "raw_code": "def sha\n        if unknown_refs.any?\n          raise ReferenceNotFoundError, \"Can't find merge base for unknown refs: #{unknown_refs.inspect}\"\n        end",
        "comment": "Returns the SHA of the first common ancestor",
        "label": "Property",
        "id": "2573"
    },
    {
        "raw_code": "def columns; @columns_hash.values; end\n\n      # Returns a ColumnDefinition for the column with name +name+.\n      def [](name)\n        @columns_hash[name.to_s]\n      end\n\n      # Instantiates a new column for the table.\n      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n      # for available options.\n      #\n      # Additional options are:\n      # * <tt>:index</tt> -\n      #   Create an index for the column. Can be either <tt>true</tt> or an options hash.\n      #\n      # This method returns <tt>self</tt>.\n      #\n      # == Examples\n      #\n      #  # Assuming `td` is an instance of TableDefinition\n      #  td.column(:granted, :boolean, index: true)\n      #\n      # == Short-hand examples\n      #\n      # Instead of calling #column directly, you can also work with the short-hand definitions for the default types.\n      # They use the type as the method name instead of as a parameter and allow for multiple columns to be defined\n      # in a single statement.\n      #\n      # What can be written like this with the regular calls to column:\n      #\n      #   create_table :products do |t|\n      #     t.column :shop_id,     :integer\n      #     t.column :creator_id,  :integer\n      #     t.column :item_number, :string\n      #     t.column :name,        :string, default: \"Untitled\"\n      #     t.column :value,       :string, default: \"Untitled\"\n      #     t.column :created_at,  :datetime\n      #     t.column :updated_at,  :datetime\n      #   end\n      #   add_index :products, :item_number\n      #\n      # can also be written as follows using the short-hand:\n      #\n      #   create_table :products do |t|\n      #     t.integer :shop_id, :creator_id\n      #     t.string  :item_number, index: true\n      #     t.string  :name, :value, default: \"Untitled\"\n      #     t.timestamps null: false\n      #   end\n      #\n      # There's a short-hand method for each of the type values declared at the top. And then there's\n      # TableDefinition#timestamps that'll add +created_at+ and +updated_at+ as datetimes.\n      #\n      # TableDefinition#references will add an appropriately-named _id column, plus a corresponding _type\n      # column if the <tt>:polymorphic</tt> option is supplied. If <tt>:polymorphic</tt> is a hash of\n      # options, these will be used when creating the <tt>_type</tt> column. The <tt>:index</tt> option\n      # will also create an index, similar to calling {add_index}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_index].\n      # So what can be written like this:\n      #\n      #   create_table :taggings do |t|\n      #     t.integer :tag_id, :tagger_id, :taggable_id\n      #     t.string  :tagger_type\n      #     t.string  :taggable_type, default: 'Photo'\n      #   end\n      #   add_index :taggings, :tag_id, name: 'index_taggings_on_tag_id'\n      #   add_index :taggings, [:tagger_id, :tagger_type]\n      #\n      # Can also be written as follows using references:\n      #\n      #   create_table :taggings do |t|\n      #     t.references :tag, index: { name: 'index_taggings_on_tag_id' }\n      #     t.references :tagger, polymorphic: true\n      #     t.references :taggable, polymorphic: { default: 'Photo' }, index: false\n      #   end\n      def column(name, type, index: nil, **options)\n        name = name.to_s\n        type = type.to_sym if type\n\n        raise_on_duplicate_column(name)\n        @columns_hash[name] = new_column_definition(name, type, **options)\n\n        if index\n          index_options = index.is_a?(Hash) ? index : {}\n          index(name, **index_options)\n        end\n\n        self\n      end",
        "comment": "Returns an array of ColumnDefinition objects for the columns of the table.",
        "label": "Property",
        "id": "13099"
    },
    {
        "raw_code": "def attached?\n      attachment.present?\n    end",
        "comment": "Returns +true+ if an attachment has been made.  class User < ApplicationRecord has_one_attached :avatar end  User.new.avatar.attached? # => false",
        "label": "Property",
        "id": "13691"
    },
    {
        "raw_code": "def replace_tag_manifests(dummy_manifest)\n          deleted_tags = @tag_names.map do |name|\n            digest = @container_repository.client.put_tag(@container_repository.path, name, dummy_manifest)\n            next unless digest\n\n            [name, digest]\n          end.compact.to_h\n\n          # make sure the digests are the same (it should always be)\n          digests = deleted_tags.values.uniq\n\n          # rubocop: disable CodeReuse/ActiveRecord\n          Gitlab::ErrorTracking.track_and_raise_for_dev_exception(ArgumentError.new('multiple tag digests')) if digests.many?\n\n          deleted_tags\n        end",
        "comment": "update the manifests of the tags with the new dummy image",
        "label": "Property",
        "id": "5949"
    },
    {
        "raw_code": "def has_plugin?(name)\n        @data[\"installed\"].key?(name)\n      end",
        "comment": "Returns true/false if the plugin is present in this state file.  @return [Boolean]",
        "label": "Property",
        "id": "8966"
    },
    {
        "raw_code": "def parameter_filter\n        @parameter_filter ||= if has_header?(\"action_dispatch.parameter_filter\")\n          parameter_filter_for get_header(\"action_dispatch.parameter_filter\")\n        else\n          NULL_PARAM_FILTER\n        end",
        "comment": "Returns the `ActiveSupport::ParameterFilter` object used to filter in this request.",
        "label": "Property",
        "id": "11424"
    },
    {
        "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
        "comment": "Returns the currently loaded version of Action Text as a `Gem::Version`.",
        "label": "Property",
        "id": "11699"
    },
    {
        "raw_code": "def end_of_day\n    change(\n      hour: 23,\n      min: 59,\n      sec: 59,\n      usec: Rational(999999999, 1000)\n    )\n  end",
        "comment": "Returns a new Time representing the end of the day, 23:59:59.999999",
        "label": "Property",
        "id": "14401"
    },
    {
        "raw_code": "def content_columns\n        @content_columns ||= columns.reject do |c|\n          c.name == primary_key ||\n          c.name == inheritance_column ||\n          c.name.end_with?(\"_id\", \"_count\")\n        end.freeze\n      end",
        "comment": "Returns an array of column objects where the primary id, all columns ending in \"_id\" or \"_count\", and columns used for single table inheritance have been removed.",
        "label": "Property",
        "id": "12525"
    },
    {
        "raw_code": "def task_status_short\n    task_status(short: true)\n  end",
        "comment": "Return a short string that describes the current state of this Taskable's task list items -- for small screens",
        "label": "Property",
        "id": "7358"
    },
    {
        "raw_code": "def response=(response)\n      set_response!(response)\n\n      # Force `performed?` to return true:\n      @_response_body = true\n    end",
        "comment": "Assign the response and mark it as committed. No further processing will occur.",
        "label": "Property",
        "id": "11229"
    },
    {
        "raw_code": "def cache_key_with_version\n      if version = cache_version\n        \"#{cache_key}-#{version}\"\n      else\n        cache_key\n      end",
        "comment": "Returns a cache key along with the version.",
        "label": "Property",
        "id": "12483"
    },
    {
        "raw_code": "def full_name\n    @full_name ||= \"#{parent_name}#{pretty_name}\"\n  end",
        "comment": " Full method/attribute name including namespace",
        "label": "Property",
        "id": "16826"
    },
    {
        "raw_code": "def inspect\n      \"#<#{self.class}: #{@name} (#{@provider.class})>\"\n    end",
        "comment": "This returns a clean inspect value so that printing the value via a pretty print (`p`) results in a readable value.  @return [String]",
        "label": "Property",
        "id": "8784"
    },
    {
        "raw_code": "def client_secret=(value)\n      reset_agent\n      @client_secret = value\n    end",
        "comment": "Set OAuth app client_secret  @param value [String] 40 character GitHub OAuth app client_secret",
        "label": "Property",
        "id": "14853"
    },
    {
        "raw_code": "def initialize(\n          context:,\n          backup_bucket: nil,\n          wait_for_completion: nil,\n          registry_bucket: nil,\n          service_account_file: nil)\n          @context = context\n          @metadata = build_metadata\n          @workdir = create_temporary_workdir!\n          @archive_directory = context.backup_basedir.join(metadata.backup_id)\n          super(\n            backup_bucket: backup_bucket,\n            wait_for_completion: wait_for_completion,\n            registry_bucket: registry_bucket,\n            service_account_file: service_account_file\n          )\n        end",
        "comment": "@param [Gitlab::Backup::Cli::SourceContext, Context::OmnibusContext] context",
        "label": "Property",
        "id": "1025"
    },
    {
        "raw_code": "def commands\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.components.commands)\n            end",
        "comment": "This returns all the registered commands.  @return [Registry<Symbol, Array<Proc, Hash>>]",
        "label": "Property",
        "id": "9066"
    },
    {
        "raw_code": "def signed_or_encrypted\n        @signed_or_encrypted ||=\n          if request.secret_key_base.present?\n            encrypted\n          else\n            signed\n          end",
        "comment": "Returns the `signed` or `encrypted` jar, preferring `encrypted` if `secret_key_base` is set. Used by ActionDispatch::Session::CookieStore to avoid the need to introduce new cookie stores.",
        "label": "Property",
        "id": "11517"
    },
    {
        "raw_code": "def formatted_offset(colon = true, alternate_utc_string = nil)\n      utc_offset == 0 && alternate_utc_string || self.class.seconds_to_utc_offset(utc_offset, colon)\n    end",
        "comment": "Returns a formatted string of the offset from UTC, or an alternative string if the time zone is already UTC.  zone = ActiveSupport::TimeZone['Central Time (US & Canada)'] zone.formatted_offset        # => \"-06:00\" zone.formatted_offset(false) # => \"-0600\"",
        "label": "Property",
        "id": "14563"
    },
    {
        "raw_code": "def test_checkout_fairness\n        skip_fiber_testing\n\n        @pool.instance_variable_set(:@max_connections, 10)\n        expected = (1..@pool.size).to_a.freeze\n        # check out all connections so our threads start out waiting\n        conns = expected.map { @pool.checkout }\n        mutex = Mutex.new\n        order = []\n        errors = []\n        dispose_held_connections = Concurrent::Event.new\n\n        threads = expected.map do |i|\n          t = new_thread {\n            begin\n              @pool.checkout # never checked back in\n              mutex.synchronize { order << i }\n\n              # if the thread terminates, its connection may be\n              # reclaimed by the pool, so we need to hold on to it\n              # until we're done trickling in connections\n              dispose_held_connections.wait\n            rescue => e\n              mutex.synchronize { errors << e }\n            end",
        "comment": "The connection pool is \"fair\" if threads waiting for connections receive them in the order in which they began waiting.  This ensures that we don't timeout one HTTP request even while well under capacity in a multi-threaded environment such as a Java servlet container.  We don't need strict fairness: if two connections become available at the same time, it's fine if two threads that were waiting acquire the connections out of order.  Thus this test prepares waiting threads and then trickles in available connections slowly, ensuring the wakeup order is correct in this case.",
        "label": "Property",
        "id": "13502"
    },
    {
        "raw_code": "def move_to_cache\n      false\n    end",
        "comment": "override GitlabUploader if set to true it erases the original file when uploading and we copy from the artifacts archive, so artifacts end up without the file",
        "label": "Property",
        "id": "8077"
    },
    {
        "raw_code": "def display_preamble(org, box_name, version, provider_name, options={})\n          @env.ui.warn(I18n.t(\"cloud_command.publish.confirm.warn\"))\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.box\", org: org,\n            box_name: box_name, version: version, provider_name: provider_name))\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.private\")) if options[:private]\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.release\")) if options[:release]\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.architecture\",\n            architecture: options[:architecture]))\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.default_architecture\")) if options[:default_architecture]\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.box_url\",\n            url: options[:url])) if options[:url]\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.box_description\",\n            description: options[:description])) if options[:description]\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.box_short_desc\",\n            short_description: options[:short_description])) if options[:short_description]\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.version_desc\",\n            version_description: options[:version_description])) if options[:version_description]\n          nil\n        end",
        "comment": "Display publishing information to user before starting process  @param [String] org Organization name @param [String] box_name Name of the box to publish @param [String] version Version of the box to publish @param [String] provider_name Name of the provider being published @param [Hash] options @option options [String] :architecture Name of architecture of provider being published# @option options [Boolean] :private Box is private @option options [Boolean] :release Box should be released @option options [String] :url Remote URL for self-hosted boxes @option options [Boolean] :default_architecture Architecture is default for provider name @option options [String] :description Description of the box @option options [String] :short_description Short description of the box @option options [String] :version_description Description of the box version @return [nil]",
        "label": "Property",
        "id": "9765"
    },
    {
        "raw_code": "def third\n      find_nth 2\n    end",
        "comment": "Find the third record. If no order is defined it will order by primary key.  Person.third # returns the third object fetched by SELECT * FROM people Person.offset(3).third # returns the third object from OFFSET 3 (which is OFFSET 5) Person.where([\"user_name = :u\", { u: user_name }]).third",
        "label": "Property",
        "id": "13375"
    },
    {
        "raw_code": "def load(config_directory_path:, feature:)\n        new(config_directory_path: config_directory_path, feature: feature).load\n      end",
        "comment": "@param [String] config_directory_path @param [String] feature",
        "label": "Property",
        "id": "10112"
    },
    {
        "raw_code": "def only(*onlies)\n      relation_with values.slice(*onlies)\n    end",
        "comment": "Keeps only the condition(s) specified in +onlies+ in the query, removing all others.  Post.order('id asc').only(:where)         # keeps only the where condition, removes the order Post.order('id asc').only(:where, :order) # keeps only the where and order conditions",
        "label": "Property",
        "id": "13440"
    },
    {
        "raw_code": "def public_path\n      application && Pathname.new(application.paths[\"public\"].first)\n    end",
        "comment": "Returns a Pathname object of the public folder of the current \\Rails project, otherwise it returns +nil+ if there is no project:  Rails.public_path # => #<Pathname:/Users/someuser/some/path/project/public>",
        "label": "Property",
        "id": "14624"
    },
    {
        "raw_code": "def get_disk(disk_file_path)\n        execute(:get_vhd, DiskFilePath: disk_file_path)\n      end",
        "comment": "@param [String] disk_file_path",
        "label": "Property",
        "id": "9690"
    },
    {
        "raw_code": "def index_commits\n      days = []\n      @map = {}\n      @reserved = {}\n\n      @commits.each_with_index do |c, i|\n        c.time = i\n        days[i] = c.committed_date\n        @map[c.id] = c\n        @reserved[i] = []\n      end",
        "comment": "Method is adding time and space on the list of commits. As well as returns date list correlated with time set on commits.  @return [Array<TimeDate>] list of commit dates correlated with time on commits",
        "label": "Property",
        "id": "7218"
    },
    {
        "raw_code": "def gather_attributes_per_project(nodes, attribute)\n        per_project = Hash.new { |hash, key| hash[key] = Set.new }\n\n        nodes.each do |node|\n          project_id = node.attr('data-project').to_i\n          id = node.attr(attribute)\n\n          per_project[project_id] << id if id\n        end",
        "comment": "Returns a Hash containing attribute values per project ID.  The returned Hash uses the following format:  { project id => [value1, value2, ...] }  nodes - An Array of HTML nodes to process. attribute - The name of the attribute (as a String) for which to gather values.  Returns a Hash.",
        "label": "Property",
        "id": "3427"
    },
    {
        "raw_code": "def self.cleanup_disks(machine, defined_disks, disk_meta_file)\n          return if disk_meta_file.values.flatten.empty?\n\n          handle_cleanup_disk(machine, defined_disks, disk_meta_file[\"disk\"])\n          handle_cleanup_dvd(machine, defined_disks, disk_meta_file[\"dvd\"])\n          # TODO: Floppy disks\n        end",
        "comment": "@param [Vagrant::Machine] machine @param [VagrantPlugins::Kernel_V2::VagrantConfigDisk] defined_disks @param [Hash] disk_meta_file - A hash of all the previously defined disks from the last configure_disk action",
        "label": "Property",
        "id": "9701"
    },
    {
        "raw_code": "def upload_paths(identifier)\n    [\n      local_storage_path(identifier),\n      File.join(remote_storage_base_path, identifier)\n    ]\n  end",
        "comment": "A personal snippet path is stored using FileUploader#upload_path.  The format for the path:  Local storage: :random_hex/:filename. Object storage: personal_snippet/:id/:random_hex/:filename.  upload_paths represent the possible paths for a given identifier, which will vary depending on whether the file is stored in local or object storage. upload_path should match an element in upload_paths.  base_dir represents the path seen by the user in Markdown, and it should always be prefixed with uploads/-/system.  store_dirs represent the paths that are actually used on disk. For object storage, this should omit the prefix /uploads/-/system.  For example, consider the requested path /uploads/-/system/personal_snippet/172/ff4ad5c2e40b39ae57cda51577317d20/file.png.  For local storage:  File on disk: /opt/gitlab/embedded/service/gitlab-rails/public/uploads/-/system/personal_snippet/172/ff4ad5c2e40b39ae57cda51577317d20/file.png.  base_dir: uploads/-/system/personal_snippet/172 upload_path: ff4ad5c2e40b39ae57cda51577317d20/file.png upload_paths: [\"ff4ad5c2e40b39ae57cda51577317d20/file.png\", \"personal_snippet/172/ff4ad5c2e40b39ae57cda51577317d20/file.png\"]. store_dirs: => {1=>\"uploads/-/system/personal_snippet/172/ff4ad5c2e40b39ae57cda51577317d20\", 2=>\"personal_snippet/172/ff4ad5c2e40b39ae57cda51577317d20\"}  For object storage:  upload_path: personal_snippet/172/ff4ad5c2e40b39ae57cda51577317d20/file.png",
        "label": "Property",
        "id": "8055"
    },
    {
        "raw_code": "def delay_for(jobinst, count, exception, msg)\n      rv = begin\n        # sidekiq_retry_in can return two different things:\n        # 1. When to retry next, as an integer of seconds\n        # 2. A symbol which re-routes the job elsewhere, e.g. :discard, :kill, :default\n        block = jobinst&.sidekiq_retry_in_block\n\n        # the sidekiq_retry_in_block can be defined in a wrapped class (ActiveJob for instance)\n        unless msg[\"wrapped\"].nil?\n          wrapped = Object.const_get(msg[\"wrapped\"])\n          block = wrapped.respond_to?(:sidekiq_retry_in_block) ? wrapped.sidekiq_retry_in_block : nil\n        end",
        "comment": "returns (strategy, seconds)",
        "label": "Property",
        "id": "5083"
    },
    {
        "raw_code": "def humanize(capitalize: true, keep_id_suffix: false)\n    ActiveSupport::Inflector.humanize(self, capitalize: capitalize, keep_id_suffix: keep_id_suffix)\n  end",
        "comment": "Capitalizes the first word, turns underscores into spaces, and (by default) strips a trailing '_id' if present. Like +titleize+, this is meant for creating pretty output.  The capitalization of the first word can be turned off by setting the optional parameter +capitalize+ to false. By default, this parameter is true.  The trailing '_id' can be kept and capitalized by setting the optional parameter +keep_id_suffix+ to true. By default, this parameter is false.  'employee_salary'.humanize                    # => \"Employee salary\" 'author_id'.humanize                          # => \"Author\" 'author_id'.humanize(capitalize: false)       # => \"author\" '_id'.humanize                                # => \"Id\" 'author_id'.humanize(keep_id_suffix: true)    # => \"Author id\"  See ActiveSupport::Inflector.humanize.",
        "label": "Property",
        "id": "14375"
    },
    {
        "raw_code": "def to_fs(format = :default)\n      if format == :db\n        utc.to_fs(format)\n      elsif formatter = ::Time::DATE_FORMATS[format]\n        formatter.respond_to?(:call) ? formatter.call(self).to_s : strftime(formatter)\n      else\n        to_s\n      end",
        "comment": "Returns a string of the object's date and time.  This method is aliased to <tt>to_formatted_s</tt>.  Accepts an optional <tt>format</tt>: * <tt>:default</tt> - default value, mimics Ruby Time#to_s format. * <tt>:db</tt> - format outputs time in UTC :db time. See Time#to_fs(:db). * Any key in +Time::DATE_FORMATS+ can be used. See active_support/core_ext/time/conversions.rb.",
        "label": "Property",
        "id": "13972"
    },
    {
        "raw_code": "def authenticate(request, realm, &password_procedure)\n        request.authorization && validate_digest_response(request, realm, &password_procedure)\n      end",
        "comment": "Returns true on a valid response, false otherwise.",
        "label": "Property",
        "id": "11274"
    },
    {
        "raw_code": "def self.handle_cleanup_disk(machine, defined_disks, disk_meta)\n          all_disks = machine.provider.driver.list_hdds\n\n          disk_meta.each do |d|\n            # look at Path instead of Name or UUID\n            disk_name  = File.basename(d[\"Path\"], '.*')\n            dsk = defined_disks.select { |dk| dk.name == disk_name }\n\n            if !dsk.empty? || d[\"primary\"] == true\n              next\n            else\n              LOGGER.warn(\"Found disk not in Vagrantfile config: '#{d[\"Name\"]}'. Removing disk from guest #{machine.name}\")\n\n              machine.ui.warn(I18n.t(\"vagrant.cap.cleanup_disks.disk_cleanup\", name: d[\"Name\"]), prefix: true)\n\n              disk_actual = all_disks.select { |a| File.realdirpath(a[\"Path\"]) == File.realdirpath(d[\"Path\"]) }.first\n              if !disk_actual\n                machine.ui.warn(I18n.t(\"vagrant.cap.cleanup_disks.disk_not_found\", name: d[\"Name\"]), prefix: true)\n              else\n                machine.provider.driver.remove_disk(disk_actual[\"ControllerType\"], disk_actual[\"ControllerNumber\"], disk_actual[\"ControllerLocation\"], disk_actual[\"Path\"])\n              end",
        "comment": "@param [Vagrant::Machine] machine @param [VagrantPlugins::Kernel_V2::VagrantConfigDisk] defined_disks @param [Hash] disk_meta - A hash of all the previously defined disks from the last configure_disk action",
        "label": "Property",
        "id": "9702"
    },
    {
        "raw_code": "def correctly_aligned_with_preceding_comment?(comment_index, column)\n          return false unless cop_config['AllowForAlignment']\n\n          processed_source.comments[0...comment_index].reverse_each do |other_comment|\n            return other_comment.loc.column == column unless own_line_comment?(other_comment)\n          end",
        "comment": "Returns true if: a) the cop is configured to allow extra indentation for alignment, and b) the currently inspected comment is aligned with the nearest preceding end-of-line comment.",
        "label": "Property",
        "id": "10373"
    },
    {
        "raw_code": "def read_guest_additions_version\n        end",
        "comment": "Returns the guest additions version that is installed on this VM.  @return [String]",
        "label": "Property",
        "id": "9581"
    },
    {
        "raw_code": "def find_namespace(id)\n      if INTEGER_ID_REGEX.match?(id.to_s)\n        # We need to stick to an up-to-date replica or primary db here in order to properly observe the namespace\n        # recently created by GitlabSubscriptions::Trials::UltimateCreateService.\n        # See https://gitlab.com/gitlab-org/customers-gitlab-com/-/issues/9808\n        ::Namespace.sticking.find_caught_up_replica(:namespace, id)\n\n        Namespace.without_project_namespaces.find_by(id: id)\n      else\n        find_namespace_by_path(id)\n      end",
        "comment": "find_namespace returns the namespace regardless of user access level on the namespace rubocop: disable CodeReuse/ActiveRecord",
        "label": "Property",
        "id": "3777"
    },
    {
        "raw_code": "def inherited_table_names(table_name) # :nodoc:\n          scope = quoted_scope(table_name, type: \"BASE TABLE\")\n\n          query_values(<<~SQL, \"SCHEMA\")\n            SELECT parent.relname\n            FROM pg_catalog.pg_inherits i\n              JOIN pg_catalog.pg_class child ON i.inhrelid = child.oid\n              JOIN pg_catalog.pg_class parent ON i.inhparent = parent.oid\n              LEFT JOIN pg_namespace n ON n.oid = child.relnamespace\n            WHERE child.relname = #{scope[:name]}\n              AND child.relkind IN (#{scope[:type]})\n              AND n.nspname = #{scope[:schema]}\n          SQL\n        end",
        "comment": "Returns the inherited table name of a given table",
        "label": "Property",
        "id": "13239"
    },
    {
        "raw_code": "def parallel_worker_id\n        @@parallel_worker_id\n      end",
        "comment": "Returns the current parallel worker ID if tests are running in parallel, nil otherwise.  ActiveSupport::TestCase.parallel_worker_id # => 2",
        "label": "Property",
        "id": "13948"
    },
    {
        "raw_code": "def mime_type(filename, mime_tab)\n      suffix1 = (/\\.(\\w+)$/ =~ filename && $1.downcase)\n      suffix2 = (/\\.(\\w+)\\.[\\w\\-]+$/ =~ filename && $1.downcase)\n      mime_tab[suffix1] || mime_tab[suffix2] || \"application/octet-stream\"\n    end",
        "comment": " Returns the mime type of +filename+ from the list in +mime_tab+.  If no mime type was found application/octet-stream is returned.",
        "label": "Property",
        "id": "664"
    },
    {
        "raw_code": "def self.mainpid(pid, unset_env = false)\n      notify(\"#{MAINPID}#{pid}\", unset_env)\n    end",
        "comment": "@param pid [Integer]",
        "label": "Property",
        "id": "5194"
    },
    {
        "raw_code": "def next_occurring(day_of_week)\n      from_now = DAYS_INTO_WEEK.fetch(day_of_week) - wday\n      from_now += 7 unless from_now > 0\n      advance(days: from_now)\n    end",
        "comment": "Returns a new date/time representing the next occurrence of the specified day of week.  today = Date.today               # => Thu, 14 Dec 2017 today.next_occurring(:monday)    # => Mon, 18 Dec 2017 today.next_occurring(:thursday)  # => Thu, 21 Dec 2017",
        "label": "Property",
        "id": "14174"
    },
    {
        "raw_code": "def __compiled_pushes\n        raise \"Must finalize first!\" if !@__finalized\n        @__compiled_pushes.dup\n      end",
        "comment": "This returns the list of compiled pushes as a hash by name.  @return [Hash<Symbol, Array<Class, Object>>]",
        "label": "Property",
        "id": "9430"
    },
    {
        "raw_code": "def module_include(base, mod)\n      MODULE_INCLUDE_MUTEX.synchronize do\n        old_methods = {}\n\n        mod.instance_methods.each do |sym|\n          old_methods[sym] = base.instance_method(sym) if base.method_defined?(sym)\n        end",
        "comment": "Internal: Inject into target module for the duration of the block.  mod - Module  Returns result of block.",
        "label": "Property",
        "id": "1293"
    },
    {
        "raw_code": "def url_for_main\n        url_for_file(\"index.html\")\n      end",
        "comment": "Returns the URL for the main page (README or alphabetic index)  @return [String] the URL pointing to the first main page the user should see.",
        "label": "Property",
        "id": "413"
    },
    {
        "raw_code": "def arrparse(ts)\n    ts = eat('[', ts)\n    arr = []\n\n    if ts[0][0] == ']'\n      return arr, ts[1..-1]\n    end",
        "comment": "Parses an \"array\" in the sense of RFC 4627. Returns the parsed value and any trailing tokens.",
        "label": "Property",
        "id": "8700"
    },
    {
        "raw_code": "def full_search(query, matched_columns: nil, use_minimum_char_limit: true)\n      if matched_columns\n        matched_columns = matched_columns.to_s.split(',')\n        matched_columns &= SEARCHABLE_FIELDS\n        matched_columns.map!(&:to_sym)\n      end",
        "comment": "Searches for records with a matching title or description.  This method uses ILIKE on PostgreSQL.  query - The search query as a String matched_columns - Modify the scope of the query. 'title', 'description' or joining them with a comma.  Returns an ActiveRecord::Relation.",
        "label": "Property",
        "id": "7399"
    },
    {
        "raw_code": "def export(path)\n        end",
        "comment": "Exports the virtual machine to the given path.  @param [String] path Path to the OVF file. @yield [progress] Yields the block with the progress of the export.",
        "label": "Property",
        "id": "9573"
    },
    {
        "raw_code": "def copy_string(start_pos, end_pos)\n    res = @str[start_pos...end_pos]\n    res.gsub!(/\\000/, '')\n    res\n  end",
        "comment": " Copies +start_pos+ to +end_pos+ from the current string",
        "label": "Property",
        "id": "16225"
    },
    {
        "raw_code": "def end_accepting\n    @res.compact\n  end",
        "comment": " Returns an Array of items that were wrapped in plus, tt or code.",
        "label": "Property",
        "id": "16261"
    },
    {
        "raw_code": "def containers\n        @__containers\n      end",
        "comment": "Accessor for the internal state.",
        "label": "Property",
        "id": "9927"
    },
    {
        "raw_code": "def self.internal_poststart_command_clone_project_script\n          read_file(\"workspace_operations/create/bm_internal_poststart_command_clone_project.sh\")\n        end",
        "comment": "@return [String] content of the file",
        "label": "Property",
        "id": "3314"
    },
    {
        "raw_code": "def prev_occurring(day_of_week)\n      ago = wday - DAYS_INTO_WEEK.fetch(day_of_week)\n      ago += 7 unless ago > 0\n      advance(days: -ago)\n    end",
        "comment": "Returns a new date/time representing the previous occurrence of the specified day of week.  today = Date.today               # => Thu, 14 Dec 2017 today.prev_occurring(:monday)    # => Mon, 11 Dec 2017 today.prev_occurring(:thursday)  # => Thu, 07 Dec 2017",
        "label": "Property",
        "id": "14175"
    },
    {
        "raw_code": "def matching(refs)\n    refs.select { |ref| ref.is_a?(String) ? matches?(ref) : matches?(ref.name) }\n  end",
        "comment": "Returns all branches/tags (among the given list of refs [`Gitlab::Git::Branch`] or their names [`String`]) that match the current protected ref.",
        "label": "Property",
        "id": "6880"
    },
    {
        "raw_code": "def delete_workflow_run(repo, id, options = {})\n        boolean_from_response :delete, \"#{Repository.path repo}/actions/runs/#{id}\", options\n      end",
        "comment": "Deletes a workflow run  @param repo [Integer, String, Repository, Hash] A GitHub repository @param id [Integer] Id of a workflow run  @return [Boolean] Returns true if the run is deleted @see https://docs.github.com/en/rest/reference/actions#delete-a-workflow-run",
        "label": "Property",
        "id": "15119"
    },
    {
        "raw_code": "def all_quarter\n      beginning_of_quarter..end_of_quarter\n    end",
        "comment": "Returns a Range representing the whole quarter of the current date/time.",
        "label": "Property",
        "id": "14172"
    },
    {
        "raw_code": "def localtime(utc_offset = nil)\n    utc = new_offset(0)\n\n    Time.utc(\n      utc.year, utc.month, utc.day,\n      utc.hour, utc.min, utc.sec + utc.sec_fraction\n    ).getlocal(utc_offset)\n  end",
        "comment": "Returns a <tt>Time</tt> instance of the simultaneous time in the system timezone.",
        "label": "Property",
        "id": "14196"
    },
    {
        "raw_code": "def load_balancing_enabled?\n          return false if Gitlab::Runtime.rake?\n\n          hosts.any? || service_discovery_enabled?\n        end",
        "comment": "Returns `true` if the use of load balancing replicas should be enabled.  This is disabled for Rake tasks to ensure e.g. database migrations always produce consistent results.",
        "label": "Property",
        "id": "3082"
    },
    {
        "raw_code": "def https?\n        @https\n      end",
        "comment": "Returns `true` if the session is mimicking a secure HTTPS request.  if session.https? ... end",
        "label": "Property",
        "id": "11626"
    },
    {
        "raw_code": "def guests\n          result = {}\n\n          @registered.each do |plugin|\n            result.merge!(plugin.guest.to_hash)\n          end",
        "comment": "This returns all the registered guests.  @return [Hash]",
        "label": "Property",
        "id": "8984"
    },
    {
        "raw_code": "def self.attribute_map\n      {\n        :'start' => :'start',\n        :'_end' => :'end',\n        :'interval' => :'interval',\n        :'group' => :'group'\n      }\n    end",
        "comment": "Attribute mapping from ruby-style variable name to JSON key.",
        "label": "Property",
        "id": "949"
    },
    {
        "raw_code": "def root_path\n      return @root_path if defined?(@root_path)\n\n      root_finder = lambda do |path|\n        # Note: To remain compatible with Ruby 1.8, we have to use\n        # a `find` here instead of an `each`.\n        vf = find_vagrantfile(path, @vagrantfile_name)\n        return path if vf\n        return nil if path.root? || !File.exist?(path)\n        root_finder.call(path.parent)\n      end",
        "comment": "The root path is the path where the top-most (loaded last) Vagrantfile resides. It can be considered the project root for this environment.  @return [String]",
        "label": "Property",
        "id": "8870"
    },
    {
        "raw_code": "def init_date_from_gitaly(author)\n        return date_in_utc(author) if author.timezone.blank?\n\n        Time.strptime(\"#{author.date.seconds} #{author.timezone}\", '%s %z')\n      rescue ArgumentError\n        date_in_utc(author)\n      end",
        "comment": "Gitaly provides a UNIX timestamp in author.date.seconds, and a timezone offset in author.timezone. If the latter isn't present, assume UTC.",
        "label": "Property",
        "id": "2599"
    },
    {
        "raw_code": "def native_database_types\n        {}\n      end",
        "comment": "Returns a hash of mappings from the abstract data types to the native database types. See TableDefinition#column for details on the recognized abstract data types.",
        "label": "Property",
        "id": "13125"
    },
    {
        "raw_code": "def block_all_mixed_content(enabled = true)\n      if enabled\n        @directives[\"block-all-mixed-content\"] = true\n      else\n        @directives.delete(\"block-all-mixed-content\")\n      end",
        "comment": "Specify whether to prevent the user agent from loading any assets over HTTP when the page uses HTTPS:  policy.block_all_mixed_content  Pass `false` to allow it again:  policy.block_all_mixed_content false ",
        "label": "Property",
        "id": "11414"
    },
    {
        "raw_code": "def message\n      __getobj__\n    end",
        "comment": "Returns the resulting Mail::Message",
        "label": "Property",
        "id": "11143"
    },
    {
        "raw_code": "def url_for(obj, anchor = nil, relative = true)\n        link = nil\n        return link unless serializer\n        return link if obj.is_a?(CodeObjects::Base) && run_verifier([obj]).empty?\n\n        if obj.is_a?(CodeObjects::Base) && !obj.is_a?(CodeObjects::NamespaceObject)\n          # If the obj is not a namespace obj make it the anchor.\n          anchor = obj\n          obj = obj.namespace\n        end",
        "comment": "Returns the URL for an object.  @param [String, CodeObjects::Base] obj the object (or object path) to link to @param [String] anchor the anchor to link to @param [Boolean] relative use a relative or absolute link @return [String] the URL location of the object",
        "label": "Property",
        "id": "410"
    },
    {
        "raw_code": "def to_body\n      to_hash\n    end",
        "comment": "to_body is an alias to to_hash (backward compatibility) @return [Hash] Returns the object in the form of hash",
        "label": "Property",
        "id": "893"
    },
    {
        "raw_code": "def report_attributes(cm)\n    return if cm.attributes.empty?\n\n    report = []\n\n    cm.attributes.each do |attr|\n      next if attr.documented?\n      line = attr.line ? \":#{attr.line}\" : nil\n      report << \"  #{attr.definition} :#{attr.name} # in file #{attr.file.full_name}#{line}\\n\"\n      report << \"\\n\"\n    end",
        "comment": " Returns a report on undocumented attributes in ClassModule +cm+",
        "label": "Property",
        "id": "15997"
    },
    {
        "raw_code": "def assert_no_broadcasts(stream, &block)\n      assert_broadcasts stream, 0, &block\n    end",
        "comment": "Asserts that no messages have been sent to the stream.  def test_no_broadcasts assert_no_broadcasts 'messages' ActionCable.server.broadcast 'messages', { text: 'hi' } assert_broadcasts 'messages', 1 end  If a block is passed, that block should not cause any message to be sent.  def test_broadcasts_again assert_no_broadcasts 'messages' do # No job messages should be sent from this block end end  Note: This assertion is simply a shortcut for:  assert_broadcasts 'messages', 0, &block ",
        "label": "Property",
        "id": "11028"
    },
    {
        "raw_code": "def in_minutes\n      in_seconds / SECONDS_PER_MINUTE.to_f\n    end",
        "comment": "Returns the amount of minutes a duration covers as a float  1.day.in_minutes # => 1440.0",
        "label": "Property",
        "id": "13820"
    },
    {
        "raw_code": "def pretty_print(pp)\n        pp.object_address_group(self) do\n          if defined?(@attributes) && @attributes\n            attr_names = attribute_names.select { |name| @attributes.key?(name) }\n            pp.seplist(attr_names, proc { pp.text \",\" }) do |attr_name|\n              pp.breakable \" \"\n              pp.group(1) do\n                pp.text attr_name\n                pp.text \":\"\n                pp.breakable\n                value = _read_attribute(attr_name)\n                pp.pp value\n              end",
        "comment": "Takes a PP and prettily prints this record to it, allowing you to get a nice result from <tt>pp record</tt> when pp is required.",
        "label": "Property",
        "id": "9977"
    },
    {
        "raw_code": "def strict_locals?\n      strict_locals!\n    end",
        "comment": "Returns whether a template is using strict locals.",
        "label": "Property",
        "id": "11758"
    },
    {
        "raw_code": "def self.values_from_list(raw_key)\n          key = cache_key_for(raw_key)\n\n          with_redis do |redis|\n            redis.lrange(key, 0, -1)\n          end",
        "comment": "Returns the values of the given list.  raw_key - The key of the list.",
        "label": "Property",
        "id": "1957"
    },
    {
        "raw_code": "def by_no_approvals?\n      includes_special_label?(IssuableFinder::Params::FILTER_NONE)\n    end",
        "comment": "Is param using special condition: \"None\" ?  @return [Boolean] whether special condition \"None\" is being used",
        "label": "Property",
        "id": "7960"
    },
    {
        "raw_code": "def to_hash\n        load_for_read!\n        @delegate.dup.delete_if { |_, v| v.nil? }\n      end",
        "comment": "Returns the session as Hash.",
        "label": "Property",
        "id": "11553"
    },
    {
        "raw_code": "def pretty_print(pp)\n      return super if custom_inspect_method_defined?\n      pp.object_address_group(self) do\n        if @attributes\n          attr_names = attributes_for_inspect.select { |name| _has_attribute?(name.to_s) }\n          pp.seplist(attr_names, proc { pp.text \",\" }) do |attr_name|\n            attr_name = attr_name.to_s\n            pp.breakable \" \"\n            pp.group(1) do\n              pp.text attr_name\n              pp.text \":\"\n              pp.breakable\n              value = attribute_for_inspect(attr_name)\n              pp.text value\n            end",
        "comment": "Takes a PP and prettily prints this record to it, allowing you to get a nice result from <tt>pp record</tt> when pp is required.",
        "label": "Property",
        "id": "12442"
    },
    {
        "raw_code": "def to_s\n      to_hash.to_s\n    end",
        "comment": "Returns the string representation of the object @return [String] String presentation of the object",
        "label": "Property",
        "id": "962"
    },
    {
        "raw_code": "def diff_hash\n          {\n            diff: diff_hunk,\n            new_path: file_path,\n            old_path: file_path,\n\n            # These fields are not displayed for LegacyDiffNote notes, so it\n            # doesn't really matter what we set them to.\n            a_mode: '100644',\n            b_mode: '100644',\n            new_file: false\n          }\n        end",
        "comment": "Returns a Hash that can be used to populate `notes.st_diff`, removing the need for requesting Git data for every diff note. Used when importing with LegacyDiffNote",
        "label": "Property",
        "id": "2276"
    },
    {
        "raw_code": "def aws_server_side_encryption_headers\n      {\n        'x-amz-server-side-encryption' => server_side_encryption,\n        'x-amz-server-side-encryption-aws-kms-key-id' => server_side_encryption_kms_key_id\n      }\n    end",
        "comment": "This returns a Hash of HTTP encryption headers to send along to S3.  They can also be passed in as Fog::AWS::Storage::File attributes, since there are aliases defined for them: https://github.com/fog/fog-aws/blob/ab288f29a0974d64fd8290db41080e5578be9651/lib/fog/aws/models/storage/file.rb#L24-L25",
        "label": "Property",
        "id": "3732"
    },
    {
        "raw_code": "def hours\n    ActiveSupport::Duration.hours(self)\n  end",
        "comment": "Returns a Duration instance matching the number of hours provided.  2.hours # => 2 hours",
        "label": "Property",
        "id": "14294"
    },
    {
        "raw_code": "def take_screenshot(html: false, screenshot: nil)\n          showing_html = html || html_from_env?\n\n          increment_unique\n          save_html if showing_html\n          save_image\n          show display_image(html: showing_html, screenshot_output: screenshot)\n        end",
        "comment": "Takes a screenshot of the current page in the browser.  `take_screenshot` can be used at any point in your system tests to take a screenshot of the current state. This can be useful for debugging or automating visual testing. You can take multiple screenshots per test to investigate changes at different points during your test. These will be named with a sequential prefix (or 'failed' for failing tests)  The default screenshots directory is `tmp/screenshots` but you can set a different one with `Capybara.save_path`  You can use the `html` argument or set the `RAILS_SYSTEM_TESTING_SCREENSHOT_HTML` environment variable to save the HTML from the page that is being screenshotted so you can investigate the elements on the page at the time of the screenshot  You can use the `screenshot` argument or set the `RAILS_SYSTEM_TESTING_SCREENSHOT` environment variable to control the output. Possible values are: `simple` (default) :       Only displays the screenshot path. This is the default value.  `inline` :       Display the screenshot in the terminal using the iTerm image protocol (https://iterm2.com/documentation-images.html).  `artifact` :       Display the screenshot in the terminal, using the terminal artifact format (https://buildkite.github.io/terminal-to-html/inline-images/).  ",
        "label": "Property",
        "id": "11608"
    },
    {
        "raw_code": "def lock_file(file_name, &block)\n          if File.exist?(file_name)\n            File.open(file_name, \"r+\") do |f|\n              f.flock File::LOCK_EX\n              yield\n            ensure\n              f.flock File::LOCK_UN\n            end",
        "comment": "Lock a file for a block so only one process can modify it at a time.",
        "label": "Property",
        "id": "14009"
    },
    {
        "raw_code": "def years_since(years)\n      advance(years: years)\n    end",
        "comment": "Returns a new date/time the specified number of years in the future.",
        "label": "Property",
        "id": "14148"
    },
    {
        "raw_code": "def foo; end\n            end",
        "comment": "{access_modifier}",
        "label": "Property",
        "id": "10878"
    },
    {
        "raw_code": "def edition\n      @edition ||= Trigger.ee? ? \"ee\" : \"ce\"\n    end",
        "comment": "Edition postfix  @return [String]",
        "label": "Property",
        "id": "5272"
    },
    {
        "raw_code": "def self.attribute_map\n      {\n        :'id' => :'id',\n        :'project' => :'project',\n        :'title' => :'title',\n        :'actor' => :'actor',\n        :'count' => :'count',\n        :'user_count' => :'userCount',\n        :'last_seen' => :'lastSeen',\n        :'first_seen' => :'firstSeen',\n        :'status' => :'status'\n      }\n    end",
        "comment": "Attribute mapping from ruby-style variable name to JSON key.",
        "label": "Property",
        "id": "931"
    },
    {
        "raw_code": "def attached?\n      attachments.any?\n    end",
        "comment": "Returns true if any attachments have been made.  class Gallery < ApplicationRecord has_many_attached :photos end  Gallery.new.photos.attached? # => false",
        "label": "Property",
        "id": "13685"
    },
    {
        "raw_code": "def initialize(text)\n            @text = text\n\n            @@mutex.synchronize do\n              @@formatter ||= RDocMarkupToHtml.new\n              @@markup ||= MARKUP.new\n            end",
        "comment": "@param text [String]",
        "label": "Property",
        "id": "457"
    },
    {
        "raw_code": "def get_statistics(table_names, check_statistics: true)\n          time = 6.hours.ago\n\n          query = ::Gitlab::Database::PgClass.joins(\"LEFT JOIN pg_stat_user_tables ON pg_stat_user_tables.relid = pg_class.oid\")\n            .where(relname: table_names)\n            .where('schemaname = current_schema()')\n            .select('pg_class.relname AS table_name, reltuples::bigint AS estimate')\n\n          if check_statistics\n            query = query.where('last_vacuum > ? OR last_autovacuum > ? OR last_analyze > ? OR last_autoanalyze > ?',\n              time, time, time, time)\n          end",
        "comment": "Generates the PostgreSQL query to return the tuples for tables that have been vacuumed or analyzed in the last hour.  @param [Array] table names @returns [Hash] Table name to count mapping (e.g. { 'projects' => 5, 'users' => 100 })",
        "label": "Property",
        "id": "3125"
    },
    {
        "raw_code": "def server_software\n      (get_header(\"SERVER_SOFTWARE\") && /^([a-zA-Z]+)/ =~ get_header(\"SERVER_SOFTWARE\")) ? $1.downcase : nil\n    end",
        "comment": "Returns the lowercase name of the HTTP server software.",
        "label": "Property",
        "id": "11464"
    },
    {
        "raw_code": "def groups(*groups)\n      hash = groups.extract_options!\n      env = Rails.env\n      groups.unshift(:default, env)\n      groups.concat ENV[\"RAILS_GROUPS\"].to_s.split(\",\")\n      groups.concat hash.map { |k, v| k if v.map(&:to_s).include?(env) }\n      groups.compact!\n      groups.uniq!\n      groups\n    end",
        "comment": "Returns all \\Rails groups for loading based on:  * The \\Rails environment; * The environment variable RAILS_GROUPS; * The optional envs given as argument and the hash with group dependencies;  Rails.groups assets: [:development, :test] # => [:default, \"development\", :assets] for Rails.env == \"development\" # => [:default, \"production\"]           for Rails.env == \"production\"",
        "label": "Property",
        "id": "14623"
    },
    {
        "raw_code": "def deep_dup\n    if name.nil?\n      super\n    else\n      self\n    end",
        "comment": "Returns a copy of module or class if it's anonymous. If it's named, returns +self+.  Object.deep_dup == Object # => true klass = Class.new klass.deep_dup == klass # => false",
        "label": "Property",
        "id": "14312"
    },
    {
        "raw_code": "def self.find_container(type, full_path)\n      return [nil, nil] if full_path.blank?\n\n      if type.snippet?\n        snippet = find_snippet(full_path)\n\n        [snippet, snippet&.project]\n      elsif type.wiki?\n        wiki = find_wiki(full_path)\n\n        [wiki, wiki.try(:project)]\n      elsif type.design?\n        design_management_repository = find_design_management_repository(full_path)\n\n        [design_management_repository, design_management_repository.project]\n      else\n        project = find_project(full_path)\n\n        [project, project]\n      end",
        "comment": "Returns an array containing: - The repository container - The related project (if available)  @returns [HasRepository, Project, String]",
        "label": "Property",
        "id": "1521"
    },
    {
        "raw_code": "def get_server_info\n        request = Gitlab::Agent::ServerInfo::Rpc::GetServerInfoRequest.new\n\n        stub_for(:server_info)\n          .get_server_info(request, metadata: metadata)\n          .current_server_info\n      end",
        "comment": "Return GitLab KAS server info This method only returns information about a single KAS server instance without taking into account that there are potentially multiple KAS replicas running, which may not have the same server info. This is particularly the case during a rollout.",
        "label": "Property",
        "id": "1828"
    },
    {
        "raw_code": "def generate_message(attribute, type = :invalid, options = {})\n      Error.generate_message(attribute, type, @base, options)\n    end",
        "comment": "Translates an error message in its default scope (<tt>activemodel.errors.messages</tt>).  Error messages are first looked up in <tt>activemodel.errors.models.MODEL.attributes.ATTRIBUTE.MESSAGE</tt>, if it's not there, it's looked up in <tt>activemodel.errors.models.MODEL.MESSAGE</tt> and if that is not there also, it returns the translation of the default message (e.g. <tt>activemodel.errors.messages.MESSAGE</tt>). The translated model name, translated attribute name, and the value are available for interpolation.  When using inheritance in your models, it will check all the inherited models too, but only if the model itself hasn't been found. Say you have <tt>class Admin < User; end</tt> and you wanted the translation for the <tt>:blank</tt> error message for the <tt>title</tt> attribute, it looks for these translations:  * <tt>activemodel.errors.models.admin.attributes.title.blank</tt> * <tt>activemodel.errors.models.admin.blank</tt> * <tt>activemodel.errors.models.user.attributes.title.blank</tt> * <tt>activemodel.errors.models.user.blank</tt> * any default you provided through the +options+ hash (in the <tt>activemodel.errors</tt> scope) * <tt>activemodel.errors.messages.blank</tt> * <tt>errors.attributes.title.blank</tt> * <tt>errors.messages.blank</tt>",
        "label": "Property",
        "id": "12239"
    },
    {
        "raw_code": "def years\n    ActiveSupport::Duration.years(self)\n  end",
        "comment": "Returns a Duration instance matching the number of years provided.  2.years # => 2 years",
        "label": "Property",
        "id": "14252"
    },
    {
        "raw_code": "def self.plugin(version, component=nil)\n    # Build up the key and return a result\n    key    = version.to_s.to_sym\n    key    = [key, component.to_s.to_sym] if component\n    result = PLUGIN_COMPONENTS.get(key)\n\n    # If we found our component then we return that\n    return result if result\n\n    # If we didn't find a result, then raise an exception, depending\n    # on if we got a component or not.\n    raise ArgumentError, \"Plugin superclass not found for version/component: \" +\n      \"#{version} #{component}\"\n  end",
        "comment": "Returns a superclass to use when creating a plugin for Vagrant. Given a specific version, this returns a proper superclass to use to register plugins for that version.  Optionally, if you give a specific component, then it will return the proper superclass for that component as well.  Plugins and plugin components should subclass the classes returned by this method. This method lets Vagrant core control these superclasses and change them over time without affecting plugins. For example, if the V1 superclass happens to be \"Vagrant::V1,\" future versions of Vagrant may move it to \"Vagrant::Plugins::V1\" and plugins will not be affected.  @param [String] version @param [String] component @return [Class]",
        "label": "Property",
        "id": "8715"
    },
    {
        "raw_code": "def to_hash\n      hash = {}\n      self.class.attribute_map.each_pair do |attr, param|\n        value = self.send(attr)\n        if value.nil?\n          is_nullable = self.class.openapi_nullable.include?(attr)\n          next if !is_nullable || (is_nullable && !instance_variable_defined?(:\"@#{attr}\"))\n        end",
        "comment": "Returns the object in the form of hash @return [Hash] Returns the object in the form of hash",
        "label": "Property",
        "id": "929"
    },
    {
        "raw_code": "def folder\n    @folder = params[:id]\n\n    respond_to do |format|\n      format.html\n      format.json do\n        states = SCOPES_TO_STATES.fetch(params[:scope], ACTIVE_STATES)\n        folder_environments = search_environments(type: params[:id])\n\n        @environments = folder_environments.with_state(states)\n          .order(:name)\n\n        render json: {\n          environments: serialize_environments(request, response),\n          available_count: folder_environments.available.count,\n          active_count: folder_environments.active.count,\n          stopped_count: folder_environments.stopped.count\n        }\n      end",
        "comment": "Returns all environments for a given folder rubocop: disable CodeReuse/ActiveRecord",
        "label": "Property",
        "id": "6595"
    },
    {
        "raw_code": "def scoped_variables(job, environment:, dependencies:)\n          Gitlab::Ci::Variables::Collection.new.tap do |variables|\n            if pipeline.only_workload_variables?\n              # predefined_project_variables includes things like $CI_PROJECT_PATH which are used by the runner to clone\n              # the repo\n              variables.concat(project.predefined_project_variables)\n\n              # yaml_variables is how we inject dynamic configuration into a workload\n              variables.concat(job.yaml_variables)\n\n              variables.concat(\n                user_defined_variables(options: job.options, environment: environment, job_variables: job.manual_variables)\n              )\n              next\n            end",
        "comment": "When adding new variables, consider either adding or commenting out them in the following methods: - unprotected_scoped_variables - scoped_variables_for_pipeline_seed",
        "label": "Property",
        "id": "2534"
    },
    {
        "raw_code": "def keyset_paginate(cursor: nil, per_page: 20, keyset_order_options: {})\n    Gitlab::Pagination::Keyset::Paginator.new(scope: self.dup, cursor: cursor, per_page: per_page, keyset_order_options: keyset_order_options)\n  end",
        "comment": "This method loads the records for the requested page and returns a keyset paginator object.",
        "label": "Property",
        "id": "1279"
    },
    {
        "raw_code": "def diff_blobs(...)\n        wrapped_gitaly_errors do\n          gitaly_diff_client.diff_blobs(...)\n        end",
        "comment": "Returns an array of DiffBlob objects that represent a diff between two blobs in a repository. For each diff generated, the pre-image and post-image blob IDs should be obtained using `find_changed_paths` method.",
        "label": "Property",
        "id": "2635"
    },
    {
        "raw_code": "def valid?\n      true\n    end",
        "comment": "Check to see if the all the properties in the model are valid @return true if the model is valid",
        "label": "Property",
        "id": "972"
    },
    {
        "raw_code": "def prev_week(start_day = Date.beginning_of_week, same_time: false)\n      result = first_hour(weeks_ago(1).beginning_of_week.days_since(days_span(start_day)))\n      same_time ? copy_time_to(result) : result\n    end",
        "comment": "Returns a new date/time representing the given day in the previous week. Week is assumed to start on +start_day+, default is +Date.beginning_of_week+ or +config.beginning_of_week+ when set. DateTime objects have their time set to 0:00 unless +same_time+ is true.",
        "label": "Property",
        "id": "14157"
    },
    {
        "raw_code": "def /(other)\n      if Scalar === other\n        Duration.new(value / other.value, @parts.transform_values { |number| number / other.value }, @variable)\n      elsif Duration === other\n        value / other.value\n      elsif Numeric === other\n        Duration.new(value / other, @parts.transform_values { |number| number / other }, @variable)\n      else\n        raise_type_error(other)\n      end",
        "comment": "Divides this Duration by a Numeric and returns a new Duration.",
        "label": "Property",
        "id": "13815"
    },
    {
        "raw_code": "def database_from_path\n          if @adapter == \"sqlite3\"\n            # 'sqlite3:/foo' is absolute, because that makes sense. The\n            # corresponding relative version, 'sqlite3:foo', is handled\n            # elsewhere, as an \"opaque\".\n\n            uri.path\n          else\n            # Only SQLite uses a filename as the \"database\" name; for\n            # anything else, a leading slash would be silly.\n\n            uri.path.delete_prefix(\"/\")\n          end",
        "comment": "Returns name of the database.",
        "label": "Property",
        "id": "13288"
    },
    {
        "raw_code": "def unmodify_nilclass\n      NILCLASS_METHODS.each do |meth|\n        next unless nil.respond_to?(meth)\n        NilClass.send(:remove_method, meth)\n      end",
        "comment": "Returns the state of NilClass back to normal @return [void]",
        "label": "Property",
        "id": "93"
    },
    {
        "raw_code": "def url_for_main\n        options.readme ? url_for_file(options.readme) : url_for_index\n      end",
        "comment": "Returns the main URL, first checking a readme and then linking to the index @return (see Templates::Helpers::HtmlHelper#url_for_main)",
        "label": "Property",
        "id": "685"
    },
    {
        "raw_code": "def _HtmlBlockOpenH1\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenH1 = \"<\" Spnl (\"h1\" | \"H1\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "15650"
    },
    {
        "raw_code": "def self.documentation_url(config = nil)\n        Documentation.url_for(self, config)\n      end",
        "comment": "Returns a url to view this cops documentation online. Requires 'DocumentationBaseURL' to be set for your department. Will follow the convention of RuboCops own documentation structure, overwrite this method to accommodate your custom layout. @return [String, nil]  @api public",
        "label": "Property",
        "id": "10248"
    },
    {
        "raw_code": "def uncached(dirties: true, &block)\n        if connected? || !configurations.empty?\n          connection_pool.disable_query_cache(dirties: dirties, &block)\n        else\n          yield\n        end",
        "comment": "Runs the block with the query cache disabled.  If the query cache was enabled before the block was executed, it is enabled again after it.  Set <tt>dirties: false</tt> to prevent query caches on all connections from being cleared by write operations. (By default, write operations dirty all connections' query caches in case they are replicas whose cache would now be outdated.)",
        "label": "Property",
        "id": "12591"
    },
    {
        "raw_code": "def last_line(src)\n  if n = src.rindex(\"\\n\")\n    src[(n+1) .. -1]\n  else\n    src\n  end",
        "comment": " Returns the last line of +src+",
        "label": "Property",
        "id": "16540"
    },
    {
        "raw_code": "def processing_jobs\n          all_jobs.lazy.reject { |job| job[:processed] }\n        end",
        "comment": "This method returns a list of all job, that are to be processed",
        "label": "Property",
        "id": "5828"
    },
    {
        "raw_code": "def hierarchy(hierarchy_top = nil, preloaded = nil, opts = {})\n    preloaded ||= ancestors_upto(hierarchy_top)\n    expand_hierarchy_for_child(self, self, hierarchy_top, preloaded, opts)\n  end",
        "comment": "Returns the hierarchy of a project or group in the from of a hash upto a given top.  Options: upto_preloaded_ancestors_only: boolean - When `true`, the hierarchy expansions stops at the highest level preloaded ancestor. The hierarchy isn't guaranteed to reach the `hierarchy_top`.  > project.hierarchy => { parent_group => { child_group => project } }",
        "label": "Property",
        "id": "7292"
    },
    {
        "raw_code": "def page\n          @page ||= Page.new(order_by: order_by, per_page: params[:per_page])\n        end",
        "comment": "extracts Paging information from request parameters",
        "label": "Property",
        "id": "2001"
    },
    {
        "raw_code": "def from_query(query)\n        operation_name = query.selected_operation_name\n\n        return UNKNOWN unless operation_name\n\n        @operation_hash[operation_name] || UNKNOWN\n      end",
        "comment": "Returns the known operation from the given ::GraphQL::Query object",
        "label": "Property",
        "id": "2084"
    },
    {
        "raw_code": "def convert_attrs(str, attrs, exclusive = false)\n    convert_attrs_matching_word_pairs(str, attrs, exclusive)\n    convert_attrs_word_pair_map(str, attrs, exclusive)\n  end",
        "comment": " Map attributes like <b>text</b>to the sequence \\001\\002<char>\\001\\003<char>, where <char> is a per-attribute specific character",
        "label": "Property",
        "id": "16227"
    },
    {
        "raw_code": "def test; end\n          end",
        "comment": "{access_modifier}",
        "label": "Property",
        "id": "10833"
    },
    {
        "raw_code": "def references_in(text, pattern = object_reference_pattern)\n          Gitlab::Utils::Gsub.gsub_with_limit(text, pattern, limit: Banzai::Filter::FILTER_ITEM_LIMIT) do |match_data|\n            yield match_data[0], match_data['user']\n          end",
        "comment": "Public: Find `@user` user references in text  references_in(text) do |match, username| \"<a href=...>@#{user}</a>\" end  text - String text to search.  Yields the String match, and the String user name.  Returns a String replaced with the return of the block.",
        "label": "Property",
        "id": "3507"
    },
    {
        "raw_code": "def A.some_method\n            implement 1\n          end",
        "comment": "{type} A",
        "label": "Property",
        "id": "10951"
    },
    {
        "raw_code": "def initialize(wiki, change, raw_change)\n        @wiki = wiki\n        @raw_change = raw_change\n        @change = change\n      end",
        "comment": "@param [Wiki] wiki @param [Hash] change - must have keys `:oldrev` and `:newrev` @param [Gitlab::Git::RawDiffChange] raw_change",
        "label": "Property",
        "id": "5863"
    },
    {
        "raw_code": "def root\n      application && application.config.root\n    end",
        "comment": "Returns a Pathname object of the current \\Rails project, otherwise it returns +nil+ if there is no project:  Rails.root # => #<Pathname:/Users/someuser/some/path/project>",
        "label": "Property",
        "id": "14618"
    },
    {
        "raw_code": "def extract_fingerprints_from_file(file_path)\n    queries = extract_queries_from_file(file_path)\n    Set.new(queries.filter_map { |q| q['fingerprint'] })\n  end",
        "comment": "Extract just the fingerprint strings from a file Returns a Set of fingerprint strings",
        "label": "Property",
        "id": "5281"
    },
    {
        "raw_code": "def can_test?(feature)\n        raise ArgumentError, %(Unknown feature \"#{feature}\") unless SUPPORTED_FEATURES.include? feature\n\n        enabled?(ENV[SUPPORTED_FEATURES[feature]], default: true)\n      end",
        "comment": "Returns true if there is an environment variable that indicates that the feature is supported in the environment under test. All features are supported by default.",
        "label": "Property",
        "id": "4463"
    },
    {
        "raw_code": "def end_of_year\n      change(month: 12).end_of_month\n    end",
        "comment": "Returns a new date/time representing the end of the year. DateTime objects will have a time set to 23:59:59.",
        "label": "Property",
        "id": "14168"
    },
    {
        "raw_code": "def added?(attribute, type = :invalid, options = {})\n      attribute, type, options = normalize_arguments(attribute, type, **options)\n\n      if type.is_a? Symbol\n        @errors.any? { |error|\n          error.strict_match?(attribute, type, **options)\n        }\n      else\n        messages_for(attribute).include?(type)\n      end",
        "comment": "Returns +true+ if an error matches provided +attribute+ and +type+, or +false+ otherwise. +type+ is treated the same as for +add+.  person.errors.add :name, :blank person.errors.added? :name, :blank           # => true person.errors.added? :name, \"can't be blank\" # => true  If the error requires options, then it returns +true+ with the correct options, or +false+ with incorrect or missing options.  person.errors.add :name, :too_long, count: 25 person.errors.added? :name, :too_long, count: 25                     # => true person.errors.added? :name, \"is too long (maximum is 25 characters)\" # => true person.errors.added? :name, :too_long, count: 24                     # => false person.errors.added? :name, :too_long                                # => false person.errors.added? :name, \"is too long\"                            # => false",
        "label": "Property",
        "id": "12233"
    },
    {
        "raw_code": "def tags\n      super.map do |tag|\n        name = tag.delete_prefix(Gitlab::Git::TAG_REF_PREFIX)\n        {\n          name: name,\n          path: tag.delete_prefix('refs/'),\n          web_path: project_tag_path(project, id: name)\n        }\n      end",
        "comment": "Note: this returns the path key as 'tags/tag_name' but it is used as a URL in the UI",
        "label": "Property",
        "id": "5412"
    },
    {
        "raw_code": "def foo; end\n          end",
        "comment": "{access_modifier}",
        "label": "Property",
        "id": "10877"
    },
    {
        "raw_code": "def initialize(ip, port: nil)\n        @ip = ip\n        @port = port\n      end",
        "comment": "Argument ip should be an IPAddr object",
        "label": "Property",
        "id": "2797"
    },
    {
        "raw_code": "def all_eager_load_paths # :nodoc:\n        eager_load_paths + paths.eager_load\n      end",
        "comment": "Private method that adds custom eager load paths to the ones defined by +paths+.",
        "label": "Property",
        "id": "14726"
    },
    {
        "raw_code": "def self.all_completed?(job_ids)\n      self.num_running(job_ids) == 0\n    end",
        "comment": "Returns true if all the given job have been completed.  job_ids - The Sidekiq job IDs to check.  Returns true or false.",
        "label": "Property",
        "id": "1470"
    },
    {
        "raw_code": "def init\n  return if object.docstring.blank? && !object.has_tag?(:api)\n  sections :index, [:private, :deprecated, :abstract, :todo, :note, :returns_void, :text], T('tags')\nend",
        "comment": "frozen_string_literal: true",
        "label": "Property",
        "id": "741"
    },
    {
        "raw_code": "def wait_for_ready(duration)\n          # By default, we implement a naive solution.\n          begin\n            Timeout.timeout(duration) do\n              while true\n                return true if ready?\n                sleep 0.5\n              end",
        "comment": "wait_for_ready waits until the communicator is ready, blocking until then. It will wait up to the given duration or raise an exception if something goes wrong.  @param [Integer] duration Timeout in seconds. @return [Boolean] Will return true on successful connection or false on timeout.",
        "label": "Property",
        "id": "9133"
    },
    {
        "raw_code": "def deep_dup\n    map(&:deep_dup)\n  end",
        "comment": "Returns a deep copy of array.  array = [1, [2, 3]] dup   = array.deep_dup dup[1][2] = 4  array[1][2] # => nil dup[1][2]   # => 4",
        "label": "Property",
        "id": "14310"
    },
    {
        "raw_code": "def to_s\n    sanitized.to_s\n  end",
        "comment": "Returns the sanitized version of the filename.",
        "label": "Property",
        "id": "13629"
    },
    {
        "raw_code": "def remove_timestamps(table_name, **options)\n        remove_columns table_name, :updated_at, :created_at\n      end",
        "comment": "Removes the timestamp columns (+created_at+ and +updated_at+) from the table definition.  remove_timestamps(:suppliers) ",
        "label": "Property",
        "id": "13173"
    },
    {
        "raw_code": "def self.completed_jids(job_ids)\n      statuses = job_status(job_ids)\n\n      completed = []\n      job_ids.zip(statuses).each do |job_id, status|\n        completed << job_id unless status\n      end",
        "comment": "Returns the JIDs that are completed  job_ids - The Sidekiq job IDs to check.  Returns an array of completed JIDs",
        "label": "Property",
        "id": "1475"
    },
    {
        "raw_code": "def cache_key\n      if new_record?\n        \"#{model_name.cache_key}/new\"\n      else\n        if cache_version\n          \"#{model_name.cache_key}/#{id}\"\n        else\n          timestamp = max_updated_column_timestamp\n\n          if timestamp\n            timestamp = timestamp.utc.to_fs(cache_timestamp_format)\n            \"#{model_name.cache_key}/#{id}-#{timestamp}\"\n          else\n            \"#{model_name.cache_key}/#{id}\"\n          end",
        "comment": "Returns a stable cache key that can be used to identify this record.  Product.new.cache_key     # => \"products/new\" Product.find(5).cache_key # => \"products/5\"  If ActiveRecord::Base.cache_versioning is turned off, as it was in \\Rails 5.1 and earlier, the cache key will also include a version.  Product.cache_versioning = false Product.find(5).cache_key  # => \"products/5-20071224150000\" (updated_at available)",
        "label": "Property",
        "id": "12481"
    },
    {
        "raw_code": "def connection_db_config\n      connection_pool.db_config\n    end",
        "comment": "Returns the db_config object from the associated connection:  ActiveRecord::Base.connection_db_config #<ActiveRecord::DatabaseConfigurations::HashConfig:0x00007fd1acbded10 @env_name=\"development\", @name=\"primary\", @config={pool: 5, timeout: 5000, database: \"storage/development.sqlite3\", adapter: \"sqlite3\"}>  Use only for reading.",
        "label": "Property",
        "id": "12411"
    },
    {
        "raw_code": "def matches_file?(filename)\n          @in_files ||= nil # avoid ruby warnings\n          return true unless @in_files\n          @in_files.any? do |in_file|\n            case in_file\n            when String\n              File.basename(filename) == in_file\n            when Regexp\n              filename =~ in_file\n            else\n              true\n            end",
        "comment": "@return [Boolean] whether the filename matches the declared file match for a handler. If no file match is specified, returns true. @since 0.6.2",
        "label": "Property",
        "id": "175"
    },
    {
        "raw_code": "def to_f\n      utc.to_f\n    end",
        "comment": "Returns the object's date and time as a floating-point number of seconds since the Epoch (January 1, 1970 00:00 UTC).  Time.zone.now.to_f # => 1417709320.285418",
        "label": "Property",
        "id": "13988"
    },
    {
        "raw_code": "def blank?(only_visible_tags = true)\n      if only_visible_tags\n        empty? && !tags.any? {|tag| Tags::Library.visible_tags.include?(tag.tag_name.to_sym) }\n      else\n        empty? && @tags.empty? && @ref_tags.empty?\n      end",
        "comment": "Returns true if the docstring has no content that is visible to a template.  @param [Boolean] only_visible_tags whether only {Tags::Library.visible_tags} should be checked, or if all tags should be considered. @return [Boolean] whether or not the docstring has content",
        "label": "Property",
        "id": "136"
    },
    {
        "raw_code": "def lookup_container(id, list_all = false)\n        container_ps = \"sudo #{@container_command} ps -q\"\n        container_ps << \" -a\" if list_all\n        @machine.communicate.tap do |comm|\n          return comm.test(\"#{container_ps} --no-trunc | grep -wFq #{id}\")\n        end",
        "comment": "Looks up if a container with a given id exists using the `ps` command. Returns Boolean  @param String - Image id",
        "label": "Property",
        "id": "9923"
    },
    {
        "raw_code": "def do_something\n            end",
        "comment": "{access_modifier}",
        "label": "Property",
        "id": "10849"
    },
    {
        "raw_code": "def design_version_added(version)\n      events = DesignManagement::Action.events\n      link_href = designs_path(version: version.id)\n\n      version.designs_by_event.map do |(event_name, designs)|\n        note_data = self.class.design_event_note_data(events[event_name])\n        icon_name = note_data[:icon]\n        n = designs.size\n\n        body = \"%s [%d %s](%s)\" % [note_data[:past_tense], n, 'design'.pluralize(n), link_href]\n\n        create_note(NoteSummary.new(noteable, project, author, body, action: icon_name))\n      end",
        "comment": "Parameters: - version [DesignManagement::Version]  Example Note text:  \"added [1 designs](link-to-version)\" \"changed [2 designs](link-to-version)\"  Returns [Array<Note>]: the created Note objects",
        "label": "Property",
        "id": "5598"
    },
    {
        "raw_code": "def self.add_post_processor # :nodoc:\n    RDoc::Markup::PreProcess.post_process do |comment, code_object|\n      next unless code_object and\n                  RDoc::Comment === comment and comment.format == 'tomdoc'\n\n      comment.text.gsub!(/(\\A\\s*# )(Public|Internal|Deprecated):\\s+/) do\n        section = code_object.add_section $2\n        code_object.temporary_section = section\n\n        $1\n      end",
        "comment": "Internal: Adds a post-processor which sets the RDoc section based on the comment's status.  Returns nothing.",
        "label": "Property",
        "id": "15503"
    },
    {
        "raw_code": "def current\n        Gitlab::Cache::Import::Caching.read_integer(cache_key) || 1\n      end",
        "comment": "Returns the current value from the cache.",
        "label": "Property",
        "id": "2927"
    },
    {
        "raw_code": "def in_hours\n      in_seconds / SECONDS_PER_HOUR.to_f\n    end",
        "comment": "Returns the amount of hours a duration covers as a float  1.day.in_hours # => 24.0",
        "label": "Property",
        "id": "13821"
    },
    {
        "raw_code": "def lock_writes_on_table(table_name, connection, database_name)\n        @result << lock_writes_manager(table_name, connection, database_name).lock_writes\n        return unless @include_partitions\n\n        table_attached_partitions(table_name, connection) do |postgres_partition|\n          @result << lock_writes_manager(postgres_partition.identifier, connection, database_name).lock_writes\n        end",
        "comment": "It locks the writes on the table and its partitions",
        "label": "Property",
        "id": "2959"
    },
    {
        "raw_code": "def self.normalized_base_url(url)\n      parsed = Utils.parse_url(url)\n      return unless parsed\n\n      if parsed.port\n        format(\"%{scheme}://%{host}:%{port}\", scheme: parsed.scheme, host: parsed.host, port: parsed.port)\n      else\n        format(\"%{scheme}://%{host}\", scheme: parsed.scheme, host: parsed.host)\n      end",
        "comment": "Returns hostname of a URL.  @param url [String] URL to parse @return [String|Nilclass] Normalized base URL, or nil if url was unparsable.",
        "label": "Property",
        "id": "1726"
    },
    {
        "raw_code": "def resolve_relative_path(path, base_path)\n        p = Pathname(base_path)\n        p = p.dirname unless p.extname.empty?\n        p += path\n\n        p.cleanpath.to_s\n      end",
        "comment": "Resolves the given relative path of file in repository into canonical path based on the specified base_path.  Examples:  # File in the same directory as the current path resolve_relative_path(\"users.adoc\", \"doc/api/README.adoc\") # => \"doc/api/users.adoc\"  # File in the same directory, which is also the current path resolve_relative_path(\"users.adoc\", \"doc/api\") # => \"doc/api/users.adoc\"  # Going up one level to a different directory resolve_relative_path(\"../update/7.14-to-8.0.adoc\", \"doc/api/README.adoc\") # => \"doc/update/7.14-to-8.0.adoc\"  Returns a String",
        "label": "Property",
        "id": "2864"
    },
    {
        "raw_code": "def extract!\n    return to_enum(:extract!) { size } unless block_given?\n\n    extracted_elements = []\n\n    reject! do |element|\n      extracted_elements << element if yield(element)\n    end",
        "comment": "Removes and returns the elements for which the block returns a true value. If no block is given, an Enumerator is returned instead.  numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] odd_numbers = numbers.extract! { |number| number.odd? } # => [1, 3, 5, 7, 9] numbers # => [0, 2, 4, 6, 8]",
        "label": "Property",
        "id": "14100"
    },
    {
        "raw_code": "def self.read_integer(raw_key, timeout: TIMEOUT)\n          value = read(raw_key, timeout: timeout)\n\n          value.to_i if value.present?\n        end",
        "comment": "Reads an integer from the cache, or returns nil if no value was found.  See Caching.read for more information.",
        "label": "Property",
        "id": "1939"
    },
    {
        "raw_code": "def gem_signature(gem_full_name)\n    require 'digest'\n\n    Digest::SHA256.new.hexdigest(@gems[gem_full_name].to_yaml).to_s\n  end",
        "comment": " The signature for the given gem specification.",
        "label": "Property",
        "id": "274"
    },
    {
        "raw_code": "def line\n        @files.first ? @files.first[1] : nil\n      end",
        "comment": "Returns the line the object was first parsed at (or nil)  @return [Fixnum] the line where the object was first defined. @return [nil] if there is no line associated with the object",
        "label": "Property",
        "id": "571"
    },
    {
        "raw_code": "def parent; end\n\n      # Custom attributes to be included in the worker context.\n      def application_context\n        { related_class: self.class.to_s }\n      end\n\n      # Exclude binary columns by default - they have no sensible JSON encoding\n      def serializable_hash(options = nil)\n        options = options.try(:dup) || {}\n        options[:except] = Array(options[:except]).dup\n        options[:except].concat [:encrypted_url_variables, :encrypted_url_variables_iv]\n\n        super\n      end\n\n      def interpolated_url(url = self.url, url_variables = self.url_variables)\n        return url unless url.include?('{')\n\n        vars = url_variables\n        url.gsub(VARIABLE_REFERENCE_RE) do |match|\n          vars.fetch(match.delete_prefix('{').delete_suffix('}'))\n        end\n      rescue KeyError => e\n        raise InterpolationError, \"Invalid URL template. Missing key #{e.key}\"\n      end",
        "comment": "Returns the associated Project or Group for the WebHook if one exists. Overridden by inheriting classes.",
        "label": "Property",
        "id": "7497"
    },
    {
        "raw_code": "def api_comments_path\n        \"#{api_get_path}/notes\"\n      end",
        "comment": "Comments (notes) path  @return [String]",
        "label": "Property",
        "id": "4200"
    },
    {
        "raw_code": "def generate_connect_cli_arguments(options)\n          options.map do |key, value|\n            # If value is false, option is not set\n            next if value.to_s == \"false\"\n            # If value is true, consider feature flag with no value\n            opt = value.to_s == \"true\" ? [] : [value]\n            opt.unshift(\"--#{key.to_s.tr(\"_\", \"-\")}\")\n          end.flatten.compact\n        end",
        "comment": "Generate CLI arguments for creating the docker network.  @param [Hash] options Options from the network config @returns[Array<String> Network create arguments",
        "label": "Property",
        "id": "9516"
    },
    {
        "raw_code": "def top_level_glob?(glob)\n          glob.exclude?('/') && glob.exclude?('**')\n        end",
        "comment": "matches glob patterns that only match files in the top level directory",
        "label": "Property",
        "id": "2470"
    },
    {
        "raw_code": "def type(node)\n            pg_type = parse_node(node.names.last)\n            type = PgTypes::TYPES.fetch(pg_type).dup\n            array_ext = '[]' if node.array_bounds.any?\n            precision_ext = \"(#{node.typmods.map { |typmod| parse_node(typmod) }.join(',')})\" if node.typmods.any?\n\n            if %w[timestamp timestamptz].include?(pg_type)\n              type.gsub!('timestamp', ['timestamp', precision_ext].compact.join)\n              precision_ext = nil\n            end",
        "comment": "Returns the node type  pg_type:: type alias, used internally by postgres, +int4+, +int8+, +bool+, +varchar+ type:: type name, like +integer+, +bigint+, +boolean+, +character varying+. array_ext:: adds the +[]+ extension for array types. precision_ext:: adds the precision, if have any, like +(255)+, +(6)+.  @info +timestamp+ and +timestamptz+ have a particular case when precision is defined. In this case, the order of the statement needs to be re-arranged from timestamp without time zone(6) to timestamp(6) without a time zone.",
        "label": "Property",
        "id": "1179"
    },
    {
        "raw_code": "def perform_bulk(*args, **kwargs)\n        Setter.new(self, {}).perform_bulk(*args, **kwargs)\n      end",
        "comment": " Push a large number of jobs to Redis, while limiting the batch of each job payload to 1,000. This method helps cut down on the number of round trips to Redis, which can increase the performance of enqueueing large numbers of jobs.  +items+ must be an Array of Arrays.  For finer-grained control, use `Sidekiq::Client.push_bulk` directly.  Example (3 Redis round trips):  SomeJob.perform_async(1) SomeJob.perform_async(2) SomeJob.perform_async(3)  Would instead become (1 Redis round trip):  SomeJob.perform_bulk([[1], [2], [3]]) ",
        "label": "Property",
        "id": "5177"
    },
    {
        "raw_code": "def change\n    create_table(:p_ci_pipelines_config, primary_key: [:pipeline_id, :partition_id],\n      options: 'PARTITION BY LIST (partition_id)') do |t|\n      t.bigint :pipeline_id, null: false\n      t.bigint :partition_id, null: false\n      t.text :content, null: false\n    end",
        "comment": "rubocop:disable Migration/EnsureFactoryForTable -- No factory needed rubocop:disable Migration/AddLimitToTextColumns -- keeps compatibility with existing table",
        "label": "Property",
        "id": "5013"
    },
    {
        "raw_code": "def fetch_and_update_cache!\n        parsed_response = fetch_google_ip_list\n\n        parse_google_prefixes(parsed_response).tap do |subnets|\n          ::ObjectStorage::CDN::GoogleIpCache.update!(subnets)\n        end",
        "comment": "Attempts to retrieve and parse the list of IPs from Google. Updates the internal cache so that the data is accessible.  Returns an array of IPAddr objects consisting of subnets.",
        "label": "Property",
        "id": "5693"
    },
    {
        "raw_code": "def _HtmlBlockCloseP\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseP = \"<\" Spnl \"/\" (\"p\" | \"P\") Spnl \">\"",
        "label": "Property",
        "id": "15681"
    },
    {
        "raw_code": "def down\n    create_table TABLE_NAME do |t|\n      t.bigint :project_id, null: false\n      t.bigint :prometheus_alert_id, null: false\n      t.datetime_with_timezone :started_at, null: false\n      t.datetime_with_timezone :ended_at\n      t.integer :status, limit: 2\n      t.string :payload_key\n\n      t.index [:prometheus_alert_id, :payload_key], name: UNIQUE_INDEX_NAME, unique: true\n      t.index [:project_id, :status], name: STATUS_INDEX\n    end",
        "comment": "Original SQL:  CREATE TABLE prometheus_alert_events ( id bigint NOT NULL, project_id bigint NOT NULL, prometheus_alert_id bigint NOT NULL, started_at timestamp with time zone NOT NULL, ended_at timestamp with time zone, status smallint, payload_key character varying );  CREATE SEQUENCE prometheus_alert_events_id_seq START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1;  ALTER SEQUENCE prometheus_alert_events_id_seq OWNED BY prometheus_alert_events.id;  CREATE UNIQUE INDEX index_prometheus_alert_event_scoped_payload_key ON prometheus_alert_events USING btree (prometheus_alert_id, payload_key);  CREATE INDEX index_prometheus_alert_events_on_project_id_and_status ON prometheus_alert_events USING btree (project_id, status); ",
        "label": "Property",
        "id": "4906"
    },
    {
        "raw_code": "def self.write_if_greater(raw_key, value, timeout: TIMEOUT)\n          validate_redis_value!(value)\n\n          key = cache_key_for(raw_key)\n          val = with_redis do |redis|\n            redis\n              .eval(WRITE_IF_GREATER_SCRIPT, keys: [key], argv: [value, timeout])\n          end",
        "comment": "Sets a key to the given integer but only if the existing value is smaller than the given value.  This method uses a Lua script to ensure the read and write are atomic.  raw_key - The key to set. value - The new value for the key. timeout - The key timeout in seconds.  Returns true when the key was overwritten, false otherwise.",
        "label": "Property",
        "id": "1951"
    },
    {
        "raw_code": "def up\n    # rubocop:disable Migration/PreventIndexCreation -- Legacy migration\n    prepare_async_index :sent_notifications, COLUMN_NAMES, where: \"noteable_type = 'Issue'\", name: INDEX_NAME\n    # rubocop:enable Migration/PreventIndexCreation\n  end",
        "comment": "Index to be created synchronously in https://gitlab.com/gitlab-org/gitlab/-/issues/502841  This is designed to replace existing index: \"index_sent_notifications_on_noteable_type_noteable_id\" btree (noteable_id) WHERE noteable_type = 'Issue' with \"index_sent_notifications_on_noteable_type_noteable_id_id\" btree (noteable_id, id) WHERE noteable_type = 'Issue' to improve iterating over issue related sent notification records in batches.",
        "label": "Property",
        "id": "4851"
    },
    {
        "raw_code": "def pajamas_sort_by(value, from: nil)\n      raise ArgumentError, 'The :from option must be given' if from.nil?\n\n      click_button from\n      find('[role=\"option\"]', text: value).click\n    end",
        "comment": "pajamas_sort_by is used to sort new pajamas dropdowns. When all of the dropdowns are converted, pajamas_sort_by can be renamed to sort_by https://gitlab.com/groups/gitlab-org/-/epics/7551",
        "label": "Property",
        "id": "8510"
    },
    {
        "raw_code": "def super_sidebar_menu_items\n      @super_sidebar_menu_items ||= renderable_menus\n        .flat_map(&:serialize_for_super_sidebar)\n    end",
        "comment": "Serializes every renderable menu and returns a flattened result",
        "label": "Property",
        "id": "3686"
    },
    {
        "raw_code": "def initialize(attributes)\n          @attributes = attributes\n        end",
        "comment": "attributes - A Hash containing the user details. The keys of this Hash (and any nested hashes) must be symbols.",
        "label": "Property",
        "id": "2270"
    },
    {
        "raw_code": "def reportable_jira_ruby_error_message(error)\n        case error.message\n        when 'Unauthorized'\n          safe_format(s_('JiraRequest|The credentials for accessing Jira are not valid. Check your %{docs_link_start}Jira integration credentials%{docs_link_end} and try again.'), docs_link_start: auth_docs_link_start, docs_link_end: '</a>'.html_safe)\n        when 'Forbidden'\n          safe_format(s_('JiraRequest|The credentials for accessing Jira are not allowed to access the data. Check your %{docs_link_start}Jira integration credentials%{docs_link_end} and try again.'), docs_link_start: auth_docs_link_start, docs_link_end: '</a>'.html_safe)\n        when 'Bad Request'\n          jira_ruby_json_error_message(error.response.body) || safe_format(s_('JiraRequest|An error occurred while requesting data from Jira. Check your %{docs_link_start}Jira integration configuration%{docs_link_end} and try again.'), docs_link_start: config_docs_link_start, docs_link_end: '</a>'.html_safe)\n        end",
        "comment": "Returns a user-facing error message for a `JIRA::HTTPError` if possible, otherwise `nil`.",
        "label": "Property",
        "id": "6038"
    },
    {
        "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
        "comment": "Returns the currently loaded version of Active Support as a +Gem::Version+.",
        "label": "Property",
        "id": "13870"
    },
    {
        "raw_code": "def list_pages(\n    direction: DIRECTION_ASC,\n    load_content: false,\n    size_limit: Gitlab::Git::Blob::MAX_DATA_DISPLAY_SIZE,\n    limit: 0,\n    offset: 0\n  )\n    capture_git_error(:list, response_on_error: []) do\n      create_wiki_repository unless repository_exists?\n\n      paths = list_page_paths(limit: limit, offset: offset)\n      next [] if paths.empty?\n\n      pages = paths.map do |path|\n        page = Gitlab::Git::WikiPage.new(\n          url_path: strip_extension(path),\n          title: canonicalize_filename(path),\n          format: find_page_format(path),\n          path: path,\n          raw_data: '',\n          name: canonicalize_filename(path),\n          historical: false\n        )\n        WikiPage.new(self, page)\n      end",
        "comment": "Lists wiki pages of the repository.  limit - max number of pages returned by the method. sort - criterion by which the pages are sorted. direction - order of the sorted pages. load_content - option, which specifies whether the content inside the page will be loaded.  Returns an Array of GitLab WikiPage instances or an empty Array if this Wiki has no pages.",
        "label": "Property",
        "id": "6909"
    },
    {
        "raw_code": "def initialize(runner, project, user, quiet: false)\n        @runner = runner\n        @project = project\n        @user = user\n        @quiet = quiet\n      end",
        "comment": "@param [Ci::Runner] runner: the runner to assign to a project @param [Project] project: the new project to assign the runner to @param [User] user: the user performing the operation @param [Boolean] quiet: true if service should avoid side effects, such as logging (e.g. when used by another service)",
        "label": "Property",
        "id": "5832"
    },
    {
        "raw_code": "def destroy_all\n        sum do |relation|\n          relation.destroy_all.count(&:destroyed?)\n        end",
        "comment": "Destroys records in batches. Returns the total number of rows affected.  Person.where(\"age < 10\").in_batches.destroy_all  See Relation#destroy_all for details of how each batch is destroyed.",
        "label": "Property",
        "id": "13446"
    },
    {
        "raw_code": "def analyzed?\n    analyzed\n  end",
        "comment": "Returns true if the blob has been analyzed.",
        "label": "Property",
        "id": "13649"
    },
    {
        "raw_code": "def error\n      ActiveSupport.error_reporter\n    end",
        "comment": "Returns the ActiveSupport::ErrorReporter of the current \\Rails project, otherwise it returns +nil+ if there is no project.  Rails.error.handle(IOError) do # ... end Rails.error.report(error)",
        "label": "Property",
        "id": "14621"
    },
    {
        "raw_code": "def accept_table(header, body, aligns)\n    widths = header.zip(*body).map do |cols|\n      cols.map(&:size).max\n    end",
        "comment": " Adds +table+ to the output",
        "label": "Property",
        "id": "16206"
    },
    {
        "raw_code": "def invoke(full_namespace, args = [], **config)\n        args = [\"--help\"] if rails_new_with_no_path?(args)\n\n        full_namespace = full_namespace.to_s\n        namespace, command_name = split_namespace(full_namespace)\n        command = find_by_namespace(namespace, command_name)\n\n        with_argv(args) do\n          if command && command.all_commands[command_name]\n            command.perform(command_name, args, config)\n          else\n            invoke_rake(full_namespace, args, config)\n          end",
        "comment": "Receives a namespace, arguments, and the behavior to invoke the command.",
        "label": "Property",
        "id": "14653"
    },
    {
        "raw_code": "def ==(other)\n    self.class === other and @relative_name == other.relative_name\n  end",
        "comment": " An RDoc::TopLevel is equal to another with the same relative_name",
        "label": "Property",
        "id": "16714"
    },
    {
        "raw_code": "def parse_symbol_in_arg\n    tk = get_tk\n    if :on_symbol == tk[:kind] then\n      tk[:text].sub(/^:/, '')\n    elsif :on_tstring == tk[:kind] then\n      tk[:text][1..-2]\n    elsif :on_dstring == tk[:kind] or :on_ident == tk[:kind] then\n      nil # ignore\n    else\n      warn(\"Expected symbol or string, got #{tk.inspect}\") if $DEBUG_RDOC\n      nil\n    end",
        "comment": " Returns symbol text from the next token",
        "label": "Property",
        "id": "16116"
    },
    {
        "raw_code": "def up\n    validate_foreign_key(:epics, :issue_id, name: NEW_FK_NAME)\n  end",
        "comment": "foreign key added in FixEpicsCascadeOptionOnFkToIssueId",
        "label": "Property",
        "id": "5032"
    },
    {
        "raw_code": "def tomorrow\n      today + 1\n    end",
        "comment": "Returns the next date in this time zone.",
        "label": "Property",
        "id": "14576"
    },
    {
        "raw_code": "def in_app_directory?(node, directory)\n      file_path_for_node(node).start_with?(\n        File.join(ce_app_directory, directory),\n        File.join(ee_app_directory, directory)\n      )\n    end",
        "comment": "Returns `true` if the given AST node resides in the given directory, relative to app and/or ee/app.",
        "label": "Property",
        "id": "3893"
    },
    {
        "raw_code": "def parallel_diff_lines\n        @parallel_diff_lines ||= Gitlab::Diff::ParallelDiff.new(self).parallelize\n      end",
        "comment": "Array[<Hash>] with right/left keys that contains Gitlab::Diff::Line objects which text is highlighted",
        "label": "Property",
        "id": "2713"
    },
    {
        "raw_code": "def self.path(system = true, site = true, home = true, gems = :latest, *extra_dirs)\n    path = raw_path system, site, home, gems, *extra_dirs\n\n    path.select { |directory| File.directory? directory }\n  end",
        "comment": " Returns existing directories from the selected documentation directories as an Array.  See also ::each",
        "label": "Property",
        "id": "16562"
    },
    {
        "raw_code": "def pipeline_result(body, context = {})\n    context.reverse_merge!(project: project) if defined?(project)\n\n    pipeline = Banzai::PipelineBase.new([described_class], context)\n    pipeline.call(body)\n  end",
        "comment": "Run text through HTML::Pipeline with the current filter and return the result Hash  body     - String text to run through the pipeline context - Hash context for the filter. (default: {project: project})  Returns the Hash",
        "label": "Property",
        "id": "8447"
    },
    {
        "raw_code": "def config\n      @config ||= deep_symbolize_keys(deserialize(read))\n    end",
        "comment": "Returns the decrypted content as a Hash with symbolized keys.  my_config = ActiveSupport::EncryptedConfiguration.new(...) my_config.read # => \"some_secret: 123\\nsome_namespace:\\n  another_secret: 456\"  my_config.config # => { some_secret: 123, some_namespace: { another_secret: 789 } } ",
        "label": "Property",
        "id": "13834"
    },
    {
        "raw_code": "def self.version\n    gem_version\n  end",
        "comment": "Returns the currently loaded version of Active Record as a +Gem::Version+.",
        "label": "Property",
        "id": "12742"
    },
    {
        "raw_code": "def merge_blocked_by_new_changes?\n          has_element?('head-mismatch-content', wait: 1)\n        end",
        "comment": "Returns true when widget shows \"Merge blocked: new changes were just added\"",
        "label": "Property",
        "id": "4298"
    },
    {
        "raw_code": "def id_in_database\n        attribute_in_database(@primary_key)\n      end",
        "comment": "Returns the primary key column's value from the database. If the primary key is composite, returns an array of primary key column values from database.",
        "label": "Property",
        "id": "12857"
    },
    {
        "raw_code": "def self.parse(rd)\n    rd = rd.lines.to_a\n\n    if rd.find { |i| /\\S/ === i } and !rd.find{|i| /^=begin\\b/ === i } then\n      rd.unshift(\"=begin\\n\").push(\"=end\\n\")\n    end",
        "comment": " Parses +rd+ source and returns an RDoc::Markup::Document.  If the <tt>=begin</tt> or <tt>=end</tt> lines are missing they will be added.",
        "label": "Property",
        "id": "15968"
    },
    {
        "raw_code": "def truncated_new_commits(commits, start_rev)\n      count = commits.size\n\n      commit_ids = if count == 1\n                     commits.first.short_id\n                   elsif start_rev && !Gitlab::Git.blank_ref?(start_rev)\n                     \"#{Commit.truncate_sha(start_rev)}...#{commits.last.short_id}\"\n                   else\n                     # This two-dots notation seems to be not functioning as expected, but we should\n                     # fallback to it as start_rev can be empty.\n                     #\n                     # For more information, please see https://gitlab.com/gitlab-org/gitlab/-/issues/391809\n                     \"#{commits.first.short_id}..#{commits.last.short_id}\"\n                   end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord Builds a summary line that describes given truncated commits.  commits - Array of Commit objects start_rev - String SHA of a Commit that will be used as the starting SHA of the range  Returns a String wrapped in 'li' tag.",
        "label": "Property",
        "id": "5607"
    },
    {
        "raw_code": "def store_path(entry)\n    fs.store(\n      path_key(entry.path),\n      entry.fingerprint,\n      content_type: \"text/plain; charset=us-ascii\",\n      metadata: entry.metadata\n    )\n  end",
        "comment": "@param [RubygemContents::Entry] entry",
        "label": "Property",
        "id": "9999"
    },
    {
        "raw_code": "def self_and_hierarchy\n        object_hierarchy(self.class.where(id: id))\n          .all_objects\n      end",
        "comment": "Returns all ancestors, self, and descendants of the current namespace.",
        "label": "Property",
        "id": "7192"
    },
    {
        "raw_code": "def self.acceptable_attributes\n      attribute_map.values\n    end",
        "comment": "Returns all the JSON keys this model knows about",
        "label": "Property",
        "id": "950"
    },
    {
        "raw_code": "def self.normalize_uid(uid)\n          ::Gitlab::Auth::Ldap::DN.normalize_value(uid)\n        rescue ::Gitlab::Auth::Ldap::DN::FormatError => e\n          Gitlab::AppLogger.info(\"Returning original UID \\\"#{uid}\\\" due to error during normalization attempt: #{e.message}\")\n\n          uid\n        end",
        "comment": "Returns the UID in a normalized form.  1. Excess spaces are stripped 2. The string is downcased (for case-insensitivity)",
        "label": "Property",
        "id": "2356"
    },
    {
        "raw_code": "def initialize(checker, defaults, file_content)\n          @checker = checker\n          @defaults = defaults\n          @file_content = file_content\n        end",
        "comment": "Defaults are strings like: self.yjit action_controller.escape_json_responses",
        "label": "Property",
        "id": "14830"
    },
    {
        "raw_code": "def previewable?\n    ActiveStorage.previewers.any? { |klass| klass.accept?(self) }\n  end",
        "comment": "Returns true if any registered previewer accepts the blob. By default, this will return true for videos and PDF documents.",
        "label": "Property",
        "id": "13653"
    },
    {
        "raw_code": "def array_column?(node)\n      node.each_descendant(:pair).any? do |pair_node|\n        pair_node.child_nodes[0].sym_type? && # Searching for a RuboCop::AST::SymbolNode\n          pair_node.child_nodes[0].value == :array && # Searching for a (pair (sym :array) (true)) node\n          pair_node.child_nodes[1].type == :true # RuboCop::AST::Node uses symbols for types, even when that is a :true\n      end",
        "comment": "Returns true if a column definition is for an array, like { array: true }  @example add_column :table, :ids, :integer, array: true, default: []  rubocop:disable Lint/BooleanSymbol",
        "label": "Property",
        "id": "3863"
    },
    {
        "raw_code": "def length\n      @rows.length\n    end",
        "comment": "Returns the number of elements in the rows array.",
        "label": "Property",
        "id": "12670"
    },
    {
        "raw_code": "def self.internal_events\n          INTERNAL_EVENTS\n        end",
        "comment": "Events that are specific to the 7 default stages",
        "label": "Property",
        "id": "2868"
    },
    {
        "raw_code": "def change_column_comment(table_name, column_name, comment_or_changes) # :nodoc:\n          clear_cache!\n          comment = extract_new_comment_value(comment_or_changes)\n          execute \"COMMENT ON COLUMN #{quote_table_name(table_name)}.#{quote_column_name(column_name)} IS #{quote(comment)}\"\n        end",
        "comment": "Adds comment for given table column or drops it if +comment+ is a +nil+",
        "label": "Property",
        "id": "13261"
    },
    {
        "raw_code": "def add_word_pair(start, stop, name, exclusive = false)\n    raise ArgumentError, \"Word flags may not start with '<'\" if\n      start[0, 1] == '<'\n\n    bitmap = @attributes.bitmap_for name\n\n    if start == stop then\n      @matching_word_pairs[start] = bitmap\n    else\n      pattern = /(#{Regexp.escape start})(\\S+)(#{Regexp.escape stop})/\n      @word_pair_map[pattern] = bitmap\n    end",
        "comment": " Adds a markup class with +name+ for words wrapped in the +start+ and +stop+ character.  To make words wrapped with \"*\" bold:  am.add_word_pair '*', '*', :BOLD",
        "label": "Property",
        "id": "16234"
    },
    {
        "raw_code": "def message\n      Rack::Utils::HTTP_STATUS_CODES[@status]\n    end",
        "comment": "Returns the corresponding message for the current HTTP status code:  response.status = 200 response.message # => \"OK\"  response.status = 404 response.message # => \"Not Found\" ",
        "label": "Property",
        "id": "11475"
    },
    {
        "raw_code": "def marshal_dump # :nodoc:\n      [ @source, @identifier, @handler, @compiled, @locals, @virtual_path, @format, @variant ]\n    end",
        "comment": "Exceptions are marshalled when using the parallel test runner with DRb, so we need to ensure that references to the template object can be marshalled as well. This means forgoing the marshalling of the compiler mutex and instantiating that again on unmarshalling.",
        "label": "Property",
        "id": "11759"
    },
    {
        "raw_code": "def test_eager_loading_in_modules\n    clients = []\n\n    assert_nothing_raised do\n      clients << MyApplication::Business::Client.references(:accounts).merge!(includes: { firm: :account }, where: \"accounts.id IS NOT NULL\").find(3)\n      clients << MyApplication::Business::Client.includes(firm: :account).find(3)\n    end",
        "comment": "An eager loading condition to force the eager loading model into the old join model.",
        "label": "Property",
        "id": "13523"
    },
    {
        "raw_code": "def nodes_visible_to_user(nodes)\n      per_type = Hash.new { |h, k| h[k] = [] }\n      visible = Set.new\n\n      nodes.each do |node|\n        per_type[node.attr('data-reference-type')] << node\n      end",
        "comment": "Returns the nodes visible to the current user.  nodes - The input nodes to check.  Returns a new Array containing the visible nodes.",
        "label": "Property",
        "id": "3413"
    },
    {
        "raw_code": "def is_utf8?\n    case encoding\n    when Encoding::UTF_8, Encoding::US_ASCII\n      valid_encoding?\n    when Encoding::ASCII_8BIT\n      dup.force_encoding(Encoding::UTF_8).valid_encoding?\n    else\n      false\n    end",
        "comment": "Returns +true+ if string has utf_8 encoding.  utf_8_str = \"some string\".encode \"UTF-8\" iso_str = \"some string\".encode \"ISO-8859-1\"  utf_8_str.is_utf8? # => true iso_str.is_utf8?   # => false",
        "label": "Property",
        "id": "14381"
    },
    {
        "raw_code": "def users_that_can_read_group(users, group)\n      DeclarativePolicy.subject_scope do\n        users.select { |u| allowed?(u, :read_group, group) }\n      end",
        "comment": "Given a list of users and a group this method returns the users that can read the given group.",
        "label": "Property",
        "id": "6832"
    },
    {
        "raw_code": "def self.calculate_ext_conn_complexity\n      false\n    end",
        "comment": "This is a flag to allow us to use `complexity_multiplier` to compute complexity for connection fields(see BaseField#connection_complexity_multiplier) in resolvers that do external connection pagination, thus disabling the default `connection` option.",
        "label": "Property",
        "id": "6168"
    },
    {
        "raw_code": "def filtered_parameters\n        @filtered_parameters ||= parameter_filter.filter(parameters)\n      rescue ActionDispatch::Http::Parameters::ParseError\n        @filtered_parameters = {}\n      end",
        "comment": "Returns a hash of parameters with all sensitive data replaced.",
        "label": "Property",
        "id": "11421"
    },
    {
        "raw_code": "def table_alias_for(table_name)\n        table_name[0...table_alias_length].tr(\".\", \"_\")\n      end",
        "comment": "Truncates a table alias according to the limits of the current adapter.",
        "label": "Property",
        "id": "13127"
    },
    {
        "raw_code": "def self.delete_batch_for(web_hook, batch_size:)\n    raise ArgumentError, 'batch_size is too small' if batch_size < 1\n\n    where(web_hook: web_hook).limit(batch_size).delete_all == batch_size\n  end",
        "comment": "Delete a batch of log records. Returns true if there may be more remaining.",
        "label": "Property",
        "id": "7608"
    },
    {
        "raw_code": "def endpoint\n      self.class.endpoint || routes\n    end",
        "comment": "Returns the endpoint for this engine. If none is registered, defaults to an ActionDispatch::Routing::RouteSet.",
        "label": "Property",
        "id": "14665"
    },
    {
        "raw_code": "def target=(target)\n        @target = target\n        loaded!\n      end",
        "comment": "Sets the target of this association to <tt>\\target</tt>, and the \\loaded flag to +true+.",
        "label": "Property",
        "id": "12749"
    },
    {
        "raw_code": "def second_to_last\n      find_nth_from_last 2\n    end",
        "comment": "Find the second-to-last record. If no order is defined it will order by primary key.  Person.second_to_last # returns the second-to-last object fetched by SELECT * FROM people Person.offset(3).second_to_last # returns the second-to-last object from OFFSET 3 Person.where([\"user_name = :u\", { u: user_name }]).second_to_last",
        "label": "Property",
        "id": "13385"
    },
    {
        "raw_code": "def seconds_since_midnight\n    to_i - change(hour: 0).to_i + (usec / 1.0e+6)\n  end",
        "comment": "Returns the number of seconds since 00:00:00.  Time.new(2012, 8, 29,  0,  0,  0).seconds_since_midnight # => 0.0 Time.new(2012, 8, 29, 12, 34, 56).seconds_since_midnight # => 45296.0 Time.new(2012, 8, 29, 23, 59, 59).seconds_since_midnight # => 86399.0",
        "label": "Property",
        "id": "14392"
    },
    {
        "raw_code": "def packages_path\n            path = gitlab_config.dig(env, 'packages', 'storage_path') ||\n              gitlab_shared_path.join(DEFAULT_PACKAGES)\n\n            absolute_path(path)\n          end",
        "comment": "Packages basepath",
        "label": "Property",
        "id": "1094"
    },
    {
        "raw_code": "def nokogiri?\n      @current_engine == :nokogiri\n    end",
        "comment": "@return [Boolean] Returns true if current engine is `:nokogiri`.",
        "label": "Property",
        "id": "8679"
    },
    {
        "raw_code": "def find_noteable_id\n          GithubImport::IssuableFinder.new(project, note).database_id\n        end",
        "comment": "Returns the ID of the issue or merge request to create the note for.",
        "label": "Property",
        "id": "2202"
    },
    {
        "raw_code": "def issue_assignee_map\n          @map ||= issue.assignees.each_with_object({}) do |assignee, map|\n            gitlab_user_id = user_finder.user_id_for(assignee, ghost: false)\n            next unless gitlab_user_id\n\n            map[gitlab_user_id] = assignee[:id]\n          end",
        "comment": "Returns a Hash of { GitLabUserId => GitHubUserId } that can be used for both importing and pushing user references.",
        "label": "Property",
        "id": "2205"
    },
    {
        "raw_code": "def delete_matched(matcher, options = nil)\n        unless String === matcher\n          raise ArgumentError, \"Only Redis glob strings are supported: #{matcher.inspect}\"\n        end",
        "comment": "Cache Store API implementation.  Supports Redis KEYS glob patterns:  h?llo matches hello, hallo and hxllo h*llo matches hllo and heeeello h[ae]llo matches hello and hallo, but not hillo h[^e]llo matches hallo, hbllo, ... but not hello h[a-b]llo matches hallo and hbllo  Use \\ to escape special characters if you want to match them verbatim.  See https://redis.io/commands/KEYS for more.  Failsafe: Raises errors.",
        "label": "Property",
        "id": "14042"
    },
    {
        "raw_code": "def wildcards_include?(path)\n    described_class::PROJECT_WILDCARD_ROUTES.include?(path) ||\n      described_class::PROJECT_WILDCARD_ROUTES.include?(path.split('/').first)\n  end",
        "comment": "If the path is reserved. Then no conflicting paths can# be created for any route using this reserved word.  Both `builds/artifacts` & `build` are covered by reserving the word `build`",
        "label": "Property",
        "id": "8225"
    },
    {
        "raw_code": "def end_of_week(start_day = Date.beginning_of_week)\n      last_hour(days_since(6 - days_to_week_start(start_day)))\n    end",
        "comment": "Returns a new date/time representing the end of this week on the given day. Week is assumed to start on +start_day+, default is +Date.beginning_of_week+ or +config.beginning_of_week+ when set. DateTime objects have their time set to 23:59:59.",
        "label": "Property",
        "id": "14165"
    },
    {
        "raw_code": "def column_types\n      if @column_types\n        @types_hash ||= begin\n          types = {}\n          @columns.each_with_index do |name, index|\n            type = @column_types[index] || Type.default_value\n            types[name] = types[index] = type\n          end",
        "comment": "Returns the +ActiveRecord::Type+ type of all columns. Note that not all database adapters return the result types, so the hash may be empty.",
        "label": "Property",
        "id": "12675"
    },
    {
        "raw_code": "def is_cached_plan_failure?(pgerror)\n          pgerror.result.result_error_field(PG::PG_DIAG_SQLSTATE) == FEATURE_NOT_SUPPORTED &&\n            pgerror.result.result_error_field(PG::PG_DIAG_SOURCE_FUNCTION) == \"RevalidateCachedQuery\"\n        rescue\n          false\n        end",
        "comment": "Annoyingly, the code for prepared statements whose return value may have changed is FEATURE_NOT_SUPPORTED.  This covers various different error types so we need to do additional work to classify the exception definitively as a ActiveRecord::PreparedStatementCacheExpired  Check here for more details: https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/utils/cache/plancache.c#l573",
        "label": "Property",
        "id": "12979"
    },
    {
        "raw_code": "def base_and_descendant_ids\n      read_only(base_and_descendant_ids_cte.apply_to(unscoped_model.select(objects_table[:id])))\n    end",
        "comment": "Returns a relation that includes ID of the descendants_base set of objects and all their descendants IDs (recursively).",
        "label": "Property",
        "id": "1426"
    },
    {
        "raw_code": "def self.reference_pattern\n    @reference_pattern ||= %r{\n      (#{Project.reference_pattern})?\n      #{Regexp.escape(reference_prefix)}#{Gitlab::Regex.merge_request}\n    }x\n  end",
        "comment": "Pattern used to extract `!123` merge request references from text  This pattern supports cross-project references.",
        "label": "Property",
        "id": "6966"
    },
    {
        "raw_code": "def graphql_data(body = fresh_response_data)\n    body['data'] || (raise NoData, graphql_errors(body))\n  end",
        "comment": "Raises an error if no data is found NB: We use fresh_response_data to support tests that make multiple requests.",
        "label": "Property",
        "id": "8402"
    },
    {
        "raw_code": "def select_all(*, **) # :nodoc:\n          if ExplainRegistry.collect? && prepared_statements\n            unprepared_statement { super }\n          else\n            super\n          end",
        "comment": "Returns an ActiveRecord::Result instance.",
        "label": "Property",
        "id": "13205"
    },
    {
        "raw_code": "def offset(value)\n      spawn.offset!(value)\n    end",
        "comment": "Specifies the number of rows to skip before returning rows.  User.offset(10) # generated SQL has \"OFFSET 10\"  Should be used with order.  User.offset(10).order(\"name ASC\")",
        "label": "Property",
        "id": "13420"
    },
    {
        "raw_code": "def self.public_or_visible_to_user(user = nil, min_access_level = nil)\n    min_access_level = nil if user&.can_read_all_resources?\n\n    return public_to_user unless user\n\n    if user.is_a?(DeployToken)\n      where(id: user.accessible_projects)\n    else\n      where(\n        'EXISTS (?) OR projects.visibility_level IN (?)',\n        user.authorizations_for_projects(min_access_level: min_access_level),\n        self.visibility_levels_for_user(user)\n      )\n    end",
        "comment": "Returns a collection of projects that is either public or visible to the logged in user.",
        "label": "Property",
        "id": "6722"
    },
    {
        "raw_code": "def encrypted?(text)\n        deserialize_message(text)\n        true\n      rescue Errors::Encoding, *DECRYPT_ERRORS\n        false\n      end",
        "comment": "Returns whether the text is encrypted or not.",
        "label": "Property",
        "id": "13316"
    },
    {
        "raw_code": "def foo; end\n        RUBY\n\n        shared_examples 'error handling' do\n          it 'raises an error with the crashing extractor/file' do\n            expect do\n              runner.run([])\n            end.to raise_error(RuboCop::Error, /runner_spec\\.rb failed to process .*example\\.rb/)\n          end",
        "comment": "frozen_string_literal: true",
        "label": "Property",
        "id": "10765"
    },
    {
        "raw_code": "def self.call(event)\n          Gitlab::ErrorTracking::ContextPayloadGenerator.generate(nil, {}).each do |key, value|\n            event.public_send(key).deep_merge!(value) # rubocop:disable GitlabSecurity/PublicSend\n          end",
        "comment": "This processor is added to inject application context into Sentry events generated by Sentry built-in integrations. When the integrations are re-implemented and use Gitlab::ErrorTracking, this processor should be removed.",
        "label": "Property",
        "id": "2787"
    },
    {
        "raw_code": "def ago(other)\n      since(-other)\n    end",
        "comment": "Subtracts an interval of time from the current object's time and returns the result as a new TimeWithZone object.  Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)' now = Time.zone.now # => Mon, 03 Nov 2014 00:26:28.725182881 EST -05:00 now.ago(1000)       # => Mon, 03 Nov 2014 00:09:48.725182881 EST -05:00  If we're subtracting a Duration of variable length (i.e., years, months, days), move backward from #time, otherwise move backward from #utc, for accuracy when moving across DST boundaries.  For instance, <tt>time.ago(24.hours)</tt> will move back exactly 24 hours, while <tt>time.ago(1.day)</tt> will move back 23-25 hours, depending on the day.  now.ago(24.hours)   # => Sun, 02 Nov 2014 01:26:28.725182881 EDT -04:00 now.ago(1.day)      # => Sun, 02 Nov 2014 00:26:28.725182881 EDT -04:00",
        "label": "Property",
        "id": "13984"
    },
    {
        "raw_code": "def update_statistics(project, statistics = [])\n    return if Gitlab::Database.read_only?\n    return unless try_obtain_lease_for(project.id, statistics)\n\n    Projects::UpdateStatisticsService.new(project, nil, statistics: statistics).execute\n\n    lease_key = project_cache_worker_key(project.id, statistics)\n    UpdateProjectStatisticsWorker.perform_in(LEASE_TIMEOUT, lease_key, project.id, statistics)\n  end",
        "comment": "NOTE: triggering both an immediate update and one in 15 minutes if we successfully obtain the lease. That way, we only need to wait for the statistics to become accurate if they were already updated once in the last 15 minutes.",
        "label": "Property",
        "id": "6289"
    },
    {
        "raw_code": "def provider_configs\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.components.configs[:provider])\n            end",
        "comment": "This returns all the config classes for the various providers.  @return [Hash]",
        "label": "Property",
        "id": "9075"
    },
    {
        "raw_code": "def _deep_transform_values_in_object(object, &block)\n      case object\n      when Hash\n        object.transform_values { |value| _deep_transform_values_in_object(value, &block) }\n      when Array\n        object.map { |e| _deep_transform_values_in_object(e, &block) }\n      else\n        yield(object)\n      end",
        "comment": "Support methods for deep transforming nested hashes and arrays.",
        "label": "Property",
        "id": "14229"
    },
    {
        "raw_code": "def named_api_path\n      \"repos/#{slug}\"\n    end",
        "comment": "@return [String] Api path for owner/name identified repos",
        "label": "Property",
        "id": "14920"
    },
    {
        "raw_code": "def create_entries(entries)\n    out = []\n\n    entries.each do |entry, items|\n      out << RDoc::Markup::Heading.new(3, entry)\n      out << RDoc::Markup::BlankLine.new\n\n      out << create_items(items)\n    end",
        "comment": " Returns a list of ChangeLog entries an RDoc::Markup nodes for the given +entries+.",
        "label": "Property",
        "id": "16051"
    },
    {
        "raw_code": "def image\n    blob.preview_image\n  end",
        "comment": "Returns the blob's attached preview image.",
        "label": "Property",
        "id": "13631"
    },
    {
        "raw_code": "def yesterday\n      advance(days: -1)\n    end",
        "comment": "Returns a new date/time representing yesterday.",
        "label": "Property",
        "id": "14130"
    },
    {
        "raw_code": "def sql_key(sql)\n          \"#{schema_search_path}-#{sql}\"\n        end",
        "comment": "Returns the statement identifier for the client side cache of statements",
        "label": "Property",
        "id": "12980"
    },
    {
        "raw_code": "def to_hash\n      hash = {}\n      self.class.attribute_map.each_pair do |attr, param|\n        value = self.send(attr)\n        if value.nil?\n          is_nullable = self.class.openapi_nullable.include?(attr)\n          next if !is_nullable || (is_nullable && !instance_variable_defined?(:\"@#{attr}\"))\n        end",
        "comment": "Returns the object in the form of hash @return [Hash] Returns the object in the form of hash",
        "label": "Property",
        "id": "860"
    },
    {
        "raw_code": "def find(dirs)\n      dirs.inject({}) { |h, dir| h.update(find_in(dir)) }\n    end",
        "comment": "Returns a hash that maps filenames under +dirs+ (recursively) to arrays with their annotations.",
        "label": "Property",
        "id": "14691"
    },
    {
        "raw_code": "def versions(options = {})\n    return [] unless persisted?\n\n    default_per_page = Kaminari.config.default_per_page\n    offset = [options[:page].to_i - 1, 0].max * options.fetch(:per_page, default_per_page)\n\n    wiki.repository.commits(\n      wiki.default_branch,\n      path: page.path,\n      limit: options.fetch(:limit, default_per_page),\n      offset: offset\n    )\n  end",
        "comment": "Returns a CommitCollection  Queries the commits for current page's path, equivalent to `git log path/to/page`. Filters and options supported: https://gitlab.com/gitlab-org/gitaly/-/blob/master/proto/commit.proto#L322-344",
        "label": "Property",
        "id": "7166"
    },
    {
        "raw_code": "def repository_license_contents(repo, options = {})\n        get \"#{Repository.path repo}/license\", options\n      end",
        "comment": "Returns the contents of the repository\u2019s license file, if one is detected.  @see https://developer.github.com/v3/licenses/#get-the-contents-of-a-repositorys-license @param repo [Integer, String, Repository, Hash] A GitHub repository @option options [String] :ref name of the Commit/Branch/Tag. Defaults to 'master'. @return [Sawyer::Resource] The detail of the license file @example Octokit.repository_license_contents 'benbalter/licensee'",
        "label": "Property",
        "id": "14998"
    },
    {
        "raw_code": "def reference_pattern(*)\n          @reference_pattern ||= /\\b(?<![@-])(?<issue>T\\d+)\\b/\n        end",
        "comment": "See https://we.phorge.it/source/phorge/browse/master/src/infrastructure/markup/rule/PhabricatorObjectRemarkupRule.php for a canonical source of the regular expression used to parse Phorge object references.  > The \"(?<![#@-])\" prevents us from linking \"#abcdef\" or similar, and > \"ABC-T1\" (see T5714), and from matching \"@T1\" as a task (it is a user) > (see T9479).  Note that object references in Phorge are prefixed with letters unique to their underlying application, so T123 (a Maniphest task) is distinct from D123 (a Differential patch). Keeping the T as part of the task ID is appropriate here as it leaves room for expanding reference parsing/linking to other types of Phorge entities.  Also note, a prefix of # is being allowed here due to: 1) an assumed likelihood of use; and b) lack of collision with native GitLab issues since all Phorge identifiers have the application specific alpha prefix.",
        "label": "Property",
        "id": "7486"
    },
    {
        "raw_code": "def projects_for_nodes(nodes)\n        @projects_for_nodes ||= grouped_objects_for_nodes(nodes, Project.includes(:project_feature), 'data-project')\n      end",
        "comment": "Returns a Hash containing the projects for a given list of HTML nodes.  The returned Hash uses the following format:  { node => project } ",
        "label": "Property",
        "id": "3434"
    },
    {
        "raw_code": "def messages\n      hash = to_hash\n      hash.default = EMPTY_ARRAY\n      hash.freeze\n      hash\n    end",
        "comment": "Returns a Hash of attributes with an array of their error messages.",
        "label": "Property",
        "id": "12229"
    },
    {
        "raw_code": "def verify_labels_import\n        logger.info(\"== Verifying label import ==\")\n        expect(labels).to include(*source_labels)\n      end",
        "comment": "Verify imported labels  @return [void]",
        "label": "Property",
        "id": "4378"
    },
    {
        "raw_code": "def close_issue(project, id:, channel:)\n            send_message_to_channel(\n              [\"/staging-gitlab #{project.path_with_namespace} issue close #{id}\"],\n              channel: channel\n            )\n          end",
        "comment": "@param [QA::Resource::Project] project @param [String] id @param [String] channel",
        "label": "Property",
        "id": "4308"
    },
    {
        "raw_code": "def self.set_count(raw_key)\n          key = cache_key_for(raw_key)\n\n          with_redis do |redis|\n            redis.scard(key)\n          end",
        "comment": "Returns the number of values in the set.  raw_key - The key of the set to check.",
        "label": "Property",
        "id": "1945"
    },
    {
        "raw_code": "def csrf_meta_tags\n        if defined?(protect_against_forgery?) && protect_against_forgery?\n          [\n            tag(\"meta\", name: \"csrf-param\", content: request_forgery_protection_token),\n            tag(\"meta\", name: \"csrf-token\", content: form_authenticity_token)\n          ].join(\"\\n\").html_safe\n        end",
        "comment": "Returns meta tags \"csrf-param\" and \"csrf-token\" with the name of the cross-site request forgery protection parameter and token, respectively.  <head> <%= csrf_meta_tags %> </head>  These are used to generate the dynamic forms that implement non-remote links with <tt>:method</tt>.  You don't need to use these tags for regular forms as they generate their own hidden fields.  For Ajax requests other than GETs, extract the \"csrf-token\" from the meta-tag and send as the +X-CSRF-Token+ HTTP header. ",
        "label": "Property",
        "id": "11823"
    },
    {
        "raw_code": "def count\n      available_themes.size\n    end",
        "comment": "Returns the number of defined Themes",
        "label": "Property",
        "id": "1351"
    },
    {
        "raw_code": "def up_only(&block)\n      execute_block(&block) unless reverting?\n    end",
        "comment": "Used to specify an operation that is only run when migrating up (for example, populating a new column with its initial values).  In the following example, the new column +published+ will be given the value +true+ for all existing records.  class AddPublishedToPosts < ActiveRecord::Migration[8.1] def change add_column :posts, :published, :boolean, default: false up_only do execute \"update posts set published = 'true'\" end end end",
        "label": "Property",
        "id": "12492"
    },
    {
        "raw_code": "def offset\n        1\n      end",
        "comment": "The normal offset, i.e., the distance from the punctuation token where a space should be, is 1.",
        "label": "Property",
        "id": "10436"
    },
    {
        "raw_code": "def from_request(request)\n      category = request.headers[\"HTTP_X_GITLAB_FEATURE_CATEGORY\"].presence\n\n      return unless category && valid?(category)\n\n      return unless ::Gitlab::RequestForgeryProtection.verified?(request.env)\n\n      category\n    end",
        "comment": "If valid, returns a feature category from the given request.",
        "label": "Property",
        "id": "1476"
    },
    {
        "raw_code": "def deep_symbolize_keys!\n    deep_transform_keys! { |key| key.to_sym rescue key }\n  end",
        "comment": "Destructively converts all keys to symbols, as long as they respond to +to_sym+. This includes the keys from the root hash and from all nested hashes and arrays.",
        "label": "Property",
        "id": "14242"
    },
    {
        "raw_code": "def unique_constraint(...)\n          @base.add_unique_constraint(name, ...)\n        end",
        "comment": "Adds a unique constraint.  t.unique_constraint(:position, name: 'unique_position', deferrable: :deferred, nulls_not_distinct: true)  See {connection.add_unique_constraint}[rdoc-ref:SchemaStatements#add_unique_constraint]",
        "label": "Property",
        "id": "13227"
    },
    {
        "raw_code": "def dismount_disk(disk_file_path)\n        execute(:dismount_vhd, DiskFilePath: disk_file_path)\n      end",
        "comment": "@param [String] disk_file_path",
        "label": "Property",
        "id": "9689"
    },
    {
        "raw_code": "def ancestors_scheduled_for_deletion\n      []\n    end",
        "comment": "Returns an array of the record's ancestors that are scheduled for deletion. This method can be overriden.",
        "label": "Property",
        "id": "7418"
    },
    {
        "raw_code": "def covered?(traversal_ids)\n        current_node = self\n\n        traversal_ids.each do |traversal_id|\n          # If we've hit an end marker, it's covered\n          return true if current_node.end\n\n          # If the segment doesn't exist, it's not covered\n          return false unless current_node.children[traversal_id]\n\n          current_node = current_node.children[traversal_id]\n        end",
        "comment": "Check if traversal ID is already covered by a broader prefix or included in trie If trie contains [9970, 123] and [9970, 456] covered?([9970]) returns false covered?([9970, 123]) returns true covered?([9970, 123, 789]) returns true",
        "label": "Property",
        "id": "3357"
    },
    {
        "raw_code": "def root\n        if defined?(ENGINE_ROOT)\n          Pathname.new(ENGINE_ROOT)\n        else\n          application_root\n        end",
        "comment": "Returns the root of the \\Rails engine or app running the command.",
        "label": "Property",
        "id": "14655"
    },
    {
        "raw_code": "def tidy_bytes(force = false)\n        chars(Unicode.tidy_bytes(@wrapped_string, force))\n      end",
        "comment": "Replaces all ISO-8859-1 or CP1252 characters by their UTF-8 equivalent resulting in a valid UTF-8 string.  Passing +true+ will forcibly tidy all bytes, assuming that the string's encoding is entirely CP1252 or ISO-8859-1.",
        "label": "Property",
        "id": "14502"
    },
    {
        "raw_code": "def future?\n      utc.future?\n    end",
        "comment": "Returns true if the current object's time is in the future.",
        "label": "Property",
        "id": "13980"
    },
    {
        "raw_code": "def parse(keyword:)\n          plain_lines.each_with_object([]) do |line, packages|\n            name = fetch(line, method_call_regex(keyword))\n\n            next unless name\n\n            git_ref = fetch(line, GIT_REGEX)\n            github_ref = fetch(line, GITHUB_REGEX)\n\n            packages << Gitlab::DependencyLinker::Package.new(name, git_ref, github_ref)\n          end",
        "comment": "Returns a list of Gitlab::DependencyLinker::Package  keyword - The package definition keyword, e.g. `:gem` for Gemfile parsing, `:pod` for Podfile.",
        "label": "Property",
        "id": "2118"
    },
    {
        "raw_code": "def next_words_on_error\n  if n = @src.rest.index(\"\\n\")\n    @src.rest[0 .. (n-1)]\n  else\n    @src.rest\n  end",
        "comment": " Returns words following an error",
        "label": "Property",
        "id": "16541"
    },
    {
        "raw_code": "def amount_to_be_flushed\n        redis_state do |redis|\n          redis.eval(LUA_FLUSH_INCREMENT_SCRIPT, keys: [key, flushed_key])\n        end",
        "comment": "amount_to_be_flushed returns the total value to be flushed. The total value is the sum of the following: - current value in the increment_key - any existing value in the flushed_key that has not been flushed",
        "label": "Property",
        "id": "1827"
    },
    {
        "raw_code": "def self.job_status(job_ids)\n      return [] if job_ids.empty?\n\n      keys = job_ids.map { |jid| key_for(jid) }\n\n      status = with_redis do |redis|\n        Gitlab::Instrumentation::RedisClusterValidator.allow_cross_slot_commands do\n          if Gitlab::Redis::ClusterUtil.cluster?(redis)\n            Gitlab::Redis::ClusterUtil.batch_get(keys, redis)\n          else\n            redis.mget(*keys)\n          end",
        "comment": "Returns the job status for each of the given job IDs.  job_ids - The Sidekiq job IDs to check.  Returns an array of true or false indicating job completion. true = job is still running or enqueued false = job completed",
        "label": "Property",
        "id": "1474"
    },
    {
        "raw_code": "def filter_phrase\n          return unless filter_name\n          return \"where filtered\" if disabled\n\n          \"#{format_info(\"where #{filter_name}\")} is...\"\n        end",
        "comment": "ex) \"where label/property is...\"",
        "label": "Property",
        "id": "5369"
    },
    {
        "raw_code": "def spec_path\n    Pathname.new(__dir__).join('..').expand_path\n  end",
        "comment": "Specs basepath @return [Pathname]",
        "label": "Property",
        "id": "1111"
    },
    {
        "raw_code": "def attribute_names\n      @attributes.keys\n    end",
        "comment": "Returns an array of attribute names as strings.  class Person include ActiveModel::Attributes  attribute :name, :string attribute :age, :integer end  person = Person.new person.attribute_names # => [\"name\", \"age\"]",
        "label": "Property",
        "id": "12172"
    },
    {
        "raw_code": "def through_reflection\n        active_record._reflect_on_association(options[:through])\n      end",
        "comment": "Returns the AssociationReflection object specified in the <tt>:through</tt> option of a HasManyThrough or HasOneThrough association.  class Post < ActiveRecord::Base has_many :taggings has_many :tags, through: :taggings end  tags_reflection = Post.reflect_on_association(:tags) tags_reflection.through_reflection # => <ActiveRecord::Reflection::HasManyReflection: @name=:taggings, @active_record=Post, @plural_name=\"taggings\"> ",
        "label": "Property",
        "id": "12617"
    },
    {
        "raw_code": "def detect_mentionable_changes\n    source = (changes.presence || previous_changes).dup\n\n    mentionable = self.class.mentionable_attrs.map { |attr, options| attr }\n\n    # Only include changed fields that are mentionable\n    source.select { |key, val| mentionable.include?(key) }\n  end",
        "comment": "Returns a Hash of changed mentionable fields  Preference is given to the `changes` Hash, but falls back to `previous_changes` if it's empty (i.e., the changes have already been persisted).  See ActiveModel::Dirty.  Returns a Hash.",
        "label": "Property",
        "id": "7238"
    },
    {
        "raw_code": "def run_command(command)\n      output, _ = Gitlab::Popen.popen(command)\n      output\n    rescue Errno::ENOENT\n      '' # if the command does not exist, return an empty string\n    end",
        "comment": "Runs the given command  Returns '' if the command was not found Returns the output of the command otherwise  see also #run_and_match",
        "label": "Property",
        "id": "1670"
    },
    {
        "raw_code": "def stubbed?\n        !@stubs.empty?\n      end",
        "comment": "Returns true if any stubs are set, false if there are none",
        "label": "Property",
        "id": "14548"
    },
    {
        "raw_code": "def url(key, **options)\n      instrument :url, key: key do |payload|\n        generated_url =\n          if public?\n            public_url(key, **options)\n          else\n            private_url(key, **options)\n          end",
        "comment": "Returns the URL for the file at the +key+. This returns a permanent URL for public files, and returns a short-lived URL for private files. For private files you can provide the +disposition+ (+:inline+ or +:attachment+), +filename+, and +content_type+ that you wish the file to be served with on request. Additionally, you can also provide the amount of seconds the URL will be valid for, specified in +expires_in+.",
        "label": "Property",
        "id": "13678"
    },
    {
        "raw_code": "def validate_options(_value)\n        return unless options\n\n        error('Options can only be used with string and number inputs')\n      end",
        "comment": "Options can be either StringInput or NumberInput and are validated accordingly.",
        "label": "Property",
        "id": "3579"
    },
    {
        "raw_code": "def today\n      tzinfo.now.to_date\n    end",
        "comment": "Returns the current date in this time zone.",
        "label": "Property",
        "id": "14575"
    },
    {
        "raw_code": "def self.without_modules(*modules)\n      modules = modules.map do |m|\n        m.is_a?(Symbol) ? ActionController.const_get(m) : m\n      end",
        "comment": "Shortcut helper that returns all the modules included in ActionController::Base except the ones passed as arguments:  class MyBaseController < ActionController::Metal ActionController::Base.without_modules(:ParamsWrapper, :Streaming).each do |left| include left end end  This gives better control over what you want to exclude and makes it easier to create a bare controller class, instead of listing the modules required manually.",
        "label": "Property",
        "id": "11220"
    },
    {
        "raw_code": "def normalized_file_list(relative_files, force_doc = false,\n                           exclude_pattern = nil)\n    file_list = {}\n\n    relative_files.each do |rel_file_name|\n      rel_file_name = rel_file_name.sub(/^\\.\\//, '')\n      next if rel_file_name.end_with? 'created.rid'\n      next if exclude_pattern && exclude_pattern =~ rel_file_name\n      stat = File.stat rel_file_name rescue next\n\n      case type = stat.ftype\n      when \"file\" then\n        mtime = (stat.mtime unless (last_modified = @last_modified[rel_file_name] and\n                                    stat.mtime.to_i <= last_modified.to_i))\n\n        if force_doc or RDoc::Parser.can_parse(rel_file_name) then\n          file_list[rel_file_name] = mtime\n        end",
        "comment": " Given a list of files and directories, create a list of all the Ruby files they contain.  If +force_doc+ is true we always add the given files, if false, only add files that we guarantee we can parse.  It is true when looking at files given on the command line, false when recursing through subdirectories.  The effect of this is that if you want a file with a non-standard extension parsed, you must name it explicitly.",
        "label": "Property",
        "id": "16015"
    },
    {
        "raw_code": "def iso8601(str)\n      # Historically `Date._iso8601(nil)` returns `{}`, but in the `date` gem versions `3.2.1`, `3.1.2`, `3.0.2`,\n      # and `2.0.1`, `Date._iso8601(nil)` raises `TypeError` https://github.com/ruby/date/issues/39\n      # Future `date` releases are expected to revert back to the original behavior.\n      raise ArgumentError, \"invalid date\" if str.nil?\n\n      parts = Date._iso8601(str)\n\n      year = parts.fetch(:year)\n\n      if parts.key?(:yday)\n        ordinal_date = Date.ordinal(year, parts.fetch(:yday))\n        month = ordinal_date.month\n        day = ordinal_date.day\n      else\n        month = parts.fetch(:mon)\n        day = parts.fetch(:mday)\n      end",
        "comment": "\\Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from an ISO 8601 string.  Time.zone = 'Hawaii'                     # => \"Hawaii\" Time.zone.iso8601('1999-12-31T14:00:00') # => Fri, 31 Dec 1999 14:00:00 HST -10:00  If the time components are missing then they will be set to zero.  Time.zone = 'Hawaii'            # => \"Hawaii\" Time.zone.iso8601('1999-12-31') # => Fri, 31 Dec 1999 00:00:00 HST -10:00  If the string is invalid then an +ArgumentError+ will be raised unlike +parse+ which usually returns +nil+ when given an invalid date string.",
        "label": "Property",
        "id": "14570"
    },
    {
        "raw_code": "def capability_module(cap_name)\n      @cap_logger.debug(\"Searching for cap: #{cap_name}\")\n      @cap_host_chain.each do |host_name, host|\n        @cap_logger.debug(\"Checking in: #{host_name}\")\n        caps = @cap_caps[host_name]\n\n        if caps && caps.key?(cap_name)\n          @cap_logger.debug(\"Found cap: #{cap_name} in #{host_name}\")\n          return caps[cap_name]\n        end",
        "comment": "Returns the registered module for a capability with the given name.  @param [Symbol] cap_name @return [Module]",
        "label": "Property",
        "id": "8776"
    },
    {
        "raw_code": "def deprecation_command_name\n        name_parts = self.class.name.split(\"::\")\n        [\n          name_parts[1].sub('Command', ''),\n          name_parts[3]\n        ].compact.map(&:downcase).join(\" \")\n      end",
        "comment": "@return [String] generated name of command",
        "label": "Property",
        "id": "9252"
    },
    {
        "raw_code": "def complex_template_path(component_name)\n        File.join(TEMPLATES_DIR, component_name, TEMPLATE_FILE)\n      end",
        "comment": "A complex template is directory-based and may consist of multiple files. Given a path like \"my-org/sub-group/the-project/templates/component\" returns the entry point path: \"templates/component/template.yml\".",
        "label": "Property",
        "id": "7594"
    },
    {
        "raw_code": "def shift_elements_for_heredoc_arg(node, elements, index)\n        return index unless node.type?(:call, :array)\n\n        heredoc_index = elements.index { |arg| arg.respond_to?(:heredoc?) && arg.heredoc? }\n        return index unless heredoc_index\n        return nil if heredoc_index.zero?\n\n        heredoc_index >= index ? index : heredoc_index + 1\n      end",
        "comment": "@api private If a `send` or `csend` node contains a heredoc argument, splitting cannot happen after the heredoc or else it will cause a syntax error.",
        "label": "Property",
        "id": "10405"
    },
    {
        "raw_code": "def async_find_by_sql(sql, binds = [], preparable: nil, allow_retry: false, &block)\n      with_connection do |c|\n        _query_by_sql(c, sql, binds, preparable: preparable, allow_retry: allow_retry, async: true)\n      end.then do |result|\n        _load_from_sql(result, &block)\n      end",
        "comment": "Same as #find_by_sql but perform the query asynchronously and returns an ActiveRecord::Promise.",
        "label": "Property",
        "id": "12587"
    },
    {
        "raw_code": "def project_root\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `RuboCop::ConfigLoader.project_root` is deprecated and will be removed in RuboCop 2.0. \\\n          Use `RuboCop::ConfigFinder.project_root` instead.\n        WARNING\n\n        ConfigFinder.project_root\n      end",
        "comment": "rubocop:enable Metrics/MethodLength Returns the path RuboCop inferred as the root of the project. No file searches will go past this directory. @deprecated Use `RuboCop::ConfigFinder.project_root` instead.",
        "label": "Property",
        "id": "10072"
    },
    {
        "raw_code": "def link_to_markdown(body, url, html_options = {})\n    return '' if body.blank?\n\n    link_to_html(markdown(body, pipeline: :single_line), url, html_options)\n  end",
        "comment": "Use this in places where you would normally use link_to(gfm(...), ...).",
        "label": "Others",
        "id": "7707"
    },
    {
        "raw_code": "def body(value = nil, &block)\n      if block_given?\n        def block.each; yield(call) end\n        response.body = block\n      elsif value\n        unless request.head? || value.is_a?(Rack::Files::BaseIterator) || value.is_a?(Stream)\n          headers.delete 'content-length'\n        end\n        response.body = value\n      else\n        response.body\n      end",
        "comment": "Set or retrieve the response body. When a block is given, evaluation is deferred until the body is read with #each.",
        "label": "Others",
        "id": "8546"
    },
    {
        "raw_code": "def migrations(org, options = {})\n        paginate \"#{Organization.path(org)}/migrations\", options\n      end",
        "comment": "Lists the most recent migrations.  Requires authenticated organization owner.  @param org [String, Integer] Organization GitHub login or id. @return [Array<Sawyer::Resource>] Array of migration resources. @see https://docs.github.com/en/rest/reference/migrations#list-organization-migrations",
        "label": "Others",
        "id": "15458"
    },
    {
        "raw_code": "def and(right)\n        Nodes::And.new [self, right]\n      end",
        "comment": " Factory method to create an Nodes::And node.",
        "label": "Others",
        "id": "13476"
    },
    {
        "raw_code": "def ide_data(project:, fork_info:, params:)\n    base_data = {\n      'new-web-ide-help-page-path' => help_page_path('user/project/web_ide/_index.md'),\n      'sign-in-path' => new_session_path(current_user),\n      'sign-out-path' => destroy_user_session_path,\n      'user-preferences-path' => profile_preferences_path\n    }.merge(extend_ide_data(project: project))\n\n    return base_data unless project\n\n    base_data.merge(\n      'fork-info' => fork_info&.to_json,\n      'branch-name' => params[:branch],\n      'file-path' => params[:path],\n      'merge-request' => params[:merge_request_id]\n    )\n  end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "7737"
    },
    {
        "raw_code": "def test_render_xml_as_string_template\n    get :render_xml_hello_as_string_template\n    assert_equal \"<html>\\n  <p>Hello David</p>\\n<p>This is grand!</p>\\n</html>\\n\", @response.body\n    assert_equal \"application/xml\", @response.media_type\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12084"
    },
    {
        "raw_code": "def deprecated(*args, version:, stack: 0)\n      super if Gitlab.dev_or_test_env?\n    end",
        "comment": "Disable all deprecations in non dev/test environments. ",
        "label": "Others",
        "id": "1302"
    },
    {
        "raw_code": "def add_hostname_to_loopback_interface(comm, name, loop_bound=DEAFAULT_LOOPBACK_CHECK_LIMIT)\n          basename = name.split(\".\", 2)[0]\n          comm.sudo <<-EOH.gsub(/^ {14}/, '')\n          grep -w '#{name}' /etc/hosts || {\n            for i in #{[*1..loop_bound].join(' ')}; do\n              grep -w \"127.0.${i}.1\" /etc/hosts || {\n                echo \"127.0.${i}.1 #{name} #{basename}\" >> /etc/hosts\n                break\n              }\n            done\n          }\n          EOH\n        end",
        "comment": "Add hostname to a loopback address on /etc/hosts if not already there Will insert name at the first free address of the form 127.0.X.1, up to the loop_bound  @param [Communicator] @param [String] full hostanme @param [int] (option) defines the upper bound for searching for an available loopback address",
        "label": "Others",
        "id": "9278"
    },
    {
        "raw_code": "def prepare_user_for_update(user)\n    user.skip_reconfirmation!\n    user.send_only_admin_changed_your_password_notification! if admin_making_changes_for_another_user?\n  end",
        "comment": "method overridden in EE",
        "label": "Others",
        "id": "6454"
    },
    {
        "raw_code": "def redirect_renamed_default_branch?\n    false\n  end",
        "comment": "Override in controllers to determine which actions are subject to the redirect",
        "label": "Others",
        "id": "1320"
    },
    {
        "raw_code": "def resolve_project(full_path: nil, project_id: nil)\n    unless full_path.present? ^ project_id.present?\n      raise ::Gitlab::Graphql::Errors::ArgumentError, 'Incompatible arguments: projectId, projectPath.'\n    end",
        "comment": "Accepts EITHER one of - full_path: String (see Project#full_path) - project_id: GlobalID. Arguments should be typed as: `::Types::GlobalIDType[Project]`",
        "label": "Others",
        "id": "6186"
    },
    {
        "raw_code": "def testable?\n        project_level?\n      end",
        "comment": "Disable test for instance-level and group-level integrations. https://gitlab.com/gitlab-org/gitlab/-/issues/213138",
        "label": "Others",
        "id": "7473"
    },
    {
        "raw_code": "def expect_autocorrect_options_for_fix_layout\n      options_keys = options.instance_variable_get(:@options).keys\n      expect(options_keys).to include(:fix_layout)\n      expect(options_keys).to include(:autocorrect)\n      expect(options_keys).not_to include(:safe_autocorrect)\n      expect(options_keys).not_to include(:autocorrect_all)\n    end",
        "comment": "rubocop:enable Naming/InclusiveLanguage",
        "label": "Others",
        "id": "10755"
    },
    {
        "raw_code": "def configurable_channels?\n        false\n      end",
        "comment": "With some integrations the webhook is already tied to a specific channel, for others the channels are configurable for each event.",
        "label": "Others",
        "id": "7482"
    },
    {
        "raw_code": "def some_method\n              implement 1\n            end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10935"
    },
    {
        "raw_code": "def remove_inverse_instance(record)\n        if inverse = inverse_association_for(record)\n          inverse.inversed_from(nil)\n        end",
        "comment": "Remove the inverse association, if possible",
        "label": "Others",
        "id": "12751"
    },
    {
        "raw_code": "def process_media_group(element, ast_node)\n        ul_element = Element.new(:ul)\n        element.children << ul_element\n\n        ast_node['content'].each do |node|\n          next unless node['type'] == 'media'\n\n          li_element = Element.new(:li)\n          ul_element.children << li_element\n\n          process_media(li_element, node)\n        end",
        "comment": "wraps a group media element. Currently ignore attrs.layout and attrs.width",
        "label": "Others",
        "id": "3667"
    },
    {
        "raw_code": "def some_method\n          ^^^^^^^^^^^^^^^ Method `A#some_method` is defined at both first.rb:2 and second.rb:2.\n            implement 2\n          end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10920"
    },
    {
        "raw_code": "def stringify_keys!\n    transform_keys! { |k| Symbol === k ? k.name : k.to_s }\n  end",
        "comment": "Destructively converts all keys to strings. Same as +stringify_keys+, but modifies +self+.",
        "label": "Others",
        "id": "14233"
    },
    {
        "raw_code": "def organize_resources(filtered_resources)\n        organized_resources = {}\n\n        sandboxes = filtered_resources.delete('QA::Resource::Sandbox')\n        groups = filtered_resources.delete('QA::Resource::Group')\n        projects = filtered_resources.delete('QA::Resource::Project')\n        users = filtered_resources.delete('QA::Resource::User')\n\n        organized_resources['QA::Resource::Sandbox'] = sandboxes if sandboxes\n        organized_resources['QA::Resource::Group'] = groups if groups\n        organized_resources['QA::Resource::Project'] = projects if projects\n        organized_resources.merge!(filtered_resources) unless filtered_resources.empty?\n        organized_resources['QA::Resource::User'] = users if users\n\n        organized_resources\n      end",
        "comment": "Organizes resources in hierarchical deletion order for efficient cleanup  Reorders resources to respect dependency relationships during deletion. The deletion order prevents dependency conflicts by removing parent resources before child resources, and system resources before user resources.  @param [Hash<String, Array<Hash>>] filtered_resources Hash where keys are resource class names and values are arrays of resource data hashes @return [Hash<String, Array<Hash>>] Reorganized resources hash in deletion order: 1. Sandboxes, 2. Groups, 3. Projects, 4. Other resources, 5. Users",
        "label": "Others",
        "id": "4671"
    },
    {
        "raw_code": "def user_password_changed?(user)\n    return false unless session[:user_password_hash]\n\n    Digest::SHA256.hexdigest(user.encrypted_password) != session[:user_password_hash]\n  end",
        "comment": "If user has been updated since we validated the password, the password might have changed.",
        "label": "Others",
        "id": "6505"
    },
    {
        "raw_code": "def assert_disallowed(match = nil, deprecator = nil, &block)\n      match, deprecator = nil, match if match.is_a?(ActiveSupport::Deprecation)\n      result, disallowed = collect_disallowed(deprecator, &block)\n      assert_not_empty disallowed, \"Expected a disallowed deprecation within the block but received none\"\n      if match\n        match = Regexp.new(Regexp.escape(match)) unless match.is_a?(Regexp)\n        assert disallowed.any?(match), \"No disallowed deprecations matched #{match}: #{disallowed.inspect}\"\n      end",
        "comment": "a la assert_deprecated",
        "label": "Others",
        "id": "14603"
    },
    {
        "raw_code": "def initialize(parent, score, item)\n      super(item)\n      @score = Float(score)\n      @parent = parent\n    end",
        "comment": ":nodoc: @api private",
        "label": "Others",
        "id": "5123"
    },
    {
        "raw_code": "def __set_internal_state(state)\n          @config_map        = state[\"config_map\"] if state.key?(\"config_map\")\n          @keys              = state[\"keys\"] if state.key?(\"keys\")\n          @missing_key_calls = state[\"missing_key_calls\"] if state.key?(\"missing_key_calls\")\n        end",
        "comment": "This sets the internal state. This is used by the core to do some merging logic and shouldn't be used by the general public.",
        "label": "Others",
        "id": "8943"
    },
    {
        "raw_code": "def parse_job(job)\n        # Error information from the previous try is in the payload for\n        # displaying in the Sidekiq UI, but is very confusing in logs!\n        job = job.except(\n          'exception.backtrace', 'exception.class', 'exception.message', 'exception.sql',\n          'error_message', 'error_class', 'error_backtrace', 'failed_at'\n        )\n\n        job['class'] = job.delete('wrapped') if job['wrapped'].present?\n\n        job['job_size_bytes'] = Sidekiq.dump_json(job['args']).bytesize\n        job['args'] = ['[COMPRESSED]'] if ::Gitlab::SidekiqMiddleware::SizeLimiter::Compressor.compressed?(job)\n\n        # Add process id params\n        job['pid'] = ::Process.pid\n\n        job.delete('args') unless SidekiqLogArguments.enabled?\n\n        job\n      end",
        "comment": "NOTE: Arguments are truncated/stringified in sidekiq_logging/json_formatter.rb",
        "label": "Others",
        "id": "3352"
    },
    {
        "raw_code": "def note label\n    #foottext = \"rdoc-label:foottext-#{label}:footmark-#{label}\"\n\n    #ref.replace foottext if ref = @unlinked_notes.delete(label)\n\n    @notes[label] = foottext\n\n    #\"{^1}[rdoc-label:footmark-#{label}:foottext-#{label}] \"\n  end",
        "comment": " Stores `label` as a note and fills in previously unknown note references.",
        "label": "Others",
        "id": "15581"
    },
    {
        "raw_code": "def test_do_with_render_text_and_layout\n    get :render_text_hello_world_with_layout\n    assert_equal \"{{hello world, I am here!}}\\n\", @response.body\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12066"
    },
    {
        "raw_code": "def with_illustration_slot\n      render(Pajamas::BannerComponent.new) do |c|\n        c.with_illustration do\n          '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"white\" stroke=\"white\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-thumbs-up\"><path d=\"M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3\"></path></svg>'.html_safe # rubocop:disable Layout/LineLength, Lint/RedundantCopDisableDirective\n        end",
        "comment": "Use the `illustration` slot instead of `svg_path` if your illustration is not part or the asset pipeline, but for example, an inline SVG via `custom_icon`.",
        "label": "Others",
        "id": "8207"
    },
    {
        "raw_code": "def notify(message, opts)\n        raise NotImplementedError\n      end",
        "comment": "every notifier must implement this independently",
        "label": "Others",
        "id": "7483"
    },
    {
        "raw_code": "def google?\n      provider == GOOGLE_PROVIDER\n    end",
        "comment": "End Azure-specific options",
        "label": "Others",
        "id": "3731"
    },
    {
        "raw_code": "def cross_project\n      []\n    end",
        "comment": "Dependencies that are defined by project and ref",
        "label": "Others",
        "id": "7531"
    },
    {
        "raw_code": "def service_disabled?\n        Feature.enabled?(:disable_cancel_redundant_pipelines_service, project, type: :ops)\n      end",
        "comment": "Finding the pipelines to cancel is an expensive task that is not well covered by indexes for all project use-cases and sometimes it might harm other services. See https://gitlab.com/gitlab-com/gl-infra/production/-/issues/14758 This feature flag is in place to disable this feature for rogue projects. ",
        "label": "Others",
        "id": "5816"
    },
    {
        "raw_code": "def with_ui(ui)\n      @ui_mutex.synchronize do\n        begin\n          old_ui = @ui\n          @ui    = ui\n          yield\n        ensure\n          @ui = old_ui\n        end",
        "comment": "Temporarily changes the machine UI. This is useful if you want to execute an {#action} with a different UI.",
        "label": "Others",
        "id": "8790"
    },
    {
        "raw_code": "def transfer_status_data(old_root_ancestor_id); end\n\n    # Overridden in EE\n    def post_update_hooks(updated_project_ids, old_root_ancestor_id)\n      refresh_project_authorizations\n      refresh_descendant_groups if @new_parent_group\n      publish_event(old_root_ancestor_id)\n    end\n\n    # Overridden in EE\n    def ensure_allowed_transfer\n      raise_transfer_error(:group_is_already_root) if group_is_already_root?\n      raise_transfer_error(:same_parent_as_current) if same_parent?\n      raise_transfer_error(:has_subscription) if has_subscription?\n      raise_transfer_error(:invalid_policies) unless valid_policies?\n      raise_transfer_error(:namespace_with_same_path) if namespace_with_same_path?\n      raise_transfer_error(:group_contains_images) if group_projects_contain_registry_images?\n      raise_transfer_error(:cannot_transfer_to_subgroup) if transfer_to_subgroup?\n      raise_transfer_error(:group_contains_namespaced_npm_packages) if group_with_namespaced_npm_packages?\n      raise_transfer_error(:no_permissions_to_migrate_crm) if no_permissions_to_migrate_crm?\n    end\n\n    def no_permissions_to_migrate_crm?\n      return false unless group && @new_parent_group\n      return false if group.crm_settings&.source_group\n      return false if group.crm_group == @new_parent_group.crm_group\n\n      return true if group.crm_group.contacts.exists? && !current_user.can?(:admin_crm_contact, @new_parent_group.root_ancestor)\n      return true if group.crm_group.crm_organizations.exists? && !current_user.can?(:admin_crm_organization, @new_parent_group.root_ancestor)\n\n      false\n    end\n\n    def group_with_namespaced_npm_packages?\n      return false unless group.packages_feature_enabled?\n\n      # TODO: Remove `packages_class` with the rollout of the FF packages_refactor_group_packages_finder\n      # https://gitlab.com/gitlab-org/gitlab/-/issues/568923\n      npm_packages = ::Packages::GroupPackagesFinder\n                       .new(current_user, group, packages_class: ::Packages::Npm::Package, preload_pipelines: false, package_type: :npm)\n                       .execute\n\n      npm_packages = npm_packages.with_npm_scope(group.root_ancestor.path)\n\n      different_root_ancestor? && npm_packages.exists?\n    end\n\n    def different_root_ancestor?\n      group.root_ancestor != new_parent_group&.root_ancestor\n    end\n\n    def group_is_already_root?\n      !@new_parent_group && !@group.has_parent?\n    end\n\n    def same_parent?\n      @new_parent_group && @new_parent_group.id == @group.parent_id\n    end\n\n    def has_subscription?\n      @group.paid?\n    end\n\n    def transfer_to_subgroup?\n      @new_parent_group && \\\n        @group.self_and_descendants.pluck_primary_key.include?(@new_parent_group.id)\n    end\n\n    def valid_policies?\n      return false unless can?(current_user, :change_group, @group)\n\n      if @new_parent_group\n        can?(current_user, :create_subgroup, @new_parent_group)\n      else\n        can?(current_user, :create_group)\n      end\n    end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "5534"
    },
    {
        "raw_code": "def stub_languages_translation_percentage(list = {})\n    return if list.blank?\n\n    allow(Gitlab::I18n)\n      .to receive(:percentage_translated_for)\n      .and_wrap_original do |_original, code|\n        list.with_indifferent_access[code].to_i\n      end",
        "comment": "Stubs the translation percentage of the i18n languages - When a `blank?` list is given no stubbing is done; - When the list is not empty, the languages in the list are stubbed with the given values, any other language will have the translation percent set to 0;",
        "label": "Others",
        "id": "8301"
    },
    {
        "raw_code": "def column\n        location.column\n      end",
        "comment": "@api private",
        "label": "Others",
        "id": "10237"
    },
    {
        "raw_code": "def view_assigns\n      variables = instance_variables - _protected_ivars\n\n      variables.each_with_object({}) do |name, hash|\n        hash[name.slice(1, name.length)] = instance_variable_get(name)\n      end",
        "comment": "This method should return a hash with assigns. You can overwrite this configuration per controller.",
        "label": "Others",
        "id": "11205"
    },
    {
        "raw_code": "def initialize(color: :dark, inline: false, label: _(\"Loading\"), size: :sm, **html_options)\n      @color = filter_attribute(color.to_sym, COLOR_OPTIONS)\n      @inline = inline\n      @label = label.presence\n      @size = filter_attribute(size.to_sym, SIZE_OPTIONS)\n      @html_options = html_options\n    end",
        "comment": "@param [Symbol] color @param [Boolean] inline @param [String] label @param [Symbol] size",
        "label": "Others",
        "id": "5398"
    },
    {
        "raw_code": "def last_column\n        location.last_column\n      end",
        "comment": "@api private",
        "label": "Others",
        "id": "10242"
    },
    {
        "raw_code": "def some_method\n              implement 1\n            end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10942"
    },
    {
        "raw_code": "def assertions\n    @assertions ||= 0\n  end",
        "comment": "Allow assertions in request context",
        "label": "Others",
        "id": "8707"
    },
    {
        "raw_code": "def test_access_to_action_name_in_view\n    get :accessing_action_name_in_template\n    assert_equal \"accessing_action_name_in_template\", @response.body\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12081"
    },
    {
        "raw_code": "def text=(text)\n    raise RDoc::Error, 'replacing document-only comment is not allowed' if\n      @text.nil? and @document\n\n    @document = nil\n    @text = text.nil? ? nil : text.dup\n  end",
        "comment": " Replaces this comment's text with +text+ and resets the parsed document.  An error is raised if the comment contains a document but no text.",
        "label": "Others",
        "id": "15965"
    },
    {
        "raw_code": "def add(x) = x + 1\n        end",
        "comment": "Adds two numbers",
        "label": "Others",
        "id": "784"
    },
    {
        "raw_code": "def edited?\n    return false if read_attribute(:last_edited_at).blank? && updated_by.blank?\n\n    super\n  end",
        "comment": "Since we used `updated_at` as `last_edited_at`, it could be touched by transforming / resolving a note. This makes sure it is only marked as edited when the note body is updated.",
        "label": "Others",
        "id": "6936"
    },
    {
        "raw_code": "def related_merge_requests\n        parse_body(api_get_from(api_related_mrs_path))\n      end",
        "comment": "Related merge requests  @return [Array<Hash>]",
        "label": "Others",
        "id": "4140"
    },
    {
        "raw_code": "def test_transaction_per_thread\n      threads = 3.times.map do\n        Thread.new do\n          Topic.transaction do\n            topic = Topic.find(1)\n            topic.approved = !topic.approved?\n            assert topic.save!\n            topic.approved = !topic.approved?\n            assert topic.save!\n          end",
        "comment": "This will cause transactions to overlap and fail unless they are performed on separate database connections.",
        "label": "Others",
        "id": "13531"
    },
    {
        "raw_code": "def allow_stale_runner_pruning=(_value)\n      raise NotImplementedError\n    end",
        "comment": "Overridden in EE::Namespace",
        "label": "Others",
        "id": "7518"
    },
    {
        "raw_code": "def line\n        location.line\n      end",
        "comment": "@api private",
        "label": "Others",
        "id": "10236"
    },
    {
        "raw_code": "def initialize(hosts = [])\n          @hosts = hosts.shuffle\n          @index = 0\n          @mutex = Mutex.new\n          @hosts_gauge = Gitlab::Metrics.gauge(:db_load_balancing_hosts, 'Current number of load balancing hosts')\n\n          set_metrics!\n        end",
        "comment": "hosts - The list of secondary hosts to add.",
        "label": "Others",
        "id": "3108"
    },
    {
        "raw_code": "def add_comment(comment)\n        @comments << comment unless comment.nil?\n      end",
        "comment": "Adds a comment for the message.  @param [String] comment the comment for the message to be added. @return [void]",
        "label": "Others",
        "id": "714"
    },
    {
        "raw_code": "def some_method\n              implement 1\n            end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10938"
    },
    {
        "raw_code": "def method; end\n      eof\n      expect(s.comments).to eq \"comment\\ncomment\\ncomment\"\n      expect(s.comments_range).to eq(1..3)\n\n      s = stmt <<-eof\n\n        # comment\n        # comment\n        def method; end\n      eof\n      expect(s.comments).to eq \"comment\\ncomment\"\n      expect(s.comments_range).to eq(2..3)\n\n      s = stmt <<-eof\n        # comment\n        # comment\n\n        def method; end\n      eof\n      expect(s.comments).to eq \"comment\\ncomment\"\n      expect(s.comments_range).to eq(1..2)\n\n      s = stmt <<-eof\n        # comment\n        def method; end\n      eof\n      expect(s.comments).to eq \"comment\"\n      expect(s.comments_range).to eq(1..1)\n\n      s = stmt <<-eof\n        def method; end # comment\n      eof\n      expect(s.comments).to eq \"comment\"\n      expect(s.comments_range).to eq(1..1)\n    end\n\n    it \"only looks up to two lines back for comments\" do\n      s = stmts <<-eof\n        # comments\n\n        # comments\n\n        def method; end\n      eof\n      expect(s[1].comments).to eq \"comments\"\n\n      s = stmts <<-eof\n        # comments\n\n\n        def method; end\n      eof\n      expect(s[1].comments).to eq nil\n\n      ss = stmts <<-eof\n        # comments\n\n\n        def method; end\n\n        # hello\n        def method2; end\n      eof\n      expect(ss[1].comments).to eq nil\n      expect(ss[2].comments).to eq 'hello'\n    end\n\n    it \"handles block comment followed by line comment\" do\n      ss = stmts <<-eof\n# comments1\n\n=begin\ncomments2\n=end\n# comments3\ndef hello; end\neof\n      expect(ss.last.comments).to eq \"comments3\"\n    end\n\n    it \"handles block comment followed by block comment\" do\n      ss = stmts <<-eof\n=begin\ncomments1\n=end\n=begin\ncomments2\n=end\ndef hello; end\neof\n      expect(ss.last.comments.strip).to eq \"comments2\"\n    end\n\n    it \"handles 1.9 lambda syntax with args\" do\n      src = \"->(a,b,c=1,*args,&block) { hello_world }\"\n      expect(stmt(src).source).to eq src\n    end\n\n    it \"handles 1.9 lambda syntax\" do\n      src = \"-> { hello_world }\"\n      expect(stmt(src).source).to eq src\n    end\n\n    it \"handles standard lambda syntax\" do\n      src = \"lambda { hello_world }\"\n      expect(stmt(src).source).to eq src\n    end\n\n    it \"throws a ParserSyntaxError on invalid code\" do\n      expect { stmt(\"Foo, bar.\") }.to raise_error(YARD::Parser::ParserSyntaxError)\n    end\n\n    it \"handles bare hashes as method parameters\" do\n      src = \"command :a => 1, :b => 2, :c => 3\"\n      expect(stmt(src).jump(:command)[1].source).to eq \":a => 1, :b => 2, :c => 3\"\n\n      src = \"command a: 1, b: 2, c: 3\"\n      expect(stmt(src).jump(:command)[1].source).to eq \"a: 1, b: 2, c: 3\"\n    end\n\n    it \"handles source for hash syntax\" do\n      src = \"{ :a => 1, :b => 2, :c => 3 }\"\n      expect(stmt(src).jump(:hash).source).to eq \"{ :a => 1, :b => 2, :c => 3 }\"\n    end\n\n    it \"handles an empty hash\" do\n      expect(stmt(\"{}\").jump(:hash).source).to eq \"{}\"\n    end",
        "comment": "comment comment comment",
        "label": "Others",
        "id": "780"
    },
    {
        "raw_code": "def owned_by?(user)\n    owner == user\n  end",
        "comment": "Group would override this to check from association",
        "label": "Others",
        "id": "7265"
    },
    {
        "raw_code": "def self.notify(state, unset_env = false)\n      sock = ENV[\"NOTIFY_SOCKET\"]\n\n      return nil unless sock\n\n      ENV.delete(\"NOTIFY_SOCKET\") if unset_env\n\n      begin\n        Addrinfo.unix(sock, :DGRAM).connect do |s|\n          s.close_on_exec = true\n          s.write(state)\n        end",
        "comment": "Notify systemd with the provided state, via the notification socket, if any.  Generally this method will be used indirectly through the other methods of the library.  @param state [String] @param unset_env [Boolean]  @return [Fixnum, nil] the number of bytes written to the notification socket or nil if there was no socket to report to (eg. the program wasn't started by systemd)  @raise [NotifyError] if there was an error communicating with the systemd socket  @see https://www.freedesktop.org/software/systemd/man/sd_notify.html",
        "label": "Others",
        "id": "5196"
    },
    {
        "raw_code": "def self.render(file_name, input, context)\n      html = render_markup(file_name, input, context).force_encoding(input.encoding)\n\n      context[:pipeline] ||= :markup\n\n      html = Banzai.render(html, context)\n      html.html_safe\n    end",
        "comment": "Public: Converts the provided markup into HTML.  input         - the source text in a markup format ",
        "label": "Others",
        "id": "1410"
    },
    {
        "raw_code": "def resolve_normal_select_types\n            # Cross reference resolved sources with what is requested by the SELECT.\n            types = Columns.types(self)\n\n            # Mixed dynamic and static queries can be normalized to simply dynamic queries for the purposes of\n            # detecting mismatched set operator parts.\n            types.delete(Type::STATIC) if types.include?(Type::DYNAMIC)\n\n            types\n          end",
        "comment": "Standard SELECT, not a set operator (UNION/INTERSECT/EXCEPT)",
        "label": "Others",
        "id": "3188"
    },
    {
        "raw_code": "def quote_string(s)\n        s.gsub(\"\\\\\", '\\&\\&').gsub(\"'\", \"''\") # ' (for ruby-mode)\n      end",
        "comment": "Quotes a string, escaping any ' (single quote) and \\ (backslash) characters.",
        "label": "Others",
        "id": "13092"
    },
    {
        "raw_code": "def added_and_removed_lines\n      hunk = \"\n        --- a/app/views/layouts/preview/rapid_diffs.html.haml\t(revision eaba934a0bc6eed56cfd1f082e9fa3f5409f2938)\n        +++ b/app/views/layouts/preview/rapid_diffs.html.haml\t(date 1718119822001)\n        @@ -1,7 +1,6 @@\n        -= universal_stylesheet_link_tag 'application'\n        -= universal_stylesheet_link_tag 'application_utilities'\n         = universal_stylesheet_link_tag 'preview/rapid_diffs'\n         = webpack_bundle_tag 'javascripts/entrypoints/preview/rapid_diffs'\n        += webpack_bundle_tag 'javascripts/entrypoints/preview'\n\n        -%div{ style: 'padding: 20px' }\n        +%div{ style: 'padding: 20px', class: 'container-fluid' }\n           = yield\n      \"\n      render(::RapidDiffs::DiffFileComponent.new(diff_file: diff_file_from_hunk(hunk)))\n    end",
        "comment": "@!group Code",
        "label": "Others",
        "id": "8183"
    },
    {
        "raw_code": "def self.some_method\n            implement 1\n          end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10911"
    },
    {
        "raw_code": "def each_bad_alignment(items, base_column)\n        prev_line = -1\n        items.each do |current|\n          if current.loc.line > prev_line && begins_its_line?(current.source_range)\n            @column_delta = base_column - display_column(current.source_range)\n\n            yield current if @column_delta.nonzero?\n          end",
        "comment": "@api private",
        "label": "Others",
        "id": "10426"
    },
    {
        "raw_code": "def some_method\n            implement 1\n          end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10914"
    },
    {
        "raw_code": "def draw(name)\n          path = @draw_paths.find do |_path|\n            File.exist? \"#{_path}/#{name}.rb\"\n          end",
        "comment": "Loads another routes file with the given `name` located inside the `config/routes` directory. In that file, you can use the normal routing DSL, but *do not* surround it with a `Rails.application.routes.draw` block.  # config/routes.rb Rails.application.routes.draw do draw :admin                 # Loads `config/routes/admin.rb` draw \"third_party/some_gem\" # Loads `config/routes/third_party/some_gem.rb` end  # config/routes/admin.rb namespace :admin do resources :accounts end  # config/routes/third_party/some_gem.rb mount SomeGem::Engine, at: \"/some_gem\"  **CAUTION:** Use this feature with care. Having multiple routes files can negatively impact discoverability and readability. For most applications \u2014 even those with a few hundred routes \u2014 it's easier for developers to have a single routes file.",
        "label": "Others",
        "id": "11581"
    },
    {
        "raw_code": "def project_finder_params_ee\n      {}\n    end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "3794"
    },
    {
        "raw_code": "def filter_opts(header_size: nil)\n        {\n          filter: true,\n          per_page: header_size ? [(window_height - header_size), 10].max : 30\n        }\n      end",
        "comment": "Accepts a number of lines occupied by text, so remaining screen real estate can be filled with select options",
        "label": "Others",
        "id": "5333"
    },
    {
        "raw_code": "def default_extension\n        '.html'\n      end",
        "comment": "@api private",
        "label": "Others",
        "id": "10293"
    },
    {
        "raw_code": "def something\n          end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10926"
    },
    {
        "raw_code": "def blank_response\n    render plain: \" \"\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12044"
    },
    {
        "raw_code": "def migrate_queues\n      routing_rules_queues = mappings.values.uniq\n      logger&.info(\"List of queues based on routing rules: #{routing_rules_queues}\")\n      Sidekiq.redis do |conn|\n        # Redis 6 supports conn.scan_each(match: \"queue:*\", type: 'list')\n        conn.scan(\"MATCH\", \"queue:*\") do |key|\n          # Redis 5 compatibility\n          next unless conn.type(key) == 'list'\n\n          queue_from = key.split(':', 2).last\n          next if routing_rules_queues.include?(queue_from)\n\n          logger&.info(\"Migrating #{queue_from} queue\")\n\n          migrated = 0\n          while queue_length(queue_from) > 0\n            begin\n              if migrated >= 0 && migrated % LOG_FREQUENCY_QUEUES == 0\n                logger&.info(\"Migrating from #{queue_from}. Total: #{queue_length(queue_from)}. Migrated: #{migrated}.\")\n              end",
        "comment": "Migrates jobs from queues that are outside the mappings",
        "label": "Others",
        "id": "1466"
    },
    {
        "raw_code": "def output_options(opts)\n        opts.separator \"\"\n        opts.separator \"Output options:\"\n\n        opts.on('--one-file', 'Generates output as a single file') do\n          options.onefile = true\n        end",
        "comment": "Adds output options",
        "label": "Others",
        "id": "544"
    },
    {
        "raw_code": "def info(message)\n          @ui.info(message)\n        end",
        "comment": "Prints the given message at info level for a trigger  @param [String] message The string to be printed",
        "label": "Others",
        "id": "9045"
    },
    {
        "raw_code": "def split_array(arr)\n  first_arr = arr.take(arr.size / 2)\n  second_arr = arr - first_arr\n  [first_arr, second_arr]\nend",
        "comment": "Splits array into two halves",
        "label": "Others",
        "id": "5041"
    },
    {
        "raw_code": "def extra_info\n      {}\n    end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "5703"
    },
    {
        "raw_code": "def <<(part)\n    case part\n    when RDoc::Markup::Document then\n      unless part.empty? then\n        parts.concat part.parts\n        parts << RDoc::Markup::BlankLine.new\n      end",
        "comment": " Appends +part+ to the document",
        "label": "Others",
        "id": "16420"
    },
    {
        "raw_code": "def run_helm(cmd, stdin = nil)\n          helm_cmd = [\"helm\", *cmd]\n          helm_cmd.push(\"--repository-cache\", repository_cache) if repository_cache.present?\n          execute_shell(helm_cmd, stdin_data: stdin)\n        rescue Helpers::Shell::CommandFailure => e\n          raise(Error, e.message)\n        end",
        "comment": "Run helm command  @param [Array] cmd @return [String]",
        "label": "Others",
        "id": "3963"
    },
    {
        "raw_code": "def dangerous_attribute_method?(name) # :nodoc:\n        ::ActiveRecord::AttributeMethods.dangerous_attribute_methods.include?(name.to_s)\n      end",
        "comment": "A method name is 'dangerous' if it is already (re)defined by Active Record, but not by any ancestors. (So 'puts' is not dangerous but 'save' is.)",
        "label": "Others",
        "id": "12360"
    },
    {
        "raw_code": "def render_hello_world_with_forward_slash\n    render \"/test/hello_world\"\n  end",
        "comment": ":ported: compatibility",
        "label": "Others",
        "id": "12030"
    },
    {
        "raw_code": "def truncate\n    ProjectMember.truncate_team(project)\n  end",
        "comment": "Remove all users from project team",
        "label": "Others",
        "id": "6840"
    },
    {
        "raw_code": "def transform(context, data)\n          import_entity = context.entity\n\n          if import_entity.destination_namespace.present?\n            namespace = Namespace.find_by_full_path(import_entity.destination_namespace)\n          end",
        "comment": "rubocop: disable Style/IfUnlessModifier",
        "label": "Others",
        "id": "3607"
    },
    {
        "raw_code": "def annotate!(*args) # :nodoc:\n      self.annotate_values |= args\n      self\n    end",
        "comment": "Like #annotate, but modifies relation in place.",
        "label": "Others",
        "id": "13433"
    },
    {
        "raw_code": "def expand_path(path)\n    File.expand_path(path, File.join(__dir__, '../../..'))\n  end",
        "comment": "Expands a path relative to rails root. This module is used in non-rails contexts and so Rails.root cannot be used.",
        "label": "Others",
        "id": "8423"
    },
    {
        "raw_code": "def gitlab_shell_path\n      Gitlab.config.gitlab_shell.path\n    end",
        "comment": "Helper methods ",
        "label": "Others",
        "id": "3696"
    },
    {
        "raw_code": "def generate_file_files\n    page_file     = @template_dir + 'page.rhtml'\n    fileinfo_file = @template_dir + 'fileinfo.rhtml'\n\n    # for legacy templates\n    filepage_file = @template_dir + 'filepage.rhtml' unless\n      page_file.exist? or fileinfo_file.exist?\n\n    return unless\n      page_file.exist? or fileinfo_file.exist? or filepage_file.exist?\n\n    debug_msg \"Generating file documentation in #{@outputdir}\"\n\n    out_file = nil\n    current = nil\n\n    @files.each do |file|\n      current = file\n\n      if file.text? and page_file.exist? then\n        generate_page file\n        next\n      end",
        "comment": " Generate a documentation file for each file",
        "label": "Others",
        "id": "16463"
    },
    {
        "raw_code": "def sanitize_link_text!(node)\n        node.inner_html = node.inner_html.gsub(RTLO, ENCODED_RTLO)\n      end",
        "comment": "escape any right-to-left (RTLO) characters in link text",
        "label": "Others",
        "id": "3464"
    },
    {
        "raw_code": "def normalized? # :nodoc:\n    @normalized\n  end",
        "comment": " Was this text normalized?",
        "label": "Others",
        "id": "15962"
    },
    {
        "raw_code": "def new_note(note, current_user)\n    handle_note(note, current_user)\n  end",
        "comment": "When create a note we should:  * mark all pending todos related to the noteable for the note author as done * create a todo for each mentioned user on note ",
        "label": "Others",
        "id": "5443"
    },
    {
        "raw_code": "def lateral_relation\n            original_relation\n              .unscope(where: foreign_key) # unscoping the where condition generated for the placeholder_record.\n              .where(klass.arel_table[foreign_key].eq(active_record.arel_table[active_record_primary_key]))\n          end",
        "comment": "This only works for HasMany and HasOne.",
        "label": "Others",
        "id": "2104"
    },
    {
        "raw_code": "def prevent_token_assignment\n      if token.present? && token_changed?\n        self.token = nil\n        self.encrypted_token = encrypted_token_was\n        self.encrypted_token_iv = encrypted_token_iv_was\n      end",
        "comment": "Blank token assignment triggers token reset",
        "label": "Others",
        "id": "7223"
    },
    {
        "raw_code": "def config\n        raise NotImplementedError\n      end",
        "comment": "This can be overridden for a custom config",
        "label": "Others",
        "id": "3237"
    },
    {
        "raw_code": "def last?\n      index == size - 1\n    end",
        "comment": "Check if this is the last iteration of the partial.",
        "label": "Others",
        "id": "12004"
    },
    {
        "raw_code": "def accept_list_end(list)\n    @list_index.pop\n    @list_type.pop\n    @list_width.pop\n  end",
        "comment": " Finishes consumption of +list+",
        "label": "Others",
        "id": "16197"
    },
    {
        "raw_code": "def self.should_push_code?(change, push_when_approved)\n        return false if change.already_approved? && !push_when_approved\n\n        change.update_required?(:code)\n      end",
        "comment": "We do not want to push code if the MR already has approvals as it will reset the approvals. Also we do not push if someone else has added commits already.",
        "label": "Others",
        "id": "1248"
    },
    {
        "raw_code": "def binary? # :nodoc:\n        false\n      end",
        "comment": "These predicates are not documented, as I need to look further into their use, and see if they can be removed entirely.",
        "label": "Others",
        "id": "12298"
    },
    {
        "raw_code": "def todoable_target_type_name\n    %w[Issue WorkItem]\n  end",
        "comment": "Todo: remove method after target_type cleanup See https://gitlab.com/gitlab-org/gitlab/-/issues/416009",
        "label": "Others",
        "id": "6784"
    },
    {
        "raw_code": "def apply_composition!(*args)\n          block = args.detect{|arg| arg.is_a?(Proc) }\n          execute_args = [\"up\", \"--remove-orphans\"]\n          if args.include?(:detach)\n            execute_args << \"-d\"\n          end",
        "comment": "Apply any changes made to the composition",
        "label": "Others",
        "id": "9506"
    },
    {
        "raw_code": "def _Eof\n    _save = self.pos\n    _tmp = get_byte\n    _tmp = _tmp ? nil : true\n    self.pos = _save\n    set_failed_rule :_Eof unless _tmp\n    return _tmp\n  end",
        "comment": "Eof = !.",
        "label": "Others",
        "id": "15797"
    },
    {
        "raw_code": "def <=>(other_object)\n      if other_object.is_a?(self.class)\n        to_key <=> other_object.to_key\n      else\n        super\n      end",
        "comment": "Allows sort on objects",
        "label": "Others",
        "id": "12433"
    },
    {
        "raw_code": "def benchmark(message = \"Benchmarking\", options = {}, &block)\n      if logger\n        options.assert_valid_keys(:level, :silence)\n        options[:level] ||= :info\n\n        result = nil\n        ms = ActiveSupport::Benchmark.realtime(:float_millisecond) do\n          result = options[:silence] ? logger.silence(&block) : yield\n        end",
        "comment": "Allows you to measure the execution time of a block in a template and records the result to the log. Wrap this block around expensive operations or possible bottlenecks to get a time reading for the operation. For example, let's say you thought your file processing method was taking too long; you could wrap it in a benchmark block.  <% benchmark 'Process data files' do %> <%= expensive_files_operation %> <% end %>  That would add something like \"Process data files (345.2ms)\" to the log, which you can then use to compare timings when optimizing your code.  You may give an optional logger level (<tt>:debug</tt>, <tt>:info</tt>, <tt>:warn</tt>, <tt>:error</tt>) as the <tt>:level</tt> option. The default logger level value is <tt>:info</tt>.  <% benchmark 'Low-level files', level: :debug do %> <%= lowlevel_files_operation %> <% end %>  Finally, you can pass true as the third argument to silence all log activity (other than the timing information) from inside the block. This is great for boiling down a noisy block to just a single statement that produces one log line:  <% benchmark 'Process data files', level: :info, silence: true do %> <%= expensive_and_chatty_files_operation %> <% end %>",
        "label": "Others",
        "id": "13715"
    },
    {
        "raw_code": "def translate(locale)\n        translated_text = String.new(\"\")\n        parse do |part|\n          case part[:type]\n          when :markup\n            translated_text << part[:line]\n          when :attribute\n            prefix = \"#{part[:prefix]}#{part[:name]}#{part[:infix]}\"\n            value = locale.translate(part[:value])\n            suffix = part[:suffix]\n            translated_text << \"#{prefix}#{value}#{suffix}\"\n          when :paragraph\n            translated_text << locale.translate(part[:paragraph])\n          when :empty_line\n            translated_text << part[:line]\n          else\n            raise \"should not reach here: unexpected type: #{type}\"\n          end",
        "comment": "Translates into +locale+.  @param [Locale] locale the translation target locale. @return [String] translated text.",
        "label": "Others",
        "id": "720"
    },
    {
        "raw_code": "def build_auth_user_params\n    { organization_id: Current.organization.id }\n  end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "6411"
    },
    {
        "raw_code": "def first_contribution?\n    false\n  end",
        "comment": " Override in issuable specialization ",
        "label": "Others",
        "id": "7407"
    },
    {
        "raw_code": "def to_html(text)\n    html = (''.encode text.encoding).dup\n\n    encoded = RDoc::Text::TO_HTML_CHARACTERS[text.encoding]\n\n    s = StringScanner.new text\n    insquotes = false\n    indquotes = false\n    after_word = nil\n\n    until s.eos? do\n      case\n      when s.scan(/<(tt|code)>.*?<\\/\\1>/) then # skip contents of tt\n        html << s.matched.gsub('\\\\\\\\', '\\\\')\n      when s.scan(/<(tt|code)>.*?/) then\n        warn \"mismatched <#{s[1]}> tag\" # TODO signal file/line\n        html << s.matched\n      when s.scan(/<[^>]+\\/?s*>/) then # skip HTML tags\n        html << s.matched\n      when s.scan(/\\\\(\\S)/) then # unhandled suppressed crossref\n        html << s[1]\n        after_word = nil\n      when s.scan(/\\.\\.\\.(\\.?)/) then\n        html << s[1] << encoded[:ellipsis]\n        after_word = nil\n      when s.scan(/\\(c\\)/i) then\n        html << encoded[:copyright]\n        after_word = nil\n      when s.scan(/\\(r\\)/i) then\n        html << encoded[:trademark]\n        after_word = nil\n      when s.scan(/---/) then\n        html << encoded[:em_dash]\n        after_word = nil\n      when s.scan(/--/) then\n        html << encoded[:en_dash]\n        after_word = nil\n      when s.scan(/&quot;|\"/) then\n        html << encoded[indquotes ? :close_dquote : :open_dquote]\n        indquotes = !indquotes\n        after_word = nil\n      when s.scan(/``/) then # backtick double quote\n        html << encoded[:open_dquote]\n        after_word = nil\n      when s.scan(/(?:&#39;|'){2}/) then # tick double quote\n        html << encoded[:close_dquote]\n        after_word = nil\n      when s.scan(/`/) then # backtick\n        if insquotes or after_word\n          html << '`'\n          after_word = false\n        else\n          html << encoded[:open_squote]\n          insquotes = true\n        end",
        "comment": " Converts ampersand, dashes, ellipsis, quotes, copyright and registered trademark symbols in +text+ to properly encoded characters.",
        "label": "Others",
        "id": "15567"
    },
    {
        "raw_code": "def self.provider(name=UNSET_VALUE, &block)\n          data[:providers] ||= Registry.new\n\n          # Register a new provider class only if a name was given\n          data[:providers].register(name.to_sym, &block) if name != UNSET_VALUE\n\n          # Return the registry\n          data[:providers]\n        end",
        "comment": "Registers additional providers to be available.  @param [Symbol] name Name of the provider.",
        "label": "Others",
        "id": "9009"
    },
    {
        "raw_code": "def self.config_for_pwd(env)\n      Util.silence_warnings do\n        # Suppress any config issues when loading the config (ie. deprecations,\n        # pending cops, etc.).\n        env.config_store.unvalidated.for_pwd\n      end",
        "comment": "@api private",
        "label": "Others",
        "id": "10085"
    },
    {
        "raw_code": "def resource_api_path(resource)\n        default = 'Cannot find resource API path'\n\n        if resource.respond_to?(:api_delete_path)\n          resource.api_delete_path.gsub('%2F', '/')\n        elsif resource.respond_to?(:api_get_path)\n          resource.api_get_path.gsub('%2F', '/')\n        else\n          default\n        end",
        "comment": "Determine resource api path or return default value Some resources fabricated via UI can raise no attribute error  @param [QA::Resource::Base] resource @return [String]",
        "label": "Others",
        "id": "4721"
    },
    {
        "raw_code": "def no_referrer\n    headers[\"Referrer-Policy\"] = \"no-referrer\"\n  end",
        "comment": "Avoid leaking confirmation token in referrer header on certain pages",
        "label": "Others",
        "id": "9959"
    },
    {
        "raw_code": "def self.jobs(limit = 1000)\n    deployable_ids = where.not(deployable_id: nil).limit(limit).pluck(:deployable_id)\n\n    Ci::Processable.where(id: deployable_ids)\n  end",
        "comment": "It should be used with caution especially on chaining. Fetching any unbounded or large intermediate dataset could lead to loading too many IDs into memory. See: https://docs.gitlab.com/ee/development/database/multiple_databases.html#use-disable_joins-for-has_one-or-has_many-through-relations For safety we default limit to fetch not more than 1000 records.",
        "label": "Others",
        "id": "6680"
    },
    {
        "raw_code": "def decrypt\n        decrypt_attributes if has_encrypted_attributes?\n      end",
        "comment": "Decrypts all the encryptable attributes and saves the changes.",
        "label": "Others",
        "id": "13311"
    },
    {
        "raw_code": "def render_template_in_top_directory\n    render template: \"shared\"\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12031"
    },
    {
        "raw_code": "def marshal_dump\n        ivars = (instance_variables - [:@reflection, :@through_reflection]).map { |name| [name, instance_variable_get(name)] }\n        [@reflection.name, ivars]\n      end",
        "comment": "We can't dump @reflection and @through_reflection since it contains the scope proc",
        "label": "Others",
        "id": "12754"
    },
    {
        "raw_code": "def add_heredoc_comma(corrector, node)\n          return unless heredoc?(node)\n\n          corrector.insert_after(node.child_nodes.last, ',')\n        end",
        "comment": "Add a comma back after the heredoc identifier",
        "label": "Others",
        "id": "10478"
    },
    {
        "raw_code": "def delete_by_value(name, value)\n      Sidekiq.redis do |conn|\n        ret = conn.zrem(name, value)\n        @_size -= 1 if ret\n        ret\n      end",
        "comment": ":nodoc: @api private",
        "label": "Others",
        "id": "5139"
    },
    {
        "raw_code": "def column_range\n        location.column_range\n      end",
        "comment": "@api private",
        "label": "Others",
        "id": "10243"
    },
    {
        "raw_code": "def <<(item)\n    @items << item\n  end",
        "comment": " Appends +item+ to the list",
        "label": "Others",
        "id": "16395"
    },
    {
        "raw_code": "def some_method\n            implement 1\n          end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10919"
    },
    {
        "raw_code": "def set_puma_worker_count(count)\n          @puma_worker_count = count\n        end",
        "comment": "Added to support Puma 7 to replace accessing Puma options directly.",
        "label": "Others",
        "id": "1973"
    },
    {
        "raw_code": "def self.my_testing_alias(test_name, &)\n    define_method(:\"test_#{test_name}\", &)\n  end",
        "comment": "Check that extensions can provide aliases for testing methods",
        "label": "Others",
        "id": "14829"
    },
    {
        "raw_code": "def initialize(lines, annotations)\n          @lines       = lines.freeze\n          @annotations = annotations.sort.freeze\n        end",
        "comment": "@param lines [Array<String>] @param annotations [Array<(Integer, String)>] each entry is the annotated line number and the annotation text  @note annotations are sorted so that reconstructing the annotation text via {#to_s} is deterministic",
        "label": "Others",
        "id": "10712"
    },
    {
        "raw_code": "def transform_quick_action_params(command_params)\n    common_params = command_params.dup\n    widget_params = {}\n\n    work_item_type.widget_classes(resource_parent)\n          .filter { |widget| widget.respond_to?(:quick_action_params) }\n          .each do |widget|\n            widget.quick_action_params\n              .filter { |param_name| common_params.key?(param_name) }\n              .each do |param_name|\n                widget_params[widget.api_symbol] ||= {}\n                param_value = common_params.delete(param_name)\n\n                widget_params[widget.api_symbol].merge!(widget.process_quick_action_param(param_name, param_value))\n              end",
        "comment": "Widgets have a set of quick action params that they must process. Map them to widget_params so they can be picked up by widget services.",
        "label": "Others",
        "id": "6786"
    },
    {
        "raw_code": "def headers(hash = nil)\n      response.headers.merge! hash if hash\n      response.headers\n    end",
        "comment": "Set multiple response headers with Hash.",
        "label": "Others",
        "id": "8551"
    },
    {
        "raw_code": "def self.query(projects, public_only: true)\n      open_issues = Issue.opened.without_hidden\n\n      if public_only\n        open_issues.public_only.where(project: projects)\n      else\n        open_issues.where(project: projects)\n      end",
        "comment": "We only show issues count including confidential for planners, who are allowed to view confidential issues. This will still show a discrepancy on issues number but should be less than before. Check https://gitlab.com/gitlab-org/gitlab-foss/issues/38418 description.",
        "label": "Others",
        "id": "5928"
    },
    {
        "raw_code": "def method_missing(name, *args, &block)\n    if response && response.respond_to?(name)\n      response.send(name, *args, &block)\n    else\n      super\n    end",
        "comment": "Delegate other missing methods to response.",
        "label": "Others",
        "id": "8709"
    },
    {
        "raw_code": "def method3\n            end",
        "comment": "{modifier}",
        "label": "Others",
        "id": "10982"
    },
    {
        "raw_code": "def could_not_move(exception); end\n\n  # Override if the implementing class is not a simple application record, for\n  # example if the record is loaded from a union.\n  def reset_relative_position\n    reset.relative_position\n  end\n\n  # Override if the model class needs a more complicated computation (e.g. the\n  # object is a member of a union).\n  def model_class\n    self.class\n  end\nend",
        "comment": "Override if you want to be notified of failures to move",
        "label": "Others",
        "id": "7291"
    },
    {
        "raw_code": "def aref_prefix\n    'attribute'\n  end",
        "comment": " The #aref prefix for attributes",
        "label": "Others",
        "id": "16704"
    },
    {
        "raw_code": "def where_clause_arel_nodes\n      return [where_clause_ast] unless where_clause_ast.respond_to?(:children)\n\n      where_clause_ast.children\n    end",
        "comment": "`ActiveRecord::WhereClause#ast` is returning a single node when there is only one predicate but returning an `Arel::Nodes::And` node if there are more than one predicates. This is why we are checking the returned object responds to `children` or not.",
        "label": "Others",
        "id": "3589"
    },
    {
        "raw_code": "def method_missing(method, ...)\n        result = @wrapped_string.__send__(method, ...)\n        if method.end_with?(\"!\")\n          self if result\n        else\n          result.kind_of?(String) ? chars(result) : result\n        end",
        "comment": "Forward all undefined methods to the wrapped string.",
        "label": "Others",
        "id": "14492"
    },
    {
        "raw_code": "def find_offense_message(begin_node, node)\n          return 'a keyword' if keyword_with_redundant_parentheses?(node)\n          return 'a literal' if node.literal? && disallowed_literal?(begin_node, node)\n          return 'a variable' if node.variable?\n          return 'a constant' if node.const_type?\n          if node.assignment? && (begin_node.parent.nil? || begin_node.parent.begin_type?)\n            return 'an assignment'\n          end",
        "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength, Metrics/PerceivedComplexity",
        "label": "Others",
        "id": "10563"
    },
    {
        "raw_code": "def now\n        @now ||= FlashNow.new(self)\n      end",
        "comment": "Sets a flash that will not be available to the next action, only to the current.  flash.now[:message] = \"Hello current action\"  This method enables you to use the flash as a central messaging system in your app. When you need to pass an object to the next action, you use the standard flash assign (`[]=`). When you need to pass an object to the current action, you use `now`, and your object will vanish when the current action is done.  Entries set via `now` are accessed the same way as standard entries: `flash['my-key']`.  Also, brings two convenience accessors:  flash.now.alert = \"Beware now!\" # Equivalent to flash.now[:alert] = \"Beware now!\"  flash.now.notice = \"Good luck now!\" # Equivalent to flash.now[:notice] = \"Good luck now!\"",
        "label": "Others",
        "id": "11526"
    },
    {
        "raw_code": "def self.root\n    options.storage_path\n  end",
        "comment": "Re-Override",
        "label": "Others",
        "id": "8063"
    },
    {
        "raw_code": "def skip_for_grouping?(node)\n          node.right_siblings.any?(&:casgn_type?) &&\n            node.right_siblings.any? { |n| n.send_type? && groupable_sibling_accessor?(node, n) }\n        end",
        "comment": "Group after constants",
        "label": "Others",
        "id": "10536"
    },
    {
        "raw_code": "def self.allow_requests!\n        @@block_requests.value = false\n      end",
        "comment": "Allows the server to accept requests again.",
        "label": "Others",
        "id": "2748"
    },
    {
        "raw_code": "def test_render_xml\n    get :render_xml_hello\n    assert_equal \"<html>\\n  <p>Hello David</p>\\n<p>This is grand!</p>\\n</html>\\n\", @response.body\n    assert_equal \"application/xml\", @response.media_type\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12083"
    },
    {
        "raw_code": "def translate(locale)\n    translated_text = ''\n    parse do |part|\n      case part[:type]\n      when :paragraph\n        translated_text += locale.translate(part[:paragraph])\n      when :empty_line\n        translated_text += part[:line]\n      else\n        raise \"should not reach here: unexpected type: #{type}\"\n      end",
        "comment": "Translates raw text into +locale+.",
        "label": "Others",
        "id": "16624"
    },
    {
        "raw_code": "def custom_metrics_tags(metadata)\n          custom_metrics(metadata, :tags)\n        end",
        "comment": "Additional custom metrics tags  @param [Hash] metadata @return [Hash]",
        "label": "Others",
        "id": "4641"
    },
    {
        "raw_code": "def spinner_success(done_message, io)\n          return spinner.success(done_message) if tty?\n\n          spinner.stop if spinner.spinning?\n          puts_with_offset(io, \"[#{success_mark}] #{spinner_message} ... #{done_message}\")\n        end",
        "comment": "Return spinner success  @param [String] done_message @param [IO] io @return [void]",
        "label": "Others",
        "id": "4064"
    },
    {
        "raw_code": "def some_method\n              implement 1\n            end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10941"
    },
    {
        "raw_code": "def cop_config\n        # Use department configuration as basis, but let individual cop\n        # configuration override.\n        @cop_config ||= @config.for_badge(self.class.badge)\n      end",
        "comment": "Configuration Helpers",
        "label": "Others",
        "id": "10261"
    },
    {
        "raw_code": "def extract_first_element_over_column_limit(node, elements, max)\n        line = node.first_line\n\n        # If a `send` or `csend` node is not parenthesized, don't move the first element, because it\n        # can result in changed behavior or a syntax error.\n        if node.call_type? && !node.parenthesized? && !first_argument_is_heredoc?(node)\n          elements = elements.drop(1)\n        end",
        "comment": "@api private",
        "label": "Others",
        "id": "10403"
    },
    {
        "raw_code": "def validation_message(opts)\n      return @validation_message if defined?(@validation_message)\n\n      prepare!\n\n      @validation_message = Gitlab::Ci::Lint\n        .new(project: opts[:project], current_user: opts[:user], sha: opts[:sha], verify_project_sha: false)\n        .legacy_validate(blob.data).errors.first\n    end",
        "comment": "rubocop:enable Lint/UnusedMethodArgument",
        "label": "Others",
        "id": "7638"
    },
    {
        "raw_code": "def some_method\n              implement 1\n            end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10936"
    },
    {
        "raw_code": "def all(**kwargs)\n        raise NotImplementedError\n      end",
        "comment": "To be overridden by Resource classes to return a list of all instances of the resource  @params [Hash] kwargs arguments to be used to query the API to search for resources with a specific criteria @return [Array]",
        "label": "Others",
        "id": "4134"
    },
    {
        "raw_code": "def each_partition\n        partition_names.each do |name|\n          yield name\n        end",
        "comment": "Iterator for operating on partitions",
        "label": "Others",
        "id": "1122"
    },
    {
        "raw_code": "def setup_authorizations\n      if @project.group\n        group_access_level = @project.group.max_member_access_for_user(\n          current_user,\n          only_concrete_membership: true\n        )\n\n        if group_access_level > GroupMember::NO_ACCESS\n          ProjectAuthorization.find_or_create_authorization_for(current_user.id, @project.id, group_access_level)\n        end",
        "comment": "Add an authorization for the current user authorizations inline (so they can access the project immediately after this request completes), and any other affected users in the background",
        "label": "Others",
        "id": "5905"
    },
    {
        "raw_code": "def use_snooze_custom_sort?\n    filter_pending_only?\n  end",
        "comment": "We only need to surface snoozed to-dos when querying pending items. The special sort order is unnecessary in the `Done` and `All` tabs where we can simply sort by ID (= creation date).",
        "label": "Others",
        "id": "7928"
    },
    {
        "raw_code": "def try_load_object(name, cache_path)\n        obj = Registry.at(name)\n        cache_object(name, cache_path) if obj && cache_path\n        obj\n      end",
        "comment": "Tries to load the object with name. If successful, caches the object with the cache_path  @param [String] name the object path @param [String] cache_path the location of the yardoc db containing the object to cache for future lookups. No caching is done if this is nil. @return [void]",
        "label": "Others",
        "id": "494"
    },
    {
        "raw_code": "def to_sort\n        [queue_namespace ? 0 : 1, generated_queue_name]\n      end",
        "comment": "Put namespaced queues first",
        "label": "Others",
        "id": "2024"
    },
    {
        "raw_code": "def something\n          end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10928"
    },
    {
        "raw_code": "def with_db_config(&block)\n    yield\n  end",
        "comment": "Overridden in EE to use custom connections",
        "label": "Others",
        "id": "8421"
    },
    {
        "raw_code": "def issue_supports_multiple_assignees?\n    false\n  end",
        "comment": "Overwritten",
        "label": "Others",
        "id": "7793"
    },
    {
        "raw_code": "def default(rubygem: Rubygem.first!, number: \"1.0.0\", platform: \"ruby\", version_gid: rubygem.versions.where(number:, platform:).first&.to_gid)\n    event = FactoryBot.build(:events_rubygem_event, rubygem:, tag: Events::RubygemEvent::VERSION_UNYANKED, additional:\n    {\n      number:,\n      platform:,\n\n      version_gid:\n    })\n    render Events::RubygemEvent::Version::UnyankedComponent.new(\n      event:\n    )\n  end",
        "comment": "@param number text @param platform text",
        "label": "Others",
        "id": "10033"
    },
    {
        "raw_code": "def delimited_string_literal?(node)\n          loc = node.location\n\n          loc.respond_to?(:begin) && loc.begin && loc.respond_to?(:end) && loc.end\n        end",
        "comment": "Some special kinds of string literals are not composed of literal characters between two delimiters: - The source map of `?a` responds to :begin and :end but its end is nil. - The source map of `__FILE__` responds to neither :begin nor :end.",
        "label": "Others",
        "id": "10479"
    },
    {
        "raw_code": "def accept_paragraph(paragraph)\n    para = @in_list_entry.last || \"<p>\"\n\n    text = paragraph.text @hard_break\n\n    @res << \"#{para}#{to_html text}\\n\"\n\n    add_paragraph\n  end",
        "comment": " Adds +paragraph+ to the output",
        "label": "Others",
        "id": "16402"
    },
    {
        "raw_code": "def importers(project)\n          [\n            Importer::IssuesImporter,\n            diff_notes_importer(project)\n          ]\n        end",
        "comment": "The importers to run in this stage. Issues can't be imported earlier on as we also use these to enrich pull requests with assigned labels.",
        "label": "Others",
        "id": "6310"
    },
    {
        "raw_code": "def project_work_item_epics_available?\n    false\n  end",
        "comment": "Not available in FOSS. This method is Overridden in EE",
        "label": "Others",
        "id": "6270"
    },
    {
        "raw_code": "def parse_subtree src\n  @subparser ||= RDoc::RD::BlockParser.new\n\n  @subparser.parse src\nend",
        "comment": " Parses subtree +src+",
        "label": "Others",
        "id": "16510"
    },
    {
        "raw_code": "def test_access_to_request_in_view\n    get :accessing_request_in_template\n    assert_equal \"Hello: www.nextangle.com\", @response.body\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12080"
    },
    {
        "raw_code": "def some_method\n              implement 1\n            end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10943"
    },
    {
        "raw_code": "def render_text_with_nil\n    render plain: nil\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12040"
    },
    {
        "raw_code": "def after_successful_create_hook(user); end\n\n  # method overridden in EE\n  def after_successful_update_hook(user); end\n\n  def after_successful_create_flash\n    { notice: _('User was successfully created.') }\n  end\n\n  def after_successful_update_flash\n    { notice: _('User was successfully updated.') }\n  end\n\n  def filter_users\n    User.filter_items(params[:filter]).order_name_asc\n  end\n\n  def safe_params\n    params.permit(:personal_projects_page, :projects_page, :groups_page)\n  end\nend\n\nAdmin::UsersController.prepend_mod_with('Admin::UsersController')",
        "comment": "method overridden in EE",
        "label": "Others",
        "id": "6455"
    },
    {
        "raw_code": "def scenario_examples\n          @scenario_examples ||= ScenarioExamples.fetch(tests)\n        end",
        "comment": "Specific examples to be executed  @return [Hash<Class, Array<String>]",
        "label": "Others",
        "id": "4779"
    },
    {
        "raw_code": "def destroy\n    service.delete(key)\n  end",
        "comment": "Deletes variant file from service.",
        "label": "Others",
        "id": "13640"
    },
    {
        "raw_code": "def run_thread\n      raise NotImplementedError\n    end",
        "comment": "Executed in separate thread",
        "label": "Others",
        "id": "1511"
    },
    {
        "raw_code": "def index_of(list, element)\n        raise NotImplementedError\n      end",
        "comment": "Classes including this method will have to define the way to identify elements through this method",
        "label": "Others",
        "id": "3693"
    },
    {
        "raw_code": "def cross_project_reference?(from)\n    case from\n    when Project\n      from.project_namespace_id != id\n    else\n      from && self != from\n    end",
        "comment": "Check if a reference is being done cross-project",
        "label": "Others",
        "id": "6694"
    },
    {
        "raw_code": "def remove_duplicate_assignees\n          associations = %w[issue_assignees merge_request_assignees merge_request_reviewers approvals]\n\n          associations.each do |association|\n            next unless @relation_hash.key?(association)\n            next unless @relation_hash[association].is_a?(Array)\n            next if @relation_hash[association].empty?\n\n            @relation_hash[association].select! { |record| record.respond_to?(:user_id) }\n            @relation_hash[association].uniq!(&:user_id)\n          end",
        "comment": "When an assignee (or any other listed association) did not exist in the members mapper, the importer is assigned. We only need to assign each user once.",
        "label": "Others",
        "id": "2831"
    },
    {
        "raw_code": "def initialize(\n      project_path: ENV['CI_PROJECT_PATH'],\n      gitlab_token: ENV['GITLAB_PROJECT_PACKAGES_CLEANUP_API_TOKEN'],\n      api_endpoint: ENV['CI_API_V4_URL'],\n      options: {}\n    )\n      @project_path = project_path\n      @gitlab_token = gitlab_token\n      @api_endpoint = api_endpoint\n      @dry_run = options[:dry_run]\n\n      puts \"Dry-run mode.\" if dry_run\n    end",
        "comment": "$GITLAB_PROJECT_PACKAGES_CLEANUP_API_TOKEN => `Packages Cleanup` project token",
        "label": "Others",
        "id": "5371"
    },
    {
        "raw_code": "def not_created_instances\n        pending_instances_count = wanted_instances - filtered_pods_by_track.count\n\n        return [] if pending_instances_count <= 0\n\n        Array.new(pending_instances_count, deployment_instance(pod_name: 'Not provided', pod_status: 'Pending'))\n      end",
        "comment": "These are replicas that did not get created yet, So they still do not have any associated pod, these are marked as pending instances.",
        "label": "Others",
        "id": "2062"
    },
    {
        "raw_code": "def initialize(filters = [], mask: FILTERED)\n      @mask = mask\n      compile_filters!(filters)\n    end",
        "comment": "Create instance with given filters. Supported type of filters are +String+, +Regexp+, and +Proc+. Other types of filters are treated as +String+ using +to_s+. For +Proc+ filters, key, value, and optional original hash is passed to block arguments.  ==== Options  * <tt>:mask</tt> - A replaced object when filtered. Defaults to <tt>\"[FILTERED]\"</tt>.",
        "label": "Others",
        "id": "13926"
    },
    {
        "raw_code": "def ref_param_name\n              'FOO_BAR_BRANCH'\n            end",
        "comment": "Must be overridden",
        "label": "Others",
        "id": "8275"
    },
    {
        "raw_code": "def test_render_action\n    get :render_action_hello_world\n    assert_equal \"Hello world!\", @response.body\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12062"
    },
    {
        "raw_code": "def merge(other_entry)\n    options = {\n      :extracted_comment  => merge_string(@extracted_comment,\n                                          other_entry.extracted_comment),\n      :translator_comment => merge_string(@translator_comment,\n                                          other_entry.translator_comment),\n      :references         => merge_array(@references,\n                                         other_entry.references),\n      :flags              => merge_array(@flags,\n                                         other_entry.flags),\n    }\n    self.class.new(@msgid, options)\n  end",
        "comment": " Merges the PO entry with +other_entry+.",
        "label": "Others",
        "id": "16494"
    },
    {
        "raw_code": "def initialize(name)\n      @name = name\n      @_size = size\n    end",
        "comment": ":nodoc: @api private",
        "label": "Others",
        "id": "5130"
    },
    {
        "raw_code": "def external_dependency_checksum\n        nil\n      end",
        "comment": "This method should be overridden when a cop's behavior depends on state that lives outside of these locations:  (1) the file under inspection (2) the cop's source code (3) the config (eg a .rubocop.yml file)  For example, some cops may want to look at other parts of the codebase being inspected to find violations. A cop may use the presence or absence of file `foo.rb` to determine whether a certain violation exists in `bar.rb`.  Overriding this method allows the cop to indicate to RuboCop's ResultCache system when those external dependencies change, ie when the ResultCache should be invalidated.",
        "label": "Others",
        "id": "10260"
    },
    {
        "raw_code": "def always_autocorrect?\n        # `true` is the same as `'always'` for backward compatibility.\n        ['always', true].include?(cop_config.fetch('AutoCorrect', 'always'))\n      end",
        "comment": "@api private",
        "label": "Others",
        "id": "10269"
    },
    {
        "raw_code": "def tables_dependencies\n        @tables.index_with do |table_name|\n          all_foreign_keys[table_name]\n        end",
        "comment": "it maps the tables to the tables that depend on it",
        "label": "Others",
        "id": "2965"
    },
    {
        "raw_code": "def pluck(*keys)\n    if keys.many?\n      map { |element| keys.map { |key| element[key] } }\n    else\n      key = keys.first\n      map { |element| element[key] }\n    end",
        "comment": "Extract the given key from each element in the enumerable.  [{ name: \"David\" }, { name: \"Rafael\" }, { name: \"Aaron\" }].pluck(:name) # => [\"David\", \"Rafael\", \"Aaron\"]  [{ id: 1, name: \"David\" }, { id: 2, name: \"Rafael\" }].pluck(:id, :name) # => [[1, \"David\"], [2, \"Rafael\"]]",
        "label": "Others",
        "id": "14073"
    },
    {
        "raw_code": "def groups(lookahead:)\n        key = ::Gitlab::Graphql::BatchKey.new(object, lookahead, object_name: :stage)\n\n        BatchLoader::GraphQL.for(key).batch(default_value: []) do |keys, loader|\n          by_pipeline = keys.group_by(&:pipeline)\n          include_needs = keys.any? do |k|\n            k.requires?(%i[nodes jobs nodes needs]) ||\n              k.requires?(%i[nodes jobs nodes previousStageJobsOrNeeds])\n          end",
        "comment": "Issues one query per pipeline",
        "label": "Others",
        "id": "6218"
    },
    {
        "raw_code": "def post_update_hooks(project, _old_group)\n      ensure_personal_project_owner_membership(project)\n      invalidate_personal_projects_counts\n\n      publish_event\n    end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "5896"
    },
    {
        "raw_code": "def reset_investigation\n        @currently_disabled_lines = @current_offenses = @processed_source = @current_corrector = nil\n      end",
        "comment": "Actually private methods",
        "label": "Others",
        "id": "10274"
    },
    {
        "raw_code": "def self_and_upstreams\n      object_hierarchy.base_and_ancestors\n    end",
        "comment": "With multi-project and parent-child pipelines",
        "label": "Others",
        "id": "7569"
    },
    {
        "raw_code": "def template_glob(glob)\n        query = File.join(escape_entry(@path), glob)\n        path_with_slash = File.join(@path, \"\")\n\n        Dir.glob(query).filter_map do |filename|\n          filename = File.expand_path(filename)\n          next if File.directory?(filename)\n          next unless filename.start_with?(path_with_slash)\n\n          filename\n        end",
        "comment": "Safe glob within @path",
        "label": "Others",
        "id": "12022"
    },
    {
        "raw_code": "def add_also_in(out, also_in)\n    return if also_in.empty?\n\n    out << RDoc::Markup::Rule.new(1)\n    out << RDoc::Markup::Paragraph.new(\"Also found in:\")\n\n    paths = RDoc::Markup::Verbatim.new\n    also_in.each do |store|\n      paths.parts.push store.friendly_path, \"\\n\"\n    end",
        "comment": " Adds paths for undocumented classes +also_in+ to +out+",
        "label": "Others",
        "id": "16574"
    },
    {
        "raw_code": "def self.autocorrect_incompatible_with\n        []\n      end",
        "comment": "List of cops that should not try to autocorrect at the same time as this cop  @return [Array<RuboCop::Cop::Base>]  @api public",
        "label": "Others",
        "id": "10247"
    },
    {
        "raw_code": "def merge_collections(mine, other, other_files, &block) # :nodoc:\n    my_things    = mine. group_by { |thing| thing.file }\n    other_things = other.group_by { |thing| thing.file }\n\n    remove_things my_things, other_files,  &block\n    add_things    my_things, other_things, &block\n  end",
        "comment": " Merges collection +mine+ with +other+ preferring other.  +other_files+ is used to help determine which items should be deleted.  Yields whether the item should be added or removed (true or false) and the item to be added or removed.  merge_collections things, other.things, other.in_files do |add, thing| if add then # add the thing else # remove the thing end end",
        "label": "Others",
        "id": "16752"
    },
    {
        "raw_code": "def set_fixture_class(class_names = {})\n        self.fixture_class_names = fixture_class_names.merge(class_names.stringify_keys)\n      end",
        "comment": "Sets the model class for a fixture when the class name cannot be inferred from the fixture name.  Examples:  set_fixture_class some_fixture:        SomeModel, 'namespaced/fixture' => Another::Model  The keys must be the fixture names, that coincide with the short paths to the fixture files.",
        "label": "Others",
        "id": "12702"
    },
    {
        "raw_code": "def validate(_protection_rule); end\n    end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "5595"
    },
    {
        "raw_code": "def supports_analyze?\n      conn.mariadb? && conn.database_version >= \"10.1.0\"\n    end",
        "comment": "https://mariadb.com/kb/en/analyze-statement/",
        "label": "Others",
        "id": "13534"
    },
    {
        "raw_code": "def mr_labels\n        ENV[\"CI_MERGE_REQUEST_LABELS\"]&.split(',') || []\n      end",
        "comment": "Merge request labels  @return [Array]",
        "label": "Others",
        "id": "4830"
    },
    {
        "raw_code": "def inline_source # :nodoc:\n    warn \"RDoc::Task#inline_source is deprecated\"\n    true\n  end",
        "comment": " All source is inline now.  This method is deprecated",
        "label": "Others",
        "id": "15519"
    },
    {
        "raw_code": "def lolol; end\n            end",
        "comment": "rubocop:enable Lint/UselessConstantScoping",
        "label": "Others",
        "id": "11000"
    },
    {
        "raw_code": "def without_approvals(items)\n      items.without_approvals\n    end",
        "comment": "Merge requests without any approval  @param [ActiveRecord::Relation] items",
        "label": "Others",
        "id": "7963"
    },
    {
        "raw_code": "def locking_order_for(tables)\n            tables = Array.wrap(tables)\n            assert_table_names_unqualified!(tables)\n\n            @table_locking_order.intersection(tables.map(&:to_s))\n          end",
        "comment": "Sorts and subsets `tables` to the tables that were explicitly requested for locking in the order that that locking was requested.",
        "label": "Others",
        "id": "3211"
    },
    {
        "raw_code": "def finish\n    if @write_options then\n      write_options\n      exit\n    end",
        "comment": " Completes any unfinished option setup business such as filtering for existent files, creating a regexp for #exclude and setting a default #template.",
        "label": "Others",
        "id": "15532"
    },
    {
        "raw_code": "def dangerous_class_method?(method_name)\n        return true if RESTRICTED_CLASS_METHODS.include?(method_name.to_s)\n\n        if Base.respond_to?(method_name, true)\n          if Object.respond_to?(method_name, true)\n            Base.method(method_name).owner != Object.method(method_name).owner\n          else\n            true\n          end",
        "comment": "A class method is 'dangerous' if it is already (re)defined by Active Record, but not by any ancestors. (So 'puts' is not dangerous but 'new' is.)",
        "label": "Others",
        "id": "12361"
    },
    {
        "raw_code": "def strip_hashes(text)\n    return text if text =~ /^(?>\\s*)[^\\#]/\n\n    empty = ''\n    empty = RDoc::Encoding.change_encoding empty, text.encoding\n\n    text.gsub(/^\\s*(#+)/) { $1.tr '#', ' ' }.gsub(/^\\s+$/, empty)\n  end",
        "comment": " Strips leading # characters from +text+",
        "label": "Others",
        "id": "15564"
    },
    {
        "raw_code": "def autocorrect_preceding_comments(corrector, comment)\n          comments = processed_source.comments\n          index = comments.index(comment)\n\n          comments[0..index]\n            .reverse_each\n            .each_cons(2)\n            .take_while { |below, above| should_correct?(above, below) }\n            .map { |_, above| autocorrect_one(corrector, above) }\n        end",
        "comment": "Corrects all comment lines that occur immediately before the given comment and have the same indentation. This is to avoid a long chain of correcting, saving the file, parsing and inspecting again, and then correcting one more line, and so on.",
        "label": "Others",
        "id": "10372"
    },
    {
        "raw_code": "def initialize(context, storage_path, excludes: [])\n            super(context)\n\n            @storage_path = storage_path\n            @excludes = excludes\n          end",
        "comment": "@param [String] storage_path @param [Array] excludes",
        "label": "Others",
        "id": "1088"
    },
    {
        "raw_code": "def regexp_with_working_captures?(node)\n          case node.type\n          when :match_with_lvasgn\n            lhs, _rhs = *node # rubocop:disable InternalAffairs/NodeDestructuring\n            node.loc.selector.source == '=~' && regexp_with_named_captures?(lhs)\n          when :send\n            node.method?(:match) &&\n              [node.receiver, node.first_argument].any? { |n| regexp_with_named_captures?(n) }\n          end",
        "comment": "Named captures work with `=~` (if regexp is on lhs) and with `match` (both sides)",
        "label": "Others",
        "id": "10533"
    },
    {
        "raw_code": "def double_render\n    render plain: \"hello\"\n    render plain: \"world\"\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12051"
    },
    {
        "raw_code": "def filter_invites_and_requests(members, _minimal_access)\n      members.without_invites_and_requests(minimal_access: false)\n    end",
        "comment": "NOTE: minimal access is Premium, so in FOSS we will not include minimal access member",
        "label": "Others",
        "id": "7701"
    },
    {
        "raw_code": "def get_class_specification\n    tk = peek_tk\n    if tk.nil?\n      return ''\n    elsif :on_kw == tk[:kind] && 'self' == tk[:text]\n      return 'self'\n    elsif :on_gvar == tk[:kind]\n      return ''\n    end",
        "comment": " Return a superclass, which can be either a constant of an expression",
        "label": "Others",
        "id": "16072"
    },
    {
        "raw_code": "def execute_with_original_text(new_text, quick_action_target, only: nil, original_text: nil)\n      sanitized_new_text, new_command_params, execution_messages, command_names = execute(\n        new_text, quick_action_target, only: only\n      )\n\n      if original_text\n        _, original_command_params = self.class.new(\n          container: container,\n          current_user: current_user,\n          params: params\n        ).execute(original_text, quick_action_target, only: only)\n\n        new_command_params = (new_command_params.to_a - original_command_params.to_a).to_h if original_command_params\n      end",
        "comment": "Similar to `execute` except also tries to extract any quick actions from original_text, and if found removes them from the main list of quick actions.",
        "label": "Others",
        "id": "6119"
    },
    {
        "raw_code": "def update_aliases\n    constants.each do |const|\n      next unless cm = const.is_alias_for\n      cm_alias = cm.dup\n      cm_alias.name = const.name\n\n      # Don't move top-level aliases under Object, they look ugly there\n      unless RDoc::TopLevel === cm_alias.parent then\n        cm_alias.parent = self\n        cm_alias.full_name = nil # force update for new parent\n      end",
        "comment": " Updates the child modules & classes by replacing the ones that are aliases through a constant.  The aliased module/class is replaced in the children and in RDoc::Store#modules_hash or RDoc::Store#classes_hash by a copy that has <tt>RDoc::ClassModule#is_alias_for</tt> set to the aliased module/class, and this copy is added to <tt>#aliases</tt> of the aliased module/class.  Formatters can use the #non_aliases method to retrieve children that are not aliases, for instance to list the namespace content, since the aliased modules are included in the constants of the class/module, that are listed separately.",
        "label": "Others",
        "id": "16767"
    },
    {
        "raw_code": "def verify_package_file(package_file, uploaded_file)\n        stored_sha256 = Digest::SHA256.hexdigest(package_file.file_sha1)\n        expected_sha256 = uploaded_file.sha256\n\n        if stored_sha256 == expected_sha256\n          no_content!\n        else\n          conflict!\n        end",
        "comment": "The sha verification done by the maven api is between: - the sha256 set by workhorse helpers - the sha256 of the sha1 of the uploaded package file",
        "label": "Others",
        "id": "3751"
    },
    {
        "raw_code": "def generate(object, opts = {})\n        adapter_generate(object, opts)\n      end",
        "comment": "Generates JSON for an object. In Oj this takes fewer options than .dump, in the JSON gem this is the only method which takes an options argument.  @param object [Hash, Array, Object] must be hash, array, or an object that responds to .to_h or .to_json @param opts [Hash] an options hash with fewer supported settings than .dump @return [String]",
        "label": "Others",
        "id": "1640"
    },
    {
        "raw_code": "def cache_email!(username, email)\n        return unless email\n\n        Gitlab::Cache::Import::Caching.write(email_cache_key(username), email)\n      end",
        "comment": "Caches the email associated to the username  An empty email is cached when the user email isn't set on GitHub. This is done to prevent UserFinder from fetching the user's email again when the user's email isn't set on GitHub",
        "label": "Others",
        "id": "2158"
    },
    {
        "raw_code": "def merge(other)\n    @parts.concat other.parts\n  end",
        "comment": " Appends +other+'s parts",
        "label": "Others",
        "id": "16293"
    },
    {
        "raw_code": "def load_parameter_rules(rules)\n      rules.flat_map do |rule_type, data|\n        data.flat_map do |configuration|\n          cops = Array(configuration['cops'])\n          parameters = Array(configuration['parameters'])\n\n          cops.product(parameters).map do |cop, parameter|\n            PARAMETER_RULE_CLASSES[rule_type].new(@config, cop, parameter, configuration)\n          end",
        "comment": "Parameter rules may apply to multiple cops and multiple parameters and are given as an array. Each combination is turned into a separate rule object.",
        "label": "Others",
        "id": "10045"
    },
    {
        "raw_code": "def self.provider(name=UNSET_VALUE, options=nil, &block)\n          options ||= {}\n          options[:priority] ||= 5\n\n          components.providers.register(name.to_sym) do\n            [block.call, options]\n          end",
        "comment": "Registers additional providers to be available.  @param [Symbol] name Name of the provider.",
        "label": "Others",
        "id": "9111"
    },
    {
        "raw_code": "def raw(name)\n      @hsh[name]\n    end",
        "comment": ":nodoc: @api private",
        "label": "Others",
        "id": "5157"
    },
    {
        "raw_code": "def stub_all_feature_flags\n    Feature.stub = true\n    Feature.reset_flipper\n  end",
        "comment": "Ensure feature flags are stubbed and reset.",
        "label": "Others",
        "id": "8503"
    },
    {
        "raw_code": "def add_include(include)\n    object_class.record_location self\n    return include unless @document_self\n    object_class.add_include include\n  end",
        "comment": " Adds +include+ to +Object+ instead of +self+.",
        "label": "Others",
        "id": "16717"
    },
    {
        "raw_code": "def content_type_whitelist\n      MIME_TYPE_ALLOWLIST\n    end",
        "comment": "Allow CarrierWave to reject files without correct mimetypes.",
        "label": "Others",
        "id": "8073"
    },
    {
        "raw_code": "def remote_connections\n        @remote_connections || @mutex.synchronize { @remote_connections ||= RemoteConnections.new(self) }\n      end",
        "comment": "Gateway to RemoteConnections. See that class for details.",
        "label": "Others",
        "id": "11082"
    },
    {
        "raw_code": "def some_method\n              implement 1\n            end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10940"
    },
    {
        "raw_code": "def translate(message)\n    @messages[message] || message\n  end",
        "comment": " Translates the +message+ into locale. If there is no translation messages for +message+ in locale, +message+ itself is returned.",
        "label": "Others",
        "id": "16629"
    },
    {
        "raw_code": "def self.parameter_filter\n          @parameter_filter ||= ActiveSupport::ParameterFilter.new(Rails.application.config.filter_parameters)\n        end",
        "comment": "Rubocop requires this be public",
        "label": "Others",
        "id": "2311"
    },
    {
        "raw_code": "def prepare_line_nodes(node) # :nodoc:\n    case node\n    when Prism::CallNode, Prism::DefNode\n      @line_nodes[node.location.start_line] ||= node\n    end",
        "comment": "Assign AST node to a line. This is used to show meta-method source code in the documentation.",
        "label": "Others",
        "id": "16029"
    },
    {
        "raw_code": "def self_and_downstreams\n      object_hierarchy.base_and_descendants\n    end",
        "comment": "With multi-project and parent-child pipelines",
        "label": "Others",
        "id": "7570"
    },
    {
        "raw_code": "def remove_import_data\n    import_data&.destroy\n  end",
        "comment": "This method is overridden in EE::Project model",
        "label": "Others",
        "id": "6735"
    },
    {
        "raw_code": "def header(routes)\n      end",
        "comment": "The header is part of the HTML page, so we don't construct it here.",
        "label": "Others",
        "id": "11558"
    },
    {
        "raw_code": "def convert_string(string)\n    string\n  end",
        "comment": " Converts a string to be fancier if desired",
        "label": "Others",
        "id": "16280"
    },
    {
        "raw_code": "def init_gitlab_deprecation(kwargs)\n        if kwargs[:deprecation_reason].present?\n          raise ArgumentError, <<~ERROR\n            Use `deprecated` property instead of `deprecation_reason`. See\n            #{Rails.application.routes.url_helpers.help_page_url('development/api_graphql_styleguide.md', anchor: 'deprecating-schema-items')}\n          ERROR\n        end",
        "comment": "Set deprecation, mutate the arguments",
        "label": "Others",
        "id": "2085"
    },
    {
        "raw_code": "def delete_matched(matcher, options = nil)\n        options = merged_options(options)\n        matcher = key_matcher(matcher, options)\n\n        instrument(:delete_matched, matcher.inspect) do\n          keys = synchronize { @data.keys }\n          keys.each do |key|\n            delete_entry(key, **options) if key.match(matcher)\n          end",
        "comment": "Deletes cache entries if the cache key matches a given pattern.",
        "label": "Others",
        "id": "14022"
    },
    {
        "raw_code": "def add_global_offense(message = nil, severity: nil)\n        severity = find_severity(nil, severity)\n        message = find_message(nil, message)\n        range = Offense::NO_LOCATION\n        status = enabled_line?(range.line) ? :unsupported : :disabled\n        current_offenses << Offense.new(severity, range, message, name, status)\n      end",
        "comment": "Adds an offense that has no particular location. No correction can be applied to global offenses",
        "label": "Others",
        "id": "10258"
    },
    {
        "raw_code": "def filter_by_availability\n      # Re-find by id so subsequent filters don't expose unavailable records\n      @collection = collection.id_in(collection\n        .select('DISTINCT ON (type_identifier) id')\n        .ordered_by_type_and_id\n        .limit(TYPE_IDENTIFIERS.length))\n    end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "7986"
    },
    {
        "raw_code": "def build_recursive_query(cursor, of, first_iteration)\n        ids = first_iteration ? cursor[:current_id] : ''\n\n        recursive_cte = Gitlab::SQL::RecursiveCTE.new(:result,\n          union_args: {\n            remove_order: false,\n            remove_duplicates: false\n          })\n\n        recursive_cte << base_namespace_class.select(\n          Arel.sql(\"#{cursor[:current_id]}::bigint\").as('current_id'),\n          Arel.sql(\"ARRAY[#{cursor[:depth].join(',')}]::bigint[]\").as('depth'),\n          Arel.sql(\"ARRAY[#{ids}]::bigint[]\").as('ids'),\n          Arel.sql('1::bigint AS count'),\n          Arel.sql('0::bigint AS index')\n        ).from('(VALUES (1)) AS initializer_row')\n          .where_exists(namespace_exists_query)\n\n        cte = Gitlab::SQL::CTE.new(:cte, base_namespace_class.select('result.*').from('result'))\n\n        union_query = base_namespace_class.with(cte.to_arel).from_union(\n          walk_down,\n          next_elements,\n          up_one_level,\n          remove_duplicates: false,\n          remove_order: false\n        ).select(*PROJECTIONS).order(base_namespace_class.arel_table[:index].asc).limit(1)\n\n        recursive_cte << union_query\n\n        base_namespace_class.with\n          .recursive(recursive_cte.to_arel)\n          .from(recursive_cte.alias_to(namespace_class.arel_table))\n          .select(*PROJECTIONS)\n          .limit(of + 1)\n      end",
        "comment": "rubocop: disable Style/AsciiComments -- Rendering a graph The depth-first algorithm is implemented here. Consider the following group hierarchy:  \u250c\u2500\u2500\u2510 \u250210\u2502 \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510 \u2502            \u2502 \u250c\u2500\u2534\u2510          \u250c\u2534\u2500\u2510 \u250241\u2502          \u250272\u2502 \u2514\u2500\u252c\u2518          \u2514\u2500\u2500\u2518 \u2502 \u250c\u2500\u2534\u2510 \u250c\u2500\u2500\u2500\u2500\u252432\u251c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502    \u2514\u2500\u252c\u2518     \u2502 \u2502      \u2502      \u2502 \u250c\u2500\u2534\u2510   \u250c\u2500\u2534\u2510    \u250c\u2534\u2500\u2510 \u250211\u2502   \u250212\u2502    \u250218\u2502 \u2514\u2500\u2500\u2518   \u2514\u2500\u2500\u2518    \u2514\u2500\u2500\u2518  1. Start with node 10 and look up the left-hand child nodes until reaching the leaf. (walk_down) 2. While walking down, record the depth in an array and also store them in the ids array. 3. depth: 10, 41, 32, 11 | ids: 10, 41, 32, 11 4. Start collecting the ids by looking at the nodes on the deepest level. (next_elements) 5. This gives us the rest of the nodes on the same level (parent_id = 32 AND id > 11) 6. depth: 10, 41, 32, 11 | ids: 10, 41, 32, 11, 12, 18 7. When done, move one level up and pop the last value from the depth. (up_one_level) 8. depth: 10, 41, 32 | ids: 10, 41, 32, 11, 12, 18 9. Do the same, look at the nodes on the same level: no records, 32 was already collected 10. depth: 10, 41, 32 | ids: 10, 41, 32, 11, 12, 18 11. Move one level up again and look at the nodes on the same level. 12. depth: 10, 41 | ids: 10, 41, 32, 11, 12, 18, 72 13. Move one level up again, we reached the root node, iteration is done. 14. depth: 10 | ids: 10, 41, 32, 11, 12, 18, 72  By tracking the currently accessed node and the depth we can stop and restore the processing of the hierarchy at any point.  rubocop: enable Style/AsciiComments",
        "label": "Others",
        "id": "2961"
    },
    {
        "raw_code": "def remove_remaining_notification_settings\n      source_project.notification_settings.destroy_all # rubocop: disable Cop/DestroyAll\n    end",
        "comment": "Remove remaining notification settings from source_project",
        "label": "Others",
        "id": "5910"
    },
    {
        "raw_code": "def new_key(key)\n    if key.user&.can?(:receive_notifications)\n      mailer.new_ssh_key_email(key.id).deliver_later\n    end",
        "comment": "Always notify user about ssh key added only if ssh key is not deploy key  This is security email so it will be sent even if user disabled notifications. However, it won't be sent to internal users like the ghost user or the EE support bot.",
        "label": "Others",
        "id": "5453"
    },
    {
        "raw_code": "def paths\n    fs.each_key(prefix: path_root).map { |key| key.delete_prefix path_root }\n  end",
        "comment": " Access stored content",
        "label": "Others",
        "id": "9994"
    },
    {
        "raw_code": "def test_default_external_works\n    with_external_encoding \"ISO-8859-1\" do\n      @template = new_template(\"hello \\xFCmlat\")\n      assert_equal Encoding::UTF_8, render.encoding\n      assert_equal \"hello \\u{fc}mlat\", render\n    end",
        "comment": "This test ensures that if the default_external is set to something other than UTF-8, we don't get any errors and get back a UTF-8 String.",
        "label": "Others",
        "id": "12101"
    },
    {
        "raw_code": "def ignored_method?\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `ignored_method?` is deprecated. Use `allowed_method?` instead.\n        WARNING\n\n        allowed_method?\n      end",
        "comment": "@deprecated Use allowed_method? instead",
        "label": "Others",
        "id": "10416"
    },
    {
        "raw_code": "def self.execute(batch_size: BATCH_SIZE)\n      scope = UserStatus\n        .select(:user_id)\n        .scheduled_for_cleanup\n        .lock('FOR UPDATE SKIP LOCKED')\n        .limit(batch_size)\n\n      deleted_rows = UserStatus.where(user_id: scope).delete_all\n\n      { deleted_rows: deleted_rows }\n    end",
        "comment": "Cleanup BATCH_SIZE user_statuses records rubocop: disable CodeReuse/ActiveRecord",
        "label": "Others",
        "id": "5989"
    },
    {
        "raw_code": "def range_with_preceding_pipe(range)\n          pos = range.begin_pos - 1\n\n          while pos\n            unless processed_source.buffer.source[pos].match?(/[\\s|]/)\n              return range.with(begin_pos: pos + 1)\n            end",
        "comment": "Collect a preceding pipe and any whitespace left of the pipe",
        "label": "Others",
        "id": "10321"
    },
    {
        "raw_code": "def add_extra_files(*files)\n        files.map! {|f| f.include?(\"*\") ? Dir.glob(f) : f }.flatten!\n        files.each do |file|\n          if extra_file_valid?(file)\n            options.files << CodeObjects::ExtraFileObject.new(file)\n          end",
        "comment": "Adds a set of extra documentation files to be processed @param [Array<String>] files the set of documentation files",
        "label": "Others",
        "id": "534"
    },
    {
        "raw_code": "def apply_hierarchical_link_rules!\n          @uri = Addressable::URI.join(@slug, @uri) if @uri.to_s[0] == '.'\n        end",
        "comment": "Of the form `./link`, `../link`, or similar",
        "label": "Others",
        "id": "3476"
    },
    {
        "raw_code": "def item_found(query_input, item); end\n\n  def max_union_size\n    MAX_UNION_SIZE\n  end\n\n  private\n\n  def primary_key\n    @primary_key ||= (model_class.primary_key || raise(\"No primary key for #{model_class}\"))\n  end\n\n  def batch\n    { key: self.class, default_value: [] }\n  end\n\n  def found(loader, key, value)\n    return unless allowed?(value)\n\n    loader.call(key) do |vs|\n      item_found(key, value)\n      vs << value\n    end\n  end",
        "comment": "Override this to intercept the items once they are found",
        "label": "Others",
        "id": "6181"
    },
    {
        "raw_code": "def self.provisioner(name=UNSET_VALUE, &block)\n          data[:provisioners] ||= Registry.new\n\n          # Register a new provisioner class only if a name was given\n          data[:provisioners].register(name.to_sym, &block) if name != UNSET_VALUE\n\n          # Return the registry\n          data[:provisioners]\n        end",
        "comment": "Registers additional provisioners to be available.  @param [String] name Name of the provisioner.",
        "label": "Others",
        "id": "9010"
    },
    {
        "raw_code": "def some_method\n              implement 1\n            end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10944"
    },
    {
        "raw_code": "def signature(model, method_name)\n              attribute_names(model, method_name.to_s).map { |name| \"_#{name}\" }.join(\", \")\n            end",
        "comment": "The parameters in the signature may have reserved Ruby words, in order to prevent errors, we start each param name with `_`.",
        "label": "Others",
        "id": "12455"
    },
    {
        "raw_code": "def general_options(opts)\n        opts.separator \"\"\n        opts.separator \"General Options:\"\n\n        opts.on('-b', '--db FILE', 'Use a specified .yardoc db to load from or save to',\n                      '  (defaults to .yardoc)') do |yfile|\n          YARD::Registry.yardoc_file = yfile\n        end",
        "comment": "Adds general options",
        "label": "Others",
        "id": "543"
    },
    {
        "raw_code": "def uniqueness_of_title\n    if project\n      relation = self.class.for_projects_and_groups([project_id], [project.group&.self_and_ancestors_ids])\n    elsif group\n      relation = self.class.for_projects_and_groups(group.all_project_ids, [group.self_and_hierarchy])\n    end",
        "comment": "milestone titles must be unique across project and group milestones",
        "label": "Others",
        "id": "6951"
    },
    {
        "raw_code": "def git_request?(query)\n      query.blank? ||\n        query == 'service=git-upload-pack' ||\n        query == 'service=git-receive-pack'\n    end",
        "comment": "Allow /info/refs, /info/refs?service=git-upload-pack, and /info/refs?service=git-receive-pack, but nothing else.",
        "label": "Others",
        "id": "3366"
    },
    {
        "raw_code": "def do_something\n              ^ #{missing_begin}\n                  end",
        "comment": "{type} Parent {type} SomeObject",
        "label": "Others",
        "id": "11015"
    },
    {
        "raw_code": "def before_triggers\n        @_before_triggers\n      end",
        "comment": "return [Array]",
        "label": "Others",
        "id": "9438"
    },
    {
        "raw_code": "def create_cross_references!(author = self.author, without = [])\n    refs = referenced_mentionables(author)\n\n    # We're using this method instead of Array diffing because that requires\n    # both of the object's `hash` values to be the same, which may not be the\n    # case for otherwise identical Commit objects.\n    refs.reject! { |ref| without.include?(ref) || cross_reference_exists?(ref) }\n\n    refs.each do |ref|\n      SystemNoteService.cross_reference(ref, local_reference, author)\n    end",
        "comment": "Create a cross-reference Note for each GFM reference to another Mentionable found in the +mentionable_attrs+.",
        "label": "Others",
        "id": "7235"
    },
    {
        "raw_code": "def attempt_correction(range, corrector)\n        if corrector\n          status = :corrected\n        elsif disable_uncorrectable?\n          corrector = disable_uncorrectable(range)\n          status = :corrected_with_todo\n        else\n          return :unsupported\n        end",
        "comment": "@return [Symbol] offense status",
        "label": "Others",
        "id": "10277"
    },
    {
        "raw_code": "def old_wiki_base_path\n          @wiki_base_path.sub('/-/', '/')\n        end",
        "comment": "before we added `/-/` to all our paths",
        "label": "Others",
        "id": "3478"
    },
    {
        "raw_code": "def sanitize_path(path)\n    require 'pathname'\n    dot = Pathname.new('.').expand_path\n\n    path.reject do |item|\n      path = Pathname.new(item).expand_path\n      is_reject = nil\n      relative = nil\n      begin\n        relative = path.relative_path_from(dot).to_s\n      rescue ArgumentError\n        # On Windows, sometimes crosses different drive letters.\n        is_reject = true\n      else\n        is_reject = relative.start_with? '..'\n      end",
        "comment": " Removes directories from +path+ that are outside the current directory",
        "label": "Others",
        "id": "15538"
    },
    {
        "raw_code": "def _racc_evalact(act, arg)\n      action_table, action_check, _, action_pointer,\n      _,            _,            _, _,\n      _,            _,            _, shift_n,\n      reduce_n,     * = arg\n      nerr = 0   # tmp\n\n      if act > 0 and act < shift_n\n        #\n        # shift\n        #\n        if @racc_error_status > 0\n          @racc_error_status -= 1 unless @racc_t <= 1 # error token or EOF\n        end",
        "comment": " common ",
        "label": "Others",
        "id": "16528"
    },
    {
        "raw_code": "def configure_rspec\n            setup = new\n\n            ::RSpec.configure do |config|\n              config.before(:suite) { setup.run_before }\n              config.after(:suite) { setup.run_after }\n            end",
        "comment": "Add global hooks to perform feature flag changes  @return [void]",
        "label": "Others",
        "id": "4432"
    },
    {
        "raw_code": "def build_omniauth_customized_providers\n      %i[bitbucket jwt]\n    end",
        "comment": "We override this in EE",
        "label": "Others",
        "id": "1339"
    },
    {
        "raw_code": "def ==(other)\n            self.class == other.class && json == other.json\n          end",
        "comment": "Object comparator  @param [Base] other @return [Booelan]",
        "label": "Others",
        "id": "3980"
    },
    {
        "raw_code": "def visit_Arel_Nodes_NullsFirst(o, collector)\n          visit o.expr, collector\n          collector << \" NULLS FIRST\"\n        end",
        "comment": "NullsFirst is available on all but MySQL, where it is redefined.",
        "label": "Others",
        "id": "13485"
    },
    {
        "raw_code": "def body=(body)\n      # Prevent ActionController::Metal::Live::Response from committing the response prematurely.\n      synchronize do\n        if body.respond_to?(:to_str)\n          @stream = build_buffer(self, [body])\n        elsif body.respond_to?(:to_path)\n          @stream = body\n        elsif body.respond_to?(:to_ary)\n          @stream = build_buffer(self, body)\n        else\n          @stream = body\n        end",
        "comment": "Allows you to manually set or override the response body.",
        "label": "Others",
        "id": "11477"
    },
    {
        "raw_code": "def resources(cpu_r, memory_r, cpu_l = nil, memory_l = nil, no_limits: false)\n            cpu_l ||= cpu_r\n            memory_l ||= memory_r\n\n            {\n              requests: {\n                cpu: cpu_r,\n                memory: memory_r\n              }\n            }.tap do |definition|\n              next if no_limits\n\n              definition[:limits] = {\n                cpu: cpu_l,\n                memory: memory_l\n              }\n            end",
        "comment": "Kubernetes resources configuration  Set limits equal to requests by default for simplicity  @param [<String, Integer>] cpu_r @param [String] memory_r @param [<String, Integer>] cpu_l @param [String] memory_l @param [Boolean] no_limits if true, skip limit definition @return [Hash]",
        "label": "Others",
        "id": "4015"
    },
    {
        "raw_code": "def initialize(clean_plz = true)\n      cleanup if clean_plz\n    end",
        "comment": ":nodoc: @api private",
        "label": "Others",
        "id": "5143"
    },
    {
        "raw_code": "def register(name, instance)\n      # logger.debug(\"register[#{name}] = #{instance}\")\n      # Sidekiq Enterprise lazy registers a few services so we\n      # can't lock down this hash completely.\n      hash = @directory.dup\n      hash[name] = instance\n      @directory = hash.freeze\n      instance\n    end",
        "comment": "register global singletons which can be accessed elsewhere",
        "label": "Others",
        "id": "5184"
    },
    {
        "raw_code": "def eager_load_namespaces\n        @@eager_load_namespaces ||= []\n      end",
        "comment": "All namespaces that are eager loaded",
        "label": "Others",
        "id": "14808"
    },
    {
        "raw_code": "def slot\n      render Pajamas::BadgeComponent.new(variant: :info) do\n        \"!ereht olleh\".reverse.capitalize\n      end",
        "comment": "Using the content slot ---  Use the content slot instead of the `text` param when things get more complicated than a plain string. All other options (`icon`, etc.) work as usual.",
        "label": "Others",
        "id": "8197"
    },
    {
        "raw_code": "def foo; end\n          def foo2; end\n\n          # @endgroup\n\n          def bar; end\n\n          # @group Group 2\n          def baz; end\n        end\n      eof\n\n      expect(Registry.at('A').groups).to eq ['Group Name', 'Group 2']\n      expect(Registry.at('A#bar').group).to be nil\n      expect(Registry.at('A#foo').group).to eq \"Group Name\"\n      expect(Registry.at('A#foo2').group).to eq \"Group Name\"\n      expect(Registry.at('A#baz').group).to eq \"Group 2\"\n    end\n\n    it \"handles multi-line class/module references\" do\n      YARD.parse_string <<-eof\n        class A::\n          B::C; end\n      eof\n      expect(Registry.all).to eq [P('A::B::C')]\n    end\n\n    it \"handles sclass definitions of multi-line class/module references\" do\n      YARD.parse_string <<-eof\n        class << A::\n          B::C\n          def foo; end\n        end\n      eof\n      expect(Registry.all.size).to eq 2\n      expect(Registry.at('A::B::C')).not_to be nil\n      expect(Registry.at('A::B::C.foo')).not_to be nil\n    end",
        "comment": "@group Group Name",
        "label": "Others",
        "id": "779"
    },
    {
        "raw_code": "def blob_highlighting(diff_line)\n        rich_line =\n          if diff_line.unchanged? || diff_line.added?\n            new_lines[diff_line.new_pos - 1]&.html_safe\n          elsif diff_line.removed?\n            old_lines[diff_line.old_pos - 1]&.html_safe\n          end",
        "comment": "Deprecated: https://gitlab.com/gitlab-org/gitlab/-/issues/324159 ------------------------------------------------------------------------",
        "label": "Others",
        "id": "2695"
    },
    {
        "raw_code": "def setup_shared_connection_pool\n        handler = ActiveRecord::Base.connection_handler\n\n        handler.connection_pool_names.each do |name|\n          pool_manager = handler.send(:connection_name_to_pool_manager)[name]\n          pool_manager.shard_names.each do |shard_name|\n            writing_pool_config = pool_manager.get_pool_config(ActiveRecord.writing_role, shard_name)\n            @saved_pool_configs[name][shard_name] ||= {}\n            pool_manager.role_names.each do |role|\n              next unless pool_config = pool_manager.get_pool_config(role, shard_name)\n              next if pool_config == writing_pool_config\n\n              @saved_pool_configs[name][shard_name][role] = pool_config\n              pool_manager.set_pool_config(role, shard_name, writing_pool_config)\n            end",
        "comment": "Shares the writing connection pool with connections on other handlers.  In an application with a primary and replica the test fixtures need to share a connection pool so that the reading connection can see data in the open transaction on the writing connection.",
        "label": "Others",
        "id": "12705"
    },
    {
        "raw_code": "def test_render\n    get :render_hello_world\n    assert_equal \"Hello world!\", @response.body\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12057"
    },
    {
        "raw_code": "def find_or_create_repository_from_path(path)\n      ContainerRepository.find_or_create_from_path!(path)\n    end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "5700"
    },
    {
        "raw_code": "def register_observers(*observers)\n        observers.flatten.compact.each { |observer| register_observer(observer) }\n      end",
        "comment": "Register one or more Observers which will be notified when mail is delivered.",
        "label": "Others",
        "id": "11106"
    },
    {
        "raw_code": "def kube_pod(name: \"kube-pod\", container_name: \"container-0\", environment_slug: \"production\", namespace: \"project-namespace\", project_slug: \"project-path-slug\", status: \"Running\", track: nil)\n    {\n      \"metadata\" => {\n        \"name\" => name,\n        \"namespace\" => namespace,\n        \"generateName\" => \"generated-name-with-suffix\",\n        \"creationTimestamp\" => \"2016-11-25T19:55:19Z\",\n        \"annotations\" => {\n          \"app.gitlab.com/env\" => environment_slug,\n          \"app.gitlab.com/app\" => project_slug\n        },\n        \"labels\" => {\n          \"track\" => track\n        }.compact\n      },\n      \"spec\" => {\n        \"containers\" => [\n          { \"name\" => container_name.to_s },\n          { \"name\" => \"#{container_name}-1\" }\n        ]\n      },\n      \"status\" => { \"phase\" => status }\n    }\n  end",
        "comment": "This is a partial response, it will have many more elements in reality but these are the ones we care about at the moment",
        "label": "Others",
        "id": "8429"
    },
    {
        "raw_code": "def render_diffs\n    diffs = @compare.diffs(diff_options)\n\n    diffs.unfold_diff_files(note_positions.unfoldable)\n    diffs.write_cache\n\n    request = {\n      current_user: current_user,\n      project: @merge_request.project,\n      render: ->(partial, locals) { view_to_html_string(partial, locals) }\n    }\n\n    options = additional_attributes.merge(\n      diff_view: \"inline\",\n      merge_ref_head_diff: render_merge_ref_head_diff?\n    )\n\n    options[:context_commits] = @merge_request.recent_context_commits\n\n    render json: DiffsSerializer.new(request).represent(diffs, options)\n  end",
        "comment": "Deprecated: https://gitlab.com/gitlab-org/gitlab/issues/37735",
        "label": "Others",
        "id": "6633"
    },
    {
        "raw_code": "def begin_db_transaction # :nodoc:\n          internal_execute(\"BEGIN\", \"TRANSACTION\", allow_retry: true, materialize_transactions: false)\n        end",
        "comment": "Begins a transaction.",
        "label": "Others",
        "id": "13208"
    },
    {
        "raw_code": "def read_only_message\n    return unless Gitlab::Database.read_only?\n\n    _('You are on a read-only GitLab instance.')\n  end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "7729"
    },
    {
        "raw_code": "def licensed_feature_available?(_feature)\n    false\n  end",
        "comment": "Overridden in EE::Project",
        "label": "Others",
        "id": "6765"
    },
    {
        "raw_code": "def validate_dashboard_choices!(user_dashboards)\n    if user_dashboards.size != localized_dashboard_choices.size\n      raise \"`User` defines #{user_dashboards.size} dashboard choices, \" \\\n        \"but `localized_dashboard_choices` defined #{localized_dashboard_choices.size}.\"\n    end",
        "comment": "Ensure that anyone adding new options updates `localized_dashboard_choices` too",
        "label": "Others",
        "id": "7833"
    },
    {
        "raw_code": "def trigger_token\n      ENV['CI_JOB_TOKEN']\n    end",
        "comment": "Can be overridden",
        "label": "Others",
        "id": "5255"
    },
    {
        "raw_code": "def forces\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `forces` is deprecated.\n        WARNING\n\n        @forces ||= self.class.forces_for(cops)\n      end",
        "comment": "@deprecated",
        "label": "Others",
        "id": "10301"
    },
    {
        "raw_code": "def skip_tkspace_comment(skip_nl = true)\n    loop do\n      skip_nl ? skip_tkspace : skip_tkspace_without_nl\n      next_tk = peek_tk\n      return if next_tk.nil? || (:on_comment != next_tk[:kind] and :on_embdoc != next_tk[:kind])\n      get_tk\n    end",
        "comment": " Skip spaces until a comment is found",
        "label": "Others",
        "id": "16128"
    },
    {
        "raw_code": "def add_resource_route\n        return if options[:actions].present?\n        route \"resources :#{file_name.pluralize}\", namespace: regular_class_path\n      end",
        "comment": "Properly nests namespaces passed into a generator  $ bin/rails generate resource admin/users/products  should give you  namespace :admin do namespace :users do resources :products end end",
        "label": "Others",
        "id": "14789"
    },
    {
        "raw_code": "def user_api_client(token)\n        Runtime::API::Client.new(ENV['GITLAB_ADDRESS'],\n          personal_access_token: token)\n      end",
        "comment": "Create a new api client for the specified token - used for deleting test user personal resources  @param [String] token Personal access token @return [Runtime::API::Client] API client",
        "label": "Others",
        "id": "4746"
    },
    {
        "raw_code": "def batch_operation_disallowed?\n      upload_request? && Gitlab::Database.read_only?\n    end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "6656"
    },
    {
        "raw_code": "def bulk_make_new_connections(num_new_conns_needed)\n          num_new_conns_needed.times do\n            # try_to_checkout_new_connection will not exceed pool's @max_connections limit\n            if new_conn = try_to_checkout_new_connection\n              # make the new_conn available to the starving threads stuck @available Queue\n              checkin(new_conn)\n            end",
        "comment": "-- this is unfortunately not concurrent",
        "label": "Others",
        "id": "13040"
    },
    {
        "raw_code": "def suggested_reviewer_users\n    User.none\n  end",
        "comment": "method overridden in EE",
        "label": "Others",
        "id": "6959"
    },
    {
        "raw_code": "def azure_storage_domain\n      credentials[:azure_storage_domain]\n    end",
        "comment": "End AWS-specific options Begin Azure-specific options",
        "label": "Others",
        "id": "3730"
    },
    {
        "raw_code": "def filter_options\n          events.flat_map(&:available_filters).uniq\n        end",
        "comment": "We accept different filters for each event, so we want any filter options available for any event",
        "label": "Others",
        "id": "5358"
    },
    {
        "raw_code": "def default(src: ActionController::Base.helpers.image_path('logo.svg'), size: 64)\n      render(Pajamas::AvatarComponent.new(src, size: size))\n    end",
        "comment": "Avatar ---- See its Pajamas design reference [here](https://design.gitlab.com/components/avatar).  The avatar component takes a single `item` param and a couple of optional arguments: - If the `item` is a plain `String`, this string will become the image `src`. In this case, also provide the `alt:` option, otherwise the resulting avatar image won't have an alt attribute. - If the `item` is a `User` object, the avatar will have a round shape. - For any other object (`Group`, `Project` etc) the shape will be rectangular with rounded corners. @param src text @param size select {{ Pajamas::AvatarComponent::SIZE_OPTIONS }}",
        "label": "Others",
        "id": "8215"
    },
    {
        "raw_code": "def self.upload(machine, content, remote_path)\n          remote_temp = mktemp(machine)\n\n          Tempfile.open(\"vagrant-nixos-configure-networks\") do |f|\n            f.binmode\n            f.write(content)\n            f.fsync\n            f.close\n            machine.communicate.upload(f.path, \"#{remote_temp}\")\n          end",
        "comment": "Upload a file.",
        "label": "Others",
        "id": "9856"
    },
    {
        "raw_code": "def <<(text)\n    @parts << text\n  end",
        "comment": " Appends +text+",
        "label": "Others",
        "id": "16291"
    },
    {
        "raw_code": "def test_render_template_with_locals\n    get :render_template_with_locals\n    assert_equal \"The secret is in the sauce\\n\", @response.body\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12072"
    },
    {
        "raw_code": "def recover(env)\n        @logger.info(\"Beginning recovery process...\")\n\n        @stack.each do |act|\n          if act.respond_to?(:recover)\n            @logger.info(\"Calling recover: #{act}\")\n            act.recover(env)\n          end",
        "comment": "We implement the recover method ourselves in case a Warden is embedded within another Warden. To recover, we just do our own recovery process on our stack.",
        "label": "Others",
        "id": "9298"
    },
    {
        "raw_code": "def object_to_http_body(model)\n      return model if model.nil? || model.is_a?(String)\n      local_body = nil\n      if model.is_a?(Array)\n        local_body = model.map { |m| object_to_hash(m) }\n      else\n        local_body = object_to_hash(model)\n      end",
        "comment": "Convert object (array, hash, object, etc) to JSON string. @param [Object] model object to be converted into JSON string @return [String] JSON string representation of the object",
        "label": "Others",
        "id": "841"
    },
    {
        "raw_code": "def prepare(machine, folders, opts)\n        end",
        "comment": "DEPRECATED: This will be removed.  @deprecated",
        "label": "Others",
        "id": "9095"
    },
    {
        "raw_code": "def documentation_uri\n    return version.metadata[\"documentation_uri\"].presence if version.metadata_uri_set?\n    linkset&.docs.presence || \"https://www.rubydoc.info/gems/#{rubygem.name}/#{version.number}\"\n  end",
        "comment": "documentation uri: if metadata has it defined, use that or if linksets has it defined, use that else, generate one from gem name and version number",
        "label": "Others",
        "id": "9981"
    },
    {
        "raw_code": "def allowlisted_routes\n          workhorse_passthrough_route? || internal_route? || lfs_batch_route? ||\n            compare_git_revisions_route? || sidekiq_route? || session_route? ||\n            graphql_query?\n        end",
        "comment": "Overridden in EE module",
        "label": "Others",
        "id": "2042"
    },
    {
        "raw_code": "def to_settings(hash)\n    hash.transform_values do |value|\n      if value.is_a? Hash\n        ::GitlabSettings::Options.build(value)\n      else\n        value\n      end",
        "comment": "Support nested hashes by converting all values into GitlabSettings::Objects objects",
        "label": "Others",
        "id": "8383"
    },
    {
        "raw_code": "def test_simple_show\n    get :hello_world\n    assert_response 200\n    assert_response :success\n    assert_equal \"<html>Hello world!</html>\", @response.body\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12055"
    },
    {
        "raw_code": "def inspect\n    attrs = { :@rubygem => @rubygem, :@owner => owner, :@message => @message, :@code => @code }.map do |attr, value|\n      \"#{attr}=#{value.inspect}\"\n    end",
        "comment": "Overridden so we don't get megabytes of the raw data printing out",
        "label": "Others",
        "id": "9984"
    },
    {
        "raw_code": "def some_method\n              implement 1\n            end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10945"
    },
    {
        "raw_code": "def set_behavior_categories(example)\n          file_path = example.file_path.gsub('./qa/specs/features', '')\n          devops_stage = file_path.match(%r{\\d{1,2}_(\\w+)/})&.captures&.first\n\n          feature_category = example.metadata[:feature_category]\n          product_group = example.metadata[:product_group]\n\n          example.epic(devops_stage) if devops_stage\n          example.feature(feature_category) if feature_category\n          example.feature(product_group) if product_group && feature_category.nil?\n        end",
        "comment": "Add behavior categories to report  @param [RSpec::Core::Example] example @return [void]",
        "label": "Others",
        "id": "4600"
    },
    {
        "raw_code": "def handle_regexp_CROSSREF(target)\n    text = target.text\n\n    text.sub(/^\\\\/, '')\n  end",
        "comment": " Converts the CROSSREF +target+ to plain text, removing the suppression marker, if any",
        "label": "Others",
        "id": "16440"
    },
    {
        "raw_code": "def without_department(department)\n        clear_enrollment_queue\n        without_department = @departments.dup\n        without_department.delete(department)\n\n        with(without_department.values.flatten)\n      end",
        "comment": "@return [Registry] Cops not for a specific department.",
        "label": "Others",
        "id": "10209"
    },
    {
        "raw_code": "def resource_parent\n      project\n    end",
        "comment": "Part of the interface of objects we can create events about",
        "label": "Others",
        "id": "7691"
    },
    {
        "raw_code": "def test_result_data(additional_data = {})\n        {\n          importer: :github,\n          source: {\n            name: \"GitHub\",\n            project_name: github_repo,\n            address: \"https://github.com\"\n          },\n          target: {\n            name: \"GitLab\",\n            address: gitlab_address,\n            project_name: imported_project.full_path\n          }\n        }.deep_merge(additional_data)\n      end",
        "comment": "Base test result data used for test result reporting  @param [Hash] additional_data @return [Hash]",
        "label": "Others",
        "id": "4395"
    },
    {
        "raw_code": "def html_list_name(list_type, open_tag)\n    ''\n  end",
        "comment": " In snippets, there are no lists",
        "label": "Others",
        "id": "16412"
    },
    {
        "raw_code": "def initialize(source)\n    @source = source\n  end",
        "comment": "Arguments: source - a Group or Project",
        "label": "Others",
        "id": "7951"
    },
    {
        "raw_code": "def normalize_comment(text)\n    return text if text.empty?\n\n    case language\n    when :ruby\n      text = strip_hashes text\n    when :c\n      text = strip_stars text\n    end",
        "comment": " Strips hashes, expands tabs then flushes +text+ to the left",
        "label": "Others",
        "id": "15561"
    },
    {
        "raw_code": "def host_only_interface_names(env)\n          env[:machine].provider.driver.read_network_interfaces\n            .map { |_, i| i[:hostonly] if i[:type] == :hostonly }.compact\n        end",
        "comment": "The list of interface names for host-only adapters. @return [Array<String>]",
        "label": "Others",
        "id": "9637"
    },
    {
        "raw_code": "def normalize_key(key, options = nil)\n          key = expand_and_namespace_key(key, options)\n          truncate_key(key)\n        end",
        "comment": "Expands, namespaces and truncates the cache key. Raises an exception when the key is +nil+ or an empty string. May be overridden by cache stores to do additional normalization.",
        "label": "Others",
        "id": "13762"
    },
    {
        "raw_code": "def operator_keyword_fragment\n        remove_duplicates ? self.class.operator_keyword : \"#{self.class.operator_keyword} ALL\"\n      end",
        "comment": "UNION [ALL] | INTERSECT [ALL] | EXCEPT [ALL]",
        "label": "Others",
        "id": "2859"
    },
    {
        "raw_code": "def self.upload(machine, content, remote_path)\n          remote_temp = mktemp(machine)\n\n          Tempfile.open(\"vagrant-nixos-change-host-name\") do |f|\n            f.binmode\n            f.write(content)\n            f.fsync\n            f.close\n            machine.communicate.upload(f.path, \"#{remote_temp}\")\n          end",
        "comment": "Upload a file.",
        "label": "Others",
        "id": "9859"
    },
    {
        "raw_code": "def inner_filter_query(user, opts = {})\n      award_emoji_table = Arel::Table.new('award_emoji')\n\n      emoji_name = opts[:name]\n      base_class_name = opts[:base_class_name] || base_class.name\n      awardable_id_column = opts[:awardable_id_column] || self.arel_table[:id]\n\n      inner_query =\n        award_emoji_table\n          .project('true')\n          .where(award_emoji_table[:user_id].eq(user.id))\n          .where(award_emoji_table[:awardable_type].eq(base_class_name))\n          .where(award_emoji_table[:awardable_id].eq(awardable_id_column))\n\n      inner_query.where(award_emoji_table[:name].eq(emoji_name)) if emoji_name.present?\n\n      inner_query\n    end",
        "comment": "Fragment used to build queries when filtering objects by award emoji",
        "label": "Others",
        "id": "7260"
    },
    {
        "raw_code": "def self.all_routes\n          ROUTES\n        end",
        "comment": "Overridden in EE to add more routes",
        "label": "Others",
        "id": "3355"
    },
    {
        "raw_code": "def default?\n        %w[user project namespace].include?(value)\n      end",
        "comment": "Refers to the top-level identifiers not included in additional_properties",
        "label": "Others",
        "id": "5313"
    },
    {
        "raw_code": "def init_with(coder)\n              @data = {\n                tag: coder.tag,       # This is the custom YAML tag, like !reference or !flatten\n                style: coder.style,\n                seq: coder.seq,       # This holds Array data\n                scalar: coder.scalar, # This holds data of basic types, like String.\n                map: coder.map        # This holds Hash data.\n              }\n            end",
        "comment": "Only one of the `seq`, `scalar`, `map` fields is available.",
        "label": "Others",
        "id": "2490"
    },
    {
        "raw_code": "def unregister_preview_interceptors(*interceptors)\n        interceptors.flatten.compact.each { |interceptor| unregister_preview_interceptor(interceptor) }\n      end",
        "comment": "Unregister one or more previously registered Interceptors.",
        "label": "Others",
        "id": "11152"
    },
    {
        "raw_code": "def some_method\n            implement 1\n          end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10910"
    },
    {
        "raw_code": "def parser=(val)\n    @parser = val\n    @store.update_parser_of_file(absolute_name, val) if @store\n    @parser\n  end",
        "comment": " Sets the parser for this toplevel context, also the store.",
        "label": "Others",
        "id": "16713"
    },
    {
        "raw_code": "def restrictive_version_specified_gem?(node)\n          return false unless version_specified_gem?(node)\n\n          node.arguments[1..]\n              .any? { |arg| arg&.str_type? && RESTRICTIVE_VERSION_PATTERN.match?(arg.value) }\n        end",
        "comment": "Version specifications that restrict all updates going forward. This excludes versions like \">= 1.0\" or \"!= 2.0.3\".",
        "label": "Others",
        "id": "10349"
    },
    {
        "raw_code": "def validate_single_recipient_in_opts!(opts)\n        return unless opts\n\n        symbolized_opts = opts.symbolize_keys\n\n        if opts.keys.length != symbolized_opts.keys.length\n          raise Gitlab::Email::MultipleRecipientsError, \"opts has colliding key names\"\n        end",
        "comment": "It is possible to send email to one or more recipients in one email by setting the list of emails to the :to key, or by :cc or :bcc-ing recipients. https://guides.rubyonrails.org/action_mailer_basics.html#sending-email-to-multiple-recipients  This method ensures an email will only go to zero or one recipients.",
        "label": "Others",
        "id": "3239"
    },
    {
        "raw_code": "def version_param_value(version_file)\n      ENV[version_file]&.strip || File.read(version_file).strip\n    end",
        "comment": "Can be overridden",
        "label": "Others",
        "id": "5257"
    },
    {
        "raw_code": "def self.guest(name=UNSET_VALUE, &block)\n          data[:guests] ||= Registry.new\n\n          # Register a new guest class only if a name was given\n          data[:guests].register(name.to_sym, &block) if name != UNSET_VALUE\n\n          # Return the registry\n          data[:guests]\n        end",
        "comment": "Defines an additionally available guest implementation with the given key.  @param [String] name Name of the guest.",
        "label": "Others",
        "id": "9007"
    },
    {
        "raw_code": "def initialize(config = nil) # :nodoc:\n        @config = config\n        @entries = nil\n        yield self if block_given?\n      end",
        "comment": "@api private",
        "label": "Others",
        "id": "5198"
    },
    {
        "raw_code": "def parse_block(opts = {})\n          return if !statement.block || statement.block.empty?\n          push_state(opts) do\n            parser.process(statement.block)\n          end",
        "comment": "@group Parsing an Inner Block",
        "label": "Others",
        "id": "221"
    },
    {
        "raw_code": "def errors\n            strong_memoize(:errors) do\n              # Check for cyclic dependencies and build error message in that case\n              cyclic_vars = each_strongly_connected_component.filter_map do |component|\n                component.map { |v| v[:key] }.inspect if component.size > 1\n              end",
        "comment": "errors sorts an array of variables, ignoring unknown variable references, and returning an error string if a circular variable reference is found",
        "label": "Others",
        "id": "2537"
    },
    {
        "raw_code": "def extra_attributes_for_measurement\n    defined?(super) ? super : {}\n  end",
        "comment": "You can set extra attributes for performance measurement log.",
        "label": "Others",
        "id": "5704"
    },
    {
        "raw_code": "def fill_editor_element(name, content)\n        element = find_element name\n\n        if element.tag_name == 'textarea'\n          element.set content\n        else\n          mod = page.driver.browser.capabilities.platform_name.include?(\"mac\") ? :command : :control\n          prosemirror = element.find '[contenteditable].ProseMirror'\n          prosemirror.send_keys [mod, 'a']\n          prosemirror.send_keys :delete\n          prosemirror.send_keys content\n\n          # Wait for the hidden input field to be updated\n          # The hidden field contains markdown serialized by RTE\n          has_field?(type: 'hidden', with: content, wait: 3)\n        end",
        "comment": "fill in editor element, whether plain text or rich text",
        "label": "Others",
        "id": "4260"
    },
    {
        "raw_code": "def custom_metrics_fields(metadata)\n          custom_metrics(metadata, :fields)\n        end",
        "comment": "Additional custom metrics fields  @param [Hash] metadata @return [Hash]",
        "label": "Others",
        "id": "4642"
    },
    {
        "raw_code": "def test_render_xml_with_default\n    get :greeting\n    assert_equal \"<p>This is grand!</p>\\n\", @response.body\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12085"
    },
    {
        "raw_code": "def extra_test_user_credential(var_name)\n            ENV[var_name].presence || raise(MissingUserCredentialError, \"Missing '#{var_name}' environment variable\")\n          end",
        "comment": "Additional test user credential  @param var_name [String] @return [String]",
        "label": "Others",
        "id": "4521"
    },
    {
        "raw_code": "def encode(x)\n    case x\n    when Hash    then objenc(x)\n    when Array   then arrenc(x)\n    else\n      raise Error, 'root value must be an Array or a Hash'\n    end",
        "comment": "Encodes x into a json text. It may contain only Array, Hash, String, Numeric, true, false, nil. (Note, this list excludes Symbol.) X itself must be an Array or a Hash. No other value can be encoded, and an error will be raised if x contains any other value, such as Nan, Infinity, Symbol, and Proc, or if a Hash key is not a String. Strings contained in x must be valid UTF-8.",
        "label": "Others",
        "id": "8705"
    },
    {
        "raw_code": "def top_level_return?(return_node)\n          return_node.each_ancestor(:block, :any_def).none?\n        end",
        "comment": "This cop works by validating the ancestors of the return node. A top-level return node's ancestors should not be of block, def, or defs type.",
        "label": "Others",
        "id": "10668"
    },
    {
        "raw_code": "def present_build!(build, queue_size:, queue_depth:)\n      # We need to use the presenter here because Gitaly calls in the presenter\n      # may fail, and we need to ensure the response has been generated.\n      presented_build = ::Ci::BuildRunnerPresenter.new(build) # rubocop:disable CodeReuse/Presenter -- old code\n      presented_build.set_queue_metrics(size: queue_size, depth: queue_depth)\n\n      @logger.instrument(:present_build_logs) do\n        log_artifacts_context(build)\n        log_build_dependencies_size(presented_build)\n      end",
        "comment": "Force variables evaluation to occur now",
        "label": "Others",
        "id": "5769"
    },
    {
        "raw_code": "def after_destroy(_web_hook)\n      success({ async: false })\n    end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "5982"
    },
    {
        "raw_code": "def self.foo\n            def some_method\n              implement 1\n            end\n          end",
        "comment": "{opening_line}",
        "label": "Others",
        "id": "10934"
    },
    {
        "raw_code": "def exception_message(exception)\n      # App code can stuff all sorts of crazy binary data into the error message\n      # that won't convert to JSON.\n      exception.message.to_s[0, 10_000]\n    rescue\n      +\"!!! ERROR MESSAGE THREW AN ERROR !!!\"\n    end",
        "comment": "Extract message from exception. Set a default if the message raises an error",
        "label": "Others",
        "id": "5084"
    },
    {
        "raw_code": "def types(stream)\n      end",
        "comment": "(enum) types are only supported by PostgreSQL",
        "label": "Others",
        "id": "12685"
    },
    {
        "raw_code": "def epics_license_available?\n    false\n  end",
        "comment": "In FOSS there is no license. This method is overridden in EE",
        "label": "Others",
        "id": "6269"
    },
    {
        "raw_code": "def ignored_line?(line)\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `ignored_line?` is deprecated. Use `allowed_line?` instead.\n        WARNING\n\n        allowed_line?(line)\n      end",
        "comment": "@deprecated Use allowed_line? instead",
        "label": "Others",
        "id": "10419"
    },
    {
        "raw_code": "def required_arguments?(field)\n    return field.requires_argument? if field.is_a?(::Types::BaseField)\n\n    if (meta = field.try(:metadata)) && meta[:type_class]\n      required_arguments?(meta[:type_class])\n    elsif args = field.try(:arguments)\n      args.values.any? { |argument| argument.type.non_null? }\n    else\n      false\n    end",
        "comment": "There are a few non BaseField fields in our schema (pageInfo for one). None of them require arguments.",
        "label": "Others",
        "id": "8406"
    },
    {
        "raw_code": "def without_executed_command_line(output)\n        # If `output.split(\"\\n\")` produces an empty Array then the slicing that\n        # follows it will produce a nil. For example:\n        #\n        #     \"\\n\".split(\"\\n\")        # => []\n        #     \"\\n\".split(\"\\n\")[1..] # => nil\n        #\n        # To work around this we only \"join\" if we're given an Array.\n        if (converted = output.split(\"\\n\")[1..])\n          converted.join(\"\\n\")\n        else\n          ''\n        end",
        "comment": "Removes the line containing the executed command from the build output.  output - A `String` containing the output of a trace section.",
        "label": "Others",
        "id": "2438"
    },
    {
        "raw_code": "def perform(*args)\n        @_args = args.dup.freeze\n        fetch_previous_iteration_state\n\n        @_executions += 1\n        @_start_time = ::Process.clock_gettime(::Process::CLOCK_MONOTONIC)\n\n        enumerator = build_enumerator(*args, cursor: @_cursor)\n        unless enumerator\n          logger.info(\"'#build_enumerator' returned nil, skipping the job.\")\n          return\n        end",
        "comment": "@api private",
        "label": "Others",
        "id": "5231"
    },
    {
        "raw_code": "def ref_param_name\n      raise NotImplementedError\n    end",
        "comment": "Must be overridden",
        "label": "Others",
        "id": "5253"
    },
    {
        "raw_code": "def correct_if_node(node, cond)\n          result = condition_evaluation?(node, cond)\n\n          new_node = if node.elsif? && result\n                       \"else\\n  #{range_with_comments(node.if_branch).source}\"\n                     elsif node.elsif? && !result\n                       \"else\\n  #{node.else_branch.source}\"\n                     elsif node.if_branch && result\n                       node.if_branch.source\n                     elsif node.elsif_conditional?\n                       \"#{node.else_branch.source.sub('elsif', 'if')}\\nend\"\n                     elsif node.else? || node.ternary?\n                       node.else_branch.source\n                     else\n                       '' # Equivalent to removing the node\n                     end",
        "comment": "rubocop:disable Metrics/AbcSize, Metrics/MethodLength, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
        "label": "Others",
        "id": "10667"
    },
    {
        "raw_code": "def referenced_by\n    []\n  end",
        "comment": "These are not saved",
        "label": "Others",
        "id": "7320"
    },
    {
        "raw_code": "def protectable_ref_names\n    return [] if @project.empty_repo?\n\n    @protectable_ref_names ||= ref_names - non_wildcard_protected_ref_names\n  end",
        "comment": "Tags/branches which are yet to be individually protected",
        "label": "Others",
        "id": "6913"
    },
    {
        "raw_code": "def mentioned_filtered_user_ids_for(refs)\n    refs.mentioned_user_ids.presence\n  end",
        "comment": "Overriden on objects that needs to filter mentioned users that cannot read them, for example, guest users that are referenced on a confidential note.",
        "label": "Others",
        "id": "7383"
    },
    {
        "raw_code": "def handle_orphan_file(file, dry_run:, delete:)\n        msg = if dry_run\n                \"Would #{delete ? 'delete' : 'move to lost and found'}: #{file.key}\"\n              elsif delete\n                file.destroy\n                \"Deleted: #{file.key}\"\n              else\n                new_path = move_to_lost_and_found(file)\n                \"Moved to lost and found: #{file.key} -> #{new_path}\"\n              end",
        "comment": "@param file [Fog::Storage::File] the orphan file to handle. @param dry_run [Boolean] if true, only log what would be done. @param delete [Boolean] if true, delete the orphan file, otherwise move it to the lost and found directory. @return [void]",
        "label": "Others",
        "id": "2736"
    },
    {
        "raw_code": "def deprecated_method_warning(method_name, message = nil)\n          warning = \"#{method_name} is deprecated and will be removed from #{gem_name} #{deprecation_horizon}\"\n          case message\n          when Symbol then \"#{warning} (use #{message} instead)\"\n          when String then \"#{warning} (#{message})\"\n          else warning\n          end",
        "comment": "Outputs a deprecation warning message  deprecated_method_warning(:method_name) # => \"method_name is deprecated and will be removed from Rails #{deprecation_horizon}\" deprecated_method_warning(:method_name, :another_method) # => \"method_name is deprecated and will be removed from Rails #{deprecation_horizon} (use another_method instead)\" deprecated_method_warning(:method_name, \"Optional message\") # => \"method_name is deprecated and will be removed from Rails #{deprecation_horizon} (Optional message)\"",
        "label": "Others",
        "id": "14446"
    },
    {
        "raw_code": "def can_delete?\n    true\n  end",
        "comment": "EE overrides this",
        "label": "Others",
        "id": "6853"
    },
    {
        "raw_code": "def localized_jobs_to_be_done_choices\n    {\n      basics: _('I want to learn the basics of Git'),\n      move_repository: _('I want to move my repository to GitLab from somewhere else'),\n      code_storage: _('I want to store my code'),\n      exploring: _('I want to explore GitLab to see if it\u2019s worth switching to'),\n      ci: _('I want to use GitLab CI with my existing repository'),\n      other: _('A different reason')\n    }.with_indifferent_access.freeze\n  end",
        "comment": "Maps `jobs_to_be_done` values to option texts",
        "label": "Others",
        "id": "7803"
    },
    {
        "raw_code": "def initialize_dup(orig) # :nodoc:\n        %w(plurals singulars uncountables humans acronyms).each do |scope|\n          instance_variable_set(\"@#{scope}\", orig.public_send(scope).dup)\n        end",
        "comment": "Private, for the test suite.",
        "label": "Others",
        "id": "14451"
    },
    {
        "raw_code": "def return_value_node_of_scope(scope)\n          body_node = scope.body_node\n\n          if body_node.begin_type?\n            body_node.children.last\n          else\n            body_node\n          end",
        "comment": "TODO: More precise handling (rescue, ensure, nested begin, etc.)",
        "label": "Others",
        "id": "10645"
    },
    {
        "raw_code": "def assemble_version(matches)\n      return if matches.blank?\n\n      major = matches[:major]\n      minor = matches[:minor]\n      patch = matches[:patch]\n      build = matches[:meta]\n\n      return unless major && minor && patch\n\n      version = \"#{major}.#{minor}.#{patch}\"\n      version += \"+#{build}\" if build\n\n      version\n    end",
        "comment": "Builds a version string based on regex matcher's output",
        "label": "Others",
        "id": "8026"
    },
    {
        "raw_code": "def dashboard_storage_limit_enabled?\n    false\n  end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "6678"
    },
    {
        "raw_code": "def required_minimum_access_level_for_private_project(feature)\n      feature = ensure_feature!(feature)\n\n      PRIVATE_FEATURES_MIN_ACCESS_LEVEL_FOR_PRIVATE_PROJECT.fetch(feature) do\n        required_minimum_access_level(feature)\n      end",
        "comment": "Guest users can perform certain features on public and internal projects, but not private projects.",
        "label": "Others",
        "id": "7121"
    },
    {
        "raw_code": "def argument_references(argument)\n          assignment_references = argument.assignments.flat_map(&:references).map(&:source_range)\n\n          argument.references.reject do |ref|\n            next false unless ref.explicit?\n\n            assignment_references.include?(ref.node.source_range)\n          end",
        "comment": "Get argument references without assignments' references ",
        "label": "Others",
        "id": "10653"
    },
    {
        "raw_code": "def do_something; end\n\n          end",
        "comment": "{type} SomeObject",
        "label": "Others",
        "id": "11011"
    },
    {
        "raw_code": "def remove_paid_features_for_projects(old_root_ancestor_id); end\n\n    # rubocop: disable CodeReuse/ActiveRecord\n    def update_children_and_projects_visibility\n      descendants = @group.descendants.with_visibility_level_greater_than(@new_parent_group.visibility_level)\n\n      Group\n        .where(id: descendants.select(:id))\n        .update_all(visibility_level: @new_parent_group.visibility_level)\n\n      projects_to_update = @group\n        .all_projects\n        .with_visibility_level_greater_than(@new_parent_group.visibility_level)\n\n      # Used in post_update_hooks in EE. Must use pluck (and not select)\n      # here as after we perform the update below we won't be able to find\n      # these records again.\n      @updated_project_ids = projects_to_update.pluck(:id)\n\n      Namespaces::ProjectNamespace\n        .where(id: projects_to_update.select(:project_namespace_id))\n        .update_all(visibility_level: @new_parent_group.visibility_level)\n\n      projects_to_update\n        .update_all(visibility_level: @new_parent_group.visibility_level)\n\n      update_project_settings(@updated_project_ids)\n    end\n\n    # Overridden in EE\n    def update_project_settings(updated_project_ids); end\n\n    def update_two_factor_authentication\n      return if namespace_parent_allows_two_factor_auth\n\n      @group.require_two_factor_authentication = false\n    end\n\n    def refresh_descendant_groups\n      return if namespace_parent_allows_two_factor_auth\n\n      if @group.descendants.where(require_two_factor_authentication: true).any?\n        DisallowTwoFactorForSubgroupsWorker.perform_async(@group.id)\n      end\n    end\n    # rubocop: enable CodeReuse/ActiveRecord\n\n    def namespace_parent_allows_two_factor_auth\n      @new_parent_group.namespace_settings.allow_mfa_for_subgroups\n    end\n\n    def ensure_ownership\n      return if @new_parent_group\n      return unless @group.non_invite_owner_members.empty?\n\n      add_owner_on_transferred_group\n    end\n\n    # Overridden in EE\n    def add_owner_on_transferred_group\n      @group.add_owner(current_user)\n    end\n\n    def refresh_project_authorizations\n      project_ids = Groups::ProjectsRequiringAuthorizationsRefresh::OnTransferFinder.new(@group).execute\n\n      AuthorizedProjectUpdate::ProjectAccessChangedService.new(project_ids).execute\n    end\n\n    def raise_transfer_error(message)\n      raise TransferError, localized_error_messages[message]\n    end\n\n    # Overridden in EE\n    def localized_error_messages\n      {\n        database_not_supported: s_('TransferGroup|Database is not supported.'),\n        namespace_with_same_path: s_('TransferGroup|The parent group already has a subgroup or a project with the same path.'),\n        group_is_already_root: s_('TransferGroup|Group is already a root group.'),\n        same_parent_as_current: s_('TransferGroup|Group is already associated to the parent group.'),\n        invalid_policies: s_(\"TransferGroup|You don't have enough permissions.\"),\n        group_contains_images: s_('TransferGroup|Cannot update the path because there are projects under this group that contain Docker images in their container registry. Please remove the images from your projects first and try again.'),\n        cannot_transfer_to_subgroup: s_('TransferGroup|Cannot transfer group to one of its subgroup.'),\n        group_contains_namespaced_npm_packages: s_('TransferGroup|Group contains projects with NPM packages scoped to the current root level group.'),\n        no_permissions_to_migrate_crm: s_(\"TransferGroup|Group contains contacts/organizations and you don't have enough permissions to move them to the new root group.\")\n      }.freeze\n    end\n\n    def inherit_group_shared_runners_settings\n      parent_setting = @group.parent&.shared_runners_setting\n      return unless parent_setting\n\n      if @group.shared_runners_setting_higher_than?(parent_setting)\n        result = Groups::UpdateSharedRunnersService.new(@group, current_user, shared_runners_setting: parent_setting).execute\n\n        raise TransferError, result[:message] unless result[:status] == :success\n      end\n    end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "5537"
    },
    {
        "raw_code": "def merge(elements)\n        merged, *other_elements = elements\n\n        other_elements.each do |element|\n          merged = merge_hash_tree(merged, element)\n        end",
        "comment": "Deep merges an array of elements which can be hashes, arrays, or other objects.  [{ hello: [\"world\"] }, { hello: \"Everyone\" }, { hello: { greetings: ['Bonjour', 'Hello', 'Hallo', 'Dzien dobry'] } }, \"Goodbye\", \"Hallo\"] =>  [ { hello: [ \"world\", \"Everyone\", { greetings: ['Bonjour', 'Hello', 'Hallo', 'Dzien dobry'] } ] }, \"Goodbye\" ]",
        "label": "Others",
        "id": "1853"
    },
    {
        "raw_code": "def re_enqueue\n      # Touch entities with created status so they are not marked as stale by\n      # BulkImports::StaleImportWorker if it takes more 24 hours to start them.\n      touch_created_entities\n\n      BulkImportWorker.perform_in(PERFORM_DELAY, bulk_import.id)\n    end",
        "comment": "A new BulkImportWorker job is enqueued to either - Process the new BulkImports::Entity created during import (e.g. for the subgroups) - Or to mark the `bulk_import` as finished",
        "label": "Others",
        "id": "5873"
    },
    {
        "raw_code": "def enqueue_all(jobs)\n        enqueued_count = 0\n        jobs.group_by(&:class).each do |job_class, same_class_jobs|\n          same_class_jobs.group_by(&:queue_name).each do |queue, same_class_and_queue_jobs|\n            immediate_jobs, scheduled_jobs = same_class_and_queue_jobs.partition { |job| job.scheduled_at.nil? }\n\n            if immediate_jobs.any?\n              jids = Sidekiq::Client.push_bulk(\n                \"class\" => JobWrapper,\n                \"wrapped\" => job_class,\n                \"queue\" => queue,\n                \"args\" => immediate_jobs.map { |job| [job.serialize] }\n              )\n              enqueued_count += jids.compact.size\n            end",
        "comment": "@api private",
        "label": "Others",
        "id": "5241"
    },
    {
        "raw_code": "def after_remove_branch(expire_cache: true)\n    if expire_cache\n      expire_branches_cache\n      expire_root_ref_cache\n    end",
        "comment": "Runs code after an existing branch has been removed.",
        "label": "Others",
        "id": "7145"
    },
    {
        "raw_code": "def size\n          synchronize do\n            @queue.size\n          end",
        "comment": "Number of elements in the queue.",
        "label": "Others",
        "id": "13190"
    },
    {
        "raw_code": "def write_if_empty\n        return if cacheable_files.empty?\n\n        new_cache_content = {}\n\n        cacheable_files.each do |diff_file|\n          new_cache_content[diff_file.file_path] = diff_file.highlighted_diff_lines.map(&:to_hash)\n        end",
        "comment": "For every file that isn't already contained in the redis hash, store the result of #highlighted_diff_lines, then submit the uncached content to #write_to_redis_hash to submit a single write. This avoids excessive IO generated by N+1's (1 writing for each highlighted line or file). ",
        "label": "Others",
        "id": "2698"
    },
    {
        "raw_code": "def self.key_name_v1(user_id, session_id = '*')\n    \"#{Gitlab::Redis::Sessions::USER_SESSIONS_NAMESPACE}:#{user_id}:#{session_id}\"\n  end",
        "comment": "Deprecated",
        "label": "Others",
        "id": "6890"
    },
    {
        "raw_code": "def referenced_mentionables(current_user = self.author)\n    return [] unless matches_cross_reference_regex?\n\n    refs = all_references(current_user)\n\n    # We're using this method instead of Array diffing because that requires\n    # both of the object's `hash` values to be the same, which may not be the\n    # case for otherwise identical Commit objects.\n    extracted_mentionables(refs).reject { |ref| ref == local_reference }\n  end",
        "comment": "Extract GFM references to other Mentionables from this Mentionable. Always excludes its #local_reference.",
        "label": "Others",
        "id": "7233"
    },
    {
        "raw_code": "def self.synced_folder(name, priority=10, &block)\n          components.synced_folders.register(name.to_sym) do\n            [block.call, priority]\n          end",
        "comment": "Registers additional synced folder implementations.  @param [String] name Name of the implementation. @param [Integer] priority The priority of the implementation, higher (big) numbers are tried before lower (small) numbers.",
        "label": "Others",
        "id": "9115"
    },
    {
        "raw_code": "def breakable_collection?(node, elements)\n        # For simplicity we only want to insert breaks in normal\n        # hashes wrapped in a set of curly braces like {foo: 1}.\n        # That is, not a kwargs hash. For method calls, this ensures\n        # the method call is made with parens.\n        starts_with_bracket = !node.hash_type? || node.loc.begin\n\n        # If the call has a second argument, we can insert a line\n        # break before the second argument and the rest of the\n        # argument will get auto-formatted onto separate lines\n        # by other cops.\n        has_second_element = elements.length >= 2\n\n        starts_with_bracket && has_second_element\n      end",
        "comment": "@api private",
        "label": "Others",
        "id": "10408"
    },
    {
        "raw_code": "def self.update_scopes(integration_ids, scopes)\n        return if integration_ids.empty?\n\n        scope_ids = scopes.pluck(:id)\n\n        attrs = scope_ids.flat_map do |scope_id|\n          integration_ids.map { |si_id| { slack_integration_id: si_id, slack_api_scope_id: scope_id } }\n        end",
        "comment": "Efficient scope propagation",
        "label": "Others",
        "id": "7655"
    },
    {
        "raw_code": "def contextual_autocorrect?\n        cop_config.fetch('AutoCorrect', 'always') == 'contextual'\n      end",
        "comment": "@api private",
        "label": "Others",
        "id": "10270"
    },
    {
        "raw_code": "def blank?\n    # The regexp that matches blank strings is expensive. For the case of empty\n    # strings we can speed up this method (~3.5x) with an empty? call. The\n    # penalty for the rest of strings is marginal.\n    empty? ||\n      begin\n        BLANK_RE.match?(self)\n      rescue Encoding::CompatibilityError\n        ENCODED_BLANKS[self.encoding].match?(self)\n      end",
        "comment": "A string is blank if it's empty or contains whitespaces only:  ''.blank?       # => true '   '.blank?    # => true \"\\t\\n\\r\".blank? # => true ' blah '.blank? # => false  Unicode whitespace is supported:  \"\\u00a0\".blank? # => true  @return [true, false]",
        "label": "Others",
        "id": "14306"
    },
    {
        "raw_code": "def file_stored_after_transaction_hooks; end\n\n    # method overridden in EE\n    def file_stored_in_transaction_hooks; end\n\n    def set_size\n      self.size = file.size\n    end\n\n    def project_destroyed?\n      # Use job.project to avoid extra DB query for project\n      job.project.pending_delete?\n    end\n\n    def log_create\n      Gitlab::Ci::Artifacts::Logger.log_created(self)\n    end\n\n    def log_destroy\n      Gitlab::Ci::Artifacts::Logger.log_deleted(self, __method__)\n    end\n\n    def validate_exposed_paths\n      return if exposed_paths.is_a?(Array) && exposed_paths.all? { |path| path.match?(EXPOSED_PATH_REGEX) }\n\n      errors.add(:exposed_paths, 'must be an array of strings without `*`')\n    end\n  end\nend",
        "comment": "method overridden in EE",
        "label": "Others",
        "id": "7553"
    },
    {
        "raw_code": "def events\n        @events ||= events_by_filepath(@selected_event_paths)\n      end",
        "comment": "----- Memoization Helpers -----------------",
        "label": "Others",
        "id": "5316"
    },
    {
        "raw_code": "def register(keyword, command)\n      @aliases.register(keyword.to_sym) do\n        lambda do |args|\n          # directly execute shell commands\n          if command.start_with?(\"!\")\n            return Util::SafeExec.exec \"#{command[1..-1]} #{args.join(\" \")}\".strip\n          end",
        "comment": "This registers an alias.",
        "label": "Others",
        "id": "8815"
    },
    {
        "raw_code": "def log_dry_run_output(resources)\n        return logger.info(\"No resources would be deleted\") if resources.empty?\n\n        logger.info(\"The following #{resources.length} resources would be deleted:\")\n\n        resources.each do |resource|\n          created_at = resource[:created_at]\n          path = resource_path(resource)\n          logger.info(\"#{path} - created at: #{created_at}\")\n        end",
        "comment": "Print results of dry run  @param [Array<Hash>] resources List of resource hashes @return [void]",
        "label": "Others",
        "id": "4735"
    },
    {
        "raw_code": "def self.identifier_min_max_queries\n        {\n          # Increase query performance by not using filters when fetching min/max ids\n          identifiers[:issues] => {\n            minimum_query: -> { ::Issue.minimum(:id) },\n            maximum_query: -> { ::Issue.maximum(:id) }\n          }\n        }\n      end",
        "comment": "Customized min and max calculation, in some cases using the original scope is too slow.",
        "label": "Others",
        "id": "7670"
    },
    {
        "raw_code": "def public_or_visible_to_user(user)\n      return public_to_user unless user\n\n      public_for_user = public_to_user_arel(user)\n      visible_for_user = visible_to_user_arel(user)\n      public_or_visible = public_for_user.or(visible_for_user)\n\n      where(public_or_visible)\n    end",
        "comment": "WARNING: This method should never be used on its own please do make sure the number of rows you are filtering is small enough for this query",
        "label": "Others",
        "id": "7010"
    },
    {
        "raw_code": "def with_lock(*args)\n        transaction_opts = args.extract_options!\n        lock = args.present? ? args.first : true\n        transaction(**transaction_opts) do\n          lock!(lock)\n          yield\n        end",
        "comment": "Wraps the passed block in a transaction, reloading the object with a lock before yielding. You can pass the SQL locking clause as an optional argument (see #lock!).  You can also pass options like <tt>requires_new:</tt>, <tt>isolation:</tt>, and <tt>joinable:</tt> to the wrapping transaction (see ActiveRecord::ConnectionAdapters::DatabaseStatements#transaction).",
        "label": "Others",
        "id": "13332"
    },
    {
        "raw_code": "def self.command(name, **opts, &block)\n          # Validate the name of the command\n          if name.to_s !~ /^[-a-z0-9]+$/i\n            raise InvalidCommandName, \"Commands can only contain letters, numbers, and hyphens\"\n          end",
        "comment": "Defines additional command line commands available by key. The key becomes the subcommand, so if you register a command \"foo\" then \"vagrant foo\" becomes available.  @param [String] name Subcommand key.",
        "label": "Others",
        "id": "9104"
    },
    {
        "raw_code": "def input_filtered_search(search_term, submit: true, extra_space: true)\n    search = search_term\n    if extra_space\n      # Add an extra space to engage visual tokens\n      search = \"#{search_term} \"\n    end",
        "comment": "Enables input to be set (similar to copy and paste)",
        "label": "Others",
        "id": "8451"
    },
    {
        "raw_code": "def call_before_action\n        before_action.call if before_action\n      end",
        "comment": "Pass a block as :before_action if issuable state needs to be changed before the quick action is executed.",
        "label": "Others",
        "id": "8326"
    },
    {
        "raw_code": "def handle_exception(ex, ctx = {})\n      if @options[:error_handlers].size == 0\n        p [\"!!!!!\", ex]\n      end",
        "comment": "INTERNAL USE ONLY",
        "label": "Others",
        "id": "5190"
    },
    {
        "raw_code": "def get_assets_download_redirection_url\n        return file_url unless file_url.starts_with?(github_assets_url_regex)\n\n        options[:follow_redirects] = false\n        response = ::Import::Clients::HTTP.get(file_url, options)\n\n        if response.redirection?\n          response.headers[:location]\n        else\n          file_url\n        end",
        "comment": "Github /assets redirection link will redirect to aws which has its own authorization. Keeping our bearer token will cause request rejection eg. Only one auth mechanism allowed; only the X-Amz-Algorithm query parameter, Signature query string parameter or the Authorization header should be specified.",
        "label": "Others",
        "id": "2159"
    },
    {
        "raw_code": "def restore_conversion_of_integer_to_bigint(table, columns, primary_key: :id) # rubocop:disable Lint/UnusedMethodArgument -- for backward compatibility, don't remove primary_key\n        Gitlab::Database::Migrations::Conversions::BigintConverter\n          .new(self, table, columns)\n          .restore_cleanup\n      end",
        "comment": "Reverts `cleanup_conversion_of_integer_to_bigint`  table - The name of the database table containing the columns columns - The name, or array of names, of the column(s) that we have converted to bigint. primary_key - The name of the primary key column (most often :id)",
        "label": "Others",
        "id": "2996"
    },
    {
        "raw_code": "def child_pipeline\n        create(:pipeline,\n          project: upstream_project,\n          id: upstream_pipeline.downstream_pipeline_id(bridge_name: 'trigger_child'))\n      end",
        "comment": "Fetch upstream project's child pipeline",
        "label": "Others",
        "id": "4422"
    },
    {
        "raw_code": "def merge(other)\n    if empty? then\n      @parts = other.parts\n      return self\n    end",
        "comment": " When this is a collection of documents (#file is not set and this document contains only other documents as its direct children) #merge replaces documents in this class with documents from +other+ when the file matches and adds documents from +other+ when the files do not.  The information in +other+ is preferred over the receiver",
        "label": "Others",
        "id": "16426"
    },
    {
        "raw_code": "def or(right)\n        Nodes::Grouping.new Nodes::Or.new([self, right])\n      end",
        "comment": " Factory method to create a Nodes::Grouping node that has an Nodes::Or node as a child.",
        "label": "Others",
        "id": "13475"
    },
    {
        "raw_code": "def diff\n              RSpec::Support::Differ.new(color: true).diff(@result, expected)\n            end",
        "comment": "Object diff  @return [String]",
        "label": "Others",
        "id": "4595"
    },
    {
        "raw_code": "def organization_user_details_for_participants(participants)\n      return participants unless Feature.enabled?(:organization_users_internal, organization)\n\n      participants.map do |participant|\n        next participant unless participant.is_a?(User)\n\n        detail = participant.organization_user_details.to_a.find do |det|\n          det.organization == organization\n        end",
        "comment": "for users that have an OrganizationUserDetail for the current organization, use this instead of the User model for rendering username, display_name, and other details details should be pre-loaded to avoid N+1 queries",
        "label": "Others",
        "id": "5881"
    },
    {
        "raw_code": "def merge_requests_batch(ids)\n      MergeRequest.id_in(ids)\n    end",
        "comment": "This method is overridden in EE to extend its functionality like preloading associations.",
        "label": "Others",
        "id": "5571"
    },
    {
        "raw_code": "def unlock_user\n    update_user(&:unlock_access!)\n  end",
        "comment": "method overridden in EE",
        "label": "Others",
        "id": "6453"
    },
    {
        "raw_code": "def test_render_custom_code\n    get :render_custom_code\n    assert_response 404\n    assert_response :missing\n    assert_equal \"hello world\", @response.body\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12074"
    },
    {
        "raw_code": "def render_nothing_with_appendix\n    render plain: \"appended\"\n  end",
        "comment": ":ported:",
        "label": "Others",
        "id": "12042"
    },
    {
        "raw_code": "def usage_activity_by_stage_enablement(time_period)\n        {}\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord Empty placeholder allows this to match the pattern used by other sections",
        "label": "Others",
        "id": "1733"
    },
    {
        "raw_code": "def deep_sort_hashes(obj)\n    if obj.is_a?(Hash)\n      obj.map do |k, v|\n        [k, deep_sort_hashes(v)]\n      end.sort!.to_h\n    elsif obj.respond_to?(:map)\n      obj.map { |v| deep_sort_hashes(v) }\n    else\n      obj\n    end",
        "comment": "sort the hash keys and recursively sort nested hashes within enumberables",
        "label": "Others",
        "id": "10021"
    },
    {
        "raw_code": "def limit_exceeded?\n    false\n  end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "6506"
    },
    {
        "raw_code": "def loose_index_scan(column:, order: :asc)\n      arel_table = self.arel_table\n\n      # Handle different column types\n      arel_column, column_alias, column_for_select = extract_column_and_alias_and_select(column, arel_table)\n\n      cte = Gitlab::SQL::RecursiveCTE.new(:loose_index_scan_cte, union_args: { remove_order: false })\n\n      cte_query = except(:select)\n        .select(column_for_select)\n        .order(column_alias => order)\n        .limit(1)\n\n      inner_query = except(:select)\n\n      cte_query, inner_query = yield([cte_query, inner_query]) if block_given?\n      cte << cte_query\n\n      inner_query = if order == :asc\n                      inner_query.where(arel_column.gt(cte.table[column_alias]))\n                    else\n                      inner_query.where(arel_column.lt(cte.table[column_alias]))\n                    end",
        "comment": "Builds a recursive query to read distinct values from a column.  Example 1: collect all distinct author ids for the `issues` table  Bad: The DB reads all issues, sorts and dedups them in memory  > Issue.select(:author_id).distinct.map(&:author_id)  Good: Use loose index scan (skip index scan)  > Issue.loose_index_scan(column: :author_id).map(&:author_id)  Example 2: List of users for the DONE todos selector. Select all users who created a todo.  Bad: Loads all DONE todos for the given user and extracts the author_ids  > User.where(id: Todo.where(user_id: 4156052).done.select(:author_id))  Good: Loads distinct author_ids from todos and then loads users  > distinct_authors = Todo.where(user_id: 4156052).done.loose_index_scan(column: :author_id).select(:author_id) > User.where(id: distinct_authors)",
        "label": "Others",
        "id": "7321"
    },
    {
        "raw_code": "def normalize\n    parts = []\n\n    newlines = 0\n\n    @parts.each do |part|\n      case part\n      when /^\\s*\\n/ then\n        newlines += 1\n        parts << part if newlines == 1\n      else\n        newlines = 0\n        parts << part\n      end",
        "comment": " Collapses 3+ newlines into two newlines",
        "label": "Others",
        "id": "16241"
    },
    {
        "raw_code": "def tokens\n        extract(self.class::REGEXP).split(self.class::SEPARATOR).map(&:strip)\n      end",
        "comment": "Individual tokens composing an editor specific comment string.  @return [Array<String>]",
        "label": "Others",
        "id": "10162"
    },
    {
        "raw_code": "def parse_symbol_arg_paren(no) # :nodoc:\n    args = []\n\n    loop do\n      skip_tkspace_comment\n      if tk1 = parse_symbol_in_arg\n        args.push tk1\n        break if no and args.size >= no\n      end",
        "comment": " Parses up to +no+ symbol arguments surrounded by () and places them in +args+.",
        "label": "Others",
        "id": "16114"
    },
    {
        "raw_code": "def decorated_message(offense)\n          offense.message.gsub(/`(.+?)`/) { \"<code>#{escape(Regexp.last_match(1))}</code>\" }\n        end",
        "comment": "rubocop:enable Lint/UselessMethodDefinition",
        "label": "Others",
        "id": "10185"
    },
    {
        "raw_code": "def networkd?(comm)\n          comm.test(\"command -v networkd\")\n        end",
        "comment": "is networkd isntalled  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @return [Boolean]",
        "label": "Others",
        "id": "9265"
    },
    {
        "raw_code": "def additional_test_user\n            return create_new_user if admin_api_client\n\n            init_user(\n              username: extra_test_user_credential(Data::ADDITIONAL_TEST_USERNAME_VARIABLE_NAME),\n              password: extra_test_user_credential(Data::ADDITIONAL_TEST_PASSWORD_VARIABLE_NAME)\n            ).reload!\n          end",
        "comment": "Additional test user  @return [QA::Resource::User]",
        "label": "Others",
        "id": "4508"
    },
    {
        "raw_code": "def all_used?\n          payload.dig(:mocks, :all_used)\n        end",
        "comment": "Check if all mock definitions have been used  @return [Boolean]",
        "label": "Others",
        "id": "4350"
    },
    {
        "raw_code": "def <=>(other)\n      return super if !other.is_a?(self.class)\n\n      # Comparison is done by composing the name and provider\n      \"#{@name}-#{@version}-#{@provider}-#{@architecture}\" <=>\n      \"#{other.name}-#{other.version}-#{other.provider}-#{other.architecture}\"\n    end",
        "comment": "Implemented for comparison with other boxes. Comparison is implemented by comparing names, providers, and architectures.",
        "label": "Others",
        "id": "8728"
    },
    {
        "raw_code": "def annotate(tag)\n    tag\n  end",
        "comment": " Allows +tag+ to be decorated with additional information.",
        "label": "Others",
        "id": "16276"
    },
    {
        "raw_code": "def do_something; end\n\n            end",
        "comment": "{type} SomeObject",
        "label": "Others",
        "id": "11021"
    },
    {
        "raw_code": "def skip_tkspace\n    tokens = []\n\n    while (tk = get_tk) and (:on_sp == tk[:kind] or :on_nl == tk[:kind] or :on_ignored_nl == tk[:kind]) do\n      tokens.push(tk)\n    end",
        "comment": " Skips whitespace tokens including newlines",
        "label": "Others",
        "id": "16179"
    },
    {
        "raw_code": "def values\n            {\n              global: {\n                shell: {\n                  port: host_ssh_port\n                },\n                pages: {\n                  port: host_http_port\n                },\n                registry: {\n                  port: host_registry_port\n                },\n                initialRootPassword: {\n                  secret: ADMIN_PASSWORD_SECRET\n                },\n                gitaly: {\n                  hooks: {\n                    preReceive: {\n                      configmap: PRE_RECEIVE_HOOK_CONFIGMAP_NAME\n                    }\n                  }\n                }\n              },\n              \"nginx-ingress\": {\n                controller: {\n                  replicaCount: 1,\n                  minAavailable: 1,\n                  service: {\n                    type: \"NodePort\",\n                    nodePorts: {\n                      \"gitlab-shell\": Orchestrator::Kind::Cluster.host_port_mapping(host_ssh_port),\n                      http: Orchestrator::Kind::Cluster.host_port_mapping(host_http_port),\n                      registry: Orchestrator::Kind::Cluster.host_port_mapping(host_registry_port)\n                    }\n                  }\n                }\n              }\n            }.deep_merge(ResourcePresets.resource_values(resource_preset))\n          end",
        "comment": "Helm chart values specific to kind deployment  @return [Hash]",
        "label": "Others",
        "id": "4023"
    },
    {
        "raw_code": "def diff_linesToChars(text1, text2)\n    line_array = ['']  # e.g. line_array[4] == \"Hello\\n\"\n    line_hash = {}     # e.g. line_hash[\"Hello\\n\"] == 4\n\n    [text1, text2].map do |text|\n      # Split text into an array of strings.  Reduce the text to a string of\n      # hashes where each Unicode character represents one line.\n      chars = ''\n      text.each_line do |line|\n        if line_hash[line]\n          chars += line_hash[line].chr(Encoding::UTF_8)\n        else\n          chars += line_array.length.chr(Encoding::UTF_8)\n          line_hash[line] = line_array.length\n          line_array.push(line)\n        end",
        "comment": "Split two texts into an array of strings.  Reduce the texts to a string of hashes where each Unicode character represents one line.",
        "label": "Others",
        "id": "5050"
    },
    {
        "raw_code": "def quiet!\n      raise \"Can't quiet an embedded process\" if embedded?\n\n      signal(\"TSTP\")\n    end",
        "comment": "Signal this process to stop processing new jobs. It will continue to execute jobs it has already fetched. This method is *asynchronous* and it can take 5-10 seconds for the process to quiet.",
        "label": "Others",
        "id": "5150"
    },
    {
        "raw_code": "def ruby_30_or_lower_optarg?\n            target_ruby_version <= 3.0 && @def_node.arguments.any?(&:optarg_type?)\n          end",
        "comment": "rubocop:enable Metrics/CyclomaticComplexity def foo(a = 41, ...) is a syntax error in 3.0.",
        "label": "Others",
        "id": "10587"
    },
    {
        "raw_code": "def self.transform(collection:, node:, user:)\n          ActiveContext.adapter.client.with_model_for(collection.collection_name) do |model|\n            relation = new(collection: collection, model: model, user: user).process(node)\n            relation.to_sql\n          end",
        "comment": "Transforms a query node into a PostgreSQL query using ActiveRecord",
        "label": "Others",
        "id": "1161"
    },
    {
        "raw_code": "def parsed_params\n        params\n      end",
        "comment": "Overridden in EE",
        "label": "Others",
        "id": "5528"
    },
    {
        "raw_code": "def convert_string(string)\n    return string unless @in_b or @in_em\n    chars = if @in_b then\n              string.chars.map do |char| \"#{char}\\b#{char}\" end\n            elsif @in_em then\n              string.chars.map do |char| \"_\\b#{char}\" end\n            end",
        "comment": " Adds bold or underline mixed with backspaces",
        "label": "Others",
        "id": "16220"
    },
    {
        "raw_code": "def unmask_protected_sequences\n    @str.gsub!(/(.)#{PROTECT_ATTR}/, \"\\\\1\\000\")\n  end",
        "comment": " Unescapes regexp handling sequences of text",
        "label": "Others",
        "id": "16233"
    },
    {
        "raw_code": "def expire_content_cache\n    expire_tags_cache\n    expire_branches_cache\n    expire_root_ref_cache\n    expire_emptiness_caches\n    expire_exists_cache\n    expire_statistics_caches\n  end",
        "comment": "expire cache that doesn't depend on repository data (when expiring)",
        "label": "How-it-is-done",
        "id": "7134"
    },
    {
        "raw_code": "def supports_check_constraints?\n        false\n      end",
        "comment": "Does this adapter support creating check constraints?",
        "label": "How-it-is-done",
        "id": "12897"
    },
    {
        "raw_code": "def refresh_storage_size!\n    self.class.where(id: id).update_all(\"storage_size = #{storage_size_sum}\")\n  end",
        "comment": "Since this incremental update method does not update the storage_size directly, we have to update the storage_size separately in an after_commit action.",
        "label": "How-it-is-done",
        "id": "7001"
    },
    {
        "raw_code": "def initialize(options, characters = 100, paragraphs = 3, markup = nil)\n    super options, markup\n\n    @character_limit = characters\n    @paragraph_limit = paragraphs\n\n    @characters = 0\n    @mask       = 0\n    @paragraphs = 0\n\n    @markup.add_regexp_handling RDoc::CrossReference::CROSSREF_REGEXP, :CROSSREF\n  end",
        "comment": " Creates a new ToHtmlSnippet formatter that will cut off the input on the next word boundary after the given number of +characters+ or +paragraphs+ of text have been encountered.",
        "label": "How-it-is-done",
        "id": "16400"
    },
    {
        "raw_code": "def register_parser_type(type, parser_klass, extensions = nil)\n          unless Base > parser_klass\n            raise ArgumentError, \"expecting parser_klass to be a subclass of YARD::Parser::Base\"\n          end",
        "comment": "Registers a new parser type.  @example Registering a parser for \"java\" files SourceParser.register_parser_type :java, JavaParser, 'java' @param [Symbol] type a symbolic name for the parser type @param [Base] parser_klass a class that implements parsing and tokenization @param [Array<String>, String, Regexp] extensions a list of extensions or a regex to match against the file extension @return [void] @see Parser::Base",
        "label": "How-it-is-done",
        "id": "290"
    },
    {
        "raw_code": "def tag(tag)\n    if gitlab_api_client.supports_gitlab_api?\n      page = tags_page(name: tag)\n      return if page[:tags].blank?\n\n      page[:tags].find { |result_tag| result_tag.name == tag }\n    else\n      ContainerRegistry::Tag.new(self, tag)\n    end",
        "comment": "If the container registry GitLab API is available, the API does a search of tags containing the name and we filter them to find the exact match. Otherwise, we instantiate a tag.",
        "label": "How-it-is-done",
        "id": "7034"
    },
    {
        "raw_code": "def unescape(html)\n    %w([ ] { }).each do |cgi_escape|\n      html.sub!(CGI.escape(cgi_escape), cgi_escape)\n    end",
        "comment": "Rinku does not escape these characters in HTML attributes, but content_tag does. We don't care about that difference for these specs, though.",
        "label": "How-it-is-done",
        "id": "8245"
    },
    {
        "raw_code": "def scope_with_cached_ids(consistent_ids_scope, model, cached_ids_column)\n        # Look up the cached ids and unnest them into rows if the cache is up to date.\n        cache_lookup_query = Namespaces::Descendants\n          .where(outdated_at: nil, namespace_id: id)\n          .select(cached_ids_column.as('ids'))\n\n        # Invoke the consistent lookup query and collect the ids as a single array value\n        consistent_descendant_ids_scope = model\n          .from(consistent_ids_scope.arel.as(model.table_name))\n          .reselect(Arel::Nodes::NamedFunction.new('ARRAY_AGG', [model.arel_table[:id]]).as('ids'))\n          .unscope(where: :type)\n\n        from = <<~SQL\n        UNNEST(\n          COALESCE(\n            (SELECT ids FROM (#{cache_lookup_query.to_sql}) cached_query),\n            (SELECT ids FROM (#{consistent_descendant_ids_scope.to_sql}) consistent_query))\n        ) AS #{model.table_name}(id)\n        SQL\n\n        model\n          .from(from)\n          .unscope(where: :type)\n          .select(:id)\n      end",
        "comment": "This method implements an OR based cache lookup using COALESCE, similar what you would do in Ruby: return cheap_cached_data || expensive_uncached_data",
        "label": "How-it-is-done",
        "id": "7191"
    },
    {
        "raw_code": "def self.post_process(html, context)\n      context = Pipeline[context[:pipeline]].transform_context(context)\n\n      # Use a passed class for the pipeline or default to PostProcessPipeline\n      pipeline = context.delete(:post_process_pipeline) || ::Banzai::Pipeline::PostProcessPipeline\n\n      instrument_filters do\n        if context[:xhtml]\n          pipeline.to_document(html, context).to_html(save_with: Nokogiri::XML::Node::SaveOptions::AS_XHTML)\n        else\n          pipeline.to_html(html, context)\n        end.html_safe\n      end",
        "comment": "Perform post-processing on an HTML String  This method is used to perform state-dependent changes to a String of HTML, such as removing references that the current user doesn't have permission to make (`ReferenceRedactorFilter`).  html     - String to process context  - Hash of options to customize output :pipeline  - Symbol pipeline type - for context transform only, defaults to :full :project   - Project :user      - User object :post_process_pipeline - pipeline to use for post_processing - defaults to PostProcessPipeline  Returns an HTML-safe String",
        "label": "How-it-is-done",
        "id": "3397"
    },
    {
        "raw_code": "def loop_until(timeout: nil, limit: 1_000_000)\n      raise ArgumentError unless limit\n\n      start = Time.now\n\n      limit.times do\n        return true unless yield\n\n        return false if timeout && (Time.now - start) > timeout\n      end",
        "comment": " This helper method repeats the same task until it's expired.  Note: ExpiredLoopError does not happen until the given block finished. Please do not use this method for heavy or asynchronous operations.",
        "label": "How-it-is-done",
        "id": "1624"
    },
    {
        "raw_code": "def dump(object)\n        adapter_dump(object)\n      end",
        "comment": "Restricted method for converting a Ruby object to JSON. If you need to pass options to this, you should use `.generate` instead, as the underlying implementation of this varies wildly based on the adapter in use.  This method does, in some situations, differ in the data it returns compared to .generate. Counter-intuitively, this is closest in terms of response to JSON.generate and to the default ActiveSupport .to_json method.  @param object [Object] the object to convert to JSON @return [String]",
        "label": "How-it-is-done",
        "id": "1639"
    },
    {
        "raw_code": "def resource_request(resource_or_path, **options)\n        api_path = resource_or_path.is_a?(Hash) ? resource_or_path[:api_path] : resource_or_path\n\n        Runtime::API::Request.new(api_client, api_path, **options).url\n      end",
        "comment": "Creates a GitLab API request URL from a resource or path  @param [Hash, String] resource_or_path Either a resource hash containing :api_path or a direct API path string @param [Hash] options Additional options to pass to the API request @return [String] The complete API request URL",
        "label": "How-it-is-done",
        "id": "4676"
    },
    {
        "raw_code": "def stale_processables\n        Ci::Processable.where(id: retained.select(:build_id))\n                       .complete\n                       .updated_at_before(5.minutes.ago)\n      end",
        "comment": "In some cases, state machine hooks in `Ci::Build` are skipped even if the job status transitions to a complete state. For example, `Ci::Build#doom!` (a.k.a `data_integrity_failure`) doesn't execute state machine hooks. To handle these edge cases, we check the staleness of the jobs that currently assigned to the resources, and release if it's stale. See https://gitlab.com/gitlab-org/gitlab/-/issues/335537#note_632925914 for more information.",
        "label": "How-it-is-done",
        "id": "7586"
    },
    {
        "raw_code": "def systemd_get_wants(unitname)\n      stdout, _stderr, status = Open3.capture3(\"systemctl\", \"--no-pager\", \"show\", unitname)\n\n      unless status\n        return []\n      end",
        "comment": "Return the Wants= of a unit, empty if the unit doesn't exist",
        "label": "How-it-is-done",
        "id": "3722"
    },
    {
        "raw_code": "def handle_comm(type, data)\n        if [:stderr, :stdout].include?(type)\n          # Clear out the newline since we add one\n          data = data.chomp\n          return if data.empty?\n\n          options = {}\n          #options[:color] = color if !config.keep_color\n\n          @machine.ui.info(data.chomp, **options)\n        end",
        "comment": "This handles outputting the communication data back to the UI",
        "label": "How-it-is-done",
        "id": "9925"
    },
    {
        "raw_code": "def transform_keys!(&block)\n      return to_enum(:transform_keys!) unless block_given?\n      @parameters.transform_keys!(&block)\n      self\n    end",
        "comment": "Performs keys transformation and returns the altered `ActionController::Parameters` instance.",
        "label": "How-it-is-done",
        "id": "11377"
    },
    {
        "raw_code": "def load(locale_directory)\n    return false if @name.nil?\n\n    po_file_candidates = [\n      File.join(locale_directory, @name, 'rdoc.po'),\n      File.join(locale_directory, \"#{@name}.po\"),\n    ]\n    po_file = po_file_candidates.find do |po_file_candidate|\n      File.exist?(po_file_candidate)\n    end",
        "comment": " Loads translation messages from +locale_directory+/+@name+/rdoc.po or +locale_directory+/+@name+.po. The former has high priority.  This method requires gettext gem for parsing .po file. If you don't have gettext gem, this method doesn't load .po file. This method warns and returns +false+.  Returns +true+ if succeeded, +false+ otherwise.",
        "label": "How-it-is-done",
        "id": "16628"
    },
    {
        "raw_code": "def create_virtual_table(table_name, module_name, values)\n        exec_query \"CREATE VIRTUAL TABLE IF NOT EXISTS #{table_name} USING #{module_name} (#{values.join(\", \")})\"\n      end",
        "comment": "Creates a virtual table  Example: create_virtual_table :emails, :fts5, ['sender', 'title', 'body']",
        "label": "How-it-is-done",
        "id": "12996"
    },
    {
        "raw_code": "def test_verbatim_normalize\n    v = @RM::Verbatim.new \"foo\\n\", \"\\n\", \"\\n\", \"bar\\n\"\n\n    v.normalize\n\n    assert_equal [\"foo\\n\", \"\\n\", \"bar\\n\"], v.parts\n\n    v = @RM::Verbatim.new \"foo\\n\", \"\\n\"\n\n    v.normalize\n\n    assert_equal [\"foo\\n\"], v.parts\n  end",
        "comment": "HACK move to Verbatim test case",
        "label": "How-it-is-done",
        "id": "16856"
    },
    {
        "raw_code": "def process_alter_sequence(alter_seq)\n            sequence_schema = alter_seq.sequence.schemaname\n            sequence_schema = default_schema_name if sequence_schema == ''\n            sequence_name = alter_seq.sequence.relname\n\n            # Look for OWNED BY option\n            return unless alter_seq.options\n\n            owner_schema = default_schema_name\n            owner_table = nil\n            owner_column = nil\n\n            alter_seq.options.each do |option|\n              def_elem = option.def_elem\n\n              next unless def_elem.defname == 'owned_by'\n              next unless def_elem.arg && def_elem.arg.node == :list\n\n              owned_by_list = def_elem.arg.list.items\n\n              next unless owned_by_list.length >= 2\n\n              # Handle schema.table.column or table.column\n              if owned_by_list.length == 3\n                owner_schema = owned_by_list[0].string.sval\n                owner_table = owned_by_list[1].string.sval\n                owner_column = owned_by_list[2].string.sval\n              else\n                owner_table = owned_by_list[0].string.sval\n                owner_column = owned_by_list[1].string.sval\n              end",
        "comment": "Processes ALTER SEQUENCE SQL queries to extract column owner. For example:  ALTER SEQUENCE ai_code_suggestion_events_id_seq OWNED BY ai_code_suggestion_events.id;",
        "label": "How-it-is-done",
        "id": "1188"
    },
    {
        "raw_code": "def find_or_create_constant_owner_name(constant_path)\n    const_path, colon, name = constant_path.rpartition('::')\n    if colon.empty? # class Foo\n      # Within `class C` or `module C`, owner is C(== current container)\n      # Within `class <<C`, owner is C.singleton_class\n      # but RDoc don't track constants of a singleton class of module\n      [(@singleton ? nil : @container), name]\n    elsif const_path.empty? # class ::Foo\n      [@top_level, name]\n    else # `class Foo::Bar` or `class ::Foo::Bar`\n      [find_or_create_module_path(const_path, :module), name]\n    end",
        "comment": "Returns a pair of owner module and constant name from a given constant path. Creates owner module if it does not exist.",
        "label": "How-it-is-done",
        "id": "16046"
    },
    {
        "raw_code": "def hostonly_create_network(config)\n          @env[:machine].provider.driver.create_host_only_network(config)\n        end",
        "comment": "----------------------------------------------------------------- Hostonly Helper Functions ----------------------------------------------------------------- This creates a host only network for the given configuration.",
        "label": "How-it-is-done",
        "id": "9645"
    },
    {
        "raw_code": "def finalize_backfilling_partitioned_table(table_name)\n          assert_table_is_allowed(table_name)\n\n          partitioned_table_name = make_partitioned_table_name(table_name)\n\n          unless table_exists?(partitioned_table_name)\n            raise \"could not find partitioned table for #{table_name}, \" \\\n              \"this could indicate the previous partitioning migration has been rolled back.\"\n          end",
        "comment": "Executes jobs from previous BatchedBackgroundMigration to backfill the partitioned table by finishing pending jobs.  **NOTE** Migrations using this method cannot be scheduled in the same release as the migration that schedules the background migration using the `enqueue_partitioning_data_migration` helper, or else the background migration jobs will be force-executed.  Example:  finalize_backfilling_partitioned_table :audit_events ",
        "label": "How-it-is-done",
        "id": "3054"
    },
    {
        "raw_code": "def impl(usable, name)\n    Class.new(Vagrant.plugin(\"2\", :synced_folder)) do\n      define_method(:name) do\n        name\n      end",
        "comment": "This creates a synced folder implementation.",
        "label": "How-it-is-done",
        "id": "9946"
    },
    {
        "raw_code": "def squish!\n    gsub!(/[[:space:]]+/, \" \")\n    strip!\n    self\n  end",
        "comment": "Performs a destructive squish. See String#squish. str = \" foo   bar    \\n   \\t   boo\" str.squish!                         # => \"foo bar boo\" str                                 # => \"foo bar boo\"",
        "label": "How-it-is-done",
        "id": "14354"
    },
    {
        "raw_code": "def cache_key\n    \"#{self.class.table_name}/#{id}-#{read_attribute_before_type_cast(:updated_at)}\"\n  end",
        "comment": "A faster version of Rails' \"cache_key\" method.  Rails' default \"cache_key\" method uses all kind of complex logic to figure out the cache key. In many cases this complexity and overhead may not be needed.  This method does not do any timestamp parsing as this process is quite expensive and not needed when generating cache keys. This method also relies on the table name instead of the cache namespace name as the latter uses complex logic to generate the exact same value (as when using the table name) in 99% of the cases.",
        "label": "How-it-is-done",
        "id": "7410"
    },
    {
        "raw_code": "def parse_tag_with_types_and_name(tag_name, text)\n        name, types, text = *extract_types_and_name_from_text(text)\n        name, text = *extract_name_from_text(text) unless name\n        Tag.new(tag_name, text, types, name)\n      end",
        "comment": "Parses tag text and creates a new tag with formally declared types, a key name and descriptive text  @param tag_name        the name of the tag to parse @param [String] text   the raw tag text @return [Tag]          a tag object with the tag_name, name, types and text values filled",
        "label": "How-it-is-done",
        "id": "232"
    },
    {
        "raw_code": "def initialize(markup = nil)\n    super\n\n    @headings[1] = ['# ',      '']\n    @headings[2] = ['## ',     '']\n    @headings[3] = ['### ',    '']\n    @headings[4] = ['#### ',   '']\n    @headings[5] = ['##### ',  '']\n    @headings[6] = ['###### ', '']\n\n    add_regexp_handling_RDOCLINK\n    add_regexp_handling_TIDYLINK\n\n    @hard_break = \"  \\n\"\n  end",
        "comment": " Creates a new formatter that will output Markdown format text",
        "label": "How-it-is-done",
        "id": "16376"
    },
    {
        "raw_code": "def parse_options(opts, args)\n        opts.parse!(args)\n      rescue OptionParser::ParseError => err\n        unrecognized_option(err)\n        args.shift if args.first && args.first[0, 1] != '-'\n        retry\n      end",
        "comment": "Parses the option and gracefully handles invalid switches  @param [OptionParser] opts the option parser object @param [Array<String>] args the arguments passed from input. This array will be modified. @return [void]",
        "label": "How-it-is-done",
        "id": "509"
    },
    {
        "raw_code": "def supports_index_include?\n        false\n      end",
        "comment": "Does this adapter support including non-key columns?",
        "label": "How-it-is-done",
        "id": "12888"
    },
    {
        "raw_code": "def initialize(type, text)\n    @type, @text = type, text\n  end",
        "comment": " Creates a new regexp handling sequence of +type+ with +text+",
        "label": "How-it-is-done",
        "id": "16436"
    },
    {
        "raw_code": "def create\n      open_authorized_keys_file(File::CREAT) { true }\n    rescue Errno::EACCES\n      false\n    end",
        "comment": "Creates the authorized_keys file if it doesn't exist  @return [Boolean]",
        "label": "How-it-is-done",
        "id": "1685"
    },
    {
        "raw_code": "def execute\n          return success(deleted: []) if @tag_names.empty?\n\n          # generates the blobs for the dummy image\n          dummy_manifest = @container_repository.client.generate_empty_manifest(@container_repository.path)\n          return error('could not generate manifest') if dummy_manifest.nil?\n\n          deleted_tags = replace_tag_manifests(dummy_manifest)\n\n          # Deletes the dummy image\n          # All created tag digests are the same since they all have the same dummy image.\n          # a single delete is sufficient to remove all tags with it\n          if deleted_tags.any? && @container_repository.delete_tag(deleted_tags.each_value.first)\n            success(deleted: deleted_tags.keys)\n          else\n            error(\"could not delete tags: #{@tag_names.join(', ')}\".truncate(1000))\n          end",
        "comment": "Replace a tag on the registry with a dummy tag. This is a hack as the registry doesn't support deleting individual tags. This code effectively pushes a dummy image and assigns the tag to it. This way when the tag is deleted only the dummy image is affected. This is used to preserve compatibility with third-party registries that don't support fast delete. See https://gitlab.com/gitlab-org/gitlab/issues/15737 for a discussion",
        "label": "How-it-is-done",
        "id": "5948"
    },
    {
        "raw_code": "def self.create_disk(machine, disk_config, controller)\n          machine.ui.detail(I18n.t(\"vagrant.cap.configure_disks.create_disk\", name: disk_config.name))\n          # NOTE: At the moment, there are no provider specific configs for VirtualBox\n          # but we grab it anyway for future use.\n          disk_provider_config = disk_config.provider_config[:virtualbox] if disk_config.provider_config\n\n          guest_info = machine.provider.driver.show_vm_info\n          guest_folder = File.dirname(guest_info[\"CfgFile\"])\n\n          disk_ext = disk_config.disk_ext\n          disk_file = File.join(guest_folder, disk_config.name) + \".#{disk_ext}\"\n\n          LOGGER.info(\"Attempting to create a new disk file '#{disk_file}' of size '#{disk_config.size}' bytes\")\n\n          disk_var = machine.provider.driver.create_disk(disk_file, disk_config.size, disk_ext.upcase)\n          dsk_controller_info = get_next_port(machine, controller)\n          machine.provider.driver.attach_disk(controller.name,\n                                              dsk_controller_info[:port],\n                                              dsk_controller_info[:device],\n                                              \"hdd\",\n                                              disk_file)\n\n          disk_metadata = { uuid: disk_var.split(\":\").last.strip, name: disk_config.name,\n                            controller: controller.name, port: dsk_controller_info[:port],\n                            device: dsk_controller_info[:device] }\n\n          disk_metadata\n        end",
        "comment": "Creates and attaches a disk to a machine  @param [Vagrant::Machine] machine @param [Kernel_V2::VagrantConfigDisk] disk_config @param [VagrantPlugins::ProviderVirtualBox::Model::StorageController] controller - the storage controller to use",
        "label": "How-it-is-done",
        "id": "9629"
    },
    {
        "raw_code": "def sub_batch_exceeds_threshold?\n          initial_sub_batch_size = batched_migration.sub_batch_size\n          reduced_sub_batch_size = (sub_batch_size * SUB_BATCH_SIZE_REDUCE_FACTOR).to_i\n          diff = initial_sub_batch_size - reduced_sub_batch_size\n\n          (1.0 * diff / initial_sub_batch_size * 100).round(2) > SUB_BATCH_SIZE_THRESHOLD\n        end",
        "comment": "It doesn't allow sub-batch size to be reduced lower than the threshold  @info It will prevent the next iteration to reduce the +sub_batch_size+ lower than the +SUB_BATCH_SIZE_THRESHOLD+ or 65% of its original size.",
        "label": "How-it-is-done",
        "id": "3223"
    },
    {
        "raw_code": "def preloader_for(reflection)\n            if reflection.options[:through]\n              ThroughAssociation\n            else\n              Association\n            end",
        "comment": "Returns a class containing the logic needed to load preload the data and attach it to a relation. The class returned implements a `run` method that accepts a preloader.",
        "label": "How-it-is-done",
        "id": "12826"
    },
    {
        "raw_code": "def create_reader(klass, member)\n    new_meth = register MethodObject.new(klass, member, :instance) do |o|\n      o.signature ||= \"def #{member}\"\n      o.source ||= \"#{o.signature}\\n  @#{member}\\nend\"\n    end",
        "comment": "Creates the getter (reader) method and attaches it to the class as an attribute. Also sets up the docstring to prettify the documentation output.  @param [ClassObject] klass the class to attach the method to @param [String] member the name of the member we're generating a method for",
        "label": "How-it-is-done",
        "id": "205"
    },
    {
        "raw_code": "def pool\n          ActiveRecord::Base.connection_handler.retrieve_connection_pool(\n            @configuration.connection_specification_name,\n            role: ActiveRecord.writing_role,\n            shard: ActiveRecord::Base.default_shard\n          ) || raise(::ActiveRecord::ConnectionNotEstablished)\n        end",
        "comment": "ActiveRecord::ConnectionAdapters::ConnectionHandler handles fetching, and caching for connections pools for each \"connection\", so we leverage that. rubocop:disable Database/MultipleDatabases",
        "label": "How-it-is-done",
        "id": "3100"
    },
    {
        "raw_code": "def add_gitlab_instance(name:, url:, external_port:, internal_port: '80', omnibus_config: nil)\n          cell_url = \"http://#{url}/\"\n          external_url = \"http://#{url}:#{external_port}/\"\n          ports = \"#{external_port}:#{internal_port}\"\n          omnibus_config ||= omnibus_configuration(cell_url: cell_url)\n          @list << Service::DockerRun::Gitlab.new(\n            image: Runtime::Env.release,\n            name: name,\n            ports: ports,\n            omnibus_config: omnibus_config,\n            external_url: external_url).tap do |gitlab|\n            gitlab.login\n            gitlab.register!\n          end",
        "comment": "Creates a DockerRun::Gitlab instance and adds to the list of instances @param name [string] the name for the instance @param url [string] the URL for the instance @param external_port [string] the external port @param internal_port [string] the internal port to use instead of default (optional) @param omnibus_config [string] omnibus_configuration to use instead of default (optional) @return [Service::DockerRun::Gitlab] the last created GitLab instance",
        "label": "How-it-is-done",
        "id": "4220"
    },
    {
        "raw_code": "def parse(data)\n      if !data.respond_to?(:read)\n        data = StringIO.new(data || \"\")\n      end",
        "comment": "Parse an XML Document string or IO into a simple hash.  Same as XmlSimple::xml_in but doesn't shoot itself in the foot, and uses the defaults from Active Support.  data:: XML Document string or IO to parse",
        "label": "How-it-is-done",
        "id": "14592"
    },
    {
        "raw_code": "def self.render_and_post_process(text, context = {})\n    post_process(render(text, context), context)\n  end",
        "comment": "if you need to render markdown, then you probably need to post_process as well, such as removing references that the current user doesn't have permission to make",
        "label": "How-it-is-done",
        "id": "1324"
    },
    {
        "raw_code": "def connecting_to(role: default_role, shard: default_shard, prevent_writes: false)\n      prevent_writes = true if role == ActiveRecord.reading_role\n\n      append_to_connected_to_stack(role: role, shard: shard, prevent_writes: prevent_writes, klasses: [self])\n    end",
        "comment": "Use a specified connection.  This method is useful for ensuring that a specific connection is being used. For example, when booting a console in readonly mode.  It is not recommended to use this method in a request since it does not yield to a block like +connected_to+.",
        "label": "How-it-is-done",
        "id": "12400"
    },
    {
        "raw_code": "def recreate_database(name, options = {})\n        drop_database(name)\n        sql = create_database(name, options)\n        reconnect!\n        sql\n      end",
        "comment": "SCHEMA STATEMENTS ======================================== Drops the database specified on the +name+ attribute and creates it again using the provided +options+.",
        "label": "How-it-is-done",
        "id": "12949"
    },
    {
        "raw_code": "def assert_no_event_reported(name = nil, payload: {}, tags: {}, &block)\n        events = EventCollector.record(&block)\n\n        if name.nil?\n          assert_predicate(events, :empty?)\n        else\n          matching_event = events.find { |event| event.matches?(name, payload, tags) }\n          if matching_event\n            message = \"Expected no '#{name}' event to be reported, but found:\\n  \" \\\n              \"#{matching_event.inspect}\"\n            flunk(message)\n          end",
        "comment": "Asserts that the block does not cause an event to be reported to +Rails.event+.  If no name is provided, passes if evaluated code in the yielded block reports no events.  assert_no_event_reported do service_that_does_not_report_events.perform end  If a name is provided, passes if evaluated code in the yielded block reports no events with that name.  assert_no_event_reported(\"user.created\") do service_that_does_not_report_events.perform end",
        "label": "How-it-is-done",
        "id": "14533"
    },
    {
        "raw_code": "def gl_redirect_listbox_tag(items, selected, html_options = {})\n    # Add script tag for app/assets/javascripts/entrypoints/behaviors/redirect_listbox.js\n    content_for :page_specific_javascripts do\n      webpack_bundle_tag 'redirect_listbox'\n    end",
        "comment": "Creates a listbox component with redirect behavior.  Use this for migrating existing deprecated dropdowns to become Pajamas-compliant. New features should use Vue components directly instead.  The `items` parameter must be an array of hashes, each with `value`, `text` and `href` keys, where `value` is a unique identifier for the item (e.g., the sort key), `text` is the user-facing string for the item, and `href` is the path to redirect to when that item is selected.  The `selected` parameter is the currently selected `value`, and should correspond to one of the `items`, or be `nil`. When `selected.nil?` or a value which does not correspond to one of the items, the first item is selected.  The final parameter `html_options` applies arbitrary attributes to the returned tag. Some of these are passed to the underlying Vue component as props, e.g., to right-align the menu of items, add `data: { placement: 'right' }`.  Examples: # Create a listbox with two items, with the first item selected - items = [{ value: 'foo', text: 'Name, ascending', href: '/foo' }, { value: 'bar', text: 'Name, descending', href: '/bar' }] = gl_redirect_listbox_tag items, 'foo'  # Create the same listbox, right-align the menu and add margin styling = gl_redirect_listbox_tag items, 'foo', class: 'gl-ml-3', data: { placement: 'right' }",
        "label": "How-it-is-done",
        "id": "7751"
    },
    {
        "raw_code": "def self.start(queues, env: :development, directory: Dir.pwd, concurrency: 20, timeout: DEFAULT_SOFT_TIMEOUT_SECONDS, dryrun: false)\n      queues.map.with_index do |pair, index|\n        start_sidekiq(pair, env: env,\n          directory: directory,\n          concurrency: concurrency,\n          worker_id: index,\n          timeout: timeout,\n          dryrun: dryrun)\n      end",
        "comment": "Starts Sidekiq workers for the pairs of processes.  Example:  start([ ['foo'], ['bar', 'baz'] ], :production)  This would start two Sidekiq processes: one processing \"foo\", and one processing \"bar\" and \"baz\". Each one is placed in its own process group.  queues - An Array containing Arrays. Each sub Array should specify the queues to use for a single process.  directory - The directory of the Rails application.  Returns an Array containing the waiter threads (from Process.detach) of the started processes.",
        "label": "How-it-is-done",
        "id": "816"
    },
    {
        "raw_code": "def overridden_method\n      return nil if namespace.is_a?(Proxy)\n      meths = namespace.meths(:all => true)\n      meths.find {|m| m.path != path && m.name == name && m.scope == scope }\n    end",
        "comment": "@return [MethodObject] the object that this method overrides @return [nil] if it does not override a method @since 0.6.0",
        "label": "How-it-is-done",
        "id": "558"
    },
    {
        "raw_code": "def sort_by_job_status\n      <<~SQL\n        CASE status\n          WHEN 'waiting_for_resource' THEN 0\n          ELSE 1\n        END ASC\n      SQL\n    end",
        "comment": "In order to avoid deadlock, we do NOT specify the job execution order in the same pipeline. The system processes wherever ready to transition to `pending` status from `waiting_for_resource`. See https://gitlab.com/gitlab-org/gitlab/-/issues/202186 for more information.",
        "label": "How-it-is-done",
        "id": "7590"
    },
    {
        "raw_code": "def self.reference_class\n        reference_type.to_s.classify.constantize\n      end",
        "comment": "Returns a model class to use as a reference. By default, the method does not take namespaces into account, thus parser classes can customize the reference class to use a model name with a namespace",
        "label": "How-it-is-done",
        "id": "3421"
    },
    {
        "raw_code": "def exec_update(sql, name = nil, binds = [])\n        affected_rows(internal_execute(sql, name, binds))\n      end",
        "comment": "Executes update +sql+ statement in the context of this connection using +binds+ as the bind substitutes. +name+ is logged along with the executed +sql+ statement.",
        "label": "How-it-is-done",
        "id": "13062"
    },
    {
        "raw_code": "def create_dhcp_server_if_necessary(interface, config)\n          existing_dhcp_server = find_matching_dhcp_server(interface)\n          if existing_dhcp_server\n            if dhcp_server_matches_config?(existing_dhcp_server, config)\n              @logger.debug(\"DHCP server already properly configured\")\n              return\n            elsif existing_dhcp_server == DEFAULT_DHCP_SERVER_FROM_VBOX_INSTALL\n              @env[:ui].info I18n.t(\"vagrant.actions.vm.network.cleanup_vbox_default_dhcp\")\n              @env[:machine].provider.driver.remove_dhcp_server(existing_dhcp_server[:network_name])\n            else\n              # We have an invalid DHCP server that we're not able to\n              # automatically clean up, so we need to give up and tell the user\n              # to sort out their own vbox dhcpservers and hostonlyifs\n              raise Vagrant::Errors::NetworkDHCPAlreadyAttached\n            end",
        "comment": " When a host-only network of type: :dhcp is configured, this handles the potential creation of a vbox dhcpserver to manage it.  @param [Hash<String>] interface hash as returned from read_host_only_interfaces @param [Hash<String>] config hash as returned from hostonly_config",
        "label": "How-it-is-done",
        "id": "9648"
    },
    {
        "raw_code": "def token_from_vagrant_login(env)\n        client = VagrantPlugins::LoginCommand::Client.new(env)\n        client.token\n      end",
        "comment": "Attempt to load the token from disk using the vagrant-login plugin. If the constant is not defined, that means the user is operating in some bespoke and unsupported Ruby environment.  @param [Vagrant::Environment] env  @return [String, nil] the token, or nil if it does not exist",
        "label": "How-it-is-done",
        "id": "9370"
    },
    {
        "raw_code": "def nav_link(options = {}, &block)\n    klass = active_nav_link?(options) ? 'active' : ''\n\n    # Add our custom class into the html_options, which may or may not exist\n    # and which may or may not already have a :class key\n    o = options.delete(:html_options) || {}\n    o[:class] = [*o[:class], klass].join(' ')\n    o[:class].strip!\n\n    if block\n      content_tag(:li, capture(&block), o)\n    else\n      content_tag(:li, nil, o)\n    end",
        "comment": "Navigation link helper  Returns an `li` element with an 'active' class if the supplied controller(s) and/or action(s) are currently active. The content of the element is the value passed to the block.  options - The options hash used to determine if the element is \"active\" (default: {}) :controller   - One or more controller names to check, use path notation when namespaced (optional). :action       - One or more action names to check (optional). :path         - A shorthand path, such as 'dashboard#index', to check (optional). :html_options - Extra options to be passed to the list element (optional). block   - An optional block that will become the contents of the returned `li` element.  When both :controller and :action are specified, BOTH must match in order to be marked as active. When only one is given, either can match.  Examples  # Assuming we're on TreeController#show  # Controller matches, but action doesn't nav_link(controller: [:tree, :refs], action: :edit) { \"Hello\" } # => '<li>Hello</li>'  # Controller matches nav_link(controller: [:tree, :refs]) { \"Hello\" } # => '<li class=\"active\">Hello</li>'  # Several paths nav_link(path: ['tree#show', 'profile#show']) { \"Hello\" } # => '<li class=\"active\">Hello</li>'  # Shorthand path nav_link(path: 'tree#show') { \"Hello\" } # => '<li class=\"active\">Hello</li>'  # Supplying custom options for the list element nav_link(controller: :tree, html_options: {class: 'home'}) { \"Hello\" } # => '<li class=\"home active\">Hello</li>'  # For namespaced controllers like Admin::AppearancesController#show  # Controller and namespace matches nav_link(controller: 'admin/appearances') { \"Hello\" } # => '<li class=\"active\">Hello</li>'  # Controller and namespace matches but action doesn't nav_link(controller: 'admin/appearances', action: :edit) { \"Hello\" } # => '<li>Hello</li>'  # Shorthand path with namespace nav_link(path: 'admin/appearances#show') { \"Hello\"} # => '<li class=\"active\">Hello</li>'  # When `TreeController#index` is requested # => '<li>Hello</li>'  # Paths, controller and actions can be used at the same time nav_link(path: 'tree#show', controller: 'admin/appearances') { \"Hello\" }  nav_link(path: 'foo#bar', controller: 'tree') { \"Hello\" } nav_link(path: 'foo#bar', controller: 'tree', action: 'show') { \"Hello\" } nav_link(path: 'foo#bar', action: 'show') { \"Hello\" }  Returns a list item element String",
        "label": "How-it-is-done",
        "id": "7734"
    },
    {
        "raw_code": "def parse_comment_tomdoc(container, tk, comment)\n    return unless signature = RDoc::TomDoc.signature(comment)\n    column  = tk[:char_no]\n    line_no = tk[:line_no]\n\n    name, = signature.split %r%[ \\(]%, 2\n\n    meth = RDoc::GhostMethod.new get_tkread, name\n    record_location meth\n    meth.line      = line_no\n\n    meth.start_collecting_tokens\n    indent = RDoc::Parser::RipperStateLex::Token.new(1, 1, :on_sp, ' ' * column)\n    position_comment = RDoc::Parser::RipperStateLex::Token.new(line_no, 1, :on_comment)\n    position_comment[:text] = \"# File #{@top_level.relative_name}, line #{line_no}\"\n    newline = RDoc::Parser::RipperStateLex::Token.new(0, 0, :on_nl, \"\\n\")\n    meth.add_tokens [position_comment, newline, indent]\n\n    meth.call_seq = signature\n\n    comment.normalize\n\n    return unless meth.name\n\n    container.add_method meth\n\n    meth.comment = comment\n\n    @stats.add_method meth\n  end",
        "comment": " Creates an RDoc::Method on +container+ from +comment+ if there is a Signature section in the comment",
        "label": "How-it-is-done",
        "id": "16092"
    },
    {
        "raw_code": "def logs_project\n      strong_memoize(:logs_project) do\n        cluster.all_projects.first\n      end",
        "comment": "currently log explorer is only available in the scope of the project for group and instance level cluster selected project does not affects fetching logs from gitlab managed apps namespace, therefore any project available to user will be sufficient.",
        "label": "How-it-is-done",
        "id": "5423"
    },
    {
        "raw_code": "def initialize(*arguments)\n      @arguments  = arguments\n      @job_id     = SecureRandom.uuid\n      @queue_name = self.class.queue_name\n      @scheduled_at = nil\n      @priority   = self.class.priority\n      @executions = 0\n      @exception_executions = {}\n      @timezone   = Time.zone&.name\n    end",
        "comment": "Creates a new job instance. Takes the arguments that will be passed to the perform method.",
        "label": "How-it-is-done",
        "id": "12114"
    },
    {
        "raw_code": "def initialize(namespace, name, *args, &block)\n      super\n\n      if is_exception?\n        self.superclass ||= \"::Exception\" unless P(namespace, name) == P(:Exception)\n      else\n        case P(namespace, name).path\n        when \"BasicObject\"\n          nil\n        when \"Object\"\n          self.superclass ||= \"::BasicObject\"\n        else\n          self.superclass ||= \"::Object\"\n        end",
        "comment": "Creates a new class object in +namespace+ with +name+  @see Base.new",
        "label": "How-it-is-done",
        "id": "586"
    },
    {
        "raw_code": "def self.user_or_deploy_token_from_jwt(raw_jwt)\n      token_payload = self.new(raw_jwt).execute\n\n      if token_payload['user_id']\n        User.find(token_payload['user_id'])\n      elsif token_payload['deploy_token']\n        DeployToken.active.find_by_token(token_payload['deploy_token'])\n      end",
        "comment": "TODO: Rename to make it obvious how it's used in Gitlab::Auth::RequestAuthenticator which is to return an <object>.<id> that is used as a rack-attack discriminator that way it cannot be confused with `.user_or_token_from_jwt` https://gitlab.com/gitlab-org/gitlab/-/issues/454518",
        "label": "How-it-is-done",
        "id": "6009"
    },
    {
        "raw_code": "def process(documents, ids_only: false)\n        type = self.class.reference_type\n        reference_options = self.class.reference_options\n\n        nodes = documents.flat_map do |document|\n          Querying.css(document, \"a[data-reference-type='#{type}'].gfm\", reference_options).to_a\n        end",
        "comment": "Processes the list of HTML documents and returns an Array containing all the references.",
        "label": "How-it-is-done",
        "id": "3432"
    },
    {
        "raw_code": "def process_token(tk)\n        # p tk.class, tk.text, @state, @level, @current_block, \"<br/>\"\n        case @state\n        when :first_statement\n          return if process_initial_comment(tk)\n          return if @statement.empty? && [TkSPACE, TkNL, TkCOMMENT].include?(tk.class)\n          @comments_last_line = nil\n          if @statement.empty? && tk.class == TkALIAS\n            @state = :alias_statement\n            @alias_values = []\n            push_token(tk)\n            return\n          end",
        "comment": "Processes a single token  @param [RubyToken::Token] tk the token to process",
        "label": "How-it-is-done",
        "id": "334"
    },
    {
        "raw_code": "def say(type, message, opts={})\n        defaults = { new_line: true, prefix: true }\n        opts     = defaults.merge(@opts).merge(opts)\n\n        # Don't output if we're hiding details\n        return if type == :detail && opts[:hide_detail]\n\n        # Determine whether we're expecting to output our\n        # own new line or not.\n        printer = opts[:new_line] ? :puts : :print\n\n        # Determine the proper IO channel to send this message\n        # to based on the type of the message\n        channel = type == :error || opts[:channel] == :error ? @stderr : @stdout\n\n        # Output! We wrap this in a lock so that it safely outputs only\n        # one line at a time. We wrap this in a thread because as of Ruby 2.0\n        # we can't acquire locks in a trap context (ctrl-c), so we have to\n        # do this.\n        Thread.new do\n          @lock.synchronize do\n            safe_puts(format_message(type, message, **opts),\n                      io: channel, printer: printer)\n          end",
        "comment": "This method handles actually outputting a message of a given type to the console.",
        "label": "How-it-is-done",
        "id": "8807"
    },
    {
        "raw_code": "def link(name, text, code = true, rdoc_ref: false)\n    if !(name.end_with?('+@', '-@')) and name =~ /(.*[^#:])?@/\n      name = $1\n      label = $'\n    end",
        "comment": " Creates an HTML link to +name+ with the given +text+.",
        "label": "How-it-is-done",
        "id": "16251"
    },
    {
        "raw_code": "def designs\n      @designs ||= files.map do |file|\n        collection.find_or_create_design!(filename: file.original_filename)\n      end",
        "comment": "Returns `Design` instances that correspond with `files`. New `Design`s will be created where a file name does not match an existing `Design`",
        "label": "How-it-is-done",
        "id": "6077"
    },
    {
        "raw_code": "def preload_stages_warnings\n          @pipeline.stages.each { |stage| stage.number_of_warnings }\n        end",
        "comment": "This preloads the number of warnings for every stage, ensuring that Ci::Stage#has_warnings? doesn't execute any additional queries.",
        "label": "How-it-is-done",
        "id": "2509"
    },
    {
        "raw_code": "def self.for_model(model)\n          cfg = model.connection_db_config.configuration_hash.deep_symbolize_keys\n          lb_cfg = cfg[:load_balancing] || {}\n          config = new(model)\n\n          if (diff = lb_cfg[:max_replication_difference])\n            config.max_replication_difference = diff\n          end",
        "comment": "Creates a configuration object for the given ActiveRecord model.",
        "label": "How-it-is-done",
        "id": "3081"
    },
    {
        "raw_code": "def initialize(length, exclusive)\n    @attrs = Array.new(length, 0)\n    @exclusive = exclusive\n  end",
        "comment": " Creates a new AttrSpan for +length+ characters",
        "label": "How-it-is-done",
        "id": "16299"
    },
    {
        "raw_code": "def initialize(filename, contents = nil)\n      self.filename = filename\n      self.name = File.basename(filename).gsub(/\\.[^.]+$/, '')\n      self.attributes = SymbolHash.new(false)\n      @original_contents = contents\n      @parsed = false\n      @locale = nil\n      ensure_parsed\n    end",
        "comment": "Creates a new extra file object. @param [String] filename the location on disk of the file @param [String] contents the file contents. If not set, the contents will be read from disk using the +filename+.",
        "label": "How-it-is-done",
        "id": "616"
    },
    {
        "raw_code": "def sorted_processes\n      @sorted_processes ||= begin\n        return processes unless processes.all? { |p| p[\"hostname\"] }\n\n        processes.to_a.sort_by do |process|\n          # Kudos to `shurikk` on StackOverflow\n          # https://stackoverflow.com/a/15170063/575547\n          process[\"hostname\"].split(/(\\d+)/).map { |a| /\\d+/.match?(a) ? a.to_i : a }\n        end",
        "comment": "Sorts processes by hostname following the natural sort order",
        "label": "How-it-is-done",
        "id": "5215"
    },
    {
        "raw_code": "def merge_script_names(previous_script_name, new_script_name)\n        return new_script_name unless previous_script_name\n        new_script_name = new_script_name.chomp(\"/\")\n\n        resolved_parts = new_script_name.count(\"/\")\n        previous_parts = previous_script_name.count(\"/\")\n        context_parts = previous_parts - resolved_parts + 1\n\n        (previous_script_name.split(\"/\").slice(0, context_parts).join(\"/\")) + new_script_name\n      end",
        "comment": "Keeps the part of the script name provided by the global context via [ENV](\"SCRIPT_NAME\"), which `mount` doesn't know about since it depends on the specific request, but use our script name resolver for the mount point dependent part.",
        "label": "How-it-is-done",
        "id": "11592"
    },
    {
        "raw_code": "def link_to_unless(condition, name, options = {}, html_options = {}, &block)\n        link_to_if !condition, name, options, html_options, &block\n      end",
        "comment": "Creates a link tag of the given +name+ using a URL created by the set of +options+ unless +condition+ is true, in which case only the name is returned. To specialize the default behavior (i.e., show a login link rather than just the plaintext link text), you can pass a block that accepts the name or the full argument list for +link_to_unless+.  ==== Examples <%= link_to_unless(@current_user.nil?, \"Reply\", { action: \"reply\" }) %> # If the user is logged in... # => <a href=\"/controller/reply/\">Reply</a>  <%= link_to_unless(@current_user.nil?, \"Reply\", { action: \"reply\" }) do |name| link_to(name, { controller: \"accounts\", action: \"signup\" }) end %> # If the user is logged in... # => <a href=\"/controller/reply/\">Reply</a> # If not... # => <a href=\"/accounts/signup\">Reply</a>",
        "label": "How-it-is-done",
        "id": "11992"
    },
    {
        "raw_code": "def has_missing_boards?\n    !multiple_boards_available? && current_board_parent.boards.size > 1\n  end",
        "comment": "Boards are hidden when extra boards were created but the license does not allow multiple boards",
        "label": "How-it-is-done",
        "id": "7750"
    },
    {
        "raw_code": "def represent(merge_request, opts = {}, entity = nil)\n    entity ||= identified_entity(opts)\n\n    super(merge_request, opts, entity)\n  end",
        "comment": "This overrided method takes care of which entity should be used to serialize the `merge_request` based on `serializer` key in `opts` param. Hence, `entity` doesn't need to be declared on the class scope.",
        "label": "How-it-is-done",
        "id": "6228"
    },
    {
        "raw_code": "def utf8_enforcer_tag\n        options = {\n          type: \"hidden\",\n          name: \"utf8\",\n          value: \"&#x2713;\".html_safe\n        }\n\n        options[:autocomplete] = \"off\" unless ActionView::Base.remove_hidden_field_autocomplete\n\n        tag(:input, options)\n      end",
        "comment": "Creates the hidden UTF-8 enforcer tag. Override this method in a helper to customize the tag.",
        "label": "How-it-is-done",
        "id": "11946"
    },
    {
        "raw_code": "def handle_directive(prefix, directive, param, code_object = nil,\n                       encoding = nil, line = nil)\n    blankline = \"#{prefix.strip}\\n\"\n    directive = directive.downcase\n\n    case directive\n    when 'arg', 'args' then\n      return \"#{prefix}:#{directive}: #{param}\\n\" unless code_object && code_object.kind_of?(RDoc::AnyMethod)\n\n      code_object.params = param\n\n      blankline\n    when 'category' then\n      if RDoc::Context === code_object then\n        section = code_object.add_section param\n        code_object.temporary_section = section\n      elsif RDoc::AnyMethod === code_object then\n        code_object.section_title = param\n      end",
        "comment": " Performs the actions described by +directive+ and its parameter +param+.  +code_object+ is used for directives that operate on a class or module. +prefix+ is used to ensure the replacement for handled directives is correct.  +encoding+ is used for the <tt>include</tt> directive.  For a list of directives in RDoc see RDoc::Markup. -- When 1.8.7 support is ditched prefix can be defaulted to ''",
        "label": "How-it-is-done",
        "id": "16369"
    },
    {
        "raw_code": "def initialize(formatter)\n        @formatter = formatter\n      end",
        "comment": "Creates a new formatter wrapper instance.  @param [Log4r::Formatter]",
        "label": "How-it-is-done",
        "id": "9237"
    },
    {
        "raw_code": "def perform_now(...)\n        job_or_instantiate(...).perform_now\n      end",
        "comment": "Performs the job immediately.  MyJob.perform_now(\"mike\") ",
        "label": "How-it-is-done",
        "id": "12125"
    },
    {
        "raw_code": "def run_in_parallel?\n        enabled?(ENV[\"QA_RUN_IN_PARALLEL\"], default: false)\n      end",
        "comment": "Execute tests in multiple parallel processes  @return [Boolean]",
        "label": "How-it-is-done",
        "id": "4473"
    },
    {
        "raw_code": "def options(path, **args)\n        process(:options, path, **args)\n      end",
        "comment": "Performs an OPTIONS request with the given parameters. See ActionDispatch::Integration::Session#process for more details.",
        "label": "How-it-is-done",
        "id": "11619"
    },
    {
        "raw_code": "def on_weekday?\n      !WEEKEND_DAYS.include?(wday)\n    end",
        "comment": "Returns true if the date/time does not fall on a Saturday or Sunday.",
        "label": "How-it-is-done",
        "id": "14138"
    },
    {
        "raw_code": "def compile(mod)\n        begin\n          mod.module_eval(compiled_source, identifier, offset)\n        rescue SyntaxError\n          # Account for when code in the template is not syntactically valid; e.g. if we're using\n          # ERB and the user writes <%= foo( %>, attempting to call a helper `foo` and interpolate\n          # the result into the template, but missing an end parenthesis.\n          raise SyntaxErrorInTemplate.new(self, encode!)\n        end",
        "comment": "Among other things, this method is responsible for properly setting the encoding of the compiled template.  If the template engine handles encodings, we send the encoded String to the engine without further processing. This allows the template engine to support additional mechanisms for specifying the encoding. For instance, ERB supports <%# encoding: %>  Otherwise, after we figure out the correct encoding, we then encode the source into <tt>Encoding.default_internal</tt>. In general, this means that templates will be UTF-8 inside of Rails, regardless of the original source encoding.",
        "label": "How-it-is-done",
        "id": "11762"
    },
    {
        "raw_code": "def base_reference_pattern(only_long: false)\n          return REFERENCE_PATTERN_LONG_REGEXP if only_long\n\n          REFERENCE_PATTERN_REGEXP\n        end",
        "comment": "Pattern used to extract links from comments Override this method on services that uses different patterns This pattern does not support cross-project references The other code assumes that this pattern is a superset of all overridden patterns. See ReferenceRegexes.external_pattern",
        "label": "How-it-is-done",
        "id": "7451"
    },
    {
        "raw_code": "def initialize(namespace, name, scope = :instance, &block)\n      @module_function = false\n      @scope = nil\n\n      # handle module function\n      if scope == :module\n        other = self.class.new(namespace, name, &block)\n        other.visibility = :private\n        scope = :class\n        @module_function = true\n      end",
        "comment": "Creates a new method object in +namespace+ with +name+ and an instance or class +scope+  If scope is +:module+, this object is instantiated as a public method in +:class+ scope, but also creates a new (empty) method as a private +:instance+ method on the same class or module.  @param [NamespaceObject] namespace the namespace @param [String, Symbol] name the method name @param [Symbol] scope +:instance+, +:class+, or +:module+",
        "label": "How-it-is-done",
        "id": "548"
    },
    {
        "raw_code": "def with_defaults(defaults)\n      self.class.new controller, @env, @defaults.merge(defaults)\n    end",
        "comment": "Creates a new renderer using the same controller, but with the given defaults merged on top of the previous defaults.",
        "label": "How-it-is-done",
        "id": "11236"
    },
    {
        "raw_code": "def connect(path = ActionCable.server.config.mount_path, **request_params)\n          path ||= DEFAULT_PATH\n\n          connection = self.class.connection_class.allocate\n          connection.singleton_class.include(TestConnection)\n          connection.send(:initialize, build_test_request(path, **request_params))\n          connection.connect if connection.respond_to?(:connect)\n\n          # Only set instance variable if connected successfully\n          @connection = connection\n        end",
        "comment": "Performs connection attempt to exert #connect on the connection under test.  Accepts request path as the first argument and the following request options:  *   params \u2013\u00a0URL parameters (Hash) *   headers \u2013 request headers (Hash) *   session \u2013\u00a0session data (Hash) *   env \u2013\u00a0additional Rack env configuration (Hash)",
        "label": "How-it-is-done",
        "id": "11079"
    },
    {
        "raw_code": "def commit_files(\n        user, branch_name:, message:, actions:,\n        author_email: nil, author_name: nil,\n        start_branch_name: nil, start_sha: nil, start_repository: nil,\n        force: false, sign: true, target_sha: nil\n      )\n        wrapped_gitaly_errors do\n          gitaly_operation_client.user_commit_files(user, branch_name,\n            message, actions, author_email, author_name, start_branch_name,\n            start_repository, force, start_sha, sign, target_sha)\n        end",
        "comment": "Creates a commit  @param [User] user The committer of the commit. @param [String] branch_name: The name of the branch to be created/updated. @param [String] message: The commit message. @param [Array<Hash>] actions: An array of files to be added/updated/removed. @option actions: [Symbol] :action One of :create, :create_dir, :update, :move, :delete, :chmod @option actions: [String] :file_path The path of the file or directory being added/updated/removed. @option actions: [String] :previous_path The path of the file being moved. Only used for the :move action. @option actions: [String,IO] :content The file content for :create or :update @option actions: [String] :encoding One of text, base64 @option actions: [Boolean] :execute_filemode True sets the executable filemode on the file. @option actions: [Boolean] :infer_content True uses the existing file contents instead of using content on move. @param [String] author_email: The authors email, if unspecified the committers email is used. @param [String] author_name: The authors name, if unspecified the committers name is used. @param [String] start_branch_name: The name of the branch to be used as the parent of the commit. Only used if start_sha: is unspecified. @param [String] start_sha: The sha to be used as the parent of the commit. @param [Gitlab::Git::Repository] start_repository: The repository that contains the start branch or sha. Defaults to use this repository. @param [Boolean] force: Force update the branch. @param [String] target_sha: The latest sha of the target branch (optional). Used to prevent races in updates between different clients. @return [Gitlab::Git::OperationService::BranchUpdate]  rubocop:disable Metrics/ParameterLists",
        "label": "How-it-is-done",
        "id": "2655"
    },
    {
        "raw_code": "def foo; end\n        RUBY\n      end",
        "comment": "Documentation",
        "label": "How-it-is-done",
        "id": "10889"
    },
    {
        "raw_code": "def extract(opts = {})\n      params = SafeZip::ExtractParams.new(**opts)\n\n      extract_with_ruby_zip(params)\n    end",
        "comment": "extract given files or directories from the archive into the destination path  @param [Hash] opts the options for extraction. @option opts [Array<String] :files list of files to be extracted @option opts [Array<String] :directories list of directories to be extracted @option opts [String] :to destination path  @raise [PermissionDeniedError] @raise [SymlinkSourceDoesNotExistError] @raise [UnsupportedEntryError] @raise [EntrySizeError] @raise [AlreadyExistsError] @raise [NoMatchingError] @raise [ExtractError]",
        "label": "How-it-is-done",
        "id": "3525"
    },
    {
        "raw_code": "def underscore(camel_cased_word)\n      return camel_cased_word.to_s.dup unless /[A-Z-]|::/.match?(camel_cased_word)\n      word = camel_cased_word.to_s.gsub(\"::\", \"/\")\n      word.gsub!(inflections.acronyms_underscore_regex) { \"#{$1 && '_' }#{$2.downcase}\" }\n      word.gsub!(/(?<=[A-Z])(?=[A-Z][a-z])|(?<=[a-z\\d])(?=[A-Z])/, \"_\")\n      word.tr!(\"-\", \"_\")\n      word.downcase!\n      word\n    end",
        "comment": "Makes an underscored, lowercase form from the expression in the string.  Changes '::' to '/' to convert namespaces to paths.  underscore('ActiveModel')         # => \"active_model\" underscore('ActiveModel::Errors') # => \"active_model/errors\"  As a rule of thumb you can think of +underscore+ as the inverse of #camelize, though there are cases where that does not hold:  camelize(underscore('SSLError'))  # => \"SslError\"",
        "label": "How-it-is-done",
        "id": "14463"
    },
    {
        "raw_code": "def by_generated_ref_commit(items)\n    return items unless params[:project_id].present? && params[:commit_sha].present?\n\n    # Only perform generated ref commit lookup as fallback when no items found\n    return items unless items.empty?\n\n    ::MergeRequests::GeneratedRefCommit\n      .merge_request_for_sha(\n        params[:project_id],\n        params[:commit_sha]\n      )\n  end",
        "comment": "This method handles commit lookup for gitlab generated refs used to run pipelines and merge code and associated with merge requests. When merge requests are processed through merge trains, new commit SHAs are generated that are not stored in the original merge request diff. This method provides a way to find the merge request associated with GitLab-generated references for MR pipelines. These commits are merged/rebased into the target branch via MergeRequests::MergeStrategies::FromSourceBranch and MergeRequests::MergeStrategies::FromTrainRef. Lookup of Refs generated via `MergeRequests::MergeToRefService` is not currently supported See: https://gitlab.com/gitlab-org/gitlab/-/issues/421025",
        "label": "How-it-is-done",
        "id": "7876"
    },
    {
        "raw_code": "def select_option_divider(text)\n        { name: \"-- #{text} --\", value: nil, disabled: '' }\n      end",
        "comment": "Creates divider to be passed to a select or multiselect as a menu item. Use with #format_disabled_options_as_dividers for best formatting.",
        "label": "How-it-is-done",
        "id": "5334"
    },
    {
        "raw_code": "def self.ok(ok_value)\n        new(ok_value: ok_value)\n      end",
        "comment": "The .ok and .err factory class methods are the only way to create a Result  \"self.ok\" corresponds to Ok(T) in Rust: https://doc.rust-lang.org/std/result/enum.Result.html#variant.Ok  @param [Object, #new] ok_value @return [Result] noinspection MissingYardParamTag -- RubyMine does not recognize \"duck type\" Types (https://rubydoc.info/gems/yard/file/docs/Tags.md#duck-types). This has been reported to JetBrains - issue link pending",
        "label": "How-it-is-done",
        "id": "2373"
    },
    {
        "raw_code": "def closed?\n      @internal_transaction.nil? || @internal_transaction.closed?\n    end",
        "comment": "Returns true if the transaction doesn't exist or is finalized.",
        "label": "How-it-is-done",
        "id": "12714"
    },
    {
        "raw_code": "def note_for ref\n    @note_order << ref\n\n    label = @note_order.length\n\n    \"{*#{label}}[rdoc-label:foottext-#{label}:footmark-#{label}]\"\n  end",
        "comment": " Creates a new link for the footnote `reference` and adds the reference to the note order list for proper display at the end of the document.",
        "label": "How-it-is-done",
        "id": "15582"
    },
    {
        "raw_code": "def mutation_to_apollo_uploads_param(mutation, files: [])\n    operations = { 'query' => mutation.query, 'variables' => mutation.variables }\n    map = {}\n    extracted_files = {}\n\n    files.each_with_index do |file_path, idx|\n      apollo_idx = (idx + 1).to_s\n      parent_dig_path = file_path[0..-2]\n      file_key = file_path[-1]\n\n      parent = operations['variables']\n      parent = parent.dig(*parent_dig_path) unless parent_dig_path.empty?\n\n      extracted_files[apollo_idx] = parent[file_key]\n      parent[file_key] = nil\n\n      map[apollo_idx] = [\"variables.#{file_path.join('.')}\"]\n    end",
        "comment": "this implements GraphQL multipart request v2 https://github.com/jaydenseric/graphql-multipart-request-spec/tree/v2.0.0-alpha.2 this is simplified and do not support file deduplication",
        "label": "How-it-is-done",
        "id": "8401"
    },
    {
        "raw_code": "def not_found\n          self.status = 404\n          return unless body.empty?\n          self.body = \"Not found: #{request.path}\"\n          headers['Content-Type'] = 'text/plain'\n          headers['X-Cascade'] = 'pass'\n          headers['Cache-Control'] = 'nocache'\n        end",
        "comment": "Sets the body and headers for a 404 response. Does not modify the body if already set.  @return [void]",
        "label": "How-it-is-done",
        "id": "704"
    },
    {
        "raw_code": "def execute\n      return false unless spam_params.captcha_response\n\n      @request = RequestStruct.new(spam_params.ip_address)\n\n      Gitlab::Recaptcha.load_configurations!\n\n      # NOTE: We could pass the model and let the recaptcha gem automatically add errors to it,\n      # but we do not, for two reasons:\n      #\n      # 1. We want control over when the errors are added\n      # 2. We want control over the wording and i18n of the message\n      # 3. We want a consistent interface and behavior when adding support for other captcha\n      #    libraries which may not support automatically adding errors to the model.\n      verify_recaptcha(response: spam_params.captcha_response)\n    end",
        "comment": " Performs verification of a captcha response.  NOTE: Currently only supports reCAPTCHA, and is not yet used in all places of the app in which captchas are verified, but these can be addressed in future MRs.  See: https://gitlab.com/gitlab-org/gitlab/-/issues/273480",
        "label": "How-it-is-done",
        "id": "5696"
    },
    {
        "raw_code": "def self.parse(string)\n      Decoder.new(string).decode!\n    end",
        "comment": "Creates a new PackageUrl from a string. @param [String] string The package URL string. @raise [InvalidPackageUrl] If the string is not a valid package URL. @return [PackageUrl]",
        "label": "How-it-is-done",
        "id": "3745"
    },
    {
        "raw_code": "def link_forks_lfs_objects\n      return unless @push.branch_updated?\n\n      merge_requests_for_forks.find_each do |mr|\n        LinkLfsObjectsService\n          .new(project: mr.target_project)\n          .execute(mr, oldrev: @push.oldrev, newrev: @push.newrev)\n      end",
        "comment": "rubocop: enable CodeReuse/ActiveRecord Link LFS objects that exists in forks but does not exists in merge requests target project",
        "label": "How-it-is-done",
        "id": "5549"
    },
    {
        "raw_code": "def with_connection(conn)\n      return yield(conn) if conn\n\n      Sidekiq.redis { |redis_conn| yield(redis_conn) }\n    end",
        "comment": "Yield block with an existing connection or creates another one",
        "label": "How-it-is-done",
        "id": "5040"
    },
    {
        "raw_code": "def self.handle_configure_disk(machine, disk, controller_name)\n          storage_controllers = machine.provider.driver.read_storage_controllers\n          controller = storage_controllers.get_controller(controller_name)\n          all_disks = controller.attachments\n\n          disk_metadata = {}\n\n          # Grab the existing configured disk attached to guest, if it exists\n          current_disk = get_current_disk(machine, disk, all_disks)\n\n          if !current_disk\n            # Look for an existing disk that's not been attached but exists\n            # inside VirtualBox\n            #\n            # NOTE: This assumes that if that disk exists and was created by\n            # Vagrant, it exists in the same location as the primary disk file.\n            # Otherwise Vagrant has no good way to determining if the disk was\n            # associated with the guest, since disk names are not unique\n            # globally to VirtualBox.\n            primary = storage_controllers.get_primary_attachment\n            existing_disk = machine.provider.driver.list_hdds.detect do |d|\n              File.dirname(d[\"Location\"]) == File.dirname(primary[:location]) &&\n                d[\"Disk Name\"] == disk.name\n            end",
        "comment": "Handles all disk configs of type `:disk`  @param [Vagrant::Machine] machine - the current machine @param [Config::Disk] disk - the current disk to configure @param [String] controller_name - the name of the storage controller to use @return [Hash] - disk_metadata",
        "label": "How-it-is-done",
        "id": "9626"
    },
    {
        "raw_code": "def select_date(date = Date.current, options = {}, html_options = {})\n        DateTimeSelector.new(date, options, html_options).select_date\n      end",
        "comment": "Returns a set of HTML select-tags (one for year, month, and day) pre-selected with the +date+. It's possible to explicitly set the order of the tags using the <tt>:order</tt> option with an array of symbols <tt>:year</tt>, <tt>:month</tt> and <tt>:day</tt> in the desired order. If the array passed to the <tt>:order</tt> option does not contain all the three symbols, all tags will be hidden.  If anything is passed in the html_options hash it will be applied to every select tag in the set.  my_date = Time.now + 6.days  # Generates a date select that defaults to the date in my_date (six days after today). select_date(my_date)  # Generates a date select that defaults to today (no specified date). select_date()  # Generates a date select that defaults to the date in my_date (six days after today) # with the fields ordered year, month, day rather than month, day, year. select_date(my_date, order: [:year, :month, :day])  # Generates a date select that discards the type of the field and defaults to the date in # my_date (six days after today). select_date(my_date, discard_type: true)  # Generates a date select that defaults to the date in my_date, # which has fields separated by '/'. select_date(my_date, date_separator: '/')  # Generates a date select that defaults to the datetime in my_date (six days after today) # prefixed with 'payday' rather than 'date'. select_date(my_date, prefix: 'payday')  # Generates a date select with a custom prompt. Use <tt>prompt: true</tt> for generic prompts. select_date(my_date, prompt: { day: 'Choose day', month: 'Choose month', year: 'Choose year' }) select_date(my_date, prompt: { hour: true }) # generic prompt for hours select_date(my_date, prompt: true) # generic prompts for all",
        "label": "How-it-is-done",
        "id": "11831"
    },
    {
        "raw_code": "def dynamic_segment\n    raise(NotImplementedError)\n  end",
        "comment": "Designed to be overridden by child uploaders that have a dynamic path segment -- that is, a path that changes based on mutable attributes of its associated model  For example, `FileUploader` builds the storage path based on the associated project model's `path_with_namespace` value, which can change when the project or its containing namespace is moved or renamed.  When implementing this method, raise `ObjectNotReadyError` if the model does not yet exist, as it will be tested in `#protect_from_path_traversal!`",
        "label": "How-it-is-done",
        "id": "8060"
    },
    {
        "raw_code": "def process_alert\n      alert.persisted? ? process_existing_alert : process_new_alert\n    end",
        "comment": "Updates or creates alert from payload for project including system notes",
        "label": "How-it-is-done",
        "id": "5712"
    },
    {
        "raw_code": "def truncate(table_name, name = nil)\n        execute(build_truncate_statement(table_name), name)\n      end",
        "comment": "Executes the truncate statement.",
        "label": "How-it-is-done",
        "id": "13066"
    },
    {
        "raw_code": "def async_maximum(column_name)\n      async.maximum(column_name)\n    end",
        "comment": "Same as #maximum, but performs the query asynchronously and returns an ActiveRecord::Promise.",
        "label": "How-it-is-done",
        "id": "13352"
    },
    {
        "raw_code": "def create_disk(disk_file, disk_size, disk_format=\"VDI\", **opts)\n          execute(\"createmedium\", '--filename', disk_file, '--sizebyte', disk_size.to_i.to_s, '--format', disk_format)\n        end",
        "comment": "Creates a disk. Default format is VDI unless overridden  @param [String] disk_file @param [Integer] disk_size - size in bytes @param [String] disk_format - format of disk, defaults to \"VDI\" @param [Hash]  opts -  additional options",
        "label": "How-it-is-done",
        "id": "9609"
    },
    {
        "raw_code": "def impossible_visibility_level?\n    return unless params[:visibility_level].present?\n\n    public_visibility_levels = Gitlab::VisibilityLevel.levels_for_user(current_user)\n\n    public_visibility_levels.exclude?(params[:visibility_level].to_i)\n  end",
        "comment": "This is an optimization - surprisingly PostgreSQL does not optimize for this.  If the default visibility level and desired visibility level filter cancels each other out, don't use the SQL clause for visibility level in `Project.public_or_visible_to_user`. In fact, this then becomes equivalent to just authorized projects for the user.  E.g. (EXISTS(<authorized_projects>) OR projects.visibility_level IN (10,20)) AND \"projects\".\"visibility_level\" = 0  is essentially EXISTS(<authorized_projects>) AND \"projects\".\"visibility_level\" = 0  See https://gitlab.com/gitlab-org/gitlab/issues/37007",
        "label": "How-it-is-done",
        "id": "7922"
    },
    {
        "raw_code": "def collecting_queries_for_explain # :nodoc:\n      ExplainRegistry.start\n      yield\n      ExplainRegistry.queries\n    ensure\n      ExplainRegistry.reset\n    end",
        "comment": "Executes the block with the collect flag enabled. Queries are collected asynchronously by the subscriber and returned.",
        "label": "How-it-is-done",
        "id": "12457"
    },
    {
        "raw_code": "def put(path, **args)\n        process(:put, path, **args)\n      end",
        "comment": "Performs a PUT request with the given parameters. See ActionDispatch::Integration::Session#process for more details.",
        "label": "How-it-is-done",
        "id": "11616"
    },
    {
        "raw_code": "def parent_from_ref(ref)\n      return context[:project] || context[:group] unless ref\n      return context[:project] if context[:project]&.full_path == ref\n\n      if reference_cache.cache_loaded?\n        # optimization to reuse the parent_per_reference query information\n        reference_cache.parent_per_reference[ref || reference_cache.current_parent_path]\n      else\n        Project.find_by_full_path(ref)\n      end",
        "comment": "Given a cross-project reference string, get the Project record  Defaults to value of `context[:project]`, or `context[:group]` if: * No reference is given OR * Reference given doesn't exist  ref - String reference.  Returns a Project, or nil if the reference can't be found",
        "label": "How-it-is-done",
        "id": "3414"
    },
    {
        "raw_code": "def add_index(table_name, column_name, **options)\n        create_index = build_create_index_definition(table_name, column_name, **options)\n        execute schema_creation.accept(create_index)\n      end",
        "comment": "Adds a new index to the table. +column_name+ can be a single Symbol, or an Array of Symbols.  The index will be named after the table and the column name(s), unless you pass <tt>:name</tt> as an option.  ====== Creating a simple index  add_index(:suppliers, :name)  generates:  CREATE INDEX index_suppliers_on_name ON suppliers(name)  ====== Creating a index which already exists  add_index(:suppliers, :name, if_not_exists: true)  generates:  CREATE INDEX IF NOT EXISTS index_suppliers_on_name ON suppliers(name)  Note: Not supported by MySQL.  ====== Creating a unique index  add_index(:accounts, [:branch_id, :party_id], unique: true)  generates:  CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id)  ====== Creating a named index  add_index(:accounts, [:branch_id, :party_id], unique: true, name: 'by_branch_party')  generates:  CREATE UNIQUE INDEX by_branch_party ON accounts(branch_id, party_id)  ====== Creating an index with specific key length  add_index(:accounts, :name, name: 'by_name', length: 10)  generates:  CREATE INDEX by_name ON accounts(name(10))  ====== Creating an index with specific key lengths for multiple keys  add_index(:accounts, [:name, :surname], name: 'by_name_surname', length: {name: 10, surname: 15})  generates:  CREATE INDEX by_name_surname ON accounts(name(10), surname(15))  Note: only supported by MySQL  ====== Creating an index with a sort order (desc or asc, asc is the default)  add_index(:accounts, [:branch_id, :party_id, :surname], name: 'by_branch_desc_party', order: {branch_id: :desc, party_id: :asc})  generates:  CREATE INDEX by_branch_desc_party ON accounts(branch_id DESC, party_id ASC, surname)  Note: MySQL only supports index order from 8.0.1 onwards (earlier versions accepted the syntax but ignored it).  ====== Creating a partial index  add_index(:accounts, [:branch_id, :party_id], unique: true, where: \"active\")  generates:  CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id) WHERE active  Note: Partial indexes are only supported for PostgreSQL and SQLite.  ====== Creating an index that includes additional columns  add_index(:accounts, :branch_id,  include: :party_id)  generates:  CREATE INDEX index_accounts_on_branch_id ON accounts USING btree(branch_id) INCLUDE (party_id)  Note: only supported by PostgreSQL.  ====== Creating an index where NULLs are treated equally  add_index(:people, :last_name, nulls_not_distinct: true)  generates:  CREATE INDEX index_people_on_last_name ON people (last_name) NULLS NOT DISTINCT  Note: only supported by PostgreSQL version 15.0.0 and greater.  ====== Creating an index with a specific method  add_index(:developers, :name, using: 'btree')  generates:  CREATE INDEX index_developers_on_name ON developers USING btree (name) -- PostgreSQL CREATE INDEX index_developers_on_name USING btree ON developers (name) -- MySQL  Note: only supported by PostgreSQL and MySQL  ====== Creating an index with a specific operator class  add_index(:developers, :name, using: 'gist', opclass: :gist_trgm_ops) # CREATE INDEX developers_on_name ON developers USING gist (name gist_trgm_ops) -- PostgreSQL  add_index(:developers, [:name, :city], using: 'gist', opclass: { city: :gist_trgm_ops }) # CREATE INDEX developers_on_name_and_city ON developers USING gist (name, city gist_trgm_ops) -- PostgreSQL  add_index(:developers, [:name, :city], using: 'gist', opclass: :gist_trgm_ops) # CREATE INDEX developers_on_name_and_city ON developers USING gist (name gist_trgm_ops, city gist_trgm_ops) -- PostgreSQL  Note: only supported by PostgreSQL  ====== Creating an index with a specific type  add_index(:developers, :name, type: :fulltext)  generates:  CREATE FULLTEXT INDEX index_developers_on_name ON developers (name) -- MySQL  Note: only supported by MySQL.  ====== Creating an index with a specific algorithm  add_index(:developers, :name, algorithm: :concurrently) # CREATE INDEX CONCURRENTLY developers_on_name on developers (name) -- PostgreSQL  add_index(:developers, :name, algorithm: :inplace) # CREATE INDEX `index_developers_on_name` ON `developers` (`name`) ALGORITHM = INPLACE -- MySQL  Note: only supported by PostgreSQL and MySQL.  Concurrently adding an index is not supported in a transaction.  For more information see the {\"Transactional Migrations\" section}[rdoc-ref:Migration].  ====== Creating an index that is not used by queries  add_index(:developers, :name, enabled: false)  generates:  CREATE INDEX index_developers_on_name ON developers (name) INVISIBLE -- MySQL  CREATE INDEX index_developers_on_name ON developers (name) IGNORED -- MariaDB  Note: only supported by MySQL version 8.0.0 and greater, and MariaDB version 10.6.0 and greater. ",
        "label": "How-it-is-done",
        "id": "13156"
    },
    {
        "raw_code": "def create_job(name)\n          job = Job.new(name, self)\n          yield job if block_given?\n          job.create\n          job\n        end",
        "comment": "Creates a new job in Jenkins  @param name [String] the name of the job @yieldparam job [Jenkins::Job] the job to be configured @return [Jenkins::Job] the created job in Jenkins",
        "label": "How-it-is-done",
        "id": "4315"
    },
    {
        "raw_code": "def ensure_valid_transfer\n    return if @rubygem_transfer.organization.present? && @rubygem_transfer.rubygems.any?\n\n    redirect_to organization_transfer_rubygems_path\n  end",
        "comment": "This is a quick sanity check to ensure we have a ready RubygemTransfer. If the transfer doesn't have an associated Organization, check the user authorization would raise a Pundit::NilClassPolicy",
        "label": "How-it-is-done",
        "id": "9970"
    },
    {
        "raw_code": "def create_inbound_email_from_mail(status: :processing, **mail_options, &block)\n      mail = Mail.new(mail_options, &block)\n      # Bcc header is not encoded by default\n      mail[:bcc].include_in_headers = true if mail[:bcc]\n\n      create_inbound_email_from_source mail.to_s, status: status\n    end",
        "comment": "Creates an InboundEmail by specifying through options or a block.  ==== Options  * <tt>:status</tt> - The +status+ to set for the created InboundEmail. For possible statuses, see its documentation.  ==== Creating a simple email  When you only need to set basic fields like +from+, +to+, +subject+, and +body+, you can pass them directly as options.  create_inbound_email_from_mail(from: \"david@loudthinking.com\", subject: \"Hello!\")  ==== Creating a multi-part email  When you need to create a more intricate email, like a multi-part email that contains both a plaintext version and an HTML version, you can pass a block.  create_inbound_email_from_mail do to \"David Heinemeier Hansson <david@loudthinking.com>\" from \"Bilbo Baggins <bilbo@bagend.com>\" subject \"Come down to the Shire!\"  text_part do body \"Please join us for a party at Bag End\" end  html_part do body \"<h1>Please join us for a party at Bag End</h1>\" end end  As with +Mail.new+, you can also use a block parameter to define the parts of the message:  create_inbound_email_from_mail do |mail| mail.to \"David Heinemeier Hansson <david@loudthinking.com>\" mail.from \"Bilbo Baggins <bilbo@bagend.com>\" mail.subject \"Come down to the Shire!\"  mail.text_part do |part| part.body \"Please join us for a party at Bag End\" end  mail.html_part do |part| part.body \"<h1>Please join us for a party at Bag End</h1>\" end end",
        "label": "How-it-is-done",
        "id": "11100"
    },
    {
        "raw_code": "def load_cop_rules(rules)\n      rules.flat_map do |rule_type, data|\n        data.filter_map do |cop_name, configuration|\n          next unless configuration # allow configurations to be disabled with `CopName: ~`\n\n          COP_RULE_CLASSES[rule_type].new(@config, cop_name, configuration)\n        end",
        "comment": "Cop rules are keyed by the name of the original cop",
        "label": "How-it-is-done",
        "id": "10044"
    },
    {
        "raw_code": "def documented?\n    return true if @received_nodoc\n    return false if @comment_location.empty?\n    @comment_location.any? { |comment, _| not comment.empty? }\n  end",
        "comment": " Does this class or module have a comment with content or is #received_nodoc true?",
        "label": "How-it-is-done",
        "id": "16743"
    },
    {
        "raw_code": "def process_filter(conditions)\n          build_bool_query(:must) do |queries|\n            conditions.each do |field, value|\n              queries << (value.is_a?(Array) ? { terms: { field => value } } : { term: { field => value } })\n            end",
        "comment": "Processes filter conditions into term or terms queries  @param conditions [Hash] The filter conditions where keys are fields and values are the terms @return [Hash] A bool query with term/terms clauses in the must array @example Single value (term) process_filter(status: 'active') # => { query: { bool: { must: [{ term: { status: 'active' } }] } } } @example Array value (terms) process_filter(status: ['active', 'pending']) # => { query: { bool: { must: [{ terms: { status: ['active', 'pending'] } }] } } }",
        "label": "How-it-is-done",
        "id": "1128"
    },
    {
        "raw_code": "def create_enum(name, values, **options)\n        sql_values = values.map { |s| quote(s) }.join(\", \")\n        scope = quoted_scope(name)\n        query = <<~SQL\n          DO $$\n          BEGIN\n              IF NOT EXISTS (\n                SELECT 1\n                FROM pg_type t\n                JOIN pg_namespace n ON t.typnamespace = n.oid\n                WHERE t.typname = #{scope[:name]}\n                  AND n.nspname = #{scope[:schema]}\n              ) THEN\n                  CREATE TYPE #{quote_table_name(name)} AS ENUM (#{sql_values});\n              END IF;\n          END\n          $$;\n        SQL\n        internal_exec_query(query).tap { reload_type_map }\n      end",
        "comment": "Given a name and an array of values, creates an enum type.",
        "label": "How-it-is-done",
        "id": "12970"
    },
    {
        "raw_code": "def supports_unique_constraints?\n        false\n      end",
        "comment": "Does this adapter support creating unique constraints?",
        "label": "How-it-is-done",
        "id": "12899"
    },
    {
        "raw_code": "def ensure_installed\n        # If the guest cannot check if Chef is installed, just exit printing a\n        # warning...\n        if !@machine.guest.capability?(:chef_installed)\n          @machine.ui.warn(I18n.t(\"vagrant.chef_cant_detect\"))\n          return\n        end",
        "comment": "This handles verifying the Chef installation, installing it if it was requested, and so on. This method will raise exceptions if things are wrong.",
        "label": "How-it-is-done",
        "id": "9892"
    },
    {
        "raw_code": "def self.create(store, req, default_options)\n        session_was = find req\n        session     = Request::Session.new(store, req)\n        session.merge! session_was if session_was\n\n        set(req, session)\n        Options.set(req, Request::Session::Options.new(store, default_options))\n        session\n      end",
        "comment": "Creates a session hash, merging the properties of the previous session if any.",
        "label": "How-it-is-done",
        "id": "11546"
    },
    {
        "raw_code": "def migrate(direction)\n      return unless respond_to?(direction)\n\n      case direction\n      when :up   then announce 'migrating'\n      when :down then announce 'reverting'\n      end",
        "comment": "Execute this migration in the named direction",
        "label": "How-it-is-done",
        "id": "3539"
    },
    {
        "raw_code": "def find_or_create_module_path(module_name, create_mode)\n    root_name, *path, name = module_name.split('::')\n    add_module = ->(mod, name, mode) {\n      case mode\n      when :class\n        mod.add_class(RDoc::NormalClass, name, 'Object').tap { |m| m.store = @store }\n      when :module\n        mod.add_module(RDoc::NormalModule, name).tap { |m| m.store = @store }\n      end",
        "comment": "Find or create module or class from a given module name. If module or class does not exist, creates a module or a class according to `create_mode` argument.",
        "label": "How-it-is-done",
        "id": "16044"
    },
    {
        "raw_code": "def initialize(relative_base_path)\n        @relative_base_path = relative_base_path\n        @extracted_objects = {}\n        @messages = Messages.new\n      end",
        "comment": "Creates a POT generator that uses +relative_base_path+ to generate locations for a msgid. +relative_base_path+ is prepended to all locations.  @param [String] relative_base_path a relative working directory path from a directory path that has created .pot file.",
        "label": "How-it-is-done",
        "id": "708"
    },
    {
        "raw_code": "def list_files_in_directory(dir)\n    files = Dir.glob File.join(dir, \"*\")\n\n    normalized_file_list files, false, @options.exclude\n  end",
        "comment": " Return a list of the files to be processed in a directory. We know that this directory doesn't have a .document file, so we're looking for real files. However we may well contain subdirectories which must be tested for .document files.",
        "label": "How-it-is-done",
        "id": "16016"
    },
    {
        "raw_code": "def create_and_upload!(key: nil, io:, filename:, content_type: nil, metadata: nil, service_name: nil, identify: true, record: nil)\n      create_after_unfurling!(key: key, io: io, filename: filename, content_type: content_type, metadata: metadata, service_name: service_name, identify: identify).tap do |blob|\n        blob.upload_without_unfurling(io)\n      end",
        "comment": "Creates a new blob instance and then uploads the contents of the given <tt>io</tt> to the service. The blob instance is going to be saved before the upload begins to prevent the upload clobbering another due to key collisions. When providing a content type, pass <tt>identify: false</tt> to bypass automatic content type inference.",
        "label": "How-it-is-done",
        "id": "13600"
    },
    {
        "raw_code": "def read_documentation_modifiers(context, allowed)\n    skip_tkspace_without_nl\n    directive, value = read_directive allowed\n\n    return unless directive\n\n    @preprocess.handle_directive '', directive, value, context do |dir, param|\n      if %w[notnew not_new not-new].include? dir then\n        context.dont_rename_initialize = true\n\n        true\n      end",
        "comment": " Handles directives following the definition for +context+ (any RDoc::CodeObject) if the directives are +allowed+ at this point.  See also RDoc::Markup::PreProcess#handle_directive",
        "label": "How-it-is-done",
        "id": "16122"
    },
    {
        "raw_code": "def run_command!(command)\n      output, status = Gitlab::Popen.popen(command)\n\n      raise Gitlab::TaskFailedError, output unless status == 0\n\n      output\n    end",
        "comment": "Runs the given command and raises a Gitlab::TaskFailedError exception if the command does not exit with 0  Returns the output of the command otherwise",
        "label": "How-it-is-done",
        "id": "1671"
    },
    {
        "raw_code": "def link_to_unless_current(name, options = {}, html_options = {}, &block)\n        link_to_unless current_page?(options), name, options, html_options, &block\n      end",
        "comment": "Creates a link tag of the given +name+ using a URL created by the set of +options+ unless the current request URI is the same as the links, in which case only the name is returned (or the given block is yielded, if one exists). You can give +link_to_unless_current+ a block which will specialize the default behavior (e.g., show a \"Start Here\" link rather than the link's text).  ==== Examples Let's say you have a navigation menu...  <ul id=\"navbar\"> <li><%= link_to_unless_current(\"Home\", { action: \"index\" }) %></li> <li><%= link_to_unless_current(\"About Us\", { action: \"about\" }) %></li> </ul>  If in the \"about\" action, it will render...  <ul id=\"navbar\"> <li><a href=\"/controller/index\">Home</a></li> <li>About Us</li> </ul>  ...but if in the \"index\" action, it will render:  <ul id=\"navbar\"> <li>Home</li> <li><a href=\"/controller/about\">About Us</a></li> </ul>  The implicit block given to +link_to_unless_current+ is evaluated if the current action is the action given. So, if we had a comments page and wanted to render a \"Go Back\" link instead of a link to the comments page, we could do something like this...  <%= link_to_unless_current(\"Comment\", { controller: \"comments\", action: \"new\" }) do link_to(\"Go back\", { controller: \"posts\", action: \"index\" }) end %>",
        "label": "How-it-is-done",
        "id": "11991"
    },
    {
        "raw_code": "def some_method\n          puts 'foo'\n        end",
        "comment": "rubocop:enable Metrics/MethodLength, Security/Eval",
        "label": "How-it-is-done",
        "id": "10758"
    },
    {
        "raw_code": "def gl_tab_counter_badge(count, html_options = {})\n    gl_badge_tag(\n      count,\n      html_options.merge(\n        class: ['gl-tab-counter-badge', *html_options[:class]]\n      )\n    )\n  end",
        "comment": "Creates a <gl-badge> for use inside tabs.  html_options - The html_options hash (default: {})",
        "label": "How-it-is-done",
        "id": "7733"
    },
    {
        "raw_code": "def initialize\n        super\n        self.scripts = []\n        self.template_paths = []\n        self.libraries = {}\n        self.options = SymbolHash.new(false).update(\n          :single_library => true,\n          :caching => false\n        )\n        self.server_options = {:Port => 8808}\n      end",
        "comment": "Creates a new instance of the Server command line utility",
        "label": "How-it-is-done",
        "id": "546"
    },
    {
        "raw_code": "def self.longname(name)\n        # We loop over the API call in case we didn't allocate enough\n        # buffer space. In general it is usually enough.\n        bufferlen = 250\n        buffer    = nil\n        while true\n          buffer = ' ' * bufferlen\n          len    = API.GetLongPathNameA(name.to_s, buffer, buffer.size)\n          if bufferlen < len\n            # If the length returned is larger than our buffer length,\n            # it is the API telling us it needs more space. Allocate it\n            # and retry.\n            bufferlen = len\n            continue\n          end",
        "comment": "Converts a Windows shortname to a long name. This only works for ASCII paths currently and doesn't use the wide character support.",
        "label": "How-it-is-done",
        "id": "9186"
    },
    {
        "raw_code": "def bar\n                  puts 'baz'\n                end",
        "comment": "Documentation",
        "label": "How-it-is-done",
        "id": "10896"
    },
    {
        "raw_code": "def create_table\n      return unless enabled?\n\n      @pool.with_connection do |connection|\n        unless connection.table_exists?(table_name)\n          connection.create_table(table_name, id: false) do |t|\n            t.string :key, **connection.internal_string_options_for_primary_key\n            t.string :value\n            t.timestamps\n          end",
        "comment": "Creates an internal metadata table with columns +key+ and +value+",
        "label": "How-it-is-done",
        "id": "12487"
    },
    {
        "raw_code": "def process_pipeline(pipeline)\n      return unless finished_pipeline_sync_event?(pipeline)\n\n      # Use upsert since this code can be called more than once for the same pipeline\n      ::Ci::FinishedPipelineChSyncEvent.upsert(\n        {\n          pipeline_id: pipeline.id,\n          pipeline_finished_at: pipeline.finished_at,\n          project_namespace_id: pipeline.project.project_namespace_id\n        },\n        unique_by: [:pipeline_id, :partition]\n      )\n    end",
        "comment": "Processes a single CI pipeline that has finished.  @param [Ci::Pipeline] pipeline The pipeline to process.",
        "label": "How-it-is-done",
        "id": "6374"
    },
    {
        "raw_code": "def frozen_string_literal?\n      frozen_string_literal == true\n    end",
        "comment": "Does the magic comment enable the frozen string literal feature.  Test whether the frozen string literal value is `true`. Cannot just return `frozen_string_literal` since an invalid magic comment like `# frozen_string_literal: yes` is possible and the truthy value `'yes'` does not actually enable the feature  @return [Boolean]",
        "label": "How-it-is-done",
        "id": "10153"
    },
    {
        "raw_code": "def api_get_from(get_path, q_params: query_parameters)\n        path = \"#{get_path}#{query_parameters_to_string(q_params)}\"\n        request = Runtime::API::Request.new(api_client, path)\n        response = get(request.url)\n\n        if response.code == HTTP_STATUS_NOT_FOUND\n          raise(ResourceNotFoundError, <<~MSG.strip)\n            Resource at #{request.mask_url} could not be found (#{response.code}): `#{response}`.\n            #{QA::Support::Loglinking.failure_metadata(response.headers[:x_request_id])}\n          MSG\n        elsif !success?(response.code)\n          raise(InternalServerError, <<~MSG.strip)\n            Failed to GET #{request.mask_url} - (#{response.code}): `#{response}`.\n            #{QA::Support::Loglinking.failure_metadata(response.headers[:x_request_id])}\n          MSG\n        end",
        "comment": "TODO: remove global query_parameters so this helper method does not depend on global variable It assumes that all resource related might have a common query which often is not the case",
        "label": "How-it-is-done",
        "id": "4117"
    },
    {
        "raw_code": "def to_sentence(options = {})\n    options.assert_valid_keys(:words_connector, :two_words_connector, :last_word_connector, :locale)\n\n    default_connectors = {\n      words_connector: \", \",\n      two_words_connector: \" and \",\n      last_word_connector: \", and \"\n    }\n    if options[:locale] != false && defined?(I18n)\n      i18n_connectors = I18n.translate(:'support.array', locale: options[:locale], default: {})\n      default_connectors.merge!(i18n_connectors)\n    end",
        "comment": "Converts the array to a comma-separated sentence where the last element is joined by the connector word.  You can pass the following options to change the default behavior. If you pass an option key that doesn't exist in the list below, it will raise an <tt>ArgumentError</tt>.  ==== Options  * <tt>:words_connector</tt> - The sign or word used to join all but the last element in arrays with three or more elements (default: <tt>\", \"</tt>). * <tt>:last_word_connector</tt> - The sign or word used to join the last element in arrays with three or more elements (default: <tt>\", and \"</tt>). * <tt>:two_words_connector</tt> - The sign or word used to join the elements in arrays with two elements (default: <tt>\" and \"</tt>). * <tt>:locale</tt> - If +i18n+ is available, you can set a locale and use the connector options defined on the 'support.array' namespace in the corresponding dictionary file.  ==== Examples  [].to_sentence                      # => \"\" ['one'].to_sentence                 # => \"one\" ['one', 'two'].to_sentence          # => \"one and two\" ['one', 'two', 'three'].to_sentence # => \"one, two, and three\"  ['one', 'two'].to_sentence(passing: 'invalid option') # => ArgumentError: Unknown key: :passing. Valid keys are: :words_connector, :two_words_connector, :last_word_connector, :locale  ['one', 'two'].to_sentence(two_words_connector: '-') # => \"one-two\"  ['one', 'two', 'three'].to_sentence(words_connector: ' or ', last_word_connector: ' or at least ') # => \"one or two or at least three\"  Using <tt>:locale</tt> option:  # Given this locale dictionary: # #   es: #     support: #       array: #         words_connector: \" o \" #         two_words_connector: \" y \" #         last_word_connector: \" o al menos \"  ['uno', 'dos'].to_sentence(locale: :es) # => \"uno y dos\"  ['uno', 'dos', 'tres'].to_sentence(locale: :es) # => \"uno o dos o al menos tres\"",
        "label": "How-it-is-done",
        "id": "14097"
    },
    {
        "raw_code": "def process_statement_end(tk)\n        # Whitespace means that we keep the same value of @new_statement as last token\n        return if tk.class == TkSPACE\n\n        return unless\n          # We might be coming after a statement-ending token...\n          (@last_tk && [TkSEMICOLON, TkNL, TkEND_OF_SCRIPT].include?(tk.class)) ||\n          # Or we might be at the beginning of an argument list\n          (@current_block == TkDEF && tk.class == TkRPAREN)\n\n        # Continue line ending on . or ::\n        return if @last_tk && [EXPR_DOT].include?(@last_tk.lex_state)\n\n        # Continue a possible existing new statement unless we just finished an expression...\n        return unless (@last_tk && [EXPR_END, EXPR_ARG].include?(@last_tk.lex_state)) ||\n                      # Or we've opened a block and are ready to move into the body\n                      (@current_block && [TkNL, TkSEMICOLON].include?(tk.class) &&\n                       # Handle the case where the block statement's expression is on the next line\n                       #\n                       # while\n                       #     foo\n                       # end\n                       @last_ns_tk.class != @current_block &&\n                       # And the case where part of the expression is on the next line\n                       #\n                       # while foo ||\n                       #     bar\n                       # end\n                       @last_tk.lex_state != EXPR_BEG)\n\n        # Continue with the statement if we've hit a comma in a def\n        return if @current_block == TkDEF && peek_no_space.class == TkCOMMA\n\n        if [TkEND_OF_SCRIPT, TkNL, TkSEMICOLON].include?(tk.class) && @state == :block_statement &&\n           [TkRBRACE, TkEND].include?(@last_ns_tk.class) && @level == 0\n          @current_block = nil\n        end",
        "comment": "Processes a token that closes a statement  @param [RubyToken::Token] tk the token to process",
        "label": "How-it-is-done",
        "id": "339"
    },
    {
        "raw_code": "def disconnect!\n        super\n\n        @raw_connection&.close rescue nil\n        @raw_connection = nil\n      end",
        "comment": "Disconnects from the database if already connected. Otherwise, this method does nothing.",
        "label": "How-it-is-done",
        "id": "12991"
    },
    {
        "raw_code": "def self.preserve_timezone # :nodoc:\n      if @@preserve_timezone.nil?\n        # Only warn once, the first time the value is used (which should\n        # be the first time #to_time is called).\n        ActiveSupport.deprecator.warn(\n          \"`to_time` will always preserve the receiver timezone rather than system local time in Rails 8.1.\" \\\n          \"To opt in to the new behavior, set `config.active_support.to_time_preserves_timezone = :zone`.\"\n        )\n\n        @@preserve_timezone = false\n      end",
        "comment": "-- This re-implements the behavior of the mattr_reader, instead of prepending on to it, to avoid overcomplicating a module that is in turn included in several places. This will all go away in Rails 8.0 anyway.",
        "label": "How-it-is-done",
        "id": "14176"
    },
    {
        "raw_code": "def self.get_instance server, *options # :nodoc:\n    stores = @server_stores[server]\n\n    new server, stores, @cache, *options\n  end",
        "comment": " Creates an instance of this servlet that shares cached data between requests.",
        "label": "How-it-is-done",
        "id": "15932"
    },
    {
        "raw_code": "def initialize indent, *parts\n    @indent = indent\n\n    super(*parts)\n  end",
        "comment": " Creates a new IndentedParagraph containing +parts+ indented with +indent+ spaces",
        "label": "How-it-is-done",
        "id": "16359"
    },
    {
        "raw_code": "def test_save_class_merge_constant\n    store = RDoc::Store.new(RDoc::Options.new)\n    tl = store.add_file 'file.rb'\n\n    klass = tl.add_class RDoc::NormalClass, 'C'\n    klass.add_comment 'comment', tl\n\n    const = klass.add_constant RDoc::Constant.new('CONST', nil, nil)\n    const.record_location tl\n\n    @s.save_class klass\n\n    # separate parse run, independent store\n    store = RDoc::Store.new(RDoc::Options.new)\n    tl = store.add_file 'file.rb'\n    klass2 = tl.add_class RDoc::NormalClass, 'C'\n    klass2.record_location tl\n\n    s = RDoc::RI::Store.new(RDoc::Options.new, path: @tmpdir)\n    s.save_class klass2\n\n    # separate `ri` run, independent store\n    s = RDoc::RI::Store.new(RDoc::Options.new, path: @tmpdir)\n\n    result = s.load_class 'C'\n\n    assert_empty result.constants\n  end",
        "comment": "This is a functional test",
        "label": "How-it-is-done",
        "id": "16851"
    },
    {
        "raw_code": "def rfc3339(str)\n      parts = Date._rfc3339(str)\n\n      raise ArgumentError, \"invalid date\" if parts.empty?\n\n      Time.new(\n        parts.fetch(:year),\n        parts.fetch(:mon),\n        parts.fetch(:mday),\n        parts.fetch(:hour),\n        parts.fetch(:min),\n        parts.fetch(:sec) + parts.fetch(:sec_fraction, 0),\n        parts.fetch(:offset)\n      )\n    end",
        "comment": "Creates a +Time+ instance from an RFC 3339 string.  Time.rfc3339('1999-12-31T14:00:00-10:00') # => 2000-01-01 00:00:00 -1000  If the time or offset components are missing then an +ArgumentError+ will be raised.  Time.rfc3339('1999-12-31') # => ArgumentError: invalid date",
        "label": "How-it-is-done",
        "id": "14391"
    },
    {
        "raw_code": "def call\n        doc.xpath('descendant-or-self::img[not(ancestor::a) and not(@data-src = \"\")]').each do |img|\n          link_replaces_image = !!context[:link_replaces_image]\n          html_class = link_replaces_image ? 'with-attachment-icon' : 'no-attachment-icon'\n\n          link = doc.document.create_element(\n            'a',\n            class: html_class,\n            href: img['data-src'] || img['src'],\n            target: '_blank',\n            rel: 'noopener noreferrer'\n          )\n\n          # make sure the original non-proxied src carries over to the link\n          link['data-canonical-src'] = img['data-canonical-src'] if img['data-canonical-src']\n\n          if img['data-diagram'] && img['data-diagram-src']\n            link['data-diagram'] = img['data-diagram']\n            link['data-diagram-src'] = img['data-diagram-src']\n            img.remove_attribute('data-diagram')\n            img.remove_attribute('data-diagram-src')\n          end",
        "comment": "Find every image that isn't already wrapped in an `a` tag, create a new node (a link to the image source), copy the image as a child of the anchor, and then replace the img with the link-wrapped version.  If `link_replaces_image` context parameter is provided, the image is going to be replaced with a link to an image.",
        "label": "How-it-is-done",
        "id": "3466"
    },
    {
        "raw_code": "def directive_create(tag_name, tag_buf, parser)\n        meth = self.class.factory_method_for(tag_name)\n        tag = send_to_factory(tag_name, meth, tag_buf)\n        meth = self.class.directive_method_name(tag_name)\n        send(meth, tag, parser)\n      end",
        "comment": "Creates a new directive with tag information and a docstring parser object. @param [String] tag_name the name of the tag @param [String] tag_buf the tag data @param [DocstringParser] parser the parser object parsing the docstring @return [Directive] the newly created directive",
        "label": "How-it-is-done",
        "id": "247"
    },
    {
        "raw_code": "def parse_tag_with_types_and_title(tag_name, text)\n        name, types, text = *extract_types_and_name_from_text_unstripped(text)\n        if name\n          title = name\n          desc = text\n        else\n          title, desc = *extract_title_and_desc_from_text(text)\n        end",
        "comment": "Parses tag text and creates a new tag with formally declared types, a title on the first line and descriptive text  @param tag_name        the name of the tag to parse @param [String] text   the raw tag text @return [Tag]          a tag object with the tag_name, name, types and text values filled",
        "label": "How-it-is-done",
        "id": "233"
    },
    {
        "raw_code": "def from(value, subquery_name = nil)\n      spawn.from!(value, subquery_name)\n    end",
        "comment": "Specifies the table from which the records will be fetched. For example:  Topic.select('title').from('posts') # SELECT title FROM posts  Can accept other relation objects. For example:  Topic.select('title').from(Topic.approved) # SELECT title FROM (SELECT * FROM topics WHERE approved = 't') subquery  Passing a second argument (string or symbol), creates the alias for the SQL from clause. Otherwise the alias \"subquery\" is used:  Topic.select('a.title').from(Topic.approved, :a) # SELECT a.title FROM (SELECT * FROM topics WHERE approved = 't') a  It does not add multiple arguments to the SQL from clause. The last +from+ chained is the one used:  Topic.select('title').from(Topic.approved).from(Topic.inactive) # SELECT title FROM (SELECT topics.* FROM topics WHERE topics.active = 'f') subquery  For multiple arguments for the SQL from clause, you can pass a string with the exact elements in the SQL from list:  color = \"red\" Color .from(\"colors c, JSONB_ARRAY_ELEMENTS(colored_things) AS colorvalues(colorvalue)\") .where(\"colorvalue->>'color' = ?\", color) .select(\"c.*\").to_a # SELECT c.* # FROM colors c, JSONB_ARRAY_ELEMENTS(colored_things) AS colorvalues(colorvalue) # WHERE (colorvalue->>'color' = 'red')",
        "label": "How-it-is-done",
        "id": "13426"
    },
    {
        "raw_code": "def scan\n    comment = RDoc::Comment.new @content, @top_level\n    comment.format = 'markdown'\n\n    @top_level.comment = comment\n  end",
        "comment": " Creates an Markdown-format TopLevel for the given file.",
        "label": "How-it-is-done",
        "id": "16135"
    },
    {
        "raw_code": "def default_i18n_subject(interpolations = {}) # :doc:\n        mailer_scope = self.class.mailer_name.tr(\"/\", \".\")\n        I18n.t(:subject, **interpolations, scope: [mailer_scope, action_name], default: action_name.humanize)\n      end",
        "comment": "Translates the +subject+ using \\Rails I18n class under <tt>[mailer_scope, action_name]</tt> scope. If it does not find a translation for the +subject+ under the specified scope it will default to a humanized version of the <tt>action_name</tt>. If the subject has interpolations, you can pass them through the +interpolations+ parameter.",
        "label": "How-it-is-done",
        "id": "11120"
    },
    {
        "raw_code": "def initialize(options, markup = nil)\n    super\n\n    @code_object = nil\n    @from_path = ''\n    @in_list_entry = nil\n    @list = nil\n    @th = nil\n    @hard_break = \"<br>\\n\"\n\n    init_regexp_handlings\n\n    init_tags\n  end",
        "comment": ":section:  Creates a new formatter that will output HTML",
        "label": "How-it-is-done",
        "id": "16324"
    },
    {
        "raw_code": "def process(node)\n          case node.type\n          when :all    then process_all\n          when :filter then process_filter(node.value)\n          when :prefix then process_prefix(node.value)\n          when :and    then process_and(node.children)\n          when :or     then process_or(node.children)\n          when :knn    then process_knn(node)\n          when :limit  then process_limit(node)\n          else\n            raise ArgumentError, \"Unsupported node type: #{node.type}\"\n          end",
        "comment": "Processes a query node and returns the corresponding ActiveRecord relation",
        "label": "How-it-is-done",
        "id": "1162"
    },
    {
        "raw_code": "def fulldoc_template\n          tplopts = [options.template, :fulldoc, options.format]\n          tplclass = Templates::Engine.template(*tplopts)\n          obj = Object.new.extend(tplclass)\n          class << obj; define_method(:init) {} end\n          obj.class = tplclass\n          obj.send(:initialize, options)\n          class << obj\n            attr_reader :contents\n            define_method(:asset) {|_, contents| @contents = contents }\n          end",
        "comment": "Hack to load a custom fulldoc template object that does not do any rendering/generation. We need this to access the generate_*_list methods.",
        "label": "How-it-is-done",
        "id": "707"
    },
    {
        "raw_code": "def reader\n        ensure_klass_exists!\n\n        if stale_target?\n          reload\n        end",
        "comment": "Implements the reader method, e.g. foo.items for Foo.has_many :items",
        "label": "How-it-is-done",
        "id": "12766"
    },
    {
        "raw_code": "def initialize\n    @regexp_handling = 1\n\n    @name_to_bitmap = [\n      [:_REGEXP_HANDLING_, @regexp_handling],\n    ]\n\n    @next_bitmap = @regexp_handling << 1\n  end",
        "comment": " Creates a new attributes set.",
        "label": "How-it-is-done",
        "id": "16372"
    },
    {
        "raw_code": "def initialize\n        @messages = {}\n      end",
        "comment": "Creates a new container.",
        "label": "How-it-is-done",
        "id": "724"
    },
    {
        "raw_code": "def authenticate_sessionless_user!(request_format)\n    user = request_authenticator.find_sessionless_user(request_format)\n    sessionless_sign_in(user) if user\n  end",
        "comment": "This filter handles personal access tokens, atom requests with rss tokens, and static object tokens",
        "label": "How-it-is-done",
        "id": "6548"
    },
    {
        "raw_code": "def self.synopsis\n          \"\"\n        end",
        "comment": "This should return a brief (60 characters or less) synopsis of what this command does. It will be used in the output of the help.  @return [String]",
        "label": "How-it-is-done",
        "id": "9085"
    },
    {
        "raw_code": "def read\n      if !key.nil? && content_path.exist?\n        decrypt content_path.binread.strip\n      else\n        raise MissingContentError, content_path\n      end",
        "comment": "Reads the file and returns the decrypted content.  Raises: - MissingKeyError if the key is missing and +raise_if_missing_key+ is true. - MissingContentError if the encrypted file does not exist or otherwise if the key is missing. - ActiveSupport::MessageEncryptor::InvalidMessage if the content cannot be decrypted or verified.",
        "label": "How-it-is-done",
        "id": "13837"
    },
    {
        "raw_code": "def execute\n        return error(errors.full_messages) unless valid?\n        return error(project.errors.full_messages) unless project.saved?\n\n        success(project)\n      rescue StandardError => e\n        error(e.message)\n      end",
        "comment": "Creates a project with the strategy parameters  @return [Services::ServiceResponse]",
        "label": "How-it-is-done",
        "id": "6096"
    },
    {
        "raw_code": "def add_section(title, comment = nil)\n    if section = @sections[title] then\n      section.add_comment comment if comment\n    else\n      section = Section.new self, title, comment\n      @sections[title] = section\n    end",
        "comment": " Returns a section with +title+, creating it if it doesn't already exist. +comment+ will be appended to the section's comment.  A section with a +title+ of +nil+ will return the default section.  See also RDoc::Context::Section",
        "label": "How-it-is-done",
        "id": "16648"
    },
    {
        "raw_code": "def parse(iso8601duration)\n        parts = ISO8601Parser.new(iso8601duration).parse!\n        new(calculate_total_seconds(parts), parts)\n      end",
        "comment": "Creates a new Duration from string formatted according to ISO 8601 Duration.  See {ISO 8601}[https://en.wikipedia.org/wiki/ISO_8601#Durations] for more information. This method allows negative parts to be present in pattern. If invalid string is provided, it will raise +ActiveSupport::Duration::ISO8601Parser::ParsingError+.",
        "label": "How-it-is-done",
        "id": "13808"
    },
    {
        "raw_code": "def initialize(*expressions)\n      @expressions = []\n      add_expressions(*expressions)\n    end",
        "comment": "Creates a verifier from a set of expressions  @param [Array<String>] expressions a list of Ruby expressions to parse.",
        "label": "How-it-is-done",
        "id": "87"
    },
    {
        "raw_code": "def initialize(opts = {})\n        @options = SymbolHash.new(false).update(opts)\n      end",
        "comment": "@group Creating a New Serializer Creates a new serializer with options  @param [Hash] opts the options to assign to {#options}",
        "label": "How-it-is-done",
        "id": "462"
    },
    {
        "raw_code": "def initialize(current_user:, params:)\n        @current_user = current_user\n        @params = params\n      end",
        "comment": "Creates a new RelationImportService.  @param [User] current_user @param [Hash] params @option params [String] path The full path of the project @option params [String] relation The relation to import. See IMPORTABLE_RELATIONS for permitted values. @option params [UploadedFile] file The export archive containing the data to import",
        "label": "How-it-is-done",
        "id": "5953"
    },
    {
        "raw_code": "def sms_to(phone_number, name = nil, html_options = {}, &block)\n        html_options, name = name, nil if name.is_a?(Hash)\n        html_options = (html_options || {}).stringify_keys\n\n        country_code = html_options.delete(\"country_code\").presence\n        country_code = country_code ? \"+#{ERB::Util.url_encode(country_code)}\" : \"\"\n\n        body = html_options.delete(\"body\").presence\n        body = body ? \"?&body=#{ERB::Util.url_encode(body)}\" : \"\"\n\n        encoded_phone_number = ERB::Util.url_encode(phone_number)\n        html_options[\"href\"] = \"sms:#{country_code}#{encoded_phone_number};#{body}\"\n\n        content_tag(\"a\", name || phone_number, html_options, &block)\n      end",
        "comment": "Creates an SMS anchor link tag to the specified +phone_number+. When the link is clicked, the default SMS messaging app is opened ready to send a message to the linked phone number. If the +body+ option is specified, the contents of the message will be preset to +body+.  If +name+ is not specified, +phone_number+ will be used as the name of the link.  A +country_code+ option is supported, which prepends a plus sign and the given country code to the linked phone number. For example, <tt>country_code: \"01\"</tt> will prepend <tt>+01</tt> to the linked phone number.  Additional HTML attributes for the link can be passed via +html_options+.  ==== Options * <tt>:country_code</tt> - Prepend the country code to the phone number. * <tt>:body</tt> - Preset the body of the message.  ==== Examples sms_to \"5155555785\" # => <a href=\"sms:5155555785;\">5155555785</a>  sms_to \"5155555785\", country_code: \"01\" # => <a href=\"sms:+015155555785;\">5155555785</a>  sms_to \"5155555785\", \"Text me\" # => <a href=\"sms:5155555785;\">Text me</a>  sms_to \"5155555785\", body: \"I have a question about your product.\" # => <a href=\"sms:5155555785;?body=I%20have%20a%20question%20about%20your%20product\">5155555785</a>  You can use a block as well if your link target is hard to fit into the name parameter. \\ERB example:  <%= sms_to \"5155555785\" do %> <strong>Text me:</strong> <% end %> # => <a href=\"sms:5155555785;\"> <strong>Text me:</strong> </a>",
        "label": "How-it-is-done",
        "id": "11996"
    },
    {
        "raw_code": "def check_merge_requests_available!\n    render_404 if project_policy.merge_requests_disabled?\n  end",
        "comment": "Normally the methods with `check_(\\w+)_available!` pattern are handled by the `method_missing` defined in `ProjectsController::ApplicationController` but that logic does not take the member roles into account, therefore, we handle this case here manually.",
        "label": "How-it-is-done",
        "id": "6630"
    },
    {
        "raw_code": "def assert_performed_with(job: nil, args: nil, at: nil, queue: nil, priority: nil, &block)\n      require_active_job_test_adapter!(\"assert_performed_with\")\n\n      expected = { job: job, args: args, at: at, queue: queue, priority: priority }.compact\n      expected_args = prepare_args_for_assertion(expected)\n      potential_matches = []\n\n      if block_given?\n        original_performed_jobs_count = performed_jobs.count\n\n        perform_enqueued_jobs(&block)\n\n        jobs = performed_jobs.drop(original_performed_jobs_count)\n      else\n        jobs = performed_jobs\n      end",
        "comment": "Asserts that the job has been performed with the given arguments.  def test_assert_performed_with MyJob.perform_later(1,2,3)  perform_enqueued_jobs  assert_performed_with(job: MyJob, args: [1,2,3])  MyJob.set(wait_until: Date.tomorrow.noon, queue: \"my_queue\").perform_later  perform_enqueued_jobs  assert_performed_with(at: Date.tomorrow.noon, queue: \"my_queue\") end  The given arguments may also be specified as matcher procs that return a boolean value indicating whether a job's attribute meets certain criteria.  For example, a proc can be used to match a range of times:  def test_assert_performed_with at_matcher = ->(job_at) { (Date.yesterday..Date.tomorrow).cover?(job_at) }  MyJob.set(wait_until: Date.today.noon).perform_later  perform_enqueued_jobs  assert_performed_with(job: MyJob, at: at_matcher) end  A proc can also be used to match a subset of a job's args:  def test_assert_performed_with args_matcher = ->(job_args) { job_args[0].key?(:foo) }  MyJob.perform_later(foo: \"bar\", other_arg: \"No need to check in the test\")  perform_enqueued_jobs  assert_performed_with(job: MyJob, args: args_matcher) end  If a block is passed, that block performs all of the jobs that were enqueued throughout the duration of the block and asserts that the job has been performed with the given arguments in the block.  def test_assert_performed_with assert_performed_with(job: MyJob, args: [1,2,3]) do MyJob.perform_later(1,2,3) end  assert_performed_with(job: MyJob, at: Date.tomorrow.noon) do MyJob.set(wait_until: Date.tomorrow.noon).perform_later end end",
        "label": "How-it-is-done",
        "id": "12145"
    },
    {
        "raw_code": "def process_prefix(conditions)\n          build_bool_query(:must) do |queries|\n            conditions.each do |field, value|\n              queries << { prefix: { field => value } }\n            end",
        "comment": "Processes prefix conditions into prefix queries  @param conditions [Hash] The prefix conditions where keys are fields and values are the prefixes @return [Hash] A bool query with prefix clauses in the must array @example process_prefix(name: 'test', path: 'foo/') # => { query: { bool: { must: [ #      { prefix: { name: 'test' } }, #      { prefix: { path: 'foo/' } } #    ] } } }",
        "label": "How-it-is-done",
        "id": "1129"
    },
    {
        "raw_code": "def handle_attr(var_name, attr_name, read, write)\n    rw = ''\n    rw += 'R' if TRUE_VALUES.include?(read)\n    rw += 'W' if TRUE_VALUES.include?(write)\n\n    class_name = @known_classes[var_name]\n\n    return unless class_name\n\n    class_obj = find_class var_name, class_name\n\n    return unless class_obj\n\n    comment = find_attr_comment var_name, attr_name\n    comment.normalize\n\n    name = attr_name.gsub(/rb_intern(?:_const)?\\(\"([^\"]+)\"\\)/, '\\1')\n\n    attr = RDoc::Attr.new '', name, rw, comment\n\n    attr.record_location @top_level\n    class_obj.add_attribute attr\n    @stats.add_attribute attr\n  end",
        "comment": " Creates a new RDoc::Attr +attr_name+ on class +var_name+ that is either +read+, +write+ or both",
        "label": "How-it-is-done",
        "id": "16159"
    },
    {
        "raw_code": "def parse_attributes!\n          self.attributes = (attributes || []).map do |attr|\n            Rails::Generators::GeneratedAttribute.parse(attr)\n          end",
        "comment": "Convert attributes array into GeneratedAttribute objects.",
        "label": "How-it-is-done",
        "id": "14782"
    },
    {
        "raw_code": "def template_result(template, context, template_file)\n    template.filename = template_file.to_s\n    template.result context\n  rescue NoMethodError => e\n    raise RDoc::Error, \"Error while evaluating %s: %s\" % [\n      template_file.expand_path,\n      e.message,\n    ], e.backtrace\n  end",
        "comment": " Creates the result for +template+ with +context+.  If an error is raised a Pathname +template_file+ will indicate the file where the error occurred.",
        "label": "How-it-is-done",
        "id": "16472"
    },
    {
        "raw_code": "def comment(text, top_level = @top_level, language = nil)\n    comment = RDoc::Comment.new text, top_level, language\n    comment\n  end",
        "comment": " Creates an RDoc::Comment with +text+ which was defined on +top_level+. By default the comment has the 'rdoc' format.",
        "label": "How-it-is-done",
        "id": "16873"
    },
    {
        "raw_code": "def initialize(spec, generate_rdoc = false, generate_ri = true)\n    @doc_dir   = spec.doc_dir\n    @force     = false\n    @rdoc      = nil\n    @spec      = spec\n\n    @generate_rdoc = generate_rdoc\n    @generate_ri   = generate_ri\n\n    @rdoc_dir = spec.doc_dir 'rdoc'\n    @ri_dir   = spec.doc_dir 'ri'\n  end",
        "comment": " Creates a new documentation generator for +spec+.  RDoc and ri data generation can be enabled or disabled through +generate_rdoc+ and +generate_ri+ respectively.  Only +generate_ri+ is enabled by default.",
        "label": "How-it-is-done",
        "id": "15900"
    },
    {
        "raw_code": "def self.handles?(statement, processor)\n          processor.globals.cruby_processed_files ||= {}\n          processor.globals.cruby_processed_files[processor.file] = true\n\n          src = statement.respond_to?(:declaration) ?\n            statement.declaration : statement.source\n\n          handlers.any? do |a_handler|\n            statement_class >= statement.class &&\n              case a_handler\n              when String\n                src == a_handler\n              when Regexp\n                src =~ a_handler\n              end",
        "comment": "@return [Boolean] whether the handler handles this statement",
        "label": "How-it-is-done",
        "id": "218"
    },
    {
        "raw_code": "def foo; end\n\n        include Foo\n        extend Bar\n        include BarFooBar\n        include Baz::XYZ\n        include Baz::ABC\n      end",
        "comment": "This method is in A",
        "label": "How-it-is-done",
        "id": "786"
    },
    {
        "raw_code": "def initialize(registry = Registry)\n      @registry = registry\n      @default_sep = nil\n\n      # Preload all code objects for separator declarations\n      YARD::CodeObjects.constants.map {|t| YARD::CodeObjects.const_get(t) }\n    end",
        "comment": "Creates a new resolver object for a registry.  @param registry [Registry] only set this if customizing the registry object",
        "label": "How-it-is-done",
        "id": "115"
    },
    {
        "raw_code": "def find_commit(oid_or_ref)\n    commit = if oid_or_ref.is_a?(Gitlab::Git::Commit)\n               oid_or_ref\n             else\n               Gitlab::Git::Commit.find(raw_repository, oid_or_ref)\n             end",
        "comment": "TODO Genericize finder, later split this on finders by Ref or Oid https://gitlab.com/gitlab-org/gitlab/issues/19877",
        "label": "How-it-is-done",
        "id": "7157"
    },
    {
        "raw_code": "def initialize(text, name, rw, comment, singleton: false)\n    super(text, name, singleton: singleton)\n\n    @rw = rw\n    self.comment = comment\n  end",
        "comment": " Creates a new Attr with body +text+, +name+, read/write status +rw+ and +comment+.  +singleton+ marks this as a class attribute.",
        "label": "How-it-is-done",
        "id": "16701"
    },
    {
        "raw_code": "def compose\n        chars(Unicode.compose(@wrapped_string.codepoints.to_a).pack(\"U*\"))\n      end",
        "comment": "Performs composition on all the characters.  '\u00e9'.length                       # => 1 '\u00e9'.mb_chars.compose.to_s.length # => 1",
        "label": "How-it-is-done",
        "id": "14500"
    },
    {
        "raw_code": "def multipart_part_upload_url(part_number)\n      connection.signed_url({\n        method: 'PUT',\n        bucket_name: bucket_name,\n        object_name: object_name,\n        query: { 'uploadId' => upload_id, 'partNumber' => part_number },\n        headers: upload_options\n      }, expire_at)\n    end",
        "comment": "Implements https://docs.aws.amazon.com/AmazonS3/latest/API/mpUploadUploadPart.html",
        "label": "How-it-is-done",
        "id": "3726"
    },
    {
        "raw_code": "def create_kubernetes_namespace(clusters)\n      clusters.each do |cluster|\n        cluster_project = cluster_projects_table.find_by(cluster_id: cluster.id)\n        project = projects_table.find(cluster_project.project_id)\n        namespace = \"#{project.path}-#{project.id}\"\n\n        cluster_kubernetes_namespaces_table.create!(\n          cluster_project_id: cluster_project.id,\n          cluster_id: cluster.id,\n          project_id: cluster_project.project_id,\n          namespace: namespace,\n          service_account_name: \"#{namespace}-service-account\"\n        )\n      end",
        "comment": "Creates a Kubernetes namespace for a list of clusters",
        "label": "How-it-is-done",
        "id": "8522"
    },
    {
        "raw_code": "def extract_ref_and_format(id)\n    return [id, nil] unless id.match?(/\\.(?:atom|json)$/)\n\n    id, _dot, format = id.rpartition('.')\n    ref = ref_names.find { |ref_name| id == ref_name }\n\n    raise InvalidPathError if ref.blank?\n\n    [ref, format.to_sym]\n  end",
        "comment": "If we have an ID of 'foo.atom' or 'foo.json', and the controller provides Atom, JSON, and HTML formats, then we have to check if the request was for the Atom version of the ID without the '.atom' suffix, the JSON version of the ID without the '.json' suffix, or the HTML version of the ID including the suffix. We only check this if the version including the suffix doesn't match, so it is possible to create a branch which has an unroutable Atom feed or JSON view.",
        "label": "How-it-is-done",
        "id": "1321"
    },
    {
        "raw_code": "def self.create(password=nil)\n          if password\n            raise NotImplementedError,\n                  \"Ed25519 key pair generation does not support passwords\"\n          end",
        "comment": "Creates an ed25519 SSH key pair @return [Array<String, String, String>] Public key, openssh private key, openssh public key with comment @note Password support was not included as it's not actively used anywhere. If it ends up being something that's needed, it can be revisited",
        "label": "How-it-is-done",
        "id": "9174"
    },
    {
        "raw_code": "def distance_of_time_as_hash(diff)\n    diff = diff.abs.floor\n\n    return { seconds: 0 } if diff == 0\n\n    mins = (diff / 60).floor\n    seconds = diff % 60\n    hours = (mins / 60).floor\n    mins %= 60\n    days = (hours / 24).floor\n    hours %= 24\n\n    duration_hash = {}\n\n    duration_hash[:days] = days if days > 0\n    duration_hash[:hours] = hours if hours > 0\n    duration_hash[:mins] = mins if mins > 0\n    duration_hash[:seconds] = seconds if seconds > 0\n\n    duration_hash\n  end",
        "comment": "Converts seconds into a hash such as: { days: 1, hours: 3, mins: 42, seconds: 40 }  It returns 0 seconds for zero or negative numbers It rounds to nearest time unit and does not return zero i.e { min: 1 } instead of { mins: 1, seconds: 0 }",
        "label": "How-it-is-done",
        "id": "6231"
    },
    {
        "raw_code": "def parse_tag_with_types(tag_name, text)\n        name, types, text = *extract_types_and_name_from_text(text)\n        raise TagFormatError, \"cannot specify a name before type list for '@#{tag_name}'\" if name\n        Tag.new(tag_name, text, types)\n      end",
        "comment": "Parses tag text and creates a new tag with formally declared types and descriptive text  @param tag_name        the name of the tag to parse @param [String] text   the raw tag text @return [Tag]          a tag object with the tag_name, types and text values filled",
        "label": "How-it-is-done",
        "id": "231"
    },
    {
        "raw_code": "def initialize(opts = {})\n        super\n        @name_map = nil\n        @basepath = (options[:basepath] || 'doc').to_s\n        @extension = (options.key?(:extension) ? options[:extension] : 'html').to_s\n      end",
        "comment": "Creates a new FileSystemSerializer with options  @option opts [String] :basepath ('doc') the base path to write data to @option opts [String] :extension ('html') the extension of the serialized path filename. If this is set to the empty string, no extension is used.",
        "label": "How-it-is-done",
        "id": "464"
    },
    {
        "raw_code": "def supports_expression_index?\n        false\n      end",
        "comment": "Does this adapter support expression indices?",
        "label": "How-it-is-done",
        "id": "12889"
    },
    {
        "raw_code": "def while_preventing_writes(enabled = true, &block)\n      connected_to(role: current_role, prevent_writes: enabled, &block)\n    end",
        "comment": "Prevent writing to the database regardless of role.  In some cases you may want to prevent writes to the database even if you are on a database that can write. +while_preventing_writes+ will prevent writes to the database for the duration of the block.  This method does not provide the same protection as a readonly user and is meant to be a safeguard against accidental writes.  See +READ_QUERY+ for the queries that are blocked by this method.",
        "label": "How-it-is-done",
        "id": "12403"
    },
    {
        "raw_code": "def foreign_key(class_name, separate_class_name_and_id_with_underscore = true)\n      underscore(demodulize(class_name)) + (separate_class_name_and_id_with_underscore ? \"_id\" : \"id\")\n    end",
        "comment": "Creates a foreign key name from a class name. +separate_class_name_and_id_with_underscore+ sets whether the method should put '_' between the name and 'id'.  foreign_key('Message')        # => \"message_id\" foreign_key('Message', false) # => \"messageid\" foreign_key('Admin::Post')    # => \"post_id\"",
        "label": "How-it-is-done",
        "id": "14473"
    },
    {
        "raw_code": "def gl_loading_icon(inline: false, color: 'dark', size: 'sm', css_class: nil, data: nil)\n    render Pajamas::SpinnerComponent.new(\n      inline: inline,\n      color: color,\n      size: size,\n      class: css_class,\n      data: data\n    )\n  end",
        "comment": "Creates a GitLab UI loading icon/spinner.  Examples: # Default gl_loading_icon  # Sizes gl_loading_icon(size: 'md') gl_loading_icon(size: 'lg') gl_loading_icon(size: 'xl')  # Colors gl_loading_icon(color: 'light')  # Block/Inline gl_loading_icon(inline: true)  # Custom classes gl_loading_icon(css_class: \"foo-bar\")  See also https://gitlab-org.gitlab.io/gitlab-ui/?path=/story/base-loading-icon--default",
        "label": "How-it-is-done",
        "id": "7825"
    },
    {
        "raw_code": "def initialize(name)\n        @name = name\n        @messages = {}\n      end",
        "comment": "Creates a locale for +name+ locale.  @param [String] name the locale name.",
        "label": "How-it-is-done",
        "id": "721"
    },
    {
        "raw_code": "def set_api_client_by_username(username)\n        user_pat = if username == \"gitlab-qa\" && ENV['GITLAB_QA_ACCESS_TOKEN']\n                     ENV['GITLAB_QA_ACCESS_TOKEN']\n                   elsif username == \"gitlab-qa-user1\" && ENV['GITLAB_QA_USER1_ACCESS_TOKEN']\n                     ENV['GITLAB_QA_USER1_ACCESS_TOKEN']\n                   elsif username == \"gitlab-qa-user2\" && ENV['GITLAB_QA_USER2_ACCESS_TOKEN']\n                     ENV['GITLAB_QA_USER2_ACCESS_TOKEN']\n                   else\n                     personal_access_token\n                   end",
        "comment": "Creates an API client using the appropriate personal access token for a given username  @param [String] username The username to create an API client for @return [Runtime::API::Client] API client configured with the user's personal access token",
        "label": "How-it-is-done",
        "id": "4677"
    },
    {
        "raw_code": "def self.handle_configure_dvd(machine, dvd, controller_name)\n          storage_controllers = machine.provider.driver.read_storage_controllers\n          controller = storage_controllers.get_controller(controller_name)\n\n          dvd_metadata = {}\n\n          dvd_location = File.expand_path(dvd.file)\n          dvd_attached = controller.attachments.detect { |a| a[:location] == dvd_location }\n\n          if dvd_attached\n            LOGGER.info(\"No further configuration required for dvd '#{dvd.name}'\")\n            dvd_metadata[:name] = dvd.name\n            dvd_metadata[:port] = dvd_attached[:port]\n            dvd_metadata[:device] = dvd_attached[:device]\n            dvd_metadata[:uuid] = dvd_attached[:uuid]\n            dvd_metadata[:controller] = controller.name\n          else\n            LOGGER.warn(\"DVD '#{dvd.name}' is not connected to guest '#{machine.name}', Vagrant will attempt to connect dvd to guest\")\n            dsk_info = get_next_port(machine, controller)\n            machine.provider.driver.attach_disk(controller.name,\n                                                dsk_info[:port],\n                                                dsk_info[:device],\n                                                \"dvddrive\",\n                                                dvd.file)\n\n            # Refresh the controller information\n            storage_controllers = machine.provider.driver.read_storage_controllers\n            controller = storage_controllers.get_controller(controller_name)\n\n            attachment = controller.attachments.detect { |a| a[:port] == dsk_info[:port] &&\n                                                             a[:device] == dsk_info[:device] }\n\n            dvd_metadata[:name] = dvd.name\n            dvd_metadata[:port] = dsk_info[:port]\n            dvd_metadata[:device] = dsk_info[:device]\n            dvd_metadata[:uuid] = attachment[:uuid]\n            dvd_metadata[:controller] = controller.name\n          end",
        "comment": "Handles all disk configs of type `:dvd`  @param [Vagrant::Machine] machine - the current machine @param [Config::Disk] dvd - the current disk to configure @param [String] controller_name - the name of the storage controller to use @return [Hash] - dvd_metadata",
        "label": "How-it-is-done",
        "id": "9627"
    },
    {
        "raw_code": "def password_field_tag(name = \"password\", value = nil, options = {})\n        text_field_tag(name, value, options.merge(type: :password))\n      end",
        "comment": "Creates a password field, a masked text field that will hide the users input behind a mask character.  ==== Options * <tt>:disabled</tt> - If set to true, the user will not be able to use this input. * <tt>:size</tt> - The number of visible characters that will fit in the input. * <tt>:maxlength</tt> - The maximum number of characters that the browser will allow the user to enter. * Any other key creates standard HTML attributes for the tag.  ==== Examples password_field_tag 'pass' # => <input id=\"pass\" name=\"pass\" type=\"password\" />  password_field_tag 'secret', 'Your secret here' # => <input id=\"secret\" name=\"secret\" type=\"password\" value=\"Your secret here\" />  password_field_tag 'masked', nil, class: 'masked_input_field' # => <input class=\"masked_input_field\" id=\"masked\" name=\"masked\" type=\"password\" />  password_field_tag 'token', '', size: 15 # => <input id=\"token\" name=\"token\" size=\"15\" type=\"password\" value=\"\" />  password_field_tag 'key', nil, maxlength: 16 # => <input id=\"key\" maxlength=\"16\" name=\"key\" type=\"password\" />  password_field_tag 'confirm_pass', nil, disabled: true # => <input disabled=\"disabled\" id=\"confirm_pass\" name=\"confirm_pass\" type=\"password\" />  password_field_tag 'pin', '1234', maxlength: 4, size: 6, class: \"pin_input\" # => <input class=\"pin_input\" id=\"pin\" maxlength=\"4\" name=\"pin\" size=\"6\" type=\"password\" value=\"1234\" />",
        "label": "How-it-is-done",
        "id": "11926"
    },
    {
        "raw_code": "def form_authenticity_token(form_options: {}) # :doc:\n        masked_authenticity_token(form_options: form_options)\n      end",
        "comment": "Creates the authenticity token for the current request.",
        "label": "How-it-is-done",
        "id": "11342"
    },
    {
        "raw_code": "def self.read_file(filename, encoding, force_transcode = false)\n    content = File.open filename, \"rb\" do |f| f.read end\n    content.gsub!(\"\\r\\n\", \"\\n\") if RUBY_PLATFORM =~ /mswin|mingw/\n\n    utf8 = content.sub!(/\\A\\xef\\xbb\\xbf/, '')\n\n    enc = RDoc::Encoding.detect_encoding content\n    content = RDoc::Encoding.change_encoding content, enc if enc\n\n    begin\n      encoding ||= Encoding.default_external\n      orig_encoding = content.encoding\n\n      if not orig_encoding.ascii_compatible? then\n        content = content.encode encoding\n      elsif utf8 then\n        content = RDoc::Encoding.change_encoding content, Encoding::UTF_8\n        content = content.encode encoding\n      else\n        # assume the content is in our output encoding\n        content = RDoc::Encoding.change_encoding content, encoding\n      end",
        "comment": " Reads the contents of +filename+ and handles any encoding directives in the file.  The content will be converted to the +encoding+.  If the file cannot be converted a warning will be printed and nil will be returned.  If +force_transcode+ is true the document will be transcoded and any unknown character in the target encoding will be replaced with '?'",
        "label": "How-it-is-done",
        "id": "15969"
    },
    {
        "raw_code": "def asset_path(source, options = {})\n        raise ArgumentError, \"nil is not a valid asset source\" if source.nil?\n\n        source = source.to_s\n        return \"\" if source.blank?\n        return source if URI_REGEXP.match?(source)\n\n        tail, source = source[/([?#].+)$/], source.sub(/([?#].+)$/, \"\")\n\n        if extname = compute_asset_extname(source, options)\n          source = \"#{source}#{extname}\"\n        end",
        "comment": "This is the entry point for all assets. When using an asset pipeline gem (e.g. propshaft or sprockets-rails), the behavior is \"enhanced\". You can bypass the asset pipeline by passing in <tt>skip_pipeline: true</tt> to the options.  All other asset *_path helpers delegate through this method.  === With the asset pipeline  All options passed to +asset_path+ will be passed to +compute_asset_path+ which is implemented by asset pipeline gems.  asset_path(\"application.js\") # => \"/assets/application-60aa4fdc5cea14baf5400fba1abf4f2a46a5166bad4772b1effe341570f07de9.js\" asset_path('application.js', host: 'example.com') # => \"//example.com/assets/application.js\" asset_path(\"application.js\", host: 'example.com', protocol: 'https') # => \"https://example.com/assets/application.js\"  === Without the asset pipeline (<tt>skip_pipeline: true</tt>)  Accepts a <tt>type</tt> option that can specify the asset's extension. No error checking is done to verify the source passed into +asset_path+ is valid and that the file exists on disk.  asset_path(\"application.js\", skip_pipeline: true)                 # => \"application.js\" asset_path(\"filedoesnotexist.png\", skip_pipeline: true)           # => \"filedoesnotexist.png\" asset_path(\"application\", type: :javascript, skip_pipeline: true) # => \"/javascripts/application.js\" asset_path(\"application\", type: :stylesheet, skip_pipeline: true) # => \"/stylesheets/application.css\"  === Options applying to all assets  Below lists scenarios that apply to +asset_path+ whether or not you're using the asset pipeline.  - All fully qualified URLs are returned immediately. This bypasses the asset pipeline and all other behavior described.  asset_path(\"http://www.example.com/js/xmlhr.js\") # => \"http://www.example.com/js/xmlhr.js\"  - All assets that begin with a forward slash are assumed to be full URLs and will not be expanded. This will bypass the asset pipeline.  asset_path(\"/foo.png\") # => \"/foo.png\"  - All blank strings will be returned immediately. This bypasses the asset pipeline and all other behavior described.  asset_path(\"\") # => \"\"  - If <tt>config.relative_url_root</tt> is specified, all assets will have that root prepended.  Rails.application.config.relative_url_root = \"bar\" asset_path(\"foo.js\", skip_pipeline: true) # => \"bar/foo.js\"  - A different asset host can be specified via <tt>config.action_controller.asset_host</tt> this is commonly used in conjunction with a CDN.  Rails.application.config.action_controller.asset_host = \"assets.example.com\" asset_path(\"foo.js\", skip_pipeline: true) # => \"http://assets.example.com/foo.js\"  - An extension name can be specified manually with <tt>extname</tt>.  asset_path(\"foo\", skip_pipeline: true, extname: \".js\")     # => \"/foo.js\" asset_path(\"foo.css\", skip_pipeline: true, extname: \".js\") # => \"/foo.css.js\"",
        "label": "How-it-is-done",
        "id": "11789"
    },
    {
        "raw_code": "def add_attribute(attribute)\n    return attribute unless @document_self\n\n    # mainly to check for redefinition of an attribute as a method\n    # TODO find a policy for 'attr_reader :foo' + 'def foo=()'\n    register = false\n\n    key = nil\n\n    if attribute.rw.index 'R' then\n      key = attribute.pretty_name\n      known = @methods_hash[key]\n\n      if known then\n        known.comment = attribute.comment if known.comment.empty?\n      elsif registered = @methods_hash[attribute.pretty_name + '='] and\n            RDoc::Attr === registered then\n        registered.rw = 'RW'\n      else\n        @methods_hash[key] = attribute\n        register = true\n      end",
        "comment": " Adds +attribute+ if not already there. If it is (as method(s) or attribute), updates the comment if it was empty.  The attribute is registered only if it defines a new method. For instance, <tt>attr_reader :foo</tt> will not be registered if method +foo+ exists, but <tt>attr_accessor :foo</tt> will be registered if method +foo+ exists, but <tt>foo=</tt> does not.",
        "label": "How-it-is-done",
        "id": "16637"
    },
    {
        "raw_code": "def initialize(parent, title, comment)\n    @parent = parent\n    @title = title ? title.strip : title\n\n    @comments = []\n\n    add_comment comment\n  end",
        "comment": " Creates a new section with +title+ and +comment+",
        "label": "How-it-is-done",
        "id": "16833"
    },
    {
        "raw_code": "def patch(path, **args)\n        process(:patch, path, **args)\n      end",
        "comment": "Performs a PATCH request with the given parameters. See ActionDispatch::Integration::Session#process for more details.",
        "label": "How-it-is-done",
        "id": "11615"
    },
    {
        "raw_code": "def self.supported_events\n      %w[commit merge_request]\n    end",
        "comment": "When these are false GitLab does not create cross reference comments on Jira except when an issue gets transitioned.",
        "label": "How-it-is-done",
        "id": "7639"
    },
    {
        "raw_code": "def self.load_options\n    options_file = File.expand_path '.rdoc_options'\n    return RDoc::Options.new unless File.exist? options_file\n\n    RDoc.load_yaml\n\n    begin\n      options = YAML.safe_load File.read('.rdoc_options'), permitted_classes: [RDoc::Options, Symbol]\n    rescue Psych::SyntaxError\n      raise RDoc::Error, \"#{options_file} is not a valid rdoc options file\"\n    end",
        "comment": " Loads options from .rdoc_options if the file exists, otherwise creates a new RDoc::Options instance.",
        "label": "How-it-is-done",
        "id": "15544"
    },
    {
        "raw_code": "def test_quoted_datetime_local\n        with_timezone_config default: :local do\n          t = Time.now.change(usec: 0).to_datetime\n          assert_equal t.to_fs(:db), @quoter.quoted_date(t)\n        end",
        "comment": " DateTime doesn't define getlocal, so make sure it does nothing",
        "label": "How-it-is-done",
        "id": "13526"
    },
    {
        "raw_code": "def initialize(*addresses)\n        addresses = addresses.flatten\n        options = addresses.extract_options!\n        if options.key?(:cache_nils)\n          options[:skip_nil] = !options.delete(:cache_nils)\n        end",
        "comment": "Creates a new +MemCacheStore+ object, with the given memcached server addresses. Each address is either a host name, or a host-with-port string in the form of \"host_name:port\". For example:  ActiveSupport::Cache::MemCacheStore.new(\"localhost\", \"server-downstairs.localnetwork:8229\")  If no addresses are provided, but <tt>ENV['MEMCACHE_SERVERS']</tt> is defined, it will be used instead. Otherwise, +MemCacheStore+ will connect to localhost:11211 (the default memcached port).",
        "label": "How-it-is-done",
        "id": "14027"
    },
    {
        "raw_code": "def perform_now\n      # Guard against jobs that were persisted before we started counting executions by zeroing out nil counters\n      self.executions = (executions || 0) + 1\n\n      deserialize_arguments_if_needed\n\n      _perform_job\n    rescue Exception => exception\n      handled = rescue_with_handler(exception)\n      return handled if handled\n\n      run_after_discard_procs(exception)\n      raise\n    end",
        "comment": "Performs the job immediately. The job is not sent to the queuing adapter but directly executed by blocking the execution of others until it's finished. +perform_now+ returns the value of your job's +perform+ method.  class MyJob < ActiveJob::Base def perform \"Hello World!\" end end  puts MyJob.new(*args).perform_now # => \"Hello World!\"",
        "label": "How-it-is-done",
        "id": "12126"
    },
    {
        "raw_code": "def foo\n              puts 'bar'\n            end",
        "comment": "Documentation",
        "label": "How-it-is-done",
        "id": "10891"
    },
    {
        "raw_code": "def declarative_enum(enum_mod, use_name: true, use_description: true)\n        graphql_name(enum_mod.name) if use_name\n        description(enum_mod.description) if use_description\n\n        enum_mod.definition.each do |key, content|\n          value(key.to_s.upcase, value: key.to_s, description: content[:description])\n        end",
        "comment": "Registers enum definition by the given DeclarativeEnum module  @param enum_mod [Module] The enum module to be used @param use_name [Boolean] Does not override the name if set `false` @param use_description [Boolean] Does not override the description if set `false`  Example:  class MyEnum < BaseEnum declarative_enum MyDeclarativeEnum end  Disabling descriptions rubocop for a false positive here ",
        "label": "How-it-is-done",
        "id": "6202"
    },
    {
        "raw_code": "def transform_values!\n      return to_enum(:transform_values!) unless block_given?\n      @parameters.transform_values! { |v| yield convert_value_to_parameters(v) }\n      self\n    end",
        "comment": "Performs values transformation and returns the altered `ActionController::Parameters` instance.",
        "label": "How-it-is-done",
        "id": "11375"
    },
    {
        "raw_code": "def label(context = nil)\n    label = aref\n\n    label = [context.aref, label].compact.join '-' if\n      context and context.respond_to? :aref\n\n    label\n  end",
        "comment": " Creates a fully-qualified label which will include the label from +context+.  This helps keep ids unique in HTML.",
        "label": "How-it-is-done",
        "id": "16267"
    },
    {
        "raw_code": "def initialize(store, file, name)\n      @store = store\n      @file  = file\n      @name  = name\n    end",
        "comment": " Creates a new MissingFileError for the missing +file+ for the given +name+ that should have been in the +store+.",
        "label": "How-it-is-done",
        "id": "15840"
    },
    {
        "raw_code": "def initialize label = nil, *parts\n    @label = label\n    @parts = []\n    @parts.concat parts\n  end",
        "comment": " Creates a new ListItem with an optional +label+ containing +parts+",
        "label": "How-it-is-done",
        "id": "16430"
    },
    {
        "raw_code": "def initialize(project_or_group, current_user = nil, params = {})\n      @project_or_group = project_or_group\n      @current_user = current_user\n      @params = params\n    end",
        "comment": "current_user - The user that performs the action params - A hash of parameters",
        "label": "How-it-is-done",
        "id": "5689"
    },
    {
        "raw_code": "def keys(reload = false) load_all if reload; @store.keys end\n\n    # Gets all code objects from the store. Loads the entire database\n    # if +reload+ is +true+\n    #\n    # @param [Boolean] reload if false, does not load the entire database\n    #   before a lookup.\n    # @return [Array<CodeObjects::Base>] all the code objects\n    def values(reload = false) load_all if reload; @store.values end\n\n    # @param [Symbol] type the type to look for\n    # @return [Array<String>] a list of object paths with a given\n    #   {CodeObjects::Base#type}\n    # @since 0.8.0\n    def paths_for_type(type, reload = false)\n      load_all if reload\n      @object_types[type] || []\n    end\n\n    # @param [Symbol] type the type to look for\n    # @return [Array<CodeObjects::Base>] a list of objects with a given\n    #   {CodeObjects::Base#type}\n    # @since 0.8.0\n    def values_for_type(type, reload = false)\n      load_all if reload\n      paths_for_type(type).map {|t| @store[t.to_sym] }\n    end\n\n    # @return [CodeObjects::RootObject] the root object\n    def root; @store[:root] end\n\n    # @param [String] name the locale name.\n    # @return [I18n::Locale] the locale object for +name+.\n    # @since 0.8.3\n    def locale(name)\n      @locales[name] ||= load_locale(name)\n    end\n\n    # @param [String, nil] file the name of the yardoc db to load\n    # @return [Boolean] whether the database was loaded\n    def load(file = nil)\n      initialize\n      @file = file\n      @serializer = Serializers::YardocSerializer.new(@file)\n      load_yardoc\n    end\n\n    # Loads the .yardoc file and loads all cached objects into memory\n    # automatically.\n    #\n    # @param [String, nil] file the name of the yardoc db to load\n    # @return [Boolean] whether the database was loaded\n    # @see #load_all\n    # @since 0.5.1\n    def load!(file = nil)\n      if load(file)\n        load_all\n        true\n      else\n        false\n      end\n    end\n\n    # Loads all cached objects into memory\n    # @return [void]\n    def load_all\n      return unless @file\n      return if @loaded_objects >= @available_objects\n      log.debug \"Loading entire database: #{@file} ...\"\n      objects = []\n\n      all_disk_objects.sort_by(&:size).each do |path|\n        obj = @serializer.deserialize(path, true)\n        objects << obj if obj\n      end\n\n      objects.each do |obj|\n        put(obj.path, obj)\n      end\n\n      @loaded_objects += objects.size\n      log.debug \"Loaded database (file='#{@file}' count=#{objects.size} total=#{@available_objects})\"\n    end",
        "comment": "Gets all path names from the store. Loads the entire database if +reload+ is +true+  @param [Boolean] reload if false, does not load the entire database before a lookup. @return [Array<Symbol>] the path names of all the code objects",
        "label": "How-it-is-done",
        "id": "98"
    },
    {
        "raw_code": "def create_migration_file\n        return if skip_migration_creation?\n        attributes.each { |a| a.attr_options.delete(:index) if a.reference? && !a.has_index? } if options[:indexes] == false\n        migration_template \"create_table_migration.rb\", File.join(db_migrate_path, \"create_#{table_name}.rb\")\n      end",
        "comment": "creates the migration file for the model.",
        "label": "How-it-is-done",
        "id": "13494"
    },
    {
        "raw_code": "def encode_with(coder)\n        coder.represent_map(nil, to_yaml)\n      end",
        "comment": "YAML representation",
        "label": "How-it-is-done",
        "id": "2025"
    },
    {
        "raw_code": "def accessor_start(node)\n          if node.loc.dot\n            node.loc.dot.begin_pos\n          else\n            node.loc.selector.begin_pos\n          end",
        "comment": "This gets the start of the accessor whether it has a dot (e.g. `.first`) or doesn't (e.g. `[0]`)",
        "label": "How-it-is-done",
        "id": "10578"
    },
    {
        "raw_code": "def complete?\n        !@checkpoint_thread.nil? && !@checkpoint_thread.alive?\n      end",
        "comment": "Check has completed",
        "label": "How-it-is-done",
        "id": "9240"
    },
    {
        "raw_code": "def process_and(children)\n          build_bool_query(:must) do |queries|\n            children.each do |child|\n              queries << extract_query(process(child))\n            end",
        "comment": "Processes AND conditions  @param children [Array<ActiveContext::Query>] The child queries to AND together @return [Hash] A bool query with must clauses @example process_and([filter_query, prefix_query]) # => { query: { bool: { must: [...] } } }",
        "label": "How-it-is-done",
        "id": "1133"
    },
    {
        "raw_code": "def execute(batch_size: nil, start: nil, finish: nil)\n          raise 'BatchCount can not be run inside a transaction' if transaction_open?\n\n          batch_size ||= DEFAULT_BATCH_SIZE\n          start = actual_start(start)\n          finish = actual_finish(finish)\n\n          raise WRONG_CONFIGURATION_ERROR if unwanted_configuration?(start, finish, batch_size)\n\n          batch_start = start\n          hll_buckets = Buckets.new\n\n          while batch_start <= finish\n            hll_buckets.merge_hash!(hll_buckets_for_batch(batch_start, batch_start + batch_size))\n            batch_start += batch_size\n            sleep(SLEEP_TIME_IN_SECONDS)\n          end",
        "comment": "Executes counter that iterates over database source and return Gitlab::Database::PostgresHll::Buckets that can be used to estimation of number of uniq elements in analysed set  @param batch_size maximal number of rows that will be analysed by single database query @param start initial pkey range @param finish final pkey range @return [Gitlab::Database::PostgresHll::Buckets] HyperLogLog data structure instance that can estimate number of unique elements",
        "label": "How-it-is-done",
        "id": "3115"
    },
    {
        "raw_code": "def empty?\n    @parts.empty? or (@parts.length == 1 and merged? and @parts.first.empty?)\n  end",
        "comment": " Does this document have no parts?",
        "label": "How-it-is-done",
        "id": "16424"
    },
    {
        "raw_code": "def with_read_consistency(build, &block)\n        ::Gitlab::Database::Consistency\n          .with_read_consistency(&block)\n      end",
        "comment": " Sometime we need to ensure that the first read goes to a primary database, what is especially important in EE. This method does not change the behavior in CE. ",
        "label": "How-it-is-done",
        "id": "7513"
    },
    {
        "raw_code": "def sanitized_note_params(note)\n      MarkdownContentRewriterService\n        .new(current_user, note, :note, from_project, to_noteable.resource_parent)\n        .execute\n    end",
        "comment": "Skip copying cached markdown HTML if text does not contain references or uploads.",
        "label": "How-it-is-done",
        "id": "5979"
    },
    {
        "raw_code": "def simulate_puma_worker\n        # Called in https://github.com/rails/rails/blob/6-1-stable/activerecord/lib/active_record/connection_adapters/pool_config.rb#L73\n        ActiveRecord::ConnectionAdapters::PoolConfig.discard_pools!\n\n        # Called in config/puma.rb\n        Gitlab::Cluster::LifecycleEvents.do_worker_start\n\n        yield\n      end",
        "comment": "We tried using Process.fork for a more realistic simulation but run into bugs where GPRC cannot be used before forking processes. See https://gitlab.com/gitlab-org/gitlab/-/issues/333184#note_1081658113",
        "label": "How-it-is-done",
        "id": "8284"
    },
    {
        "raw_code": "def validate_model_is_not_member\n      model_class = model&.safe_constantize\n      return unless model_class.present? && model_class.new.is_a?(Member)\n\n      errors.add(:model, :invalid, message: 'cannot be a Member')\n    end",
        "comment": "Membership data is handled in `Import::Placeholders::Membership` records instead. Use `Import::PlaceholderMemberships::CreateService` to save the membership data.",
        "label": "How-it-is-done",
        "id": "7694"
    },
    {
        "raw_code": "def anonymous?\n    name.nil?\n  end",
        "comment": "A module may or may not have a name.  module M; end M.name # => \"M\"  m = Module.new m.name # => nil  +anonymous?+ method returns true if module does not have a name, false otherwise:  Module.new.anonymous? # => true  module M; end M.anonymous?          # => false  A module gets a name when it is first assigned to a constant. Either via the +module+ or +class+ keyword or by an explicit assignment:  m = Module.new # creates an anonymous module m.anonymous?   # => true M = m          # m gets a name here as a side-effect m.name         # => \"M\" m.anonymous?   # => false",
        "label": "How-it-is-done",
        "id": "14260"
    },
    {
        "raw_code": "def quick_actions_supported?(_note)\n          false\n        end",
        "comment": "Github does not have support to quick actions in notes (like /assign) Therefore, when importing notes we skip the quick actions processing",
        "label": "How-it-is-done",
        "id": "6100"
    },
    {
        "raw_code": "def handle_cfengine_bootstrap\n        @logger.info(\"Bootstrapping CFEngine...\")\n        if !@machine.guest.capability(:cfengine_needs_bootstrap, @config)\n          @machine.ui.info(I18n.t(\"vagrant.cfengine_no_bootstrap\"))\n          return\n        end",
        "comment": "This handles checking if the CFEngine installation needs to be bootstrapped, and bootstraps if it does.",
        "label": "How-it-is-done",
        "id": "9915"
    },
    {
        "raw_code": "def create_tag(tag_name, tag_buf = '')\n      if tag_buf =~ /\\A\\s*(?:(\\S+)\\s+)?\\(\\s*see\\s+(\\S+)\\s*\\)\\s*\\Z/\n        return create_ref_tag(tag_name, $1, $2)\n      end",
        "comment": "@!group Tag Manipulation Methods Creates a tag from the {Tags::DefaultFactory tag factory}.  To add an already created tag object, append it to {#tags}.  @param [String] tag_name the tag name @param [String] tag_buf the text attached to the tag with newlines removed. @return [Tags::Tag, Tags::RefTag] a tag",
        "label": "How-it-is-done",
        "id": "79"
    },
    {
        "raw_code": "def path_options\n        @path_options ||= default_paths? ? executable_specs : paths\n      end",
        "comment": "Rspec path options  When default path is used, parallel runner will try to split tests based on the amount of spec files found within the path even though rspec tags would end up skipping most of these tests To avoid spawning processes that skip all tests, set spec paths based on example data which takes in to account which tags have been used  @return [Array]",
        "label": "How-it-is-done",
        "id": "4363"
    },
    {
        "raw_code": "def initialize(header, align, body)\n    @header, @align, @body = header, align, body\n  end",
        "comment": "Creates new instance",
        "label": "How-it-is-done",
        "id": "16392"
    },
    {
        "raw_code": "def grouped_options_for_select(grouped_options, selected_key = nil, options = {})\n        prompt  = options[:prompt]\n        divider = options[:divider]\n\n        body = \"\".html_safe\n\n        if prompt\n          body.safe_concat content_tag(\"option\", prompt_text(prompt), value: \"\")\n        end",
        "comment": "Returns a string of <tt><option></tt> tags, like #options_for_select, but wraps them with <tt><optgroup></tt> tags:  grouped_options = [ ['North America', [['United States','US'],'Canada']], ['Europe', ['Denmark','Germany','France']] ] grouped_options_for_select(grouped_options)  grouped_options = { 'North America' => [['United States','US'], 'Canada'], 'Europe' => ['Denmark','Germany','France'] } grouped_options_for_select(grouped_options)  Possible output: <optgroup label=\"North America\"> <option value=\"US\">United States</option> <option value=\"Canada\">Canada</option> </optgroup> <optgroup label=\"Europe\"> <option value=\"Denmark\">Denmark</option> <option value=\"Germany\">Germany</option> <option value=\"France\">France</option> </optgroup>  ==== Parameters  * +grouped_options+ - Accepts a nested array or hash of strings. The first value serves as the <tt><optgroup></tt> label while the second value must be an array of options. The second value can be a nested array of text-value pairs. See <tt>options_for_select</tt> for more info. Ex. [\"North America\",[[\"United States\",\"US\"],[\"Canada\",\"CA\"]]] An optional third value can be provided as HTML attributes for the <tt>optgroup</tt>. Ex. [\"North America\",[[\"United States\",\"US\"],[\"Canada\",\"CA\"]], { disabled: \"disabled\" }] * +selected_key+ - A value equal to the +value+ attribute for one of the <tt><option></tt> tags, which will have the +selected+ attribute set. Note: It is possible for this value to match multiple options as you might have the same option in multiple groups. Each will then get <tt>selected=\"selected\"</tt>.  ==== Options  * <tt>:prompt</tt> - set to true or a prompt string. When the select element doesn't have a value yet, this prepends an option with a generic prompt - \"Please select\" - or the given prompt string. * <tt>:divider</tt> - the divider for the options groups.  grouped_options = [ [['United States','US'], 'Canada'], ['Denmark','Germany','France'] ] grouped_options_for_select(grouped_options, nil, divider: '---------')  Possible output: <optgroup label=\"---------\"> <option value=\"US\">United States</option> <option value=\"Canada\">Canada</option> </optgroup> <optgroup label=\"---------\"> <option value=\"Denmark\">Denmark</option> <option value=\"Germany\">Germany</option> <option value=\"France\">France</option> </optgroup>  <b>Note:</b> Only the <tt><optgroup></tt> and <tt><option></tt> tags are returned, so you still have to wrap the output in an appropriate <tt><select></tt> tag.",
        "label": "How-it-is-done",
        "id": "11906"
    },
    {
        "raw_code": "def track_greatest(new_value)\n      InternalId.internal_id_transactions_increment(operation: :track_greatest, usage: usage)\n\n      function = Arel::Nodes::NamedFunction.new('GREATEST', [arel_table[:last_value], new_value.to_i])\n\n      next_iid = update_record!(subject, scope, usage, function)\n      return next_iid if next_iid\n\n      create_record!(subject, scope, usage, [initial_value(subject, scope), new_value].max)\n    rescue RecordAlreadyExists\n      retry\n    end",
        "comment": "Create a record in internal_ids if one does not yet exist and set its new_value if it is higher than the current last_value",
        "label": "How-it-is-done",
        "id": "7041"
    },
    {
        "raw_code": "def compose_associated_id!(issuable, event)\n          return if event[:event] != 'cross-referenced'\n\n          event[:id] = \"cross-reference##{issuable.iid}-in-#{event.dig(:source, :issue, :id)}\"\n        end",
        "comment": "Cross-referenced events on Github doesn't have id.",
        "label": "How-it-is-done",
        "id": "2210"
    },
    {
        "raw_code": "def render_to_body(options = {})\n    end",
        "comment": "Performs the actual template rendering.",
        "label": "How-it-is-done",
        "id": "11203"
    },
    {
        "raw_code": "def setup_scanner(input)\n    @s = MyStringScanner.new input\n  end",
        "comment": " Creates the StringScanner",
        "label": "How-it-is-done",
        "id": "16315"
    },
    {
        "raw_code": "def raw_execute(sql, name = nil, binds = [], prepare: false, async: false, allow_retry: false, materialize_transactions: true, batch: false)\n          type_casted_binds = type_casted_binds(binds)\n          log(sql, name, binds, type_casted_binds, async: async, allow_retry: allow_retry) do |notification_payload|\n            with_raw_connection(allow_retry: allow_retry, materialize_transactions: materialize_transactions) do |conn|\n              result = perform_query(conn, sql, binds, type_casted_binds, prepare: prepare, notification_payload: notification_payload, batch: batch)\n              handle_warnings(result, sql)\n              result\n            end",
        "comment": "Lowest level way to execute a query. Doesn't check for illegal writes, doesn't annotate queries, yields a native result object.",
        "label": "How-it-is-done",
        "id": "13076"
    },
    {
        "raw_code": "def monotonic_subscribe(pattern = nil, callback = nil, &block)\n        notifier.subscribe(pattern, callback, monotonic: true, &block)\n      end",
        "comment": "Performs the same functionality as #subscribe, but the +start+ and +finish+ block arguments are in monotonic time instead of wall-clock time. Monotonic time will not jump forward or backward (due to NTP or Daylights Savings). Use +monotonic_subscribe+ when accuracy of time duration is important. For example, computing elapsed time between two events.",
        "label": "How-it-is-done",
        "id": "13916"
    },
    {
        "raw_code": "def assign_nested_attributes_for_one_to_one_association(association_name, attributes)\n        if attributes.respond_to?(:permitted?)\n          attributes = attributes.to_h\n        end",
        "comment": "Assigns the given attributes to the association.  If an associated record does not yet exist, one will be instantiated. If an associated record already exists, the method's behavior depends on the value of the update_only option. If update_only is +false+ and the given attributes include an <tt>:id</tt> that matches the existing record's id, then the existing record will be modified. If no <tt>:id</tt> is provided it will be replaced with a new record. If update_only is +true+ the existing record will be modified regardless of whether an <tt>:id</tt> is provided.  If the given attributes include a matching <tt>:id</tt> attribute, or update_only is true, and a <tt>:_destroy</tt> key set to a truthy value, then the existing record will be marked for destruction.",
        "label": "How-it-is-done",
        "id": "12533"
    },
    {
        "raw_code": "def stale_state\n          if through_reflection.belongs_to?\n            Array(through_reflection.foreign_key).filter_map do |foreign_key_column|\n              owner[foreign_key_column]\n            end.presence\n          end",
        "comment": "Note: this does not capture all cases, for example it would be impractical to try to properly support stale-checking for nested associations.",
        "label": "How-it-is-done",
        "id": "12819"
    },
    {
        "raw_code": "def shell_execute(connection, command, **opts)\n        opts = {\n          sudo: false,\n          shell: nil\n        }.merge(opts)\n\n        sudo  = opts[:sudo]\n\n        @logger.info(\"Execute: #{command} (sudo=#{sudo.inspect})\")\n        exit_status = nil\n\n        # These variables are used to scrub PTY output if we're in a PTY\n        pty = false\n        pty_stdout = \"\"\n\n        # Open the channel so we can execute or command\n        channel = connection.open_channel do |ch|\n          if machine_config_ssh.pty\n            ch.request_pty do |ch2, success|\n              pty = success && command != \"\"\n\n              if success\n                @logger.debug(\"pty obtained for connection\")\n              else\n                @logger.warn(\"failed to obtain pty, will try to continue anyways\")\n              end",
        "comment": "Executes the command on an SSH connection within a login shell.",
        "label": "How-it-is-done",
        "id": "9409"
    },
    {
        "raw_code": "def masked_authenticity_token(form_options: {})\n        action, method = form_options.values_at(:action, :method)\n\n        raw_token = if per_form_csrf_tokens && action && method\n          action_path = normalize_action_path(action)\n          per_form_csrf_token(nil, action_path, method)\n        else\n          global_csrf_token\n        end",
        "comment": "Creates a masked version of the authenticity token that varies on each request. The masking is used to mitigate SSL attacks like BREACH.",
        "label": "How-it-is-done",
        "id": "11343"
    },
    {
        "raw_code": "def recover(entry)\n      @lock.synchronize do\n        with_index_lock do\n          # Reload the data\n          unlocked_reload\n          # Don't recover if entry already exists in the global\n          return entry if find_by_prefix(entry.id)\n\n          lock_file = lock_machine(entry.id)\n          if !lock_file\n            raise Errors::MachineLocked,\n              name: entry.name,\n              provider: entry.provider\n          end",
        "comment": "Reinsert a machine into the global index if it has a valid existing uuid but does not currently exist in the index.  @param [Entry] entry @return [Entry]",
        "label": "How-it-is-done",
        "id": "8760"
    },
    {
        "raw_code": "def bare_access_modifier?(node)\n          node.send_type? && node.bare_access_modifier?\n        end",
        "comment": "Not all nodes define `bare_access_modifier?` (for example, `RuboCop::AST::DefNode` does not), so we must check `send_type?` first to avoid a NoMethodError.",
        "label": "How-it-is-done",
        "id": "10352"
    },
    {
        "raw_code": "def sudo(command, opts=nil)\n        end",
        "comment": "Executes a command on the remote machine with administrative privileges. See {#execute} for documentation, as the API is the same.  @see #execute",
        "label": "How-it-is-done",
        "id": "9137"
    },
    {
        "raw_code": "def aref_prefix\n    'method'\n  end",
        "comment": " Prefix for +aref+ is 'method'.",
        "label": "How-it-is-done",
        "id": "16784"
    },
    {
        "raw_code": "def initialize(pool_config)\n        super()\n\n        @pool_config = pool_config\n        @db_config = pool_config.db_config\n        @role = pool_config.role\n        @shard = pool_config.shard\n\n        @checkout_timeout = db_config.checkout_timeout\n        @idle_timeout = db_config.idle_timeout\n        @max_connections = db_config.max_connections\n        @min_connections = db_config.min_connections\n        @max_age = db_config.max_age\n        @keepalive = db_config.keepalive\n\n        # This variable tracks the cache of threads mapped to reserved connections, with the\n        # sole purpose of speeding up the +connection+ method. It is not the authoritative\n        # registry of which thread owns which connection. Connection ownership is tracked by\n        # the +connection.owner+ attr on each +connection+ instance.\n        # The invariant works like this: if there is mapping of <tt>thread => conn</tt>,\n        # then that +thread+ does indeed own that +conn+. However, an absence of such\n        # mapping does not mean that the +thread+ doesn't own the said connection. In\n        # that case +conn.owner+ attr should be consulted.\n        # Access and modification of <tt>@leases</tt> does not require\n        # synchronization.\n        @leases = LeaseRegistry.new\n\n        @connections         = []\n        @automatic_reconnect = true\n\n        # Connection pool allows for concurrent (outside the main +synchronize+ section)\n        # establishment of new connections. This variable tracks the number of threads\n        # currently in the process of independently establishing connections to the DB.\n        @now_connecting = 0\n\n        # Sometimes otherwise-idle connections are temporarily held by the Reaper for\n        # maintenance. This variable tracks the number of connections currently in that\n        # state -- if a thread requests a connection and there are none available, it\n        # will await any in-maintenance connections in preference to creating a new one.\n        @maintaining = 0\n\n        @threads_blocking_new_connections = 0\n\n        @available = ConnectionLeasingQueue.new self\n        @pinned_connection = nil\n        @pinned_connections_depth = 0\n\n        @async_executor = build_async_executor\n\n        @schema_cache = nil\n\n        @activated = false\n        @original_context = ActiveSupport::IsolatedExecutionState.context\n\n        @reaper_lock = Monitor.new\n        @reaper = Reaper.new(self, db_config.reaping_frequency)\n        @reaper.run\n      end",
        "comment": "Creates a new ConnectionPool object. +pool_config+ is a PoolConfig object which describes database connection information (e.g. adapter, host name, username, password, etc), as well as the maximum size for this ConnectionPool.  The default ConnectionPool maximum size is 5.",
        "label": "How-it-is-done",
        "id": "13013"
    },
    {
        "raw_code": "def returned_timeout_value\n        HTML::Pipeline.parse(Banzai::Filter::SanitizeLinkFilter::TIMEOUT_MARKDOWN_MESSAGE)\n      end",
        "comment": "Since this filter does a level of sanitization, we can not return partial un-sanitized results. It's ok to allow any following filters to run since this is safe HTML.",
        "label": "How-it-is-done",
        "id": "3461"
    },
    {
        "raw_code": "def create_vagrantfile\n          File.open(File.join(@env[\"export.temp_dir\"], \"Vagrantfile\"), \"w\") do |f|\n            f.write(TemplateRenderer.render(\"package_Vagrantfile\", {\n              base_mac: @env[:machine].provider.driver.read_mac_address\n            }))\n          end",
        "comment": "This method creates the auto-generated Vagrantfile at the root of the box. This Vagrantfile contains the MAC address so that the user doesn't have to worry about it.",
        "label": "How-it-is-done",
        "id": "9651"
    },
    {
        "raw_code": "def initialize(id)\n        @id = id\n        @locations = Set.new\n        @comments = Set.new\n      end",
        "comment": "Creates a translate target message for message ID +id+.  @param [String] id the message ID of the translate target message.",
        "label": "How-it-is-done",
        "id": "712"
    },
    {
        "raw_code": "def no_repository_fallback(name, fallback: nil, &block)\n      # Avoid unnecessary gRPC invocations\n      return fallback if fallback && fallback_early?(name)\n\n      yield\n    rescue Gitlab::Git::Repository::NoRepository\n      # Even if the `#exists?` check in `fallback_early?` passes, these errors\n      # might still occur (for example because of a non-existing HEAD). We\n      # want to gracefully handle this and not memoize anything.\n      fallback\n    end",
        "comment": "Returns the fallback value if the repository does not exist",
        "label": "How-it-is-done",
        "id": "1713"
    },
    {
        "raw_code": "def shell_execute(connection, command, **opts)\n        opts[:shell] ||= machine_config_ssh.shell\n\n        command = shell_cmd(opts.merge(command: command))\n\n        @logger.info(\"Execute: #{command} - opts: #{opts}\")\n        exit_status = nil\n\n        # Open the channel so we can execute or command\n        channel = connection.open_channel do |ch|\n          marker_found = false\n          data_buffer = ''\n          stderr_marker_found = false\n          stderr_data_buffer = ''\n\n          @logger.debug(\"Base SSH exec command: #{command}\")\n          command = \"$ProgressPreference = 'SilentlyContinue';Write-Output #{CMD_GARBAGE_MARKER};[Console]::Error.WriteLine('#{CMD_GARBAGE_MARKER}');#{command}\"\n\n          ch.exec(command) do |ch2, _|\n            # Setup the channel callbacks so we can get data and exit status\n            ch2.on_data do |ch3, data|\n              # Filter out the clear screen command\n              data = remove_ansi_escape_codes(data)\n\n              if !marker_found\n                data_buffer << data\n                marker_index = data_buffer.index(CMD_GARBAGE_MARKER)\n                if marker_index\n                  marker_found = true\n                  data_buffer.slice!(0, marker_index + CMD_GARBAGE_MARKER.size)\n                  data.replace(data_buffer)\n                  data_buffer = nil\n                end",
        "comment": "Executes the command on an SSH connection within a login shell.",
        "label": "How-it-is-done",
        "id": "9394"
    },
    {
        "raw_code": "def self.[](*hsh)\n    obj = new\n    if hsh.size == 1 && hsh.first.is_a?(Hash)\n      hsh.first.each {|k, v| obj[k] = v }\n    else\n      0.step(hsh.size, 2) {|n| obj[hsh[n]] = hsh[n + 1] }\n    end",
        "comment": "@overload [](hash) Creates a SymbolHash object from an existing Hash  @example SymbolHash['x' => 1, :y => 2] # => #<SymbolHash:0x...> @param [Hash] hash the hash object @return [SymbolHash] a new SymbolHash from a hash object  @overload [](*list) Creates a SymbolHash from an even list of keys and values  @example SymbolHash[key1, value1, key2, value2, ...] @param [Array] list an even list of key followed by value @return [SymbolHash] a new SymbolHash object",
        "label": "How-it-is-done",
        "id": "478"
    },
    {
        "raw_code": "def error(*codes, &block)\n        path = caller_files[1] || File.expand_path($0)\n        result = super\n        codes.each do |c|\n          watch_element(path, :error, code: c, handler: @errors[c])\n        end",
        "comment": "Does everything Sinatra::Base#error does, but it also tells the +Watcher::List+ for the Sinatra application to watch the defined error handler.",
        "label": "How-it-is-done",
        "id": "8642"
    },
    {
        "raw_code": "def use(middleware, *args, &block)\n        path = caller_files[1] || File.expand_path($0)\n        watch_element(path, :middleware, [middleware, args, block])\n        super\n      end",
        "comment": "Does everything Sinatra::Base#use does, but it also tells the +Watcher::List+ for the Sinatra application to watch the middleware being used.",
        "label": "How-it-is-done",
        "id": "8640"
    },
    {
        "raw_code": "def self.get_current_disk(machine, disk, all_disks)\n          current_disk = nil\n          if disk.primary\n            storage_controllers = machine.provider.driver.read_storage_controllers\n            current_disk = storage_controllers.get_primary_attachment\n          else\n            current_disk = all_disks.detect { |d| d[:disk_name] == disk.name }\n          end",
        "comment": "@param [Vagrant::Machine] machine - the current machine @param [Config::Disk] disk - the current disk to configure @param [Array] all_disks - A list of all currently defined disks in VirtualBox @return [Hash] current_disk - Returns the current disk. Returns nil if it doesn't exist",
        "label": "How-it-is-done",
        "id": "9625"
    },
    {
        "raw_code": "def get_tk\n    tk = nil\n\n    if @tokens.empty? then\n      if @scanner_point >= @scanner.size\n        return nil\n      else\n        tk = @scanner[@scanner_point]\n        @scanner_point += 1\n        @read.push tk[:text]\n      end",
        "comment": " Fetches the next token from the scanner",
        "label": "How-it-is-done",
        "id": "16172"
    },
    {
        "raw_code": "def diff_halfMatchI(longtext, shorttext, i)\n    seed = longtext[i, longtext.length / 4]\n    j = -1\n    best_common = ''\n    while j = shorttext.index(seed, j + 1)\n      prefix_length = diff_commonPrefix(longtext[i..-1], shorttext[j..-1])\n      suffix_length = diff_commonSuffix(longtext[0...i], shorttext[0...j])\n      if best_common.length < suffix_length + prefix_length\n        best_common = shorttext[(j - suffix_length)...j] + shorttext[j...(j + prefix_length)]\n        best_longtext_a = longtext[0...(i - suffix_length)]\n        best_longtext_b = longtext[(i + prefix_length)..-1]\n        best_shorttext_a = shorttext[0...(j - suffix_length)]\n        best_shorttext_b = shorttext[(j + prefix_length)..-1]\n      end",
        "comment": "Does a substring of shorttext exist within longtext such that the substring is at least half the length of longtext?",
        "label": "How-it-is-done",
        "id": "5055"
    },
    {
        "raw_code": "def stop_working\n      # no-ops\n    end",
        "comment": "Executed in lock context",
        "label": "How-it-is-done",
        "id": "1512"
    },
    {
        "raw_code": "def handle_cfengine_installation\n        if !@machine.guest.capability?(:cfengine_installed)\n          @machine.ui.warn(I18n.t(\"vagrant.cfengine_cant_detect\"))\n          return\n        end",
        "comment": "This handles verifying the CFEngine installation, installing it if it was requested, and so on. This method will raise exceptions if things are wrong.",
        "label": "How-it-is-done",
        "id": "9916"
    },
    {
        "raw_code": "def date_field_tag(name, value = nil, options = {})\n        text_field_tag(name, value, options.merge(type: :date))\n      end",
        "comment": "Creates a text field of type \"date\".  ==== Options  Supports the same options as #text_field_tag.  ==== Examples  date_field_tag 'name' # => <input id=\"name\" name=\"name\" type=\"date\" />  date_field_tag 'date', '2014-12-31' # => <input id=\"date\" name=\"date\" type=\"date\" value=\"2014-12-31\" />  date_field_tag 'date', nil, class: 'special_input' # => <input class=\"special_input\" id=\"date\" name=\"date\" type=\"date\" />  date_field_tag 'date', '2014-12-31', class: 'special_input', disabled: true # => <input disabled=\"disabled\" class=\"special_input\" id=\"date\" name=\"date\" type=\"date\" value=\"2014-12-31\" />",
        "label": "How-it-is-done",
        "id": "11937"
    },
    {
        "raw_code": "def []=(key, value)\n      regular_writer(convert_key(key), convert_value(value, conversion: :assignment))\n    end",
        "comment": "Assigns a new value to the hash:  hash = ActiveSupport::HashWithIndifferentAccess.new hash[:key] = 'value'  This value can be later fetched using either +:key+ or <tt>'key'</tt>.  If the value is a Hash or contains one or multiple Hashes, they will be converted to +HashWithIndifferentAccess+.",
        "label": "How-it-is-done",
        "id": "13874"
    },
    {
        "raw_code": "def create_metadata\n          File.open(File.join(@env[\"export.temp_dir\"], \"metadata.json\"), \"w\") do |f|\n            f.write(JSON.generate({\n              provider: \"hyperv\"\n            }))\n          end",
        "comment": "This method creates a metadata.json file to tell vagrant this is a Hyper V box",
        "label": "How-it-is-done",
        "id": "9710"
    },
    {
        "raw_code": "def supports_validate_constraints?\n        false\n      end",
        "comment": "Does this adapter support creating invalid constraints?",
        "label": "How-it-is-done",
        "id": "12895"
    },
    {
        "raw_code": "def module?\n    false\n  end",
        "comment": " Does this object represent a module?",
        "label": "How-it-is-done",
        "id": "16754"
    },
    {
        "raw_code": "def discussion_root_note_ids(notes_filter:, sort: :created_asc)\n    sort = :created_asc if sort.nil?\n    relations = []\n\n    relations << discussion_notes.select(\n      \"'notes' AS table_name\",\n      'MIN(id) AS id',\n      'MIN(created_at) AS created_at',\n      'ARRAY_AGG(id) AS ids'\n    ).with_notes_filter(notes_filter)\n     .group(:discussion_id)\n\n    if notes_filter != UserPreference::NOTES_FILTERS[:only_comments]\n      relations += synthetic_note_ids_relations\n    end",
        "comment": "This does not consider OutOfContextDiscussions in MRs where notes from commits are overriden so that they have the same discussion_id",
        "label": "How-it-is-done",
        "id": "7335"
    },
    {
        "raw_code": "def create_shell\n        winrm_info = Helper.winrm_info(@machine)\n\n        WinRMShell.new(\n          winrm_info[:host],\n          winrm_info[:port],\n          @machine.config.winrm\n        )\n      end",
        "comment": "This creates a new WinRMShell based on the information we know about this machine.",
        "label": "How-it-is-done",
        "id": "9405"
    },
    {
        "raw_code": "def prepare_update_statement(o)\n          if o.offset || has_group_by_and_having?(o) ||\n            has_join_sources?(o) && has_limit_or_offset_or_orders?(o)\n            super\n          else\n            o\n          end",
        "comment": "In the simple case, MySQL allows us to place JOINs directly into the UPDATE query. However, this does not allow for LIMIT, OFFSET and ORDER. To support these, we must use a subquery.",
        "label": "How-it-is-done",
        "id": "13479"
    }
]