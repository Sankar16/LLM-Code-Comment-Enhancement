[
    {
        "raw_code": "def self.load_yaml\n    begin\n      gem 'psych'\n    rescue NameError => e # --disable-gems\n      raise unless e.name == :gem\n    rescue Gem::LoadError\n    end",
        "comment": " Loads the best available YAML library.",
        "label": "What",
        "id": "1"
    },
    {
        "raw_code": "def self.home\n    rdoc_dir = begin\n                File.expand_path('~/.rdoc')\n              rescue ArgumentError\n              end",
        "comment": " Searches and returns the directory for settings.  1. <tt>$HOME/.rdoc</tt> directory, if it exists. 2. The +rdoc+ directory under the path specified by the +XDG_DATA_HOME+ environment variable, if it is set. 3. <tt>$HOME/.local/share/rdoc</tt> directory.  Other than the home directory, the containing directory will be created automatically.",
        "label": "How-to-use",
        "id": "2"
    },
    {
        "raw_code": "def set_eoutvar(compiler, eoutvar = '_erbout')\n    super\n\n    compiler.pre_cmd = [\"#{eoutvar} ||= +''\"]\n  end",
        "comment": " Overrides +compiler+ startup to set the +eoutvar+ to an empty string only if it isn't already set.",
        "label": "Property",
        "id": "3"
    },
    {
        "raw_code": "def self.add_post_processor # :nodoc:\n    RDoc::Markup::PreProcess.post_process do |comment, code_object|\n      next unless code_object and\n                  RDoc::Comment === comment and comment.format == 'tomdoc'\n\n      comment.text.gsub!(/(\\A\\s*# )(Public|Internal|Deprecated):\\s+/) do\n        section = code_object.add_section $2\n        code_object.temporary_section = section\n\n        $1\n      end",
        "comment": "Internal: Adds a post-processor which sets the RDoc section based on the comment's status.  Returns nothing.",
        "label": "Property",
        "id": "4"
    },
    {
        "raw_code": "def self.parse(text)\n    parser = new\n\n    parser.tokenize text\n    doc = RDoc::Markup::Document.new\n    parser.parse doc\n    doc\n  end",
        "comment": "Public: Parses TomDoc from text  text - A String containing TomDoc-format text.  Examples  RDoc::TomDoc.parse <<-TOMDOC This method does some things  Returns nothing. TOMDOC # => #<RDoc::Markup::Document:0xXXX @parts=[...], @file=nil>  Returns an RDoc::Markup::Document representing the TomDoc format.",
        "label": "How-it-is-done",
        "id": "5"
    },
    {
        "raw_code": "def self.signature(comment)\n    return unless comment.tomdoc?\n\n    document = comment.parse\n\n    signature = nil\n    found_heading = false\n    found_signature = false\n\n    document.parts.delete_if do |part|\n      next false if found_signature\n\n      found_heading ||=\n        RDoc::Markup::Heading === part && part.text == 'Signature'\n\n      next false unless found_heading\n\n      next true if RDoc::Markup::BlankLine === part\n\n      if RDoc::Markup::Verbatim === part then\n        signature = part\n        found_signature = true\n      end",
        "comment": "Internal: Extracts the Signature section's method signature  comment - An RDoc::Comment that will be parsed and have the signature extracted  Returns a String containing the signature and nil if not",
        "label": "Property",
        "id": "6"
    },
    {
        "raw_code": "def initialize\n    super\n\n    @section      = nil\n    @seen_returns = false\n  end",
        "comment": "Public: Creates a new TomDoc parser.  See also RDoc::Markup::parse",
        "label": "How-it-is-done",
        "id": "7"
    },
    {
        "raw_code": "def build_heading(level)\n    heading = super\n\n    @section = heading.text\n\n    heading\n  end",
        "comment": "Internal: Builds a heading from the token stream  level - The level of heading to create  Returns an RDoc::Markup::Heading",
        "label": "Property",
        "id": "8"
    },
    {
        "raw_code": "def build_verbatim(margin)\n    verbatim = super\n\n    verbatim.format = :ruby if @section == 'Examples'\n\n    verbatim\n  end",
        "comment": "Internal: Builds a verbatim from the token stream.  A verbatim in the Examples section will be marked as in Ruby format.  margin - The indentation from the margin for lines that belong to this verbatim section.  Returns an RDoc::Markup::Verbatim",
        "label": "Property",
        "id": "9"
    },
    {
        "raw_code": "def build_paragraph(margin)\n    p :paragraph_start => margin if @debug\n\n    paragraph = RDoc::Markup::Paragraph.new\n\n    until @tokens.empty? do\n      type, data, = get\n\n      case type\n      when :TEXT then\n        @section = 'Returns' if data =~ /\\A(Returns|Raises)/\n\n        paragraph << data\n      when :NEWLINE then\n        if :TEXT == peek_token[0] then\n          # Lines beginning with 'Raises' in the Returns section should not be\n          # treated as multiline text\n          if 'Returns' == @section and\n            peek_token[1].start_with?('Raises') then\n            break\n          else\n            paragraph << ' '\n          end",
        "comment": "Internal: Builds a paragraph from the token stream  margin - Unused  Returns an RDoc::Markup::Paragraph.",
        "label": "Property",
        "id": "10"
    },
    {
        "raw_code": "def parse_text(parent, indent) # :nodoc:\n    paragraph = build_paragraph indent\n\n    if false == @seen_returns and 'Returns' == @section then\n      @seen_returns = true\n      parent << RDoc::Markup::Heading.new(3, 'Returns')\n      parent << RDoc::Markup::BlankLine.new\n    end",
        "comment": " Detects a section change to \"Returns\" and adds a heading",
        "label": "Property",
        "id": "11"
    },
    {
        "raw_code": "def tokenize(text)\n    text = text.sub(/\\A(Public|Internal|Deprecated):\\s+/, '')\n\n    setup_scanner text\n\n    until @s.eos? do\n      pos = @s.pos\n\n      # leading spaces will be reflected by the column of the next token\n      # the only thing we loose are trailing spaces at the end of the file\n      next if @s.scan(/ +/)\n\n      @tokens << case\n                 when @s.scan(/\\r?\\n/) then\n                   token = [:NEWLINE, @s.matched, *pos]\n                   @s.newline!\n                   token\n                 when @s.scan(/(Examples|Signature)$/) then\n                   @tokens << [:HEADER, 3, *pos]\n\n                   [:TEXT, @s[1], *pos]\n                 when @s.scan(/([:\\w][\\w\\[\\]]*)[ ]+- /) then\n                   [:NOTE, @s[1], *pos]\n                 else\n                   @s.scan(/.*/)\n                   [:TEXT, @s.matched.sub(/\\r$/, ''), *pos]\n                 end",
        "comment": "Internal: Turns text into an Array of tokens  text - A String containing TomDoc-format text.  Returns self.",
        "label": "Property",
        "id": "12"
    },
    {
        "raw_code": "def initialize(context)\n    @context = context\n    @store   = context.store\n\n    @seen = {}\n  end",
        "comment": " Allows cross-references to be created based on the given +context+ (RDoc::Context).",
        "label": "Property",
        "id": "13"
    },
    {
        "raw_code": "def resolve_method(name)\n    ref = nil\n\n    if /#{CLASS_REGEXP_STR}([.#]|::)#{METHOD_REGEXP_STR}/o =~ name then\n      type = $2\n      if '.' == type # will find either #method or ::method\n        method = $3\n      else\n        method = \"#{type}#{$3}\"\n      end",
        "comment": " Returns a method reference to +name+.",
        "label": "Property",
        "id": "14"
    },
    {
        "raw_code": "def resolve(name, text)\n    return @seen[name] if @seen.include? name\n\n    ref = case name\n          when /^\\\\(#{CLASS_REGEXP_STR})$/o then\n            @context.find_symbol $1\n          else\n            @context.find_symbol name\n          end",
        "comment": " Returns a reference to +name+.  If the reference is found and +name+ is not documented +text+ will be returned.  If +name+ is escaped +name+ is returned.  If +name+ is not found +text+ is returned.",
        "label": "Property",
        "id": "15"
    },
    {
        "raw_code": "def initialize(name = :rdoc) # :yield: self\n    defaults\n\n    check_names name\n\n    @name = name\n\n    yield self if block_given?\n\n    define\n  end",
        "comment": " Create an RDoc task with the given name. See the RDoc::Task class overview for documentation.",
        "label": "How-to-use",
        "id": "16"
    },
    {
        "raw_code": "def check_names(names)\n    return unless Hash === names\n\n    invalid_options =\n      names.keys.map { |k| k.to_sym } - [:rdoc, :clobber_rdoc, :rerdoc]\n\n    unless invalid_options.empty? then\n      raise ArgumentError, \"invalid options: #{invalid_options.join ', '}\"\n    end",
        "comment": " Ensures that +names+ only includes names for the :rdoc, :clobber_rdoc and :rerdoc.  If other names are given an ArgumentError is raised.",
        "label": "Property",
        "id": "17"
    },
    {
        "raw_code": "def clobber_task_description\n    \"Remove RDoc HTML files\"\n  end",
        "comment": " Task description for the clobber rdoc task or its renamed equivalent",
        "label": "What",
        "id": "18"
    },
    {
        "raw_code": "def defaults\n    @name = :rdoc\n    @rdoc_files = Rake::FileList.new\n    @rdoc_dir = 'html'\n    @main = nil\n    @title = nil\n    @template = nil\n    @generator = nil\n    @options = []\n  end",
        "comment": " Sets default task values",
        "label": "What",
        "id": "19"
    },
    {
        "raw_code": "def inline_source # :nodoc:\n    warn \"RDoc::Task#inline_source is deprecated\"\n    true\n  end",
        "comment": " All source is inline now.  This method is deprecated",
        "label": "Others",
        "id": "20"
    },
    {
        "raw_code": "def inline_source=(value) # :nodoc:\n    warn \"RDoc::Task#inline_source is deprecated\"\n  end",
        "comment": " All source is inline now.  This method is deprecated",
        "label": "Others",
        "id": "21"
    },
    {
        "raw_code": "def define\n    desc rdoc_task_description\n    task rdoc_task_name\n\n    desc rerdoc_task_description\n    task rerdoc_task_name => [clobber_task_name, rdoc_task_name]\n\n    desc clobber_task_description\n    task clobber_task_name do\n      rm_r @rdoc_dir rescue nil\n    end",
        "comment": " Create the tasks defined by this task lib.",
        "label": "What",
        "id": "22"
    },
    {
        "raw_code": "def option_list\n    result = @options.dup\n    result << \"-o\"       << @rdoc_dir\n    result << \"--main\"   << main      if main\n    result << \"--markup\" << markup    if markup\n    result << \"--title\"  << title     if title\n    result << \"-T\"       << template  if template\n    result << '-f'       << generator if generator\n    result\n  end",
        "comment": " List of options that will be supplied to RDoc",
        "label": "What",
        "id": "23"
    },
    {
        "raw_code": "def before_running_rdoc(&block)\n    @before_running_rdoc = block\n  end",
        "comment": " The block passed to this method will be called just before running the RDoc generator. It is allowed to modify RDoc::Task attributes inside the block.",
        "label": "How-to-use",
        "id": "24"
    },
    {
        "raw_code": "def rdoc_task_description\n    'Build RDoc HTML files'\n  end",
        "comment": " Task description for the rdoc task or its renamed equivalent",
        "label": "What",
        "id": "25"
    },
    {
        "raw_code": "def rerdoc_task_description\n    \"Rebuild RDoc HTML files\"\n  end",
        "comment": " Task description for the rerdoc task or its renamed description",
        "label": "What",
        "id": "26"
    },
    {
        "raw_code": "def coverage_task_description\n    \"Print RDoc coverage report\"\n  end",
        "comment": " Task description for the coverage task or its renamed description",
        "label": "What",
        "id": "27"
    },
    {
        "raw_code": "def check_files\n    @files.delete_if do |file|\n      if File.exist? file then\n        if File.readable? file then\n          false\n        else\n          warn \"file '#{file}' not readable\"\n\n          true\n        end",
        "comment": " Check that the files on the command line exist",
        "label": "What",
        "id": "28"
    },
    {
        "raw_code": "def check_generator\n    if @generator then\n      raise OptionParser::InvalidOption,\n        \"generator already set to #{@generator_name}\"\n    end",
        "comment": " Ensure only one generator is loaded",
        "label": "What",
        "id": "29"
    },
    {
        "raw_code": "def default_title=(string)\n    @title ||= string\n  end",
        "comment": " Set the title, but only if not already set. Used to set the title from a source file, so that a title set from the command line will have the priority.",
        "label": "How-to-use",
        "id": "30"
    },
    {
        "raw_code": "def to_yaml(*options) # :nodoc:\n    encoding = @encoding ? @encoding.name : nil\n\n    yaml = {}\n    yaml['encoding'] = encoding\n    yaml['static_path'] = sanitize_path(@static_path)\n    yaml['rdoc_include'] = sanitize_path(@rdoc_include)\n    yaml['page_dir'] = (sanitize_path([@page_dir]).first if @page_dir)\n\n    ivars = instance_variables.map { |ivar| ivar.to_s[1..-1] }\n    ivars -= SPECIAL\n\n    ivars.sort.each do |ivar|\n      yaml[ivar] = instance_variable_get(\"@#{ivar}\")\n    end",
        "comment": " For dumping YAML",
        "label": "How-to-use",
        "id": "31"
    },
    {
        "raw_code": "def exclude\n    if @exclude.nil? or Regexp === @exclude then\n      # done, #finish is being re-run\n      @exclude\n    elsif !@apply_default_exclude and @exclude.empty? then\n      nil\n    else\n      exclude = @exclude\n      exclude |= DEFAULT_EXCLUDE if @apply_default_exclude\n      Regexp.new(exclude.join(\"|\"))\n    end",
        "comment": " Create a regexp for #exclude",
        "label": "How-to-use",
        "id": "32"
    },
    {
        "raw_code": "def finish\n    if @write_options then\n      write_options\n      exit\n    end",
        "comment": " Completes any unfinished option setup business such as filtering for existent files, creating a regexp for #exclude and setting a default #template.",
        "label": "Others",
        "id": "33"
    },
    {
        "raw_code": "def finish_page_dir\n    return unless @page_dir\n\n    @files << @page_dir\n\n    page_dir = Pathname(@page_dir)\n    begin\n      page_dir = page_dir.expand_path.relative_path_from @root\n    rescue ArgumentError\n      # On Windows, sometimes crosses different drive letters.\n      page_dir = page_dir.expand_path\n    end",
        "comment": " Fixes the page_dir to be relative to the root_dir and adds the page_dir to the files list.",
        "label": "What",
        "id": "34"
    },
    {
        "raw_code": "def generator_descriptions\n    lengths = []\n\n    generators = RDoc::RDoc::GENERATORS.map do |name, generator|\n      lengths << name.length\n\n      description = generator::DESCRIPTION if\n        generator.const_defined? :DESCRIPTION\n\n      [name, description]\n    end",
        "comment": " Returns a properly-space list of generators and their descriptions.",
        "label": "Property",
        "id": "35"
    },
    {
        "raw_code": "def parse(argv)\n    ignore_invalid = true\n\n    argv.insert(0, *ENV['RDOCOPT'].split) if ENV['RDOCOPT']\n\n    opts = OptionParser.new do |opt|\n      @option_parser = opt\n      opt.program_name = File.basename $0\n      opt.version = RDoc::VERSION\n      opt.release = nil\n      opt.summary_indent = ' ' * 4\n      opt.banner = <<-EOF\nUsage: #{opt.program_name} [options] [names...]\n\n  Files are parsed, and the information they contain collected, before any\n  output is produced. This allows cross references between all files to be\n  resolved. If a name is a directory, it is traversed. If no names are\n  specified, all Ruby files in the current directory (and subdirectories) are\n  processed.\n\n  How RDoc generates output depends on the output formatter being used, and on\n  the options you give.\n\n  Options can be specified via the RDOCOPT environment variable, which\n  functions similar to the RUBYOPT environment variable for ruby.\n\n    $ export RDOCOPT=\"--show-hash\"\n\n  will make rdoc show hashes in method links by default.  Command-line options\n  always will override those in RDOCOPT.\n\n  Available formatters:\n\n#{generator_descriptions}\n\n  RDoc understands the following file formats:\n\n      EOF\n\n      parsers = Hash.new { |h, parser| h[parser] = [] }\n\n      RDoc::Parser.parsers.each do |regexp, parser|\n        parsers[parser.name.sub('RDoc::Parser::', '')] << regexp.source\n      end",
        "comment": " Parses command line options.",
        "label": "Others",
        "id": "36"
    },
    {
        "raw_code": "def quiet\n    @verbosity.zero?\n  end",
        "comment": " Don't display progress as we process the files",
        "label": "Why",
        "id": "37"
    },
    {
        "raw_code": "def quiet=(bool)\n    @verbosity = bool ? 0 : 1\n  end",
        "comment": " Set quietness to +bool+",
        "label": "Property",
        "id": "38"
    },
    {
        "raw_code": "def sanitize_path(path)\n    require 'pathname'\n    dot = Pathname.new('.').expand_path\n\n    path.reject do |item|\n      path = Pathname.new(item).expand_path\n      is_reject = nil\n      relative = nil\n      begin\n        relative = path.relative_path_from(dot).to_s\n      rescue ArgumentError\n        # On Windows, sometimes crosses different drive letters.\n        is_reject = true\n      else\n        is_reject = relative.start_with? '..'\n      end",
        "comment": " Removes directories from +path+ that are outside the current directory",
        "label": "Others",
        "id": "39"
    },
    {
        "raw_code": "def setup_generator(generator_name = @generator_name)\n    @generator = @generators[generator_name]\n\n    unless @generator then\n      raise OptionParser::InvalidArgument,\n            \"Invalid output formatter #{generator_name}\"\n    end",
        "comment": " Set up an output generator for the named +generator_name+.  If the found generator responds to :setup_options it will be called with the options instance.  This allows generators to add custom options or set default options.",
        "label": "How-to-use",
        "id": "40"
    },
    {
        "raw_code": "def template_dir_for(template)\n    template_path = File.join 'rdoc', 'generator', 'template', template\n\n    $LOAD_PATH.map do |path|\n      File.join File.expand_path(path), template_path\n    end.find do |dir|\n      File.directory? dir\n    end",
        "comment": " Finds the template dir for +template+",
        "label": "What",
        "id": "41"
    },
    {
        "raw_code": "def visibility=(visibility)\n    case visibility\n    when :all\n      @visibility = :private\n    else\n      @visibility = visibility\n    end",
        "comment": "Sets the minimum visibility of a documented method.  Accepts +:public+, +:protected+, +:private+, +:nodoc+, or +:all+.  When +:all+ is passed, visibility is set to +:private+, similarly to RDOCOPT=\"--all\", see #visibility for more information.",
        "label": "Property",
        "id": "42"
    },
    {
        "raw_code": "def warn(message)\n    super message if @verbosity > 1\n  end",
        "comment": " Displays a warning using Kernel#warn if we're being verbose",
        "label": "What",
        "id": "43"
    },
    {
        "raw_code": "def write_options\n    RDoc.load_yaml\n\n    File.open '.rdoc_options', 'w' do |io|\n      io.set_encoding Encoding::UTF_8\n\n      io.print to_yaml\n    end",
        "comment": " Writes the YAML file .rdoc_options to the current directory containing the parsed options.",
        "label": "What",
        "id": "44"
    },
    {
        "raw_code": "def self.load_options\n    options_file = File.expand_path '.rdoc_options'\n    return RDoc::Options.new unless File.exist? options_file\n\n    RDoc.load_yaml\n\n    begin\n      options = YAML.safe_load File.read('.rdoc_options'), permitted_classes: [RDoc::Options, Symbol]\n    rescue Psych::SyntaxError\n      raise RDoc::Error, \"#{options_file} is not a valid rdoc options file\"\n    end",
        "comment": " Loads options from .rdoc_options if the file exists, otherwise creates a new RDoc::Options instance.",
        "label": "How-it-is-done",
        "id": "45"
    },
    {
        "raw_code": "def self.alias_extension(old_ext, new_ext)\n    old_ext = old_ext.sub(/^\\.(.*)/, '\\1')\n    new_ext = new_ext.sub(/^\\.(.*)/, '\\1')\n\n    parser = can_parse_by_name \"xxx.#{old_ext}\"\n    return false unless parser\n\n    RDoc::Parser.parsers.unshift [/\\.#{new_ext}$/, parser]\n\n    true\n  end",
        "comment": " Alias an extension to another extension. After this call, files ending \"new_ext\" will be parsed using the same parser as \"old_ext\"",
        "label": "How-to-use",
        "id": "46"
    },
    {
        "raw_code": "def self.binary?(file)\n    return false if file =~ /\\.(rdoc|txt)$/\n\n    s = File.read(file, 1024) or return false\n\n    return true if s[0, 2] == Marshal.dump('')[0, 2] or s.index(\"\\x00\")\n\n    mode = 'r:utf-8' # default source encoding has been changed to utf-8\n    s.sub!(/\\A#!.*\\n/, '')     # assume shebang line isn't longer than 1024.\n    encoding = s[/^\\s*\\#\\s*(?:-\\*-\\s*)?(?:en)?coding:\\s*([^\\s;]+?)(?:-\\*-|[\\s;])/, 1]\n    mode = \"rb:#{encoding}\" if encoding\n    s = File.open(file, mode) {|f| f.gets(nil, 1024)}\n\n    not s.valid_encoding?\n  end",
        "comment": " Determines if the file is a \"binary\" file which basically means it has content that an RDoc parser shouldn't try to consume.",
        "label": "What",
        "id": "47"
    },
    {
        "raw_code": "def self.zip?(file)\n    zip_signature = File.read file, 4\n\n    zip_signature == \"PK\\x03\\x04\" or\n      zip_signature == \"PK\\x05\\x06\" or\n      zip_signature == \"PK\\x07\\x08\"\n  rescue\n    false\n  end",
        "comment": " Checks if +file+ is a zip file in disguise.  Signatures from http://www.garykessler.net/library/file_sigs.html",
        "label": "What",
        "id": "48"
    },
    {
        "raw_code": "def self.can_parse(file_name)\n    parser = can_parse_by_name file_name\n\n    # HACK Selenium hides a jar file using a .txt extension\n    return if parser == RDoc::Parser::Simple and zip? file_name\n\n    parser\n  end",
        "comment": " Return a parser that can handle a particular extension",
        "label": "How-to-use",
        "id": "49"
    },
    {
        "raw_code": "def self.can_parse_by_name(file_name)\n    _, parser = RDoc::Parser.parsers.find { |regexp,| regexp =~ file_name }\n\n    # The default parser must not parse binary files\n    ext_name = File.extname file_name\n    return parser if ext_name.empty?\n\n    if parser == RDoc::Parser::Simple and ext_name !~ /txt|rdoc/ then\n      case mode = check_modeline(file_name)\n      when nil, 'rdoc' then # continue\n      else\n        RDoc::Parser.parsers.find { |_, p| return p if mode.casecmp?(p.name[/\\w+\\z/]) }\n        return nil\n      end",
        "comment": " Returns a parser that can handle the extension for +file_name+.  This does not depend upon the file being readable.",
        "label": "How-it-is-done",
        "id": "50"
    },
    {
        "raw_code": "def self.check_modeline(file_name)\n    line = File.open file_name do |io|\n      io.gets\n    end",
        "comment": " Returns the file type from the modeline in +file_name+",
        "label": "Property",
        "id": "51"
    },
    {
        "raw_code": "def self.for(top_level, content, options, stats)\n    file_name = top_level.absolute_name\n    return if binary? file_name\n\n    parser = use_markup content\n\n    unless parser then\n      parse_name = file_name\n\n      # If no extension, look for shebang\n      if file_name !~ /\\.\\w+$/ && content =~ %r{\\A#!(.+)} then\n        shebang = $1\n        case shebang\n        when %r{env\\s+ruby}, %r{/ruby}\n          parse_name = 'dummy.rb'\n        end",
        "comment": " Finds and instantiates the correct parser for the given +file_name+ and +content+.",
        "label": "What",
        "id": "52"
    },
    {
        "raw_code": "def self.parse_files_matching(regexp)\n    RDoc::Parser.parsers.unshift [regexp, self]\n  end",
        "comment": " Record which file types this parser can understand.  It is ok to call this multiple times.",
        "label": "How-to-use",
        "id": "53"
    },
    {
        "raw_code": "def self.remove_modeline(content)\n    content.sub(/\\A.*-\\*-\\s*(.*?\\S)\\s*-\\*-.*\\r?\\n/, '')\n  end",
        "comment": " Removes an emacs-style modeline from the first line of the document",
        "label": "Others",
        "id": "54"
    },
    {
        "raw_code": "def self.use_markup(content)\n    markup = content.lines.first(3).grep(/markup:\\s+(\\w+)/) { $1 }.first\n\n    return unless markup\n\n    # TODO Ruby should be returned only when the filename is correct\n    return RDoc::Parser::Ruby if %w[tomdoc markdown].include? markup\n\n    markup = Regexp.escape markup\n\n    _, selected = RDoc::Parser.parsers.find do |_, parser|\n      /^#{markup}$/i =~ parser.name.sub(/.*:/, '')\n    end",
        "comment": " If there is a <tt>markup: parser_name</tt> comment at the front of the file, use it to determine the parser.  For example:  # markup: rdoc # Class comment can go here  class C end  The comment should appear as the first line of the +content+.  If the content contains a shebang or editor modeline the comment may appear on the second or third line.  Any comment style may be used to hide the markup comment.",
        "label": "Property",
        "id": "55"
    },
    {
        "raw_code": "def initialize(top_level, content, options, stats)\n    @top_level = top_level\n    @top_level.parser = self.class\n    @store = @top_level.store\n\n    @file_name = top_level.absolute_name\n    @content = content\n    @options = options\n    @stats = stats\n\n    @preprocess = RDoc::Markup::PreProcess.new @file_name, @options.rdoc_include\n    @preprocess.options = @options\n  end",
        "comment": " Creates a new Parser storing +top_level+, +file_name+, +content+, +options+ and +stats+ in instance variables.  In +@preprocess+ an RDoc::Markup::PreProcess object is created which allows processing of directives.",
        "label": "How-it-is-done",
        "id": "56"
    },
    {
        "raw_code": "def handle_tab_width(body)\n    if /\\t/ =~ body\n      tab_width = @options.tab_width\n      body.split(/\\n/).map do |line|\n        1 while line.gsub!(/\\t+/) do\n          b, e = $~.offset(0)\n          ' ' * (tab_width * (e-b) - b % tab_width)\n        end",
        "comment": " Normalizes tabs in +body+",
        "label": "How-to-use",
        "id": "57"
    },
    {
        "raw_code": "def self.encode_fallback(character, encoding, fallback)\n    character.encode(encoding, :fallback => { character => fallback },\n                     :undef => :replace, :replace => fallback)\n  end",
        "comment": " Transcodes +character+ to +encoding+ with a +fallback+ character.",
        "label": "How-to-use",
        "id": "58"
    },
    {
        "raw_code": "def expand_tabs(text)\n    expanded = []\n\n    text.each_line do |line|\n      nil while line.gsub!(/(?:\\G|\\r)((?:.{8})*?)([^\\t\\r\\n]{0,7})\\t/) do\n        r = \"#{$1}#{$2}#{' ' * (8 - $2.size)}\"\n        r = RDoc::Encoding.change_encoding r, text.encoding\n        r\n      end",
        "comment": " Expands tab characters in +text+ to eight spaces",
        "label": "Others",
        "id": "59"
    },
    {
        "raw_code": "def flush_left(text)\n    indent = 9999\n\n    text.each_line do |line|\n      line_indent = line =~ /\\S/ || 9999\n      indent = line_indent if indent > line_indent\n    end",
        "comment": " Flush +text+ left based on the shortest line",
        "label": "How-to-use",
        "id": "60"
    },
    {
        "raw_code": "def markup(text)\n    if @store.options\n      locale = @store.options.locale\n    else\n      locale = nil\n    end",
        "comment": " Convert a string in markup format into HTML.  Requires the including class to implement #formatter",
        "label": "What",
        "id": "61"
    },
    {
        "raw_code": "def normalize_comment(text)\n    return text if text.empty?\n\n    case language\n    when :ruby\n      text = strip_hashes text\n    when :c\n      text = strip_stars text\n    end",
        "comment": " Strips hashes, expands tabs then flushes +text+ to the left",
        "label": "Others",
        "id": "62"
    },
    {
        "raw_code": "def parse(text, format = 'rdoc')\n    return text if RDoc::Markup::Document === text\n    return text.parse if RDoc::Comment === text\n\n    text = normalize_comment text # TODO remove, should not be necessary\n\n    return RDoc::Markup::Document.new if text =~ /\\A\\n*\\z/\n\n    MARKUP_FORMAT[format].parse text\n  end",
        "comment": " Normalizes +text+ then builds a RDoc::Markup::Document from it",
        "label": "What",
        "id": "63"
    },
    {
        "raw_code": "def snippet(text, limit = 100)\n    document = parse text\n\n    RDoc::Markup::ToHtmlSnippet.new(options, limit).convert document\n  end",
        "comment": " The first +limit+ characters of +text+ as HTML",
        "label": "How-to-use",
        "id": "64"
    },
    {
        "raw_code": "def strip_hashes(text)\n    return text if text =~ /^(?>\\s*)[^\\#]/\n\n    empty = ''\n    empty = RDoc::Encoding.change_encoding empty, text.encoding\n\n    text.gsub(/^\\s*(#+)/) { $1.tr '#', ' ' }.gsub(/^\\s+$/, empty)\n  end",
        "comment": " Strips leading # characters from +text+",
        "label": "Others",
        "id": "65"
    },
    {
        "raw_code": "def strip_newlines(text)\n    text.gsub(/\\A\\n*(.*?)\\n*\\z/m) do $1 end # block preserves String encoding\n  end",
        "comment": " Strips leading and trailing \\n characters from +text+",
        "label": "Others",
        "id": "66"
    },
    {
        "raw_code": "def strip_stars(text)\n    return text unless text =~ %r%/\\*.*\\*/%m\n\n    encoding = text.encoding\n\n    text = text.gsub %r%Document-method:\\s+[\\w:.#=!?|^&<>~+\\-/*\\%@`\\[\\]]+%, ''\n\n    space = ' '\n    space = RDoc::Encoding.change_encoding space, encoding if encoding\n\n    text.sub!  %r%/\\*+%       do space * $&.length end\n    text.sub!  %r%\\*+/%       do space * $&.length end\n    text.gsub! %r%^[ \\t]*\\*%m do space * $&.length end\n\n    empty = ''\n    empty = RDoc::Encoding.change_encoding empty, encoding if encoding\n    text.gsub(/^\\s+$/, empty)\n  end",
        "comment": " Strips /* */ style comments",
        "label": "What",
        "id": "67"
    },
    {
        "raw_code": "def to_html(text)\n    html = (''.encode text.encoding).dup\n\n    encoded = RDoc::Text::TO_HTML_CHARACTERS[text.encoding]\n\n    s = StringScanner.new text\n    insquotes = false\n    indquotes = false\n    after_word = nil\n\n    until s.eos? do\n      case\n      when s.scan(/<(tt|code)>.*?<\\/\\1>/) then # skip contents of tt\n        html << s.matched.gsub('\\\\\\\\', '\\\\')\n      when s.scan(/<(tt|code)>.*?/) then\n        warn \"mismatched <#{s[1]}> tag\" # TODO signal file/line\n        html << s.matched\n      when s.scan(/<[^>]+\\/?s*>/) then # skip HTML tags\n        html << s.matched\n      when s.scan(/\\\\(\\S)/) then # unhandled suppressed crossref\n        html << s[1]\n        after_word = nil\n      when s.scan(/\\.\\.\\.(\\.?)/) then\n        html << s[1] << encoded[:ellipsis]\n        after_word = nil\n      when s.scan(/\\(c\\)/i) then\n        html << encoded[:copyright]\n        after_word = nil\n      when s.scan(/\\(r\\)/i) then\n        html << encoded[:trademark]\n        after_word = nil\n      when s.scan(/---/) then\n        html << encoded[:em_dash]\n        after_word = nil\n      when s.scan(/--/) then\n        html << encoded[:en_dash]\n        after_word = nil\n      when s.scan(/&quot;|\"/) then\n        html << encoded[indquotes ? :close_dquote : :open_dquote]\n        indquotes = !indquotes\n        after_word = nil\n      when s.scan(/``/) then # backtick double quote\n        html << encoded[:open_dquote]\n        after_word = nil\n      when s.scan(/(?:&#39;|'){2}/) then # tick double quote\n        html << encoded[:close_dquote]\n        after_word = nil\n      when s.scan(/`/) then # backtick\n        if insquotes or after_word\n          html << '`'\n          after_word = false\n        else\n          html << encoded[:open_squote]\n          insquotes = true\n        end",
        "comment": " Converts ampersand, dashes, ellipsis, quotes, copyright and registered trademark symbols in +text+ to properly encoded characters.",
        "label": "Others",
        "id": "68"
    },
    {
        "raw_code": "def wrap(txt, line_len = 76)\n    res = []\n    sp = 0\n    ep = txt.length\n\n    while sp < ep\n      # scan back for a space\n      p = sp + line_len - 1\n      if p >= ep\n        p = ep\n      else\n        while p > sp and txt[p] != ?\\s\n          p -= 1\n        end",
        "comment": " Wraps +txt+ to +line_len+",
        "label": "Property",
        "id": "69"
    },
    {
        "raw_code": "def initialize(str, debug=false)\n      setup_parser(str, debug)\n    end",
        "comment": ":stopdoc: This is distinct from setup_parser so that a standalone parser can redefine #initialize and still have access to the proper parser setup code.",
        "label": "How-to-use",
        "id": "70"
    },
    {
        "raw_code": "def setup_parser(str, debug=false)\n      set_string str, 0\n      @memoizations = Hash.new { |h,k| h[k] = {} }\n      @result = nil\n      @failed_rule = nil\n      @failing_rule_offset = -1\n      @line_offsets = nil\n\n      setup_foreign_grammar\n    end",
        "comment": "Prepares for parsing +str+.  If you define a custom initialize you must call this method before #parse",
        "label": "How-to-use",
        "id": "71"
    },
    {
        "raw_code": "def set_string string, pos\n      @string = string\n      @string_size = string ? string.size : 0\n      @pos = pos\n      @position_line_offsets = nil\n    end",
        "comment": "Sets the string and current parsing position for the parser.",
        "label": "How-to-use",
        "id": "72"
    },
    {
        "raw_code": "def self.extension name\n    EXTENSIONS << name\n\n    define_method \"#{name}?\" do\n      extension? name\n    end",
        "comment": ":section: Extensions  Creates extension methods for the `name` extension to enable and disable the extension and to query if they are active.",
        "label": "How-it-is-done",
        "id": "73"
    },
    {
        "raw_code": "def self.parse markdown\n    parser = new\n\n    parser.parse markdown\n  end",
        "comment": ":section:  Parses the `markdown` document into an RDoc::Document using the default extensions.",
        "label": "What",
        "id": "74"
    },
    {
        "raw_code": "def initialize extensions = DEFAULT_EXTENSIONS, debug = false\n    @debug      = debug\n    @formatter  = RDoc::Markup::ToJoinedParagraph.new\n    @extensions = extensions\n\n    @references          = nil\n    @unlinked_references = nil\n\n    @footnotes       = nil\n    @note_order      = nil\n  end",
        "comment": " Creates a new markdown parser that enables the given +extensions+.",
        "label": "How-it-is-done",
        "id": "75"
    },
    {
        "raw_code": "def emphasis text\n    if text =~ /\\A[a-z\\d.\\/]+\\z/i then\n      \"_#{text}_\"\n    else\n      \"<em>#{text}</em>\"\n    end",
        "comment": " Wraps `text` in emphasis for rdoc inline formatting",
        "label": "How-to-use",
        "id": "76"
    },
    {
        "raw_code": "def extension? name\n    @extensions.include? name\n  end",
        "comment": " :category: Extensions  Is the extension `name` enabled?",
        "label": "Why",
        "id": "77"
    },
    {
        "raw_code": "def extension name, enable\n    if enable then\n      @extensions |= [name]\n    else\n      @extensions -= [name]\n    end",
        "comment": " :category: Extensions  Enables or disables the extension with `name`",
        "label": "What",
        "id": "78"
    },
    {
        "raw_code": "def inner_parse text # :nodoc:\n    parser = clone\n\n    parser.setup_parser text, @debug\n\n    parser.peg_parse\n\n    doc = parser.result\n\n    doc.accept @formatter\n\n    doc.parts\n  end",
        "comment": " Parses `text` in a clone of this parser.  This is used for handling nested lists the same way as markdown_parser.",
        "label": "How-to-use",
        "id": "79"
    },
    {
        "raw_code": "def link_to content, label = content, text = nil\n    raise ParseError, 'enable notes extension' if\n      content.start_with? '^' and label.equal? content\n\n    if ref = @references[label] then\n      \"{#{content}}[#{ref}]\"\n    elsif label.equal? content then\n      \"[#{content}]#{text}\"\n    else\n      \"[#{content}]#{text}[#{label}]\"\n    end",
        "comment": " Finds a link reference for `label` and creates a new link to it with `content` as the link text.  If `label` was not encountered in the reference-gathering parser pass the label and content are reconstructed with the linking `text` (usually whitespace).",
        "label": "What",
        "id": "80"
    },
    {
        "raw_code": "def list_item_from unparsed\n    parsed = inner_parse unparsed.join\n    RDoc::Markup::ListItem.new nil, *parsed\n  end",
        "comment": " Creates an RDoc::Markup::ListItem by parsing the `unparsed` content from the first parsing pass.",
        "label": "How-it-is-done",
        "id": "81"
    },
    {
        "raw_code": "def note label\n    #foottext = \"rdoc-label:foottext-#{label}:footmark-#{label}\"\n\n    #ref.replace foottext if ref = @unlinked_notes.delete(label)\n\n    @notes[label] = foottext\n\n    #\"{^1}[rdoc-label:footmark-#{label}:foottext-#{label}] \"\n  end",
        "comment": " Stores `label` as a note and fills in previously unknown note references.",
        "label": "Others",
        "id": "82"
    },
    {
        "raw_code": "def note_for ref\n    @note_order << ref\n\n    label = @note_order.length\n\n    \"{*#{label}}[rdoc-label:foottext-#{label}:footmark-#{label}]\"\n  end",
        "comment": " Creates a new link for the footnote `reference` and adds the reference to the note order list for proper display at the end of the document.",
        "label": "How-it-is-done",
        "id": "83"
    },
    {
        "raw_code": "def paragraph parts\n    parts = parts.map do |part|\n      if \"\\n\" == part then\n        RDoc::Markup::HardBreak.new\n      else\n        part\n      end",
        "comment": " Creates an RDoc::Markup::Paragraph from `parts` and including extension-specific behavior",
        "label": "How-it-is-done",
        "id": "84"
    },
    {
        "raw_code": "def parse markdown\n    @references          = {}\n    @unlinked_references = {}\n\n    markdown += \"\\n\\n\"\n\n    setup_parser markdown, @debug\n    peg_parse 'References'\n\n    if notes? then\n      @footnotes       = {}\n\n      setup_parser markdown, @debug\n      peg_parse 'Notes'\n\n      # using note_order on the first pass would be a bug\n      @note_order      = []\n    end",
        "comment": " Parses `markdown` into an RDoc::Document",
        "label": "What",
        "id": "85"
    },
    {
        "raw_code": "def reference label, link\n    if ref = @unlinked_references.delete(label) then\n      ref.replace link\n    end",
        "comment": " Stores `label` as a reference to `link` and fills in previously unknown link references.",
        "label": "What",
        "id": "86"
    },
    {
        "raw_code": "def strong text\n    if text =~ /\\A[a-z\\d.\\/-]+\\z/i then\n      \"*#{text}*\"\n    else\n      \"<b>#{text}</b>\"\n    end",
        "comment": " Wraps `text` in strong markup for rdoc inline formatting",
        "label": "How-to-use",
        "id": "87"
    },
    {
        "raw_code": "def strike text\n    if text =~ /\\A[a-z\\d.\\/-]+\\z/i then\n      \"~#{text}~\"\n    else\n      \"<s>#{text}</s>\"\n    end",
        "comment": " Wraps `text` in strike markup for rdoc inline formatting",
        "label": "Others",
        "id": "88"
    },
    {
        "raw_code": "def code text\n    # trim even spaces\n    text = $2 while /\\A( +|\\t+)(.*)\\1\\z/ =~ text\n    # escape unescaped backslash at the end\n    backslash_at_end = \"\\\\\" if /(?<!\\\\)(?:\\\\\\\\)*\\\\\\z/.match?(text)\n    \"<code>#{text}#{backslash_at_end}</code>\"\n  end",
        "comment": " Wraps `text` in code markup for rdoc inline formatting",
        "label": "Others",
        "id": "89"
    },
    {
        "raw_code": "def parse_table_cells(table)\n    # Parse header cells\n    table.header = table.header.map { |cell| parse_cell_inline(cell) }\n\n    # Parse body cells\n    table.body = table.body.map do |row|\n      row.map { |cell| parse_cell_inline(cell) }\n    end",
        "comment": " Parses inline markdown in table cells",
        "label": "Others",
        "id": "90"
    },
    {
        "raw_code": "def parse_cell_inline(text)\n    return text if text.nil? || text.empty?\n\n    # Create a new parser instance for the cell\n    cell_parser = RDoc::Markdown.new(@extensions, @debug)\n\n    # Parse the cell content\n    doc = cell_parser.parse(text)\n\n    # Extract the parsed content\n    if doc && doc.parts && !doc.parts.empty?\n      para = doc.parts.first\n      if para.is_a?(RDoc::Markup::Paragraph)\n        para.parts.join\n      else\n        text\n      end",
        "comment": " Parses inline markdown in a single table cell",
        "label": "How-to-use",
        "id": "91"
    },
    {
        "raw_code": "def setup_foreign_grammar\n    @_grammar_literals = RDoc::Markdown::Literals.new(nil)\n  end",
        "comment": ":stopdoc:",
        "label": "What",
        "id": "92"
    },
    {
        "raw_code": "def _root\n    _tmp = apply(:_Doc)\n    set_failed_rule :_root unless _tmp\n    return _tmp\n  end",
        "comment": "root = Doc",
        "label": "What",
        "id": "93"
    },
    {
        "raw_code": "def _Doc\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = apply(:_BOM)\n      unless _tmp\n        _tmp = true\n        self.pos = _save1\n      end",
        "comment": "Doc = BOM? Block*:a { RDoc::Markup::Document.new(*a.compact) }",
        "label": "What",
        "id": "94"
    },
    {
        "raw_code": "def _Block\n\n    _save = self.pos\n    while true # sequence\n      while true\n        _tmp = _BlankLine()\n        break unless _tmp\n      end",
        "comment": "Block = @BlankLine* (BlockQuote | Verbatim | CodeFence | Table | Note | Reference | HorizontalRule | Heading | OrderedList | BulletList | DefinitionList | HtmlBlock | StyleBlock | Para | Plain)",
        "label": "Others",
        "id": "95"
    },
    {
        "raw_code": "def _Para\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _NonindentSpace()\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Para = @NonindentSpace Inlines:a @BlankLine+ { paragraph a }",
        "label": "Property",
        "id": "96"
    },
    {
        "raw_code": "def _Plain\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_Inlines)\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Plain = Inlines:a { paragraph a }",
        "label": "What",
        "id": "97"
    },
    {
        "raw_code": "def _AtxInline\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = _Newline()\n      _tmp = _tmp ? nil : true\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "AtxInline = !@Newline !(@Sp /#*/ @Sp @Newline) Inline",
        "label": "What",
        "id": "98"
    },
    {
        "raw_code": "def _AtxStart\n\n    _save = self.pos\n    while true # sequence\n      _text_start = self.pos\n      _tmp = scan(/\\G(?-mix:\\#{1,6})/)\n      if _tmp\n        text = get_text(_text_start)\n      end",
        "comment": "AtxStart = < /\\#{1,6}/ > { text.length }",
        "label": "What",
        "id": "99"
    },
    {
        "raw_code": "def _AtxHeading\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_AtxStart)\n      s = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "AtxHeading = AtxStart:s @Spacechar+ AtxInline+:a (@Sp /#*/ @Sp)? @Newline { RDoc::Markup::Heading.new(s, a.join) }",
        "label": "What",
        "id": "100"
    },
    {
        "raw_code": "def _SetextHeading\n\n    _save = self.pos\n    while true # choice\n      _tmp = apply(:_SetextHeading1)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_SetextHeading2)\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_SetextHeading unless _tmp\n    return _tmp\n  end",
        "comment": "SetextHeading = (SetextHeading1 | SetextHeading2)",
        "label": "Property",
        "id": "101"
    },
    {
        "raw_code": "def _SetextBottom1\n\n    _save = self.pos\n    while true # sequence\n      _tmp = scan(/\\G(?-mix:={1,})/)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "SetextBottom1 = /={1,}/ @Newline",
        "label": "What",
        "id": "102"
    },
    {
        "raw_code": "def _SetextBottom2\n\n    _save = self.pos\n    while true # sequence\n      _tmp = scan(/\\G(?-mix:-{1,})/)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "SetextBottom2 = /-{1,}/ @Newline",
        "label": "What",
        "id": "103"
    },
    {
        "raw_code": "def _SetextHeading1\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n\n      _save2 = self.pos\n      while true # sequence\n        _tmp = _RawLine()\n        unless _tmp\n          self.pos = _save2\n          break\n        end",
        "comment": "SetextHeading1 = &(@RawLine SetextBottom1) @StartList:a (!@Endline Inline:b { a << b })+ @Sp @Newline SetextBottom1 { RDoc::Markup::Heading.new(1, a.join) }",
        "label": "What",
        "id": "104"
    },
    {
        "raw_code": "def _SetextHeading2\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n\n      _save2 = self.pos\n      while true # sequence\n        _tmp = _RawLine()\n        unless _tmp\n          self.pos = _save2\n          break\n        end",
        "comment": "SetextHeading2 = &(@RawLine SetextBottom2) @StartList:a (!@Endline Inline:b { a << b })+ @Sp @Newline SetextBottom2 { RDoc::Markup::Heading.new(2, a.join) }",
        "label": "What",
        "id": "105"
    },
    {
        "raw_code": "def _Heading\n\n    _save = self.pos\n    while true # choice\n      _tmp = apply(:_SetextHeading)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_AtxHeading)\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_Heading unless _tmp\n    return _tmp\n  end",
        "comment": "Heading = (SetextHeading | AtxHeading)",
        "label": "Property",
        "id": "106"
    },
    {
        "raw_code": "def _BlockQuote\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_BlockQuoteRaw)\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "BlockQuote = BlockQuoteRaw:a { RDoc::Markup::BlockQuote.new(*a) }",
        "label": "What",
        "id": "107"
    },
    {
        "raw_code": "def _BlockQuoteRaw\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _StartList()\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "BlockQuoteRaw = @StartList:a (\">\" \" \"? Line:l { a << l } (!\">\" !@BlankLine Line:c { a << c })* (@BlankLine:n { a << n })*)+ { inner_parse a.join }",
        "label": "What",
        "id": "108"
    },
    {
        "raw_code": "def _NonblankIndentedLine\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = _BlankLine()\n      _tmp = _tmp ? nil : true\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "NonblankIndentedLine = !@BlankLine IndentedLine",
        "label": "What",
        "id": "109"
    },
    {
        "raw_code": "def _VerbatimChunk\n\n    _save = self.pos\n    while true # sequence\n      _ary = []\n      while true\n        _tmp = _BlankLine()\n        _ary << @result if _tmp\n        break unless _tmp\n      end",
        "comment": "VerbatimChunk = @BlankLine*:a NonblankIndentedLine+:b { a.concat b }",
        "label": "What",
        "id": "110"
    },
    {
        "raw_code": "def _Verbatim\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _ary = []\n      _tmp = apply(:_VerbatimChunk)\n      if _tmp\n        _ary << @result\n        while true\n          _tmp = apply(:_VerbatimChunk)\n          _ary << @result if _tmp\n          break unless _tmp\n        end",
        "comment": "Verbatim = VerbatimChunk+:a { RDoc::Markup::Verbatim.new(*a.flatten) }",
        "label": "What",
        "id": "111"
    },
    {
        "raw_code": "def _HorizontalRule\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _NonindentSpace()\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HorizontalRule = @NonindentSpace (\"*\" @Sp \"*\" @Sp \"*\" (@Sp \"*\")* | \"-\" @Sp \"-\" @Sp \"-\" (@Sp \"-\")* | \"_\" @Sp \"_\" @Sp \"_\" (@Sp \"_\")*) @Sp @Newline @BlankLine+ { RDoc::Markup::Rule.new 1 }",
        "label": "What",
        "id": "112"
    },
    {
        "raw_code": "def _Bullet\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = apply(:_HorizontalRule)\n      _tmp = _tmp ? nil : true\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Bullet = !HorizontalRule @NonindentSpace /[+*-]/ @Spacechar+",
        "label": "What",
        "id": "113"
    },
    {
        "raw_code": "def _BulletList\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = apply(:_Bullet)\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "BulletList = &Bullet (ListTight | ListLoose):a { RDoc::Markup::List.new(:BULLET, *a) }",
        "label": "Property",
        "id": "114"
    },
    {
        "raw_code": "def _ListTight\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _ary = []\n      _tmp = apply(:_ListItemTight)\n      if _tmp\n        _ary << @result\n        while true\n          _tmp = apply(:_ListItemTight)\n          _ary << @result if _tmp\n          break unless _tmp\n        end",
        "comment": "ListTight = ListItemTight+:a @BlankLine* !(Bullet | Enumerator) { a }",
        "label": "Property",
        "id": "115"
    },
    {
        "raw_code": "def _ListLoose\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _StartList()\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ListLoose = @StartList:a (ListItem:b @BlankLine* { a << b })+ { a }",
        "label": "What",
        "id": "116"
    },
    {
        "raw_code": "def _ListItem\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_Bullet)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_Enumerator)\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ListItem = (Bullet | Enumerator) @StartList:a ListBlock:b { a << b } (ListContinuationBlock:c { a.push(*c) })* { list_item_from a }",
        "label": "What",
        "id": "117"
    },
    {
        "raw_code": "def _ListItemTight\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_Bullet)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_Enumerator)\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ListItemTight = (Bullet | Enumerator) ListBlock:a (!@BlankLine ListContinuationBlock:b { a.push(*b) })* !ListContinuationBlock { list_item_from a }",
        "label": "Property",
        "id": "118"
    },
    {
        "raw_code": "def _ListBlock\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = _BlankLine()\n      _tmp = _tmp ? nil : true\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ListBlock = !@BlankLine Line:a ListBlockLine*:c { [a, *c] }",
        "label": "Property",
        "id": "119"
    },
    {
        "raw_code": "def _ListContinuationBlock\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _StartList()\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ListContinuationBlock = @StartList:a @BlankLine* { a << \"\\n\" } (Indent ListBlock:b { a.concat b })+ { a }",
        "label": "What",
        "id": "120"
    },
    {
        "raw_code": "def _Enumerator\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _NonindentSpace()\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Enumerator = @NonindentSpace [0-9]+ \".\" @Spacechar+",
        "label": "What",
        "id": "121"
    },
    {
        "raw_code": "def _OrderedList\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = apply(:_Enumerator)\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "OrderedList = &Enumerator (ListTight | ListLoose):a { RDoc::Markup::List.new(:NUMBER, *a) }",
        "label": "Property",
        "id": "122"
    },
    {
        "raw_code": "def _ListBlockLine\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = _BlankLine()\n      _tmp = _tmp ? nil : true\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ListBlockLine = !@BlankLine !(Indent? (Bullet | Enumerator)) !HorizontalRule OptionallyIndentedLine",
        "label": "Property",
        "id": "123"
    },
    {
        "raw_code": "def _HtmlOpenAnchor\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlOpenAnchor = \"<\" Spnl (\"a\" | \"A\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "124"
    },
    {
        "raw_code": "def _HtmlCloseAnchor\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlCloseAnchor = \"<\" Spnl \"/\" (\"a\" | \"A\") Spnl \">\"",
        "label": "What",
        "id": "125"
    },
    {
        "raw_code": "def _HtmlAnchor\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlOpenAnchor)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlAnchor = HtmlOpenAnchor (HtmlAnchor | !HtmlCloseAnchor .)* HtmlCloseAnchor",
        "label": "What",
        "id": "126"
    },
    {
        "raw_code": "def _HtmlBlockOpenAddress\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenAddress = \"<\" Spnl (\"address\" | \"ADDRESS\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "127"
    },
    {
        "raw_code": "def _HtmlBlockCloseAddress\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseAddress = \"<\" Spnl \"/\" (\"address\" | \"ADDRESS\") Spnl \">\"",
        "label": "What",
        "id": "128"
    },
    {
        "raw_code": "def _HtmlBlockAddress\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenAddress)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockAddress = HtmlBlockOpenAddress (HtmlBlockAddress | !HtmlBlockCloseAddress .)* HtmlBlockCloseAddress",
        "label": "What",
        "id": "129"
    },
    {
        "raw_code": "def _HtmlBlockOpenBlockquote\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenBlockquote = \"<\" Spnl (\"blockquote\" | \"BLOCKQUOTE\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "130"
    },
    {
        "raw_code": "def _HtmlBlockCloseBlockquote\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseBlockquote = \"<\" Spnl \"/\" (\"blockquote\" | \"BLOCKQUOTE\") Spnl \">\"",
        "label": "How-to-use",
        "id": "131"
    },
    {
        "raw_code": "def _HtmlBlockBlockquote\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenBlockquote)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockBlockquote = HtmlBlockOpenBlockquote (HtmlBlockBlockquote | !HtmlBlockCloseBlockquote .)* HtmlBlockCloseBlockquote",
        "label": "What",
        "id": "132"
    },
    {
        "raw_code": "def _HtmlBlockOpenCenter\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenCenter = \"<\" Spnl (\"center\" | \"CENTER\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "133"
    },
    {
        "raw_code": "def _HtmlBlockCloseCenter\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseCenter = \"<\" Spnl \"/\" (\"center\" | \"CENTER\") Spnl \">\"",
        "label": "What",
        "id": "134"
    },
    {
        "raw_code": "def _HtmlBlockCenter\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenCenter)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCenter = HtmlBlockOpenCenter (HtmlBlockCenter | !HtmlBlockCloseCenter .)* HtmlBlockCloseCenter",
        "label": "What",
        "id": "135"
    },
    {
        "raw_code": "def _HtmlBlockOpenDir\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenDir = \"<\" Spnl (\"dir\" | \"DIR\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "136"
    },
    {
        "raw_code": "def _HtmlBlockCloseDir\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseDir = \"<\" Spnl \"/\" (\"dir\" | \"DIR\") Spnl \">\"",
        "label": "What",
        "id": "137"
    },
    {
        "raw_code": "def _HtmlBlockDir\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenDir)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockDir = HtmlBlockOpenDir (HtmlBlockDir | !HtmlBlockCloseDir .)* HtmlBlockCloseDir",
        "label": "What",
        "id": "138"
    },
    {
        "raw_code": "def _HtmlBlockOpenDiv\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenDiv = \"<\" Spnl (\"div\" | \"DIV\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "139"
    },
    {
        "raw_code": "def _HtmlBlockCloseDiv\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseDiv = \"<\" Spnl \"/\" (\"div\" | \"DIV\") Spnl \">\"",
        "label": "What",
        "id": "140"
    },
    {
        "raw_code": "def _HtmlBlockDiv\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenDiv)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockDiv = HtmlBlockOpenDiv (HtmlBlockDiv | !HtmlBlockCloseDiv .)* HtmlBlockCloseDiv",
        "label": "What",
        "id": "141"
    },
    {
        "raw_code": "def _HtmlBlockOpenDl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenDl = \"<\" Spnl (\"dl\" | \"DL\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "142"
    },
    {
        "raw_code": "def _HtmlBlockCloseDl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseDl = \"<\" Spnl \"/\" (\"dl\" | \"DL\") Spnl \">\"",
        "label": "What",
        "id": "143"
    },
    {
        "raw_code": "def _HtmlBlockDl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenDl)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockDl = HtmlBlockOpenDl (HtmlBlockDl | !HtmlBlockCloseDl .)* HtmlBlockCloseDl",
        "label": "What",
        "id": "144"
    },
    {
        "raw_code": "def _HtmlBlockOpenFieldset\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenFieldset = \"<\" Spnl (\"fieldset\" | \"FIELDSET\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "145"
    },
    {
        "raw_code": "def _HtmlBlockCloseFieldset\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseFieldset = \"<\" Spnl \"/\" (\"fieldset\" | \"FIELDSET\") Spnl \">\"",
        "label": "Property",
        "id": "146"
    },
    {
        "raw_code": "def _HtmlBlockFieldset\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenFieldset)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockFieldset = HtmlBlockOpenFieldset (HtmlBlockFieldset | !HtmlBlockCloseFieldset .)* HtmlBlockCloseFieldset",
        "label": "What",
        "id": "147"
    },
    {
        "raw_code": "def _HtmlBlockOpenForm\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenForm = \"<\" Spnl (\"form\" | \"FORM\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "148"
    },
    {
        "raw_code": "def _HtmlBlockCloseForm\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseForm = \"<\" Spnl \"/\" (\"form\" | \"FORM\") Spnl \">\"",
        "label": "What",
        "id": "149"
    },
    {
        "raw_code": "def _HtmlBlockForm\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenForm)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockForm = HtmlBlockOpenForm (HtmlBlockForm | !HtmlBlockCloseForm .)* HtmlBlockCloseForm",
        "label": "What",
        "id": "150"
    },
    {
        "raw_code": "def _HtmlBlockOpenH1\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenH1 = \"<\" Spnl (\"h1\" | \"H1\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "151"
    },
    {
        "raw_code": "def _HtmlBlockCloseH1\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseH1 = \"<\" Spnl \"/\" (\"h1\" | \"H1\") Spnl \">\"",
        "label": "What",
        "id": "152"
    },
    {
        "raw_code": "def _HtmlBlockH1\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenH1)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockH1 = HtmlBlockOpenH1 (HtmlBlockH1 | !HtmlBlockCloseH1 .)* HtmlBlockCloseH1",
        "label": "What",
        "id": "153"
    },
    {
        "raw_code": "def _HtmlBlockOpenH2\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenH2 = \"<\" Spnl (\"h2\" | \"H2\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "154"
    },
    {
        "raw_code": "def _HtmlBlockCloseH2\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseH2 = \"<\" Spnl \"/\" (\"h2\" | \"H2\") Spnl \">\"",
        "label": "What",
        "id": "155"
    },
    {
        "raw_code": "def _HtmlBlockH2\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenH2)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockH2 = HtmlBlockOpenH2 (HtmlBlockH2 | !HtmlBlockCloseH2 .)* HtmlBlockCloseH2",
        "label": "What",
        "id": "156"
    },
    {
        "raw_code": "def _HtmlBlockOpenH3\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenH3 = \"<\" Spnl (\"h3\" | \"H3\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "157"
    },
    {
        "raw_code": "def _HtmlBlockCloseH3\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseH3 = \"<\" Spnl \"/\" (\"h3\" | \"H3\") Spnl \">\"",
        "label": "What",
        "id": "158"
    },
    {
        "raw_code": "def _HtmlBlockH3\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenH3)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockH3 = HtmlBlockOpenH3 (HtmlBlockH3 | !HtmlBlockCloseH3 .)* HtmlBlockCloseH3",
        "label": "What",
        "id": "159"
    },
    {
        "raw_code": "def _HtmlBlockOpenH4\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenH4 = \"<\" Spnl (\"h4\" | \"H4\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "160"
    },
    {
        "raw_code": "def _HtmlBlockCloseH4\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseH4 = \"<\" Spnl \"/\" (\"h4\" | \"H4\") Spnl \">\"",
        "label": "What",
        "id": "161"
    },
    {
        "raw_code": "def _HtmlBlockH4\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenH4)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockH4 = HtmlBlockOpenH4 (HtmlBlockH4 | !HtmlBlockCloseH4 .)* HtmlBlockCloseH4",
        "label": "What",
        "id": "162"
    },
    {
        "raw_code": "def _HtmlBlockOpenH5\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenH5 = \"<\" Spnl (\"h5\" | \"H5\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "163"
    },
    {
        "raw_code": "def _HtmlBlockCloseH5\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseH5 = \"<\" Spnl \"/\" (\"h5\" | \"H5\") Spnl \">\"",
        "label": "What",
        "id": "164"
    },
    {
        "raw_code": "def _HtmlBlockH5\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenH5)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockH5 = HtmlBlockOpenH5 (HtmlBlockH5 | !HtmlBlockCloseH5 .)* HtmlBlockCloseH5",
        "label": "What",
        "id": "165"
    },
    {
        "raw_code": "def _HtmlBlockOpenH6\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenH6 = \"<\" Spnl (\"h6\" | \"H6\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "166"
    },
    {
        "raw_code": "def _HtmlBlockCloseH6\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseH6 = \"<\" Spnl \"/\" (\"h6\" | \"H6\") Spnl \">\"",
        "label": "What",
        "id": "167"
    },
    {
        "raw_code": "def _HtmlBlockH6\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenH6)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockH6 = HtmlBlockOpenH6 (HtmlBlockH6 | !HtmlBlockCloseH6 .)* HtmlBlockCloseH6",
        "label": "What",
        "id": "168"
    },
    {
        "raw_code": "def _HtmlBlockOpenMenu\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenMenu = \"<\" Spnl (\"menu\" | \"MENU\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "169"
    },
    {
        "raw_code": "def _HtmlBlockCloseMenu\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseMenu = \"<\" Spnl \"/\" (\"menu\" | \"MENU\") Spnl \">\"",
        "label": "What",
        "id": "170"
    },
    {
        "raw_code": "def _HtmlBlockMenu\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenMenu)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockMenu = HtmlBlockOpenMenu (HtmlBlockMenu | !HtmlBlockCloseMenu .)* HtmlBlockCloseMenu",
        "label": "What",
        "id": "171"
    },
    {
        "raw_code": "def _HtmlBlockOpenNoframes\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenNoframes = \"<\" Spnl (\"noframes\" | \"NOFRAMES\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "172"
    },
    {
        "raw_code": "def _HtmlBlockCloseNoframes\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseNoframes = \"<\" Spnl \"/\" (\"noframes\" | \"NOFRAMES\") Spnl \">\"",
        "label": "What",
        "id": "173"
    },
    {
        "raw_code": "def _HtmlBlockNoframes\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenNoframes)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockNoframes = HtmlBlockOpenNoframes (HtmlBlockNoframes | !HtmlBlockCloseNoframes .)* HtmlBlockCloseNoframes",
        "label": "What",
        "id": "174"
    },
    {
        "raw_code": "def _HtmlBlockOpenNoscript\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenNoscript = \"<\" Spnl (\"noscript\" | \"NOSCRIPT\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "175"
    },
    {
        "raw_code": "def _HtmlBlockCloseNoscript\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseNoscript = \"<\" Spnl \"/\" (\"noscript\" | \"NOSCRIPT\") Spnl \">\"",
        "label": "What",
        "id": "176"
    },
    {
        "raw_code": "def _HtmlBlockNoscript\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenNoscript)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockNoscript = HtmlBlockOpenNoscript (HtmlBlockNoscript | !HtmlBlockCloseNoscript .)* HtmlBlockCloseNoscript",
        "label": "What",
        "id": "177"
    },
    {
        "raw_code": "def _HtmlBlockOpenOl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenOl = \"<\" Spnl (\"ol\" | \"OL\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "178"
    },
    {
        "raw_code": "def _HtmlBlockCloseOl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseOl = \"<\" Spnl \"/\" (\"ol\" | \"OL\") Spnl \">\"",
        "label": "What",
        "id": "179"
    },
    {
        "raw_code": "def _HtmlBlockOl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenOl)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOl = HtmlBlockOpenOl (HtmlBlockOl | !HtmlBlockCloseOl .)* HtmlBlockCloseOl",
        "label": "What",
        "id": "180"
    },
    {
        "raw_code": "def _HtmlBlockOpenP\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenP = \"<\" Spnl (\"p\" | \"P\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "181"
    },
    {
        "raw_code": "def _HtmlBlockCloseP\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseP = \"<\" Spnl \"/\" (\"p\" | \"P\") Spnl \">\"",
        "label": "Property",
        "id": "182"
    },
    {
        "raw_code": "def _HtmlBlockP\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenP)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockP = HtmlBlockOpenP (HtmlBlockP | !HtmlBlockCloseP .)* HtmlBlockCloseP",
        "label": "What",
        "id": "183"
    },
    {
        "raw_code": "def _HtmlBlockOpenPre\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenPre = \"<\" Spnl (\"pre\" | \"PRE\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "184"
    },
    {
        "raw_code": "def _HtmlBlockClosePre\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockClosePre = \"<\" Spnl \"/\" (\"pre\" | \"PRE\") Spnl \">\"",
        "label": "Property",
        "id": "185"
    },
    {
        "raw_code": "def _HtmlBlockPre\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenPre)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockPre = HtmlBlockOpenPre (HtmlBlockPre | !HtmlBlockClosePre .)* HtmlBlockClosePre",
        "label": "What",
        "id": "186"
    },
    {
        "raw_code": "def _HtmlBlockOpenTable\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenTable = \"<\" Spnl (\"table\" | \"TABLE\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "187"
    },
    {
        "raw_code": "def _HtmlBlockCloseTable\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseTable = \"<\" Spnl \"/\" (\"table\" | \"TABLE\") Spnl \">\"",
        "label": "What",
        "id": "188"
    },
    {
        "raw_code": "def _HtmlBlockTable\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenTable)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockTable = HtmlBlockOpenTable (HtmlBlockTable | !HtmlBlockCloseTable .)* HtmlBlockCloseTable",
        "label": "What",
        "id": "189"
    },
    {
        "raw_code": "def _HtmlBlockOpenUl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenUl = \"<\" Spnl (\"ul\" | \"UL\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "190"
    },
    {
        "raw_code": "def _HtmlBlockCloseUl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseUl = \"<\" Spnl \"/\" (\"ul\" | \"UL\") Spnl \">\"",
        "label": "What",
        "id": "191"
    },
    {
        "raw_code": "def _HtmlBlockUl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenUl)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockUl = HtmlBlockOpenUl (HtmlBlockUl | !HtmlBlockCloseUl .)* HtmlBlockCloseUl",
        "label": "What",
        "id": "192"
    },
    {
        "raw_code": "def _HtmlBlockOpenDd\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenDd = \"<\" Spnl (\"dd\" | \"DD\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "193"
    },
    {
        "raw_code": "def _HtmlBlockCloseDd\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseDd = \"<\" Spnl \"/\" (\"dd\" | \"DD\") Spnl \">\"",
        "label": "What",
        "id": "194"
    },
    {
        "raw_code": "def _HtmlBlockDd\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenDd)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockDd = HtmlBlockOpenDd (HtmlBlockDd | !HtmlBlockCloseDd .)* HtmlBlockCloseDd",
        "label": "What",
        "id": "195"
    },
    {
        "raw_code": "def _HtmlBlockOpenDt\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenDt = \"<\" Spnl (\"dt\" | \"DT\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "196"
    },
    {
        "raw_code": "def _HtmlBlockCloseDt\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseDt = \"<\" Spnl \"/\" (\"dt\" | \"DT\") Spnl \">\"",
        "label": "What",
        "id": "197"
    },
    {
        "raw_code": "def _HtmlBlockDt\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenDt)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockDt = HtmlBlockOpenDt (HtmlBlockDt | !HtmlBlockCloseDt .)* HtmlBlockCloseDt",
        "label": "What",
        "id": "198"
    },
    {
        "raw_code": "def _HtmlBlockOpenFrameset\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenFrameset = \"<\" Spnl (\"frameset\" | \"FRAMESET\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "199"
    },
    {
        "raw_code": "def _HtmlBlockCloseFrameset\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseFrameset = \"<\" Spnl \"/\" (\"frameset\" | \"FRAMESET\") Spnl \">\"",
        "label": "Property",
        "id": "200"
    },
    {
        "raw_code": "def _HtmlBlockFrameset\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenFrameset)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockFrameset = HtmlBlockOpenFrameset (HtmlBlockFrameset | !HtmlBlockCloseFrameset .)* HtmlBlockCloseFrameset",
        "label": "What",
        "id": "201"
    },
    {
        "raw_code": "def _HtmlBlockOpenLi\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenLi = \"<\" Spnl (\"li\" | \"LI\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "202"
    },
    {
        "raw_code": "def _HtmlBlockCloseLi\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseLi = \"<\" Spnl \"/\" (\"li\" | \"LI\") Spnl \">\"",
        "label": "What",
        "id": "203"
    },
    {
        "raw_code": "def _HtmlBlockLi\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenLi)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockLi = HtmlBlockOpenLi (HtmlBlockLi | !HtmlBlockCloseLi .)* HtmlBlockCloseLi",
        "label": "What",
        "id": "204"
    },
    {
        "raw_code": "def _HtmlBlockOpenTbody\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenTbody = \"<\" Spnl (\"tbody\" | \"TBODY\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "205"
    },
    {
        "raw_code": "def _HtmlBlockCloseTbody\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseTbody = \"<\" Spnl \"/\" (\"tbody\" | \"TBODY\") Spnl \">\"",
        "label": "What",
        "id": "206"
    },
    {
        "raw_code": "def _HtmlBlockTbody\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenTbody)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockTbody = HtmlBlockOpenTbody (HtmlBlockTbody | !HtmlBlockCloseTbody .)* HtmlBlockCloseTbody",
        "label": "What",
        "id": "207"
    },
    {
        "raw_code": "def _HtmlBlockOpenTd\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenTd = \"<\" Spnl (\"td\" | \"TD\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "208"
    },
    {
        "raw_code": "def _HtmlBlockCloseTd\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseTd = \"<\" Spnl \"/\" (\"td\" | \"TD\") Spnl \">\"",
        "label": "What",
        "id": "209"
    },
    {
        "raw_code": "def _HtmlBlockTd\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenTd)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockTd = HtmlBlockOpenTd (HtmlBlockTd | !HtmlBlockCloseTd .)* HtmlBlockCloseTd",
        "label": "What",
        "id": "210"
    },
    {
        "raw_code": "def _HtmlBlockOpenTfoot\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenTfoot = \"<\" Spnl (\"tfoot\" | \"TFOOT\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "211"
    },
    {
        "raw_code": "def _HtmlBlockCloseTfoot\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseTfoot = \"<\" Spnl \"/\" (\"tfoot\" | \"TFOOT\") Spnl \">\"",
        "label": "What",
        "id": "212"
    },
    {
        "raw_code": "def _HtmlBlockTfoot\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenTfoot)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockTfoot = HtmlBlockOpenTfoot (HtmlBlockTfoot | !HtmlBlockCloseTfoot .)* HtmlBlockCloseTfoot",
        "label": "What",
        "id": "213"
    },
    {
        "raw_code": "def _HtmlBlockOpenTh\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenTh = \"<\" Spnl (\"th\" | \"TH\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "214"
    },
    {
        "raw_code": "def _HtmlBlockCloseTh\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseTh = \"<\" Spnl \"/\" (\"th\" | \"TH\") Spnl \">\"",
        "label": "What",
        "id": "215"
    },
    {
        "raw_code": "def _HtmlBlockTh\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenTh)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockTh = HtmlBlockOpenTh (HtmlBlockTh | !HtmlBlockCloseTh .)* HtmlBlockCloseTh",
        "label": "What",
        "id": "216"
    },
    {
        "raw_code": "def _HtmlBlockOpenThead\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenThead = \"<\" Spnl (\"thead\" | \"THEAD\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "217"
    },
    {
        "raw_code": "def _HtmlBlockCloseThead\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseThead = \"<\" Spnl \"/\" (\"thead\" | \"THEAD\") Spnl \">\"",
        "label": "What",
        "id": "218"
    },
    {
        "raw_code": "def _HtmlBlockThead\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenThead)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockThead = HtmlBlockOpenThead (HtmlBlockThead | !HtmlBlockCloseThead .)* HtmlBlockCloseThead",
        "label": "What",
        "id": "219"
    },
    {
        "raw_code": "def _HtmlBlockOpenTr\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenTr = \"<\" Spnl (\"tr\" | \"TR\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "220"
    },
    {
        "raw_code": "def _HtmlBlockCloseTr\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseTr = \"<\" Spnl \"/\" (\"tr\" | \"TR\") Spnl \">\"",
        "label": "What",
        "id": "221"
    },
    {
        "raw_code": "def _HtmlBlockTr\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenTr)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockTr = HtmlBlockOpenTr (HtmlBlockTr | !HtmlBlockCloseTr .)* HtmlBlockCloseTr",
        "label": "What",
        "id": "222"
    },
    {
        "raw_code": "def _HtmlBlockOpenScript\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenScript = \"<\" Spnl (\"script\" | \"SCRIPT\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "223"
    },
    {
        "raw_code": "def _HtmlBlockCloseScript\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseScript = \"<\" Spnl \"/\" (\"script\" | \"SCRIPT\") Spnl \">\"",
        "label": "What",
        "id": "224"
    },
    {
        "raw_code": "def _HtmlBlockScript\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenScript)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockScript = HtmlBlockOpenScript (!HtmlBlockCloseScript .)* HtmlBlockCloseScript",
        "label": "What",
        "id": "225"
    },
    {
        "raw_code": "def _HtmlBlockOpenHead\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockOpenHead = \"<\" Spnl (\"head\" | \"HEAD\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "226"
    },
    {
        "raw_code": "def _HtmlBlockCloseHead\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockCloseHead = \"<\" Spnl \"/\" (\"head\" | \"HEAD\") Spnl \">\"",
        "label": "What",
        "id": "227"
    },
    {
        "raw_code": "def _HtmlBlockHead\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_HtmlBlockOpenHead)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockHead = HtmlBlockOpenHead (!HtmlBlockCloseHead .)* HtmlBlockCloseHead",
        "label": "What",
        "id": "228"
    },
    {
        "raw_code": "def _HtmlBlockInTags\n\n    _save = self.pos\n    while true # choice\n      _tmp = apply(:_HtmlAnchor)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockAddress)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockBlockquote)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockCenter)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockDir)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockDiv)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockDl)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockFieldset)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockForm)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockH1)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockH2)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockH3)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockH4)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockH5)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockH6)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockMenu)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockNoframes)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockNoscript)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockOl)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockP)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockPre)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockTable)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockUl)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockDd)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockDt)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockFrameset)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockLi)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockTbody)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockTd)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockTfoot)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockTh)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockThead)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockTr)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockScript)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_HtmlBlockHead)\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_HtmlBlockInTags unless _tmp\n    return _tmp\n  end",
        "comment": "HtmlBlockInTags = (HtmlAnchor | HtmlBlockAddress | HtmlBlockBlockquote | HtmlBlockCenter | HtmlBlockDir | HtmlBlockDiv | HtmlBlockDl | HtmlBlockFieldset | HtmlBlockForm | HtmlBlockH1 | HtmlBlockH2 | HtmlBlockH3 | HtmlBlockH4 | HtmlBlockH5 | HtmlBlockH6 | HtmlBlockMenu | HtmlBlockNoframes | HtmlBlockNoscript | HtmlBlockOl | HtmlBlockP | HtmlBlockPre | HtmlBlockTable | HtmlBlockUl | HtmlBlockDd | HtmlBlockDt | HtmlBlockFrameset | HtmlBlockLi | HtmlBlockTbody | HtmlBlockTd | HtmlBlockTfoot | HtmlBlockTh | HtmlBlockThead | HtmlBlockTr | HtmlBlockScript | HtmlBlockHead)",
        "label": "Others",
        "id": "229"
    },
    {
        "raw_code": "def _HtmlBlock\n\n    _save = self.pos\n    while true # sequence\n      _text_start = self.pos\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_HtmlBlockInTags)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_HtmlComment)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_HtmlBlockSelfClosing)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_HtmlUnclosed)\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      if _tmp\n        text = get_text(_text_start)\n      end",
        "comment": "HtmlBlock = < (HtmlBlockInTags | HtmlComment | HtmlBlockSelfClosing | HtmlUnclosed) > @BlankLine+ { if html? then                 RDoc::Markup::Raw.new text               end }",
        "label": "What",
        "id": "230"
    },
    {
        "raw_code": "def _HtmlUnclosed\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlUnclosed = \"<\" Spnl HtmlUnclosedType Spnl HtmlAttribute* Spnl \">\"",
        "label": "Property",
        "id": "231"
    },
    {
        "raw_code": "def _HtmlUnclosedType\n\n    _save = self.pos\n    while true # choice\n      _tmp = match_string(\"HR\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"hr\")\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_HtmlUnclosedType unless _tmp\n    return _tmp\n  end",
        "comment": "HtmlUnclosedType = (\"HR\" | \"hr\")",
        "label": "Why",
        "id": "232"
    },
    {
        "raw_code": "def _HtmlBlockSelfClosing\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlBlockSelfClosing = \"<\" Spnl HtmlBlockType Spnl HtmlAttribute* \"/\" Spnl \">\"",
        "label": "Property",
        "id": "233"
    },
    {
        "raw_code": "def _HtmlBlockType\n\n    _save = self.pos\n    while true # choice\n      _tmp = match_string(\"ADDRESS\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"BLOCKQUOTE\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"CENTER\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"DD\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"DIR\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"DIV\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"DL\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"DT\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"FIELDSET\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"FORM\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"FRAMESET\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"H1\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"H2\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"H3\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"H4\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"H5\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"H6\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"HR\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"ISINDEX\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"LI\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"MENU\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"NOFRAMES\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"NOSCRIPT\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"OL\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"P\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"PRE\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"SCRIPT\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"TABLE\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"TBODY\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"TD\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"TFOOT\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"TH\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"THEAD\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"TR\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"UL\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"address\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"blockquote\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"center\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"dd\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"dir\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"div\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"dl\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"dt\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"fieldset\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"form\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"frameset\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"h1\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"h2\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"h3\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"h4\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"h5\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"h6\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"hr\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"isindex\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"li\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"menu\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"noframes\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"noscript\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"ol\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"p\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"pre\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"script\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"table\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"tbody\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"td\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"tfoot\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"th\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"thead\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"tr\")\n      break if _tmp\n      self.pos = _save\n      _tmp = match_string(\"ul\")\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_HtmlBlockType unless _tmp\n    return _tmp\n  end",
        "comment": "HtmlBlockType = (\"ADDRESS\" | \"BLOCKQUOTE\" | \"CENTER\" | \"DD\" | \"DIR\" | \"DIV\" | \"DL\" | \"DT\" | \"FIELDSET\" | \"FORM\" | \"FRAMESET\" | \"H1\" | \"H2\" | \"H3\" | \"H4\" | \"H5\" | \"H6\" | \"HR\" | \"ISINDEX\" | \"LI\" | \"MENU\" | \"NOFRAMES\" | \"NOSCRIPT\" | \"OL\" | \"P\" | \"PRE\" | \"SCRIPT\" | \"TABLE\" | \"TBODY\" | \"TD\" | \"TFOOT\" | \"TH\" | \"THEAD\" | \"TR\" | \"UL\" | \"address\" | \"blockquote\" | \"center\" | \"dd\" | \"dir\" | \"div\" | \"dl\" | \"dt\" | \"fieldset\" | \"form\" | \"frameset\" | \"h1\" | \"h2\" | \"h3\" | \"h4\" | \"h5\" | \"h6\" | \"hr\" | \"isindex\" | \"li\" | \"menu\" | \"noframes\" | \"noscript\" | \"ol\" | \"p\" | \"pre\" | \"script\" | \"table\" | \"tbody\" | \"td\" | \"tfoot\" | \"th\" | \"thead\" | \"tr\" | \"ul\")",
        "label": "What",
        "id": "234"
    },
    {
        "raw_code": "def _StyleOpen\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "StyleOpen = \"<\" Spnl (\"style\" | \"STYLE\") Spnl HtmlAttribute* \">\"",
        "label": "Property",
        "id": "235"
    },
    {
        "raw_code": "def _StyleClose\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "StyleClose = \"<\" Spnl \"/\" (\"style\" | \"STYLE\") Spnl \">\"",
        "label": "What",
        "id": "236"
    },
    {
        "raw_code": "def _InStyleTags\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_StyleOpen)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "InStyleTags = StyleOpen (!StyleClose .)* StyleClose",
        "label": "What",
        "id": "237"
    },
    {
        "raw_code": "def _StyleBlock\n\n    _save = self.pos\n    while true # sequence\n      _text_start = self.pos\n      _tmp = apply(:_InStyleTags)\n      if _tmp\n        text = get_text(_text_start)\n      end",
        "comment": "StyleBlock = < InStyleTags > @BlankLine* { if css? then                     RDoc::Markup::Raw.new text                   end }",
        "label": "What",
        "id": "238"
    },
    {
        "raw_code": "def _Inlines\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _ary = []\n\n      _save2 = self.pos\n      while true # choice\n\n        _save3 = self.pos\n        while true # sequence\n          _save4 = self.pos\n          _tmp = _Endline()\n          _tmp = _tmp ? nil : true\n          self.pos = _save4\n          unless _tmp\n            self.pos = _save3\n            break\n          end",
        "comment": "Inlines = (!@Endline Inline:i { i } | @Endline:c !(&{ github? } Ticks3 /[^`\\n]*$/) &Inline { c })+:chunks @Endline? { chunks }",
        "label": "What",
        "id": "239"
    },
    {
        "raw_code": "def _Inline\n\n    _save = self.pos\n    while true # choice\n      _tmp = apply(:_Str)\n      break if _tmp\n      self.pos = _save\n      _tmp = _Endline()\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_UlOrStarLine)\n      break if _tmp\n      self.pos = _save\n      _tmp = _Space()\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_Strong)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_Emph)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_Strike)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_Image)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_Link)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_NoteReference)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_InlineNote)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_Code)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_RawHtml)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_Entity)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_EscapedChar)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_Symbol)\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_Inline unless _tmp\n    return _tmp\n  end",
        "comment": "Inline = (Str | @Endline | UlOrStarLine | @Space | Strong | Emph | Strike | Image | Link | NoteReference | InlineNote | Code | RawHtml | Entity | EscapedChar | Symbol)",
        "label": "What",
        "id": "240"
    },
    {
        "raw_code": "def _Space\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = _Spacechar()\n      if _tmp\n        while true\n          _tmp = _Spacechar()\n          break unless _tmp\n        end",
        "comment": "Space = @Spacechar+ { \" \" }",
        "label": "What",
        "id": "241"
    },
    {
        "raw_code": "def _Str\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _StartList()\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Str = @StartList:a < @NormalChar+ > { a = text } (StrChunk:c { a << c })* { a }",
        "label": "What",
        "id": "242"
    },
    {
        "raw_code": "def _StrChunk\n\n    _save = self.pos\n    while true # sequence\n      _text_start = self.pos\n      _save1 = self.pos\n\n      _save2 = self.pos\n      while true # choice\n        _tmp = _NormalChar()\n        break if _tmp\n        self.pos = _save2\n\n        _save3 = self.pos\n        while true # sequence\n          _tmp = scan(/\\G(?-mix:_+)/)\n          unless _tmp\n            self.pos = _save3\n            break\n          end",
        "comment": "StrChunk = < (@NormalChar | /_+/ &Alphanumeric)+ > { text }",
        "label": "Others",
        "id": "243"
    },
    {
        "raw_code": "def _EscapedChar\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"\\\\\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "EscapedChar = \"\\\\\" !@Newline < /[:\\\\`|*_{}\\[\\]()#+.!><-]/ > { text }",
        "label": "What",
        "id": "244"
    },
    {
        "raw_code": "def _Entity\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_HexEntity)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_DecEntity)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_CharEntity)\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Entity = (HexEntity | DecEntity | CharEntity):a { a }",
        "label": "What",
        "id": "245"
    },
    {
        "raw_code": "def _Endline\n\n    _save = self.pos\n    while true # choice\n      _tmp = _LineBreak()\n      break if _tmp\n      self.pos = _save\n      _tmp = _TerminalEndline()\n      break if _tmp\n      self.pos = _save\n      _tmp = _NormalEndline()\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_Endline unless _tmp\n    return _tmp\n  end",
        "comment": "Endline = (@LineBreak | @TerminalEndline | @NormalEndline)",
        "label": "What",
        "id": "246"
    },
    {
        "raw_code": "def _NormalEndline\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _Sp()\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "NormalEndline = @Sp @Newline !@BlankLine !\">\" !AtxStart !(Line /={1,}|-{1,}/ @Newline) { \"\\n\" }",
        "label": "What",
        "id": "247"
    },
    {
        "raw_code": "def _TerminalEndline\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _Sp()\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "TerminalEndline = @Sp @Newline @Eof",
        "label": "Others",
        "id": "248"
    },
    {
        "raw_code": "def _LineBreak\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"  \")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "LineBreak = \"  \" @NormalEndline { RDoc::Markup::HardBreak.new }",
        "label": "What",
        "id": "249"
    },
    {
        "raw_code": "def _Symbol\n\n    _save = self.pos\n    while true # sequence\n      _text_start = self.pos\n      _tmp = _SpecialChar()\n      if _tmp\n        text = get_text(_text_start)\n      end",
        "comment": "Symbol = < @SpecialChar > { text }",
        "label": "Others",
        "id": "250"
    },
    {
        "raw_code": "def _UlOrStarLine\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_UlLine)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_StarLine)\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "UlOrStarLine = (UlLine | StarLine):a { a }",
        "label": "What",
        "id": "251"
    },
    {
        "raw_code": "def _StarLine\n\n    _save = self.pos\n    while true # choice\n\n      _save1 = self.pos\n      while true # sequence\n        _text_start = self.pos\n        _tmp = scan(/\\G(?-mix:\\*{4,})/)\n        if _tmp\n          text = get_text(_text_start)\n        end",
        "comment": "StarLine = (< /\\*{4,}/ > { text } | < @Spacechar /\\*+/ &@Spacechar > { text })",
        "label": "What",
        "id": "252"
    },
    {
        "raw_code": "def _UlLine\n\n    _save = self.pos\n    while true # choice\n\n      _save1 = self.pos\n      while true # sequence\n        _text_start = self.pos\n        _tmp = scan(/\\G(?-mix:_{4,})/)\n        if _tmp\n          text = get_text(_text_start)\n        end",
        "comment": "UlLine = (< /_{4,}/ > { text } | < @Spacechar /_+/ &@Spacechar > { text })",
        "label": "What",
        "id": "253"
    },
    {
        "raw_code": "def _Emph\n\n    _save = self.pos\n    while true # choice\n      _tmp = apply(:_EmphStar)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_EmphUl)\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_Emph unless _tmp\n    return _tmp\n  end",
        "comment": "Emph = (EmphStar | EmphUl)",
        "label": "How-to-use",
        "id": "254"
    },
    {
        "raw_code": "def _Whitespace\n\n    _save = self.pos\n    while true # choice\n      _tmp = _Spacechar()\n      break if _tmp\n      self.pos = _save\n      _tmp = _Newline()\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_Whitespace unless _tmp\n    return _tmp\n  end",
        "comment": "Whitespace = (@Spacechar | @Newline)",
        "label": "What",
        "id": "255"
    },
    {
        "raw_code": "def _EmphStar\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"*\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "EmphStar = \"*\" !@Whitespace @StartList:a (!\"*\" Inline:b { a << b } | StrongStar:b { a << b })+ \"*\" { emphasis a.join }",
        "label": "What",
        "id": "256"
    },
    {
        "raw_code": "def _EmphUl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"_\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "EmphUl = \"_\" !@Whitespace @StartList:a (!\"_\" Inline:b { a << b } | StrongUl:b { a << b })+ \"_\" { emphasis a.join }",
        "label": "What",
        "id": "257"
    },
    {
        "raw_code": "def _Strong\n\n    _save = self.pos\n    while true # choice\n      _tmp = apply(:_StrongStar)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_StrongUl)\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_Strong unless _tmp\n    return _tmp\n  end",
        "comment": "Strong = (StrongStar | StrongUl)",
        "label": "What",
        "id": "258"
    },
    {
        "raw_code": "def _StrongStar\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"**\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "StrongStar = \"**\" !@Whitespace @StartList:a (!\"**\" Inline:b { a << b })+ \"**\" { strong a.join }",
        "label": "What",
        "id": "259"
    },
    {
        "raw_code": "def _StrongUl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"__\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "StrongUl = \"__\" !@Whitespace @StartList:a (!\"__\" Inline:b { a << b })+ \"__\" { strong a.join }",
        "label": "What",
        "id": "260"
    },
    {
        "raw_code": "def _Strike\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = begin;  strike? ; end\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Strike = &{ strike? } \"~~\" !@Whitespace @StartList:a (!\"~~\" Inline:b { a << b })+ \"~~\" { strike a.join }",
        "label": "What",
        "id": "261"
    },
    {
        "raw_code": "def _Image\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"!\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Image = \"!\" ExplicitLinkWithLabel:a { \"rdoc-image:#{a[:link]}:#{a[:label]}\" }",
        "label": "What",
        "id": "262"
    },
    {
        "raw_code": "def _Link\n\n    _save = self.pos\n    while true # choice\n      _tmp = apply(:_ExplicitLink)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_ReferenceLink)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_AutoLink)\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_Link unless _tmp\n    return _tmp\n  end",
        "comment": "Link = (ExplicitLink | ReferenceLink | AutoLink)",
        "label": "What",
        "id": "263"
    },
    {
        "raw_code": "def _ReferenceLink\n\n    _save = self.pos\n    while true # choice\n      _tmp = apply(:_ReferenceLinkDouble)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_ReferenceLinkSingle)\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_ReferenceLink unless _tmp\n    return _tmp\n  end",
        "comment": "ReferenceLink = (ReferenceLinkDouble | ReferenceLinkSingle)",
        "label": "Why",
        "id": "264"
    },
    {
        "raw_code": "def _ReferenceLinkDouble\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_Label)\n      content = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ReferenceLinkDouble = Label:content < Spnl > !\"[]\" Label:label { link_to content, label, text }",
        "label": "What",
        "id": "265"
    },
    {
        "raw_code": "def _ReferenceLinkSingle\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_Label)\n      content = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ReferenceLinkSingle = Label:content < (Spnl \"[]\")? > { link_to content, content, text }",
        "label": "Property",
        "id": "266"
    },
    {
        "raw_code": "def _ExplicitLink\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_ExplicitLinkWithLabel)\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ExplicitLink = ExplicitLinkWithLabel:a { \"{#{a[:label]}}[#{a[:link]}]\" }",
        "label": "What",
        "id": "267"
    },
    {
        "raw_code": "def _ExplicitLinkWithLabel\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_Label)\n      label = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ExplicitLinkWithLabel = Label:label \"(\" @Sp Source:link Spnl Title @Sp \")\" { { label: label, link: link } }",
        "label": "What",
        "id": "268"
    },
    {
        "raw_code": "def _Source\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n\n        _save2 = self.pos\n        while true # sequence\n          _tmp = match_string(\"<\")\n          unless _tmp\n            self.pos = _save2\n            break\n          end",
        "comment": "Source = (\"<\" < SourceContents > \">\" | < SourceContents >) { text }",
        "label": "What",
        "id": "269"
    },
    {
        "raw_code": "def _SourceContents\n    while true\n\n      _save1 = self.pos\n      while true # choice\n        _save2 = self.pos\n\n        _save3 = self.pos\n        while true # sequence\n          _save4 = self.pos\n          _tmp = match_string(\"(\")\n          _tmp = _tmp ? nil : true\n          self.pos = _save4\n          unless _tmp\n            self.pos = _save3\n            break\n          end",
        "comment": "SourceContents = ((!\"(\" !\")\" !\">\" Nonspacechar)+ | \"(\" SourceContents \")\")*",
        "label": "What",
        "id": "270"
    },
    {
        "raw_code": "def _Title\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_TitleSingle)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_TitleDouble)\n        break if _tmp\n        self.pos = _save1\n        _tmp = match_string(\"\")\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Title = (TitleSingle | TitleDouble | \"\"):a { a }",
        "label": "What",
        "id": "271"
    },
    {
        "raw_code": "def _TitleSingle\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"'\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "TitleSingle = \"'\" (!(\"'\" @Sp (\")\" | @Newline)) .)* \"'\"",
        "label": "What",
        "id": "272"
    },
    {
        "raw_code": "def _TitleDouble\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"\\\"\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "TitleDouble = \"\\\"\" (!(\"\\\"\" @Sp (\")\" | @Newline)) .)* \"\\\"\"",
        "label": "What",
        "id": "273"
    },
    {
        "raw_code": "def _AutoLink\n\n    _save = self.pos\n    while true # choice\n      _tmp = apply(:_AutoLinkUrl)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_AutoLinkEmail)\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_AutoLink unless _tmp\n    return _tmp\n  end",
        "comment": "AutoLink = (AutoLinkUrl | AutoLinkEmail)",
        "label": "What",
        "id": "274"
    },
    {
        "raw_code": "def _AutoLinkUrl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "AutoLinkUrl = \"<\" < /[A-Za-z]+/ \"://\" (!@Newline !\">\" .)+ > \">\" { text }",
        "label": "Property",
        "id": "275"
    },
    {
        "raw_code": "def _AutoLinkEmail\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "AutoLinkEmail = \"<\" \"mailto:\"? < /[\\w+.\\/!%~$-]+/i \"@\" (!@Newline !\">\" .)+ > \">\" { \"mailto:#{text}\" }",
        "label": "What",
        "id": "276"
    },
    {
        "raw_code": "def _Reference\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _NonindentSpace()\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Reference = @NonindentSpace !\"[]\" Label:label \":\" Spnl RefSrc:link RefTitle @BlankLine+ { # TODO use title               reference label, link               nil             }",
        "label": "How-to-use",
        "id": "277"
    },
    {
        "raw_code": "def _Label\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"[\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Label = \"[\" (!\"^\" &{ notes? } | &. &{ !notes? }) @StartList:a (!\"]\" Inline:l { a << l })* \"]\" { a.join.gsub(/\\s+/, ' ') }",
        "label": "What",
        "id": "278"
    },
    {
        "raw_code": "def _RefSrc\n\n    _save = self.pos\n    while true # sequence\n      _text_start = self.pos\n      _save1 = self.pos\n      _tmp = apply(:_Nonspacechar)\n      if _tmp\n        while true\n          _tmp = apply(:_Nonspacechar)\n          break unless _tmp\n        end",
        "comment": "RefSrc = < Nonspacechar+ > { text }",
        "label": "Others",
        "id": "279"
    },
    {
        "raw_code": "def _RefTitle\n\n    _save = self.pos\n    while true # choice\n      _tmp = apply(:_RefTitleSingle)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_RefTitleDouble)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_RefTitleParens)\n      break if _tmp\n      self.pos = _save\n      _tmp = apply(:_EmptyTitle)\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_RefTitle unless _tmp\n    return _tmp\n  end",
        "comment": "RefTitle = (RefTitleSingle | RefTitleDouble | RefTitleParens | EmptyTitle)",
        "label": "Property",
        "id": "280"
    },
    {
        "raw_code": "def _EmptyTitle\n    _tmp = match_string(\"\")\n    set_failed_rule :_EmptyTitle unless _tmp\n    return _tmp\n  end",
        "comment": "EmptyTitle = \"\"",
        "label": "What",
        "id": "281"
    },
    {
        "raw_code": "def _RefTitleSingle\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_Spnl)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "RefTitleSingle = Spnl \"'\" < (!(\"'\" @Sp @Newline | @Newline) .)* > \"'\" { text }",
        "label": "What",
        "id": "282"
    },
    {
        "raw_code": "def _RefTitleDouble\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_Spnl)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "RefTitleDouble = Spnl \"\\\"\" < (!(\"\\\"\" @Sp @Newline | @Newline) .)* > \"\\\"\" { text }",
        "label": "Property",
        "id": "283"
    },
    {
        "raw_code": "def _RefTitleParens\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_Spnl)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "RefTitleParens = Spnl \"(\" < (!(\")\" @Sp @Newline | @Newline) .)* > \")\" { text }",
        "label": "Property",
        "id": "284"
    },
    {
        "raw_code": "def _References\n    while true\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_Reference)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_SkipBlock)\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      break unless _tmp\n    end",
        "comment": "References = (Reference | SkipBlock)*",
        "label": "What",
        "id": "285"
    },
    {
        "raw_code": "def _Ticks1\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"`\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Ticks1 = \"`\" !\"`\"",
        "label": "What",
        "id": "286"
    },
    {
        "raw_code": "def _Ticks2\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"``\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Ticks2 = \"``\" !\"`\"",
        "label": "What",
        "id": "287"
    },
    {
        "raw_code": "def _Ticks3\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"```\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Ticks3 = \"```\" !\"`\"",
        "label": "What",
        "id": "288"
    },
    {
        "raw_code": "def _Ticks4\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"````\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Ticks4 = \"````\" !\"`\"",
        "label": "What",
        "id": "289"
    },
    {
        "raw_code": "def _Ticks5\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"`````\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Ticks5 = \"`````\" !\"`\"",
        "label": "What",
        "id": "290"
    },
    {
        "raw_code": "def _Code\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n\n        _save2 = self.pos\n        while true # sequence\n          _tmp = apply(:_Ticks1)\n          unless _tmp\n            self.pos = _save2\n            break\n          end",
        "comment": "Code = (Ticks1 < ((!\"`\" Nonspacechar)+ | !Ticks1 /`+/ | !Ticks1 (@Spacechar | @Newline !@BlankLine))+ > Ticks1 | Ticks2 < ((!\"`\" Nonspacechar)+ | !Ticks2 /`+/ | !Ticks2 (@Spacechar | @Newline !@BlankLine))+ > Ticks2 | Ticks3 < ((!\"`\" Nonspacechar)+ | !Ticks3 /`+/ | !Ticks3 (@Spacechar | @Newline !@BlankLine))+ > Ticks3 | Ticks4 < ((!\"`\" Nonspacechar)+ | !Ticks4 /`+/ | !Ticks4 (@Spacechar | @Newline !@BlankLine))+ > Ticks4 | Ticks5 < ((!\"`\" Nonspacechar)+ | !Ticks5 /`+/ | !Ticks5 (@Spacechar | @Newline !@BlankLine))+ > Ticks5) { code text }",
        "label": "What",
        "id": "291"
    },
    {
        "raw_code": "def _RawHtml\n\n    _save = self.pos\n    while true # sequence\n      _text_start = self.pos\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_HtmlComment)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_HtmlBlockScript)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_HtmlTag)\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      if _tmp\n        text = get_text(_text_start)\n      end",
        "comment": "RawHtml = < (HtmlComment | HtmlBlockScript | HtmlTag) > { if html? then text else '' end }",
        "label": "What",
        "id": "292"
    },
    {
        "raw_code": "def _BlankLine\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _Sp()\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "BlankLine = @Sp @Newline { \"\\n\" }",
        "label": "What",
        "id": "293"
    },
    {
        "raw_code": "def _Quoted\n\n    _save = self.pos\n    while true # choice\n\n      _save1 = self.pos\n      while true # sequence\n        _tmp = match_string(\"\\\"\")\n        unless _tmp\n          self.pos = _save1\n          break\n        end",
        "comment": "Quoted = (\"\\\"\" (!\"\\\"\" .)* \"\\\"\" | \"'\" (!\"'\" .)* \"'\")",
        "label": "What",
        "id": "294"
    },
    {
        "raw_code": "def _HtmlAttribute\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n\n      _save2 = self.pos\n      while true # choice\n        _tmp = apply(:_AlphanumericAscii)\n        break if _tmp\n        self.pos = _save2\n        _tmp = match_string(\"-\")\n        break if _tmp\n        self.pos = _save2\n        break\n      end # end choice\n\n      if _tmp\n        while true\n\n          _save3 = self.pos\n          while true # choice\n            _tmp = apply(:_AlphanumericAscii)\n            break if _tmp\n            self.pos = _save3\n            _tmp = match_string(\"-\")\n            break if _tmp\n            self.pos = _save3\n            break\n          end # end choice\n\n          break unless _tmp\n        end",
        "comment": "HtmlAttribute = (AlphanumericAscii | \"-\")+ Spnl (\"=\" Spnl (Quoted | (!\">\" Nonspacechar)+))? Spnl",
        "label": "How-to-use",
        "id": "295"
    },
    {
        "raw_code": "def _HtmlComment\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<!--\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlComment = \"<!--\" (!\"-->\" .)* \"-->\"",
        "label": "What",
        "id": "296"
    },
    {
        "raw_code": "def _HtmlTag\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"<\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HtmlTag = \"<\" Spnl \"/\"? AlphanumericAscii+ Spnl HtmlAttribute* \"/\"? Spnl \">\"",
        "label": "What",
        "id": "297"
    },
    {
        "raw_code": "def _Eof\n    _save = self.pos\n    _tmp = get_byte\n    _tmp = _tmp ? nil : true\n    self.pos = _save\n    set_failed_rule :_Eof unless _tmp\n    return _tmp\n  end",
        "comment": "Eof = !.",
        "label": "Others",
        "id": "298"
    },
    {
        "raw_code": "def _Nonspacechar\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = _Spacechar()\n      _tmp = _tmp ? nil : true\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Nonspacechar = !@Spacechar !@Newline .",
        "label": "Why",
        "id": "299"
    },
    {
        "raw_code": "def _Sp\n    while true\n      _tmp = _Spacechar()\n      break unless _tmp\n    end",
        "comment": "Sp = @Spacechar*",
        "label": "Others",
        "id": "300"
    },
    {
        "raw_code": "def _Spnl\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _Sp()\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Spnl = @Sp (@Newline @Sp)?",
        "label": "What",
        "id": "301"
    },
    {
        "raw_code": "def _SpecialChar\n\n    _save = self.pos\n    while true # choice\n      _tmp = scan(/\\G(?-mix:[~*_`&\\[\\]()<!#\\\\'\"])/)\n      break if _tmp\n      self.pos = _save\n      _tmp = _ExtendedSpecialChar()\n      break if _tmp\n      self.pos = _save\n      break\n    end # end choice\n\n    set_failed_rule :_SpecialChar unless _tmp\n    return _tmp\n  end",
        "comment": "SpecialChar = (/[~*_`&\\[\\]()<!#\\\\'\"]/ | @ExtendedSpecialChar)",
        "label": "Property",
        "id": "302"
    },
    {
        "raw_code": "def _NormalChar\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n\n      _save2 = self.pos\n      while true # choice\n        _tmp = _SpecialChar()\n        break if _tmp\n        self.pos = _save2\n        _tmp = _Spacechar()\n        break if _tmp\n        self.pos = _save2\n        _tmp = _Newline()\n        break if _tmp\n        self.pos = _save2\n        break\n      end # end choice\n\n      _tmp = _tmp ? nil : true\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "NormalChar = !(@SpecialChar | @Spacechar | @Newline) .",
        "label": "What",
        "id": "303"
    },
    {
        "raw_code": "def _Digit\n    _save = self.pos\n    _tmp = get_byte\n    if _tmp\n      unless _tmp >= 48 and _tmp <= 57\n        self.pos = _save\n        _tmp = nil\n      end",
        "comment": "Digit = [0-9]",
        "label": "What",
        "id": "304"
    },
    {
        "raw_code": "def _Alphanumeric\n    _tmp = @_grammar_literals.external_invoke(self, :_Alphanumeric)\n    set_failed_rule :_Alphanumeric unless _tmp\n    return _tmp\n  end",
        "comment": "Alphanumeric = %literals.Alphanumeric",
        "label": "Others",
        "id": "305"
    },
    {
        "raw_code": "def _AlphanumericAscii\n    _tmp = @_grammar_literals.external_invoke(self, :_AlphanumericAscii)\n    set_failed_rule :_AlphanumericAscii unless _tmp\n    return _tmp\n  end",
        "comment": "AlphanumericAscii = %literals.AlphanumericAscii",
        "label": "What",
        "id": "306"
    },
    {
        "raw_code": "def _BOM\n    _tmp = @_grammar_literals.external_invoke(self, :_BOM)\n    set_failed_rule :_BOM unless _tmp\n    return _tmp\n  end",
        "comment": "BOM = %literals.BOM",
        "label": "What",
        "id": "307"
    },
    {
        "raw_code": "def _Newline\n    _tmp = @_grammar_literals.external_invoke(self, :_Newline)\n    set_failed_rule :_Newline unless _tmp\n    return _tmp\n  end",
        "comment": "Newline = %literals.Newline",
        "label": "What",
        "id": "308"
    },
    {
        "raw_code": "def _Spacechar\n    _tmp = @_grammar_literals.external_invoke(self, :_Spacechar)\n    set_failed_rule :_Spacechar unless _tmp\n    return _tmp\n  end",
        "comment": "Spacechar = %literals.Spacechar",
        "label": "Others",
        "id": "309"
    },
    {
        "raw_code": "def _HexEntity\n\n    _save = self.pos\n    while true # sequence\n      _tmp = scan(/\\G(?i-mx:&#x)/)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "HexEntity = /&#x/i < /[0-9a-fA-F]+/ > \";\" { [text.to_i(16)].pack 'U' }",
        "label": "What",
        "id": "310"
    },
    {
        "raw_code": "def _DecEntity\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"&#\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "DecEntity = \"&#\" < /[0-9]+/ > \";\" { [text.to_i].pack 'U' }",
        "label": "Property",
        "id": "311"
    },
    {
        "raw_code": "def _CharEntity\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"&\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "CharEntity = \"&\" < /[A-Za-z0-9]+/ > \";\" { if entity = HTML_ENTITIES[text] then                  entity.pack 'U*'                else                  \"&#{text};\"                end              }",
        "label": "What",
        "id": "312"
    },
    {
        "raw_code": "def _NonindentSpace\n    _tmp = scan(/\\G(?-mix: {0,3})/)\n    set_failed_rule :_NonindentSpace unless _tmp\n    return _tmp\n  end",
        "comment": "NonindentSpace = / {0,3}/",
        "label": "What",
        "id": "313"
    },
    {
        "raw_code": "def _Indent\n    _tmp = scan(/\\G(?-mix:\\t|    )/)\n    set_failed_rule :_Indent unless _tmp\n    return _tmp\n  end",
        "comment": "Indent = /\\t|    /",
        "label": "What",
        "id": "314"
    },
    {
        "raw_code": "def _IndentedLine\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_Indent)\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "IndentedLine = Indent Line",
        "label": "How-to-use",
        "id": "315"
    },
    {
        "raw_code": "def _OptionallyIndentedLine\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = apply(:_Indent)\n      unless _tmp\n        _tmp = true\n        self.pos = _save1\n      end",
        "comment": "OptionallyIndentedLine = Indent? Line",
        "label": "Why",
        "id": "316"
    },
    {
        "raw_code": "def _StartList\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = get_byte\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "StartList = &. { [] }",
        "label": "What",
        "id": "317"
    },
    {
        "raw_code": "def _Line\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _RawLine()\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Line = @RawLine:a { a }",
        "label": "What",
        "id": "318"
    },
    {
        "raw_code": "def _RawLine\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n        _text_start = self.pos\n\n        _save2 = self.pos\n        while true # sequence\n          _tmp = scan(/\\G(?-mix:[^\\r\\n]*)/)\n          unless _tmp\n            self.pos = _save2\n            break\n          end",
        "comment": "RawLine = (< /[^\\r\\n]*/ @Newline > | < .+ > @Eof) { text }",
        "label": "Others",
        "id": "319"
    },
    {
        "raw_code": "def _SkipBlock\n\n    _save = self.pos\n    while true # choice\n      _tmp = apply(:_HtmlBlock)\n      break if _tmp\n      self.pos = _save\n\n      _save1 = self.pos\n      while true # sequence\n        _save2 = self.pos\n\n        _save3 = self.pos\n        while true # sequence\n          _save4 = self.pos\n          _tmp = match_string(\"#\")\n          _tmp = _tmp ? nil : true\n          self.pos = _save4\n          unless _tmp\n            self.pos = _save3\n            break\n          end",
        "comment": "SkipBlock = (HtmlBlock | (!\"#\" !SetextBottom1 !SetextBottom2 !@BlankLine @RawLine)+ @BlankLine* | @BlankLine+ | @RawLine)",
        "label": "What",
        "id": "320"
    },
    {
        "raw_code": "def _ExtendedSpecialChar\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = begin;  notes? ; end\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "ExtendedSpecialChar = &{ notes? } \"^\"",
        "label": "Others",
        "id": "321"
    },
    {
        "raw_code": "def _NoteReference\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = begin;  notes? ; end\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "NoteReference = &{ notes? } RawNoteReference:ref { note_for ref }",
        "label": "What",
        "id": "322"
    },
    {
        "raw_code": "def _RawNoteReference\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"[^\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "RawNoteReference = \"[^\" < (!@Newline !\"]\" .)+ > \"]\" { text }",
        "label": "What",
        "id": "323"
    },
    {
        "raw_code": "def _Note\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = begin;  notes? ; end\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Note = &{ notes? } @NonindentSpace RawNoteReference:ref \":\" @Sp @StartList:a RawNoteBlock:i { a.concat i } (&Indent RawNoteBlock:i { a.concat i })* { @footnotes[ref] = paragraph a                    nil                 }",
        "label": "What",
        "id": "324"
    },
    {
        "raw_code": "def _InlineNote\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = begin;  notes? ; end\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "InlineNote = &{ notes? } \"^[\" @StartList:a (!\"]\" Inline:l { a << l })+ \"]\" { ref = [:inline, @note_order.length]                @footnotes[ref] = paragraph a                 note_for ref              }",
        "label": "What",
        "id": "325"
    },
    {
        "raw_code": "def _Notes\n    while true\n\n      _save1 = self.pos\n      while true # choice\n        _tmp = apply(:_Note)\n        break if _tmp\n        self.pos = _save1\n        _tmp = apply(:_SkipBlock)\n        break if _tmp\n        self.pos = _save1\n        break\n      end # end choice\n\n      break unless _tmp\n    end",
        "comment": "Notes = (Note | SkipBlock)*",
        "label": "What",
        "id": "326"
    },
    {
        "raw_code": "def _RawNoteBlock\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _StartList()\n      a = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "RawNoteBlock = @StartList:a (!@BlankLine !RawNoteReference OptionallyIndentedLine:l { a << l })+ < @BlankLine* > { a << text } { a }",
        "label": "Property",
        "id": "327"
    },
    {
        "raw_code": "def _CodeFence\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = begin;  github? ; end\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "CodeFence = &{ github? } Ticks3 (@Sp StrChunk:format)? Spnl < ((!\"`\" Nonspacechar)+ | !Ticks3 /`+/ | Spacechar | @Newline)+ > Ticks3 @Sp @Newline* { verbatim = RDoc::Markup::Verbatim.new text               verbatim.format = format.intern if format.instance_of?(String)               verbatim             }",
        "label": "What",
        "id": "328"
    },
    {
        "raw_code": "def _Table\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = begin;  github? ; end\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "Table = &{ github? } TableHead:header TableLine:line TableRow+:body {           table = RDoc::Markup::Table.new(header, line, body)           parse_table_cells(table)         }",
        "label": "What",
        "id": "329"
    },
    {
        "raw_code": "def _TableHead\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _ary = []\n      _tmp = apply(:_TableItem2)\n      if _tmp\n        _ary << @result\n        while true\n          _tmp = apply(:_TableItem2)\n          _ary << @result if _tmp\n          break unless _tmp\n        end",
        "comment": "TableHead = TableItem2+:items \"|\"? @Newline { items }",
        "label": "What",
        "id": "330"
    },
    {
        "raw_code": "def _TableRow\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n\n        _save2 = self.pos\n        while true # sequence\n          _tmp = apply(:_TableItem)\n          item1 = @result\n          unless _tmp\n            self.pos = _save2\n            break\n          end",
        "comment": "TableRow = ((TableItem:item1 TableItem2*:items { [item1, *items] }):row | TableItem2+:row) \"|\"? @Newline { row }",
        "label": "What",
        "id": "331"
    },
    {
        "raw_code": "def _TableItem2\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"|\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "TableItem2 = \"|\" TableItem",
        "label": "What",
        "id": "332"
    },
    {
        "raw_code": "def _TableItem\n\n    _save = self.pos\n    while true # sequence\n      _text_start = self.pos\n      _tmp = scan(/\\G(?-mix:(?:\\\\.|[^|\\n])+)/)\n      if _tmp\n        text = get_text(_text_start)\n      end",
        "comment": "TableItem = < /(?:\\\\.|[^|\\n])+/ > { text.strip.gsub(/\\\\([|])/, '\\1')  }",
        "label": "What",
        "id": "333"
    },
    {
        "raw_code": "def _TableLine\n\n    _save = self.pos\n    while true # sequence\n\n      _save1 = self.pos\n      while true # choice\n\n        _save2 = self.pos\n        while true # sequence\n          _tmp = apply(:_TableAlign)\n          align1 = @result\n          unless _tmp\n            self.pos = _save2\n            break\n          end",
        "comment": "TableLine = ((TableAlign:align1 TableAlign2*:aligns {[align1, *aligns] }):line | TableAlign2+:line) \"|\"? @Newline { line }",
        "label": "What",
        "id": "334"
    },
    {
        "raw_code": "def _TableAlign2\n\n    _save = self.pos\n    while true # sequence\n      _tmp = match_string(\"|\")\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "TableAlign2 = \"|\" @Sp TableAlign",
        "label": "What",
        "id": "335"
    },
    {
        "raw_code": "def _TableAlign\n\n    _save = self.pos\n    while true # sequence\n      _text_start = self.pos\n      _tmp = scan(/\\G(?-mix::?-+:?)/)\n      if _tmp\n        text = get_text(_text_start)\n      end",
        "comment": "TableAlign = < /:?-+:?/ > @Sp {                 text.start_with?(\":\") ?                 (text.end_with?(\":\") ? :center : :left) :                 (text.end_with?(\":\") ? :right : nil)               }",
        "label": "What",
        "id": "336"
    },
    {
        "raw_code": "def _DefinitionList\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _tmp = begin;  definition_lists? ; end\n      self.pos = _save1\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "DefinitionList = &{ definition_lists? } DefinitionListItem+:list { RDoc::Markup::List.new :NOTE, *list.flatten }",
        "label": "What",
        "id": "337"
    },
    {
        "raw_code": "def _DefinitionListItem\n\n    _save = self.pos\n    while true # sequence\n      _save1 = self.pos\n      _ary = []\n      _tmp = apply(:_DefinitionListLabel)\n      if _tmp\n        _ary << @result\n        while true\n          _tmp = apply(:_DefinitionListLabel)\n          _ary << @result if _tmp\n          break unless _tmp\n        end",
        "comment": "DefinitionListItem = DefinitionListLabel+:label DefinitionListDefinition+:defns { list_items = []                        list_items <<                          RDoc::Markup::ListItem.new(label, defns.shift)                         list_items.concat defns.map { |defn|                          RDoc::Markup::ListItem.new nil, defn                        } unless list_items.empty?                         list_items                      }",
        "label": "What",
        "id": "338"
    },
    {
        "raw_code": "def _DefinitionListLabel\n\n    _save = self.pos\n    while true # sequence\n      _tmp = apply(:_Inline)\n      label = @result\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "DefinitionListLabel = Inline:label @Sp @Newline { label }",
        "label": "Property",
        "id": "339"
    },
    {
        "raw_code": "def _DefinitionListDefinition\n\n    _save = self.pos\n    while true # sequence\n      _tmp = _NonindentSpace()\n      unless _tmp\n        self.pos = _save\n        break\n      end",
        "comment": "DefinitionListDefinition = @NonindentSpace \":\" @Space Inlines:a @BlankLine+ { paragraph a }",
        "label": "What",
        "id": "340"
    },
    {
        "raw_code": "def initialize(store, file, name)\n      @store = store\n      @file  = file\n      @name  = name\n    end",
        "comment": " Creates a new MissingFileError for the missing +file+ for the given +name+ that should have been in the +store+.",
        "label": "How-it-is-done",
        "id": "341"
    },
    {
        "raw_code": "def initialize(options, path: nil, type: nil)\n    @options  = options\n    @dry_run  = options.dry_run\n    @encoding = options.encoding\n    @path     = path || options.op_dir\n    @type     = type\n\n    @cache = {\n      :ancestors                   => {},\n      :attributes                  => {},\n      :class_methods               => {},\n      :c_class_variables           => {},\n      :c_singleton_class_variables => {},\n      :encoding                    => @encoding,\n      :instance_methods            => {},\n      :main                        => options.main_page,\n      :modules                     => [],\n      :pages                       => [],\n      :title                       => options.title,\n    }\n\n    @classes_hash = {}\n    @modules_hash = {}\n    @files_hash   = {}\n    @text_files_hash = {}\n\n    @c_enclosure_classes = {}\n    @c_enclosure_names   = {}\n\n    @c_class_variables           = {}\n    @c_singleton_class_variables = {}\n\n    @unique_classes = nil\n    @unique_modules = nil\n\n    @unmatched_constant_alias = {}\n  end",
        "comment": " Creates a new Store of +type+ that will load or save to +path+",
        "label": "How-it-is-done",
        "id": "342"
    },
    {
        "raw_code": "def add_c_enclosure(variable, namespace)\n    @c_enclosure_classes[variable] = namespace\n  end",
        "comment": " Adds +module+ as an enclosure (namespace) for the given +variable+ for C files.",
        "label": "What",
        "id": "343"
    },
    {
        "raw_code": "def add_c_variables(c_parser)\n    filename = c_parser.top_level.relative_name\n\n    @c_class_variables[filename] = make_variable_map c_parser.classes\n\n    @c_singleton_class_variables[filename] = c_parser.singleton_classes\n  end",
        "comment": " Adds C variables from an RDoc::Parser::C",
        "label": "What",
        "id": "344"
    },
    {
        "raw_code": "def add_file(absolute_name, relative_name: absolute_name, parser: nil)\n    unless top_level = @files_hash[relative_name] then\n      top_level = RDoc::TopLevel.new absolute_name, relative_name\n      top_level.parser = parser if parser\n      top_level.store = self\n      @files_hash[relative_name] = top_level\n      @text_files_hash[relative_name] = top_level if top_level.text?\n    end",
        "comment": " Adds the file with +name+ as an RDoc::TopLevel to the store.  Returns the created RDoc::TopLevel.",
        "label": "Property",
        "id": "345"
    },
    {
        "raw_code": "def resolve_c_superclasses\n    @classes_hash.each_value do |klass|\n      if klass.superclass.is_a?(String) && (candidate = find_c_enclosure(klass.superclass))\n        klass.superclass = candidate\n      end",
        "comment": " Make sure any references to C variable names are resolved to the corresponding class. ",
        "label": "How-to-use",
        "id": "346"
    },
    {
        "raw_code": "def update_parser_of_file(absolute_name, parser)\n    if top_level = @files_hash[absolute_name] then\n      @text_files_hash[absolute_name] = top_level if top_level.text?\n    end",
        "comment": " Sets the parser of +absolute_name+, unless it from a source code file.",
        "label": "What",
        "id": "347"
    },
    {
        "raw_code": "def all_classes\n    @classes_hash.values\n  end",
        "comment": " Returns all classes discovered by RDoc",
        "label": "Property",
        "id": "348"
    },
    {
        "raw_code": "def all_classes_and_modules\n    @classes_hash.values + @modules_hash.values\n  end",
        "comment": " Returns all classes and modules discovered by RDoc",
        "label": "Property",
        "id": "349"
    },
    {
        "raw_code": "def all_files\n    @files_hash.values\n  end",
        "comment": " All TopLevels known to RDoc",
        "label": "What",
        "id": "350"
    },
    {
        "raw_code": "def all_modules\n    modules_hash.values\n  end",
        "comment": " Returns all modules discovered by RDoc",
        "label": "Property",
        "id": "351"
    },
    {
        "raw_code": "def ancestors\n    @cache[:ancestors]\n  end",
        "comment": " Ancestors cache accessor.  Maps a klass name to an Array of its ancestors in this store.  If Foo in this store inherits from Object, Kernel won't be listed (it will be included from ruby's ri store).",
        "label": "Others",
        "id": "352"
    },
    {
        "raw_code": "def attributes\n    @cache[:attributes]\n  end",
        "comment": " Attributes cache accessor.  Maps a class to an Array of its attributes.",
        "label": "What",
        "id": "353"
    },
    {
        "raw_code": "def cache_path\n    File.join @path, 'cache.ri'\n  end",
        "comment": " Path to the cache file",
        "label": "What",
        "id": "354"
    },
    {
        "raw_code": "def class_file(klass_name)\n    name = klass_name.split('::').last\n    File.join class_path(klass_name), \"cdesc-#{name}.ri\"\n  end",
        "comment": " Path to the ri data for +klass_name+",
        "label": "Why",
        "id": "355"
    },
    {
        "raw_code": "def class_methods\n    @cache[:class_methods]\n  end",
        "comment": " Class methods cache accessor.  Maps a class to an Array of its class methods (not full name).",
        "label": "What",
        "id": "356"
    },
    {
        "raw_code": "def class_path(klass_name)\n    File.join @path, *klass_name.split('::')\n  end",
        "comment": " Path where data for +klass_name+ will be stored (methods or class data)",
        "label": "What",
        "id": "357"
    },
    {
        "raw_code": "def classes_hash\n    @classes_hash\n  end",
        "comment": " Hash of all classes known to RDoc",
        "label": "What",
        "id": "358"
    },
    {
        "raw_code": "def clean_cache_collection(collection) # :nodoc:\n    collection.each do |name, item|\n      if item.empty? then\n        collection.delete name\n      else\n        # HACK mongrel-1.1.5 documents its files twice\n        item.uniq!\n        item.sort!\n      end",
        "comment": " Removes empty items and ensures item in each collection are unique and sorted",
        "label": "Others",
        "id": "359"
    },
    {
        "raw_code": "def complete(min_visibility)\n    fix_basic_object_inheritance\n\n    # cache included modules before they are removed from the documentation\n    all_classes_and_modules.each { |cm| cm.ancestors }\n\n    unless min_visibility == :nodoc then\n      remove_nodoc @classes_hash\n      remove_nodoc @modules_hash\n    end",
        "comment": " Prepares the RDoc code object tree for use by a generator.  It finds unique classes/modules defined, and replaces classes/modules that are aliases for another one by a copy with RDoc::ClassModule#is_alias_for set.  It updates the RDoc::ClassModule#constant_aliases attribute of \"real\" classes or modules.  It also completely removes the classes and modules that should be removed from the documentation and the methods that have a visibility below +min_visibility+, which is the <tt>--visibility</tt> option.  See also RDoc::Context#remove_from_documentation?",
        "label": "What",
        "id": "360"
    },
    {
        "raw_code": "def files_hash\n    @files_hash\n  end",
        "comment": " Hash of all files known to RDoc",
        "label": "What",
        "id": "361"
    },
    {
        "raw_code": "def find_c_enclosure(variable)\n    @c_enclosure_classes.fetch variable do\n      break unless name = @c_enclosure_names[variable]\n\n      mod = find_class_or_module name\n\n      unless mod then\n        loaded_mod = load_class_data name\n\n        file = loaded_mod.in_files.first\n\n        return unless file # legacy data source\n\n        file.store = self\n\n        mod = file.add_module RDoc::NormalModule, name\n      end",
        "comment": " Finds the enclosure (namespace) for the given C +variable+.",
        "label": "What",
        "id": "362"
    },
    {
        "raw_code": "def find_class_named(name)\n    @classes_hash[name]\n  end",
        "comment": " Finds the class with +name+ in all discovered classes",
        "label": "What",
        "id": "363"
    },
    {
        "raw_code": "def find_class_named_from(name, from)\n    from = find_class_named from unless RDoc::Context === from\n\n    until RDoc::TopLevel === from do\n      return nil unless from\n\n      klass = from.find_class_named name\n      return klass if klass\n\n      from = from.parent\n    end",
        "comment": " Finds the class with +name+ starting in namespace +from+",
        "label": "What",
        "id": "364"
    },
    {
        "raw_code": "def find_class_or_module(name)\n    name = $' if name =~ /^::/\n    @classes_hash[name] || @modules_hash[name]\n  end",
        "comment": " Finds the class or module with +name+",
        "label": "What",
        "id": "365"
    },
    {
        "raw_code": "def find_file_named(name)\n    @files_hash[name]\n  end",
        "comment": " Finds the file with +name+ in all discovered files",
        "label": "What",
        "id": "366"
    },
    {
        "raw_code": "def find_module_named(name)\n    @modules_hash[name]\n  end",
        "comment": " Finds the module with +name+ in all discovered modules",
        "label": "What",
        "id": "367"
    },
    {
        "raw_code": "def find_text_page(file_name)\n    @text_files_hash.each_value.find do |file|\n      file.full_name == file_name\n    end",
        "comment": " Returns the RDoc::TopLevel that is a text file and has the given +file_name+",
        "label": "Property",
        "id": "368"
    },
    {
        "raw_code": "def find_unique(all_hash)\n    unique = []\n\n    all_hash.each_pair do |full_name, cm|\n      unique << cm if full_name == cm.full_name\n    end",
        "comment": " Finds unique classes/modules defined in +all_hash+, and returns them as an array. Performs the alias updates in +all_hash+: see ::complete. -- TODO  aliases should be registered by Context#add_module_alias",
        "label": "What",
        "id": "369"
    },
    {
        "raw_code": "def fix_basic_object_inheritance\n    basic = classes_hash['BasicObject']\n    return unless basic\n    basic.superclass = nil\n  end",
        "comment": " Fixes the erroneous <tt>BasicObject < Object</tt> in 1.9.  Because we assumed all classes without a stated superclass inherit from Object, we have the above wrong inheritance.  We fix BasicObject right away if we are running in a Ruby version >= 1.9.",
        "label": "Why",
        "id": "370"
    },
    {
        "raw_code": "def friendly_path\n    case type\n    when :gem    then\n      parent = File.expand_path '..', @path\n      \"gem #{File.basename parent}\"\n    when :home   then RDoc.home\n    when :site   then 'ruby site'\n    when :system then 'ruby core'\n    else @path\n    end",
        "comment": " Friendly rendition of #path",
        "label": "How-to-use",
        "id": "371"
    },
    {
        "raw_code": "def instance_methods\n    @cache[:instance_methods]\n  end",
        "comment": " Instance methods cache accessor.  Maps a class to an Array of its instance methods (not full name).",
        "label": "What",
        "id": "372"
    },
    {
        "raw_code": "def load_all\n    load_cache\n\n    module_names.each do |module_name|\n      mod = find_class_or_module(module_name) || load_class(module_name)\n\n      # load method documentation since the loaded class/module does not have\n      # it\n      loaded_methods = mod.method_list.map do |method|\n        load_method module_name, method.full_name\n      end",
        "comment": " Loads all items from this store into memory.  This recreates a documentation tree for use by a generator",
        "label": "How-it-is-done",
        "id": "373"
    },
    {
        "raw_code": "def load_cache\n    #orig_enc = @encoding\n\n    @cache = marshal_load(cache_path)\n\n    load_enc = @cache[:encoding]\n\n    # TODO this feature will be time-consuming to add:\n    # a) Encodings may be incompatible but transcodeable\n    # b) Need to warn in the appropriate spots, wherever they may be\n    # c) Need to handle cross-cache differences in encodings\n    # d) Need to warn when generating into a cache with different encodings\n    #\n    #if orig_enc and load_enc != orig_enc then\n    #  warn \"Cached encoding #{load_enc} is incompatible with #{orig_enc}\\n\" \\\n    #       \"from #{path}/cache.ri\" unless\n    #    Encoding.compatible? orig_enc, load_enc\n    #end\n\n    @encoding = load_enc unless @encoding\n\n    @cache[:pages]                       ||= []\n    @cache[:main]                        ||= nil\n    @cache[:c_class_variables]           ||= {}\n    @cache[:c_singleton_class_variables] ||= {}\n\n    @cache[:c_class_variables].each do |_, map|\n      map.each do |variable, name|\n        @c_enclosure_names[variable] = name\n      end",
        "comment": " Loads cache file for this store",
        "label": "What",
        "id": "374"
    },
    {
        "raw_code": "def load_class(klass_name)\n    obj = load_class_data klass_name\n\n    obj.store = self\n\n    case obj\n    when RDoc::NormalClass then\n      @classes_hash[klass_name] = obj\n    when RDoc::SingleClass then\n      @classes_hash[klass_name] = obj\n    when RDoc::NormalModule then\n      @modules_hash[klass_name] = obj\n    end",
        "comment": " Loads ri data for +klass_name+ and hooks it up to this store.",
        "label": "What",
        "id": "375"
    },
    {
        "raw_code": "def load_class_data(klass_name)\n    file = class_file klass_name\n\n    marshal_load(file)\n  rescue Errno::ENOENT => e\n    error = MissingFileError.new(self, file, klass_name)\n    error.set_backtrace e.backtrace\n    raise error\n  end",
        "comment": " Loads ri data for +klass_name+",
        "label": "Why",
        "id": "376"
    },
    {
        "raw_code": "def load_method(klass_name, method_name)\n    file = method_file klass_name, method_name\n\n    obj = marshal_load(file)\n    obj.store = self\n    obj.parent ||= find_class_or_module(klass_name) || load_class(klass_name)\n    obj\n  rescue Errno::ENOENT => e\n    error = MissingFileError.new(self, file, klass_name + method_name)\n    error.set_backtrace e.backtrace\n    raise error\n  end",
        "comment": " Loads ri data for +method_name+ in +klass_name+",
        "label": "Why",
        "id": "377"
    },
    {
        "raw_code": "def load_page(page_name)\n    file = page_file page_name\n\n    obj = marshal_load(file)\n    obj.store = self\n    obj\n  rescue Errno::ENOENT => e\n    error = MissingFileError.new(self, file, page_name)\n    error.set_backtrace e.backtrace\n    raise error\n  end",
        "comment": " Loads ri data for +page_name+",
        "label": "What",
        "id": "378"
    },
    {
        "raw_code": "def main\n    @cache[:main]\n  end",
        "comment": " Gets the main page for this RDoc store.  This page is used as the root of the RDoc server.",
        "label": "What",
        "id": "379"
    },
    {
        "raw_code": "def main=(page)\n    @cache[:main] = page\n  end",
        "comment": " Sets the main page for this RDoc store.",
        "label": "What",
        "id": "380"
    },
    {
        "raw_code": "def make_variable_map(variables)\n    map = {}\n\n    variables.each { |variable, class_module|\n      map[variable] = class_module.full_name\n    }\n\n    map\n  end",
        "comment": " Converts the variable => ClassModule map +variables+ from a C parser into a variable => class name map.",
        "label": "How-to-use",
        "id": "381"
    },
    {
        "raw_code": "def method_file(klass_name, method_name)\n    method_name = method_name.split('::').last\n    method_name =~ /#(.*)/\n    method_type = $1 ? 'i' : 'c'\n    method_name = $1 if $1\n    method_name = method_name.gsub(/\\W/) { \"%%%02x\" % $&[0].ord }\n\n    File.join class_path(klass_name), \"#{method_name}-#{method_type}.ri\"\n  end",
        "comment": " Path to the ri data for +method_name+ in +klass_name+",
        "label": "What",
        "id": "382"
    },
    {
        "raw_code": "def module_names\n    @cache[:modules]\n  end",
        "comment": " Modules cache accessor.  An Array of all the module (and class) names in the store.",
        "label": "What",
        "id": "383"
    },
    {
        "raw_code": "def modules_hash\n    @modules_hash\n  end",
        "comment": " Hash of all modules known to RDoc",
        "label": "What",
        "id": "384"
    },
    {
        "raw_code": "def page(name)\n    @files_hash.each_value.find do |file|\n      file.page_name == name or file.base_name == name\n    end",
        "comment": " Returns the RDoc::TopLevel that is a file and has the given +name+",
        "label": "Property",
        "id": "385"
    },
    {
        "raw_code": "def page_file(page_name)\n    file_name = File.basename(page_name).gsub('.', '_')\n\n    File.join @path, File.dirname(page_name), \"page-#{file_name}.ri\"\n  end",
        "comment": " Path to the ri data for +page_name+",
        "label": "What",
        "id": "386"
    },
    {
        "raw_code": "def remove_nodoc(all_hash)\n    all_hash.keys.each do |name|\n      context = all_hash[name]\n      all_hash.delete(name) if context.remove_from_documentation?\n    end",
        "comment": " Removes from +all_hash+ the contexts that are nodoc or have no content.  See RDoc::Context#remove_from_documentation?",
        "label": "What",
        "id": "387"
    },
    {
        "raw_code": "def save\n    load_cache\n\n    all_classes_and_modules.each do |klass|\n      save_class klass\n\n      klass.each_method do |method|\n        save_method klass, method\n      end",
        "comment": " Saves all entries in the store",
        "label": "What",
        "id": "388"
    },
    {
        "raw_code": "def save_cache\n    clean_cache_collection @cache[:ancestors]\n    clean_cache_collection @cache[:attributes]\n    clean_cache_collection @cache[:class_methods]\n    clean_cache_collection @cache[:instance_methods]\n\n    @cache[:modules].uniq!\n    @cache[:modules].sort!\n\n    @cache[:pages].uniq!\n    @cache[:pages].sort!\n\n    @cache[:encoding] = @encoding # this gets set twice due to assert_cache\n\n    @cache[:c_class_variables].merge!           @c_class_variables\n    @cache[:c_singleton_class_variables].merge! @c_singleton_class_variables\n\n    return if @dry_run\n\n    File.open cache_path, 'wb' do |io|\n      Marshal.dump @cache, io\n    end",
        "comment": " Writes the cache file for this store",
        "label": "What",
        "id": "389"
    },
    {
        "raw_code": "def save_class(klass)\n    full_name = klass.full_name\n\n    FileUtils.mkdir_p class_path(full_name) unless @dry_run\n\n    @cache[:modules] << full_name\n\n    path = class_file full_name\n\n    begin\n      disk_klass = load_class full_name\n\n      klass = disk_klass.merge klass\n    rescue MissingFileError\n    end",
        "comment": " Writes the ri data for +klass+ (or module)",
        "label": "Property",
        "id": "390"
    },
    {
        "raw_code": "def save_method(klass, method)\n    full_name = klass.full_name\n\n    FileUtils.mkdir_p class_path(full_name) unless @dry_run\n\n    cache = if method.singleton then\n              @cache[:class_methods]\n            else\n              @cache[:instance_methods]\n            end",
        "comment": " Writes the ri data for +method+ on +klass+",
        "label": "What",
        "id": "391"
    },
    {
        "raw_code": "def save_page(page)\n    return unless page.text?\n\n    path = page_file page.full_name\n\n    FileUtils.mkdir_p File.dirname(path) unless @dry_run\n\n    cache[:pages] ||= []\n    cache[:pages] << page.full_name\n\n    return if @dry_run\n\n    File.open path, 'wb' do |io|\n      Marshal.dump page, io\n    end",
        "comment": " Writes the ri data for +page+",
        "label": "What",
        "id": "392"
    },
    {
        "raw_code": "def source\n    case type\n    when :gem    then File.basename File.expand_path '..', @path\n    when :home   then 'home'\n    when :site   then 'site'\n    when :system then 'ruby'\n    else @path\n    end",
        "comment": " Source of the contents of this store.  For a store from a gem the source is the gem name.  For a store from the home directory the source is \"home\".  For system ri store (the standard library documentation) the source is\"ruby\".  For a store from the site ri directory the store is \"site\".  For other stores the source is the #path.",
        "label": "Others",
        "id": "393"
    },
    {
        "raw_code": "def title\n    @cache[:title]\n  end",
        "comment": " Gets the title for this RDoc store.  This is used as the title in each page on the RDoc server",
        "label": "What",
        "id": "394"
    },
    {
        "raw_code": "def title=(title)\n    @cache[:title] = title\n  end",
        "comment": " Sets the title page for this RDoc store.",
        "label": "What",
        "id": "395"
    },
    {
        "raw_code": "def unique_classes\n    @unique_classes\n  end",
        "comment": " Returns the unique classes discovered by RDoc.  ::complete must have been called prior to using this method.",
        "label": "How-to-use",
        "id": "396"
    },
    {
        "raw_code": "def unique_classes_and_modules\n    @unique_classes + @unique_modules\n  end",
        "comment": " Returns the unique classes and modules discovered by RDoc. ::complete must have been called prior to using this method.",
        "label": "How-to-use",
        "id": "397"
    },
    {
        "raw_code": "def unique_modules\n    @unique_modules\n  end",
        "comment": " Returns the unique modules discovered by RDoc. ::complete must have been called prior to using this method.",
        "label": "How-to-use",
        "id": "398"
    },
    {
        "raw_code": "def self.generate(installer, specs)\n    start = Time.now\n    types = installer.document\n\n    generate_rdoc = types.include? 'rdoc'\n    generate_ri   = types.include? 'ri'\n\n    specs.each do |spec|\n      new(spec, generate_rdoc, generate_ri).generate\n    end",
        "comment": " Post installs hook that generates documentation for each specification in +specs+",
        "label": "How-to-use",
        "id": "399"
    },
    {
        "raw_code": "def self.load_rdoc\n    return if @rdoc_version\n\n    require_relative 'rdoc'\n\n    @rdoc_version = Gem::Version.new ::RDoc::VERSION\n  end",
        "comment": " Loads the RDoc generator",
        "label": "How-to-use",
        "id": "400"
    },
    {
        "raw_code": "def initialize(spec, generate_rdoc = false, generate_ri = true)\n    @doc_dir   = spec.doc_dir\n    @force     = false\n    @rdoc      = nil\n    @spec      = spec\n\n    @generate_rdoc = generate_rdoc\n    @generate_ri   = generate_ri\n\n    @rdoc_dir = spec.doc_dir 'rdoc'\n    @ri_dir   = spec.doc_dir 'ri'\n  end",
        "comment": " Creates a new documentation generator for +spec+.  RDoc and ri data generation can be enabled or disabled through +generate_rdoc+ and +generate_ri+ respectively.  Only +generate_ri+ is enabled by default.",
        "label": "How-it-is-done",
        "id": "401"
    },
    {
        "raw_code": "def delete_legacy_args(args)\n    args.delete '--inline-source'\n    args.delete '--promiscuous'\n    args.delete '-p'\n    args.delete '--one-file'\n  end",
        "comment": " Removes legacy rdoc arguments from +args+ -- TODO move to RDoc::Options",
        "label": "How-to-use",
        "id": "402"
    },
    {
        "raw_code": "def document(generator, options, destination)\n    generator_name = generator\n\n    options = options.dup\n    options.exclude ||= [] # TODO maybe move to RDoc::Options#finish\n    options.setup_generator generator\n    options.op_dir = destination\n    Dir.chdir @spec.full_gem_path do\n      options.finish\n    end",
        "comment": " Generates documentation using the named +generator+ (\"darkfish\" or \"ri\") and following the given +options+.  Documentation will be generated into +destination+",
        "label": "How-to-use",
        "id": "403"
    },
    {
        "raw_code": "def generate\n    return if @spec.default_gem?\n    return unless @generate_ri or @generate_rdoc\n\n    setup\n\n    options = nil\n\n    args = @spec.rdoc_options\n    args.concat @spec.source_paths\n    args.concat @spec.extra_rdoc_files\n\n    case config_args = Gem.configuration[:rdoc]\n    when String then\n      args = args.concat config_args.split(' ')\n    when Array then\n      args = args.concat config_args\n    end",
        "comment": " Generates RDoc and ri data",
        "label": "What",
        "id": "404"
    },
    {
        "raw_code": "def new_rdoc # :nodoc:\n    ::RDoc::RDoc.new\n  end",
        "comment": " #new_rdoc creates a new RDoc instance.  This method is provided only to make testing easier.",
        "label": "How-it-is-done",
        "id": "405"
    },
    {
        "raw_code": "def rdoc_installed?\n    File.exist? @rdoc_dir\n  end",
        "comment": " Is rdoc documentation installed?",
        "label": "What",
        "id": "406"
    },
    {
        "raw_code": "def remove\n    base_dir = @spec.base_dir\n\n    raise Gem::FilePermissionError, base_dir unless File.writable? base_dir\n\n    FileUtils.rm_rf @rdoc_dir\n    FileUtils.rm_rf @ri_dir\n  end",
        "comment": " Removes generated RDoc and ri data",
        "label": "What",
        "id": "407"
    },
    {
        "raw_code": "def ri_installed?\n    File.exist? @ri_dir\n  end",
        "comment": " Is ri data installed?",
        "label": "What",
        "id": "408"
    },
    {
        "raw_code": "def setup\n    self.class.load_rdoc\n\n    raise Gem::FilePermissionError, @doc_dir if\n      File.exist?(@doc_dir) and not File.writable?(@doc_dir)\n\n    FileUtils.mkdir_p @doc_dir unless File.exist? @doc_dir\n  end",
        "comment": " Prepares the spec for documentation generation",
        "label": "What",
        "id": "409"
    },
    {
        "raw_code": "def initialize\n    @metadata         = {}\n    @comment          = ''\n    @parent           = nil\n    @parent_name      = nil # for loading\n    @parent_class     = nil # for loading\n    @section          = nil\n    @section_title    = nil # for loading\n    @file             = nil\n    @full_name        = nil\n    @store            = nil\n    @track_visibility = true\n    @mixin_from       = nil\n\n    initialize_visibility\n  end",
        "comment": " Creates a new CodeObject that will document itself and its children",
        "label": "How-it-is-done",
        "id": "410"
    },
    {
        "raw_code": "def initialize_visibility # :nodoc:\n    @document_children   = true\n    @document_self       = true\n    @done_documenting    = false\n    @force_documentation = false\n    @received_nodoc      = false\n    @ignored             = false\n    @suppressed          = false\n    @track_visibility    = true\n  end",
        "comment": " Initializes state for visibility of this CodeObject and its children.",
        "label": "How-to-use",
        "id": "411"
    },
    {
        "raw_code": "def comment=(comment)\n    @comment = case comment\n               when NilClass               then ''\n               when RDoc::Comment          then comment.normalize\n               else\n                 if comment and not comment.empty? then\n                   normalize_comment comment\n                 else\n                   # HACK correct fix is to have #initialize create @comment\n                   #      with the correct encoding\n                   if String === @comment and @comment.empty? then\n                     @comment = RDoc::Encoding.change_encoding @comment, comment.encoding\n                   end",
        "comment": " Replaces our comment with +comment+, unless it is empty.",
        "label": "Others",
        "id": "412"
    },
    {
        "raw_code": "def display?\n    @document_self and not @ignored and\n      (documented? or not @suppressed)\n  end",
        "comment": " Should this CodeObject be displayed in output?  A code object should be displayed if:  * The item didn't have a nodoc or wasn't in a container that had nodoc * The item wasn't ignored * The item has documentation and was not suppressed",
        "label": "Why",
        "id": "413"
    },
    {
        "raw_code": "def document_children=(document_children)\n    return unless @track_visibility\n\n    @document_children = document_children unless @done_documenting\n  end",
        "comment": " Enables or disables documentation of this CodeObject's children unless it has been turned off by :enddoc:",
        "label": "What",
        "id": "414"
    },
    {
        "raw_code": "def document_self=(document_self)\n    return unless @track_visibility\n    return if @done_documenting\n\n    @document_self = document_self\n    @received_nodoc = true if document_self.nil?\n  end",
        "comment": " Enables or disables documentation of this CodeObject unless it has been turned off by :enddoc:.  If the argument is +nil+ it means the documentation is turned off by +:nodoc:+.",
        "label": "What",
        "id": "415"
    },
    {
        "raw_code": "def documented?\n    @received_nodoc or !@comment.empty?\n  end",
        "comment": " Does this object have a comment with content or is #received_nodoc true?",
        "label": "How-it-is-done",
        "id": "416"
    },
    {
        "raw_code": "def done_documenting=(value)\n    return unless @track_visibility\n    @done_documenting  = value\n    @document_self     = !value\n    @document_children = @document_self\n  end",
        "comment": " Turns documentation on/off, and turns on/off #document_self and #document_children.  Once documentation has been turned off (by +:enddoc:+), the object will refuse to turn #document_self or #document_children on, so +:doc:+ and +:start_doc:+ directives will have no effect in the current file.",
        "label": "What",
        "id": "417"
    },
    {
        "raw_code": "def file_name\n    return unless @file\n\n    @file.absolute_name\n  end",
        "comment": " File name where this CodeObject was found.  See also RDoc::Context#in_files",
        "label": "What",
        "id": "418"
    },
    {
        "raw_code": "def force_documentation=(value)\n    @force_documentation = value unless @done_documenting\n  end",
        "comment": " Force the documentation of this object unless documentation has been turned off by :enddoc: -- HACK untested, was assigning to an ivar",
        "label": "What",
        "id": "419"
    },
    {
        "raw_code": "def full_name=(full_name)\n    @full_name = full_name\n  end",
        "comment": " Sets the full_name overriding any computed full name.  Set to +nil+ to clear RDoc's cached value",
        "label": "What",
        "id": "420"
    },
    {
        "raw_code": "def ignore\n    return unless @track_visibility\n\n    @ignored = true\n\n    stop_doc\n  end",
        "comment": " Use this to ignore a CodeObject and all its children until found again (#record_location is called).  An ignored item will not be displayed in documentation.  See github issue #55  The ignored status is temporary in order to allow implementation details to be hidden.  At the end of processing a file RDoc allows all classes and modules to add new documentation to previously created classes.  If a class was ignored (via stopdoc) then reopened later with additional documentation it should be displayed.  If a class was ignored and never reopened it should not be displayed.  The ignore flag allows this to occur.",
        "label": "How-to-use",
        "id": "421"
    },
    {
        "raw_code": "def ignored?\n    @ignored\n  end",
        "comment": " Has this class been ignored?  See also #ignore",
        "label": "What",
        "id": "422"
    },
    {
        "raw_code": "def options\n    @store&.options || RDoc::Options.new\n  end",
        "comment": " The options instance from the store this CodeObject is attached to, or a default options instance if the CodeObject is not attached.  This is used by Text#snippet",
        "label": "What",
        "id": "423"
    },
    {
        "raw_code": "def parent\n    return @parent if @parent\n    return nil unless @parent_name\n\n    if @parent_class == RDoc::TopLevel then\n      @parent = @store.add_file @parent_name\n    else\n      @parent = @store.find_class_or_module @parent_name\n\n      return @parent if @parent\n\n      begin\n        @parent = @store.load_class @parent_name\n      rescue RDoc::Store::MissingFileError\n        nil\n      end",
        "comment": " Our parent CodeObject.  The parent may be missing for classes loaded from legacy RI data stores.",
        "label": "What",
        "id": "424"
    },
    {
        "raw_code": "def parent_name\n    @parent ? @parent.full_name : '(unknown)'\n  end",
        "comment": " Name of our parent",
        "label": "What",
        "id": "425"
    },
    {
        "raw_code": "def record_location(top_level)\n    @ignored    = false\n    @suppressed = false\n    @file       = top_level\n  end",
        "comment": " Records the RDoc::TopLevel (file) where this code object was defined",
        "label": "What",
        "id": "426"
    },
    {
        "raw_code": "def section\n    return @section if @section\n\n    @section = parent.add_section @section_title if parent\n  end",
        "comment": " The section this CodeObject is in.  Sections allow grouping of constants, attributes and methods inside a class or module.",
        "label": "What",
        "id": "427"
    },
    {
        "raw_code": "def start_doc\n    return if @done_documenting\n\n    @document_self = true\n    @document_children = true\n    @ignored    = false\n    @suppressed = false\n  end",
        "comment": " Enable capture of documentation unless documentation has been turned off by :enddoc:",
        "label": "Why",
        "id": "428"
    },
    {
        "raw_code": "def stop_doc\n    return unless @track_visibility\n\n    @document_self = false\n    @document_children = false\n  end",
        "comment": " Disable capture of documentation",
        "label": "Others",
        "id": "429"
    },
    {
        "raw_code": "def store=(store)\n    @store = store\n\n    return unless @track_visibility\n\n    if :nodoc == options.visibility then\n      initialize_visibility\n      @track_visibility = false\n    end",
        "comment": " Sets the +store+ that contains this CodeObject",
        "label": "What",
        "id": "430"
    },
    {
        "raw_code": "def suppress\n    return unless @track_visibility\n\n    @suppressed = true\n\n    stop_doc\n  end",
        "comment": " Use this to suppress a CodeObject and all its children until the next file it is seen in or documentation is discovered.  A suppressed item with documentation will be displayed while an ignored item with documentation may not be displayed.",
        "label": "How-to-use",
        "id": "431"
    },
    {
        "raw_code": "def suppressed?\n    @suppressed\n  end",
        "comment": " Has this class been suppressed?  See also #suppress",
        "label": "What",
        "id": "432"
    },
    {
        "raw_code": "def self.get_instance server, *options # :nodoc:\n    stores = @server_stores[server]\n\n    new server, stores, @cache, *options\n  end",
        "comment": " Creates an instance of this servlet that shares cached data between requests.",
        "label": "How-it-is-done",
        "id": "433"
    },
    {
        "raw_code": "def initialize(server, stores, cache, mount_path = nil, extra_doc_dirs = [])\n    super server\n\n    @cache      = cache\n    @mount_path = mount_path\n    @extra_doc_dirs = extra_doc_dirs\n    @stores     = stores\n\n    @options = RDoc::Options.new\n    @options.op_dir = '.'\n\n    darkfish_dir = nil\n\n    # HACK dup\n    $LOAD_PATH.each do |path|\n      darkfish_dir = File.join path, 'rdoc/generator/template/darkfish/'\n      next unless File.directory? darkfish_dir\n      @options.template_dir = darkfish_dir\n      break\n    end",
        "comment": " Creates a new WEBrick servlet.  Use +mount_path+ when mounting the servlet somewhere other than /.  Use +extra_doc_dirs+ for additional documentation directories.  +server+ is provided automatically by WEBrick when mounting.  +stores+ and +cache+ are provided automatically by the servlet.",
        "label": "How-to-use",
        "id": "434"
    },
    {
        "raw_code": "def asset(generator_name, req, res)\n    asset_dir = @asset_dirs[generator_name]\n\n    asset_path = File.join asset_dir, req.path\n\n    if_modified_since req, res, asset_path\n\n    res.body = File.read asset_path\n\n    res.content_type = case req.path\n                       when /\\.css\\z/ then 'text/css'\n                       when /\\.js\\z/  then 'application/javascript'\n                       else                'application/octet-stream'\n                       end",
        "comment": " Serves the asset at the path in +req+ for +generator_name+ via +res+.",
        "label": "Property",
        "id": "435"
    },
    {
        "raw_code": "def do_GET(req, res)\n    req.path.sub!(/\\A#{Regexp.escape @mount_path}/, '') if @mount_path\n\n    case req.path\n    when '/' then\n      root req, res\n    when '/js/darkfish.js', '/js/jquery.js', '/js/search.js',\n         %r%^/css/%, %r%^/images/%, %r%^/fonts/% then\n      asset :darkfish, req, res\n    when '/js/navigation.js', '/js/searcher.js' then\n      asset :json_index, req, res\n    when '/js/search_index.js' then\n      root_search req, res\n    else\n      show_documentation req, res\n    end",
        "comment": " GET request entry point.  Fills in +res+ for the path, etc. in +req+.",
        "label": "What",
        "id": "436"
    },
    {
        "raw_code": "def documentation_page(store, generator, path, req, res)\n    text_name = path.chomp '.html'\n    name = text_name.gsub '/', '::'\n\n    if klass = store.find_class_or_module(name) then\n      res.body = generator.generate_class klass\n    elsif page = store.find_text_page(name.sub(/_([^_]*)\\z/, '.\\1')) then\n      res.body = generator.generate_page page\n    elsif page = store.find_text_page(text_name.sub(/_([^_]*)\\z/, '.\\1')) then\n      res.body = generator.generate_page page\n    else\n      not_found generator, req, res\n    end",
        "comment": " Fills in +res+ with the class, module or page for +req+ from +store+.  +path+ is relative to the mount_path and is used to determine the class, module or page name (/RDoc/Servlet.html becomes RDoc::Servlet). +generator+ is used to create the page.",
        "label": "What",
        "id": "437"
    },
    {
        "raw_code": "def documentation_search(store, generator, req, res)\n    json_index = @cache[store].fetch :json_index do\n      @cache[store][:json_index] =\n        JSON.dump generator.json_index.build_index\n    end",
        "comment": " Creates the JSON search index on +res+ for the given +store+.  +generator+ must respond to \\#json_index to build.  +req+ is ignored.",
        "label": "How-it-is-done",
        "id": "438"
    },
    {
        "raw_code": "def documentation_source(path)\n    _, source_name, path = path.split '/', 3\n\n    store = @stores[source_name]\n    return store, path if store\n\n    store = store_for source_name\n\n    store.load_all\n\n    @stores[source_name] = store\n\n    return store, path\n  end",
        "comment": " Returns the RDoc::Store and path relative to +mount_path+ for documentation at +path+.",
        "label": "Property",
        "id": "439"
    },
    {
        "raw_code": "def error(exception, req, res)\n    backtrace = exception.backtrace.join \"\\n\"\n\n    res.content_type = 'text/html'\n    res.status = 500\n    res.body = <<-BODY\n<!DOCTYPE html>\n<html>\n<head>\n<meta content=\"text/html; charset=UTF-8\" http-equiv=\"Content-Type\">\n\n<title>Error - #{ERB::Util.html_escape exception.class}</title>\n\n<link type=\"text/css\" media=\"screen\" href=\"#{@mount_path}/css/rdoc.css\" rel=\"stylesheet\">\n</head>\n<body>\n<h1>Error</h1>\n\n<p>While processing <code>#{ERB::Util.html_escape req.request_uri}</code> the\nRDoc (#{ERB::Util.html_escape RDoc::VERSION}) server has encountered a\n<code>#{ERB::Util.html_escape exception.class}</code>\nexception:\n\n<pre>#{ERB::Util.html_escape exception.message}</pre>\n\n<p>Please report this to the\n<a href=\"https://github.com/ruby/rdoc/issues\">RDoc issues tracker</a>.  Please\ninclude the RDoc version, the URI above and exception class, message and\nbacktrace.  If you're viewing a gem's documentation, include the gem name and\nversion.  If you're viewing Ruby's documentation, include the version of ruby.\n\n<p>Backtrace:\n\n<pre>#{ERB::Util.html_escape backtrace}</pre>\n\n</body>\n</html>\n    BODY\n  end",
        "comment": " Generates an error page for the +exception+ while handling +req+ on +res+.",
        "label": "What",
        "id": "440"
    },
    {
        "raw_code": "def generator_for(store)\n    generator = RDoc::Generator::Darkfish.new store, @options\n    generator.file_output = false\n    generator.asset_rel_path = '..'\n    generator.setup\n\n    rdoc = RDoc::RDoc.new\n    rdoc.store     = store\n    rdoc.generator = generator\n    rdoc.options   = @options\n\n    @options.main_page = store.main\n    @options.title     = store.title\n\n    generator\n  end",
        "comment": " Instantiates a Darkfish generator for +store+",
        "label": "What",
        "id": "441"
    },
    {
        "raw_code": "def if_modified_since(req, res, path = nil)\n    last_modified = File.stat(path).mtime if path\n\n    res['last-modified'] = last_modified.httpdate\n\n    return unless ims = req['if-modified-since']\n\n    ims = Time.parse ims\n\n    unless ims < last_modified then\n      res.body = ''\n      raise WEBrick::HTTPStatus::NotModified\n    end",
        "comment": " Handles the If-Modified-Since HTTP header on +req+ for +path+.  If the file has not been modified a Not Modified response is returned.  If the file has been modified a Last-Modified header is added to +res+.",
        "label": "How-it-is-done",
        "id": "442"
    },
    {
        "raw_code": "def installed_docs\n    extra_counter = 0\n    ri_paths.map do |path, type|\n      store = RDoc::Store.new(@options, path: path, type: type)\n      exists = File.exist? store.cache_path\n\n      case type\n      when :gem then\n        gem_path = path[%r%/([^/]*)/ri$%, 1]\n        [gem_path, \"#{gem_path}/\", exists, type, path]\n      when :system then\n        ['Ruby Documentation', 'ruby/', exists, type, path]\n      when :site then\n        ['Site Documentation', 'site/', exists, type, path]\n      when :home then\n        ['Home Documentation', 'home/', exists, type, path]\n      when :extra then\n        extra_counter += 1\n        store.load_cache if exists\n        title = store.title || \"Extra Documentation\"\n        [title, \"extra-#{extra_counter}/\", exists, type, path]\n      end",
        "comment": " Returns an Array of installed documentation.  Each entry contains the documentation name (gem name, 'Ruby Documentation', etc.), the path relative to the mount point, whether the documentation exists, the type of documentation (See RDoc::RI::Paths#each) and the filesystem to the RDoc::Store for the documentation.",
        "label": "Property",
        "id": "443"
    },
    {
        "raw_code": "def not_found(generator, req, res, message = nil)\n    message ||= \"The page <kbd>#{ERB::Util.h req.path}</kbd> was not found\"\n    res.body = generator.generate_servlet_not_found message\n    res.status = 404\n  end",
        "comment": " Returns a 404 page built by +generator+ for +req+ on +res+.",
        "label": "Property",
        "id": "444"
    },
    {
        "raw_code": "def ri_paths(&block)\n    RDoc::RI::Paths.each true, true, true, :all, *@extra_doc_dirs, &block #TODO: pass extra_dirs\n  end",
        "comment": " Enumerates the ri paths.  See RDoc::RI::Paths#each",
        "label": "What",
        "id": "445"
    },
    {
        "raw_code": "def root(req, res)\n    generator = RDoc::Generator::Darkfish.new nil, @options\n\n    res.body = generator.generate_servlet_root installed_docs\n\n    res.content_type = 'text/html'\n  end",
        "comment": " Generates the root page on +res+.  +req+ is ignored.",
        "label": "What",
        "id": "446"
    },
    {
        "raw_code": "def root_search(req, res)\n    search_index = []\n    info         = []\n\n    installed_docs.map do |name, href, exists, type, path|\n      next unless exists\n\n      search_index << name\n\n      case type\n      when :gem\n        gemspec = path.gsub(%r%/doc/([^/]*?)/ri$%,\n                            '/specifications/\\1.gemspec')\n\n        spec = Gem::Specification.load gemspec\n\n        path    = spec.full_name\n        comment = spec.summary\n      when :system then\n        path    = 'ruby'\n        comment = 'Documentation for the Ruby standard library'\n      when :site then\n        path    = 'site'\n        comment = 'Documentation for non-gem libraries'\n      when :home then\n        path    = 'home'\n        comment = 'Documentation from your home directory'\n      when :extra\n        comment = name\n      end",
        "comment": " Generates a search index for the root page on +res+.  +req+ is ignored.",
        "label": "What",
        "id": "447"
    },
    {
        "raw_code": "def show_documentation(req, res)\n    store, path = documentation_source req.path\n\n    if_modified_since req, res, store.cache_path\n\n    generator = generator_for store\n\n    case path\n    when nil, '', 'index.html' then\n      res.body = generator.generate_index\n    when 'table_of_contents.html' then\n      res.body = generator.generate_table_of_contents\n    when 'js/search_index.js' then\n      documentation_search store, generator, req, res\n    else\n      documentation_page store, generator, path, req, res\n    end",
        "comment": " Displays documentation for +req+ on +res+, whether that be HTML or some asset.",
        "label": "How-to-use",
        "id": "448"
    },
    {
        "raw_code": "def store_for(source_name)\n    case source_name\n    when 'home' then\n      RDoc::Store.new(@options, path: RDoc::RI::Paths.home_dir, type: :home)\n    when 'ruby' then\n      RDoc::Store.new(@options, path: RDoc::RI::Paths.system_dir, type: :system)\n    when 'site' then\n      RDoc::Store.new(@options, path: RDoc::RI::Paths.site_dir, type: :site)\n    when /\\Aextra-(\\d+)\\z/ then\n      index = $1.to_i - 1\n      ri_dir = installed_docs[index][4]\n      RDoc::Store.new(@options, path: ri_dir, type: :extra)\n    else\n      ri_dir, type = ri_paths.find do |dir, dir_type|\n        next unless dir_type == :gem\n\n        source_name == dir[%r%/([^/]*)/ri$%, 1]\n      end",
        "comment": " Returns an RDoc::Store for the given +source_name+ ('ruby' or a gem name).",
        "label": "Property",
        "id": "449"
    },
    {
        "raw_code": "def self.parse(str)\n    RDoc::Markup::Parser.parse str\n  rescue RDoc::Markup::Parser::Error => e\n    $stderr.puts <<-EOF\nWhile parsing markup, RDoc encountered a #{e.class}:\n\n#{e}\n\\tfrom #{e.backtrace.join \"\\n\\tfrom \"}\n\n---8<---\n#{text}\n---8<---\n\nRDoc #{RDoc::VERSION}\n\nRuby #{RUBY_VERSION}-p#{RUBY_PATCHLEVEL} #{RUBY_RELEASE_DATE}\n\nPlease file a bug report with the above information at:\n\nhttps://github.com/ruby/rdoc/issues\n\n    EOF\n    raise\n  end",
        "comment": " Parses +str+ into an RDoc::Markup::Document.",
        "label": "What",
        "id": "450"
    },
    {
        "raw_code": "def initialize(attribute_manager = nil)\n    @attribute_manager = attribute_manager || RDoc::Markup::AttributeManager.new\n    @output = nil\n  end",
        "comment": " Take a block of text and use various heuristics to determine its structure (paragraphs, lists, and so on).  Invoke an event handler as we identify significant chunks.",
        "label": "How-to-use",
        "id": "451"
    },
    {
        "raw_code": "def add_word_pair(start, stop, name)\n    @attribute_manager.add_word_pair(start, stop, name)\n  end",
        "comment": " Add to the sequences used to add formatting to an individual word (such as *bold*).  Matching entries will generate attributes that the output formatters can recognize by their +name+.",
        "label": "How-to-use",
        "id": "452"
    },
    {
        "raw_code": "def add_html(tag, name)\n    @attribute_manager.add_html(tag, name)\n  end",
        "comment": " Add to the sequences recognized as general markup.",
        "label": "What",
        "id": "453"
    },
    {
        "raw_code": "def add_regexp_handling(pattern, name)\n    @attribute_manager.add_regexp_handling(pattern, name)\n  end",
        "comment": " Add to other inline sequences.  For example, we could add WikiWords using something like:  parser.add_regexp_handling(/\\b([A-Z][a-z]+[A-Z]\\w+)/, :WIKIWORD)  Each wiki word will be presented to the output formatter.",
        "label": "Others",
        "id": "454"
    },
    {
        "raw_code": "def convert(input, formatter)\n    document = case input\n               when RDoc::Markup::Document then\n                 input\n               else\n                 RDoc::Markup::Parser.parse input\n               end",
        "comment": " We take +input+, parse it if necessary, then invoke the output +formatter+ using a Visitor to render the result.",
        "label": "How-to-use",
        "id": "455"
    },
    {
        "raw_code": "def initialize(text = nil, location = nil, language = nil)\n    @location = location\n    @text     = text.nil? ? nil : text.dup\n    @language = language\n\n    @document   = nil\n    @format     = 'rdoc'\n    @normalized = false\n  end",
        "comment": " Creates a new comment with +text+ that is found in the RDoc::TopLevel +location+.",
        "label": "How-it-is-done",
        "id": "456"
    },
    {
        "raw_code": "def initialize_copy(copy) # :nodoc:\n    @text = copy.text.dup\n  end",
        "comment": " -- TODO deep copy @document",
        "label": "How-to-use",
        "id": "457"
    },
    {
        "raw_code": "def extract_call_seq\n    # we must handle situations like the above followed by an unindented first\n    # comment.  The difficulty is to make sure not to match lines starting\n    # with ARGF at the same indent, but that are after the first description\n    # paragraph.\n    if /^(?<S> ((?!\\n)\\s)*+        (?# whitespaces except newline))\n         :?call-seq:\n           (?<B> \\g<S>(?<N>\\n|\\z)  (?# trailing spaces))?\n         (?<seq>\n           (\\g<S>(?!\\w)\\S.*\\g<N>)*\n           (?>\n             (?<H> \\g<S>\\w+        (?# ' #   ARGF' in the example above))\n             .*\\g<N>)?\n           (\\g<S>\\S.*\\g<N>         (?# other non-blank line))*+\n           (\\g<B>+(\\k<H>.*\\g<N>    (?# ARGF.to_a lines))++)*+\n         )\n         (?m:^\\s*$|\\z)\n        /x =~ @text\n      seq = $~[:seq]\n\n      all_start, all_stop = $~.offset(0)\n      @text.slice! all_start...all_stop\n\n      seq.gsub!(/^\\s*/, '')\n    end",
        "comment": " Look for a 'call-seq' in the comment to override the normal parameter handling.  The :call-seq: is indented from the baseline.  All lines of the same indentation level and prefix are consumed.  For example, all of the following will be used as the :call-seq:  # :call-seq: #   ARGF.readlines(sep=$/)     -> array #   ARGF.readlines(limit)      -> array #   ARGF.readlines(sep, limit) -> array # #   ARGF.to_a(sep=$/)     -> array #   ARGF.to_a(limit)      -> array #   ARGF.to_a(sep, limit) -> array",
        "label": "How-to-use",
        "id": "458"
    },
    {
        "raw_code": "def empty?\n    @text.empty? && (@document.nil? || @document.empty?)\n  end",
        "comment": " A comment is empty if its text String is empty.",
        "label": "Others",
        "id": "459"
    },
    {
        "raw_code": "def encode!(encoding)\n    @text = String.new @text, encoding: encoding\n    self\n  end",
        "comment": " HACK dubious",
        "label": "What",
        "id": "460"
    },
    {
        "raw_code": "def format=(format)\n    @format = format\n    @document = nil\n  end",
        "comment": " Sets the format of this comment and resets any parsed document",
        "label": "What",
        "id": "461"
    },
    {
        "raw_code": "def normalize\n    return self unless @text\n    return self if @normalized # TODO eliminate duplicate normalization\n\n    @text = normalize_comment @text\n\n    @normalized = true\n\n    self\n  end",
        "comment": " Normalizes the text.  See RDoc::Text#normalize_comment for details",
        "label": "How-to-use",
        "id": "462"
    },
    {
        "raw_code": "def normalized? # :nodoc:\n    @normalized\n  end",
        "comment": " Was this text normalized?",
        "label": "Others",
        "id": "463"
    },
    {
        "raw_code": "def parse\n    return @document if @document\n\n    @document = super @text, @format\n    @document.file = @location\n    @document\n  end",
        "comment": " Parses the comment into an RDoc::Markup::Document.  The parsed document is cached until the text is changed.",
        "label": "What",
        "id": "464"
    },
    {
        "raw_code": "def remove_private\n    # Workaround for gsub encoding for Ruby 1.9.2 and earlier\n    empty = ''\n    empty = RDoc::Encoding.change_encoding empty, @text.encoding\n\n    @text = @text.gsub(%r%^\\s*([#*]?)--.*?^\\s*(\\1)\\+\\+\\n?%m, empty)\n    @text = @text.sub(%r%^\\s*[#*]?--.*%m, '')\n  end",
        "comment": " Removes private sections from this comment.  Private sections are flush to the comment marker and start with <tt>--</tt> and end with <tt>++</tt>. For C-style comments, a private marker may not start at the opening of the comment.  /* *-- * private *++ * public */",
        "label": "What",
        "id": "465"
    },
    {
        "raw_code": "def text=(text)\n    raise RDoc::Error, 'replacing document-only comment is not allowed' if\n      @text.nil? and @document\n\n    @document = nil\n    @text = text.nil? ? nil : text.dup\n  end",
        "comment": " Replaces this comment's text with +text+ and resets the parsed document.  An error is raised if the comment contains a document but no text.",
        "label": "Others",
        "id": "466"
    },
    {
        "raw_code": "def tomdoc?\n    @format == 'tomdoc'\n  end",
        "comment": " Returns true if this comment is in TomDoc format.",
        "label": "Property",
        "id": "467"
    },
    {
        "raw_code": "def self.from_document(document) # :nodoc:\n    comment = RDoc::Comment.new('')\n    comment.document = document\n    comment.location = RDoc::TopLevel.new(document.file) if document.file\n    comment\n  end",
        "comment": " Create a new parsed comment from a document",
        "label": "How-to-use",
        "id": "468"
    },
    {
        "raw_code": "def self.parse(rd)\n    rd = rd.lines.to_a\n\n    if rd.find { |i| /\\S/ === i } and !rd.find{|i| /^=begin\\b/ === i } then\n      rd.unshift(\"=begin\\n\").push(\"=end\\n\")\n    end",
        "comment": " Parses +rd+ source and returns an RDoc::Markup::Document.  If the <tt>=begin</tt> or <tt>=end</tt> lines are missing they will be added.",
        "label": "Property",
        "id": "469"
    },
    {
        "raw_code": "def self.read_file(filename, encoding, force_transcode = false)\n    content = File.open filename, \"rb\" do |f| f.read end\n    content.gsub!(\"\\r\\n\", \"\\n\") if RUBY_PLATFORM =~ /mswin|mingw/\n\n    utf8 = content.sub!(/\\A\\xef\\xbb\\xbf/, '')\n\n    enc = RDoc::Encoding.detect_encoding content\n    content = RDoc::Encoding.change_encoding content, enc if enc\n\n    begin\n      encoding ||= Encoding.default_external\n      orig_encoding = content.encoding\n\n      if not orig_encoding.ascii_compatible? then\n        content = content.encode encoding\n      elsif utf8 then\n        content = RDoc::Encoding.change_encoding content, Encoding::UTF_8\n        content = content.encode encoding\n      else\n        # assume the content is in our output encoding\n        content = RDoc::Encoding.change_encoding content, encoding\n      end",
        "comment": " Reads the contents of +filename+ and handles any encoding directives in the file.  The content will be converted to the +encoding+.  If the file cannot be converted a warning will be printed and nil will be returned.  If +force_transcode+ is true the document will be transcoded and any unknown character in the target encoding will be replaced with '?'",
        "label": "How-it-is-done",
        "id": "470"
    },
    {
        "raw_code": "def self.detect_encoding(string)\n    result = HEADER_REGEXP.match string\n    name = result && result[:name]\n\n    name ? Encoding.find(name) : nil\n  end",
        "comment": " Detects the encoding of +string+ based on the magic comment",
        "label": "What",
        "id": "471"
    },
    {
        "raw_code": "def self.remove_magic_comment(string)\n    string.sub HEADER_REGEXP do |s|\n      s.gsub(/[^\\n]/, '')\n    end",
        "comment": " Removes magic comments and shebang",
        "label": "How-it-is-done",
        "id": "472"
    },
    {
        "raw_code": "def self.change_encoding(text, encoding)\n    if text.kind_of? RDoc::Comment\n      text.encode! encoding\n    else\n      String.new text, encoding: encoding\n    end",
        "comment": " Changes encoding based on +encoding+ without converting and returns new string",
        "label": "Property",
        "id": "473"
    },
    {
        "raw_code": "def self.to_html(token_stream)\n    starting_title = false\n\n    token_stream.map do |t|\n      next unless t\n\n      style = case t[:kind]\n              when :on_const   then 'ruby-constant'\n              when :on_kw      then 'ruby-keyword'\n              when :on_ivar    then 'ruby-ivar'\n              when :on_cvar    then 'ruby-identifier'\n              when :on_gvar    then 'ruby-identifier'\n              when '=' != t[:text] && :on_op\n                               then 'ruby-operator'\n              when :on_tlambda then 'ruby-operator'\n              when :on_ident   then 'ruby-identifier'\n              when :on_label   then 'ruby-value'\n              when :on_backref, :on_dstring\n                               then 'ruby-node'\n              when :on_comment then 'ruby-comment'\n              when :on_embdoc  then 'ruby-comment'\n              when :on_regexp  then 'ruby-regexp'\n              when :on_tstring then 'ruby-string'\n              when :on_int, :on_float,\n                   :on_rational, :on_imaginary,\n                   :on_heredoc,\n                   :on_symbol, :on_CHAR then 'ruby-value'\n              when :on_heredoc_beg, :on_heredoc_end\n                               then 'ruby-identifier'\n              end",
        "comment": " Converts +token_stream+ to HTML wrapping various tokens with <tt><span></tt> elements. Some tokens types are wrapped in spans with the given class names. Other token types are not wrapped in spans.",
        "label": "How-to-use",
        "id": "474"
    },
    {
        "raw_code": "def add_tokens(tokens)\n    @token_stream.concat(tokens)\n  end",
        "comment": " Adds +tokens+ to the collected tokens",
        "label": "What",
        "id": "475"
    },
    {
        "raw_code": "def add_token(token)\n    @token_stream.push(token)\n  end",
        "comment": " Adds one +token+ to the collected tokens",
        "label": "What",
        "id": "476"
    },
    {
        "raw_code": "def collect_tokens\n    @token_stream = []\n  end",
        "comment": " Starts collecting tokens",
        "label": "What",
        "id": "477"
    },
    {
        "raw_code": "def pop_token\n    @token_stream.pop\n  end",
        "comment": " Remove the last token from the collected tokens",
        "label": "What",
        "id": "478"
    },
    {
        "raw_code": "def token_stream\n    @token_stream\n  end",
        "comment": " Current token stream",
        "label": "What",
        "id": "479"
    },
    {
        "raw_code": "def tokens_to_s\n    (token_stream or return '').compact.map { |token| token[:text] }.join ''\n  end",
        "comment": " Returns a string representation of the token stream",
        "label": "Property",
        "id": "480"
    },
    {
        "raw_code": "def initialize(store, num_files, verbosity = 1)\n    @num_files = num_files\n    @store     = store\n\n    @coverage_level   = 0\n    @doc_items        = nil\n    @files_so_far     = 0\n    @fully_documented = false\n    @num_params       = 0\n    @percent_doc      = nil\n    @start            = Time.now\n    @undoc_params     = 0\n\n    @display = case verbosity\n               when 0 then Quiet.new   num_files\n               when 1 then Normal.new  num_files\n               else        Verbose.new num_files\n               end",
        "comment": " Creates a new Stats that will have +num_files+.  +verbosity+ defaults to 1 which will create an RDoc::Stats::Normal outputter.",
        "label": "How-it-is-done",
        "id": "481"
    },
    {
        "raw_code": "def add_alias(as)\n    @display.print_alias as\n  end",
        "comment": " Records the parsing of an alias +as+.",
        "label": "How-to-use",
        "id": "482"
    },
    {
        "raw_code": "def add_attribute(attribute)\n    @display.print_attribute attribute\n  end",
        "comment": " Records the parsing of an attribute +attribute+",
        "label": "What",
        "id": "483"
    },
    {
        "raw_code": "def add_class(klass)\n    @display.print_class klass\n  end",
        "comment": " Records the parsing of a class +klass+",
        "label": "How-to-use",
        "id": "484"
    },
    {
        "raw_code": "def add_constant(constant)\n    @display.print_constant constant\n  end",
        "comment": " Records the parsing of +constant+",
        "label": "How-to-use",
        "id": "485"
    },
    {
        "raw_code": "def add_file(file)\n    @files_so_far += 1\n    @display.print_file @files_so_far, file\n  end",
        "comment": " Records the parsing of +file+",
        "label": "How-to-use",
        "id": "486"
    },
    {
        "raw_code": "def add_method(method)\n    @display.print_method method\n  end",
        "comment": " Records the parsing of +method+",
        "label": "How-to-use",
        "id": "487"
    },
    {
        "raw_code": "def add_module(mod)\n    @display.print_module mod\n  end",
        "comment": " Records the parsing of a module +mod+",
        "label": "What",
        "id": "488"
    },
    {
        "raw_code": "def begin_adding\n    @display.begin_adding\n  end",
        "comment": " Call this to mark the beginning of parsing for display purposes",
        "label": "Why",
        "id": "489"
    },
    {
        "raw_code": "def calculate\n    return if @doc_items\n\n    ucm = @store.unique_classes_and_modules\n\n    classes = @store.unique_classes.reject { |cm| cm.full_name == 'Object' }\n\n    constants = []\n    ucm.each { |cm| constants.concat cm.constants }\n\n    methods = []\n    ucm.each { |cm| methods.concat cm.method_list }\n\n    attributes = []\n    ucm.each { |cm| attributes.concat cm.attributes }\n\n    @num_attributes, @undoc_attributes = doc_stats attributes\n    @num_classes,    @undoc_classes    = doc_stats classes\n    @num_constants,  @undoc_constants  = doc_stats constants\n    @num_methods,    @undoc_methods    = doc_stats methods\n    @num_modules,    @undoc_modules    = doc_stats @store.unique_modules\n\n    @num_items =\n      @num_attributes +\n      @num_classes +\n      @num_constants +\n      @num_methods +\n      @num_modules +\n      @num_params\n\n    @undoc_items =\n      @undoc_attributes +\n      @undoc_classes +\n      @undoc_constants +\n      @undoc_methods +\n      @undoc_modules +\n      @undoc_params\n\n    @doc_items = @num_items - @undoc_items\n  end",
        "comment": " Calculates documentation totals and percentages for classes, modules, constants, attributes and methods.",
        "label": "What",
        "id": "490"
    },
    {
        "raw_code": "def coverage_level=(level)\n    level = -1 unless level\n\n    @coverage_level = level\n  end",
        "comment": " Sets coverage report level.  Accepted values are:  false or nil:: No report 0:: Classes, modules, constants, attributes, methods 1:: Level 0 + method parameters",
        "label": "What",
        "id": "491"
    },
    {
        "raw_code": "def doc_stats(collection)\n    visible = collection.select { |item| item.display? }\n    [visible.length, visible.count { |item| not item.documented? }]\n  end",
        "comment": " Returns the length and number of undocumented items in +collection+.",
        "label": "Property",
        "id": "492"
    },
    {
        "raw_code": "def done_adding\n    @display.done_adding\n  end",
        "comment": " Call this to mark the end of parsing for display purposes",
        "label": "Why",
        "id": "493"
    },
    {
        "raw_code": "def fully_documented?\n    @fully_documented\n  end",
        "comment": " The documentation status of this project.  +true+ when 100%, +false+ when less than 100% and +nil+ when unknown.  Set by calling #calculate",
        "label": "How-to-use",
        "id": "494"
    },
    {
        "raw_code": "def great_job\n    report = RDoc::Markup::Document.new\n\n    report << RDoc::Markup::Paragraph.new('100% documentation!')\n    report << RDoc::Markup::Paragraph.new('Great Job!')\n\n    report\n  end",
        "comment": " A report that says you did a great job!",
        "label": "What",
        "id": "495"
    },
    {
        "raw_code": "def percent_doc\n    return @percent_doc if @percent_doc\n\n    @fully_documented = (@num_items - @doc_items) == 0\n\n    @percent_doc = @doc_items.to_f / @num_items * 100 if @num_items.nonzero?\n    @percent_doc ||= 0\n\n    @percent_doc\n  end",
        "comment": " Calculates the percentage of items documented.",
        "label": "What",
        "id": "496"
    },
    {
        "raw_code": "def report\n    if @coverage_level > 0 then\n      extend RDoc::Text\n    end",
        "comment": " Returns a report on which items are not documented",
        "label": "Property",
        "id": "497"
    },
    {
        "raw_code": "def report_attributes(cm)\n    return if cm.attributes.empty?\n\n    report = []\n\n    cm.attributes.each do |attr|\n      next if attr.documented?\n      line = attr.line ? \":#{attr.line}\" : nil\n      report << \"  #{attr.definition} :#{attr.name} # in file #{attr.file.full_name}#{line}\\n\"\n      report << \"\\n\"\n    end",
        "comment": " Returns a report on undocumented attributes in ClassModule +cm+",
        "label": "Property",
        "id": "498"
    },
    {
        "raw_code": "def report_class_module(cm)\n    return if cm.fully_documented? and @coverage_level.zero?\n    return unless cm.display?\n\n    report = RDoc::Markup::Document.new\n\n    if cm.in_files.empty? then\n      report << RDoc::Markup::Paragraph.new(\"#{cm.definition} is referenced but empty.\")\n      report << RDoc::Markup::Paragraph.new(\"It probably came from another project.  I'm sorry I'm holding it against you.\")\n\n      return report\n    elsif cm.documented? then\n      documented = true\n      klass = RDoc::Markup::Verbatim.new(\"#{cm.definition} # is documented\\n\")\n    else\n      report << RDoc::Markup::Paragraph.new('In files:')\n\n      list = RDoc::Markup::List.new :BULLET\n\n      cm.in_files.each do |file|\n        para = RDoc::Markup::Paragraph.new file.full_name\n        list << RDoc::Markup::ListItem.new(nil, para)\n      end",
        "comment": " Returns a report on undocumented items in ClassModule +cm+",
        "label": "Property",
        "id": "499"
    },
    {
        "raw_code": "def report_constants(cm)\n    return if cm.constants.empty?\n\n    report = []\n\n    cm.constants.each do |constant|\n      # TODO constant aliases are listed in the summary but not reported\n      # figure out what to do here\n      next if constant.documented? || constant.is_alias_for\n\n      line = constant.line ? \":#{constant.line}\" : line\n      report << \"  # in file #{constant.file.full_name}#{line}\\n\"\n      report << \"  #{constant.name} = nil\\n\"\n      report << \"\\n\"\n    end",
        "comment": " Returns a report on undocumented constants in ClassModule +cm+",
        "label": "Property",
        "id": "500"
    },
    {
        "raw_code": "def report_methods(cm)\n    return if cm.method_list.empty?\n\n    report = []\n\n    cm.each_method do |method|\n      next if method.documented? and @coverage_level.zero?\n\n      if @coverage_level > 0 then\n        params, undoc = undoc_params method\n\n        @num_params += params\n\n        unless undoc.empty? then\n          @undoc_params += undoc.length\n\n          undoc = undoc.map do |param| \"+#{param}+\" end\n          param_report = \"  # #{undoc.join ', '} is not documented\\n\"\n        end",
        "comment": " Returns a report on undocumented methods in ClassModule +cm+",
        "label": "Property",
        "id": "501"
    },
    {
        "raw_code": "def summary\n    calculate\n\n    num_width = [@num_files, @num_items].max.to_s.length\n    undoc_width = [\n      @undoc_attributes,\n      @undoc_classes,\n      @undoc_constants,\n      @undoc_items,\n      @undoc_methods,\n      @undoc_modules,\n      @undoc_params,\n    ].max.to_s.length\n\n    report = RDoc::Markup::Verbatim.new\n\n    report << \"Files:      %*d\\n\" % [num_width, @num_files]\n\n    report << \"\\n\"\n\n    report << \"Classes:    %*d (%*d undocumented)\\n\" % [\n      num_width, @num_classes, undoc_width, @undoc_classes]\n    report << \"Modules:    %*d (%*d undocumented)\\n\" % [\n      num_width, @num_modules, undoc_width, @undoc_modules]\n    report << \"Constants:  %*d (%*d undocumented)\\n\" % [\n      num_width, @num_constants, undoc_width, @undoc_constants]\n    report << \"Attributes: %*d (%*d undocumented)\\n\" % [\n      num_width, @num_attributes, undoc_width, @undoc_attributes]\n    report << \"Methods:    %*d (%*d undocumented)\\n\" % [\n      num_width, @num_methods, undoc_width, @undoc_methods]\n    report << \"Parameters: %*d (%*d undocumented)\\n\" % [\n      num_width, @num_params, undoc_width, @undoc_params] if\n        @coverage_level > 0\n\n    report << \"\\n\"\n\n    report << \"Total:      %*d (%*d undocumented)\\n\" % [\n      num_width, @num_items, undoc_width, @undoc_items]\n\n    report << \"%6.2f%% documented\\n\" % percent_doc\n    report << \"\\n\"\n    report << \"Elapsed: %0.1fs\\n\" % (Time.now - @start)\n\n    RDoc::Markup::Document.new report\n  end",
        "comment": " Returns a summary of the collected statistics.",
        "label": "Property",
        "id": "502"
    },
    {
        "raw_code": "def undoc_params(method)\n    @formatter ||= RDoc::Markup::ToTtOnly.new\n\n    params = method.param_list\n\n    params = params.map { |param| param.gsub(/^\\*\\*?/, '') }\n\n    return 0, [] if params.empty?\n\n    document = parse method.comment\n\n    tts = document.accept @formatter\n\n    undoc = params - tts\n\n    [params.length, undoc]\n  end",
        "comment": " Determines which parameters in +method+ were not documented.  Returns a total parameter count and an Array of undocumented methods.",
        "label": "What",
        "id": "503"
    },
    {
        "raw_code": "def self.add_generator(klass)\n    name = klass.name.sub(/^RDoc::Generator::/, '').downcase\n    GENERATORS[name] = klass\n  end",
        "comment": " Add +klass+ that can generate output after parsing",
        "label": "Property",
        "id": "504"
    },
    {
        "raw_code": "def self.current\n    @current\n  end",
        "comment": " Active RDoc::RDoc instance",
        "label": "Property",
        "id": "505"
    },
    {
        "raw_code": "def self.current=(rdoc)\n    @current = rdoc\n  end",
        "comment": " Sets the active RDoc::RDoc instance",
        "label": "What",
        "id": "506"
    },
    {
        "raw_code": "def initialize\n    @current       = nil\n    @generator     = nil\n    @last_modified = {}\n    @old_siginfo   = nil\n    @options       = nil\n    @stats         = nil\n    @store         = nil\n  end",
        "comment": " Creates a new RDoc::RDoc instance.  Call #document to parse files and generate documentation.",
        "label": "How-to-use",
        "id": "507"
    },
    {
        "raw_code": "def error(msg)\n    raise RDoc::Error, msg\n  end",
        "comment": " Report an error message and exit",
        "label": "Others",
        "id": "508"
    },
    {
        "raw_code": "def gather_files(files)\n    files = [@options.root.to_s] if files.empty?\n\n    file_list = normalized_file_list files, true, @options.exclude\n\n    file_list = remove_unparseable(file_list)\n\n    if file_list.count {|name, mtime|\n         file_list[name] = @last_modified[name] unless mtime\n         mtime\n       } > 0\n      @last_modified.replace file_list\n      file_list.keys.sort\n    else\n      []\n    end",
        "comment": " Gathers a set of parseable files from the files and directories listed in +files+.",
        "label": "What",
        "id": "509"
    },
    {
        "raw_code": "def handle_pipe\n    @html = RDoc::Markup::ToHtml.new @options\n\n    parser = RDoc::Text::MARKUP_FORMAT[@options.markup]\n\n    document = parser.parse $stdin.read\n\n    out = @html.convert document\n\n    $stdout.write out\n  end",
        "comment": " Turns RDoc from stdin into HTML",
        "label": "How-to-use",
        "id": "510"
    },
    {
        "raw_code": "def install_siginfo_handler\n    return unless Signal.list.include? 'INFO'\n\n    @old_siginfo = trap 'INFO' do\n      puts @current if @current\n    end",
        "comment": " Installs a siginfo handler that prints the current filename.",
        "label": "What",
        "id": "511"
    },
    {
        "raw_code": "def setup_output_dir(dir, force)\n    flag_file = output_flag_file dir\n\n    last = {}\n\n    if @options.dry_run then\n      # do nothing\n    elsif File.exist? dir then\n      error \"#{dir} exists and is not a directory\" unless File.directory? dir\n\n      begin\n        File.open flag_file do |io|\n          unless force then\n            Time.parse io.gets\n\n            io.each do |line|\n              file, time = line.split \"\\t\", 2\n              time = Time.parse(time) rescue next\n              last[file] = time\n            end",
        "comment": " Create an output dir if it doesn't exist. If it does exist, but doesn't contain the flag file <tt>created.rid</tt> then we refuse to use it, as we may clobber some manually generated documentation",
        "label": "How-it-is-done",
        "id": "512"
    },
    {
        "raw_code": "def update_output_dir(op_dir, time, last = {})\n    return if @options.dry_run or not @options.update_output_dir\n    unless ENV['SOURCE_DATE_EPOCH'].nil?\n      time = Time.at(ENV['SOURCE_DATE_EPOCH'].to_i).gmtime\n    end",
        "comment": " Update the flag file in an output directory.",
        "label": "How-to-use",
        "id": "513"
    },
    {
        "raw_code": "def output_flag_file(op_dir)\n    File.join op_dir, \"created.rid\"\n  end",
        "comment": " Return the path name of the flag file in an output directory.",
        "label": "How-to-use",
        "id": "514"
    },
    {
        "raw_code": "def parse_dot_doc_file(in_dir, filename)\n    # read and strip comments\n    patterns = File.read(filename).gsub(/#.*/, '')\n\n    result = {}\n\n    patterns.split(' ').each do |patt|\n      candidates = Dir.glob(File.join(in_dir, patt))\n      result.update normalized_file_list(candidates, false, @options.exclude)\n    end",
        "comment": " The .document file contains a list of file and directory name patterns, representing candidates for documentation. It may also contain comments (starting with '#')",
        "label": "What",
        "id": "515"
    },
    {
        "raw_code": "def normalized_file_list(relative_files, force_doc = false,\n                           exclude_pattern = nil)\n    file_list = {}\n\n    relative_files.each do |rel_file_name|\n      rel_file_name = rel_file_name.sub(/^\\.\\//, '')\n      next if rel_file_name.end_with? 'created.rid'\n      next if exclude_pattern && exclude_pattern =~ rel_file_name\n      stat = File.stat rel_file_name rescue next\n\n      case type = stat.ftype\n      when \"file\" then\n        mtime = (stat.mtime unless (last_modified = @last_modified[rel_file_name] and\n                                    stat.mtime.to_i <= last_modified.to_i))\n\n        if force_doc or RDoc::Parser.can_parse(rel_file_name) then\n          file_list[rel_file_name] = mtime\n        end",
        "comment": " Given a list of files and directories, create a list of all the Ruby files they contain.  If +force_doc+ is true we always add the given files, if false, only add files that we guarantee we can parse.  It is true when looking at files given on the command line, false when recursing through subdirectories.  The effect of this is that if you want a file with a non-standard extension parsed, you must name it explicitly.",
        "label": "Property",
        "id": "516"
    },
    {
        "raw_code": "def list_files_in_directory(dir)\n    files = Dir.glob File.join(dir, \"*\")\n\n    normalized_file_list files, false, @options.exclude\n  end",
        "comment": " Return a list of the files to be processed in a directory. We know that this directory doesn't have a .document file, so we're looking for real files. However we may well contain subdirectories which must be tested for .document files.",
        "label": "How-it-is-done",
        "id": "517"
    },
    {
        "raw_code": "def parse_file(filename)\n    encoding = @options.encoding\n    filename = filename.encode encoding\n\n    @stats.add_file filename\n\n    return if RDoc::Parser.binary? filename\n\n    content = RDoc::Encoding.read_file filename, encoding\n\n    return unless content\n\n    filename_path = Pathname(filename).expand_path\n    begin\n      relative_path = filename_path.relative_path_from @options.root\n    rescue ArgumentError\n      relative_path = filename_path\n    end",
        "comment": " Parses +filename+ and returns an RDoc::TopLevel",
        "label": "Property",
        "id": "518"
    },
    {
        "raw_code": "def parse_files(files)\n    file_list = gather_files files\n    @stats = RDoc::Stats.new @store, file_list.length, @options.verbosity\n\n    return [] if file_list.empty?\n\n    # This workaround can be removed after the :main: directive is removed\n    original_options = @options.dup\n    @stats.begin_adding\n\n    file_info = file_list.map do |filename|\n      @current = filename\n      parse_file filename\n    end.compact\n\n    @store.resolve_c_superclasses\n\n    @stats.done_adding\n    @options = original_options\n\n    file_info\n  end",
        "comment": " Parse each file on the command line, recursively entering directories.",
        "label": "How-to-use",
        "id": "519"
    },
    {
        "raw_code": "def remove_unparseable(files)\n    files.reject do |file, *|\n      file =~ /\\.(?:class|eps|erb|scpt\\.txt|svg|ttf|yml)$/i or\n        (file =~ /tags$/i and\n         /\\A(\\f\\n[^,]+,\\d+$|!_TAG_)/.match?(File.binread(file, 100)))\n    end",
        "comment": " Removes file extensions known to be unparseable from +files+ and TAGS files for emacs and vim.",
        "label": "What",
        "id": "520"
    },
    {
        "raw_code": "def document(options)\n    if RDoc::Options === options then\n      @options = options\n    else\n      @options = RDoc::Options.load_options\n      @options.parse options\n    end",
        "comment": " Generates documentation or a coverage report depending upon the settings in +options+.  +options+ can be either an RDoc::Options instance or an array of strings equivalent to the strings that would be passed on the command line like <tt>%w[-q -o doc -t My\\ Doc\\ Title]</tt>.  #document will automatically call RDoc::Options#finish if an options instance was given.  For a list of options, see either RDoc::Options or <tt>rdoc --help</tt>.  By default, output will be stored in a directory called \"doc\" below the current directory, so make sure you're somewhere writable before invoking.",
        "label": "How-to-use",
        "id": "521"
    },
    {
        "raw_code": "def generate\n    if @options.dry_run then\n      # do nothing\n      @generator.generate\n    else\n      Dir.chdir @options.op_dir do\n        unless @options.quiet then\n          $stderr.puts \"\\nGenerating #{@generator.class.name.sub(/^.*::/, '')} format into #{Dir.pwd}...\"\n          $stderr.puts \"\\nYou can visit the home page at: \\e]8;;file://#{Dir.pwd}/index.html\\e\\\\file://#{Dir.pwd}/index.html\\e]8;;\\e\\\\\"\n        end",
        "comment": " Generates documentation for +file_info+ (from #parse_files) into the output dir using the generator selected by the RDoc options",
        "label": "What",
        "id": "522"
    },
    {
        "raw_code": "def remove_siginfo_handler\n    return unless Signal.list.key? 'INFO'\n\n    handler = @old_siginfo || 'DEFAULT'\n\n    trap 'INFO', handler\n  end",
        "comment": " Removes a siginfo handler and replaces the previous",
        "label": "What",
        "id": "523"
    },
    {
        "raw_code": "def initialize(str, trim_mode: nil, eoutvar: 'io')\n    super(str, trim_mode: trim_mode, eoutvar: eoutvar)\n  end",
        "comment": " Defaults +eoutvar+ to 'io', otherwise is identical to ERB's initialize",
        "label": "How-to-use",
        "id": "524"
    },
    {
        "raw_code": "def set_eoutvar(compiler, io_variable)\n    compiler.put_cmd    = \"#{io_variable}.write\"\n    compiler.insert_cmd = \"#{io_variable}.write\"\n    compiler.pre_cmd    = []\n    compiler.post_cmd   = []\n  end",
        "comment": " Instructs +compiler+ how to write to +io_variable+",
        "label": "How-to-use",
        "id": "525"
    },
    {
        "raw_code": "def with_in_proc_block\n    @in_proc_block = true\n    yield\n    @in_proc_block = false\n  end",
        "comment": "Suppress `extend` and `include` within block because they might be a metaprogramming block example: `Module.new { include M }` `M.module_eval { include N }`",
        "label": "Why",
        "id": "526"
    },
    {
        "raw_code": "def with_container(container, singleton: false)\n    old_container = @container\n    old_visibility = @visibility\n    old_singleton = @singleton\n    old_in_proc_block = @in_proc_block\n    @visibility = :public\n    @container = container\n    @singleton = singleton\n    @in_proc_block = false\n    unless singleton\n      # Need to update module parent chain to emulate Module.nesting.\n      # This mechanism is inaccurate and needs to be fixed.\n      container.parent = old_container\n    end",
        "comment": "Dive into another container",
        "label": "Others",
        "id": "527"
    },
    {
        "raw_code": "def record_location(container) # :nodoc:\n    case container\n    when RDoc::ClassModule then\n      @top_level.add_to_classes_or_modules container\n    end",
        "comment": "Records the location of this +container+ in the file for this parser and adds it to the list of classes and modules in the file.",
        "label": "What",
        "id": "528"
    },
    {
        "raw_code": "def scan\n    @tokens = RDoc::Parser::RipperStateLex.parse(@content)\n    @lines = @content.lines\n    result = Prism.parse(@content)\n    @program_node = result.value\n    @line_nodes = {}\n    prepare_line_nodes(@program_node)\n    prepare_comments(result.comments)\n    return if @top_level.done_documenting\n\n    @first_non_meta_comment = nil\n    if (_line_no, start_line, rdoc_comment = @unprocessed_comments.first)\n      @first_non_meta_comment = rdoc_comment if start_line < @program_node.location.start_line\n    end",
        "comment": "Scans this Ruby file for Ruby constructs",
        "label": "What",
        "id": "529"
    },
    {
        "raw_code": "def prepare_line_nodes(node) # :nodoc:\n    case node\n    when Prism::CallNode, Prism::DefNode\n      @line_nodes[node.location.start_line] ||= node\n    end",
        "comment": "Assign AST node to a line. This is used to show meta-method source code in the documentation.",
        "label": "Others",
        "id": "530"
    },
    {
        "raw_code": "def prepare_comments(comments)\n    current = []\n    consecutive_comments = [current]\n    @modifier_comments = {}\n    comments.each do |comment|\n      if comment.is_a? Prism::EmbDocComment\n        consecutive_comments << [comment] << (current = [])\n      elsif comment.location.start_line_slice.match?(/\\S/)\n        @modifier_comments[comment.location.start_line] = RDoc::Comment.new(comment.slice, @top_level, :ruby)\n      elsif current.empty? || current.last.location.end_line + 1 == comment.location.start_line\n        current << comment\n      else\n        consecutive_comments << (current = [comment])\n      end",
        "comment": "Prepares comments for processing. Comments are grouped into consecutive. Consecutive comment is linked to the next non-blank line.  Example: 01| class A # modifier comment 1 02|   def foo; end # modifier comment 2 03| 04|   # consecutive comment 1 start_line: 4 05|   # consecutive comment 1 linked to line: 7 06| 07|   # consecutive comment 2 start_line: 7 08|   # consecutive comment 2 linked to line: 10 09| 10|   def bar; end # consecutive comment 2 linked to this line 11| end",
        "label": "Property",
        "id": "531"
    },
    {
        "raw_code": "def parse_comment_tomdoc(container, comment, line_no, start_line)\n    return unless signature = RDoc::TomDoc.signature(comment)\n\n    name, = signature.split %r%[ \\(]%, 2\n\n    meth = RDoc::GhostMethod.new comment.text, name\n    record_location(meth)\n    meth.line = start_line\n    meth.call_seq = signature\n    return unless meth.name\n\n    meth.start_collecting_tokens\n    node = @line_nodes[line_no]\n    tokens = node ? visible_tokens_from_location(node.location) : [file_line_comment_token(start_line)]\n    tokens.each { |token| meth.token_stream << token }\n\n    container.add_method meth\n    comment.remove_private\n    comment.normalize\n    meth.comment = comment\n    @stats.add_method meth\n  end",
        "comment": "Creates an RDoc::Method on +container+ from +comment+ if there is a Signature section in the comment",
        "label": "How-it-is-done",
        "id": "532"
    },
    {
        "raw_code": "def handle_meta_method_comment(comment, node)\n    is_call_node = node.is_a?(Prism::CallNode)\n    singleton_method = false\n    visibility = @visibility\n    attributes = rw = line_no = method_name = nil\n\n    processed_comment = comment.dup\n    @preprocess.handle(processed_comment, @container) do |directive, param, line|\n      case directive\n      when 'attr', 'attr_reader', 'attr_writer', 'attr_accessor'\n        attributes = [param] if param\n        attributes ||= call_node_name_arguments(node) if is_call_node\n        rw = directive == 'attr_writer' ? 'W' : directive == 'attr_accessor' ? 'RW' : 'R'\n        ''\n      when 'method'\n        method_name = param\n        line_no = line\n        ''\n      when 'singleton-method'\n        method_name = param\n        line_no = line\n        singleton_method = true\n        visibility = :public\n        ''\n      when 'section' then\n        @container.set_current_section(param, comment.dup)\n        return # If the comment contains :section:, it is not a meta method comment\n      end",
        "comment": "Handles meta method comments",
        "label": "How-it-is-done",
        "id": "533"
    },
    {
        "raw_code": "def process_comments_until(line_no_until)\n    while !@unprocessed_comments.empty? && @unprocessed_comments.first[0] <= line_no_until\n      line_no, start_line, rdoc_comment = @unprocessed_comments.shift\n      handle_standalone_consecutive_comment_directive(rdoc_comment, line_no, start_line)\n    end",
        "comment": "Processes consecutive comments that were not linked to any documentable code until the given line number",
        "label": "How-it-is-done",
        "id": "534"
    },
    {
        "raw_code": "def skip_comments_until(line_no_until)\n    while !@unprocessed_comments.empty? && @unprocessed_comments.first[0] <= line_no_until\n      @unprocessed_comments.shift\n    end",
        "comment": "Skips all undocumentable consecutive comments until the given line number. Undocumentable comments are comments written inside `def` or inside undocumentable class/module",
        "label": "Others",
        "id": "535"
    },
    {
        "raw_code": "def consecutive_comment(line_no)\n    if @unprocessed_comments.first&.first == line_no\n      @unprocessed_comments.shift.last\n    end",
        "comment": "Returns consecutive comment linked to the given line number",
        "label": "Property",
        "id": "536"
    },
    {
        "raw_code": "def visible_tokens_from_location(location)\n    position_comment = file_line_comment_token(location.start_line)\n    newline_token = RDoc::Parser::RipperStateLex::Token.new(0, 0, :on_nl, \"\\n\")\n    indent_token = RDoc::Parser::RipperStateLex::Token.new(location.start_line, 0, :on_sp, ' ' * location.start_character_column)\n    tokens = slice_tokens(\n      [location.start_line, location.start_character_column],\n      [location.end_line, location.end_character_column]\n    )\n    [position_comment, newline_token, indent_token, *tokens]\n  end",
        "comment": "Returns tokens from the given location",
        "label": "Property",
        "id": "537"
    },
    {
        "raw_code": "def change_method_visibility(names, visibility, singleton: @singleton)\n    new_methods = []\n    @container.methods_matching(names, singleton) do |m|\n      if m.parent != @container\n        m = m.dup\n        record_location(m)\n        new_methods << m\n      else\n        m.visibility = visibility\n      end",
        "comment": "Handles `public :foo, :bar` `private :foo, :bar` and `protected :foo, :bar`",
        "label": "How-it-is-done",
        "id": "538"
    },
    {
        "raw_code": "def change_method_to_module_function(names)\n    @container.set_visibility_for(names, :private, false)\n    new_methods = []\n    @container.methods_matching(names) do |m|\n      s_m = m.dup\n      record_location(s_m)\n      s_m.singleton = true\n      new_methods << s_m\n    end",
        "comment": "Handles `module_function :foo, :bar`",
        "label": "How-it-is-done",
        "id": "539"
    },
    {
        "raw_code": "def add_alias_method(old_name, new_name, line_no)\n    comment = consecutive_comment(line_no)\n    handle_consecutive_comment_directive(@container, comment)\n    visibility = @container.find_method(old_name, @singleton)&.visibility || :public\n    a = RDoc::Alias.new(nil, old_name, new_name, comment, singleton: @singleton)\n    handle_modifier_directive(a, line_no)\n    a.store = @store\n    a.line = line_no\n    record_location(a)\n    if should_document?(a)\n      @container.add_alias(a)\n      @container.find_method(new_name, @singleton)&.visibility = visibility\n    end",
        "comment": "Handles `alias foo bar` and `alias_method :foo, :bar`",
        "label": "How-it-is-done",
        "id": "540"
    },
    {
        "raw_code": "def add_attributes(names, rw, line_no)\n    comment = consecutive_comment(line_no)\n    handle_consecutive_comment_directive(@container, comment)\n    return unless @container.document_children\n\n    names.each do |symbol|\n      a = RDoc::Attr.new(nil, symbol.to_s, rw, comment, singleton: @singleton)\n      a.store = @store\n      a.line = line_no\n      record_location(a)\n      handle_modifier_directive(a, line_no)\n      @container.add_attribute(a) if should_document?(a)\n      a.visibility = visibility # should set after adding to container\n    end",
        "comment": "Handles `attr :a, :b`, `attr_reader :a, :b`, `attr_writer :a, :b` and `attr_accessor :a, :b`",
        "label": "How-it-is-done",
        "id": "541"
    },
    {
        "raw_code": "def add_includes(names, line_no) # :nodoc:\n    add_includes_extends(names, RDoc::Include, line_no)\n  end",
        "comment": "Handle `include Foo, Bar`",
        "label": "How-to-use",
        "id": "542"
    },
    {
        "raw_code": "def add_extends(names, line_no) # :nodoc:\n    add_includes_extends(names, RDoc::Extend, line_no)\n  end",
        "comment": "Handle `extend Foo, Bar`",
        "label": "How-to-use",
        "id": "543"
    },
    {
        "raw_code": "def add_method(name, receiver_name:, receiver_fallback_type:, visibility:, singleton:, params:, calls_super:, block_params:, tokens:, start_line:, args_end_line:, end_line:)\n    return if @in_proc_block\n\n    receiver = receiver_name ? find_or_create_module_path(receiver_name, receiver_fallback_type) : @container\n    meth = RDoc::AnyMethod.new(nil, name, singleton: singleton)\n    if (comment = consecutive_comment(start_line))\n      handle_consecutive_comment_directive(@container, comment)\n      handle_consecutive_comment_directive(meth, comment)\n\n      comment.normalize\n      meth.call_seq = comment.extract_call_seq\n      meth.comment = comment\n    end",
        "comment": "Adds a method defined by `def` syntax",
        "label": "How-to-use",
        "id": "544"
    },
    {
        "raw_code": "def find_or_create_module_path(module_name, create_mode)\n    root_name, *path, name = module_name.split('::')\n    add_module = ->(mod, name, mode) {\n      case mode\n      when :class\n        mod.add_class(RDoc::NormalClass, name, 'Object').tap { |m| m.store = @store }\n      when :module\n        mod.add_module(RDoc::NormalModule, name).tap { |m| m.store = @store }\n      end",
        "comment": "Find or create module or class from a given module name. If module or class does not exist, creates a module or a class according to `create_mode` argument.",
        "label": "How-it-is-done",
        "id": "545"
    },
    {
        "raw_code": "def resolve_constant_path(constant_path)\n    owner_name, path = constant_path.split('::', 2)\n    return constant_path if owner_name.empty? # ::Foo, ::Foo::Bar\n    mod = nil\n    @module_nesting.reverse_each do |nesting, singleton|\n      next if singleton\n      mod = nesting.find_module_named(owner_name)\n      break if mod\n    end",
        "comment": "Resolves constant path to a full path by searching module nesting",
        "label": "What",
        "id": "546"
    },
    {
        "raw_code": "def find_or_create_constant_owner_name(constant_path)\n    const_path, colon, name = constant_path.rpartition('::')\n    if colon.empty? # class Foo\n      # Within `class C` or `module C`, owner is C(== current container)\n      # Within `class <<C`, owner is C.singleton_class\n      # but RDoc don't track constants of a singleton class of module\n      [(@singleton ? nil : @container), name]\n    elsif const_path.empty? # class ::Foo\n      [@top_level, name]\n    else # `class Foo::Bar` or `class ::Foo::Bar`\n      [find_or_create_module_path(const_path, :module), name]\n    end",
        "comment": "Returns a pair of owner module and constant name from a given constant path. Creates owner module if it does not exist.",
        "label": "How-it-is-done",
        "id": "547"
    },
    {
        "raw_code": "def add_constant(constant_name, rhs_name, start_line, end_line)\n    comment = consecutive_comment(start_line)\n    handle_consecutive_comment_directive(@container, comment)\n    owner, name = find_or_create_constant_owner_name(constant_name)\n    return unless owner\n\n    constant = RDoc::Constant.new(name, rhs_name, comment)\n    constant.store = @store\n    constant.line = start_line\n    record_location(constant)\n    handle_modifier_directive(constant, start_line)\n    handle_modifier_directive(constant, end_line)\n    owner.add_constant(constant)\n    mod =\n      if rhs_name =~ /^::/\n        @store.find_class_or_module(rhs_name)\n      else\n        @container.find_module_named(rhs_name)\n      end",
        "comment": "Adds a constant",
        "label": "What",
        "id": "548"
    },
    {
        "raw_code": "def add_module_or_class(module_name, start_line, end_line, is_class: false, superclass_name: nil, superclass_expr: nil)\n    comment = consecutive_comment(start_line)\n    handle_consecutive_comment_directive(@container, comment)\n    return unless @container.document_children\n\n    owner, name = find_or_create_constant_owner_name(module_name)\n    return unless owner\n\n    if is_class\n      # RDoc::NormalClass resolves superclass name despite of the lack of module nesting information.\n      # We need to fix it when RDoc::NormalClass resolved to a wrong constant name\n      if superclass_name\n        superclass_full_path = resolve_constant_path(superclass_name)\n        superclass = @store.find_class_or_module(superclass_full_path) if superclass_full_path\n        superclass_full_path ||= superclass_name\n        superclass_full_path = superclass_full_path.sub(/^::/, '')\n      end",
        "comment": "Adds module or class",
        "label": "Others",
        "id": "549"
    },
    {
        "raw_code": "def continue_entry_body(entry_body, continuation)\n    return unless last = entry_body.last\n\n    if last =~ /\\)\\s*\\z/ and continuation =~ /\\A\\(/ then\n      last.sub!(/\\)\\s*\\z/, ',')\n      continuation = continuation.sub(/\\A\\(/, '')\n    end",
        "comment": " Attaches the +continuation+ of the previous line to the +entry_body+.  Continued function listings are joined together as a single entry. Continued descriptions are joined to make a single paragraph.",
        "label": "Others",
        "id": "550"
    },
    {
        "raw_code": "def create_document(groups)\n    doc = RDoc::Markup::Document.new\n    doc.omit_headings_below = 2\n    doc.file = @top_level\n\n    doc << RDoc::Markup::Heading.new(1, File.basename(@file_name))\n    doc << RDoc::Markup::BlankLine.new\n\n    groups.sort_by do |day,| day end.reverse_each do |day, entries|\n      doc << RDoc::Markup::Heading.new(2, day.dup)\n      doc << RDoc::Markup::BlankLine.new\n\n      doc.concat create_entries entries\n    end",
        "comment": " Creates an RDoc::Markup::Document given the +groups+ of ChangeLog entries.",
        "label": "How-it-is-done",
        "id": "551"
    },
    {
        "raw_code": "def create_entries(entries)\n    out = []\n\n    entries.each do |entry, items|\n      out << RDoc::Markup::Heading.new(3, entry)\n      out << RDoc::Markup::BlankLine.new\n\n      out << create_items(items)\n    end",
        "comment": " Returns a list of ChangeLog entries an RDoc::Markup nodes for the given +entries+.",
        "label": "Property",
        "id": "552"
    },
    {
        "raw_code": "def create_items(items)\n    list = RDoc::Markup::List.new :NOTE\n\n    items.each do |item|\n      item =~ /\\A(.*?(?:\\([^)]+\\))?):\\s*/\n\n      title = $1\n      body = $'\n\n      paragraph = RDoc::Markup::Paragraph.new body\n      list_item = RDoc::Markup::ListItem.new title, paragraph\n      list << list_item\n    end",
        "comment": " Returns an RDoc::Markup::List containing the given +items+ in the ChangeLog",
        "label": "Property",
        "id": "553"
    },
    {
        "raw_code": "def group_entries(entries)\n    @time_cache ||= {}\n    entries.group_by do |title, _|\n      begin\n        time = @time_cache[title]\n        (time || parse_date(title)).strftime '%Y-%m-%d'\n      rescue NoMethodError, ArgumentError\n        time, = title.split '  ', 2\n        parse_date(time).strftime '%Y-%m-%d'\n      end",
        "comment": " Groups +entries+ by date.",
        "label": "Others",
        "id": "554"
    },
    {
        "raw_code": "def parse_date(date)\n    case date\n    when /\\A\\s*(\\d+)-(\\d+)-(\\d+)(?:[ T](\\d+):(\\d+):(\\d+) *([-+]\\d\\d):?(\\d\\d))?\\b/\n      Time.new($1, $2, $3, $4, $5, $6, (\"#{$7}:#{$8}\" if $7))\n    when /\\A\\s*\\w{3}, +(\\d+) (\\w{3}) (\\d+) (\\d+):(\\d+):(\\d+) *(?:([-+]\\d\\d):?(\\d\\d))\\b/\n      Time.new($3, $2, $1, $4, $5, $6, (\"#{$7}:#{$8}\" if $7))\n    when /\\A\\s*\\w{3} (\\w{3}) +(\\d+) (\\d+) (\\d+):(\\d+):(\\d+) *(?:([-+]\\d\\d):?(\\d\\d))\\b/\n      Time.new($3, $1, $2, $4, $5, $6, (\"#{$7}:#{$8}\" if $7))\n    when /\\A\\s*\\w{3} (\\w{3}) +(\\d+) (\\d+):(\\d+):(\\d+) (\\d+)\\b/\n      Time.new($6, $1, $2, $3, $4, $5)\n    else\n      raise ArgumentError, \"bad date: #{date}\"\n    end",
        "comment": " Parse date in ISO-8601, RFC-2822, or default of Git",
        "label": "How-to-use",
        "id": "555"
    },
    {
        "raw_code": "def parse_entries\n    @time_cache ||= {}\n\n    if /\\A((?:.*\\n){,3})commit\\s/ =~ @content\n      class << self; prepend Git; end\n      parse_info($1)\n      return parse_entries\n    end",
        "comment": " Parses the entries in the ChangeLog.  Returns an Array of each ChangeLog entry in order of parsing.  A ChangeLog entry is an Array containing the ChangeLog title (date and committer) and an Array of ChangeLog items (file and function changed with description).  An example result would be:  [ 'Tue Dec  4 08:33:46 2012  Eric Hodel  <drbrain@segment7.net>', [ 'README.EXT:  Converted to RDoc format', 'README.EXT.ja:  ditto']]",
        "label": "Property",
        "id": "556"
    },
    {
        "raw_code": "def scan\n    @time_cache = {}\n\n    entries = parse_entries\n    grouped_entries = group_entries entries\n\n    doc = create_document grouped_entries\n    comment = RDoc::Comment.new(@content)\n    comment.document = doc\n    @top_level.comment = comment\n\n    @top_level\n  end",
        "comment": " Converts the ChangeLog into an RDoc::Markup::Document",
        "label": "What",
        "id": "557"
    },
    {
        "raw_code": "def parse_info(info)\n      /^\\s*base-url\\s*=\\s*(.*\\S)/ =~ info\n      @base_url = $1\n    end",
        "comment": " Parses auxiliary info.  Currently `base-url` to expand references is effective.",
        "label": "Others",
        "id": "558"
    },
    {
        "raw_code": "def parse_entries\n      entries = []\n\n      @content.scan(/^commit\\s+(\\h{20})\\h*\\n((?:.+\\n)*)\\n((?: {4}.*\\n+)*)/) do\n        entry_name, header, entry_body = $1, $2, $3.gsub(/^ {4}/, '')\n        # header = header.scan(/^ *(\\S+?): +(.*)/).to_h\n        # date = header[\"CommitDate\"] || header[\"Date\"]\n        date = header[/^ *(?:Author)?Date: +(.*)/, 1]\n        author = header[/^ *Author: +(.*)/, 1]\n        begin\n          time = parse_date(header[/^ *CommitDate: +(.*)/, 1] || date)\n          @time_cache[entry_name] = time\n          author.sub!(/\\s*<(.*)>/, '')\n          email = $1\n          entries << [entry_name, [author, email, date, entry_body]]\n        rescue ArgumentError\n        end",
        "comment": " Parses the entries in the Git commit logs",
        "label": "What",
        "id": "559"
    },
    {
        "raw_code": "def create_entries(entries)\n      # git log entries have no strictly itemized style like the old\n      # style, just assume Markdown.\n      entries.map do |commit, entry|\n        LogEntry.new(@base_url, commit, *entry)\n      end",
        "comment": " Returns a list of ChangeLog entries as RDoc::Parser::ChangeLog::Git::LogEntry list for the given +entries+.",
        "label": "Property",
        "id": "560"
    },
    {
        "raw_code": "def initialize(top_level, content, options, stats)\n    super\n\n    content = handle_tab_width(content)\n\n    @size = 0\n    @token_listeners = nil\n    content = RDoc::Encoding.remove_magic_comment content\n    @scanner = RDoc::Parser::RipperStateLex.parse(content)\n    @content = content\n    @scanner_point = 0\n    @prev_seek = nil\n    @markup = @options.markup\n    @track_visibility = :nodoc != @options.visibility\n    @encoding = @options.encoding\n\n    reset\n  end",
        "comment": " Creates a new Ruby parser.",
        "label": "How-it-is-done",
        "id": "561"
    },
    {
        "raw_code": "def tk_nl?(tk)\n    :on_nl == tk[:kind] or :on_ignored_nl == tk[:kind]\n  end",
        "comment": " Return +true+ if +tk+ is a newline.",
        "label": "What",
        "id": "562"
    },
    {
        "raw_code": "def get_tkread_clean(pattern, replacement) # :nodoc:\n    read = get_tkread.gsub(pattern, replacement).strip\n    return '' if read == ';'\n    read\n  end",
        "comment": " Retrieves the read token stream and replaces +pattern+ with +replacement+ using gsub.  If the result is only a \";\" returns an empty string.",
        "label": "What",
        "id": "563"
    },
    {
        "raw_code": "def get_visibility_information(tk, single) # :nodoc:\n    vis_type  = tk[:text]\n    singleton = single == SINGLE\n\n    vis =\n      case vis_type\n      when 'private'   then :private\n      when 'protected' then :protected\n      when 'public'    then :public\n      when 'private_class_method' then\n        singleton = true\n        :private\n      when 'public_class_method' then\n        singleton = true\n        :public\n      when 'module_function' then\n        singleton = true\n        :public\n      else\n        raise RDoc::Error, \"Invalid visibility: #{tk.name}\"\n      end",
        "comment": " Extracts the visibility information for the visibility token +tk+ and +single+ class type identifier.  Returns the visibility type (a string), the visibility (a symbol) and +singleton+ if the methods following should be converted to singleton methods.",
        "label": "Property",
        "id": "564"
    },
    {
        "raw_code": "def collect_first_comment\n    skip_tkspace\n    comment = ''.dup\n    comment = RDoc::Encoding.change_encoding comment, @encoding if @encoding\n    first_line = true\n    first_comment_tk_kind = nil\n    line_no = nil\n\n    tk = get_tk\n\n    while tk && (:on_comment == tk[:kind] or :on_embdoc == tk[:kind])\n      comment_body = retrieve_comment_body(tk)\n      if first_line and comment_body =~ /\\A#!/ then\n        skip_tkspace\n        tk = get_tk\n      elsif first_line and comment_body =~ /\\A#\\s*-\\*-/ then\n        first_line = false\n        skip_tkspace\n        tk = get_tk\n      else\n        break if first_comment_tk_kind and not first_comment_tk_kind === tk[:kind]\n        first_comment_tk_kind = tk[:kind]\n\n        line_no = tk[:line_no] if first_line\n        first_line = false\n        comment << comment_body\n        tk = get_tk\n\n        if :on_nl === tk then\n          skip_tkspace_without_nl\n          tk = get_tk\n        end",
        "comment": " Look for the first comment in a file that isn't a shebang line.",
        "label": "Others",
        "id": "565"
    },
    {
        "raw_code": "def consume_trailing_spaces # :nodoc:\n    skip_tkspace_without_nl\n  end",
        "comment": " Consumes trailing whitespace from the token stream",
        "label": "Property",
        "id": "566"
    },
    {
        "raw_code": "def create_attr(container, single, name, rw, comment) # :nodoc:\n    att = RDoc::Attr.new get_tkread, name, rw, comment, singleton: single == SINGLE\n    record_location att\n\n    container.add_attribute att\n    @stats.add_attribute att\n\n    att\n  end",
        "comment": " Creates a new attribute in +container+ with +name+.",
        "label": "How-it-is-done",
        "id": "567"
    },
    {
        "raw_code": "def create_module_alias(container, constant, rhs_name) # :nodoc:\n    mod = if rhs_name =~ /^::/ then\n            @store.find_class_or_module rhs_name\n          else\n            container.find_module_named rhs_name\n          end",
        "comment": " Creates a module alias in +container+ at +rhs_name+ (or at the top-level for \"::\") with the name from +constant+.",
        "label": "How-it-is-done",
        "id": "568"
    },
    {
        "raw_code": "def error(msg)\n    msg = make_message msg\n\n    abort msg\n  end",
        "comment": " Aborts with +msg+",
        "label": "Why",
        "id": "569"
    },
    {
        "raw_code": "def get_bool\n    skip_tkspace\n    tk = get_tk\n    if :on_kw == tk[:kind] && 'true' == tk[:text]\n      true\n    elsif :on_kw == tk[:kind] && ('false' == tk[:text] || 'nil' == tk[:text])\n      false\n    else\n      unget_tk tk\n      true\n    end",
        "comment": " Looks for a true or false token.",
        "label": "What",
        "id": "570"
    },
    {
        "raw_code": "def get_class_or_module(container, ignore_constants = false)\n    skip_tkspace\n    name_t = get_tk\n    given_name = ''.dup\n\n    # class ::A -> A is in the top level\n    if :on_op == name_t[:kind] and '::' == name_t[:text] then # bug\n      name_t = get_tk\n      container = @top_level\n      given_name << '::'\n    end",
        "comment": " Look for the name of a class of module (optionally with a leading :: or with :: separated named) and return the ultimate name, the associated container, and the given name (with the ::).",
        "label": "How-to-use",
        "id": "571"
    },
    {
        "raw_code": "def skip_parentheses(&block)\n    left_tk = peek_tk\n\n    if :on_lparen == left_tk[:kind]\n      get_tk\n\n      ret = skip_parentheses(&block)\n\n      right_tk = peek_tk\n      if :on_rparen == right_tk[:kind]\n        get_tk\n      end",
        "comment": " Skip opening parentheses and yield the block. Skip closing parentheses too when exists.",
        "label": "Others",
        "id": "572"
    },
    {
        "raw_code": "def get_class_specification\n    tk = peek_tk\n    if tk.nil?\n      return ''\n    elsif :on_kw == tk[:kind] && 'self' == tk[:text]\n      return 'self'\n    elsif :on_gvar == tk[:kind]\n      return ''\n    end",
        "comment": " Return a superclass, which can be either a constant of an expression",
        "label": "Others",
        "id": "573"
    },
    {
        "raw_code": "def get_constant\n    res = \"\"\n    skip_tkspace_without_nl\n    tk = get_tk\n\n    while tk && ((:on_op == tk[:kind] && '::' == tk[:text]) || :on_const == tk[:kind]) do\n      res += tk[:text]\n      tk = get_tk\n    end",
        "comment": " Parse a constant, which might be qualified by one or more class or module names",
        "label": "How-to-use",
        "id": "574"
    },
    {
        "raw_code": "def get_included_module_with_optional_parens\n    skip_tkspace_without_nl\n    get_tkread\n    tk = get_tk\n    end_token = get_end_token tk\n    return '' unless end_token\n\n    nest = 0\n    continue = false\n    only_constant = true\n\n    while tk != nil do\n      is_element_of_constant = false\n      case tk[:kind]\n      when :on_semicolon then\n        break if nest == 0\n      when :on_lbracket then\n        nest += 1\n      when :on_rbracket then\n        nest -= 1\n      when :on_lbrace then\n        nest += 1\n      when :on_rbrace then\n        nest -= 1\n        if nest <= 0\n          # we might have a.each { |i| yield i }\n          unget_tk(tk) if nest < 0\n          break\n        end",
        "comment": " Get an included module that may be surrounded by parens",
        "label": "Others",
        "id": "575"
    },
    {
        "raw_code": "def get_end_token(tk) # :nodoc:\n    case tk[:kind]\n    when :on_lparen\n      token = RDoc::Parser::RipperStateLex::Token.new\n      token[:kind] = :on_rparen\n      token[:text] = ')'\n      token\n    when :on_rparen\n      nil\n    else\n      token = RDoc::Parser::RipperStateLex::Token.new\n      token[:kind] = :on_nl\n      token[:text] = \"\\n\"\n      token\n    end",
        "comment": " Little hack going on here. In the statement:  f = 2*(1+yield)  We see the RPAREN as the next token, so we need to exit early.  This still won't catch all cases (such as \"a = yield + 1\"",
        "label": "What",
        "id": "576"
    },
    {
        "raw_code": "def get_method_container(container, name_t) # :nodoc:\n    prev_container = container\n    container = container.find_module_named(name_t[:text])\n\n    unless container then\n      constant = prev_container.constants.find do |const|\n        const.name == name_t[:text]\n      end",
        "comment": " Retrieves the method container for a singleton method.",
        "label": "What",
        "id": "577"
    },
    {
        "raw_code": "def get_symbol_or_name\n    tk = get_tk\n    case tk[:kind]\n    when :on_symbol then\n      text = tk[:text].sub(/^:/, '')\n\n      next_tk = peek_tk\n      if next_tk && :on_op == next_tk[:kind] && '=' == next_tk[:text] then\n        get_tk\n        text << '='\n      end",
        "comment": " Extracts a name or symbol from the token stream.",
        "label": "What",
        "id": "578"
    },
    {
        "raw_code": "def suppress_parents(container, ancestor) # :nodoc:\n    while container and container != ancestor do\n      container.suppress unless container.documented?\n      container = container.parent\n    end",
        "comment": " Marks containers between +container+ and +ancestor+ as ignored",
        "label": "Others",
        "id": "579"
    },
    {
        "raw_code": "def look_for_directives_in(container, comment)\n    @preprocess.handle comment, container do |directive, param|\n      case directive\n      when 'method', 'singleton-method',\n           'attr', 'attr_accessor', 'attr_reader', 'attr_writer' then\n        false # handled elsewhere\n      when 'section' then\n        break unless container.kind_of?(RDoc::Context)\n        container.set_current_section param, comment.dup\n        comment.text = ''\n        break\n      end",
        "comment": " Look for directives in a normal comment block:  # :stopdoc: # Don't display comment from this point forward  This routine modifies its +comment+ parameter.",
        "label": "How-to-use",
        "id": "580"
    },
    {
        "raw_code": "def make_message(message)\n    prefix = \"#{@file_name}:\".dup\n\n    tk = peek_tk\n    prefix << \"#{tk[:line_no]}:#{tk[:char_no]}:\" if tk\n\n    \"#{prefix} #{message}\"\n  end",
        "comment": " Adds useful info about the parser to +message+",
        "label": "How-to-use",
        "id": "581"
    },
    {
        "raw_code": "def new_comment(comment, line_no = nil)\n    c = RDoc::Comment.new comment, @top_level, :ruby\n    c.line = line_no\n    c.format = @markup\n    c\n  end",
        "comment": " Creates a comment with the correct format",
        "label": "How-it-is-done",
        "id": "582"
    },
    {
        "raw_code": "def parse_attr(context, single, tk, comment)\n    line_no = tk[:line_no]\n\n    args = parse_symbol_arg 1\n    if args.size > 0 then\n      name = args[0]\n      rw = \"R\"\n      skip_tkspace_without_nl\n      tk = get_tk\n\n      if :on_comma == tk[:kind] then\n        rw = \"RW\" if get_bool\n      else\n        unget_tk tk\n      end",
        "comment": " Creates an RDoc::Attr for the name following +tk+, setting the comment to +comment+.",
        "label": "How-it-is-done",
        "id": "583"
    },
    {
        "raw_code": "def parse_attr_accessor(context, single, tk, comment)\n    line_no = tk[:line_no]\n\n    args = parse_symbol_arg\n    rw = \"?\"\n\n    tmp = RDoc::CodeObject.new\n    read_documentation_modifiers tmp, RDoc::ATTR_MODIFIERS\n    # TODO In most other places we let the context keep track of document_self\n    # and add found items appropriately but here we do not.  I'm not sure why.\n    return if @track_visibility and not tmp.document_self\n\n    case tk[:text]\n    when \"attr_reader\"   then rw = \"R\"\n    when \"attr_writer\"   then rw = \"W\"\n    when \"attr_accessor\" then rw = \"RW\"\n    else\n      rw = '?'\n    end",
        "comment": " Creates an RDoc::Attr for each attribute listed after +tk+, setting the comment for each to +comment+.",
        "label": "How-it-is-done",
        "id": "584"
    },
    {
        "raw_code": "def parse_alias(context, single, tk, comment)\n    line_no = tk[:line_no]\n\n    skip_tkspace\n\n    if :on_lparen === peek_tk[:kind] then\n      get_tk\n      skip_tkspace\n    end",
        "comment": " Parses an +alias+ in +context+ with +comment+",
        "label": "Others",
        "id": "585"
    },
    {
        "raw_code": "def parse_call_parameters(tk)\n    end_token = case tk[:kind]\n                when :on_lparen\n                  :on_rparen\n                when :on_rparen\n                  return \"\"\n                else\n                  :on_nl\n                end",
        "comment": " Extracts call parameters from the token stream.",
        "label": "How-to-use",
        "id": "586"
    },
    {
        "raw_code": "def parse_class(container, single, tk, comment)\n    line_no = tk[:line_no]\n\n    declaration_context = container\n    container, name_t, given_name, = get_class_or_module container\n\n    if name_t[:kind] == :on_const\n      cls = parse_class_regular container, declaration_context, single,\n        name_t, given_name, comment\n    elsif name_t[:kind] == :on_op && name_t[:text] == '<<'\n      case name = skip_parentheses { get_class_specification }\n      when 'self', container.name\n        read_documentation_modifiers cls, RDoc::CLASS_MODIFIERS\n        parse_statements container, SINGLE\n        return # don't update line\n      else\n        cls = parse_class_singleton container, name, comment\n      end",
        "comment": " Parses a class in +context+ with +comment+",
        "label": "How-to-use",
        "id": "587"
    },
    {
        "raw_code": "def parse_class_regular(container, declaration_context, single, # :nodoc:\n                          name_t, given_name, comment)\n    superclass = '::Object'\n\n    if given_name =~ /^::/ then\n      declaration_context = @top_level\n      given_name = $'\n    end",
        "comment": " Parses and creates a regular class",
        "label": "How-it-is-done",
        "id": "588"
    },
    {
        "raw_code": "def parse_class_singleton(container, name, comment) # :nodoc:\n    other = @store.find_class_named name\n\n    unless other then\n      if name =~ /^::/ then\n        name = $'\n        container = @top_level\n      end",
        "comment": " Parses a singleton class in +container+ with the given +name+ and +comment+.",
        "label": "What",
        "id": "589"
    },
    {
        "raw_code": "def parse_constant(container, tk, comment, ignore_constants = false)\n    line_no = tk[:line_no]\n\n    name = tk[:text]\n    skip_tkspace_without_nl\n\n    return unless name =~ /^\\w+$/\n\n    new_modules = []\n    if :on_op == peek_tk[:kind] && '::' == peek_tk[:text] then\n      unget_tk tk\n\n      container, name_t, _, new_modules = get_class_or_module container, true\n\n      name = name_t[:text]\n    end",
        "comment": " Parses a constant in +context+ with +comment+.  If +ignore_constants+ is true, no found constants will be added to RDoc.",
        "label": "Others",
        "id": "590"
    },
    {
        "raw_code": "def parse_comment(container, tk, comment)\n    return parse_comment_tomdoc container, tk, comment if @markup == 'tomdoc'\n    column  = tk[:char_no]\n    line_no = comment.line.nil? ? tk[:line_no] : comment.line\n\n    comment.text = comment.text.sub(/(^# +:?)(singleton-)(method:)/, '\\1\\3')\n    singleton = !!$~\n\n    co =\n      if (comment.text = comment.text.sub(/^# +:?method: *(\\S*).*?\\n/i, '')) && !!$~ then\n        line_no += $`.count(\"\\n\")\n        parse_comment_ghost container, comment.text, $1, column, line_no, comment\n      elsif (comment.text = comment.text.sub(/# +:?(attr(_reader|_writer|_accessor)?): *(\\S*).*?\\n/i, '')) && !!$~ then\n        parse_comment_attr container, $1, $3, comment\n      end",
        "comment": " Generates an RDoc::Method or RDoc::Attr from +comment+ by looking for :method: or :attr: directives in +comment+.",
        "label": "What",
        "id": "591"
    },
    {
        "raw_code": "def parse_comment_attr(container, type, name, comment) # :nodoc:\n    return if name.empty?\n\n    rw = case type\n         when 'attr_reader' then 'R'\n         when 'attr_writer' then 'W'\n         else 'RW'\n         end",
        "comment": " Parse a comment that is describing an attribute in +container+ with the given +name+ and +comment+.",
        "label": "How-to-use",
        "id": "592"
    },
    {
        "raw_code": "def parse_comment_tomdoc(container, tk, comment)\n    return unless signature = RDoc::TomDoc.signature(comment)\n    column  = tk[:char_no]\n    line_no = tk[:line_no]\n\n    name, = signature.split %r%[ \\(]%, 2\n\n    meth = RDoc::GhostMethod.new get_tkread, name\n    record_location meth\n    meth.line      = line_no\n\n    meth.start_collecting_tokens\n    indent = RDoc::Parser::RipperStateLex::Token.new(1, 1, :on_sp, ' ' * column)\n    position_comment = RDoc::Parser::RipperStateLex::Token.new(line_no, 1, :on_comment)\n    position_comment[:text] = \"# File #{@top_level.relative_name}, line #{line_no}\"\n    newline = RDoc::Parser::RipperStateLex::Token.new(0, 0, :on_nl, \"\\n\")\n    meth.add_tokens [position_comment, newline, indent]\n\n    meth.call_seq = signature\n\n    comment.normalize\n\n    return unless meth.name\n\n    container.add_method meth\n\n    meth.comment = comment\n\n    @stats.add_method meth\n  end",
        "comment": " Creates an RDoc::Method on +container+ from +comment+ if there is a Signature section in the comment",
        "label": "How-it-is-done",
        "id": "593"
    },
    {
        "raw_code": "def parse_extend_or_include(klass, container, comment) # :nodoc:\n    loop do\n      skip_tkspace_comment\n\n      name = get_included_module_with_optional_parens\n\n      unless name.empty? then\n        obj = container.add klass, name, comment\n        record_location obj\n      end",
        "comment": " Parses an +include+ or +extend+, indicated by the +klass+ and adds it to +container+ # with +comment+",
        "label": "Others",
        "id": "594"
    },
    {
        "raw_code": "def parse_included_with_activesupport_concern(container, comment) # :nodoc:\n    skip_tkspace_without_nl\n    tk = get_tk\n    unless tk[:kind] == :on_lbracket || (tk[:kind] == :on_kw && tk[:text] == 'do')\n      unget_tk tk\n      return nil # should be a block\n    end",
        "comment": " Parses an +included+ with a block feature of ActiveSupport::Concern.",
        "label": "What",
        "id": "595"
    },
    {
        "raw_code": "def parse_identifier(container, single, tk, comment) # :nodoc:\n    case tk[:text]\n    when 'private', 'protected', 'public', 'private_class_method',\n         'public_class_method', 'module_function' then\n      parse_visibility container, single, tk\n      return true\n    when 'private_constant', 'public_constant'\n      parse_constant_visibility container, single, tk\n      return true\n    when 'attr' then\n      parse_attr container, single, tk, comment\n    when /^attr_(reader|writer|accessor)$/ then\n      parse_attr_accessor container, single, tk, comment\n    when 'alias_method' then\n      parse_alias container, single, tk, comment\n    when 'require', 'include' then\n      # ignore\n    else\n      if comment.text =~ /\\A#\\#$/ then\n        case comment.text\n        when /^# +:?attr(_reader|_writer|_accessor)?:/ then\n          parse_meta_attr container, single, tk, comment\n        else\n          method = parse_meta_method container, single, tk, comment\n          method.params = container.params if\n            container.params\n          method.block_params = container.block_params if\n            container.block_params\n        end",
        "comment": " Parses identifiers that can create new methods or change visibility.  Returns true if the comment was not consumed.",
        "label": "Property",
        "id": "596"
    },
    {
        "raw_code": "def parse_meta_attr(context, single, tk, comment)\n    args = parse_symbol_arg\n    rw = \"?\"\n\n    # If nodoc is given, don't document any of them\n\n    tmp = RDoc::CodeObject.new\n    read_documentation_modifiers tmp, RDoc::ATTR_MODIFIERS\n\n    regexp = /^# +:?(attr(_reader|_writer|_accessor)?): *(\\S*).*?\\n/i\n    if regexp =~ comment.text then\n      comment.text = comment.text.sub(regexp, '')\n      rw = case $1\n           when 'attr_reader' then 'R'\n           when 'attr_writer' then 'W'\n           else 'RW'\n           end",
        "comment": " Parses a meta-programmed attribute and creates an RDoc::Attr.  To create foo and bar attributes on class C with comment \"My attributes\":  class C  ## # :attr: # # My attributes  my_attr :foo, :bar  end  To create a foo attribute on class C with comment \"My attribute\":  class C  ## # :attr: foo # # My attribute  my_attr :foo, :bar  end",
        "label": "How-it-is-done",
        "id": "597"
    },
    {
        "raw_code": "def parse_meta_method(container, single, tk, comment)\n    column  = tk[:char_no]\n    line_no = tk[:line_no]\n\n    start_collecting_tokens\n    add_token tk\n    add_token_listener self\n\n    skip_tkspace_without_nl\n\n    comment.text = comment.text.sub(/(^# +:?)(singleton-)(method:)/, '\\1\\3')\n    singleton = !!$~\n\n    name = parse_meta_method_name comment, tk\n\n    return unless name\n\n    meth = RDoc::MetaMethod.new get_tkread, name, singleton: singleton\n    record_location meth\n    meth.line   = line_no\n\n    remove_token_listener self\n\n    meth.start_collecting_tokens\n    indent = RDoc::Parser::RipperStateLex::Token.new(1, 1, :on_sp, ' ' * column)\n    position_comment = RDoc::Parser::RipperStateLex::Token.new(line_no, 1, :on_comment)\n    position_comment[:text] = \"# File #{@top_level.relative_name}, line #{line_no}\"\n    newline = RDoc::Parser::RipperStateLex::Token.new(0, 0, :on_nl, \"\\n\")\n    meth.add_tokens [position_comment, newline, indent]\n    meth.add_tokens @token_stream\n\n    parse_meta_method_params container, single, meth, tk, comment\n\n    meth.comment = comment\n\n    @stats.add_method meth\n\n    meth\n  end",
        "comment": " Parses a meta-programmed method",
        "label": "Others",
        "id": "598"
    },
    {
        "raw_code": "def parse_meta_method_name(comment, tk) # :nodoc:\n    if comment.text.sub!(/^# +:?method: *(\\S*).*?\\n/i, '') then\n      return $1 unless $1.empty?\n    end",
        "comment": " Parses the name of a metaprogrammed method.  +comment+ is used to determine the name while +tk+ is used in an error message if the name cannot be determined.",
        "label": "What",
        "id": "599"
    },
    {
        "raw_code": "def parse_meta_method_params(container, single, meth, tk, comment) # :nodoc:\n    token_listener meth do\n      meth.params = ''\n\n      look_for_directives_in meth, comment\n      comment.normalize\n      meth.call_seq = comment.extract_call_seq\n\n      container.add_method meth\n\n      last_tk = tk\n\n      while tk = get_tk do\n        if :on_semicolon == tk[:kind] then\n          break\n        elsif :on_nl == tk[:kind] then\n          break unless last_tk and :on_comma == last_tk[:kind]\n        elsif :on_sp == tk[:kind] then\n          # expression continues\n        elsif :on_kw == tk[:kind] && 'do' == tk[:text] then\n          parse_statements container, single, meth\n          break\n        else\n          last_tk = tk\n        end",
        "comment": " Parses the parameters and block for a meta-programmed method.",
        "label": "What",
        "id": "600"
    },
    {
        "raw_code": "def parse_method(container, single, tk, comment)\n    singleton = nil\n    added_container = false\n    name = nil\n    column  = tk[:char_no]\n    line_no = tk[:line_no]\n\n    start_collecting_tokens\n    add_token tk\n\n    token_listener self do\n      prev_container = container\n      name, container, singleton = parse_method_name container\n      added_container = container != prev_container\n    end",
        "comment": " Parses a normal method defined by +def+",
        "label": "How-to-use",
        "id": "601"
    },
    {
        "raw_code": "def parse_method_params_and_body(container, single, meth, added_container)\n    token_listener meth do\n      parse_method_parameters meth\n\n      if meth.document_self or not @track_visibility then\n        container.add_method meth\n      elsif added_container then\n        container.document_self = false\n      end",
        "comment": " Parses the parameters and body of +meth+",
        "label": "What",
        "id": "602"
    },
    {
        "raw_code": "def parse_method_dummy(container)\n    dummy = RDoc::Context.new\n    dummy.parent = container\n    dummy.store  = container.store\n    skip_method dummy\n  end",
        "comment": " Parses a method that needs to be ignored.",
        "label": "Others",
        "id": "603"
    },
    {
        "raw_code": "def parse_method_name(container) # :nodoc:\n    skip_tkspace\n    name_t = get_tk\n    back_tk = skip_tkspace_without_nl\n    singleton = false\n\n    dot = get_tk\n    if dot[:kind] == :on_period || (dot[:kind] == :on_op && dot[:text] == '::') then\n      singleton = true\n\n      name, container = parse_method_name_singleton container, name_t\n    else\n      unget_tk dot\n      back_tk.reverse_each do |token|\n        unget_tk token\n      end",
        "comment": " Parses the name of a method in +container+.  Returns the method name, the container it is in (for def Foo.name) and if it is a singleton or regular method.",
        "label": "Property",
        "id": "604"
    },
    {
        "raw_code": "def parse_method_name_regular(container, name_t) # :nodoc:\n    if :on_op == name_t[:kind] && (%w{* & [] []= <<}.include?(name_t[:text])) then\n      name_t[:text]\n    else\n      unless [:on_kw, :on_const, :on_ident].include?(name_t[:kind]) then\n        warn \"expected method name token, . or ::, got #{name_t.inspect}\"\n        skip_method container\n        return\n      end",
        "comment": " For the given +container+ and initial name token +name_t+ the method name is parsed from the token stream for a regular method.",
        "label": "How-to-use",
        "id": "605"
    },
    {
        "raw_code": "def parse_method_name_singleton(container, name_t) # :nodoc:\n    skip_tkspace\n    name_t2 = get_tk\n\n    if (:on_kw == name_t[:kind] && 'self' == name_t[:text]) || (:on_op == name_t[:kind] && '%' == name_t[:text]) then\n      # NOTE: work around '[' being consumed early\n      if :on_lbracket == name_t2[:kind]\n        get_tk\n        name = '[]'\n      else\n        name = name_t2[:text]\n      end",
        "comment": " For the given +container+ and initial name token +name_t+ the method name and the new +container+ (if necessary) are parsed from the token stream for a singleton method.",
        "label": "How-to-use",
        "id": "606"
    },
    {
        "raw_code": "def parse_method_or_yield_parameters(method = nil,\n                                       modifiers = RDoc::METHOD_MODIFIERS)\n    skip_tkspace_without_nl\n    tk = get_tk\n    end_token = get_end_token tk\n    return '' unless end_token\n\n    nest = 0\n    continue = false\n\n    while tk != nil do\n      case tk[:kind]\n      when :on_semicolon then\n        break if nest == 0\n      when :on_lbracket then\n        nest += 1\n      when :on_rbracket then\n        nest -= 1\n      when :on_lbrace then\n        nest += 1\n      when :on_rbrace then\n        nest -= 1\n        if nest <= 0\n          # we might have a.each { |i| yield i }\n          unget_tk(tk) if nest < 0\n          break\n        end",
        "comment": " Extracts +yield+ parameters from +method+",
        "label": "How-to-use",
        "id": "607"
    },
    {
        "raw_code": "def parse_method_parameters(method)\n    res = parse_method_or_yield_parameters method\n\n    res = \"(#{res})\" unless res =~ /\\A\\(/\n    method.params = res unless method.params\n\n    return if  method.block_params\n\n    skip_tkspace_without_nl\n    read_documentation_modifiers method, RDoc::METHOD_MODIFIERS\n  end",
        "comment": " Capture the method's parameters. Along the way, look for a comment containing:  # yields: ....  and add this as the block_params for the method",
        "label": "What",
        "id": "608"
    },
    {
        "raw_code": "def parse_module(container, single, tk, comment)\n    container, name_t, = get_class_or_module container\n\n    name = name_t[:text]\n\n    mod = container.add_module RDoc::NormalModule, name\n    mod.ignore unless container.document_children\n    record_location mod\n\n    read_documentation_modifiers mod, RDoc::CLASS_MODIFIERS\n    mod.add_comment comment, @top_level\n    parse_statements mod\n\n    # after end modifiers\n    read_documentation_modifiers mod, RDoc::CLASS_MODIFIERS\n\n    @stats.add_module mod\n  end",
        "comment": " Parses an RDoc::NormalModule in +container+ with +comment+",
        "label": "What",
        "id": "609"
    },
    {
        "raw_code": "def parse_require(context, comment)\n    skip_tkspace_comment\n    tk = get_tk\n\n    if :on_lparen == tk[:kind] then\n      skip_tkspace_comment\n      tk = get_tk\n    end",
        "comment": " Parses an RDoc::Require in +context+ containing +comment+",
        "label": "Property",
        "id": "610"
    },
    {
        "raw_code": "def parse_rescue\n    skip_tkspace_without_nl\n\n    while tk = get_tk\n      case tk[:kind]\n      when :on_nl, :on_semicolon, :on_comment then\n        break\n      when :on_comma then\n        skip_tkspace_without_nl\n\n        get_tk if :on_nl == peek_tk[:kind]\n      end",
        "comment": " Parses a rescue",
        "label": "What",
        "id": "611"
    },
    {
        "raw_code": "def retrieve_comment_body(tk)\n    if :on_embdoc == tk[:kind]\n      tk[:text].gsub(/\\A=begin.*\\n/, '').gsub(/=end\\n?\\z/, '')\n    else\n      tk[:text]\n    end",
        "comment": " Retrieve comment body without =begin/=end",
        "label": "Others",
        "id": "612"
    },
    {
        "raw_code": "def parse_statements(container, single = NORMAL, current_method = nil,\n                       comment = new_comment(''))\n    raise 'no' unless RDoc::Comment === comment\n    comment = RDoc::Encoding.change_encoding comment, @encoding if @encoding\n\n    nest = 1\n    save_visibility = container.visibility\n    container.visibility = :public unless current_method\n\n    non_comment_seen = true\n\n    while tk = get_tk do\n      keep_comment = false\n      try_parse_comment = false\n\n      non_comment_seen = true unless (:on_comment == tk[:kind] or :on_embdoc == tk[:kind])\n\n      case tk[:kind]\n      when :on_nl, :on_ignored_nl, :on_comment, :on_embdoc then\n        if :on_nl == tk[:kind] or :on_ignored_nl == tk[:kind]\n          skip_tkspace\n          tk = get_tk\n        else\n          past_tokens = @read.size > 1 ? @read[0..-2] : []\n          nl_position = 0\n          past_tokens.reverse.each_with_index do |read_tk, i|\n            if read_tk =~ /^\\n$/ then\n              nl_position = (past_tokens.size - 1) - i\n              break\n            elsif read_tk =~ /^#.*\\n$/ then\n              nl_position = ((past_tokens.size - 1) - i) + 1\n              break\n            end",
        "comment": " The core of the Ruby parser.",
        "label": "What",
        "id": "613"
    },
    {
        "raw_code": "def parse_symbol_arg(no = nil)\n    skip_tkspace_comment\n\n    tk = get_tk\n    if tk[:kind] == :on_lparen\n      parse_symbol_arg_paren no\n    else\n      parse_symbol_arg_space no, tk\n    end",
        "comment": " Parse up to +no+ symbol arguments",
        "label": "How-to-use",
        "id": "614"
    },
    {
        "raw_code": "def parse_symbol_arg_paren(no) # :nodoc:\n    args = []\n\n    loop do\n      skip_tkspace_comment\n      if tk1 = parse_symbol_in_arg\n        args.push tk1\n        break if no and args.size >= no\n      end",
        "comment": " Parses up to +no+ symbol arguments surrounded by () and places them in +args+.",
        "label": "Others",
        "id": "615"
    },
    {
        "raw_code": "def parse_symbol_arg_space(no, tk) # :nodoc:\n    args = []\n\n    unget_tk tk\n    if tk = parse_symbol_in_arg\n      args.push tk\n      return args if no and args.size >= no\n    end",
        "comment": " Parses up to +no+ symbol arguments separated by spaces and places them in +args+.",
        "label": "Others",
        "id": "616"
    },
    {
        "raw_code": "def parse_symbol_in_arg\n    tk = get_tk\n    if :on_symbol == tk[:kind] then\n      tk[:text].sub(/^:/, '')\n    elsif :on_tstring == tk[:kind] then\n      tk[:text][1..-2]\n    elsif :on_dstring == tk[:kind] or :on_ident == tk[:kind] then\n      nil # ignore\n    else\n      warn(\"Expected symbol or string, got #{tk.inspect}\") if $DEBUG_RDOC\n      nil\n    end",
        "comment": " Returns symbol text from the next token",
        "label": "Property",
        "id": "617"
    },
    {
        "raw_code": "def parse_top_level_statements(container)\n    comment = collect_first_comment\n\n    look_for_directives_in container, comment\n\n    throw :eof if container.done_documenting\n\n    @markup = comment.format\n\n    # HACK move if to RDoc::Context#comment=\n    container.comment = comment if container.document_self unless comment.empty?\n\n    parse_statements container, NORMAL, nil, comment\n  end",
        "comment": " Parses statements in the top-level +container+",
        "label": "Property",
        "id": "618"
    },
    {
        "raw_code": "def parse_visibility(container, single, tk)\n    vis_type, vis, singleton = get_visibility_information tk, single\n\n    skip_tkspace_comment false\n\n    ptk = peek_tk\n    # Ryan Davis suggested the extension to ignore modifiers, because he\n    # often writes\n    #\n    #   protected unless $TESTING\n    #\n    if [:on_nl, :on_semicolon].include?(ptk[:kind]) || (:on_kw == ptk[:kind] && (['if', 'unless'].include?(ptk[:text]))) then\n      container.ongoing_visibility = vis\n    elsif :on_kw == ptk[:kind] && 'def' == ptk[:text]\n      container.current_line_visibility = vis\n    else\n      update_visibility container, vis_type, vis, singleton\n    end",
        "comment": " Determines the visibility in +container+ from +tk+",
        "label": "What",
        "id": "619"
    },
    {
        "raw_code": "def parse_constant_visibility(container, single, tk)\n    args = parse_symbol_arg\n    case tk[:text]\n    when 'private_constant'\n      vis = :private\n    when 'public_constant'\n      vis = :public\n    else\n      raise RDoc::Error, 'Unreachable'\n    end",
        "comment": " Parses a Module#private_constant or Module#public_constant call from +tk+.",
        "label": "How-to-use",
        "id": "620"
    },
    {
        "raw_code": "def parse_yield(context, single, tk, method)\n    return if method.block_params\n\n    get_tkread\n    method.block_params = parse_method_or_yield_parameters\n  end",
        "comment": " Determines the block parameter for +context+",
        "label": "What",
        "id": "621"
    },
    {
        "raw_code": "def read_directive(allowed)\n    tokens = []\n\n    while tk = get_tk do\n      tokens << tk\n\n      if :on_nl == tk[:kind] or (:on_kw == tk[:kind] && 'def' == tk[:text]) then\n        return\n      elsif :on_comment == tk[:kind] or :on_embdoc == tk[:kind] then\n        return unless tk[:text] =~ /:?\\b([\\w-]+):\\s*(.*)/\n\n        directive = $1.downcase\n\n        return [directive, $2] if allowed.include? directive\n\n        return\n      end",
        "comment": " Directives are modifier comments that can appear after class, module, or method names. For example:  def fred # :yields: a, b  or:  class MyClass # :nodoc:  We return the directive name and any parameters as a two element array if the name is in +allowed+.  A directive can be found anywhere up to the end of the current line.",
        "label": "What",
        "id": "622"
    },
    {
        "raw_code": "def read_documentation_modifiers(context, allowed)\n    skip_tkspace_without_nl\n    directive, value = read_directive allowed\n\n    return unless directive\n\n    @preprocess.handle_directive '', directive, value, context do |dir, param|\n      if %w[notnew not_new not-new].include? dir then\n        context.dont_rename_initialize = true\n\n        true\n      end",
        "comment": " Handles directives following the definition for +context+ (any RDoc::CodeObject) if the directives are +allowed+ at this point.  See also RDoc::Markup::PreProcess#handle_directive",
        "label": "How-it-is-done",
        "id": "623"
    },
    {
        "raw_code": "def record_location(container) # :nodoc:\n    case container\n    when RDoc::ClassModule then\n      @top_level.add_to_classes_or_modules container\n    end",
        "comment": " Records the location of this +container+ in the file for this parser and adds it to the list of classes and modules in the file.",
        "label": "What",
        "id": "624"
    },
    {
        "raw_code": "def scan\n    reset\n\n    catch :eof do\n      begin\n        parse_top_level_statements @top_level\n\n      rescue StandardError => e\n        if @content.include?('<%') and @content.include?('%>') then\n          # Maybe, this is ERB.\n          $stderr.puts \"\\033[2KRDoc detects ERB file. Skips it for compatibility:\"\n          $stderr.puts @file_name\n          return\n        end",
        "comment": " Scans this Ruby file for Ruby constructs",
        "label": "What",
        "id": "625"
    },
    {
        "raw_code": "def skip_optional_do_after_expression\n    skip_tkspace_without_nl\n    tk = get_tk\n\n    b_nest = 0\n    nest = 0\n\n    loop do\n      break unless tk\n      case tk[:kind]\n      when :on_semicolon, :on_nl, :on_ignored_nl then\n        break if b_nest.zero?\n      when :on_lparen then\n        nest += 1\n      when :on_rparen then\n        nest -= 1\n      when :on_kw then\n        case tk[:text]\n        when 'begin'\n          b_nest += 1\n        when 'end'\n          b_nest -= 1\n        when 'do'\n          break if nest.zero?\n        end",
        "comment": " while, until, and for have an optional do",
        "label": "How-to-use",
        "id": "626"
    },
    {
        "raw_code": "def skip_for_variable\n    skip_tkspace_without_nl\n    get_tk\n    skip_tkspace_without_nl\n    tk = get_tk\n    unget_tk(tk) unless :on_kw == tk[:kind] and 'in' == tk[:text]\n  end",
        "comment": " skip the var [in] part of a 'for' statement",
        "label": "Why",
        "id": "627"
    },
    {
        "raw_code": "def skip_method(container)\n    meth = RDoc::AnyMethod.new \"\", \"anon\"\n    parse_method_parameters meth\n    parse_statements container, false, meth\n  end",
        "comment": " Skips the next method in +container+",
        "label": "Property",
        "id": "628"
    },
    {
        "raw_code": "def skip_tkspace_comment(skip_nl = true)\n    loop do\n      skip_nl ? skip_tkspace : skip_tkspace_without_nl\n      next_tk = peek_tk\n      return if next_tk.nil? || (:on_comment != next_tk[:kind] and :on_embdoc != next_tk[:kind])\n      get_tk\n    end",
        "comment": " Skip spaces until a comment is found",
        "label": "Others",
        "id": "629"
    },
    {
        "raw_code": "def update_visibility(container, vis_type, vis, singleton) # :nodoc:\n    new_methods = []\n\n    case vis_type\n    when 'module_function' then\n      args = parse_symbol_arg\n      container.set_visibility_for args, :private, false\n\n      container.methods_matching args do |m|\n        s_m = m.dup\n        record_location s_m\n        s_m.singleton = true\n        new_methods << s_m\n      end",
        "comment": " Updates visibility in +container+ from +vis_type+ and +vis+.",
        "label": "What",
        "id": "630"
    },
    {
        "raw_code": "def warn(message)\n    @options.warn make_message message\n  end",
        "comment": " Prints +message+ to +$stderr+ unless we're being quiet",
        "label": "Others",
        "id": "631"
    },
    {
        "raw_code": "def initialize(top_level, content, options, stats)\n    super\n\n    preprocess = RDoc::Markup::PreProcess.new @file_name, @options.rdoc_include\n\n    @content = preprocess.handle @content, @top_level\n  end",
        "comment": " Prepare to parse a plain file",
        "label": "How-to-use",
        "id": "632"
    },
    {
        "raw_code": "def scan\n    comment = remove_coding_comment @content\n    comment = remove_private_comment comment\n\n    comment = RDoc::Comment.new comment, @top_level\n\n    @top_level.comment = comment\n    @top_level\n  end",
        "comment": " Extract the file contents and attach them to the TopLevel as a comment",
        "label": "How-to-use",
        "id": "633"
    },
    {
        "raw_code": "def remove_coding_comment(text)\n    text.sub(/\\A# .*coding[=:].*$/, '')\n  end",
        "comment": " Removes the encoding magic comment from +text+",
        "label": "What",
        "id": "634"
    },
    {
        "raw_code": "def remove_private_comment(comment)\n    # Workaround for gsub encoding for Ruby 1.9.2 and earlier\n    empty = ''\n    empty = RDoc::Encoding.change_encoding empty, comment.encoding\n\n    comment = comment.gsub(%r%^--\\n.*?^\\+\\+\\n?%m, empty)\n    comment.sub(%r%^--\\n.*%m, empty)\n  end",
        "comment": " Removes private comments.  Unlike RDoc::Comment#remove_private this implementation only looks for two dashes at the beginning of the line.  Three or more dashes are considered to be a rule and ignored.",
        "label": "Others",
        "id": "635"
    },
    {
        "raw_code": "def scan\n    comment = RDoc::Comment.new @content, @top_level\n    comment.format = 'markdown'\n\n    @top_level.comment = comment\n  end",
        "comment": " Creates an Markdown-format TopLevel for the given file.",
        "label": "How-it-is-done",
        "id": "636"
    },
    {
        "raw_code": "def initialize(code)\n    @buf = []\n    @heredoc_queue = []\n    @inner_lex = InnerStateLex.new(code)\n    @tokens = @inner_lex.parse([])\n  end",
        "comment": ":startdoc: New lexer for +code+.",
        "label": "How-to-use",
        "id": "637"
    },
    {
        "raw_code": "def self.parse(code)\n    lex = self.new(code)\n    tokens = []\n    begin\n      while tk = lex.get_squashed_tk\n        tokens.push tk\n      end",
        "comment": "Returns tokens parsed from +code+.",
        "label": "Property",
        "id": "638"
    },
    {
        "raw_code": "def self.end?(token)\n    (token[:state] & EXPR_END)\n  end",
        "comment": "Returns +true+ if lex state will be +END+ after +token+.",
        "label": "Property",
        "id": "639"
    },
    {
        "raw_code": "def initialize(top_level, content, options, stats)\n    super\n\n    @known_classes = RDoc::KNOWN_CLASSES.dup\n    @content = handle_tab_width handle_ifdefs_in @content\n    @file_dir = File.dirname @file_name\n\n    @classes           = load_variable_map :c_class_variables\n    @singleton_classes = load_variable_map :c_singleton_class_variables\n\n    @markup = @options.markup\n\n    # class_variable => { function => [method, ...] }\n    @methods = Hash.new { |h, f| h[f] = Hash.new { |i, m| i[m] = [] } }\n\n    # missing variable => [handle_class_module arguments]\n    @missing_dependencies = {}\n\n    # missing enclosure variable => [dependent handle_class_module arguments]\n    @enclosure_dependencies = Hash.new { |h, k| h[k] = [] }\n    @enclosure_dependencies.instance_variable_set :@missing_dependencies,\n                                                  @missing_dependencies\n\n    @enclosure_dependencies.extend TSort\n\n    def @enclosure_dependencies.tsort_each_node(&block)\n      each_key(&block)\n    rescue TSort::Cyclic => e\n      cycle_vars = e.message.scan(/\"(.*?)\"/).flatten\n\n      cycle = cycle_vars.sort.map do |var_name|\n        delete var_name\n\n        var_name, type, mod_name, = @missing_dependencies[var_name]\n\n        \"#{type} #{mod_name} (#{var_name})\"\n      end.join ', '\n\n      warn \"Unable to create #{cycle} due to a cyclic class or module creation\"\n\n      retry\n    end\n\n    def @enclosure_dependencies.tsort_each_child(node, &block)\n      fetch(node, []).each(&block)\n    end\n  end",
        "comment": " Prepares for parsing a C file.  See RDoc::Parser#initialize for details on the arguments.",
        "label": "How-to-use",
        "id": "640"
    },
    {
        "raw_code": "def do_aliases\n    @content.scan(/rb_define_alias\\s*\\(\n                   \\s*(\\w+),\n                   \\s*\"(.+?)\",\n                   \\s*\"(.+?)\"\n                   \\s*\\)/xm) do |var_name, new_name, old_name|\n      class_name = @known_classes[var_name]\n\n      unless class_name then\n        @options.warn \"Enclosing class or module %p for alias %s %s is not known\" % [\n          var_name, new_name, old_name]\n        next\n      end",
        "comment": " Scans #content for rb_define_alias",
        "label": "What",
        "id": "641"
    },
    {
        "raw_code": "def add_alias(var_name, class_obj, old_name, new_name, comment)\n    al = RDoc::Alias.new '', old_name, new_name, comment, singleton: @singleton_classes.key?(var_name)\n    al.record_location @top_level\n    class_obj.add_alias al\n    @stats.add_alias al\n    al\n  end",
        "comment": " Add alias, either from a direct alias definition, or from two method that reference the same function.",
        "label": "What",
        "id": "642"
    },
    {
        "raw_code": "def do_attrs\n    @content.scan(/rb_attr\\s*\\(\n                   \\s*(\\w+),\n                   \\s*([\\w\"()]+),\n                   #{BOOL_ARG_PATTERN},\n                   #{BOOL_ARG_PATTERN},\n                   \\s*\\w+\\);/xmo) do |var_name, attr_name, read, write|\n      handle_attr var_name, attr_name, read, write\n    end",
        "comment": " Scans #content for rb_attr and rb_define_attr",
        "label": "What",
        "id": "643"
    },
    {
        "raw_code": "def do_boot_defclass\n    @content.scan(/(\\w+)\\s*=\\s*boot_defclass\\s*\\(\\s*\"(\\w+?)\",\\s*(\\w+?)\\s*\\)/) do\n      |var_name, class_name, parent|\n      parent = nil if parent == \"0\"\n      handle_class_module(var_name, :class, class_name, parent, nil)\n    end",
        "comment": " Scans #content for boot_defclass",
        "label": "What",
        "id": "644"
    },
    {
        "raw_code": "def do_classes_and_modules\n    do_boot_defclass if @file_name == \"class.c\"\n\n    @content.scan(\n      %r(\n        (?<open>\\s*\\(\\s*) {0}\n        (?<close>\\s*\\)\\s*) {0}\n        (?<name>\\s*\"(?<class_name>\\w+)\") {0}\n        (?<parent>\\s*(?:\n          (?<parent_name>[\\w\\*\\s\\(\\)\\.\\->]+) |\n          rb_path2class\\s*\\(\\s*\"(?<path>[\\w:]+)\"\\s*\\)\n        )) {0}\n        (?<under>\\w+) {0}\n\n        (?<var_name>[\\w\\.]+)\\s* =\n        \\s*rb_(?:\n          define_(?:\n            class(?: # rb_define_class(name, parent_name)\n              \\(\\s*\n                \\g<name>,\n                \\g<parent>\n              \\s*\\)\n            |\n              _under\\g<open> # rb_define_class_under(under, name, parent_name...)\n                \\g<under>,\n                \\g<name>,\n                \\g<parent>\n              \\g<close>\n            )\n          |\n            (?<module>)\n            module(?: # rb_define_module(name)\n              \\g<open>\n                \\g<name>\n              \\g<close>\n            |\n              _under\\g<open> # rb_define_module_under(under, name)\n                \\g<under>,\n                \\g<name>\n              \\g<close>\n            )\n          )\n      |\n        (?<attributes>(?:\\s*\"\\w+\",)*\\s*NULL\\s*) {0}\n        struct_define(?:\n          \\g<open> # rb_struct_define(name, ...)\n            \\g<name>,\n        |\n          _under\\g<open> # rb_struct_define_under(under, name, ...)\n            \\g<under>,\n            \\g<name>,\n        |\n          _without_accessor(?:\n            \\g<open> # rb_struct_define_without_accessor(name, parent_name, ...)\n          |\n            _under\\g<open> # rb_struct_define_without_accessor_under(under, name, parent_name, ...)\n              \\g<under>,\n          )\n            \\g<name>,\n            \\g<parent>,\n            \\s*\\w+,        # Allocation function\n        )\n          \\g<attributes>\n        \\g<close>\n      |\n        singleton_class\\g<open> # rb_singleton_class(target_class_name)\n          (?<target_class_name>\\w+)\n        \\g<close>\n        )\n      )mx\n    ) do\n      if target_class_name = $~[:target_class_name]\n        # rb_singleton_class(target_class_name)\n        handle_singleton $~[:var_name], target_class_name\n        next\n      end",
        "comment": " Scans #content for rb_define_class, boot_defclass, rb_define_class_under and rb_singleton_class",
        "label": "What",
        "id": "645"
    },
    {
        "raw_code": "def do_constants\n    @content.scan(%r%\\Wrb_define_\n                   ( variable          |\n                     readonly_variable |\n                     const             |\n                     global_const        )\n               \\s*\\(\n                 (?:\\s*(\\w+),)?\n                 \\s*\"(\\w+)\",\n                 \\s*(.*?)\\s*\\)\\s*;\n                 %xm) do |type, var_name, const_name, definition|\n      var_name = \"rb_cObject\" if !var_name or var_name == \"rb_mKernel\"\n      type = \"const\" if type == \"global_const\"\n      handle_constants type, var_name, const_name, definition\n    end",
        "comment": " Scans #content for rb_define_variable, rb_define_readonly_variable, rb_define_const and rb_define_global_const",
        "label": "What",
        "id": "646"
    },
    {
        "raw_code": "def do_includes\n    @content.scan(/rb_include_module\\s*\\(\\s*(\\w+?),\\s*(\\w+?)\\s*\\)/) do |c, m|\n      next unless cls = @classes[c]\n      m = @known_classes[m] || m\n\n      comment = new_comment '', @top_level, :c\n      incl = cls.add_include RDoc::Include.new(m, comment)\n      incl.record_location @top_level\n    end",
        "comment": " Scans #content for rb_include_module",
        "label": "What",
        "id": "647"
    },
    {
        "raw_code": "def do_methods\n    @content.scan(%r%rb_define_\n                   (\n                      singleton_method |\n                      method           |\n                      module_function  |\n                      private_method\n                   )\n                   \\s*\\(\\s*([\\w\\.]+),\n                     \\s*\"([^\"]+)\",\n                     \\s*(?:RUBY_METHOD_FUNC\\(|VALUEFUNC\\(|\\(METHOD\\))?(\\w+)\\)?,\n                     \\s*(-?\\w+)\\s*\\)\n                   (?:;\\s*/[*/]\\s+in\\s+(\\w+?\\.(?:cpp|c|y)))?\n                 %xm) do |type, var_name, meth_name, function, param_count, source_file|\n\n      # Ignore top-object and weird struct.c dynamic stuff\n      next if var_name == \"ruby_top_self\"\n      next if var_name == \"nstr\"\n\n      var_name = \"rb_cObject\" if var_name == \"rb_mKernel\"\n      handle_method(type, var_name, meth_name, function, param_count,\n                    source_file)\n    end",
        "comment": " Scans #content for rb_define_method, rb_define_singleton_method, rb_define_module_function, rb_define_private_method, rb_define_global_function and define_filetest_function",
        "label": "Others",
        "id": "648"
    },
    {
        "raw_code": "def do_missing\n    return if @missing_dependencies.empty?\n\n    @enclosure_dependencies.tsort.each do |in_module|\n      arguments = @missing_dependencies.delete in_module\n\n      next unless arguments # dependency on existing class\n\n      handle_class_module(*arguments)\n    end",
        "comment": " Creates classes and module that were missing were defined due to the file order being different than the declaration order.",
        "label": "How-it-is-done",
        "id": "649"
    },
    {
        "raw_code": "def find_alias_comment(class_name, new_name, old_name)\n    content =~ %r%((?>/\\*.*?\\*/\\s+))\n                  rb_define_alias\\(\\s*#{Regexp.escape class_name}\\s*,\n                                   \\s*\"#{Regexp.escape new_name}\"\\s*,\n                                   \\s*\"#{Regexp.escape old_name}\"\\s*\\);%xm\n\n    new_comment($1 || '', @top_level, :c)\n  end",
        "comment": " Finds the comment for an alias on +class_name+ from +new_name+ to +old_name+",
        "label": "What",
        "id": "650"
    },
    {
        "raw_code": "def find_attr_comment(var_name, attr_name, read = nil, write = nil)\n    attr_name = Regexp.escape attr_name\n\n    rw = if read and write then\n           /\\s*#{read}\\s*,\\s*#{write}\\s*/xm\n         else\n           /.*?/m\n         end",
        "comment": " Finds a comment for rb_define_attr, rb_attr or Document-attr.  +var_name+ is the C class variable the attribute is defined on. +attr_name+ is the attribute's name.  +read+ and +write+ are the read/write flags ('1' or '0').  Either both or neither must be provided.",
        "label": "What",
        "id": "651"
    },
    {
        "raw_code": "def gen_body_table(file_content)\n    table = {}\n    file_content.scan(%r{\n      ((?>/\\*.*?\\*/\\s*)?)\n      ((?:\\w+\\s+){0,2} VALUE\\s+(\\w+)\n        \\s*(?:\\([^\\)]*\\))(?:[^\\);]|$))\n    | ((?>/\\*.*?\\*/\\s*))^\\s*(\\#\\s*define\\s+(\\w+)\\s+(\\w+))\n    | ^\\s*\\#\\s*define\\s+(\\w+)\\s+(\\w+)\n    }xm) do\n      case\n      when name = $3\n        table[name] = [:func_def, $1, $2, $~.offset(2)] if !(t = table[name]) || t[0] != :func_def\n      when name = $6\n        table[name] = [:macro_def, $4, $5, $~.offset(5), $7] if !(t = table[name]) || t[0] == :macro_alias\n      when name = $8\n        table[name] ||= [:macro_alias, $9]\n      end",
        "comment": " Generate a Ruby-method table",
        "label": "How-to-use",
        "id": "652"
    },
    {
        "raw_code": "def find_body(class_name, meth_name, meth_obj, file_content, quiet = false)\n    if file_content\n      @body_table ||= {}\n      @body_table[file_content] ||= gen_body_table file_content\n      type, *args = @body_table[file_content][meth_name]\n    end",
        "comment": " Find the C code corresponding to a Ruby method",
        "label": "What",
        "id": "653"
    },
    {
        "raw_code": "def find_class(raw_name, name, base_name = nil)\n    unless @classes[raw_name]\n      if raw_name =~ /^rb_m/\n        container = @top_level.add_module RDoc::NormalModule, name\n      else\n        container = @top_level.add_class RDoc::NormalClass, name\n      end",
        "comment": " Finds a RDoc::NormalClass or RDoc::NormalModule for +raw_name+",
        "label": "What",
        "id": "654"
    },
    {
        "raw_code": "def find_class_comment(class_name, class_mod)\n    comment = nil\n\n    if @content =~ %r%\n        ((?>/\\*.*?\\*/\\s+))\n        (static\\s+)?\n        void\\s+\n        Init(?:VM)?_(?i:#{class_name})\\s*(?:_\\(\\s*)?\\(\\s*(?:void\\s*)?\\)%xm then\n      comment = $1.sub(%r%Document-(?:class|module):\\s+#{class_name}%, '')\n    elsif @content =~ %r%Document-(?:class|module):\\s+#{class_name}\\s*?\n                         (?:<\\s+[:,\\w]+)?\\n((?>.*?\\*/))%xm then\n      comment = \"/*\\n#{$1}\"\n    elsif @content =~ %r%((?>/\\*.*?\\*/\\s+))\n                         ([\\w\\.\\s]+\\s* = \\s+)?rb_define_(class|module)[\\t (]*?\"(#{class_name})\"%xm then\n      comment = $1\n    elsif @content =~ %r%((?>/\\*.*?\\*/\\s+))\n                         ([\\w\\. \\t]+ = \\s+)?rb_define_(class|module)_under[\\t\\w, (]*?\"(#{class_name.split('::').last})\"%xm then\n      comment = $1\n    else\n      comment = ''\n    end",
        "comment": " Look for class or module documentation above Init_+class_name+(void), in a Document-class +class_name+ (or module) comment or above an rb_define_class (or module).  If a comment is supplied above a matching Init_ and a rb_define_class the Init_ comment is used.  /* * This is a comment for Foo */ Init_Foo(void) { VALUE cFoo = rb_define_class(\"Foo\", rb_cObject); }  /* * Document-class: Foo * This is a comment for Foo */ Init_foo(void) { VALUE cFoo = rb_define_class(\"Foo\", rb_cObject); }  /* * This is a comment for Foo */ VALUE cFoo = rb_define_class(\"Foo\", rb_cObject);",
        "label": "What",
        "id": "655"
    },
    {
        "raw_code": "def gen_const_table(file_content)\n    table = {}\n    @content.scan(%r{\n      (?<doc>(?>^\\s*/\\*.*?\\*/\\s+))\n        rb_define_(?<type>\\w+)\\(\\s*(?:\\w+),\\s*\n                           \"(?<name>\\w+)\"\\s*,\n                           .*?\\)\\s*;\n    | (?<doc>(?>^\\s*/\\*.*?\\*/\\s+))\n        rb_define_global_(?<type>const)\\(\\s*\n                           \"(?<name>\\w+)\"\\s*,\n                           .*?\\)\\s*;\n    |  (?<doc>(?>^\\s*/\\*.*?\\*/\\s+))\n        rb_file_(?<type>const)\\(\\s*\n                           \"(?<name>\\w+)\"\\s*,\n                           .*?\\)\\s*;\n    |  (?<doc>(?>^\\s*/\\*.*?\\*/\\s+))\n        rb_curses_define_(?<type>const)\\(\\s*\n                           (?<name>\\w+)\n                           \\s*\\)\\s*;\n    | Document-(?:const|global|variable):\\s\n        (?<name>(?:\\w+::)*\\w+)\n        \\s*?\\n(?<doc>(?>.*?\\*/))\n    }mxi) do\n      name, doc, type = $~.values_at(:name, :doc, :type)\n      if type\n        table[[type, name]] = doc\n      else\n        table[name] = \"/*\\n\" + doc\n      end",
        "comment": " Generate a const table",
        "label": "How-to-use",
        "id": "656"
    },
    {
        "raw_code": "def find_const_comment(type, const_name, class_name = nil)\n    @const_table ||= {}\n    @const_table[@content] ||= gen_const_table @content\n    table = @const_table[@content]\n\n    comment =\n      table[[type, const_name]] ||\n      (class_name && table[class_name + \"::\" + const_name]) ||\n      table[const_name] ||\n      ''\n\n    new_comment comment, @top_level, :c\n  end",
        "comment": " Finds a comment matching +type+ and +const_name+ either above the comment or in the matching Document- section.",
        "label": "What",
        "id": "657"
    },
    {
        "raw_code": "def find_modifiers(comment, meth_obj)\n    comment.normalize\n    meth_obj.call_seq = comment.extract_call_seq\n\n    look_for_directives_in meth_obj, comment\n  end",
        "comment": " Handles modifiers in +comment+ and updates +meth_obj+ as appropriate.",
        "label": "How-it-is-done",
        "id": "658"
    },
    {
        "raw_code": "def find_override_comment(class_name, meth_obj)\n    name = Regexp.escape meth_obj.name\n    prefix = Regexp.escape meth_obj.name_prefix\n\n    comment = if @content =~ %r%Document-method:\n                                \\s+#{class_name}#{prefix}#{name}\n                                \\s*?\\n((?>.*?\\*/))%xm then\n                \"/*#{$1}\"\n              elsif @content =~ %r%Document-method:\n                                   \\s#{name}\\s*?\\n((?>.*?\\*/))%xm then\n                \"/*#{$1}\"\n              end",
        "comment": " Finds a <tt>Document-method</tt> override for +meth_obj+ on +class_name+",
        "label": "What",
        "id": "659"
    },
    {
        "raw_code": "def handle_attr(var_name, attr_name, read, write)\n    rw = ''\n    rw += 'R' if TRUE_VALUES.include?(read)\n    rw += 'W' if TRUE_VALUES.include?(write)\n\n    class_name = @known_classes[var_name]\n\n    return unless class_name\n\n    class_obj = find_class var_name, class_name\n\n    return unless class_obj\n\n    comment = find_attr_comment var_name, attr_name\n    comment.normalize\n\n    name = attr_name.gsub(/rb_intern(?:_const)?\\(\"([^\"]+)\"\\)/, '\\1')\n\n    attr = RDoc::Attr.new '', name, rw, comment\n\n    attr.record_location @top_level\n    class_obj.add_attribute attr\n    @stats.add_attribute attr\n  end",
        "comment": " Creates a new RDoc::Attr +attr_name+ on class +var_name+ that is either +read+, +write+ or both",
        "label": "How-it-is-done",
        "id": "660"
    },
    {
        "raw_code": "def handle_class_module(var_name, type, class_name, parent, in_module)\n    parent_name = @known_classes[parent] || parent\n\n    if in_module then\n      enclosure = @classes[in_module] || @store.find_c_enclosure(in_module)\n\n      if enclosure.nil? and enclosure = @known_classes[in_module] then\n        enc_type = /^rb_m/ =~ in_module ? :module : :class\n        handle_class_module in_module, enc_type, enclosure, nil, nil\n        enclosure = @classes[in_module]\n      end",
        "comment": " Creates a new RDoc::NormalClass or RDoc::NormalModule based on +type+ named +class_name+ in +parent+ which was assigned to the C +var_name+.",
        "label": "How-it-is-done",
        "id": "661"
    },
    {
        "raw_code": "def handle_constants(type, var_name, const_name, definition)\n    class_name = @known_classes[var_name]\n\n    return unless class_name\n\n    class_obj = find_class var_name, class_name, class_name[/::\\K[^:]+\\z/]\n\n    unless class_obj then\n      @options.warn 'Enclosing class or module %p is not known' % [const_name]\n      return\n    end",
        "comment": " Adds constants.  By providing some_value: at the start of the comment you can override the C value of the comment to give a friendly definition.  /* 300: The perfect score in bowling */ rb_define_const(cFoo, \"PERFECT\", INT2FIX(300));  Will override <tt>INT2FIX(300)</tt> with the value +300+ in the output RDoc.  Values may include quotes and escaped colons (\\:).",
        "label": "What",
        "id": "662"
    },
    {
        "raw_code": "def handle_ifdefs_in(body)\n    body.gsub(/^#ifdef HAVE_PROTOTYPES.*?#else.*?\\n(.*?)#endif.*?\\n/m, '\\1')\n  end",
        "comment": " Removes #ifdefs that would otherwise confuse us",
        "label": "How-to-use",
        "id": "663"
    },
    {
        "raw_code": "def handle_method(type, var_name, meth_name, function, param_count,\n                    source_file = nil)\n    class_name = @known_classes[var_name]\n    singleton  = @singleton_classes.key? var_name\n\n    @methods[var_name][function] << meth_name\n\n    return unless class_name\n\n    class_obj = find_class var_name, class_name\n\n    if existing_method = class_obj.method_list.find { |m| m.c_function == function }\n      add_alias(var_name, class_obj, existing_method.name, meth_name, existing_method.comment)\n    end",
        "comment": " Adds an RDoc::AnyMethod +meth_name+ defined on a class or module assigned to +var_name+.  +type+ is the type of method definition function used. +singleton_method+ and +module_function+ create a singleton method.",
        "label": "What",
        "id": "664"
    },
    {
        "raw_code": "def handle_singleton(sclass_var, class_var)\n    class_name = @known_classes[class_var]\n\n    @known_classes[sclass_var]     = class_name\n    @singleton_classes[sclass_var] = class_name\n  end",
        "comment": " Registers a singleton class +sclass_var+ as a singleton of +class_var+",
        "label": "What",
        "id": "665"
    },
    {
        "raw_code": "def load_variable_map(map_name)\n    return {} unless files = @store.cache[map_name]\n    return {} unless name_map = files[@file_name]\n\n    class_map = {}\n\n    name_map.each do |variable, name|\n      next unless mod = @store.find_class_or_module(name)\n\n      class_map[variable] = if map_name == :c_class_variables then\n                              mod\n                            else\n                              name\n                            end",
        "comment": " Loads the variable map with the given +name+ from the RDoc::Store, if present.",
        "label": "How-to-use",
        "id": "666"
    },
    {
        "raw_code": "def look_for_directives_in(context, comment)\n    @preprocess.handle comment, context do |directive, param|\n      case directive\n      when 'main' then\n        @options.main_page = param\n\n        warn <<~MSG\n          The :main: directive is deprecated and will be removed in RDoc 7.\n\n          You can use these options to specify the initial page displayed instead:\n          - `--main=#{param}` via the command line\n          - `rdoc.main = \"#{param}\"` if you use `RDoc::Task`\n          - `main_page: #{param}` in your `.rdoc_options` file\n        MSG\n        ''\n      when 'title' then\n        @options.default_title = param if @options.respond_to? :default_title=\n\n        warn <<~MSG\n          The :title: directive is deprecated and will be removed in RDoc 7.\n\n          You can use these options to specify the title displayed instead:\n          - `--title=#{param}` via the command line\n          - `rdoc.title = \"#{param}\"` if you use `RDoc::Task`\n          - `title: #{param}` in your `.rdoc_options` file\n        MSG\n        ''\n      end",
        "comment": " Look for directives in a normal comment block:  /* * :title: My Awesome Project */  This method modifies the +comment+ Both :main: and :title: directives are deprecated and will be removed in RDoc 7.",
        "label": "How-to-use",
        "id": "667"
    },
    {
        "raw_code": "def rb_scan_args(method_body)\n    method_body =~ /rb_scan_args\\((.*?)\\)/m\n    return '(*args)' unless $1\n\n    $1.split(/,/)[2] =~ /\"(.*?)\"/ # format argument\n    format = $1.split(//)\n\n    lead = opt = trail = 0\n\n    if format.first =~ /\\d/ then\n      lead = $&.to_i\n      format.shift\n      if format.first =~ /\\d/ then\n        opt = $&.to_i\n        format.shift\n        if format.first =~ /\\d/ then\n          trail = $&.to_i\n          format.shift\n          block_arg = true\n        end",
        "comment": " Extracts parameters from the +method_body+ and returns a method parameter string.  Follows 1.9.3dev's scan-arg-spec, see README.EXT",
        "label": "Property",
        "id": "668"
    },
    {
        "raw_code": "def remove_commented_out_lines\n    @content = @content.gsub(%r%//.*rb_define_%, '//')\n  end",
        "comment": " Removes lines that are commented out that might otherwise get picked up when scanning for classes and methods",
        "label": "Others",
        "id": "669"
    },
    {
        "raw_code": "def scan\n    remove_commented_out_lines\n\n    do_classes_and_modules\n    do_missing\n\n    do_constants\n    do_methods\n    do_includes\n    do_aliases\n    do_attrs\n\n    @store.add_c_variables self\n\n    @top_level\n  end",
        "comment": " Extracts the classes, modules, methods, attributes, constants and aliases from a C file and returns an RDoc::TopLevel for this file",
        "label": "Property",
        "id": "670"
    },
    {
        "raw_code": "def new_comment(text = nil, location = nil, language = nil)\n    RDoc::Comment.new(text, location, language).tap do |comment|\n      comment.format = @markup\n    end",
        "comment": " Creates a RDoc::Comment instance.",
        "label": "How-it-is-done",
        "id": "671"
    },
    {
        "raw_code": "def add_token_listener(obj)\n    @token_listeners ||= []\n    @token_listeners << obj\n  end",
        "comment": " Adds a token listener +obj+, but you should probably use token_listener",
        "label": "What",
        "id": "672"
    },
    {
        "raw_code": "def get_tk\n    tk = nil\n\n    if @tokens.empty? then\n      if @scanner_point >= @scanner.size\n        return nil\n      else\n        tk = @scanner[@scanner_point]\n        @scanner_point += 1\n        @read.push tk[:text]\n      end",
        "comment": " Fetches the next token from the scanner",
        "label": "How-it-is-done",
        "id": "673"
    },
    {
        "raw_code": "def get_tk_until(*tokens)\n    read = []\n\n    loop do\n      tk = get_tk\n\n      case tk\n      when *tokens then\n        unget_tk tk\n        break\n      end",
        "comment": " Reads and returns all tokens up to one of +tokens+.  Leaves the matched token in the token list.",
        "label": "Property",
        "id": "674"
    },
    {
        "raw_code": "def get_tkread\n    read = @read.join(\"\")\n    @read = []\n    read\n  end",
        "comment": " Retrieves a String representation of the read tokens",
        "label": "What",
        "id": "675"
    },
    {
        "raw_code": "def peek_read\n    @read.join('')\n  end",
        "comment": " Peek equivalent for get_tkread",
        "label": "How-to-use",
        "id": "676"
    },
    {
        "raw_code": "def peek_tk\n    unget_tk(tk = get_tk)\n    tk\n  end",
        "comment": " Peek at the next token, but don't remove it from the stream",
        "label": "How-to-use",
        "id": "677"
    },
    {
        "raw_code": "def remove_token_listener(obj)\n    @token_listeners.delete(obj)\n  end",
        "comment": " Removes the token listener +obj+",
        "label": "Others",
        "id": "678"
    },
    {
        "raw_code": "def reset\n    @read       = []\n    @tokens     = []\n    @unget_read = []\n    @nest = 0\n    @scanner_point = 0\n  end",
        "comment": " Resets the tools",
        "label": "What",
        "id": "679"
    },
    {
        "raw_code": "def skip_tkspace\n    tokens = []\n\n    while (tk = get_tk) and (:on_sp == tk[:kind] or :on_nl == tk[:kind] or :on_ignored_nl == tk[:kind]) do\n      tokens.push(tk)\n    end",
        "comment": " Skips whitespace tokens including newlines",
        "label": "Others",
        "id": "680"
    },
    {
        "raw_code": "def skip_tkspace_without_nl\n    tokens = []\n\n    while (tk = get_tk) and :on_sp == tk[:kind] do\n      tokens.push(tk)\n    end",
        "comment": " Skips whitespace tokens excluding newlines",
        "label": "Others",
        "id": "681"
    },
    {
        "raw_code": "def token_listener(obj)\n    add_token_listener obj\n    yield\n  ensure\n    remove_token_listener obj\n  end",
        "comment": " Has +obj+ listen to tokens",
        "label": "Property",
        "id": "682"
    },
    {
        "raw_code": "def unget_tk(tk)\n    @tokens.unshift tk\n    @unget_read.unshift @read.pop\n\n    # Remove this token from any listeners\n    @token_listeners.each do |obj|\n      obj.pop_token\n    end if @token_listeners\n\n    nil\n  end",
        "comment": " Returns +tk+ to the scanner",
        "label": "Property",
        "id": "683"
    },
    {
        "raw_code": "def scan\n    comment = RDoc::Comment.new @content, @top_level\n    comment.format = 'rd'\n\n    @top_level.comment = comment\n  end",
        "comment": " Creates an rd-format TopLevel for the given file.",
        "label": "How-it-is-done",
        "id": "684"
    },
    {
        "raw_code": "def initialize(str, debug=false)\n      setup_parser(str, debug)\n    end",
        "comment": ":stopdoc: This is distinct from setup_parser so that a standalone parser can redefine #initialize and still have access to the proper parser setup code.",
        "label": "How-to-use",
        "id": "685"
    },
    {
        "raw_code": "def setup_parser(str, debug=false)\n      set_string str, 0\n      @memoizations = Hash.new { |h,k| h[k] = {} }\n      @result = nil\n      @failed_rule = nil\n      @failing_rule_offset = -1\n      @line_offsets = nil\n\n      setup_foreign_grammar\n    end",
        "comment": "Prepares for parsing +str+.  If you define a custom initialize you must call this method before #parse",
        "label": "How-to-use",
        "id": "686"
    },
    {
        "raw_code": "def set_string string, pos\n      @string = string\n      @string_size = string ? string.size : 0\n      @pos = pos\n      @position_line_offsets = nil\n    end",
        "comment": "Sets the string and current parsing position for the parser.",
        "label": "How-to-use",
        "id": "687"
    },
    {
        "raw_code": "def setup_foreign_grammar; end\n\n  # Alphanumeric = /\\p{Word}/\n  def _Alphanumeric\n    _tmp = scan(/\\G(?-mix:\\p{Word})/)\n    set_failed_rule :_Alphanumeric unless _tmp\n    return _tmp\n  end\n\n  # AlphanumericAscii = /[A-Za-z0-9]/\n  def _AlphanumericAscii\n    _tmp = scan(/\\G(?-mix:[A-Za-z0-9])/)\n    set_failed_rule :_AlphanumericAscii unless _tmp\n    return _tmp\n  end\n\n  # BOM = \"uFEFF\"\n  def _BOM\n    _tmp = match_string(\"uFEFF\")\n    set_failed_rule :_BOM unless _tmp\n    return _tmp\n  end\n\n  # Newline = /\\n|\\r\\n?|\\p{Zl}|\\p{Zp}/\n  def _Newline\n    _tmp = scan(/\\G(?-mix:\\n|\\r\\n?|\\p{Zl}|\\p{Zp})/)\n    set_failed_rule :_Newline unless _tmp\n    return _tmp\n  end\n\n  # NonAlphanumeric = /\\p{^Word}/\n  def _NonAlphanumeric\n    _tmp = scan(/\\G(?-mix:\\p{^Word})/)\n    set_failed_rule :_NonAlphanumeric unless _tmp\n    return _tmp\n  end\n\n  # Spacechar = /\\t|\\p{Zs}/\n  def _Spacechar\n    _tmp = scan(/\\G(?-mix:\\t|\\p{Zs})/)\n    set_failed_rule :_Spacechar unless _tmp\n    return _tmp\n  end\n\n  Rules = {}\n  Rules[:_Alphanumeric] = rule_info(\"Alphanumeric\", \"/\\\\p{Word}/\")\n  Rules[:_AlphanumericAscii] = rule_info(\"AlphanumericAscii\", \"/[A-Za-z0-9]/\")\n  Rules[:_BOM] = rule_info(\"BOM\", \"\\\"uFEFF\\\"\")\n  Rules[:_Newline] = rule_info(\"Newline\", \"/\\\\n|\\\\r\\\\n?|\\\\p{Zl}|\\\\p{Zp}/\")\n  Rules[:_NonAlphanumeric] = rule_info(\"NonAlphanumeric\", \"/\\\\p{^Word}/\")\n  Rules[:_Spacechar] = rule_info(\"Spacechar\", \"/\\\\t|\\\\p{Zs}/\")\n  # :startdoc:\nend",
        "comment": ":startdoc: :stopdoc:",
        "label": "What",
        "id": "688"
    },
    {
        "raw_code": "def print_file(files_so_far, filename)\n    progress_bar = sprintf(\"%3d%% [%2d/%2d]  \",\n                           100 * files_so_far / @num_files,\n                           files_so_far,\n                           @num_files)\n\n    if $stdout.tty?\n      # Print a progress bar, but make sure it fits on a single line. Filename\n      # will be truncated if necessary.\n      size = IO.respond_to?(:console_size) ? IO.console_size : IO.console.winsize\n      terminal_width = size[1].to_i.nonzero? || 80\n      max_filename_size = (terminal_width - progress_bar.size) - 1\n\n      if filename.size > max_filename_size then\n        # Turn \"some_long_filename.rb\" to \"...ong_filename.rb\"\n        filename = filename[(filename.size - max_filename_size) .. -1]\n        filename[0..2] = \"...\"\n      end",
        "comment": " Prints a file with a progress bar",
        "label": "What",
        "id": "689"
    },
    {
        "raw_code": "def initialize(num_files)\n    @num_files = num_files\n  end",
        "comment": " Creates a new Quiet that will print nothing",
        "label": "How-it-is-done",
        "id": "690"
    },
    {
        "raw_code": "def begin_adding(*) end\n\n  ##\n  # Prints when an alias is added\n\n  def print_alias(*) end\n\n  ##\n  # Prints when an attribute is added\n\n  def print_attribute(*) end\n\n  ##\n  # Prints when a class is added\n\n  def print_class(*) end\n\n  ##\n  # Prints when a constant is added\n\n  def print_constant(*) end\n\n  ##\n  # Prints when a file is added\n\n  def print_file(*) end\n\n  ##\n  # Prints when a method is added\n\n  def print_method(*) end\n\n  ##\n  # Prints when a module is added\n\n  def print_module(*) end\n\n  ##\n  # Prints when RDoc is done\n\n  def done_adding(*) end\n\nend",
        "comment": " Prints a message at the beginning of parsing",
        "label": "Others",
        "id": "691"
    },
    {
        "raw_code": "def nodoc(co)\n    \" (undocumented)\" unless co.documented?\n  end",
        "comment": " Returns a marker for RDoc::CodeObject +co+ being undocumented",
        "label": "Property",
        "id": "692"
    },
    {
        "raw_code": "def initialize(markup = nil)\n    super nil, markup\n\n    @markup.add_regexp_handling(/\\\\\\S/, :SUPPRESSED_CROSSREF)\n    @width = 78\n    init_tags\n\n    @headings = DEFAULT_HEADINGS.dup\n    @hard_break = \"\\n\"\n  end",
        "comment": " Creates a new formatter that will output (mostly) \\RDoc markup",
        "label": "How-it-is-done",
        "id": "693"
    },
    {
        "raw_code": "def init_tags\n    add_tag :BOLD, \"<b>\", \"</b>\"\n    add_tag :TT,   \"<tt>\", \"</tt>\"\n    add_tag :EM,   \"<em>\", \"</em>\"\n  end",
        "comment": " Maps attributes to HTML sequences",
        "label": "How-to-use",
        "id": "694"
    },
    {
        "raw_code": "def accept_blank_line(blank_line)\n    @res << \"\\n\"\n  end",
        "comment": " Adds +blank_line+ to the output",
        "label": "What",
        "id": "695"
    },
    {
        "raw_code": "def accept_block_quote(block_quote)\n    @indent += 2\n\n    block_quote.parts.each do |part|\n      @prefix = '> '\n\n      part.accept self\n    end",
        "comment": " Adds +paragraph+ to the output",
        "label": "Others",
        "id": "696"
    },
    {
        "raw_code": "def accept_heading(heading)\n    use_prefix or @res << ' ' * @indent\n    @res << @headings[heading.level][0]\n    @res << attributes(heading.text)\n    @res << @headings[heading.level][1]\n    @res << \"\\n\"\n  end",
        "comment": " Adds +heading+ to the output",
        "label": "What",
        "id": "697"
    },
    {
        "raw_code": "def accept_list_end(list)\n    @list_index.pop\n    @list_type.pop\n    @list_width.pop\n  end",
        "comment": " Finishes consumption of +list+",
        "label": "Others",
        "id": "698"
    },
    {
        "raw_code": "def accept_list_item_end(list_item)\n    width = case @list_type.last\n            when :BULLET then\n              2\n            when :NOTE, :LABEL then\n              if @prefix then\n                @res << @prefix.strip\n                @prefix = nil\n              end",
        "comment": " Finishes consumption of +list_item+",
        "label": "What",
        "id": "699"
    },
    {
        "raw_code": "def accept_list_item_start(list_item)\n    type = @list_type.last\n\n    case type\n    when :NOTE, :LABEL then\n      stripped_labels = Array(list_item.label).map do |label|\n        attributes(label).strip\n      end",
        "comment": " Prepares the visitor for consuming +list_item+",
        "label": "How-to-use",
        "id": "700"
    },
    {
        "raw_code": "def accept_list_start(list)\n    case list.type\n    when :BULLET then\n      @list_index << nil\n      @list_width << 1\n    when :LABEL, :NOTE then\n      @list_index << nil\n      @list_width << 2\n    when :LALPHA then\n      @list_index << 'a'\n      @list_width << list.items.length.to_s.length\n    when :NUMBER then\n      @list_index << 1\n      @list_width << list.items.length.to_s.length\n    when :UALPHA then\n      @list_index << 'A'\n      @list_width << list.items.length.to_s.length\n    else\n      raise RDoc::Error, \"invalid list type #{list.type}\"\n    end",
        "comment": " Prepares the visitor for consuming +list+",
        "label": "How-to-use",
        "id": "701"
    },
    {
        "raw_code": "def accept_paragraph(paragraph)\n    text = paragraph.text @hard_break\n    wrap attributes text\n  end",
        "comment": " Adds +paragraph+ to the output",
        "label": "Others",
        "id": "702"
    },
    {
        "raw_code": "def accept_indented_paragraph(paragraph)\n    @indent += paragraph.indent\n    text = paragraph.text @hard_break\n    wrap attributes text\n    @indent -= paragraph.indent\n  end",
        "comment": " Adds +paragraph+ to the output",
        "label": "Others",
        "id": "703"
    },
    {
        "raw_code": "def accept_raw(raw)\n    @res << raw.parts.join(\"\\n\")\n  end",
        "comment": " Adds +raw+ to the output",
        "label": "What",
        "id": "704"
    },
    {
        "raw_code": "def accept_rule(rule)\n    use_prefix or @res << ' ' * @indent\n    @res << '-' * (@width - @indent)\n    @res << \"\\n\"\n  end",
        "comment": " Adds +rule+ to the output",
        "label": "Others",
        "id": "705"
    },
    {
        "raw_code": "def accept_verbatim(verbatim)\n    indent = ' ' * (@indent + 2)\n\n    verbatim.parts.each do |part|\n      @res << indent unless part == \"\\n\"\n      @res << part\n    end",
        "comment": " Outputs +verbatim+ indented 2 columns",
        "label": "What",
        "id": "706"
    },
    {
        "raw_code": "def accept_table(header, body, aligns)\n    widths = header.zip(*body).map do |cols|\n      cols.map(&:size).max\n    end",
        "comment": " Adds +table+ to the output",
        "label": "Property",
        "id": "707"
    },
    {
        "raw_code": "def attributes(text)\n    flow = @am.flow text.dup\n    convert_flow flow\n  end",
        "comment": " Applies attribute-specific markup to +text+ using RDoc::AttributeManager",
        "label": "How-to-use",
        "id": "708"
    },
    {
        "raw_code": "def end_accepting\n    @res.join\n  end",
        "comment": " Returns the generated output",
        "label": "Property",
        "id": "709"
    },
    {
        "raw_code": "def handle_regexp_SUPPRESSED_CROSSREF(target)\n    text = target.text\n    text = text.sub('\\\\', '') unless in_tt?\n    text\n  end",
        "comment": " Removes preceding \\\\ from the suppressed crossref +target+",
        "label": "Others",
        "id": "710"
    },
    {
        "raw_code": "def handle_regexp_HARD_BREAK(target)\n    \"\\n\"\n  end",
        "comment": " Adds a newline to the output",
        "label": "Others",
        "id": "711"
    },
    {
        "raw_code": "def start_accepting\n    @res = [\"\"]\n    @indent = 0\n    @prefix = nil\n\n    @list_index = []\n    @list_type  = []\n    @list_width = []\n  end",
        "comment": " Prepares the visitor for text generation",
        "label": "How-to-use",
        "id": "712"
    },
    {
        "raw_code": "def use_prefix\n    prefix, @prefix = @prefix, nil\n    @res << prefix if prefix\n\n    prefix\n  end",
        "comment": " Adds the stored #prefix to the output and clears it.  Lists generate a prefix for later consumption.",
        "label": "What",
        "id": "713"
    },
    {
        "raw_code": "def wrap(text)\n    return unless text && !text.empty?\n\n    text_len = @width - @indent\n\n    text_len = 20 if text_len < 20\n\n    next_prefix = ' ' * @indent\n\n    prefix = @prefix || next_prefix\n    @prefix = nil\n\n    text.scan(/\\G(?:([^ \\n]{#{text_len}})(?=[^ \\n])|(.{1,#{text_len}})(?:[ \\n]|\\z))/) do\n      @res << prefix << ($1 || $2) << \"\\n\"\n      prefix = next_prefix\n    end",
        "comment": " Wraps +text+ to #width",
        "label": "What",
        "id": "714"
    },
    {
        "raw_code": "def initialize(markup = nil)\n    super\n\n    @in_b  = false\n    @in_em = false\n  end",
        "comment": " Returns a new ToBs that is ready for hot backspace action!",
        "label": "Property",
        "id": "715"
    },
    {
        "raw_code": "def init_tags\n    add_tag :BOLD, '+b', '-b'\n    add_tag :EM,   '+_', '-_'\n    add_tag :TT,   '', ''   # we need in_tt information maintained\n  end",
        "comment": " Sets a flag that is picked up by #annotate to do the right thing in #convert_string",
        "label": "How-to-use",
        "id": "716"
    },
    {
        "raw_code": "def accept_heading(heading)\n    use_prefix or @res << ' ' * @indent\n    @res << @headings[heading.level][0]\n    @in_b = true\n    @res << attributes(heading.text)\n    @in_b = false\n    @res << @headings[heading.level][1]\n    @res << \"\\n\"\n  end",
        "comment": " Makes heading text bold.",
        "label": "Others",
        "id": "717"
    },
    {
        "raw_code": "def accept_list_item_start(list_item)\n    type = @list_type.last\n\n    case type\n    when :NOTE, :LABEL then\n      bullets = Array(list_item.label).map do |label|\n        attributes(label).strip\n      end.join \"\\n\"\n\n      bullets << \":\\n\" unless bullets.empty?\n\n      @prefix = ' ' * @indent\n      @indent += 2\n      @prefix << bullets + (' ' * @indent)\n    else\n      bullet = type == :BULLET ? '*' :  @list_index.last.to_s + '.'\n      @prefix = (' ' * @indent) + bullet.ljust(bullet.length + 1)\n      width = bullet.length + 1\n      @indent += width\n    end",
        "comment": " Prepares the visitor for consuming +list_item+",
        "label": "How-to-use",
        "id": "718"
    },
    {
        "raw_code": "def annotate(tag)\n    case tag\n    when '+b' then @in_b = true\n    when '-b' then @in_b = false\n    when '+_' then @in_em = true\n    when '-_' then @in_em = false\n    end",
        "comment": " Turns on or off regexp handling for +convert_string+",
        "label": "What",
        "id": "719"
    },
    {
        "raw_code": "def convert_regexp_handling(target)\n    convert_string super\n  end",
        "comment": " Calls convert_string on the result of convert_regexp_handling",
        "label": "How-to-use",
        "id": "720"
    },
    {
        "raw_code": "def convert_string(string)\n    return string unless @in_b or @in_em\n    chars = if @in_b then\n              string.chars.map do |char| \"#{char}\\b#{char}\" end\n            elsif @in_em then\n              string.chars.map do |char| \"_\\b#{char}\" end\n            end",
        "comment": " Adds bold or underline mixed with backspaces",
        "label": "Others",
        "id": "721"
    },
    {
        "raw_code": "def initialize\n    @html_tags = {}\n    @matching_word_pairs = {}\n    @protectable = %w[<]\n    @regexp_handlings = []\n    @word_pair_map = {}\n    @exclusive_bitmap = 0\n    @attributes = RDoc::Markup::Attributes.new\n\n    add_word_pair \"*\", \"*\", :BOLD, true\n    add_word_pair \"_\", \"_\", :EM, true\n    add_word_pair \"+\", \"+\", :TT, true\n\n    add_html \"em\", :EM, true\n    add_html \"i\",  :EM, true\n    add_html \"b\",  :BOLD, true\n    add_html \"tt\",   :TT, true\n    add_html \"code\", :TT, true\n  end",
        "comment": " Creates a new attribute manager that understands bold, emphasized and teletype text.",
        "label": "How-it-is-done",
        "id": "722"
    },
    {
        "raw_code": "def attribute(turn_on, turn_off)\n    RDoc::Markup::AttrChanger.new turn_on, turn_off\n  end",
        "comment": " Return an attribute object with the given turn_on and turn_off bits set",
        "label": "How-to-use",
        "id": "723"
    },
    {
        "raw_code": "def change_attribute(current, new)\n    diff = current ^ new\n    attribute(new & diff, current & diff)\n  end",
        "comment": " Changes the current attribute from +current+ to +new+",
        "label": "What",
        "id": "724"
    },
    {
        "raw_code": "def changed_attribute_by_name(current_set, new_set)\n    current = new = 0\n    current_set.each do |name|\n      current |= @attributes.bitmap_for(name)\n    end",
        "comment": " Used by the tests to change attributes by name from +current_set+ to +new_set+",
        "label": "What",
        "id": "725"
    },
    {
        "raw_code": "def copy_string(start_pos, end_pos)\n    res = @str[start_pos...end_pos]\n    res.gsub!(/\\000/, '')\n    res\n  end",
        "comment": " Copies +start_pos+ to +end_pos+ from the current string",
        "label": "Property",
        "id": "726"
    },
    {
        "raw_code": "def exclusive?(attr)\n    (attr & @exclusive_bitmap) != 0\n  end",
        "comment": ":nodoc:",
        "label": "Property",
        "id": "727"
    },
    {
        "raw_code": "def convert_attrs(str, attrs, exclusive = false)\n    convert_attrs_matching_word_pairs(str, attrs, exclusive)\n    convert_attrs_word_pair_map(str, attrs, exclusive)\n  end",
        "comment": " Map attributes like <b>text</b>to the sequence \\001\\002<char>\\001\\003<char>, where <char> is a per-attribute specific character",
        "label": "Property",
        "id": "728"
    },
    {
        "raw_code": "def convert_attrs_matching_word_pairs(str, attrs, exclusive)\n    # first do matching ones\n    tags = @matching_word_pairs.select { |start, bitmap|\n      exclusive == exclusive?(bitmap)\n    }.keys\n    return if tags.empty?\n    tags = \"[#{tags.join(\"\")}](?!#{PROTECT_ATTR})\"\n    all_tags = \"[#{@matching_word_pairs.keys.join(\"\")}](?!#{PROTECT_ATTR})\"\n\n    re = /(?:^|\\W|#{all_tags})\\K(#{tags})(\\1*[#\\\\]?[\\w:#{PROTECT_ATTR}.\\/\\[\\]-]+?\\S?)\\1(?!\\1)(?=#{all_tags}|\\W|$)/\n\n    1 while str.gsub!(re) { |orig|\n      a, w = (m = $~).values_at(1, 2)\n      attr = @matching_word_pairs[a]\n      if attrs.set_attrs(m.begin(2), w.length, attr)\n        a = NULL * a.length\n      else\n        a = NON_PRINTING_START + a + NON_PRINTING_END\n      end",
        "comment": ":nodoc:",
        "label": "Property",
        "id": "729"
    },
    {
        "raw_code": "def convert_attrs_word_pair_map(str, attrs, exclusive)\n    # then non-matching\n    unless @word_pair_map.empty? then\n      @word_pair_map.each do |regexp, attr|\n        next unless exclusive == exclusive?(attr)\n        1 while str.gsub!(regexp) { |orig|\n          w = (m = ($~))[2]\n          updated = attrs.set_attrs(m.begin(2), w.length, attr)\n          if updated\n            NULL * m.match_length(1) + w + NULL * m.match_length(3)\n          else\n            orig\n          end",
        "comment": ":nodoc:",
        "label": "Property",
        "id": "730"
    },
    {
        "raw_code": "def convert_html(str, attrs, exclusive = false)\n    tags = @html_tags.select { |start, bitmap|\n      exclusive == exclusive?(bitmap)\n    }.keys.join '|'\n\n    1 while str.gsub!(/<(#{tags})>(.*?)<\\/\\1>/i) { |orig|\n      attr = @html_tags[$1.downcase]\n      html_length = $~.match_length(1) + 2 # \"<>\".length\n      seq = NULL * html_length\n      attrs.set_attrs($~.begin(2), $~.match_length(2), attr)\n      seq + $2 + seq + NULL\n    }\n  end",
        "comment": " Converts HTML tags to RDoc attributes",
        "label": "How-to-use",
        "id": "731"
    },
    {
        "raw_code": "def convert_regexp_handlings(str, attrs, exclusive = false)\n    @regexp_handlings.each do |regexp, attribute|\n      next unless exclusive == exclusive?(attribute)\n      str.scan(regexp) do\n        capture = $~.size == 1 ? 0 : 1\n\n        s, e = $~.offset capture\n\n        attrs.set_attrs s, e - s, attribute | @attributes.regexp_handling\n      end",
        "comment": " Converts regexp handling sequences to RDoc attributes",
        "label": "How-to-use",
        "id": "732"
    },
    {
        "raw_code": "def mask_protected_sequences\n    # protect __send__, __FILE__, etc.\n    @str.gsub!(/__([a-z]+)__/i,\n      \"_#{PROTECT_ATTR}_#{PROTECT_ATTR}\\\\1_#{PROTECT_ATTR}_#{PROTECT_ATTR}\")\n    @str.gsub!(/(\\A|[^\\\\])\\\\([#{Regexp.escape @protectable.join}])/m,\n               \"\\\\1\\\\2#{PROTECT_ATTR}\")\n    @str.gsub!(/\\\\(\\\\[#{Regexp.escape @protectable.join}])/m, \"\\\\1\")\n  end",
        "comment": " Escapes regexp handling sequences of text to prevent conversion to RDoc",
        "label": "Why",
        "id": "733"
    },
    {
        "raw_code": "def unmask_protected_sequences\n    @str.gsub!(/(.)#{PROTECT_ATTR}/, \"\\\\1\\000\")\n  end",
        "comment": " Unescapes regexp handling sequences of text",
        "label": "Others",
        "id": "734"
    },
    {
        "raw_code": "def add_word_pair(start, stop, name, exclusive = false)\n    raise ArgumentError, \"Word flags may not start with '<'\" if\n      start[0, 1] == '<'\n\n    bitmap = @attributes.bitmap_for name\n\n    if start == stop then\n      @matching_word_pairs[start] = bitmap\n    else\n      pattern = /(#{Regexp.escape start})(\\S+)(#{Regexp.escape stop})/\n      @word_pair_map[pattern] = bitmap\n    end",
        "comment": " Adds a markup class with +name+ for words wrapped in the +start+ and +stop+ character.  To make words wrapped with \"*\" bold:  am.add_word_pair '*', '*', :BOLD",
        "label": "Property",
        "id": "735"
    },
    {
        "raw_code": "def add_html(tag, name, exclusive = false)\n    bitmap = @attributes.bitmap_for name\n    @html_tags[tag.downcase] = bitmap\n    @exclusive_bitmap |= bitmap if exclusive\n  end",
        "comment": " Adds a markup class with +name+ for words surrounded by HTML tag +tag+. To process emphasis tags:  am.add_html 'em', :EM",
        "label": "Others",
        "id": "736"
    },
    {
        "raw_code": "def add_regexp_handling(pattern, name, exclusive = false)\n    bitmap = @attributes.bitmap_for(name)\n    @regexp_handlings << [pattern, bitmap]\n    @exclusive_bitmap |= bitmap if exclusive\n  end",
        "comment": " Adds a regexp handling for +pattern+ with +name+.  A simple URL handler would be:  @am.add_regexp_handling(/((https?:)\\S+\\w)/, :HYPERLINK)",
        "label": "What",
        "id": "737"
    },
    {
        "raw_code": "def flow(str)\n    @str = str.dup\n\n    mask_protected_sequences\n\n    @attrs = RDoc::Markup::AttrSpan.new @str.length, @exclusive_bitmap\n\n    convert_attrs            @str, @attrs, true\n    convert_html             @str, @attrs, true\n    convert_regexp_handlings @str, @attrs, true\n    convert_attrs            @str, @attrs\n    convert_html             @str, @attrs\n    convert_regexp_handlings @str, @attrs\n\n    unmask_protected_sequences\n\n    split_into_flow\n  end",
        "comment": " Processes +str+ converting attributes, HTML and regexp handlings",
        "label": "How-it-is-done",
        "id": "738"
    },
    {
        "raw_code": "def display_attributes\n    puts\n    puts @str.tr(NULL, \"!\")\n    bit = 1\n    16.times do |bno|\n      line = \"\"\n      @str.length.times do |i|\n        if (@attrs[i] & bit) == 0\n          line << \" \"\n        else\n          if bno.zero?\n            line << \"S\"\n          else\n            line << (\"%d\" % (bno+1))\n          end",
        "comment": " Debug method that prints a string along with its attributes",
        "label": "How-to-use",
        "id": "739"
    },
    {
        "raw_code": "def split_into_flow\n    res = []\n    current_attr = 0\n\n    str_len = @str.length\n\n    # skip leading invisible text\n    i = 0\n    i += 1 while i < str_len and @str[i].chr == \"\\0\"\n    start_pos = i\n\n    # then scan the string, chunking it on attribute changes\n    while i < str_len\n      new_attr = @attrs[i]\n      if new_attr != current_attr\n        if i > start_pos\n          res << copy_string(start_pos, i)\n          start_pos = i\n        end",
        "comment": " Splits the string into chunks by attribute change",
        "label": "Property",
        "id": "740"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_verbatim self\n  end",
        "comment": " Calls #accept_verbatim on +visitor+",
        "label": "How-to-use",
        "id": "741"
    },
    {
        "raw_code": "def normalize\n    parts = []\n\n    newlines = 0\n\n    @parts.each do |part|\n      case part\n      when /^\\s*\\n/ then\n        newlines += 1\n        parts << part if newlines == 1\n      else\n        newlines = 0\n        parts << part\n      end",
        "comment": " Collapses 3+ newlines into two newlines",
        "label": "Others",
        "id": "742"
    },
    {
        "raw_code": "def ruby?\n    @format ||= nil # TODO for older ri data, switch the tree to marshal_dump\n    @format == :ruby\n  end",
        "comment": " Is this verbatim section Ruby code?",
        "label": "What",
        "id": "743"
    },
    {
        "raw_code": "def text\n    @parts.join\n  end",
        "comment": " The text of the section",
        "label": "What",
        "id": "744"
    },
    {
        "raw_code": "def initialize(options, from_path, context, markup = nil)\n    raise ArgumentError, 'from_path cannot be nil' if from_path.nil?\n\n    super options, markup\n\n    @context       = context\n    @from_path     = from_path\n    @hyperlink_all = @options.hyperlink_all\n    @show_hash     = @options.show_hash\n\n    @cross_reference = RDoc::CrossReference.new @context\n  end",
        "comment": " Creates a new crossref resolver that generates links relative to +context+ which lives at +from_path+ in the generated files.  '#' characters on references are removed unless +show_hash+ is true.  Only method names preceded by '#' or '::' are linked, unless +hyperlink_all+ is true.",
        "label": "How-it-is-done",
        "id": "745"
    },
    {
        "raw_code": "def init_link_notation_regexp_handlings\n    add_regexp_handling_RDOCLINK\n\n    # The crossref must be linked before tidylink because Klass.method[:sym]\n    # will be processed as a tidylink first and will be broken.\n    crossref_re = @options.hyperlink_all ? ALL_CROSSREF_REGEXP : CROSSREF_REGEXP\n    @markup.add_regexp_handling crossref_re, :CROSSREF\n\n    add_regexp_handling_TIDYLINK\n  end",
        "comment": ":nodoc:",
        "label": "Property",
        "id": "746"
    },
    {
        "raw_code": "def cross_reference(name, text = nil, code = true, rdoc_ref: false)\n    lookup = name\n\n    name = name[1..-1] unless @show_hash if name[0, 1] == '#'\n\n    if !(name.end_with?('+@', '-@')) and name =~ /(.*[^#:])?@/\n      text ||= [CGI.unescape($'), (\" at <code>#{$1}</code>\" if $~.begin(1))].join(\"\")\n      code = false\n    else\n      text ||= name\n    end",
        "comment": " Creates a link to the reference +name+ if the name exists.  If +text+ is given it is used as the link text, otherwise +name+ is used.",
        "label": "How-it-is-done",
        "id": "747"
    },
    {
        "raw_code": "def handle_regexp_CROSSREF(target)\n    name = target.text\n\n    return name if @options.autolink_excluded_words&.include?(name)\n\n    return name if name =~ /@[\\w-]+\\.[\\w-]/ # labels that look like emails\n\n    unless @hyperlink_all then\n      # This ensures that words entirely consisting of lowercase letters will\n      # not have cross-references generated (to suppress lots of erroneous\n      # cross-references to \"new\" in text, for instance)\n      return name if name =~ /\\A[a-z]*\\z/\n    end",
        "comment": " We're invoked when any text matches the CROSSREF pattern.  If we find the corresponding reference, generate a link.  If the name we're looking for contains no punctuation, we look for it up the module/class chain.  For example, ToHtml is found, even without the <tt>RDoc::Markup::</tt> prefix, because we look for it in module Markup first.",
        "label": "Why",
        "id": "748"
    },
    {
        "raw_code": "def handle_regexp_HYPERLINK(target)\n    url = target.text\n\n    case url\n    when /\\Ardoc-ref:/\n      cross_reference $', rdoc_ref: true\n    else\n      super\n    end",
        "comment": " Handles <tt>rdoc-ref:</tt> scheme links and allows RDoc::Markup::ToHtml to handle other schemes.",
        "label": "How-it-is-done",
        "id": "749"
    },
    {
        "raw_code": "def handle_regexp_RDOCLINK(target)\n    url = target.text\n\n    case url\n    when /\\Ardoc-ref:/\n      cross_reference $', rdoc_ref: true\n    else\n      super\n    end",
        "comment": " +target+ is an rdoc-schemed link that will be converted into a hyperlink. For the rdoc-ref scheme the cross-reference will be looked up and the given name will be used.  All other contents are handled by {the superclass}[rdoc-ref:RDoc::Markup::ToHtml#handle_regexp_RDOCLINK]",
        "label": "How-to-use",
        "id": "750"
    },
    {
        "raw_code": "def gen_url(url, text)\n    if url =~ /\\Ardoc-ref:/\n      name = $'\n      cross_reference name, text, name == text, rdoc_ref: true\n    else\n      super\n    end",
        "comment": " Generates links for <tt>rdoc-ref:</tt> scheme URLs and allows RDoc::Markup::ToHtml to handle other schemes.",
        "label": "Others",
        "id": "751"
    },
    {
        "raw_code": "def link(name, text, code = true, rdoc_ref: false)\n    if !(name.end_with?('+@', '-@')) and name =~ /(.*[^#:])?@/\n      name = $1\n      label = $'\n    end",
        "comment": " Creates an HTML link to +name+ with the given +text+.",
        "label": "How-it-is-done",
        "id": "752"
    },
    {
        "raw_code": "def convert_tt_crossref(flow_items, index)\n    opener = flow_items[index]\n    return unless tt_tag?(opener.turn_on)\n\n    string = flow_items[index + 1]\n    closer = flow_items[index + 2]\n\n    return unless String === string\n    return unless RDoc::Markup::AttrChanger === closer\n    return unless tt_tag?(closer.turn_off, true)\n\n    crossref_regexp = @options.hyperlink_all ? ALL_CROSSREF_REGEXP : CROSSREF_REGEXP\n    match = crossref_regexp.match(string)\n    return unless match\n    return unless match.begin(1).zero?\n\n    trailing = match.post_match\n    # Only convert when the remainder is punctuation/whitespace so other tt text stays literal.\n    return unless trailing.match?(/\\A[[:punct:]\\s]*\\z/)\n\n    text = cross_reference(string)\n    return if text == string\n\n    text\n  end",
        "comment": " Detects <tt>...</tt> spans that contain a single cross-reference candidate. When the candidate occupies the whole span (aside from trailing punctuation), the tt markup is replaced by the resolved cross-reference.",
        "label": "How-to-use",
        "id": "753"
    },
    {
        "raw_code": "def initialize(markup = nil)\n    super nil, markup\n\n    add_tag :TT, nil, nil\n  end",
        "comment": " Creates a new tt-only formatter.",
        "label": "How-it-is-done",
        "id": "754"
    },
    {
        "raw_code": "def accept_block_quote(block_quote)\n    tt_sections block_quote.text\n  end",
        "comment": " Adds tts from +block_quote+ to the output",
        "label": "What",
        "id": "755"
    },
    {
        "raw_code": "def accept_list_end(list)\n    @list_type.pop\n  end",
        "comment": " Pops the list type for +list+ from #list_type",
        "label": "How-to-use",
        "id": "756"
    },
    {
        "raw_code": "def accept_list_start(list)\n    @list_type << list.type\n  end",
        "comment": " Pushes the list type for +list+ onto #list_type",
        "label": "Why",
        "id": "757"
    },
    {
        "raw_code": "def accept_list_item_start(list_item)\n    case @list_type.last\n    when :NOTE, :LABEL then\n      Array(list_item.label).map do |label|\n        tt_sections label\n      end.flatten\n    end",
        "comment": " Prepares the visitor for consuming +list_item+",
        "label": "How-to-use",
        "id": "758"
    },
    {
        "raw_code": "def accept_paragraph(paragraph)\n    tt_sections(paragraph.text)\n  end",
        "comment": " Adds +paragraph+ to the output",
        "label": "Others",
        "id": "759"
    },
    {
        "raw_code": "def do_nothing(markup_item)\n  end",
        "comment": " Does nothing to +markup_item+ because it doesn't have any user-built content",
        "label": "Why",
        "id": "760"
    },
    {
        "raw_code": "def tt_sections(text)\n    flow = @am.flow text.dup\n\n    flow.each do |item|\n      case item\n      when String then\n        @res << item if in_tt?\n      when RDoc::Markup::AttrChanger then\n        off_tags res, item\n        on_tags res, item\n      when RDoc::Markup::RegexpHandling then\n        @res << convert_regexp_handling(item) if in_tt? # TODO can this happen?\n      else\n        raise \"Unknown flow element: #{item.inspect}\"\n      end",
        "comment": " Extracts tt sections from +text+",
        "label": "What",
        "id": "761"
    },
    {
        "raw_code": "def end_accepting\n    @res.compact\n  end",
        "comment": " Returns an Array of items that were wrapped in plus, tt or code.",
        "label": "Property",
        "id": "762"
    },
    {
        "raw_code": "def start_accepting\n    @res = []\n\n    @list_type = []\n  end",
        "comment": " Prepares the visitor for gathering tt sections",
        "label": "What",
        "id": "763"
    },
    {
        "raw_code": "def self.to_label\n    @to_label ||= RDoc::Markup::ToLabel.new\n  end",
        "comment": " A singleton RDoc::Markup::ToLabel formatter for headings.",
        "label": "What",
        "id": "764"
    },
    {
        "raw_code": "def self.to_html\n    return @to_html if @to_html\n\n    markup = RDoc::Markup.new\n    markup.add_regexp_handling RDoc::CrossReference::CROSSREF_REGEXP, :CROSSREF\n\n    @to_html = RDoc::Markup::ToHtml.new nil\n\n    def @to_html.handle_regexp_CROSSREF(target)\n      target.text.sub(/^\\\\/, '')\n    end\n\n    @to_html\n  end",
        "comment": " A singleton plain HTML formatter for headings.  Used for creating labels for the Table of Contents",
        "label": "What",
        "id": "765"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_heading self\n  end",
        "comment": " Calls #accept_heading on +visitor+",
        "label": "How-to-use",
        "id": "766"
    },
    {
        "raw_code": "def aref\n    \"label-#{self.class.to_label.convert text.dup}\"\n  end",
        "comment": " An HTML-safe anchor reference for this header.",
        "label": "What",
        "id": "767"
    },
    {
        "raw_code": "def label(context = nil)\n    label = aref\n\n    label = [context.aref, label].compact.join '-' if\n      context and context.respond_to? :aref\n\n    label\n  end",
        "comment": " Creates a fully-qualified label which will include the label from +context+.  This helps keep ids unique in HTML.",
        "label": "How-it-is-done",
        "id": "768"
    },
    {
        "raw_code": "def plain_html\n    text = self.text.dup\n\n    if matched = text.match(/rdoc-image:[^:]+:(.*)/)\n      text = matched[1]\n    end",
        "comment": " HTML markup of the text of this label without the surrounding header element.",
        "label": "What",
        "id": "769"
    },
    {
        "raw_code": "def initialize(file, include_path)\n    @file = file\n    @include_path = include_path\n  end",
        "comment": " Creates a new include that will import +file+ from +include_path+",
        "label": "How-it-is-done",
        "id": "770"
    },
    {
        "raw_code": "def self.gen_relative_url(path, target)\n    from        = File.dirname path\n    to, to_file = File.split target\n\n    from = from.split \"/\"\n    to   = to.split \"/\"\n\n    from.delete '.'\n    to.delete '.'\n\n    while from.size > 0 and to.size > 0 and from[0] == to[0] do\n      from.shift\n      to.shift\n    end",
        "comment": " Converts a target url to one that is relative to a given path",
        "label": "What",
        "id": "771"
    },
    {
        "raw_code": "def initialize(options, markup = nil)\n    @options = options\n\n    @markup = markup || RDoc::Markup.new\n    @am     = @markup.attribute_manager\n    @am.add_regexp_handling(/<br>/, :HARD_BREAK)\n\n    @attributes = @am.attributes\n\n    @attr_tags = []\n\n    @in_tt = 0\n    @tt_bit = @attributes.bitmap_for :TT\n\n    @hard_break = ''\n    @from_path = '.'\n  end",
        "comment": " Creates a new Formatter",
        "label": "How-it-is-done",
        "id": "772"
    },
    {
        "raw_code": "def accept_document(document)\n    document.parts.each do |item|\n      case item\n      when RDoc::Markup::Document then # HACK\n        accept_document item\n      else\n        item.accept self\n      end",
        "comment": " Adds +document+ to the output",
        "label": "What",
        "id": "773"
    },
    {
        "raw_code": "def add_regexp_handling_RDOCLINK\n    @markup.add_regexp_handling(/rdoc-[a-z]+:[^\\s\\]]+/, :RDOCLINK)\n  end",
        "comment": " Adds a regexp handling for links of the form rdoc-...:",
        "label": "What",
        "id": "774"
    },
    {
        "raw_code": "def add_regexp_handling_TIDYLINK\n    @markup.add_regexp_handling(/(?:\n                                  \\{[^{}]*\\} | # multi-word label\n                                  \\b[^\\s{}]+? # single-word label\n                                 )\n\n                                 \\[\\S+?\\]     # link target\n                                /x, :TIDYLINK)\n  end",
        "comment": " Adds a regexp handling for links of the form {<text>}[<url>] and <word>[<url>]",
        "label": "Others",
        "id": "775"
    },
    {
        "raw_code": "def add_tag(name, start, stop)\n    attr = @attributes.bitmap_for name\n    @attr_tags << InlineTag.new(attr, start, stop)\n  end",
        "comment": " Add a new set of tags for an attribute. We allow separate start and end tags for flexibility",
        "label": "How-to-use",
        "id": "776"
    },
    {
        "raw_code": "def annotate(tag)\n    tag\n  end",
        "comment": " Allows +tag+ to be decorated with additional information.",
        "label": "Others",
        "id": "777"
    },
    {
        "raw_code": "def convert(content)\n    @markup.convert content, self\n  end",
        "comment": " Marks up +content+",
        "label": "What",
        "id": "778"
    },
    {
        "raw_code": "def convert_flow(flow)\n    res = []\n\n    flow.each do |item|\n      case item\n      when String then\n        res << convert_string(item)\n      when RDoc::Markup::AttrChanger then\n        off_tags res, item\n        on_tags res, item\n      when RDoc::Markup::RegexpHandling then\n        res << convert_regexp_handling(item)\n      else\n        raise \"Unknown flow element: #{item.inspect}\"\n      end",
        "comment": " Converts flow items +flow+",
        "label": "How-it-is-done",
        "id": "779"
    },
    {
        "raw_code": "def convert_regexp_handling(target)\n    return target.text if in_tt?\n\n    handled = false\n\n    @attributes.each_name_of target.type do |name|\n      method_name = \"handle_regexp_#{name}\"\n\n      if respond_to? method_name then\n        target.text = public_send method_name, target\n        handled = true\n      end",
        "comment": " Converts added regexp handlings. See RDoc::Markup#add_regexp_handling",
        "label": "What",
        "id": "780"
    },
    {
        "raw_code": "def convert_string(string)\n    string\n  end",
        "comment": " Converts a string to be fancier if desired",
        "label": "Others",
        "id": "781"
    },
    {
        "raw_code": "def ignore *node\n  end",
        "comment": " Use ignore in your subclass to ignore the content of a node.  ## # We don't support raw nodes in ToNoRaw  alias accept_raw ignore",
        "label": "What",
        "id": "782"
    },
    {
        "raw_code": "def in_tt?\n    @in_tt > 0\n  end",
        "comment": " Are we currently inside tt tags?",
        "label": "What",
        "id": "783"
    },
    {
        "raw_code": "def on_tags(res, item)\n    each_attr_tag(item.turn_on) do |tag|\n      res << annotate(tag.on)\n      @in_tt += 1 if tt? tag\n    end",
        "comment": " Turns on tags for +item+ on +res+",
        "label": "What",
        "id": "784"
    },
    {
        "raw_code": "def off_tags(res, item)\n    each_attr_tag(item.turn_off, true) do |tag|\n      @in_tt -= 1 if tt? tag\n      res << annotate(tag.off)\n    end",
        "comment": " Turns off tags for +item+ on +res+",
        "label": "What",
        "id": "785"
    },
    {
        "raw_code": "def parse_url(url)\n    case url\n    when /^rdoc-label:([^:]*)(?::(.*))?/ then\n      scheme = 'link'\n      path   = \"##{$1}\"\n      id     = \" id=\\\"#{$2}\\\"\" if $2\n    when /([A-Za-z]+):(.*)/ then\n      scheme = $1.downcase\n      path   = $2\n    when /^#/ then\n    else\n      scheme = 'http'\n      path   = url\n      url    = url\n    end",
        "comment": " Extracts and a scheme, url and an anchor id from +url+ and returns them.",
        "label": "Property",
        "id": "786"
    },
    {
        "raw_code": "def tt?(tag)\n    tag.bit == @tt_bit\n  end",
        "comment": " Is +tag+ a tt tag?",
        "label": "What",
        "id": "787"
    },
    {
        "raw_code": "def self.new\n    @instance\n  end",
        "comment": " RDoc::Markup::BlankLine is a singleton",
        "label": "What",
        "id": "788"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_blank_line self\n  end",
        "comment": " Calls #accept_blank_line on +visitor+",
        "label": "How-to-use",
        "id": "789"
    },
    {
        "raw_code": "def start_accepting\n    @res = []\n    @list = []\n  end",
        "comment": ":stopdoc:  :section: Visitor",
        "label": "What",
        "id": "790"
    },
    {
        "raw_code": "def initialize *parts\n    @parts = []\n    @parts.concat parts\n  end",
        "comment": " Creates a new Raw containing +parts+",
        "label": "How-it-is-done",
        "id": "791"
    },
    {
        "raw_code": "def <<(text)\n    @parts << text\n  end",
        "comment": " Appends +text+",
        "label": "Others",
        "id": "792"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_raw self\n  end",
        "comment": " Calls #accept_raw+ on +visitor+",
        "label": "How-to-use",
        "id": "793"
    },
    {
        "raw_code": "def merge(other)\n    @parts.concat other.parts\n  end",
        "comment": " Appends +other+'s parts",
        "label": "Others",
        "id": "794"
    },
    {
        "raw_code": "def push *texts\n    self.parts.concat texts\n  end",
        "comment": " Appends +texts+ onto this Paragraph",
        "label": "What",
        "id": "795"
    },
    {
        "raw_code": "def text\n    @parts.join ' '\n  end",
        "comment": " The raw text",
        "label": "What",
        "id": "796"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_rule self\n  end",
        "comment": " Calls #accept_rule on +visitor+",
        "label": "How-to-use",
        "id": "797"
    },
    {
        "raw_code": "def self.new\n    @instance\n  end",
        "comment": " RDoc::Markup::HardBreak is a singleton",
        "label": "What",
        "id": "798"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_hard_break self\n  end",
        "comment": " Calls #accept_hard_break on +visitor+",
        "label": "How-to-use",
        "id": "799"
    },
    {
        "raw_code": "def initialize(length, exclusive)\n    @attrs = Array.new(length, 0)\n    @exclusive = exclusive\n  end",
        "comment": " Creates a new AttrSpan for +length+ characters",
        "label": "How-it-is-done",
        "id": "800"
    },
    {
        "raw_code": "def set_attrs(start, length, bits)\n    updated = false\n    for i in start ... (start+length)\n      if (@exclusive & @attrs[i]) == 0 || (@exclusive & bits) != 0\n        @attrs[i] |= bits\n        updated = true\n      end",
        "comment": " Toggles +bits+ from +start+ to +length+",
        "label": "Property",
        "id": "801"
    },
    {
        "raw_code": "def [](n)\n    @attrs[n]\n  end",
        "comment": " Accesses flags for character +n+",
        "label": "What",
        "id": "802"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_block_quote self\n  end",
        "comment": " Calls #accept_block_quote on +visitor+",
        "label": "How-to-use",
        "id": "803"
    },
    {
        "raw_code": "def self.parse(str)\n    parser = new\n    parser.tokenize str\n    doc = RDoc::Markup::Document.new\n    parser.parse doc\n  end",
        "comment": " Parses +str+ into a Document.  Use RDoc::Markup#parse instead of this method.",
        "label": "How-to-use",
        "id": "804"
    },
    {
        "raw_code": "def self.tokenize(str)\n    parser = new\n    parser.tokenize str\n    parser.tokens\n  end",
        "comment": " Returns a token stream for +str+, for testing",
        "label": "Property",
        "id": "805"
    },
    {
        "raw_code": "def initialize\n    @binary_input   = nil\n    @current_token  = nil\n    @debug          = false\n    @s              = nil\n    @tokens         = []\n  end",
        "comment": " Creates a new Parser.  See also ::parse",
        "label": "How-it-is-done",
        "id": "806"
    },
    {
        "raw_code": "def build_heading(level)\n    type, text, = get\n\n    text = case type\n           when :TEXT then\n             skip :NEWLINE\n             text\n           else\n             unget\n             ''\n           end",
        "comment": " Builds a Heading of +level+",
        "label": "What",
        "id": "807"
    },
    {
        "raw_code": "def build_list(margin)\n    p :list_start => margin if @debug\n\n    list = RDoc::Markup::List.new\n    label = nil\n\n    until @tokens.empty? do\n      type, data, column, = get\n\n      case type\n      when *LIST_TOKENS then\n        if column < margin || (list.type && list.type != type) then\n          unget\n          break\n        end",
        "comment": " Builds a List flush to +margin+",
        "label": "How-to-use",
        "id": "808"
    },
    {
        "raw_code": "def build_paragraph(margin)\n    p :paragraph_start => margin if @debug\n\n    paragraph = RDoc::Markup::Paragraph.new\n\n    until @tokens.empty? do\n      type, data, column, = get\n\n      if type == :TEXT and column == margin then\n        paragraph << data\n\n        break if peek_token.first == :BREAK\n\n        data << ' ' if skip :NEWLINE and /#{SPACE_SEPARATED_LETTER_CLASS}\\z/o.match?(data)\n      else\n        unget\n        break\n      end",
        "comment": " Builds a Paragraph that is flush to +margin+",
        "label": "How-to-use",
        "id": "809"
    },
    {
        "raw_code": "def build_verbatim(margin)\n    p :verbatim_begin => margin if @debug\n    verbatim = RDoc::Markup::Verbatim.new\n\n    min_indent = nil\n    generate_leading_spaces = true\n    line = ''.dup\n\n    until @tokens.empty? do\n      type, data, column, = get\n\n      if type == :NEWLINE then\n        line << data\n        verbatim << line\n        line = ''.dup\n        generate_leading_spaces = true\n        next\n      end",
        "comment": " Builds a Verbatim that is indented from +margin+.  The verbatim block is shifted left (the least indented lines start in column 0).  Each part of the verbatim is one line of text, always terminated by a newline.  Blank lines always consist of a single newline character, and there is never a single newline at the end of the verbatim.",
        "label": "How-to-use",
        "id": "810"
    },
    {
        "raw_code": "def get\n    @current_token = @tokens.shift\n    p :get => @current_token if @debug\n    @current_token\n  end",
        "comment": " Pulls the next token from the stream.",
        "label": "What",
        "id": "811"
    },
    {
        "raw_code": "def parse(parent, indent = 0)\n    p :parse_start => indent if @debug\n\n    until @tokens.empty? do\n      type, data, column, = get\n\n      case type\n      when :BREAK then\n        parent << RDoc::Markup::BlankLine.new\n        skip :NEWLINE, false\n        next\n      when :NEWLINE then\n        # trailing newlines are skipped below, so this is a blank line\n        parent << RDoc::Markup::BlankLine.new\n        skip :NEWLINE, false\n        next\n      end",
        "comment": " Parses the tokens into an array of RDoc::Markup::XXX objects, and appends them to the passed +parent+ RDoc::Markup::YYY object.  Exits at the end of the token stream, or when it encounters a token in a column less than +indent+ (unless it is a NEWLINE).  Returns +parent+.",
        "label": "Property",
        "id": "812"
    },
    {
        "raw_code": "def parse_text(parent, indent) # :nodoc:\n    parent << build_paragraph(indent)\n  end",
        "comment": " Small hook that is overridden by RDoc::TomDoc",
        "label": "What",
        "id": "813"
    },
    {
        "raw_code": "def peek_token\n    token = @tokens.first || []\n    p :peek => token if @debug\n    token\n  end",
        "comment": " Returns the next token on the stream without modifying the stream",
        "label": "Property",
        "id": "814"
    },
    {
        "raw_code": "def initialize(input)\n      @line = @column = 0\n      @s = StringScanner.new input\n    end",
        "comment": ":stopdoc:",
        "label": "What",
        "id": "815"
    },
    {
        "raw_code": "def setup_scanner(input)\n    @s = MyStringScanner.new input\n  end",
        "comment": " Creates the StringScanner",
        "label": "How-it-is-done",
        "id": "816"
    },
    {
        "raw_code": "def skip(token_type, error = true)\n    type, = get\n    return unless type # end of stream\n    return @current_token if token_type == type\n    unget\n    raise ParseError, \"expected #{token_type} got #{@current_token.inspect}\" if error\n  end",
        "comment": " Skips the next token if its type is +token_type+.  Optionally raises an error if the next token is not of the expected type.",
        "label": "How-to-use",
        "id": "817"
    },
    {
        "raw_code": "def tokenize(input)\n    setup_scanner input\n\n    until @s.eos? do\n      pos = @s.pos\n\n      # leading spaces will be reflected by the column of the next token\n      # the only thing we loose are trailing spaces at the end of the file\n      next if @s.scan(/ +/)\n\n      # note: after BULLET, LABEL, etc.,\n      # indent will be the column of the next non-newline token\n\n      @tokens << case\n                 # [CR]LF => :NEWLINE\n                 when @s.scan(/\\r?\\n/) then\n                   token = [:NEWLINE, @s.matched, *pos]\n                   @s.newline!\n                   token\n                 # === text => :HEADER then :TEXT\n                 when @s.scan(/(=+)(\\s*)/) then\n                   level = @s[1].length\n                   header = [:HEADER, level, *pos]\n\n                   if @s[2] =~ /^\\r?\\n/ then\n                     @s.unscan(@s[2])\n                     header\n                   else\n                     pos = @s.pos\n                     @s.scan(/.*/)\n                     @tokens << header\n                     [:TEXT, @s.matched.sub(/\\r$/, ''), *pos]\n                   end",
        "comment": " Turns text +input+ into a stream of tokens",
        "label": "How-to-use",
        "id": "818"
    },
    {
        "raw_code": "def unget\n    token = @current_token\n    p :unget => token if @debug\n    raise Error, 'too many #ungets' if token == @tokens.first\n    @tokens.unshift token if token\n  end",
        "comment": " Returns the current token to the token stream",
        "label": "Property",
        "id": "819"
    },
    {
        "raw_code": "def initialize(markup = nil)\n    super\n\n    @headings.clear\n    @headings[1] = [\"\\e[1;32m\", \"\\e[m\"] # bold\n    @headings[2] = [\"\\e[4;32m\", \"\\e[m\"] # underline\n    @headings[3] = [\"\\e[32m\",   \"\\e[m\"] # just green\n  end",
        "comment": " Creates a new ToAnsi visitor that is ready to output vibrant ANSI color!",
        "label": "How-it-is-done",
        "id": "820"
    },
    {
        "raw_code": "def init_tags\n    add_tag :BOLD, \"\\e[1m\", \"\\e[m\"\n    add_tag :TT,   \"\\e[7m\", \"\\e[m\"\n    add_tag :EM,   \"\\e[4m\", \"\\e[m\"\n  end",
        "comment": " Maps attributes to ANSI sequences",
        "label": "Property",
        "id": "821"
    },
    {
        "raw_code": "def accept_list_item_end(list_item)\n    width = case @list_type.last\n            when :BULLET then\n              2\n            when :NOTE, :LABEL then\n              if @prefix then\n                @res << @prefix.strip\n                @prefix = nil\n              end",
        "comment": " Overrides indent width to ensure output lines up correctly.",
        "label": "Why",
        "id": "822"
    },
    {
        "raw_code": "def accept_list_item_start(list_item)\n    bullet = case @list_type.last\n             when :BULLET then\n               '*'\n             when :NOTE, :LABEL then\n               labels = Array(list_item.label).map do |label|\n                 attributes(label).strip\n               end.join \"\\n\"\n\n               labels << \":\\n\" unless labels.empty?\n\n               labels\n             else\n               @list_index.last.to_s + '.'\n             end",
        "comment": " Adds coloring to note and label list items",
        "label": "Others",
        "id": "823"
    },
    {
        "raw_code": "def start_accepting\n    super\n\n    @res = [\"\\e[0m\"]\n  end",
        "comment": " Starts accepting with a reset screen",
        "label": "What",
        "id": "824"
    },
    {
        "raw_code": "def initialize(options, markup = nil)\n    super\n\n    @code_object = nil\n    @from_path = ''\n    @in_list_entry = nil\n    @list = nil\n    @th = nil\n    @hard_break = \"<br>\\n\"\n\n    init_regexp_handlings\n\n    init_tags\n  end",
        "comment": ":section:  Creates a new formatter that will output HTML",
        "label": "How-it-is-done",
        "id": "825"
    },
    {
        "raw_code": "def init_regexp_handlings\n    # external links\n    @markup.add_regexp_handling(/(?:link:|https?:|mailto:|ftp:|irc:|www\\.)#{URL_CHARACTERS_REGEXP_STR}+\\w/,\n                                :HYPERLINK)\n    init_link_notation_regexp_handlings\n  end",
        "comment": " Adds regexp handlings.",
        "label": "What",
        "id": "826"
    },
    {
        "raw_code": "def init_link_notation_regexp_handlings\n    add_regexp_handling_RDOCLINK\n    add_regexp_handling_TIDYLINK\n  end",
        "comment": " Adds regexp handlings about link notations.",
        "label": "How-to-use",
        "id": "827"
    },
    {
        "raw_code": "def handle_regexp_HARD_BREAK(target)\n    '<br>'\n  end",
        "comment": " +target+ is a <code><br></code>",
        "label": "What",
        "id": "828"
    },
    {
        "raw_code": "def handle_regexp_HYPERLINK(target)\n    url = CGI.escapeHTML(target.text)\n\n    gen_url url, url\n  end",
        "comment": " +target+ is a potential link.  The following schemes are handled:  <tt>mailto:</tt>:: Inserted as-is. <tt>http:</tt>:: Links are checked to see if they reference an image. If so, that image gets inserted using an <tt><img></tt> tag. Otherwise a conventional <tt><a href></tt> is used. <tt>link:</tt>:: Reference to a local file relative to the output directory.",
        "label": "How-to-use",
        "id": "829"
    },
    {
        "raw_code": "def handle_regexp_RDOCLINK(target)\n    handle_RDOCLINK target.text\n  end",
        "comment": " +target+ is an rdoc-schemed link that will be converted into a hyperlink.  For the +rdoc-ref+ scheme the named reference will be returned without creating a link.  For the +rdoc-label+ scheme the footnote and label prefixes are stripped when creating a link.  All other contents will be linked verbatim.",
        "label": "Others",
        "id": "830"
    },
    {
        "raw_code": "def handle_regexp_TIDYLINK(target)\n    text = target.text\n\n    return text unless\n      text =~ /^\\{(.*)\\}\\[(.*?)\\]$/ or text =~ /^(\\S+)\\[(.*?)\\]$/\n\n    label = $1\n    url   = CGI.escapeHTML($2)\n\n    if /^rdoc-image:/ =~ label\n      label = handle_RDOCLINK(label)\n    else\n      label = CGI.escapeHTML(label)\n    end",
        "comment": " This +target+ is a link where the label is different from the URL <tt>label[url]</tt> or <tt>{long label}[url]</tt>",
        "label": "Others",
        "id": "831"
    },
    {
        "raw_code": "def start_accepting\n    @res = []\n    @in_list_entry = []\n    @list = []\n  end",
        "comment": ":section: Visitor  These methods implement the HTML visitor.  Prepares the visitor for HTML generation",
        "label": "What",
        "id": "832"
    },
    {
        "raw_code": "def end_accepting\n    @res.join\n  end",
        "comment": " Returns the generated output",
        "label": "Property",
        "id": "833"
    },
    {
        "raw_code": "def accept_block_quote(block_quote)\n    @res << \"\\n<blockquote>\"\n\n    block_quote.parts.each do |part|\n      part.accept self\n    end",
        "comment": " Adds +block_quote+ to the output",
        "label": "Property",
        "id": "834"
    },
    {
        "raw_code": "def accept_paragraph(paragraph)\n    @res << \"\\n<p>\"\n    text = paragraph.text @hard_break\n    text = text.gsub(/(#{SPACE_SEPARATED_LETTER_CLASS})?\\K\\r?\\n(?=(?(1)(#{SPACE_SEPARATED_LETTER_CLASS})?))/o) {\n      defined?($2) && ' '\n    }\n    @res << to_html(text)\n    @res << \"</p>\\n\"\n  end",
        "comment": " Adds +paragraph+ to the output",
        "label": "Others",
        "id": "835"
    },
    {
        "raw_code": "def accept_verbatim(verbatim)\n    text = verbatim.text.rstrip\n\n    klass = nil\n\n    content = if verbatim.ruby? or parseable? text then\n                begin\n                  tokens = RDoc::Parser::RipperStateLex.parse text\n                  klass  = ' class=\"ruby\"'\n\n                  result = RDoc::TokenStream.to_html tokens\n                  result = result + \"\\n\" unless \"\\n\" == result[-1]\n                  result\n                rescue\n                  CGI.escapeHTML text\n                end",
        "comment": " Adds +verbatim+ to the output",
        "label": "What",
        "id": "836"
    },
    {
        "raw_code": "def accept_rule(rule)\n    @res << \"<hr>\\n\"\n  end",
        "comment": " Adds +rule+ to the output",
        "label": "Others",
        "id": "837"
    },
    {
        "raw_code": "def accept_list_start(list)\n    @list << list.type\n    @res << html_list_name(list.type, true)\n    @in_list_entry.push false\n  end",
        "comment": " Prepares the visitor for consuming +list+",
        "label": "How-to-use",
        "id": "838"
    },
    {
        "raw_code": "def accept_list_end(list)\n    @list.pop\n    if tag = @in_list_entry.pop\n      @res << tag\n    end",
        "comment": " Finishes consumption of +list+",
        "label": "Others",
        "id": "839"
    },
    {
        "raw_code": "def accept_list_item_start(list_item)\n    if tag = @in_list_entry.last\n      @res << tag\n    end",
        "comment": " Prepares the visitor for consuming +list_item+",
        "label": "How-to-use",
        "id": "840"
    },
    {
        "raw_code": "def accept_list_item_end(list_item)\n    @in_list_entry[-1] = list_end_for(@list.last)\n  end",
        "comment": " Finishes consumption of +list_item+",
        "label": "What",
        "id": "841"
    },
    {
        "raw_code": "def accept_blank_line(blank_line)\n    # @res << annotate(\"<p />\") << \"\\n\"\n  end",
        "comment": " Adds +blank_line+ to the output",
        "label": "What",
        "id": "842"
    },
    {
        "raw_code": "def accept_heading(heading)\n    level = [6, heading.level].min\n\n    label = heading.label @code_object\n\n    @res << if @options.output_decoration\n              \"\\n<h#{level} id=\\\"#{label}\\\">\"\n            else\n              \"\\n<h#{level}>\"\n            end",
        "comment": " Adds +heading+ to the output.  The headings greater than 6 are trimmed to level 6.",
        "label": "Property",
        "id": "843"
    },
    {
        "raw_code": "def accept_raw(raw)\n    @res << raw.parts.join(\"\\n\")\n  end",
        "comment": " Adds +raw+ to the output",
        "label": "What",
        "id": "844"
    },
    {
        "raw_code": "def accept_table(header, body, aligns)\n    @res << \"\\n<table role=\\\"table\\\">\\n<thead>\\n<tr>\\n\"\n    header.zip(aligns) do |text, align|\n      @res << '<th'\n      @res << ' align=\"' << align << '\"' if align\n      @res << '>' << to_html(text) << \"</th>\\n\"\n    end",
        "comment": " Adds +table+ to the output",
        "label": "Property",
        "id": "845"
    },
    {
        "raw_code": "def convert_string(text)\n    CGI.escapeHTML text\n  end",
        "comment": ":section: Utilities  CGI-escapes +text+",
        "label": "What",
        "id": "846"
    },
    {
        "raw_code": "def gen_url(url, text)\n    scheme, url, id = parse_url url\n\n    if %w[http https link].include?(scheme) and\n       url =~ /\\.(gif|png|jpg|jpeg|bmp)$/ then\n      \"<img src=\\\"#{url}\\\" />\"\n    else\n      if scheme != 'link' and %r%\\A((?!https?:)(?:[^/#]*/)*+)([^/#]+)\\.(rb|rdoc|md)(?=\\z|#)%i =~ url\n        url = \"#$1#{$2.tr('.', '_')}_#$3.html#$'\"\n      end",
        "comment": " Generate a link to +url+ with content +text+.  Handles the special cases for img: and link: described under handle_regexp_HYPERLINK",
        "label": "How-it-is-done",
        "id": "847"
    },
    {
        "raw_code": "def html_list_name(list_type, open_tag)\n    tags = LIST_TYPE_TO_HTML[list_type]\n    raise RDoc::Error, \"Invalid list type: #{list_type.inspect}\" unless tags\n    tags[open_tag ? 0 : 1]\n  end",
        "comment": " Determines the HTML list element for +list_type+ and +open_tag+",
        "label": "What",
        "id": "848"
    },
    {
        "raw_code": "def init_tags\n    add_tag :BOLD, \"<strong>\", \"</strong>\"\n    add_tag :TT,   \"<code>\",   \"</code>\"\n    add_tag :EM,   \"<em>\",     \"</em>\"\n  end",
        "comment": " Maps attributes to HTML tags",
        "label": "How-to-use",
        "id": "849"
    },
    {
        "raw_code": "def list_item_start(list_item, list_type)\n    case list_type\n    when :BULLET, :LALPHA, :NUMBER, :UALPHA then\n      \"<li>\"\n    when :LABEL, :NOTE then\n      Array(list_item.label).map do |label|\n        \"<dt>#{to_html label}</dt>\\n\"\n      end.join << \"<dd>\"\n    else\n      raise RDoc::Error, \"Invalid list type: #{list_type.inspect}\"\n    end",
        "comment": " Returns the HTML tag for +list_type+, possible using a label from +list_item+",
        "label": "Property",
        "id": "850"
    },
    {
        "raw_code": "def list_end_for(list_type)\n    case list_type\n    when :BULLET, :LALPHA, :NUMBER, :UALPHA then\n      \"</li>\"\n    when :LABEL, :NOTE then\n      \"</dd>\"\n    else\n      raise RDoc::Error, \"Invalid list type: #{list_type.inspect}\"\n    end",
        "comment": " Returns the HTML end-tag for +list_type+",
        "label": "Property",
        "id": "851"
    },
    {
        "raw_code": "def parseable?(text)\n    verbose, $VERBOSE = $VERBOSE, nil\n    catch(:valid) do\n      eval(\"BEGIN { throw :valid, true }\\n#{text}\")\n    end",
        "comment": " Returns true if text is valid ruby syntax",
        "label": "Property",
        "id": "852"
    },
    {
        "raw_code": "def to_html(item)\n    super convert_flow @am.flow item\n  end",
        "comment": " Converts +item+ to HTML using RDoc::Text#to_html",
        "label": "How-to-use",
        "id": "853"
    },
    {
        "raw_code": "def self.to_toc\n    @to_toc ||= new\n  end",
        "comment": " Singleton for table-of-contents generation",
        "label": "What",
        "id": "854"
    },
    {
        "raw_code": "def accept_document(document)\n    @omit_headings_below = document.omit_headings_below\n\n    super\n  end",
        "comment": " Adds +document+ to the output, using its heading cutoff if present",
        "label": "Property",
        "id": "855"
    },
    {
        "raw_code": "def accept_heading(heading)\n    @res << heading unless suppressed? heading\n  end",
        "comment": " Adds +heading+ to the table of contents",
        "label": "What",
        "id": "856"
    },
    {
        "raw_code": "def end_accepting\n    @res\n  end",
        "comment": " Returns the table of contents",
        "label": "Property",
        "id": "857"
    },
    {
        "raw_code": "def start_accepting\n    @omit_headings_below = nil\n    @res = []\n  end",
        "comment": " Prepares the visitor for text generation",
        "label": "How-to-use",
        "id": "858"
    },
    {
        "raw_code": "def suppressed?(heading)\n    return false unless @omit_headings_below\n\n    heading.level > @omit_headings_below\n  end",
        "comment": " Returns true if +heading+ is below the display threshold",
        "label": "Property",
        "id": "859"
    },
    {
        "raw_code": "def initialize indent, *parts\n    @indent = indent\n\n    super(*parts)\n  end",
        "comment": " Creates a new IndentedParagraph containing +parts+ indented with +indent+ spaces",
        "label": "How-it-is-done",
        "id": "860"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_indented_paragraph self\n  end",
        "comment": " Calls #accept_indented_paragraph on +visitor+",
        "label": "How-to-use",
        "id": "861"
    },
    {
        "raw_code": "def text(hard_break = nil)\n    @parts.map do |part|\n      if RDoc::Markup::HardBreak === part then\n        '%1$s%3$*2$s' % [hard_break, @indent, ' '] if hard_break\n      else\n        part\n      end",
        "comment": " Joins the raw paragraph text and converts inline HardBreaks to the +hard_break+ text followed by the indent.",
        "label": "How-it-is-done",
        "id": "862"
    },
    {
        "raw_code": "def self.post_process(&block)\n    @post_processors << block\n  end",
        "comment": " Adds a post-process handler for directives.  The handler will be called with the result RDoc::Comment (or text String) and the code object for the comment (if any).",
        "label": "How-to-use",
        "id": "863"
    },
    {
        "raw_code": "def self.post_processors\n    @post_processors\n  end",
        "comment": " Registered post-processors",
        "label": "What",
        "id": "864"
    },
    {
        "raw_code": "def self.register(directive, &block)\n    @registered[directive] = block\n  end",
        "comment": " Registers +directive+ as one handled by RDoc.  If a block is given the directive will be replaced by the result of the block, otherwise the directive will be removed from the processed text.  The block will be called with the directive name and the directive parameter:  RDoc::Markup::PreProcess.register 'my-directive' do |directive, param| # replace text, etc. end",
        "label": "How-to-use",
        "id": "865"
    },
    {
        "raw_code": "def self.registered\n    @registered\n  end",
        "comment": " Registered directives",
        "label": "Property",
        "id": "866"
    },
    {
        "raw_code": "def self.reset\n    @post_processors = []\n    @registered = {}\n  end",
        "comment": " Clears all registered directives and post-processors",
        "label": "What",
        "id": "867"
    },
    {
        "raw_code": "def initialize(input_file_name, include_path)\n    @input_file_name = input_file_name\n    @include_path = include_path\n    @options = nil\n  end",
        "comment": " Creates a new pre-processor for +input_file_name+ that will look for included files in +include_path+",
        "label": "How-it-is-done",
        "id": "868"
    },
    {
        "raw_code": "def handle(text, code_object = nil, &block)\n    first_line = 1\n    if RDoc::Comment === text then\n      comment = text\n      text = text.text\n      first_line = comment.line || 1\n    end",
        "comment": " Look for directives in the given +text+.  Options that we don't handle are yielded.  If the block returns false the directive is restored to the text.  If the block returns nil or no block was given the directive is handled according to the registered directives. If a String was returned the directive is replaced with the string.  If no matching directive was registered the directive is restored to the text.  If +code_object+ is given and the directive is unknown then the directive's parameter is set as metadata on the +code_object+.  See RDoc::CodeObject#metadata for details.",
        "label": "Property",
        "id": "869"
    },
    {
        "raw_code": "def handle_directive(prefix, directive, param, code_object = nil,\n                       encoding = nil, line = nil)\n    blankline = \"#{prefix.strip}\\n\"\n    directive = directive.downcase\n\n    case directive\n    when 'arg', 'args' then\n      return \"#{prefix}:#{directive}: #{param}\\n\" unless code_object && code_object.kind_of?(RDoc::AnyMethod)\n\n      code_object.params = param\n\n      blankline\n    when 'category' then\n      if RDoc::Context === code_object then\n        section = code_object.add_section param\n        code_object.temporary_section = section\n      elsif RDoc::AnyMethod === code_object then\n        code_object.section_title = param\n      end",
        "comment": " Performs the actions described by +directive+ and its parameter +param+.  +code_object+ is used for directives that operate on a class or module. +prefix+ is used to ensure the replacement for handled directives is correct.  +encoding+ is used for the <tt>include</tt> directive.  For a list of directives in RDoc see RDoc::Markup. -- When 1.8.7 support is ditched prefix can be defaulted to ''",
        "label": "How-it-is-done",
        "id": "870"
    },
    {
        "raw_code": "def include_file(name, indent, encoding)\n    full_name = find_include_file name\n\n    unless full_name then\n      warn \"Couldn't find file to include '#{name}' from #{@input_file_name}\"\n      return ''\n    end",
        "comment": " Handles the <tt>:include: _filename_</tt> directive.  If the first line of the included file starts with '#', and contains an encoding information in the form 'coding:' or 'coding=', it is removed.  If all lines in the included file start with a '#', this leading '#' is removed before inclusion. The included content is indented like the <tt>:include:</tt> directive. -- so all content will be verbatim because of the likely space after '#'? TODO shift left the whole file content in that case TODO comment stop/start #-- and #++ in included file must be processed here",
        "label": "Why",
        "id": "871"
    },
    {
        "raw_code": "def find_include_file(name)\n    to_search = [File.dirname(@input_file_name)].concat @include_path\n    to_search.each do |dir|\n      full_name = File.join(dir, name)\n      stat = File.stat(full_name) rescue next\n      return full_name if stat.readable?\n    end",
        "comment": " Look for the given file in the directory containing the current file, and then in each of the directories specified in the RDOC_INCLUDE path",
        "label": "How-to-use",
        "id": "872"
    },
    {
        "raw_code": "def initialize\n    @regexp_handling = 1\n\n    @name_to_bitmap = [\n      [:_REGEXP_HANDLING_, @regexp_handling],\n    ]\n\n    @next_bitmap = @regexp_handling << 1\n  end",
        "comment": " Creates a new attributes set.",
        "label": "How-it-is-done",
        "id": "873"
    },
    {
        "raw_code": "def bitmap_for(name)\n    bitmap = @name_to_bitmap.assoc name\n\n    unless bitmap then\n      bitmap = @next_bitmap\n      @next_bitmap <<= 1\n      @name_to_bitmap << [name, bitmap]\n    else\n      bitmap = bitmap.last\n    end",
        "comment": " Returns a unique bit for +name+",
        "label": "Property",
        "id": "874"
    },
    {
        "raw_code": "def as_string(bitmap)\n    return 'none' if bitmap.zero?\n    res = []\n\n    @name_to_bitmap.each do |name, bit|\n      res << name if (bitmap & bit) != 0\n    end",
        "comment": " Returns a string representation of +bitmap+",
        "label": "Property",
        "id": "875"
    },
    {
        "raw_code": "def each_name_of(bitmap)\n    return enum_for __method__, bitmap unless block_given?\n\n    @name_to_bitmap.each do |name, bit|\n      next if bit == @regexp_handling\n\n      yield name.to_s if (bitmap & bit) != 0\n    end",
        "comment": " yields each attribute name in +bitmap+",
        "label": "How-to-use",
        "id": "876"
    },
    {
        "raw_code": "def initialize(markup = nil)\n    super\n\n    @headings[1] = ['# ',      '']\n    @headings[2] = ['## ',     '']\n    @headings[3] = ['### ',    '']\n    @headings[4] = ['#### ',   '']\n    @headings[5] = ['##### ',  '']\n    @headings[6] = ['###### ', '']\n\n    add_regexp_handling_RDOCLINK\n    add_regexp_handling_TIDYLINK\n\n    @hard_break = \"  \\n\"\n  end",
        "comment": " Creates a new formatter that will output Markdown format text",
        "label": "How-it-is-done",
        "id": "877"
    },
    {
        "raw_code": "def init_tags\n    add_tag :BOLD, '**', '**'\n    add_tag :EM,   '*',  '*'\n    add_tag :TT,   '`',  '`'\n  end",
        "comment": " Maps attributes to HTML sequences",
        "label": "How-to-use",
        "id": "878"
    },
    {
        "raw_code": "def handle_regexp_HARD_BREAK(target)\n    \"  \\n\"\n  end",
        "comment": " Adds a newline to the output",
        "label": "Others",
        "id": "879"
    },
    {
        "raw_code": "def accept_list_end(list)\n    super\n  end",
        "comment": " Finishes consumption of `list`",
        "label": "What",
        "id": "880"
    },
    {
        "raw_code": "def accept_list_item_end(list_item)\n    width = case @list_type.last\n            when :BULLET then\n              4\n            when :NOTE, :LABEL then\n              use_prefix\n\n              @res << \"\\n\"\n\n              4\n            else\n              @list_index[-1] = @list_index.last.succ\n              4\n            end",
        "comment": " Finishes consumption of `list_item`",
        "label": "What",
        "id": "881"
    },
    {
        "raw_code": "def accept_list_item_start(list_item)\n    type = @list_type.last\n\n    case type\n    when :NOTE, :LABEL then\n      bullets = Array(list_item.label).map do |label|\n        attributes(label).strip\n      end.join \"\\n\"\n\n      bullets << \"\\n\" unless bullets.empty?\n\n      @prefix = ' ' * @indent\n      @indent += 4\n      @prefix << bullets << \":\" << (' ' * (@indent - 1))\n    else\n      bullet = type == :BULLET ? '*' : @list_index.last.to_s + '.'\n      @prefix = (' ' * @indent) + bullet.ljust(4)\n\n      @indent += 4\n    end",
        "comment": " Prepares the visitor for consuming `list_item`",
        "label": "How-to-use",
        "id": "882"
    },
    {
        "raw_code": "def accept_list_start(list)\n    case list.type\n    when :BULLET, :LABEL, :NOTE then\n      @list_index << nil\n    when :LALPHA, :NUMBER, :UALPHA then\n      @list_index << 1\n    else\n      raise RDoc::Error, \"invalid list type #{list.type}\"\n    end",
        "comment": " Prepares the visitor for consuming `list`",
        "label": "How-to-use",
        "id": "883"
    },
    {
        "raw_code": "def accept_rule(rule)\n    use_prefix or @res << ' ' * @indent\n    @res << '-' * 3\n    @res << \"\\n\"\n  end",
        "comment": " Adds `rule` to the output",
        "label": "What",
        "id": "884"
    },
    {
        "raw_code": "def accept_verbatim(verbatim)\n    indent = ' ' * (@indent + 4)\n\n    verbatim.parts.each do |part|\n      @res << indent unless part == \"\\n\"\n      @res << part\n    end",
        "comment": " Outputs `verbatim` indented 4 columns",
        "label": "What",
        "id": "885"
    },
    {
        "raw_code": "def gen_url(url, text)\n    scheme, url, = parse_url url\n\n    \"[#{text.sub(%r{^#{scheme}:/*}i, '')}](#{url})\"\n  end",
        "comment": " Creates a Markdown-style URL from +url+ with +text+.",
        "label": "How-it-is-done",
        "id": "886"
    },
    {
        "raw_code": "def handle_rdoc_link(url)\n    case url\n    when /^rdoc-ref:/ then\n      $'\n    when /^rdoc-label:footmark-(\\d+)/ then\n      \"[^#{$1}]:\"\n    when /^rdoc-label:foottext-(\\d+)/ then\n      \"[^#{$1}]\"\n    when /^rdoc-label:label-/ then\n      gen_url url, $'\n    when /^rdoc-image:/ then\n      \"![](#{$'})\"\n    when /^rdoc-[a-z]+:/ then\n      $'\n    end",
        "comment": " Handles <tt>rdoc-</tt> type links for footnotes.",
        "label": "How-it-is-done",
        "id": "887"
    },
    {
        "raw_code": "def handle_regexp_TIDYLINK(target)\n    text = target.text\n\n    return text unless text =~ /\\{(.*?)\\}\\[(.*?)\\]/ or text =~ /(\\S+)\\[(.*?)\\]/\n\n    label = $1\n    url   = $2\n\n    if url =~ /^rdoc-label:foot/ then\n      handle_rdoc_link url\n    else\n      gen_url url, label\n    end",
        "comment": " Converts the RDoc markup tidylink into a Markdown.style link.",
        "label": "What",
        "id": "888"
    },
    {
        "raw_code": "def handle_regexp_RDOCLINK(target)\n    handle_rdoc_link target.text\n  end",
        "comment": " Converts the rdoc-...: links into a Markdown.style links.",
        "label": "What",
        "id": "889"
    },
    {
        "raw_code": "def accept_paragraph(paragraph)\n    parts = paragraph.parts.chunk do |part|\n      String === part\n    end.flat_map do |string, chunk|\n      string ? chunk.join.rstrip : chunk\n    end",
        "comment": " Converts the parts of +paragraph+ to a single entry.",
        "label": "Others",
        "id": "890"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_paragraph self\n  end",
        "comment": " Calls #accept_paragraph on +visitor+",
        "label": "How-to-use",
        "id": "891"
    },
    {
        "raw_code": "def text(hard_break = '')\n    @parts.map do |part|\n      if RDoc::Markup::HardBreak === part then\n        hard_break\n      else\n        part\n      end",
        "comment": " Joins the raw paragraph text and converts inline HardBreaks to the +hard_break+ text.",
        "label": "Property",
        "id": "892"
    },
    {
        "raw_code": "def initialize(header, align, body)\n    @header, @align, @body = header, align, body\n  end",
        "comment": "Creates new instance",
        "label": "How-it-is-done",
        "id": "893"
    },
    {
        "raw_code": "def ==(other)\n    self.class == other.class and\n      @header == other.header and\n      @align == other.align and\n      @body == other.body\n  end",
        "comment": ":stopdoc:",
        "label": "What",
        "id": "894"
    },
    {
        "raw_code": "def initialize type = nil, *items\n    @type = type\n    @items = []\n    @items.concat items\n  end",
        "comment": " Creates a new list of +type+ with +items+.  Valid list types are: +:BULLET+, +:LABEL+, +:LALPHA+, +:NOTE+, +:NUMBER+, +:UALPHA+",
        "label": "How-it-is-done",
        "id": "895"
    },
    {
        "raw_code": "def <<(item)\n    @items << item\n  end",
        "comment": " Appends +item+ to the list",
        "label": "Others",
        "id": "896"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_list_start self\n\n    @items.each do |item|\n      item.accept visitor\n    end",
        "comment": " Runs this list and all its #items through +visitor+",
        "label": "What",
        "id": "897"
    },
    {
        "raw_code": "def empty?\n    @items.empty?\n  end",
        "comment": " Is the list empty?",
        "label": "Others",
        "id": "898"
    },
    {
        "raw_code": "def last\n    @items.last\n  end",
        "comment": " Returns the last item in the list",
        "label": "Property",
        "id": "899"
    },
    {
        "raw_code": "def push *items\n    @items.concat items\n  end",
        "comment": " Appends +items+ to the list",
        "label": "Others",
        "id": "900"
    },
    {
        "raw_code": "def initialize(options, characters = 100, paragraphs = 3, markup = nil)\n    super options, markup\n\n    @character_limit = characters\n    @paragraph_limit = paragraphs\n\n    @characters = 0\n    @mask       = 0\n    @paragraphs = 0\n\n    @markup.add_regexp_handling RDoc::CrossReference::CROSSREF_REGEXP, :CROSSREF\n  end",
        "comment": " Creates a new ToHtmlSnippet formatter that will cut off the input on the next word boundary after the given number of +characters+ or +paragraphs+ of text have been encountered.",
        "label": "How-it-is-done",
        "id": "901"
    },
    {
        "raw_code": "def accept_heading(heading)\n    @res << \"<p>#{to_html heading.text}\\n\"\n\n    add_paragraph\n  end",
        "comment": " Adds +heading+ to the output as a paragraph",
        "label": "What",
        "id": "902"
    },
    {
        "raw_code": "def accept_paragraph(paragraph)\n    para = @in_list_entry.last || \"<p>\"\n\n    text = paragraph.text @hard_break\n\n    @res << \"#{para}#{to_html text}\\n\"\n\n    add_paragraph\n  end",
        "comment": " Adds +paragraph+ to the output",
        "label": "Others",
        "id": "903"
    },
    {
        "raw_code": "def accept_list_item_end(list_item)\n  end",
        "comment": " Finishes consumption of +list_item+",
        "label": "What",
        "id": "904"
    },
    {
        "raw_code": "def accept_list_item_start(list_item)\n    @res << list_item_start(list_item, @list.last)\n  end",
        "comment": " Prepares the visitor for consuming +list_item+",
        "label": "How-to-use",
        "id": "905"
    },
    {
        "raw_code": "def accept_list_start(list)\n    @list << list.type\n    @res << html_list_name(list.type, true)\n    @in_list_entry.push ''\n  end",
        "comment": " Prepares the visitor for consuming +list+",
        "label": "How-to-use",
        "id": "906"
    },
    {
        "raw_code": "def accept_verbatim(verbatim)\n    throw :done if @characters >= @character_limit\n    input = verbatim.text.rstrip\n\n    text = truncate input\n    text << ' ...' unless text == input\n\n    super RDoc::Markup::Verbatim.new text\n\n    add_paragraph\n  end",
        "comment": " Adds +verbatim+ to the output",
        "label": "What",
        "id": "907"
    },
    {
        "raw_code": "def start_accepting\n    super\n\n    @characters = 0\n  end",
        "comment": " Prepares the visitor for HTML snippet generation",
        "label": "How-to-use",
        "id": "908"
    },
    {
        "raw_code": "def handle_regexp_CROSSREF(target)\n    target.text.sub(/\\A\\\\/, '')\n  end",
        "comment": " Removes escaping from the cross-references in +target+",
        "label": "How-to-use",
        "id": "909"
    },
    {
        "raw_code": "def handle_regexp_HARD_BREAK(target)\n    @characters -= 4\n    '<br>'\n  end",
        "comment": " +target+ is a <code><br></code>",
        "label": "What",
        "id": "910"
    },
    {
        "raw_code": "def list_item_start(list_item, list_type)\n    throw :done if @characters >= @character_limit\n\n    case list_type\n    when :BULLET, :LALPHA, :NUMBER, :UALPHA then\n      \"<p>\"\n    when :LABEL, :NOTE then\n      labels = Array(list_item.label).map do |label|\n        to_html label\n      end.join ', '\n\n      labels << \" &mdash; \" unless labels.empty?\n\n      start = \"<p>#{labels}\"\n      @characters += 1 # try to include the label\n      start\n    else\n      raise RDoc::Error, \"Invalid list type: #{list_type.inspect}\"\n    end",
        "comment": " Lists are paragraphs, but notes and labels have a separator",
        "label": "Others",
        "id": "911"
    },
    {
        "raw_code": "def gen_url(url, text)\n    if url =~ /^rdoc-label:([^:]*)(?::(.*))?/ then\n      type = \"link\"\n    elsif url =~ /([A-Za-z]+):(.*)/ then\n      type = $1\n    else\n      type = \"http\"\n    end",
        "comment": " Returns just the text of +link+, +url+ is only used to determine the link type.",
        "label": "Property",
        "id": "912"
    },
    {
        "raw_code": "def html_list_name(list_type, open_tag)\n    ''\n  end",
        "comment": " In snippets, there are no lists",
        "label": "Others",
        "id": "913"
    },
    {
        "raw_code": "def add_paragraph\n    @paragraphs += 1\n\n    throw :done if @paragraphs >= @paragraph_limit\n  end",
        "comment": " Throws +:done+ when paragraph_limit paragraphs have been encountered",
        "label": "Others",
        "id": "914"
    },
    {
        "raw_code": "def convert(content)\n    catch :done do\n      return super\n    end",
        "comment": " Marks up +content+",
        "label": "What",
        "id": "915"
    },
    {
        "raw_code": "def convert_flow(flow)\n    throw :done if @characters >= @character_limit\n\n    res = []\n    @mask = 0\n\n    flow.each do |item|\n      case item\n      when RDoc::Markup::AttrChanger then\n        off_tags res, item\n        on_tags  res, item\n      when String then\n        text = convert_string item\n        res << truncate(text)\n      when RDoc::Markup::RegexpHandling then\n        text = convert_regexp_handling item\n        res << truncate(text)\n      else\n        raise \"Unknown flow element: #{item.inspect}\"\n      end",
        "comment": " Converts flow items +flow+",
        "label": "How-it-is-done",
        "id": "916"
    },
    {
        "raw_code": "def on_tags(res, item)\n    @mask ^= item.turn_on\n\n    super\n  end",
        "comment": " Maintains a bitmask to allow HTML elements to be closed properly.  See RDoc::Markup::Formatter.",
        "label": "What",
        "id": "917"
    },
    {
        "raw_code": "def off_tags(res, item)\n    @mask ^= item.turn_off\n\n    super\n  end",
        "comment": " Maintains a bitmask to allow HTML elements to be closed properly.  See RDoc::Markup::Formatter.",
        "label": "What",
        "id": "918"
    },
    {
        "raw_code": "def truncate(text)\n    length = text.length\n    characters = @characters\n    @characters += length\n\n    return text if @characters < @character_limit\n\n    remaining = @character_limit - characters\n\n    text =~ /\\A(.{#{remaining},}?)(\\s|$)/m # TODO word-break instead of \\s?\n\n    $1\n  end",
        "comment": " Truncates +text+ at the end of the first word after the character_limit.",
        "label": "Others",
        "id": "919"
    },
    {
        "raw_code": "def initialize *parts\n    @parts = []\n    @parts.concat parts\n\n    @file = nil\n    @omit_headings_from_table_of_contents_below = nil\n  end",
        "comment": " Creates a new Document with +parts+",
        "label": "How-it-is-done",
        "id": "920"
    },
    {
        "raw_code": "def <<(part)\n    case part\n    when RDoc::Markup::Document then\n      unless part.empty? then\n        parts.concat part.parts\n        parts << RDoc::Markup::BlankLine.new\n      end",
        "comment": " Appends +part+ to the document",
        "label": "Others",
        "id": "921"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.start_accepting\n\n    visitor.accept_document self\n\n    visitor.end_accepting\n  end",
        "comment": " Runs this document and all its #items through +visitor+",
        "label": "What",
        "id": "922"
    },
    {
        "raw_code": "def concat(parts)\n    self.parts.concat parts\n  end",
        "comment": " Concatenates the given +parts+ onto the document",
        "label": "Others",
        "id": "923"
    },
    {
        "raw_code": "def each(&block)\n    @parts.each(&block)\n  end",
        "comment": " Enumerator for the parts of this document",
        "label": "What",
        "id": "924"
    },
    {
        "raw_code": "def empty?\n    @parts.empty? or (@parts.length == 1 and merged? and @parts.first.empty?)\n  end",
        "comment": " Does this document have no parts?",
        "label": "How-it-is-done",
        "id": "925"
    },
    {
        "raw_code": "def file=(location)\n    @file = case location\n            when RDoc::TopLevel then\n              location.relative_name\n            else\n              location\n            end",
        "comment": " The file this Document was created from.",
        "label": "What",
        "id": "926"
    },
    {
        "raw_code": "def merge(other)\n    if empty? then\n      @parts = other.parts\n      return self\n    end",
        "comment": " When this is a collection of documents (#file is not set and this document contains only other documents as its direct children) #merge replaces documents in this class with documents from +other+ when the file matches and adds documents from +other+ when the files do not.  The information in +other+ is preferred over the receiver",
        "label": "Others",
        "id": "927"
    },
    {
        "raw_code": "def merged?\n    RDoc::Markup::Document === @parts.first\n  end",
        "comment": " Does this Document contain other Documents?",
        "label": "How-it-is-done",
        "id": "928"
    },
    {
        "raw_code": "def push *parts\n    self.parts.concat parts\n  end",
        "comment": " Appends +parts+ to the document",
        "label": "Others",
        "id": "929"
    },
    {
        "raw_code": "def table_of_contents\n    accept RDoc::Markup::ToTableOfContents.to_toc\n  end",
        "comment": " Returns an Array of headings in the document.  Require 'rdoc/markup/formatter' before calling this method.",
        "label": "How-to-use",
        "id": "930"
    },
    {
        "raw_code": "def initialize label = nil, *parts\n    @label = label\n    @parts = []\n    @parts.concat parts\n  end",
        "comment": " Creates a new ListItem with an optional +label+ containing +parts+",
        "label": "How-it-is-done",
        "id": "931"
    },
    {
        "raw_code": "def <<(part)\n    @parts << part\n  end",
        "comment": " Appends +part+ to the ListItem",
        "label": "What",
        "id": "932"
    },
    {
        "raw_code": "def accept(visitor)\n    visitor.accept_list_item_start self\n\n    @parts.each do |part|\n      part.accept visitor\n    end",
        "comment": " Runs this list item and all its #parts through +visitor+",
        "label": "What",
        "id": "933"
    },
    {
        "raw_code": "def empty?\n    @parts.empty?\n  end",
        "comment": " Is the ListItem empty?",
        "label": "What",
        "id": "934"
    },
    {
        "raw_code": "def length\n    @parts.length\n  end",
        "comment": " Length of parts in the ListItem",
        "label": "What",
        "id": "935"
    },
    {
        "raw_code": "def push *parts\n    @parts.concat parts\n  end",
        "comment": " Adds +parts+ to the ListItem",
        "label": "Others",
        "id": "936"
    },
    {
        "raw_code": "def initialize(type, text)\n    @type, @text = type, text\n  end",
        "comment": " Creates a new regexp handling sequence of +type+ with +text+",
        "label": "How-it-is-done",
        "id": "937"
    },
    {
        "raw_code": "def ==(o)\n    self.text == o.text && self.type == o.type\n  end",
        "comment": " Regexp handlings are equal when the have the same text and type",
        "label": "What",
        "id": "938"
    },
    {
        "raw_code": "def initialize(markup = nil)\n    super nil, markup\n\n    @markup.add_regexp_handling RDoc::CrossReference::CROSSREF_REGEXP, :CROSSREF\n    @markup.add_regexp_handling(/(((\\{.*?\\})|\\b\\S+?)\\[\\S+?\\])/, :TIDYLINK)\n\n    add_tag :BOLD, '', ''\n    add_tag :TT,   '', ''\n    add_tag :EM,   '', ''\n\n    @res = []\n  end",
        "comment": " Creates a new formatter that will output HTML-safe labels",
        "label": "How-it-is-done",
        "id": "939"
    },
    {
        "raw_code": "def convert(text)\n    label = convert_flow @am.flow text\n\n    CGI.escape(label).gsub('%', '-').sub(/^-/, '')\n  end",
        "comment": " Converts +text+ to an HTML-safe label",
        "label": "How-to-use",
        "id": "940"
    },
    {
        "raw_code": "def handle_regexp_CROSSREF(target)\n    text = target.text\n\n    text.sub(/^\\\\/, '')\n  end",
        "comment": " Converts the CROSSREF +target+ to plain text, removing the suppression marker, if any",
        "label": "Others",
        "id": "941"
    },
    {
        "raw_code": "def handle_regexp_TIDYLINK(target)\n    text = target.text\n\n    return text unless text =~ /\\{(.*?)\\}\\[(.*?)\\]/ or text =~ /(\\S+)\\[(.*?)\\]/\n\n    $1\n  end",
        "comment": " Converts the TIDYLINK +target+ to just the text part",
        "label": "Property",
        "id": "942"
    },
    {
        "raw_code": "def initialize(parent_generator, options)\n    @parent_generator = parent_generator\n    @store            = parent_generator.store\n    @options          = options\n\n    @template_dir = File.expand_path '../template/json_index', __FILE__\n    @base_dir = @parent_generator.base_dir\n\n    @classes = nil\n    @files   = nil\n    @index   = nil\n  end",
        "comment": " Creates a new generator. +options+ are the same options passed to the parent generator.",
        "label": "How-it-is-done",
        "id": "943"
    },
    {
        "raw_code": "def build_index\n    reset @store.all_files.sort, @store.all_classes_and_modules.sort\n\n    index_classes\n    index_methods\n    index_pages\n\n    { :index => @index }\n  end",
        "comment": " Builds the JSON index as a Hash.",
        "label": "What",
        "id": "944"
    },
    {
        "raw_code": "def debug_msg *msg\n    return unless $DEBUG_RDOC\n    $stderr.puts(*msg)\n  end",
        "comment": " Output progress information if debugging is enabled",
        "label": "What",
        "id": "945"
    },
    {
        "raw_code": "def generate\n    debug_msg \"Generating JSON index\"\n\n    debug_msg \"  writing search index to %s\" % SEARCH_INDEX_FILE\n    data = build_index\n\n    return if @options.dry_run\n\n    out_dir = @base_dir + @options.op_dir\n    index_file = out_dir + SEARCH_INDEX_FILE\n\n    FileUtils.mkdir_p index_file.dirname, :verbose => $DEBUG_RDOC\n\n    index_file.open 'w', 0644 do |io|\n      io.set_encoding Encoding::UTF_8\n      io.write 'var search_data = '\n\n      JSON.dump data, io, 0\n    end",
        "comment": " Writes the JSON index to disk",
        "label": "What",
        "id": "946"
    },
    {
        "raw_code": "def generate_gzipped\n    return if @options.dry_run or not defined?(Zlib)\n\n    debug_msg \"Compressing generated JSON index\"\n    out_dir = @base_dir + @options.op_dir\n\n    search_index_file = out_dir + SEARCH_INDEX_FILE\n    outfile           = out_dir + \"#{search_index_file}.gz\"\n\n    debug_msg \"Reading the JSON index file from %s\" % search_index_file\n    search_index = search_index_file.read(mode: 'r:utf-8')\n\n    debug_msg \"Writing gzipped search index to %s\" % outfile\n\n    Zlib::GzipWriter.open(outfile) do |gz|\n      gz.mtime = File.mtime(search_index_file)\n      gz.orig_name = search_index_file.basename.to_s\n      gz.write search_index\n      gz.close\n    end",
        "comment": " Compress the search_index.js file using gzip",
        "label": "What",
        "id": "947"
    },
    {
        "raw_code": "def index_classes\n    debug_msg \"  generating class search index\"\n\n    documented = @classes.uniq.select do |klass|\n      klass.document_self_or_methods\n    end",
        "comment": " Adds classes and modules to the index",
        "label": "What",
        "id": "948"
    },
    {
        "raw_code": "def index_methods\n    debug_msg \"  generating method search index\"\n\n    list = @classes.uniq.flat_map do |klass|\n      klass.method_list\n    end.sort_by do |method|\n      [method.name, method.parent.full_name]\n    end",
        "comment": " Adds methods to the index",
        "label": "Others",
        "id": "949"
    },
    {
        "raw_code": "def index_pages\n    debug_msg \"  generating pages search index\"\n\n    pages = @files.select do |file|\n      file.text?\n    end",
        "comment": " Adds pages to the index",
        "label": "Others",
        "id": "950"
    },
    {
        "raw_code": "def search_string(string)\n    string.downcase.gsub(/\\s/, '')\n  end",
        "comment": " Removes whitespace and downcases +string+",
        "label": "Others",
        "id": "951"
    },
    {
        "raw_code": "def initialize(store, options) #:not-new:\n    @options    = options\n    @store      = store\n    @store.path = '.'\n  end",
        "comment": " Set up a new ri generator",
        "label": "What",
        "id": "952"
    },
    {
        "raw_code": "def generate\n    @store.save\n  end",
        "comment": " Writes the parsed data store to disk for use by ri.",
        "label": "What",
        "id": "953"
    },
    {
        "raw_code": "def initialize(store, options)\n    @store   = store\n    @options = options\n\n    @asset_rel_path = ''\n    @base_dir       = Pathname.pwd.expand_path\n    @dry_run        = @options.dry_run\n    @file_output    = true\n    @template_dir   = Pathname.new options.template_dir\n    @template_cache = {}\n\n    @classes = nil\n    @context = nil\n    @files   = nil\n    @methods = nil\n    @modsort = nil\n\n    @json_index = RDoc::Generator::JsonIndex.new self, options\n  end",
        "comment": " Initialize a few instance variables before we start",
        "label": "How-to-use",
        "id": "954"
    },
    {
        "raw_code": "def debug_msg *msg\n    return unless $DEBUG_RDOC\n    $stderr.puts(*msg)\n  end",
        "comment": " Output progress information if debugging is enabled",
        "label": "What",
        "id": "955"
    },
    {
        "raw_code": "def gen_sub_directories\n    @outputdir.mkpath\n  end",
        "comment": " Create the directories the generated docs will live in if they don't already exist.",
        "label": "What",
        "id": "956"
    },
    {
        "raw_code": "def write_style_sheet\n    debug_msg \"Copying static files\"\n    options = { :verbose => $DEBUG_RDOC, :noop => @dry_run }\n\n    BUILTIN_STYLE_ITEMS.each do |item|\n      install_rdoc_static_file @template_dir + item, \"./#{item}\", options\n    end",
        "comment": " Copy over the stylesheet into the appropriate place in the output directory.",
        "label": "What",
        "id": "957"
    },
    {
        "raw_code": "def generate\n    setup\n\n    write_style_sheet\n    generate_index\n    generate_class_files\n    generate_file_files\n    generate_table_of_contents\n    @json_index.generate\n    @json_index.generate_gzipped\n\n    copy_static\n\n  rescue => e\n    debug_msg \"%s: %s\\n  %s\" % [\n      e.class.name, e.message, e.backtrace.join(\"\\n  \")\n    ]\n\n    raise\n  end",
        "comment": " Build the initial indices and output objects based on an array of TopLevel objects containing the extracted information.",
        "label": "How-to-use",
        "id": "958"
    },
    {
        "raw_code": "def copy_static\n    return if @options.static_path.empty?\n\n    fu_options = { :verbose => $DEBUG_RDOC, :noop => @dry_run }\n\n    @options.static_path.each do |path|\n      unless File.directory? path then\n        FileUtils.install path, @outputdir, **fu_options.merge(:mode => 0644)\n        next\n      end",
        "comment": " Copies static files from the static_path into the output directory",
        "label": "What",
        "id": "959"
    },
    {
        "raw_code": "def get_sorted_module_list(classes)\n    classes.select do |klass|\n      klass.display?\n    end.sort\n  end",
        "comment": " Return a list of the documented modules sorted by salience first, then by name.",
        "label": "What",
        "id": "960"
    },
    {
        "raw_code": "def generate_index\n    template_file = @template_dir + 'index.rhtml'\n    return unless template_file.exist?\n\n    debug_msg \"Rendering the index page...\"\n\n    out_file = @base_dir + @options.op_dir + 'index.html'\n    rel_prefix = @outputdir.relative_path_from out_file.dirname\n    search_index_rel_prefix = rel_prefix\n    search_index_rel_prefix += @asset_rel_path if @file_output\n\n    asset_rel_prefix = rel_prefix + @asset_rel_path\n\n    @title = @options.title\n    @main_page = @files.find { |f| f.full_name == @options.main_page }\n\n    render_template template_file, out_file do |io|\n      here = binding\n      # suppress 1.9.3 warning\n      here.local_variable_set(:asset_rel_prefix, asset_rel_prefix)\n      # some partials rely on the presence of current variable to render\n      here.local_variable_set(:current, @main_page) if @main_page\n      here\n    end",
        "comment": " Generate an index page which lists all the classes which are documented.",
        "label": "What",
        "id": "961"
    },
    {
        "raw_code": "def generate_class(klass, template_file = nil)\n    current = klass\n\n    template_file ||= @template_dir + 'class.rhtml'\n\n    debug_msg \"  working on %s (%s)\" % [klass.full_name, klass.path]\n    out_file   = @outputdir + klass.path\n    rel_prefix = @outputdir.relative_path_from out_file.dirname\n    search_index_rel_prefix = rel_prefix\n    search_index_rel_prefix += @asset_rel_path if @file_output\n\n    asset_rel_prefix = rel_prefix + @asset_rel_path\n\n    breadcrumb = # used in templates\n    breadcrumb = generate_nesting_namespaces_breadcrumb(current, rel_prefix)\n\n    @title = \"#{klass.type} #{klass.full_name} - #{@options.title}\"\n\n    debug_msg \"  rendering #{out_file}\"\n    render_template template_file, out_file do |io|\n      here = binding\n      # suppress 1.9.3 warning\n      here.local_variable_set(:asset_rel_prefix, asset_rel_prefix)\n      here\n    end",
        "comment": " Generates a class file for +klass+",
        "label": "How-to-use",
        "id": "962"
    },
    {
        "raw_code": "def generate_class_files\n    template_file = @template_dir + 'class.rhtml'\n    template_file = @template_dir + 'classpage.rhtml' unless\n      template_file.exist?\n    return unless template_file.exist?\n    debug_msg \"Generating class documentation in #{@outputdir}\"\n\n    current = nil\n\n    @classes.each do |klass|\n      current = klass\n\n      generate_class klass, template_file\n    end",
        "comment": " Generate a documentation file for each class and module",
        "label": "What",
        "id": "963"
    },
    {
        "raw_code": "def generate_file_files\n    page_file     = @template_dir + 'page.rhtml'\n    fileinfo_file = @template_dir + 'fileinfo.rhtml'\n\n    # for legacy templates\n    filepage_file = @template_dir + 'filepage.rhtml' unless\n      page_file.exist? or fileinfo_file.exist?\n\n    return unless\n      page_file.exist? or fileinfo_file.exist? or filepage_file.exist?\n\n    debug_msg \"Generating file documentation in #{@outputdir}\"\n\n    out_file = nil\n    current = nil\n\n    @files.each do |file|\n      current = file\n\n      if file.text? and page_file.exist? then\n        generate_page file\n        next\n      end",
        "comment": " Generate a documentation file for each file",
        "label": "Others",
        "id": "964"
    },
    {
        "raw_code": "def generate_page(file)\n    template_file = @template_dir + 'page.rhtml'\n\n    out_file = @outputdir + file.path\n    debug_msg \"  working on %s (%s)\" % [file.full_name, out_file]\n    rel_prefix = @outputdir.relative_path_from out_file.dirname\n    search_index_rel_prefix = rel_prefix\n    search_index_rel_prefix += @asset_rel_path if @file_output\n\n    current          = file\n    asset_rel_prefix = rel_prefix + @asset_rel_path\n\n    @title = \"#{file.page_name} - #{@options.title}\"\n\n    debug_msg \"  rendering #{out_file}\"\n    render_template template_file, out_file do |io|\n      here = binding\n      # suppress 1.9.3 warning\n      here.local_variable_set(:current, current)\n      here.local_variable_set(:asset_rel_prefix, asset_rel_prefix)\n      here\n    end",
        "comment": " Generate a page file for +file+",
        "label": "What",
        "id": "965"
    },
    {
        "raw_code": "def generate_servlet_not_found(message)\n    template_file = @template_dir + 'servlet_not_found.rhtml'\n    return unless template_file.exist?\n\n    debug_msg \"Rendering the servlet 404 Not Found page...\"\n\n    rel_prefix = rel_prefix = ''\n    search_index_rel_prefix = rel_prefix\n    search_index_rel_prefix += @asset_rel_path if @file_output\n\n    asset_rel_prefix = ''\n\n    @title = 'Not Found'\n\n    render_template template_file do |io|\n      here = binding\n      # suppress 1.9.3 warning\n      here.local_variable_set(:asset_rel_prefix, asset_rel_prefix)\n      here\n    end",
        "comment": " Generates the 404 page for the RDoc servlet",
        "label": "What",
        "id": "966"
    },
    {
        "raw_code": "def generate_servlet_root(installed)\n    template_file = @template_dir + 'servlet_root.rhtml'\n    return unless template_file.exist?\n\n    debug_msg 'Rendering the servlet root page...'\n\n    rel_prefix = '.'\n    asset_rel_prefix = rel_prefix\n    search_index_rel_prefix = asset_rel_prefix\n    search_index_rel_prefix += @asset_rel_path if @file_output\n\n    @title = 'Local RDoc Documentation'\n\n    render_template template_file do |io| binding end\n  rescue => e\n    error = RDoc::Error.new \\\n      \"error generating servlet_root: #{e.message} (#{e.class})\"\n    error.set_backtrace e.backtrace\n\n    raise error\n  end",
        "comment": " Generates the servlet root page for the RDoc servlet",
        "label": "What",
        "id": "967"
    },
    {
        "raw_code": "def generate_table_of_contents\n    template_file = @template_dir + 'table_of_contents.rhtml'\n    return unless template_file.exist?\n\n    debug_msg \"Rendering the Table of Contents...\"\n\n    out_file = @outputdir + 'table_of_contents.html'\n    rel_prefix = @outputdir.relative_path_from out_file.dirname\n    search_index_rel_prefix = rel_prefix\n    search_index_rel_prefix += @asset_rel_path if @file_output\n\n    asset_rel_prefix = rel_prefix + @asset_rel_path\n\n    @title = \"Table of Contents - #{@options.title}\"\n\n    render_template template_file, out_file do |io|\n      here = binding\n      # suppress 1.9.3 warning\n      here.local_variable_set(:asset_rel_prefix, asset_rel_prefix)\n      here\n    end",
        "comment": " Generate an index page which lists all the classes which are documented.",
        "label": "What",
        "id": "968"
    },
    {
        "raw_code": "def setup\n    return if instance_variable_defined? :@outputdir\n\n    @outputdir = Pathname.new(@options.op_dir).expand_path @base_dir\n\n    return unless @store\n\n    @classes = @store.all_classes_and_modules.sort\n    @files   = @store.all_files.sort\n    @methods = @classes.flat_map { |m| m.method_list }.sort\n    @modsort = get_sorted_module_list @classes\n  end",
        "comment": " Prepares for generation of output from the current directory",
        "label": "How-to-use",
        "id": "969"
    },
    {
        "raw_code": "def assemble_template(body_file)\n    body = body_file.read\n    return body if body =~ /<html/\n\n    head_file = @template_dir + '_head.rhtml'\n\n    <<-TEMPLATE\n<!DOCTYPE html>\n\n<html lang=\"#{@options.locale&.name || 'en'}\">\n<head>\n#{head_file.read}\n\n#{body}\n    TEMPLATE\n  end",
        "comment": " Creates a template from its components and the +body_file+.  For backwards compatibility, if +body_file+ contains \"<html\" the body is used directly.",
        "label": "How-it-is-done",
        "id": "970"
    },
    {
        "raw_code": "def render(file_name)\n    template_file = @template_dir + file_name\n\n    template = template_for template_file, false, RDoc::ERBPartial\n\n    template.filename = template_file.to_s\n\n    template.result @context\n  end",
        "comment": " Renders the ERb contained in +file_name+ relative to the template directory and returns the result based on the current context.",
        "label": "Property",
        "id": "971"
    },
    {
        "raw_code": "def render_template(template_file, out_file = nil) # :yield: io\n    io_output = out_file && !@dry_run && @file_output\n    erb_klass = io_output ? RDoc::ERBIO : ERB\n\n    template = template_for template_file, true, erb_klass\n\n    if io_output then\n      debug_msg \"Outputting to %s\" % [out_file.expand_path]\n\n      out_file.dirname.mkpath\n      out_file.open 'w', 0644 do |io|\n        io.set_encoding @options.encoding\n\n        @context = yield io\n\n        template_result template, @context, template_file\n      end",
        "comment": " Load and render the erb template in the given +template_file+ and write it out to +out_file+.  Both +template_file+ and +out_file+ should be Pathname-like objects.  An io will be yielded which must be captured by binding in the caller.",
        "label": "How-to-use",
        "id": "972"
    },
    {
        "raw_code": "def template_result(template, context, template_file)\n    template.filename = template_file.to_s\n    template.result context\n  rescue NoMethodError => e\n    raise RDoc::Error, \"Error while evaluating %s: %s\" % [\n      template_file.expand_path,\n      e.message,\n    ], e.backtrace\n  end",
        "comment": " Creates the result for +template+ with +context+.  If an error is raised a Pathname +template_file+ will indicate the file where the error occurred.",
        "label": "How-it-is-done",
        "id": "973"
    },
    {
        "raw_code": "def template_for(file, page = true, klass = ERB)\n    template = @template_cache[file]\n\n    return template if template\n\n    if page then\n      template = assemble_template file\n      erbout = 'io'\n    else\n      template = file.read\n      template = template.encode @options.encoding\n\n      file_var = File.basename(file).sub(/\\..*/, '')\n\n      erbout = \"_erbout_#{file_var}\"\n    end",
        "comment": " Retrieves a cache template for +file+, if present, or fills the cache.",
        "label": "What",
        "id": "974"
    },
    {
        "raw_code": "def excerpt(comment)\n    text = case comment\n    when RDoc::Comment\n      comment.text\n    else\n      comment\n    end",
        "comment": ":startdoc: Returns an excerpt of the comment for usage in meta description tags",
        "label": "How-to-use",
        "id": "975"
    },
    {
        "raw_code": "def initialize(store, options) #:not-new:\n    @options    = options\n    @store      = store\n  end",
        "comment": " Set up a new .pot generator",
        "label": "What",
        "id": "976"
    },
    {
        "raw_code": "def generate\n    po = extract_messages\n    pot_path = 'rdoc.pot'\n    File.open(pot_path, \"w\") do |pot|\n      pot.print(po.to_s)\n    end",
        "comment": " Writes .pot to disk.",
        "label": "Property",
        "id": "977"
    },
    {
        "raw_code": "def aref_to(target_path)\n    RDoc::Markup::ToHtml.gen_relative_url path, target_path\n  end",
        "comment": " Generates a relative URL from this object's path to +target_path+",
        "label": "What",
        "id": "978"
    },
    {
        "raw_code": "def as_href(from_path)\n    RDoc::Markup::ToHtml.gen_relative_url from_path, path\n  end",
        "comment": " Generates a relative URL from +from_path+ to this object's path",
        "label": "What",
        "id": "979"
    },
    {
        "raw_code": "def description\n    markup @comment\n  end",
        "comment": " Handy wrapper for marking up this object's comment",
        "label": "How-to-use",
        "id": "980"
    },
    {
        "raw_code": "def formatter\n    return @formatter if defined? @formatter\n\n    options = @store.options\n    this = RDoc::Context === self ? self : @parent\n\n    @formatter = RDoc::Markup::ToHtmlCrossref.new options, this.path, this\n    @formatter.code_object = self\n    @formatter\n  end",
        "comment": " Creates an RDoc::Markup::ToHtmlCrossref formatter",
        "label": "How-it-is-done",
        "id": "981"
    },
    {
        "raw_code": "def cvs_url(url, full_path)\n    if /%s/ =~ url then\n      sprintf url, full_path\n    else\n      url + full_path\n    end",
        "comment": " Build a webcvs URL starting for the given +url+ with +full_path+ appended as the destination path.  If +url+ contains '%s' +full_path+ will be will replace the %s using sprintf on the +url+.",
        "label": "Property",
        "id": "982"
    },
    {
        "raw_code": "def canonical_url\n    options = @store.options\n    if path\n      File.join(options.canonical_root, path.to_s)\n    else\n      options.canonical_root\n    end",
        "comment": " The preferred URL for this object.",
        "label": "What",
        "id": "983"
    },
    {
        "raw_code": "def add_line_numbers(src)\n    return unless src.sub!(/\\A(.*)(, line (\\d+))/, '\\1')\n    first = $3.to_i - 1\n    last  = first + src.count(\"\\n\")\n    size = last.to_s.length\n\n    line = first\n    src.gsub!(/^/) do\n      res = if line == first then\n              \" \" * (size + 1)\n            else\n              \"<span class=\\\"line-num\\\">%2$*1$d</span> \" % [size, line]\n            end",
        "comment": " Prepend +src+ with line numbers.  Relies on the first line of a source code listing having:  # File xxxxx, line dddd  If it has this comment then line numbers are added to +src+ and the <tt>, line dddd</tt> portion of the comment is removed.",
        "label": "How-to-use",
        "id": "984"
    },
    {
        "raw_code": "def markup_code\n    return '' unless @token_stream\n\n    src = RDoc::TokenStream.to_html @token_stream\n\n    # dedent the source\n    indent = src.length\n    lines = src.lines.to_a\n    lines.shift if src =~ /\\A.*#\\ *File/i # remove '# File' comment\n    lines.each do |line|\n      if line =~ /^ *(?=\\S)/\n        n = $~.end(0)\n        indent = n if n < indent\n        break if n == 0\n      end",
        "comment": " Turns the method's token stream into HTML.  Prepends line numbers if +options.line_numbers+ is true.",
        "label": "How-to-use",
        "id": "985"
    },
    {
        "raw_code": "def description\n    markup @comment_location\n  end",
        "comment": " Handy wrapper for marking up this class or module's comment",
        "label": "How-to-use",
        "id": "986"
    },
    {
        "raw_code": "def cvs_url\n    url = @store.options.webcvs\n\n    if /%s/ =~ url then\n      url % @relative_name\n    else\n      url + @relative_name\n    end",
        "comment": " Returns a URL for this source file on some web repository.  Use the -W command line option to set.",
        "label": "Property",
        "id": "987"
    },
    {
        "raw_code": "def initialize(store)\n    @store = store\n    @po = RDoc::Generator::POT::PO.new\n  end",
        "comment": " Creates a message extractor for +store+.",
        "label": "How-it-is-done",
        "id": "988"
    },
    {
        "raw_code": "def extract\n    @store.all_classes_and_modules.each do |klass|\n      extract_from_klass(klass)\n    end",
        "comment": " Extracts messages from +store+, stores them into RDoc::Generator::POT::PO and returns it.",
        "label": "Property",
        "id": "989"
    },
    {
        "raw_code": "def initialize\n    @entries = {}\n    add_header\n  end",
        "comment": " Creates an object that represents PO format.",
        "label": "How-it-is-done",
        "id": "990"
    },
    {
        "raw_code": "def add(entry)\n    existing_entry = @entries[entry.msgid]\n    if existing_entry\n      entry = existing_entry.merge(entry)\n    end",
        "comment": " Adds a PO entry to the PO.",
        "label": "Property",
        "id": "991"
    },
    {
        "raw_code": "def to_s\n    po = ''\n    sort_entries.each do |entry|\n      po += \"\\n\" unless po.empty?\n      po += entry.to_s\n    end",
        "comment": " Returns PO format text for the PO.",
        "label": "Property",
        "id": "992"
    },
    {
        "raw_code": "def initialize(msgid, options = {})\n    @msgid = msgid\n    @msgstr = options[:msgstr] || \"\"\n    @translator_comment = options[:translator_comment]\n    @extracted_comment = options[:extracted_comment]\n    @references = options[:references] || []\n    @flags = options[:flags] || []\n  end",
        "comment": " Creates a PO entry for +msgid+. Other values can be specified by +options+.",
        "label": "How-it-is-done",
        "id": "993"
    },
    {
        "raw_code": "def to_s\n    entry = ''\n    entry += format_translator_comment\n    entry += format_extracted_comment\n    entry += format_references\n    entry += format_flags\n    entry += <<-ENTRY\nmsgid #{format_message(@msgid)}\nmsgstr #{format_message(@msgstr)}\n    ENTRY\n  end",
        "comment": " Returns the PO entry in PO format.",
        "label": "Property",
        "id": "994"
    },
    {
        "raw_code": "def merge(other_entry)\n    options = {\n      :extracted_comment  => merge_string(@extracted_comment,\n                                          other_entry.extracted_comment),\n      :translator_comment => merge_string(@translator_comment,\n                                          other_entry.translator_comment),\n      :references         => merge_array(@references,\n                                         other_entry.references),\n      :flags              => merge_array(@flags,\n                                         other_entry.flags),\n    }\n    self.class.new(@msgid, options)\n  end",
        "comment": " Merges the PO entry with +other_entry+.",
        "label": "Others",
        "id": "995"
    },
    {
        "raw_code": "def next_token\n      raise NotImplementedError, \"#{self.class}\\#next_token is not defined\"\n    end",
        "comment": "The method to fetch next token. If you use #do_parse method, you must implement #next_token.  The format of return value is [TOKEN_SYMBOL, VALUE]. +token-symbol+ is represented by Ruby's symbol by default, e.g. :IDENT for 'IDENT'.  \";\" (String) for ';'.  The final symbol (End of file) must be false.",
        "label": "What",
        "id": "996"
    },
    {
        "raw_code": "def _racc_evalact(act, arg)\n      action_table, action_check, _, action_pointer,\n      _,            _,            _, _,\n      _,            _,            _, shift_n,\n      reduce_n,     * = arg\n      nerr = 0   # tmp\n\n      if act > 0 and act < shift_n\n        #\n        # shift\n        #\n        if @racc_error_status > 0\n          @racc_error_status -= 1 unless @racc_t <= 1 # error token or EOF\n        end",
        "comment": " common ",
        "label": "Others",
        "id": "997"
    },
    {
        "raw_code": "def on_error(t, val, vstack)\n      raise ParseError, sprintf(\"parse error on value %s (%s)\",\n                                val.inspect, token_to_str(t) || '?')\n    end",
        "comment": "This method is called when a parse error is found.  ERROR_TOKEN_ID is an internal ID of token which caused error. You can get string representation of this ID by calling #token_to_str.  ERROR_VALUE is a value of error token.  value_stack is a stack of symbol values. DO NOT MODIFY this object.  This method raises ParseError by default.  If this method returns, parsers enter \"error recovering mode\".",
        "label": "How-to-use",
        "id": "998"
    },
    {
        "raw_code": "def yyerror\n      throw :racc_jump, 1\n    end",
        "comment": "Enter error recovering mode. This method does not call #on_error.",
        "label": "How-to-use",
        "id": "999"
    },
    {
        "raw_code": "def yyaccept\n      throw :racc_jump, 2\n    end",
        "comment": "Exit parser. Return value is +Symbol_Value_Stack[0]+.",
        "label": "What",
        "id": "1000"
    },
    {
        "raw_code": "def yyerrok\n      @racc_error_status = 0\n    end",
        "comment": "Leave error recovering mode.",
        "label": "Others",
        "id": "1001"
    },
    {
        "raw_code": "def racc_read_token(t, tok, val)\n      @racc_debug_out.print 'read    '\n      @racc_debug_out.print tok.inspect, '(', racc_token2str(t), ') '\n      @racc_debug_out.puts val.inspect\n      @racc_debug_out.puts\n    end",
        "comment": "For debugging output",
        "label": "How-to-use",
        "id": "1002"
    },
    {
        "raw_code": "def token_to_str(t)\n      self.class::Racc_token_to_s_table[t]\n    end",
        "comment": "Convert internal ID of token symbol to the string.",
        "label": "How-to-use",
        "id": "1003"
    },
    {
        "raw_code": "def initialize\n  @inline_parser = RDoc::RD::InlineParser.new self\n  @include_path = []\n\n  # for testing\n  @footnotes = []\n  @labels    = {}\nend",
        "comment": " Creates a new RDoc::RD::BlockParser.  Use #parse to parse an rd-format document.",
        "label": "How-it-is-done",
        "id": "1004"
    },
    {
        "raw_code": "def parse src\n  @src = src\n  @src.push false\n\n  @footnotes = []\n  @labels    = {}\n\n  # @i: index(line no.) of src\n  @i = 0\n\n  # stack for current indentation\n  @indent_stack = []\n\n  # how indented.\n  @current_indent = @indent_stack.join(\"\")\n\n  # RDoc::RD::BlockParser for tmp src\n  @subparser = nil\n\n  # which part is in now\n  @in_part = nil\n  @part_content = []\n\n  @in_verbatim = false\n\n  @yydebug = true\n\n  document = do_parse\n\n  unless @footnotes.empty? then\n    blankline = document.parts.pop\n\n    document.parts << RDoc::Markup::Rule.new(1)\n    document.parts.concat @footnotes\n\n    document.parts.push blankline\n  end",
        "comment": " Parses +src+ and returns an RDoc::Markup::Document.",
        "label": "Property",
        "id": "1005"
    },
    {
        "raw_code": "def next_token # :nodoc:\n  # preprocessing\n  # if it is not in RD part\n  # => method\n  while @in_part != \"rd\"\n    line = @src[@i]\n    @i += 1 # next line\n\n    case line\n    # src end\n    when false\n      return [false, false]\n    # RD part begin\n    when /^=begin\\s*(?:\\bRD\\b.*)?\\s*$/\n      if @in_part # if in non-RD part\n        @part_content.push(line)\n      else\n        @in_part = \"rd\"\n        return [:WHITELINE, \"=begin\\n\"] # <= for textblockand\n      end",
        "comment": " Returns the next token from the document",
        "label": "Property",
        "id": "1006"
    },
    {
        "raw_code": "def if_current_indent_equal(indent)\n  indent = indent.sub(/\\t/, \"\\s\" * 8)\n  if @current_indent == indent\n    @i += 1 # next line\n    yield\n  elsif indent.index(@current_indent) == 0\n    @indent_stack.push(indent[@current_indent.size .. -1])\n    [:INDENT, \":INDENT\"]\n  else\n    @indent_stack.pop\n    [:DEDENT, \":DEDENT\"]\n  end",
        "comment": " Yields to the given block if +indent+ matches the current indent, otherwise an indentation token is processed.",
        "label": "How-to-use",
        "id": "1007"
    },
    {
        "raw_code": "def cut_off(src)\n  ret = []\n  whiteline_buf = []\n\n  line = src.shift\n  /^\\s*/ =~ line\n\n  indent = Regexp.quote($&)\n  ret.push($')\n\n  while line = src.shift\n    if /^(\\s*)$/ =~ line\n      whiteline_buf.push(line)\n    elsif /^#{indent}/ =~ line\n      unless whiteline_buf.empty?\n        ret.concat(whiteline_buf)\n        whiteline_buf.clear\n      end",
        "comment": " Cuts off excess whitespace in +src+",
        "label": "What",
        "id": "1008"
    },
    {
        "raw_code": "def on_error(et, ev, _values)\n  prv, cur, nxt = format_line_num(@i, @i+1, @i+2)\n\n  raise ParseError, <<Msg\n\nRD syntax error: line #{@i+1}:\n  #{prv}  |#{@src[@i-1].chomp}\n  #{cur}=>|#{@src[@i].chomp}\n  #{nxt}  |#{@src[@i+1].chomp}\n\nMsg\nend",
        "comment": " Raises a ParseError when invalid formatting is found",
        "label": "Why",
        "id": "1009"
    },
    {
        "raw_code": "def line_index\n  @i\nend",
        "comment": " Current line number",
        "label": "What",
        "id": "1010"
    },
    {
        "raw_code": "def parse_subtree src\n  @subparser ||= RDoc::RD::BlockParser.new\n\n  @subparser.parse src\nend",
        "comment": " Parses subtree +src+",
        "label": "Others",
        "id": "1011"
    },
    {
        "raw_code": "def get_included(file)\n  included = []\n\n  @include_path.each do |dir|\n    file_name = File.join dir, file\n\n    if File.exist? file_name then\n      included = File.readlines file_name\n      break\n    end",
        "comment": " Retrieves the content for +file+ from the include_path",
        "label": "What",
        "id": "1012"
    },
    {
        "raw_code": "def format_line_num(*line_numbers)\n  width = line_numbers.collect{|i| i.to_s.length }.max\n  line_numbers.collect{|i| sprintf(\"%#{width}d\", i) }\nend",
        "comment": " Formats line numbers +line_numbers+ prettily",
        "label": "How-to-use",
        "id": "1013"
    },
    {
        "raw_code": "def content values\n values.map { |value| value.content }.join\nend",
        "comment": " Retrieves the content of +values+ as a single String",
        "label": "What",
        "id": "1014"
    },
    {
        "raw_code": "def paragraph value\n  content = cut_off(value).join(' ').rstrip\n  contents = @inline_parser.parse content\n\n  RDoc::Markup::Paragraph.new(*contents)\nend",
        "comment": " Creates a paragraph for +value+",
        "label": "How-it-is-done",
        "id": "1015"
    },
    {
        "raw_code": "def add_footnote content\n  index = @footnotes.length / 2 + 1\n\n  footmark_link = \"{^#{index}}[rdoc-label:footmark-#{index}:foottext-#{index}]\"\n\n  @footnotes << RDoc::Markup::Paragraph.new(footmark_link, ' ', *content)\n  @footnotes << RDoc::Markup::BlankLine.new\n\n  index\nend",
        "comment": " Adds footnote +content+ to the document",
        "label": "Others",
        "id": "1016"
    },
    {
        "raw_code": "def add_label label\n  @labels[label] = true\n\n  label\nend",
        "comment": " Adds label +label+ to the document",
        "label": "Others",
        "id": "1017"
    },
    {
        "raw_code": "def _reduce_1(val, _values, result)\n result = RDoc::Markup::Document.new(*val[0])\n    result\nend",
        "comment": "State transition tables end ##### reduce 0 omitted",
        "label": "What",
        "id": "1018"
    },
    {
        "raw_code": "def _reduce_8(val, _values, result)\n result = val\n    result\nend",
        "comment": "reduce 7 omitted",
        "label": "What",
        "id": "1019"
    },
    {
        "raw_code": "def _reduce_27(val, _values, result)\n      result = val[0]\n\n    result\nend",
        "comment": "reduce 23 omitted reduce 24 omitted reduce 25 omitted reduce 26 omitted",
        "label": "What",
        "id": "1020"
    },
    {
        "raw_code": "def _reduce_54(val, _values, result)\n result = val\n    result\nend",
        "comment": "reduce 53 omitted",
        "label": "What",
        "id": "1021"
    },
    {
        "raw_code": "def _reduce_57(val, _values, result)\n result = []\n    result\nend",
        "comment": "reduce 56 omitted",
        "label": "What",
        "id": "1022"
    },
    {
        "raw_code": "def _reduce_62(val, _values, result)\n      result = paragraph [val[0]].concat(val[1])\n\n    result\nend",
        "comment": "reduce 58 omitted reduce 59 omitted reduce 60 omitted reduce 61 omitted",
        "label": "What",
        "id": "1023"
    },
    {
        "raw_code": "def _reduce_71(val, _values, result)\n result = []\n    result\nend",
        "comment": "reduce 70 omitted",
        "label": "What",
        "id": "1024"
    },
    {
        "raw_code": "def self.new(rdoc, reference = rdoc)\n    if self === rdoc and reference.equal? rdoc then\n      rdoc\n    else\n      super\n    end",
        "comment": " Creates a new Inline for +rdoc+ and +reference+.  +rdoc+ may be another Inline or a String.  If +reference+ is not given it will use the text from +rdoc+.",
        "label": "How-it-is-done",
        "id": "1025"
    },
    {
        "raw_code": "def initialize(rdoc, reference) # :not-new:\n    @reference = reference.equal?(rdoc) ? reference.dup : reference\n\n    # unpack\n    @reference = @reference.reference if self.class === @reference\n    @rdoc      = rdoc\n  end",
        "comment": " Initializes the Inline with +rdoc+ and +inline+",
        "label": "How-to-use",
        "id": "1026"
    },
    {
        "raw_code": "def append(more)\n    case more\n    when String then\n      @reference += more\n      @rdoc      += more\n    when RDoc::RD::Inline then\n      @reference += more.reference\n      @rdoc      += more.rdoc\n    else\n      raise \"unknown thingy #{more}\"\n    end",
        "comment": " Appends +more+ to this inline.  +more+ may be a String or another Inline.",
        "label": "Property",
        "id": "1027"
    },
    {
        "raw_code": "def next_token\n      raise NotImplementedError, \"#{self.class}\\#next_token is not defined\"\n    end",
        "comment": "The method to fetch next token. If you use #do_parse method, you must implement #next_token.  The format of return value is [TOKEN_SYMBOL, VALUE]. +token-symbol+ is represented by Ruby's symbol by default, e.g. :IDENT for 'IDENT'.  \";\" (String) for ';'.  The final symbol (End of file) must be false.",
        "label": "What",
        "id": "1028"
    },
    {
        "raw_code": "def _racc_evalact(act, arg)\n      action_table, action_check, _, action_pointer,\n      _,            _,            _, _,\n      _,            _,            _, shift_n,\n      reduce_n,     * = arg\n      nerr = 0   # tmp\n\n      if act > 0 and act < shift_n\n        #\n        # shift\n        #\n        if @racc_error_status > 0\n          @racc_error_status -= 1 unless @racc_t <= 1 # error token or EOF\n        end",
        "comment": " common ",
        "label": "Others",
        "id": "1029"
    },
    {
        "raw_code": "def on_error(t, val, vstack)\n      raise ParseError, sprintf(\"parse error on value %s (%s)\",\n                                val.inspect, token_to_str(t) || '?')\n    end",
        "comment": "This method is called when a parse error is found.  ERROR_TOKEN_ID is an internal ID of token which caused error. You can get string representation of this ID by calling #token_to_str.  ERROR_VALUE is a value of error token.  value_stack is a stack of symbol values. DO NOT MODIFY this object.  This method raises ParseError by default.  If this method returns, parsers enter \"error recovering mode\".",
        "label": "How-to-use",
        "id": "1030"
    },
    {
        "raw_code": "def yyerror\n      throw :racc_jump, 1\n    end",
        "comment": "Enter error recovering mode. This method does not call #on_error.",
        "label": "How-to-use",
        "id": "1031"
    },
    {
        "raw_code": "def yyaccept\n      throw :racc_jump, 2\n    end",
        "comment": "Exit parser. Return value is +Symbol_Value_Stack[0]+.",
        "label": "What",
        "id": "1032"
    },
    {
        "raw_code": "def yyerrok\n      @racc_error_status = 0\n    end",
        "comment": "Leave error recovering mode.",
        "label": "Others",
        "id": "1033"
    },
    {
        "raw_code": "def racc_read_token(t, tok, val)\n      @racc_debug_out.print 'read    '\n      @racc_debug_out.print tok.inspect, '(', racc_token2str(t), ') '\n      @racc_debug_out.puts val.inspect\n      @racc_debug_out.puts\n    end",
        "comment": "For debugging output",
        "label": "How-to-use",
        "id": "1034"
    },
    {
        "raw_code": "def token_to_str(t)\n      self.class::Racc_token_to_s_table[t]\n    end",
        "comment": "Convert internal ID of token symbol to the string.",
        "label": "How-to-use",
        "id": "1035"
    },
    {
        "raw_code": "def initialize block_parser\n  @block_parser = block_parser\nend",
        "comment": "{Regexp.quote(CODE_OPEN)}|#{Regexp.quote(CODE_CLOSE)}| {Regexp.quote(VAR_OPEN)}|#{Regexp.quote(VAR_CLOSE)}| {Regexp.quote(KBD_OPEN)}|#{Regexp.quote(KBD_CLOSE)}| {Regexp.quote(INDEX_OPEN)}|#{Regexp.quote(INDEX_CLOSE)}| {Regexp.quote(REF_OPEN)}|#{Regexp.quote(REF_CLOSE)}| {Regexp.quote(FOOTNOTE_OPEN)}|#{Regexp.quote(FOOTNOTE_CLOSE)}| {Regexp.quote(VERB_OPEN)}|#{Regexp.quote(VERB_CLOSE)}| {Regexp.quote(BAR)}| {Regexp.quote(QUOTE)}| {Regexp.quote(SLASH)}| {Regexp.quote(BACK_SLASH)}| {Regexp.quote(URL)})\", other_re_mode) :startdoc:  Creates a new parser for inline markup in the rd format.  The +block_parser+ is used to for footnotes and labels in the inline text.",
        "label": "How-it-is-done",
        "id": "1036"
    },
    {
        "raw_code": "def parse inline\n  @inline = inline\n  @src = StringScanner.new inline\n  @pre = \"\".dup\n  @yydebug = true\n  do_parse.to_s\nend",
        "comment": " Parses the +inline+ text from RD format into RDoc format.",
        "label": "Others",
        "id": "1037"
    },
    {
        "raw_code": "def next_token\n  return [false, false] if @src.eos?\n#  p @src.rest if @yydebug\n  if ret = @src.scan(EM_OPEN_RE)\n    @pre << ret\n    [:EM_OPEN, ret]\n  elsif ret = @src.scan(EM_CLOSE_RE)\n    @pre << ret\n    [:EM_CLOSE, ret]\n  elsif ret = @src.scan(CODE_OPEN_RE)\n    @pre << ret\n    [:CODE_OPEN, ret]\n  elsif ret = @src.scan(CODE_CLOSE_RE)\n    @pre << ret\n    [:CODE_CLOSE, ret]\n  elsif ret = @src.scan(VAR_OPEN_RE)\n    @pre << ret\n    [:VAR_OPEN, ret]\n  elsif ret = @src.scan(VAR_CLOSE_RE)\n    @pre << ret\n    [:VAR_CLOSE, ret]\n  elsif ret = @src.scan(KBD_OPEN_RE)\n    @pre << ret\n    [:KBD_OPEN, ret]\n  elsif ret = @src.scan(KBD_CLOSE_RE)\n    @pre << ret\n    [:KBD_CLOSE, ret]\n  elsif ret = @src.scan(INDEX_OPEN_RE)\n    @pre << ret\n    [:INDEX_OPEN, ret]\n  elsif ret = @src.scan(INDEX_CLOSE_RE)\n    @pre << ret\n    [:INDEX_CLOSE, ret]\n  elsif ret = @src.scan(REF_OPEN_RE)\n    @pre << ret\n    [:REF_OPEN, ret]\n  elsif ret = @src.scan(REF_CLOSE_RE)\n    @pre << ret\n    [:REF_CLOSE, ret]\n  elsif ret = @src.scan(FOOTNOTE_OPEN_RE)\n    @pre << ret\n    [:FOOTNOTE_OPEN, ret]\n  elsif ret = @src.scan(FOOTNOTE_CLOSE_RE)\n    @pre << ret\n    [:FOOTNOTE_CLOSE, ret]\n  elsif ret = @src.scan(VERB_OPEN_RE)\n    @pre << ret\n    [:VERB_OPEN, ret]\n  elsif ret = @src.scan(VERB_CLOSE_RE)\n    @pre << ret\n    [:VERB_CLOSE, ret]\n  elsif ret = @src.scan(BAR_RE)\n    @pre << ret\n    [:BAR, ret]\n  elsif ret = @src.scan(QUOTE_RE)\n    @pre << ret\n    [:QUOTE, ret]\n  elsif ret = @src.scan(SLASH_RE)\n    @pre << ret\n    [:SLASH, ret]\n  elsif ret = @src.scan(BACK_SLASH_RE)\n    @pre << ret\n    [:BACK_SLASH, ret]\n  elsif ret = @src.scan(URL_RE)\n    @pre << ret\n    [:URL, ret]\n  elsif ret = @src.scan(OTHER_RE)\n    @pre << ret\n    [:OTHER, ret]\n  else\n    ret = @src.rest\n    @pre << ret\n    @src.terminate\n    [:OTHER, ret]\n  end",
        "comment": " Returns the next token from the inline text",
        "label": "Property",
        "id": "1038"
    },
    {
        "raw_code": "def on_error(et, ev, values)\n  lines_of_rest = @src.rest.lines.to_a.length\n  prev_words = prev_words_on_error(ev)\n  at = 4 + prev_words.length\n\n  message = <<-MSG\nRD syntax error: line #{@block_parser.line_index - lines_of_rest}:\n...#{prev_words} #{(ev||'')} #{next_words_on_error()} ...\n  MSG\n\n  message << \" \" * at + \"^\" * (ev ? ev.length : 0) + \"\\n\"\n  raise ParseError, message\nend",
        "comment": " Raises a ParseError when invalid formatting is found",
        "label": "Why",
        "id": "1039"
    },
    {
        "raw_code": "def prev_words_on_error(ev)\n  pre = @pre\n  if ev and /#{Regexp.quote(ev)}$/ =~ pre\n    pre = $`\n  end",
        "comment": " Returns words before the error",
        "label": "Property",
        "id": "1040"
    },
    {
        "raw_code": "def last_line(src)\n  if n = src.rindex(\"\\n\")\n    src[(n+1) .. -1]\n  else\n    src\n  end",
        "comment": " Returns the last line of +src+",
        "label": "Property",
        "id": "1041"
    },
    {
        "raw_code": "def next_words_on_error\n  if n = @src.rest.index(\"\\n\")\n    @src.rest[0 .. (n-1)]\n  else\n    @src.rest\n  end",
        "comment": " Returns words following an error",
        "label": "Property",
        "id": "1042"
    },
    {
        "raw_code": "def inline rdoc, reference = rdoc\n  RDoc::RD::Inline.new rdoc, reference\nend",
        "comment": " Creates a new RDoc::RD::Inline for the +rdoc+ markup and the raw +reference+",
        "label": "How-it-is-done",
        "id": "1043"
    },
    {
        "raw_code": "def _reduce_2(val, _values, result)\n result.append val[1]\n    result\nend",
        "comment": "State transition tables end ##### reduce 0 omitted reduce 1 omitted",
        "label": "What",
        "id": "1044"
    },
    {
        "raw_code": "def _reduce_13(val, _values, result)\n      content = val[1]\n      result = inline \"<em>#{content}</em>\", content\n\n    result\nend",
        "comment": "reduce 4 omitted reduce 5 omitted reduce 6 omitted reduce 7 omitted reduce 8 omitted reduce 9 omitted reduce 10 omitted reduce 11 omitted reduce 12 omitted",
        "label": "What",
        "id": "1045"
    },
    {
        "raw_code": "def _reduce_29(val, _values, result)\n result = val[1]\n    result\nend",
        "comment": "reduce 28 omitted",
        "label": "What",
        "id": "1046"
    },
    {
        "raw_code": "def _reduce_36(val, _values, result)\n result = val[1]\n    result\nend",
        "comment": "reduce 35 omitted",
        "label": "What",
        "id": "1047"
    },
    {
        "raw_code": "def _reduce_43(val, _values, result)\n      result = val[0].append val[1]\n\n    result\nend",
        "comment": "reduce 42 omitted",
        "label": "What",
        "id": "1048"
    },
    {
        "raw_code": "def _reduce_57(val, _values, result)\n      result = val[0]\n\n    result\nend",
        "comment": "reduce 47 omitted reduce 48 omitted reduce 49 omitted reduce 50 omitted reduce 51 omitted reduce 52 omitted reduce 53 omitted reduce 54 omitted reduce 55 omitted reduce 56 omitted",
        "label": "What",
        "id": "1049"
    },
    {
        "raw_code": "def _reduce_62(val, _values, result)\n      result << val[1]\n\n    result\nend",
        "comment": "reduce 61 omitted",
        "label": "What",
        "id": "1050"
    },
    {
        "raw_code": "def _reduce_64(val, _values, result)\n      result << val[1]\n\n    result\nend",
        "comment": "reduce 63 omitted",
        "label": "What",
        "id": "1051"
    },
    {
        "raw_code": "def _reduce_78(val, _values, result)\n result << val[1]\n    result\nend",
        "comment": "reduce 65 omitted reduce 66 omitted reduce 67 omitted reduce 68 omitted reduce 69 omitted reduce 70 omitted reduce 71 omitted reduce 72 omitted reduce 73 omitted reduce 74 omitted reduce 75 omitted reduce 76 omitted reduce 77 omitted",
        "label": "What",
        "id": "1052"
    },
    {
        "raw_code": "def _reduce_101(val, _values, result)\n      index = @block_parser.add_footnote val[1].rdoc\n      result = \"{*#{index}}[rdoc-label:foottext-#{index}:footmark-#{index}]\"\n\n    result\nend",
        "comment": "reduce 79 omitted reduce 80 omitted reduce 81 omitted reduce 82 omitted reduce 83 omitted reduce 84 omitted reduce 85 omitted reduce 86 omitted reduce 87 omitted reduce 88 omitted reduce 89 omitted reduce 90 omitted reduce 91 omitted reduce 92 omitted reduce 93 omitted reduce 94 omitted reduce 95 omitted reduce 96 omitted reduce 97 omitted reduce 98 omitted reduce 99 omitted reduce 100 omitted",
        "label": "What",
        "id": "1053"
    },
    {
        "raw_code": "def _reduce_109(val, _values, result)\n result << val[1]\n    result\nend",
        "comment": "reduce 103 omitted reduce 104 omitted reduce 105 omitted reduce 106 omitted reduce 107 omitted reduce 108 omitted",
        "label": "What",
        "id": "1054"
    },
    {
        "raw_code": "def _reduce_111(val, _values, result)\n      result = inline val[0]\n\n    result\nend",
        "comment": "reduce 110 omitted",
        "label": "What",
        "id": "1055"
    },
    {
        "raw_code": "def _reduce_113(val, _values, result)\n result = val[1]\n    result\nend",
        "comment": "reduce 112 omitted",
        "label": "What",
        "id": "1056"
    },
    {
        "raw_code": "def _reduce_136(val, _values, result)\n result << val[1]\n    result\nend",
        "comment": "reduce 116 omitted reduce 117 omitted reduce 118 omitted reduce 119 omitted reduce 120 omitted reduce 121 omitted reduce 122 omitted reduce 123 omitted reduce 124 omitted reduce 125 omitted reduce 126 omitted reduce 127 omitted reduce 128 omitted reduce 129 omitted reduce 130 omitted reduce 131 omitted reduce 132 omitted reduce 133 omitted reduce 134 omitted reduce 135 omitted",
        "label": "What",
        "id": "1057"
    },
    {
        "raw_code": "def _reduce_none(val, _values, result)\n  val[0]\nend",
        "comment": "reduce 137 omitted",
        "label": "What",
        "id": "1058"
    },
    {
        "raw_code": "def self.each system = true, site = true, home = true, gems = :latest, *extra_dirs # :yields: directory, type\n    return enum_for __method__, system, site, home, gems, *extra_dirs unless\n      block_given?\n\n    extra_dirs.each do |dir|\n      yield dir, :extra\n    end",
        "comment": ":startdoc:  Iterates over each selected path yielding the directory and type.  Yielded types: :system:: Where Ruby's ri data is stored.  Yielded when +system+ is true :site:: Where ri for installed libraries are stored.  Yielded when +site+ is true.  Normally no ri data is stored here. :home:: ~/.rdoc.  Yielded when +home+ is true. :gem:: ri data for an installed gem.  Yielded when +gems+ is true. :extra:: ri data directory from the command line.  Yielded for each entry in +extra_dirs+",
        "label": "Property",
        "id": "1059"
    },
    {
        "raw_code": "def self.gem_dir(name, version)\n    req = Gem::Requirement.new \"= #{version}\"\n\n    spec = Gem::Specification.find_by_name name, req\n\n    File.join spec.doc_dir, 'ri'\n  end",
        "comment": " The ri directory for the gem with +gem_name+.",
        "label": "What",
        "id": "1060"
    },
    {
        "raw_code": "def self.gemdirs(filter = :latest)\n    ri_paths = {}\n\n    all = Gem::Specification.map do |spec|\n      [File.join(spec.doc_dir, 'ri'), spec.name, spec.version]\n    end",
        "comment": " The latest installed gems' ri directories.  +filter+ can be :all or :latest.  A +filter+ :all includes all versions of gems and includes gems without ri documentation.",
        "label": "Property",
        "id": "1061"
    },
    {
        "raw_code": "def self.home_dir\n    HOMEDIR\n  end",
        "comment": " The location of the rdoc data in the user's home directory.  Like ::system, ri data in the user's home directory is rare and predates libraries distributed via RubyGems.  ri data is rarely generated into this directory.",
        "label": "What",
        "id": "1062"
    },
    {
        "raw_code": "def self.path(system = true, site = true, home = true, gems = :latest, *extra_dirs)\n    path = raw_path system, site, home, gems, *extra_dirs\n\n    path.select { |directory| File.directory? directory }\n  end",
        "comment": " Returns existing directories from the selected documentation directories as an Array.  See also ::each",
        "label": "Property",
        "id": "1063"
    },
    {
        "raw_code": "def self.raw_path(system, site, home, gems, *extra_dirs)\n    path = []\n\n    each(system, site, home, gems, *extra_dirs) do |dir, type|\n      path << dir\n    end",
        "comment": " Returns selected documentation directories including nonexistent directories.  See also ::each",
        "label": "Property",
        "id": "1064"
    },
    {
        "raw_code": "def self.site_dir\n    File.join BASE, 'site'\n  end",
        "comment": " The location of ri data installed into the site dir.  Historically this was available for documentation installed by Ruby libraries predating RubyGems.  It is unlikely to contain any content for modern Ruby installations.",
        "label": "How-to-use",
        "id": "1065"
    },
    {
        "raw_code": "def self.system_dir\n    File.join BASE, 'system'\n  end",
        "comment": " The location of the built-in ri data.  This data is built automatically when `make` is run when Ruby is installed.  If you did not install Ruby by hand you may need to install the documentation yourself.  Please consult the documentation for your package manager or Ruby installer for details.  You can also use the rdoc-data gem to install system ri data for common versions of Ruby.",
        "label": "How-to-use",
        "id": "1066"
    },
    {
        "raw_code": "def initialize(name = DEFAULT_NAMES) # :yield: self\n    super\n  end",
        "comment": " Create an ri task with the given name. See RDoc::Task for documentation on setting names.",
        "label": "How-to-use",
        "id": "1067"
    },
    {
        "raw_code": "def defaults\n    super\n\n    @rdoc_dir = '.rdoc'\n  end",
        "comment": " Sets default task values",
        "label": "What",
        "id": "1068"
    },
    {
        "raw_code": "def name\n      @klass\n    end",
        "comment": " Name that wasn't found",
        "label": "What",
        "id": "1069"
    },
    {
        "raw_code": "def self.default_options\n    options = {}\n    options[:interactive] = false\n    options[:profile]     = false\n    options[:show_all]    = false\n    options[:expand_refs] = true\n    options[:use_stdout]  = !$stdout.tty?\n    options[:width]       = 72\n\n    # By default all standard paths are used.\n    options[:use_system]     = true\n    options[:use_site]       = true\n    options[:use_home]       = true\n    options[:use_gems]       = true\n    options[:extra_doc_dirs] = []\n\n    return options\n  end",
        "comment": " Default options for ri",
        "label": "Why",
        "id": "1070"
    },
    {
        "raw_code": "def self.dump(data_path)\n    require 'pp'\n\n    File.open data_path, 'rb' do |io|\n      pp Marshal.load(io.read)\n    end",
        "comment": " Dump +data_path+ using pp",
        "label": "Property",
        "id": "1071"
    },
    {
        "raw_code": "def self.process_args(argv)\n    options = default_options\n\n    opts = OptionParser.new do |opt|\n      opt.program_name = File.basename $0\n      opt.version = RDoc::VERSION\n      opt.release = nil\n      opt.summary_indent = ' ' * 4\n\n      opt.banner = <<-EOT\nUsage: #{opt.program_name} [options] [name ...]\n\nWhere name can be:\n\n  Class | Module | Module::Class\n\n  Class::method | Class#method | Class.method | method\n\n  gem_name: | gem_name:README | gem_name:History\n\n  ruby: | ruby:NEWS | ruby:globals\n\nAll class names may be abbreviated to their minimum unambiguous form.\nIf a name is ambiguous, all valid options will be listed.\n\nA '.' matches either class or instance methods, while #method\nmatches only instance and ::method matches only class methods.\n\nREADME and other files may be displayed by prefixing them with the gem name\nthey're contained in.  If the gem name is followed by a ':' all files in the\ngem will be shown.  The file name extension may be omitted where it is\nunambiguous.\n\n'ruby' can be used as a pseudo gem name to display files from the Ruby\ncore documentation. Use 'ruby:' by itself to get a list of all available\ncore documentation files.\n\nFor example:\n\n    #{opt.program_name} Fil\n    #{opt.program_name} File\n    #{opt.program_name} File.new\n    #{opt.program_name} zip\n    #{opt.program_name} rdoc:README\n    #{opt.program_name} ruby:comments\n\nNote that shell quoting or escaping may be required for method names\ncontaining punctuation:\n\n    #{opt.program_name} 'Array.[]'\n    #{opt.program_name} compact\\\\!\n\nTo see the default directories #{opt.program_name} will search, run:\n\n    #{opt.program_name} --list-doc-dirs\n\nSpecifying the --system, --site, --home, --gems, or --doc-dir options\nwill limit ri to searching only the specified directories.\n\nri options may be set in the RI environment variable.\n\nThe ri pager can be set with the RI_PAGER environment variable\nor the PAGER environment variable.\n      EOT\n\n      opt.separator nil\n      opt.separator \"Options:\"\n\n      opt.separator nil\n\n      opt.on(\"--[no-]interactive\", \"-i\",\n             \"In interactive mode you can repeatedly\",\n             \"look up methods with autocomplete.\") do |interactive|\n        options[:interactive] = interactive\n      end",
        "comment": " Parses +argv+ and returns a Hash of options",
        "label": "Property",
        "id": "1072"
    },
    {
        "raw_code": "def self.run(argv = ARGV)\n    options = process_args argv\n\n    if options[:dump_path] then\n      dump options[:dump_path]\n      return\n    end",
        "comment": " Runs the ri command line executable using +argv+",
        "label": "What",
        "id": "1073"
    },
    {
        "raw_code": "def initialize(initial_options = {})\n    @paging = false\n    @classes = nil\n\n    options = self.class.default_options.update(initial_options)\n\n    @formatter_klass = options[:formatter]\n\n    require 'profile' if options[:profile]\n\n    @names = options[:names]\n    @list = options[:list]\n\n    @doc_dirs = []\n    @stores   = []\n\n    RDoc::RI::Paths.each(options[:use_system], options[:use_site],\n                         options[:use_home], options[:use_gems],\n                         *options[:extra_doc_dirs]) do |path, type|\n      @doc_dirs << path\n\n      store = RDoc::RI::Store.new(RDoc::Options.new, path: path, type: type)\n      store.load_cache\n      @stores << store\n    end",
        "comment": " Creates a new driver using +initial_options+ from ::process_args",
        "label": "How-it-is-done",
        "id": "1074"
    },
    {
        "raw_code": "def add_also_in(out, also_in)\n    return if also_in.empty?\n\n    out << RDoc::Markup::Rule.new(1)\n    out << RDoc::Markup::Paragraph.new(\"Also found in:\")\n\n    paths = RDoc::Markup::Verbatim.new\n    also_in.each do |store|\n      paths.parts.push store.friendly_path, \"\\n\"\n    end",
        "comment": " Adds paths for undocumented classes +also_in+ to +out+",
        "label": "Others",
        "id": "1075"
    },
    {
        "raw_code": "def add_class(out, name, classes)\n    heading = if classes.all? { |klass| klass.module? } then\n                name\n              else\n                superclass = classes.map do |klass|\n                  klass.superclass unless klass.module?\n                end.compact.shift || 'Object'\n\n                superclass = superclass.full_name unless String === superclass\n\n                \"#{name} < #{superclass}\"\n              end",
        "comment": " Adds a class header to +out+ for class +name+ which is described in +classes+.",
        "label": "What",
        "id": "1076"
    },
    {
        "raw_code": "def add_from(out, store)\n    out << RDoc::Markup::Paragraph.new(\"(from #{store.friendly_path})\")\n  end",
        "comment": " Adds \"(from ...)\" to +out+ for +store+",
        "label": "Others",
        "id": "1077"
    },
    {
        "raw_code": "def add_extends(out, extends)\n    add_extension_modules out, 'Extended by', extends\n  end",
        "comment": " Adds +extends+ to +out+",
        "label": "Others",
        "id": "1078"
    },
    {
        "raw_code": "def add_extension_modules(out, type, extensions)\n    return if extensions.empty?\n\n    out << RDoc::Markup::Rule.new(1)\n    out << RDoc::Markup::Heading.new(1, \"#{type}:\")\n\n    extensions.each do |modules, store|\n      if modules.length == 1 then\n        add_extension_modules_single out, store, modules.first\n      else\n        add_extension_modules_multiple out, store, modules\n      end",
        "comment": " Adds a list of +extensions+ to this module of the given +type+ to +out+. add_includes and add_extends call this, so you should use those directly.",
        "label": "How-to-use",
        "id": "1079"
    },
    {
        "raw_code": "def add_extension_modules_multiple(out, store, modules) # :nodoc:\n    out << RDoc::Markup::Paragraph.new(\"(from #{store.friendly_path})\")\n\n    wout, with = modules.partition { |incl| incl.comment.empty? }\n\n    out << RDoc::Markup::BlankLine.new unless with.empty?\n\n    with.each do |incl|\n      out << RDoc::Markup::Paragraph.new(incl.name)\n      out << RDoc::Markup::BlankLine.new\n      out << incl.comment.parse\n    end",
        "comment": " Renders multiple included +modules+ from +store+ to +out+.",
        "label": "Others",
        "id": "1080"
    },
    {
        "raw_code": "def add_extension_modules_single(out, store, include) # :nodoc:\n    name = include.name\n    path = store.friendly_path\n    out << RDoc::Markup::Paragraph.new(\"#{name} (from #{path})\")\n\n    if include.comment then\n      out << RDoc::Markup::BlankLine.new\n      out << include.comment.parse\n    end",
        "comment": " Adds a single extension module +include+ from +store+ to +out+",
        "label": "What",
        "id": "1081"
    },
    {
        "raw_code": "def add_includes(out, includes)\n    add_extension_modules out, 'Includes', includes\n  end",
        "comment": " Adds +includes+ to +out+",
        "label": "Others",
        "id": "1082"
    },
    {
        "raw_code": "def add_method(out, name)\n    filtered = lookup_method name\n    method_document out, name, filtered\n  end",
        "comment": " Looks up the method +name+ and adds it to +out+",
        "label": "How-to-use",
        "id": "1083"
    },
    {
        "raw_code": "def add_method_documentation(out, klass)\n    klass.method_list.each do |method|\n      begin\n        add_method out, method.full_name\n      rescue NotFoundError\n        next\n      end",
        "comment": " Adds documentation for all methods in +klass+ to +out+",
        "label": "How-to-use",
        "id": "1084"
    },
    {
        "raw_code": "def add_method_list(out, methods, name)\n    return if methods.empty?\n\n    out << RDoc::Markup::Heading.new(1, \"#{name}:\")\n    out << RDoc::Markup::BlankLine.new\n\n    if @use_stdout and !@interactive then\n      out.concat methods.map { |method|\n        RDoc::Markup::Verbatim.new method\n      }\n    else\n      out << RDoc::Markup::IndentedParagraph.new(2, methods.join(', '))\n    end",
        "comment": " Adds a list of +methods+ to +out+ with a heading of +name+",
        "label": "What",
        "id": "1085"
    },
    {
        "raw_code": "def ancestors_of(klass)\n    ancestors = []\n\n    unexamined = [klass]\n    seen = []\n\n    loop do\n      break if unexamined.empty?\n      current = unexamined.shift\n      seen << current\n\n      stores = classes[current]\n\n      next unless stores and not stores.empty?\n\n      klasses = stores.flat_map do |store|\n        store.ancestors[current] || []\n      end.uniq\n\n      klasses = klasses - seen\n\n      ancestors.concat klasses\n      unexamined.concat klasses\n    end",
        "comment": " Returns ancestor classes of +klass+",
        "label": "Property",
        "id": "1086"
    },
    {
        "raw_code": "def class_cache # :nodoc:\n  end",
        "comment": " For RubyGems backwards compatibility",
        "label": "Why",
        "id": "1087"
    },
    {
        "raw_code": "def class_document(name, found, klasses, includes, extends)\n    also_in = []\n\n    out = RDoc::Markup::Document.new\n\n    add_class out, name, klasses\n\n    add_includes out, includes\n    add_extends  out, extends\n\n    found.each do |store, klass|\n      render_class out, store, klass, also_in\n    end",
        "comment": " Builds a RDoc::Markup::Document from +found+, +klasess+ and +includes+",
        "label": "What",
        "id": "1088"
    },
    {
        "raw_code": "def class_document_comment(out, document) # :nodoc:\n    unless document.empty? then\n      out << RDoc::Markup::Rule.new(1)\n\n      if document.merged? then\n        parts = document.parts\n        parts = parts.zip [RDoc::Markup::BlankLine.new] * parts.length\n        parts.flatten!\n        parts.pop\n\n        out.concat parts\n      else\n        out << comment\n      end",
        "comment": " Adds the class +comment+ to +out+.",
        "label": "Others",
        "id": "1089"
    },
    {
        "raw_code": "def class_document_constants(out, klass) # :nodoc:\n    return if klass.constants.empty?\n\n    out << RDoc::Markup::Heading.new(1, \"Constants:\")\n    out << RDoc::Markup::BlankLine.new\n    list = RDoc::Markup::List.new :NOTE\n\n    constants = klass.constants.sort_by { |constant| constant.name }\n\n    list.items.concat constants.map { |constant|\n      parts = constant.comment.parse.parts\n      parts << RDoc::Markup::Paragraph.new('[not documented]') if\n        parts.empty?\n\n      RDoc::Markup::ListItem.new(constant.name, *parts)\n    }\n\n    out << list\n    out << RDoc::Markup::BlankLine.new\n  end",
        "comment": " Adds the constants from +klass+ to the Document +out+.",
        "label": "What",
        "id": "1090"
    },
    {
        "raw_code": "def classes\n    return @classes if @classes\n\n    @classes = {}\n\n    @stores.each do |store|\n      store.cache[:modules].each do |mod|\n        # using default block causes searched-for modules to be added\n        @classes[mod] ||= []\n        @classes[mod] << store\n      end",
        "comment": " Hash mapping a known class or module to the stores it can be loaded from",
        "label": "What",
        "id": "1091"
    },
    {
        "raw_code": "def classes_and_includes_and_extends_for(name)\n    klasses = []\n    extends = []\n    includes = []\n\n    found = @stores.map do |store|\n      begin\n        klass = store.load_class name\n        klasses  << klass\n        extends  << [klass.extends,  store] if klass.extends\n        includes << [klass.includes, store] if klass.includes\n        [store, klass]\n      rescue RDoc::Store::MissingFileError\n      end",
        "comment": " Returns the stores wherein +name+ is found along with the classes, extends and includes that match it",
        "label": "Property",
        "id": "1092"
    },
    {
        "raw_code": "def complete(name)\n    completions = []\n\n    klass, selector, method = parse_name name\n\n    complete_klass  name, klass, selector, method, completions\n    complete_method name, klass, selector,         completions\n\n    completions.uniq.select {|s| s.start_with? name }.sort\n  end",
        "comment": " Completes +name+ based on the caches.  For Readline",
        "label": "What",
        "id": "1093"
    },
    {
        "raw_code": "def display(document)\n    page do |io|\n      f = formatter(io)\n      f.width = @width if @width and f.respond_to?(:width)\n      text = document.accept f\n\n      io.write text\n    end",
        "comment": " Converts +document+ to text and writes it to the pager",
        "label": "How-to-use",
        "id": "1094"
    },
    {
        "raw_code": "def display_class(name)\n    return if name =~ /#|\\./\n\n    found, klasses, includes, extends =\n      classes_and_includes_and_extends_for name\n\n    return if found.empty?\n\n    out = class_document name, found, klasses, includes, extends\n\n    display out\n  end",
        "comment": " Outputs formatted RI data for class +name+.  Groups undocumented classes",
        "label": "What",
        "id": "1095"
    },
    {
        "raw_code": "def display_method(name)\n    out = RDoc::Markup::Document.new\n\n    add_method out, name\n\n    expand_rdoc_refs_at_the_bottom(out)\n\n    display out\n  end",
        "comment": " Outputs formatted RI data for method +name+",
        "label": "What",
        "id": "1096"
    },
    {
        "raw_code": "def display_name(name)\n    if name =~ /\\w:(\\w|$)/ then\n      display_page name\n      return true\n    end",
        "comment": " Outputs formatted RI data for the class or method +name+.  Returns true if +name+ was found, false if it was not an alternative could be guessed, raises an error if +name+ couldn't be guessed.",
        "label": "Property",
        "id": "1097"
    },
    {
        "raw_code": "def display_names(names)\n    names.each do |name|\n      name = expand_name name\n\n      display_name name\n    end",
        "comment": " Displays each name in +name+",
        "label": "How-to-use",
        "id": "1098"
    },
    {
        "raw_code": "def display_page(name)\n    store_name, page_name = name.split ':', 2\n\n    store = @stores.find { |s| s.source == store_name }\n\n    return display_page_list store if page_name.empty?\n\n    pages = store.cache[:pages]\n\n    unless pages.include? page_name then\n      found_names = pages.select do |n|\n        n =~ /#{Regexp.escape page_name}\\.[^.]+$/\n      end",
        "comment": " Outputs formatted RI data for page +name+.",
        "label": "What",
        "id": "1099"
    },
    {
        "raw_code": "def display_page_list(store, pages = store.cache[:pages], search = nil)\n    out = RDoc::Markup::Document.new\n\n    title = if search then\n              \"#{search} pages\"\n            else\n              'Pages'\n            end",
        "comment": " Outputs a formatted RI page list for the pages in +store+.",
        "label": "What",
        "id": "1100"
    },
    {
        "raw_code": "def expand_class(klass)\n    class_names = classes.keys\n    ary = class_names.grep(Regexp.new(\"\\\\A#{klass.gsub(/(?=::|\\z)/, '[^:]*')}\\\\z\"))\n    if ary.length != 1 && ary.first != klass\n      if check_did_you_mean\n        suggestion_proc = -> { DidYouMean::SpellChecker.new(dictionary: class_names).correct(klass) }\n        raise NotFoundError.new(klass, suggestion_proc)\n      else\n        raise NotFoundError, klass\n      end",
        "comment": " Expands abbreviated klass +klass+ into a fully-qualified class.  \"Zl::Da\" will be expanded to Zlib::DataError.",
        "label": "What",
        "id": "1101"
    },
    {
        "raw_code": "def expand_name(name)\n    klass, selector, method = parse_name name\n\n    return [selector, method].join if klass.empty?\n\n    case selector\n    when ':' then\n      [find_store(klass),   selector, method]\n    else\n      [expand_class(klass), selector, method]\n    end.join\n  end",
        "comment": " Expands the class portion of +name+ into a fully-qualified class.  See #expand_class.",
        "label": "What",
        "id": "1102"
    },
    {
        "raw_code": "def filter_methods(found, name)\n    regexp = name_regexp name\n\n    filtered = found.find_all do |store, methods|\n      methods.any? { |method| method.full_name =~ regexp }\n    end",
        "comment": " Filters the methods in +found+ trying to find a match for +name+.",
        "label": "Why",
        "id": "1103"
    },
    {
        "raw_code": "def find_methods(name)\n    klass, selector, method = parse_name name\n\n    types = method_type selector\n\n    klasses = nil\n    ambiguous = klass.empty?\n\n    if ambiguous then\n      klasses = classes.keys\n    else\n      klasses = ancestors_of klass\n      klasses.unshift klass\n    end",
        "comment": " Yields items matching +name+ including the store they were found in, the class being searched for, the class they were found in (an ancestor) the types of methods to look up (from #method_type), and the method name being searched for",
        "label": "What",
        "id": "1104"
    },
    {
        "raw_code": "def find_store(name)\n    @stores.each do |store|\n      source = store.source\n\n      return source if source == name\n\n      return source if\n        store.type == :gem and source =~ /^#{Regexp.escape name}-\\d/\n    end",
        "comment": " Finds a store that matches +name+ which can be the name of a gem, \"ruby\", \"home\" or \"site\".  See also RDoc::Store#source",
        "label": "What",
        "id": "1105"
    },
    {
        "raw_code": "def formatter(io)\n    if @formatter_klass then\n      @formatter_klass.new\n    elsif paging? or !io.tty? then\n      RDoc::Markup::ToBs.new\n    else\n      RDoc::Markup::ToAnsi.new\n    end",
        "comment": " Creates a new RDoc::Markup::Formatter.  If a formatter is given with -f, use it.  If we're outputting to a pager, use bs, otherwise ansi.",
        "label": "How-it-is-done",
        "id": "1106"
    },
    {
        "raw_code": "def interactive\n    puts \"\\nEnter the method name you want to look up.\"\n\n    begin\n      require 'readline'\n    rescue LoadError\n    end",
        "comment": " Runs ri interactively using Readline if it is available.",
        "label": "What",
        "id": "1107"
    },
    {
        "raw_code": "def list_known_classes(names = [])\n    classes = []\n\n    stores.each do |store|\n      classes << store.module_names\n    end",
        "comment": " Lists classes known to ri starting with +names+.  If +names+ is empty all known classes are shown.",
        "label": "Others",
        "id": "1108"
    },
    {
        "raw_code": "def list_methods_matching(name)\n    found = []\n\n    find_methods name do |store, klass, ancestor, types, method|\n      if types == :instance or types == :both then\n        methods = store.instance_methods[ancestor]\n\n        if methods then\n          matches = methods.grep(/^#{Regexp.escape method.to_s}/)\n\n          matches = matches.map do |match|\n            \"#{klass}##{match}\"\n          end",
        "comment": " Returns an Array of methods matching +name+",
        "label": "Property",
        "id": "1109"
    },
    {
        "raw_code": "def load_method(store, cache, klass, type, name)\n    methods = store.public_send(cache)[klass]\n\n    return unless methods\n\n    method = methods.find do |method_name|\n      method_name == name\n    end",
        "comment": " Loads RI data for method +name+ on +klass+ from +store+.  +type+ and +cache+ indicate if it is a class or instance method.",
        "label": "Why",
        "id": "1110"
    },
    {
        "raw_code": "def load_methods_matching(name)\n    found = []\n\n    find_methods name do |store, klass, ancestor, types, method|\n      methods = []\n\n      methods << load_method(store, :class_methods, ancestor, '::',  method) if\n        [:class, :both].include? types\n\n      methods << load_method(store, :instance_methods, ancestor, '#',  method) if\n        [:instance, :both].include? types\n\n      found << [store, methods.compact]\n    end",
        "comment": " Returns an Array of RI data for methods matching +name+",
        "label": "Property",
        "id": "1111"
    },
    {
        "raw_code": "def lookup_method(name)\n    found = load_methods_matching name\n\n    if found.empty?\n      if check_did_you_mean\n        methods = []\n        _, _, method_name = parse_name name\n        find_methods name do |store, klass, ancestor, types, method|\n          methods.push(*store.class_methods[klass]) if [:class, :both].include? types\n          methods.push(*store.instance_methods[klass]) if [:instance, :both].include? types\n        end",
        "comment": " Returns a filtered list of methods matching +name+",
        "label": "Property",
        "id": "1112"
    },
    {
        "raw_code": "def method_document(out, name, filtered)\n    out << RDoc::Markup::Heading.new(1, name)\n    out << RDoc::Markup::BlankLine.new\n\n    filtered.each do |store, methods|\n      methods.each do |method|\n        render_method out, store, method, name\n      end",
        "comment": " Builds a RDoc::Markup::Document from +found+, +klasses+ and +includes+",
        "label": "What",
        "id": "1113"
    },
    {
        "raw_code": "def method_type(selector)\n    case selector\n    when '.', nil then :both\n    when '#'      then :instance\n    else               :class\n    end",
        "comment": " Returns the type of method (:both, :instance, :class) for +selector+",
        "label": "Property",
        "id": "1114"
    },
    {
        "raw_code": "def name_regexp(name)\n    klass, type, name = parse_name name\n\n    case type\n    when '#', '::' then\n      /^#{klass}#{type}#{Regexp.escape name}$/\n    else\n      /^#{klass}(#|::)#{Regexp.escape name}$/\n    end",
        "comment": " Returns a regular expression for +name+ that will match an RDoc::AnyMethod's name.",
        "label": "Property",
        "id": "1115"
    },
    {
        "raw_code": "def page\n    if pager = setup_pager then\n      begin\n        yield pager\n      ensure\n        pager.close\n      end",
        "comment": " Paginates output through a pager program.",
        "label": "Property",
        "id": "1116"
    },
    {
        "raw_code": "def paging?\n    @paging\n  end",
        "comment": " Are we using a pager?",
        "label": "What",
        "id": "1117"
    },
    {
        "raw_code": "def parse_name(name)\n    parts = name.split(/(::?|#|\\.)/)\n\n    if parts.length == 1 then\n      if parts.first =~ /^[a-z]|^([%&*+\\/<>^`|~-]|\\+@|-@|<<|<=>?|===?|=>|=~|>>|\\[\\]=?|~@)$/ then\n        type = '.'\n        meth = parts.pop\n      else\n        type = nil\n        meth = nil\n      end",
        "comment": " Extracts the class, selector and method name parts from +name+ like Foo::Bar#baz.  NOTE: Given Foo::Bar, Bar is considered a class even though it may be a method",
        "label": "What",
        "id": "1118"
    },
    {
        "raw_code": "def render_class(out, store, klass, also_in) # :nodoc:\n    document = klass.comment.parse\n    # TODO the store's cache should always return an empty Array\n    class_methods    = store.class_methods[klass.full_name]    || []\n    instance_methods = store.instance_methods[klass.full_name] || []\n    attributes       = store.attributes[klass.full_name]       || []\n\n    if document.empty? and\n       instance_methods.empty? and class_methods.empty? then\n      also_in << store\n      return\n    end",
        "comment": " Renders the +klass+ from +store+ to +out+.  If the klass has no documentable items the class is added to +also_in+ instead.",
        "label": "Others",
        "id": "1119"
    },
    {
        "raw_code": "def run\n    if @list_doc_dirs then\n      puts @doc_dirs\n    elsif @list then\n      list_known_classes @names\n    elsif @server then\n      start_server\n    elsif @interactive or @names.empty? then\n      interactive\n    else\n      display_names @names\n    end",
        "comment": " Looks up and displays ri data according to the options given.",
        "label": "What",
        "id": "1120"
    },
    {
        "raw_code": "def setup_pager\n    return if @use_stdout\n\n    pagers = [ENV['RI_PAGER'], ENV['PAGER'], 'pager', 'less', 'more']\n\n    require 'shellwords'\n    pagers.compact.uniq.each do |pager|\n      pager = Shellwords.split(pager)\n      next if pager.empty?\n\n      io = IO.popen(pager, 'w') rescue next\n      next if $? and $?.pid == io.pid and $?.exited? # pager didn't work\n\n      @paging = true\n\n      return io\n    end",
        "comment": " Sets up a pager program to pass output through.  Tries the RI_PAGER and PAGER environment variables followed by pager, less then more.",
        "label": "What",
        "id": "1121"
    },
    {
        "raw_code": "def start_server\n    begin\n      require 'webrick'\n    rescue LoadError\n      abort \"webrick is not found. You may need to `gem install webrick` to install webrick.\"\n    end",
        "comment": " Starts a WEBrick server for ri.",
        "label": "What",
        "id": "1122"
    },
    {
        "raw_code": "def initialize(raw)\n    @raw = raw\n  end",
        "comment": " Creates a new i18n supported text for +raw+ text.",
        "label": "How-it-is-done",
        "id": "1123"
    },
    {
        "raw_code": "def extract_messages\n    parse do |part|\n      case part[:type]\n      when :empty_line\n        # ignore\n      when :paragraph\n        yield(part)\n      end",
        "comment": " Extracts translation target messages and yields each message.  Each yielded message is a Hash. It consists of the followings:  :type      :: :paragraph :paragraph :: String (The translation target message itself.) :line_no   :: Integer (The line number of the :paragraph is started.)  The above content may be added in the future.",
        "label": "Property",
        "id": "1124"
    },
    {
        "raw_code": "def translate(locale)\n    translated_text = ''\n    parse do |part|\n      case part[:type]\n      when :paragraph\n        translated_text += locale.translate(part[:paragraph])\n      when :empty_line\n        translated_text += part[:line]\n      else\n        raise \"should not reach here: unexpected type: #{type}\"\n      end",
        "comment": "Translates raw text into +locale+.",
        "label": "Others",
        "id": "1125"
    },
    {
        "raw_code": "def [](locale_name)\n      @@locales[locale_name] ||= new(locale_name)\n    end",
        "comment": " Returns the locale object for +locale_name+.",
        "label": "Property",
        "id": "1126"
    },
    {
        "raw_code": "def []=(locale_name, locale)\n      @@locales[locale_name] = locale\n    end",
        "comment": " Sets the locale object for +locale_name+.  Normally, this method is not used. This method is useful for testing.",
        "label": "Property",
        "id": "1127"
    },
    {
        "raw_code": "def initialize(name)\n    @name = name\n    @messages = {}\n  end",
        "comment": " Creates a new locale object for +name+ locale. +name+ must follow IETF language tag format.",
        "label": "How-it-is-done",
        "id": "1128"
    },
    {
        "raw_code": "def load(locale_directory)\n    return false if @name.nil?\n\n    po_file_candidates = [\n      File.join(locale_directory, @name, 'rdoc.po'),\n      File.join(locale_directory, \"#{@name}.po\"),\n    ]\n    po_file = po_file_candidates.find do |po_file_candidate|\n      File.exist?(po_file_candidate)\n    end",
        "comment": " Loads translation messages from +locale_directory+/+@name+/rdoc.po or +locale_directory+/+@name+.po. The former has high priority.  This method requires gettext gem for parsing .po file. If you don't have gettext gem, this method doesn't load .po file. This method warns and returns +false+.  Returns +true+ if succeeded, +false+ otherwise.",
        "label": "How-it-is-done",
        "id": "1129"
    },
    {
        "raw_code": "def translate(message)\n    @messages[message] || message\n  end",
        "comment": " Translates the +message+ into locale. If there is no translation messages for +message+ in locale, +message+ itself is returned.",
        "label": "Others",
        "id": "1130"
    },
    {
        "raw_code": "def initialize(name, comment)\n    super()\n    @name = name.gsub(/'|\"/, \"\") #'\n    @top_level = nil\n    self.comment = comment\n  end",
        "comment": " Creates a new Require that loads +name+ with +comment+",
        "label": "How-it-is-done",
        "id": "1131"
    },
    {
        "raw_code": "def top_level\n    @top_level ||= begin\n      tl = RDoc::TopLevel.all_files_hash[name + '.rb']\n\n      if tl.nil? and RDoc::TopLevel.all_files.first.full_name =~ %r(^lib/) then\n        # second chance\n        tl = RDoc::TopLevel.all_files_hash['lib/' + name + '.rb']\n      end",
        "comment": " The RDoc::TopLevel corresponding to this require, or +nil+ if not found.",
        "label": "What",
        "id": "1132"
    },
    {
        "raw_code": "def initialize\n    super\n\n    @in_files = []\n\n    @name    ||= \"unknown\"\n    @parent  = nil\n    @visibility = :public\n\n    @current_section = Section.new self, nil, nil\n    @sections = { nil => @current_section }\n    @temporary_section = nil\n\n    @classes = {}\n    @modules = {}\n\n    initialize_methods_etc\n  end",
        "comment": " Creates an unnamed empty context with public current visibility",
        "label": "How-it-is-done",
        "id": "1133"
    },
    {
        "raw_code": "def initialize_methods_etc\n    @method_list = []\n    @attributes  = []\n    @aliases     = []\n    @requires    = []\n    @includes    = []\n    @extends     = []\n    @constants   = []\n    @external_aliases = []\n    @current_line_visibility = nil\n\n    # This Hash maps a method name to a list of unmatched aliases (aliases of\n    # a method not yet encountered).\n    @unmatched_alias_lists = {}\n\n    @methods_hash   = {}\n    @constants_hash = {}\n\n    @params = nil\n\n    @store ||= nil\n  end",
        "comment": " Sets the defaults for methods and so-forth",
        "label": "What",
        "id": "1134"
    },
    {
        "raw_code": "def <=>(other)\n    return nil unless RDoc::CodeObject === other\n\n    full_name <=> other.full_name\n  end",
        "comment": " Contexts are sorted by full_name",
        "label": "What",
        "id": "1135"
    },
    {
        "raw_code": "def add(klass, name, comment)\n    if RDoc::Extend == klass then\n      ext = RDoc::Extend.new name, comment\n      add_extend ext\n    elsif RDoc::Include == klass then\n      incl = RDoc::Include.new name, comment\n      add_include incl\n    else\n      raise NotImplementedError, \"adding a #{klass} is not implemented\"\n    end",
        "comment": " Adds an item of type +klass+ with the given +name+ and +comment+ to the context.  Currently only RDoc::Extend and RDoc::Include are supported.",
        "label": "Others",
        "id": "1136"
    },
    {
        "raw_code": "def add_alias(an_alias)\n    return an_alias unless @document_self\n\n    method_attr = find_method(an_alias.old_name, an_alias.singleton) ||\n                  find_attribute(an_alias.old_name, an_alias.singleton)\n\n    if method_attr then\n      method_attr.add_alias an_alias, self\n    else\n      add_to @external_aliases, an_alias\n      unmatched_alias_list =\n        @unmatched_alias_lists[an_alias.pretty_old_name] ||= []\n      unmatched_alias_list.push an_alias\n    end",
        "comment": " Adds +an_alias+ that is automatically resolved",
        "label": "How-to-use",
        "id": "1137"
    },
    {
        "raw_code": "def add_attribute(attribute)\n    return attribute unless @document_self\n\n    # mainly to check for redefinition of an attribute as a method\n    # TODO find a policy for 'attr_reader :foo' + 'def foo=()'\n    register = false\n\n    key = nil\n\n    if attribute.rw.index 'R' then\n      key = attribute.pretty_name\n      known = @methods_hash[key]\n\n      if known then\n        known.comment = attribute.comment if known.comment.empty?\n      elsif registered = @methods_hash[attribute.pretty_name + '='] and\n            RDoc::Attr === registered then\n        registered.rw = 'RW'\n      else\n        @methods_hash[key] = attribute\n        register = true\n      end",
        "comment": " Adds +attribute+ if not already there. If it is (as method(s) or attribute), updates the comment if it was empty.  The attribute is registered only if it defines a new method. For instance, <tt>attr_reader :foo</tt> will not be registered if method +foo+ exists, but <tt>attr_accessor :foo</tt> will be registered if method +foo+ exists, but <tt>foo=</tt> does not.",
        "label": "How-it-is-done",
        "id": "1138"
    },
    {
        "raw_code": "def add_class(class_type, given_name, superclass = '::Object')\n    # superclass +nil+ is passed by the C parser in the following cases:\n    # - registering Object in 1.8 (correct)\n    # - registering BasicObject in 1.9 (correct)\n    # - registering RubyVM in 1.9 in iseq.c (incorrect: < Object in vm.c)\n    #\n    # If we later find a superclass for a registered class with a nil\n    # superclass, we must honor it.\n\n    # find the name & enclosing context\n    if given_name =~ /^:+(\\w+)$/ then\n      full_name = $1\n      enclosing = top_level\n      name = full_name.split(/:+/).last\n    else\n      full_name = child_name given_name\n\n      if full_name =~ /^(.+)::(\\w+)$/ then\n        name = $2\n        ename = $1\n        enclosing = @store.classes_hash[ename] || @store.modules_hash[ename]\n        # HACK: crashes in actionpack/lib/action_view/helpers/form_helper.rb (metaprogramming)\n        unless enclosing then\n          # try the given name at top level (will work for the above example)\n          enclosing = @store.classes_hash[given_name] ||\n                      @store.modules_hash[given_name]\n          return enclosing if enclosing\n          # not found: create the parent(s)\n          names = ename.split('::')\n          enclosing = self\n          names.each do |n|\n            enclosing = enclosing.classes_hash[n] ||\n                        enclosing.modules_hash[n] ||\n                        enclosing.add_module(RDoc::NormalModule, n)\n          end",
        "comment": " Adds a class named +given_name+ with +superclass+.  Both +given_name+ and +superclass+ may contain '::', and are interpreted relative to the +self+ context. This allows handling correctly examples like these: class RDoc::Gauntlet < Gauntlet module Mod class Object   # implies < ::Object class SubObject < Object  # this is _not_ ::Object  Given <tt>class Container::Item</tt> RDoc assumes +Container+ is a module unless it later sees <tt>class Container</tt>.  +add_class+ automatically upgrades +given_name+ to a class in this case.",
        "label": "How-to-use",
        "id": "1139"
    },
    {
        "raw_code": "def add_class_or_module(mod, self_hash, all_hash)\n    mod.section = current_section # TODO declaring context? something is\n                                  # wrong here...\n    mod.parent = self\n    mod.full_name = nil\n    mod.store = @store\n\n    unless @done_documenting then\n      self_hash[mod.name] = mod\n      # this must be done AFTER adding mod to its parent, so that the full\n      # name is correct:\n      all_hash[mod.full_name] = mod\n      if @store.unmatched_constant_alias[mod.full_name] then\n        to, file = @store.unmatched_constant_alias[mod.full_name]\n        add_module_alias mod, mod.name, to, file\n      end",
        "comment": " Adds the class or module +mod+ to the modules or classes Hash +self_hash+, and to +all_hash+ (either <tt>TopLevel::modules_hash</tt> or <tt>TopLevel::classes_hash</tt>), unless #done_documenting is +true+. Sets the #parent of +mod+ to +self+, and its #section to #current_section. Returns +mod+.",
        "label": "Property",
        "id": "1140"
    },
    {
        "raw_code": "def add_constant(constant)\n    return constant unless @document_self\n\n    # HACK: avoid duplicate 'PI' & 'E' in math.c (1.8.7 source code)\n    # (this is a #ifdef: should be handled by the C parser)\n    known = @constants_hash[constant.name]\n\n    if known then\n      known.comment = constant.comment if known.comment.empty?\n\n      known.value = constant.value if\n        known.value.nil? or known.value.strip.empty?\n\n      known.is_alias_for ||= constant.is_alias_for\n    else\n      @constants_hash[constant.name] = constant\n      add_to @constants, constant\n    end",
        "comment": " Adds +constant+ if not already there. If it is, updates the comment, value and/or is_alias_for of the known constant if they were empty/nil.",
        "label": "What",
        "id": "1141"
    },
    {
        "raw_code": "def add_include(include)\n    add_to @includes, include\n\n    include\n  end",
        "comment": " Adds included module +include+ which should be an RDoc::Include",
        "label": "What",
        "id": "1142"
    },
    {
        "raw_code": "def add_extend(ext)\n    add_to @extends, ext\n\n    ext\n  end",
        "comment": " Adds extension module +ext+ which should be an RDoc::Extend",
        "label": "What",
        "id": "1143"
    },
    {
        "raw_code": "def add_method(method)\n    return method unless @document_self\n\n    # HACK: avoid duplicate 'new' in io.c & struct.c (1.8.7 source code)\n    key = method.pretty_name\n    known = @methods_hash[key]\n\n    if known then\n      if @store then # otherwise we are loading\n        known.comment = method.comment if known.comment.empty?\n        previously = \", previously in #{known.file}\" unless\n          method.file == known.file\n        @store.options.warn \\\n          \"Duplicate method #{known.full_name} in #{method.file}#{previously}\"\n      end",
        "comment": " Adds +method+ if not already there. If it is (as method or attribute), updates the comment if it was empty.",
        "label": "What",
        "id": "1144"
    },
    {
        "raw_code": "def add_module(class_type, name)\n    mod = @classes[name] || @modules[name]\n    return mod if mod\n\n    full_name = child_name name\n    mod = @store.modules_hash[full_name] || class_type.new(name)\n\n    add_class_or_module mod, @modules, @store.modules_hash\n  end",
        "comment": " Adds a module named +name+.  If RDoc already knows +name+ is a class then that class is returned instead.  See also #add_class.",
        "label": "What",
        "id": "1145"
    },
    {
        "raw_code": "def add_module_by_normal_module(mod)\n    add_class_or_module mod, @modules, @store.modules_hash\n  end",
        "comment": " Adds a module by +RDoc::NormalModule+ instance. See also #add_module.",
        "label": "What",
        "id": "1146"
    },
    {
        "raw_code": "def add_module_alias(from, from_name, to, file)\n    return from if @done_documenting\n\n    to_full_name = child_name to.name\n\n    # if we already know this name, don't register an alias:\n    # see the metaprogramming in lib/active_support/basic_object.rb,\n    # where we already know BasicObject is a class when we find\n    # BasicObject = BlankSlate\n    return from if @store.find_class_or_module to_full_name\n\n    unless from\n      @store.unmatched_constant_alias[child_name(from_name)] = [to, file]\n      return to\n    end",
        "comment": " Adds an alias from +from+ (a class or module) to +name+ which was defined in +file+.",
        "label": "What",
        "id": "1147"
    },
    {
        "raw_code": "def add_require(require)\n    return require unless @document_self\n\n    if RDoc::TopLevel === self then\n      add_to @requires, require\n    else\n      parent.add_require require\n    end",
        "comment": " Adds +require+ to this context's top level",
        "label": "What",
        "id": "1148"
    },
    {
        "raw_code": "def add_section(title, comment = nil)\n    if section = @sections[title] then\n      section.add_comment comment if comment\n    else\n      section = Section.new self, title, comment\n      @sections[title] = section\n    end",
        "comment": " Returns a section with +title+, creating it if it doesn't already exist. +comment+ will be appended to the section's comment.  A section with a +title+ of +nil+ will return the default section.  See also RDoc::Context::Section",
        "label": "How-it-is-done",
        "id": "1149"
    },
    {
        "raw_code": "def add_to(array, thing)\n    array << thing if @document_self\n\n    thing.parent  = self\n    thing.store   = @store if @store\n    thing.section = current_section\n  end",
        "comment": " Adds +thing+ to the collection +array+",
        "label": "What",
        "id": "1150"
    },
    {
        "raw_code": "def any_content(includes = true)\n    @any_content ||= !(\n      @comment.empty? &&\n      @method_list.empty? &&\n      @attributes.empty? &&\n      @aliases.empty? &&\n      @external_aliases.empty? &&\n      @requires.empty? &&\n      @constants.empty?\n    )\n    @any_content || (includes && !(@includes + @extends).empty? )\n  end",
        "comment": " Is there any content?  This means any of: comment, aliases, methods, attributes, external aliases, require, constant.  Includes and extends are also checked unless <tt>includes == false</tt>.",
        "label": "What",
        "id": "1151"
    },
    {
        "raw_code": "def child_name(name)\n    if name =~ /^:+/\n      $'  #'\n    elsif RDoc::TopLevel === self then\n      name\n    else\n      \"#{self.full_name}::#{name}\"\n    end",
        "comment": " Creates the full name for a child with +name+",
        "label": "How-it-is-done",
        "id": "1152"
    },
    {
        "raw_code": "def class_attributes\n    @class_attributes ||= attributes.select { |a| a.singleton }\n  end",
        "comment": " Class attributes",
        "label": "Property",
        "id": "1153"
    },
    {
        "raw_code": "def class_method_list\n    @class_method_list ||= method_list.select { |a| a.singleton }\n  end",
        "comment": " Class methods",
        "label": "Property",
        "id": "1154"
    },
    {
        "raw_code": "def classes\n    @classes.values\n  end",
        "comment": " Array of classes in this context",
        "label": "Others",
        "id": "1155"
    },
    {
        "raw_code": "def classes_and_modules\n    classes + modules\n  end",
        "comment": " All classes and modules in this namespace",
        "label": "What",
        "id": "1156"
    },
    {
        "raw_code": "def classes_hash\n    @classes\n  end",
        "comment": " Hash of classes keyed by class name",
        "label": "Property",
        "id": "1157"
    },
    {
        "raw_code": "def current_section\n    if section = @temporary_section then\n      @temporary_section = nil\n    else\n      section = @current_section\n    end",
        "comment": " The current documentation section that new items will be added to.  If temporary_section is available it will be used.",
        "label": "What",
        "id": "1158"
    },
    {
        "raw_code": "def each_ancestor(&_) # :nodoc:\n  end",
        "comment": " Iterator for ancestors for duck-typing.  Does nothing.  See RDoc::ClassModule#each_ancestor.  This method exists to make it easy to work with Context subclasses that aren't part of RDoc.",
        "label": "How-it-is-done",
        "id": "1159"
    },
    {
        "raw_code": "def each_classmodule(&block) # :yields: module\n    classes_and_modules.sort.each(&block)\n  end",
        "comment": " Iterator for classes and modules",
        "label": "How-to-use",
        "id": "1160"
    },
    {
        "raw_code": "def each_method # :yields: method\n    return enum_for __method__ unless block_given?\n\n    @method_list.sort.each { |m| yield m }\n  end",
        "comment": " Iterator for methods",
        "label": "How-to-use",
        "id": "1161"
    },
    {
        "raw_code": "def each_section # :yields: section, constants, attributes\n    return enum_for __method__ unless block_given?\n\n    constants  = @constants.group_by  do |constant|  constant.section end\n    attributes = @attributes.group_by do |attribute| attribute.section end\n\n    constants.default  = []\n    attributes.default = []\n\n    sort_sections.each do |section|\n      yield section, constants[section].select(&:display?).sort, attributes[section].select(&:display?).sort\n    end",
        "comment": " Iterator for each section's contents sorted by title.  The +section+, the section's +constants+ and the sections +attributes+ are yielded.  The +constants+ and +attributes+ collections are sorted.  To retrieve methods in a section use #methods_by_type with the optional +section+ parameter.  NOTE: Do not edit collections yielded by this method",
        "label": "How-to-use",
        "id": "1162"
    },
    {
        "raw_code": "def find_attribute(name, singleton)\n    name = $1 if name =~ /^(.*)=$/\n    @attributes.find { |a| a.name == name && a.singleton == singleton }\n  end",
        "comment": " Finds an attribute +name+ with singleton value +singleton+.",
        "label": "What",
        "id": "1163"
    },
    {
        "raw_code": "def find_attribute_named(name)\n    case name\n    when /\\A#/ then\n      find_attribute name[1..-1], false\n    when /\\A::/ then\n      find_attribute name[2..-1], true\n    else\n      @attributes.find { |a| a.name == name }\n    end",
        "comment": " Finds an attribute with +name+ in this context",
        "label": "What",
        "id": "1164"
    },
    {
        "raw_code": "def find_class_method_named(name)\n    @method_list.find { |meth| meth.singleton && meth.name == name }\n  end",
        "comment": " Finds a class method with +name+ in this context",
        "label": "What",
        "id": "1165"
    },
    {
        "raw_code": "def find_constant_named(name)\n    @constants.find do |m|\n      m.name == name || m.full_name == name\n    end",
        "comment": " Finds a constant with +name+ in this context",
        "label": "What",
        "id": "1166"
    },
    {
        "raw_code": "def find_enclosing_module_named(name)\n    parent && parent.find_module_named(name)\n  end",
        "comment": " Find a module at a higher scope",
        "label": "What",
        "id": "1167"
    },
    {
        "raw_code": "def find_external_alias(name, singleton)\n    @external_aliases.find { |m| m.name == name && m.singleton == singleton }\n  end",
        "comment": " Finds an external alias +name+ with singleton value +singleton+.",
        "label": "What",
        "id": "1168"
    },
    {
        "raw_code": "def find_external_alias_named(name)\n    case name\n    when /\\A#/ then\n      find_external_alias name[1..-1], false\n    when /\\A::/ then\n      find_external_alias name[2..-1], true\n    else\n      @external_aliases.find { |a| a.name == name }\n    end",
        "comment": " Finds an external alias with +name+ in this context",
        "label": "What",
        "id": "1169"
    },
    {
        "raw_code": "def find_instance_method_named(name)\n    @method_list.find { |meth| !meth.singleton && meth.name == name }\n  end",
        "comment": " Finds an instance method with +name+ in this context",
        "label": "What",
        "id": "1170"
    },
    {
        "raw_code": "def find_local_symbol(symbol)\n    find_method_named(symbol) or\n    find_constant_named(symbol) or\n    find_attribute_named(symbol) or\n    find_external_alias_named(symbol) or\n    find_module_named(symbol) or\n    @store.find_file_named(symbol)\n  end",
        "comment": " Finds a method, constant, attribute, external alias, module or file named +symbol+ in this context.",
        "label": "What",
        "id": "1171"
    },
    {
        "raw_code": "def find_method(name, singleton)\n    @method_list.find { |m|\n      if m.singleton\n        m.name == name && m.singleton == singleton\n      else\n        m.name == name && !m.singleton && !singleton\n      end",
        "comment": " Finds a method named +name+ with singleton value +singleton+.",
        "label": "What",
        "id": "1172"
    },
    {
        "raw_code": "def find_method_named(name)\n    case name\n    when /\\A#/ then\n      find_method name[1..-1], false\n    when /\\A::/ then\n      find_method name[2..-1], true\n    else\n      @method_list.find { |meth| meth.name == name }\n    end",
        "comment": " Finds a instance or module method with +name+ in this context",
        "label": "What",
        "id": "1173"
    },
    {
        "raw_code": "def find_module_named(name)\n    res = @modules[name] || @classes[name]\n    return res if res\n    return self if self.name == name\n    find_enclosing_module_named name\n  end",
        "comment": " Find a module with +name+ using ruby's scoping rules",
        "label": "How-to-use",
        "id": "1174"
    },
    {
        "raw_code": "def find_symbol(symbol)\n    find_symbol_module(symbol) || find_local_symbol(symbol)\n  end",
        "comment": " Look up +symbol+, first as a module, then as a local symbol.",
        "label": "How-to-use",
        "id": "1175"
    },
    {
        "raw_code": "def find_symbol_module(symbol)\n    result = nil\n\n    # look for a class or module 'symbol'\n    case symbol\n    when /^::/ then\n      result = @store.find_class_or_module symbol\n    when /^(\\w+):+(.+)$/\n      suffix = $2\n      top = $1\n      searched = self\n      while searched do\n        mod = searched.find_module_named(top)\n        break unless mod\n        result = @store.find_class_or_module \"#{mod.full_name}::#{suffix}\"\n        break if result || searched.is_a?(RDoc::TopLevel)\n        searched = searched.parent\n      end",
        "comment": " Look up a module named +symbol+.",
        "label": "How-to-use",
        "id": "1176"
    },
    {
        "raw_code": "def full_name\n    '(unknown)'\n  end",
        "comment": " The full name for this context.  This method is overridden by subclasses.",
        "label": "What",
        "id": "1177"
    },
    {
        "raw_code": "def fully_documented?\n    documented? and\n      attributes.all? { |a| a.documented? } and\n      method_list.all? { |m| m.documented? } and\n      constants.all? { |c| c.documented? }\n  end",
        "comment": " Does this context and its methods and constants all have documentation?  (Yes, fully documented doesn't mean everything.)",
        "label": "How-it-is-done",
        "id": "1178"
    },
    {
        "raw_code": "def http_url\n    path = name_for_path\n    path = path.gsub(/<<\\s*(\\w*)/, 'from-\\1') if path =~ /<</\n    path = path.split('::')\n\n    File.join(*path.compact) + '.html'\n  end",
        "comment": " URL for this with a +prefix+",
        "label": "What",
        "id": "1179"
    },
    {
        "raw_code": "def instance_attributes\n    @instance_attributes ||= attributes.reject { |a| a.singleton }\n  end",
        "comment": " Instance attributes",
        "label": "What",
        "id": "1180"
    },
    {
        "raw_code": "def instance_methods\n    @instance_methods ||= method_list.reject { |a| a.singleton }\n  end",
        "comment": " Instance methods",
        "label": "What",
        "id": "1181"
    },
    {
        "raw_code": "def instance_method_list\n    warn '#instance_method_list is obsoleted, please use #instance_methods'\n    @instance_methods ||= method_list.reject { |a| a.singleton }\n  end",
        "comment": " Instance methods -- TODO remove this later",
        "label": "How-to-use",
        "id": "1182"
    },
    {
        "raw_code": "def methods_by_type(section = nil)\n    methods = {}\n\n    TYPES.each do |type|\n      visibilities = {}\n      RDoc::VISIBILITIES.each do |vis|\n        visibilities[vis] = []\n      end",
        "comment": " Breaks method_list into a nested hash by type (<tt>'class'</tt> or <tt>'instance'</tt>) and visibility (+:public+, +:protected+, +:private+).  If +section+ is provided only methods in that RDoc::Context::Section will be returned.",
        "label": "What",
        "id": "1183"
    },
    {
        "raw_code": "def methods_matching(methods, singleton = false, &block)\n    (@method_list + @attributes).each do |m|\n      yield m if methods.include?(m.name) and m.singleton == singleton\n    end",
        "comment": " Yields AnyMethod and Attr entries matching the list of names in +methods+.",
        "label": "How-to-use",
        "id": "1184"
    },
    {
        "raw_code": "def modules\n    @modules.values\n  end",
        "comment": " Array of modules in this context",
        "label": "Others",
        "id": "1185"
    },
    {
        "raw_code": "def modules_hash\n    @modules\n  end",
        "comment": " Hash of modules keyed by module name",
        "label": "Others",
        "id": "1186"
    },
    {
        "raw_code": "def name_for_path\n    full_name\n  end",
        "comment": " Name to use to generate the url. <tt>#full_name</tt> by default.",
        "label": "What",
        "id": "1187"
    },
    {
        "raw_code": "def ongoing_visibility=(visibility)\n    @visibility = visibility\n  end",
        "comment": " Changes the visibility for new methods to +visibility+",
        "label": "What",
        "id": "1188"
    },
    {
        "raw_code": "def record_location(top_level)\n    @in_files << top_level unless @in_files.include?(top_level)\n  end",
        "comment": " Record +top_level+ as a file +self+ is in.",
        "label": "What",
        "id": "1189"
    },
    {
        "raw_code": "def remove_from_documentation?\n    @remove_from_documentation ||=\n      @received_nodoc &&\n      !any_content(false) &&\n      @includes.all? { |i| !i.module.is_a?(String) && i.module.remove_from_documentation? } &&\n      classes_and_modules.all? { |cm| cm.remove_from_documentation? }\n  end",
        "comment": " Should we remove this context from the documentation?  The answer is yes if: * #received_nodoc is +true+ * #any_content is +false+ (not counting includes) * All #includes are modules (not a string), and their module has <tt>#remove_from_documentation? == true</tt> * All classes and modules have <tt>#remove_from_documentation? == true</tt>",
        "label": "What",
        "id": "1190"
    },
    {
        "raw_code": "def remove_invisible(min_visibility)\n    return if [:private, :nodoc].include? min_visibility\n    remove_invisible_in @method_list, min_visibility\n    remove_invisible_in @attributes, min_visibility\n    remove_invisible_in @constants, min_visibility\n  end",
        "comment": " Removes methods and attributes with a visibility less than +min_visibility+. -- TODO mark the visibility of attributes in the template (if not public?)",
        "label": "How-to-use",
        "id": "1191"
    },
    {
        "raw_code": "def remove_invisible_in(array, min_visibility) # :nodoc:\n    if min_visibility == :public then\n      array.reject! { |e|\n        e.visibility != :public and not e.force_documentation\n      }\n    else\n      array.reject! { |e|\n        e.visibility == :private and not e.force_documentation\n      }\n    end",
        "comment": " Only called when min_visibility == :public or :private",
        "label": "How-to-use",
        "id": "1192"
    },
    {
        "raw_code": "def resolve_aliases(added)\n    # resolve any pending unmatched aliases\n    key = added.pretty_name\n    unmatched_alias_list = @unmatched_alias_lists[key]\n    return unless unmatched_alias_list\n    unmatched_alias_list.each do |unmatched_alias|\n      added.add_alias unmatched_alias, self\n      @external_aliases.delete unmatched_alias\n    end",
        "comment": " Tries to resolve unmatched aliases when a method or attribute has just been added.",
        "label": "Others",
        "id": "1193"
    },
    {
        "raw_code": "def section_contents\n    used_sections = {}\n\n    each_method do |method|\n      next unless method.display?\n\n      used_sections[method.section] = true\n    end",
        "comment": " Returns RDoc::Context::Section objects referenced in this context for use in a table of contents.",
        "label": "Property",
        "id": "1194"
    },
    {
        "raw_code": "def sections\n    @sections.values\n  end",
        "comment": " Sections in this context",
        "label": "Others",
        "id": "1195"
    },
    {
        "raw_code": "def set_current_section(title, comment)\n    @current_section = add_section title, comment\n  end",
        "comment": " Sets the current section to a section with +title+.  See also #add_section",
        "label": "What",
        "id": "1196"
    },
    {
        "raw_code": "def set_visibility_for(methods, visibility, singleton = false)\n    methods_matching methods, singleton do |m|\n      m.visibility = visibility\n    end",
        "comment": " Given an array +methods+ of method names, set the visibility of each to +visibility+",
        "label": "How-to-use",
        "id": "1197"
    },
    {
        "raw_code": "def set_constant_visibility_for(names, visibility)\n    names.each do |name|\n      constant = @constants_hash[name] or next\n      constant.visibility = visibility\n    end",
        "comment": " Given an array +names+ of constants, set the visibility of each constant to +visibility+",
        "label": "How-to-use",
        "id": "1198"
    },
    {
        "raw_code": "def sort_sections\n    titles = @sections.map { |title, _| title }\n\n    if titles.length > 1 and\n       TOMDOC_TITLES_SORT ==\n         (titles | TOMDOC_TITLES).sort_by { |title| title.to_s } then\n      @sections.values_at(*TOMDOC_TITLES).compact\n    else\n      @sections.sort_by { |title, _|\n        title.to_s\n      }.map { |_, section|\n        section\n      }\n    end",
        "comment": " Sorts sections alphabetically (default) or in TomDoc fashion (none, Public, Internal, Deprecated)",
        "label": "How-to-use",
        "id": "1199"
    },
    {
        "raw_code": "def top_level\n    return @top_level if defined? @top_level\n    @top_level = self\n    @top_level = @top_level.parent until RDoc::TopLevel === @top_level\n    @top_level\n  end",
        "comment": " Return the TopLevel that owns us -- FIXME we can be 'owned' by several TopLevel (see #record_location & #in_files)",
        "label": "What",
        "id": "1200"
    },
    {
        "raw_code": "def upgrade_to_class(mod, class_type, enclosing)\n    enclosing.modules_hash.delete mod.name\n\n    klass = RDoc::ClassModule.from_module class_type, mod\n    klass.store = @store\n\n    # if it was there, then we keep it even if done_documenting\n    @store.classes_hash[mod.full_name] = klass\n    enclosing.classes_hash[mod.name]   = klass\n\n    klass\n  end",
        "comment": " Upgrades NormalModule +mod+ in +enclosing+ to a +class_type+",
        "label": "What",
        "id": "1201"
    },
    {
        "raw_code": "def initialize(text, name, rw, comment, singleton: false)\n    super(text, name, singleton: singleton)\n\n    @rw = rw\n    self.comment = comment\n  end",
        "comment": " Creates a new Attr with body +text+, +name+, read/write status +rw+ and +comment+.  +singleton+ marks this as a class attribute.",
        "label": "How-it-is-done",
        "id": "1202"
    },
    {
        "raw_code": "def ==(other)\n    self.class == other.class and\n      self.name == other.name and\n      self.rw == other.rw and\n      self.singleton == other.singleton\n  end",
        "comment": " Attributes are equal when their names, singleton and rw are identical",
        "label": "What",
        "id": "1203"
    },
    {
        "raw_code": "def add_alias(an_alias, context)\n    new_attr = self.class.new(text, an_alias.new_name, rw, comment, singleton: singleton)\n    new_attr.record_location an_alias.file\n    new_attr.visibility = self.visibility\n    new_attr.is_alias_for = self\n    @aliases << new_attr\n    context.add_attribute new_attr\n    new_attr\n  end",
        "comment": " Add +an_alias+ as an attribute in +context+.",
        "label": "What",
        "id": "1204"
    },
    {
        "raw_code": "def aref_prefix\n    'attribute'\n  end",
        "comment": " The #aref prefix for attributes",
        "label": "Others",
        "id": "1205"
    },
    {
        "raw_code": "def calls_super # :nodoc:\n    false\n  end",
        "comment": " Attributes never call super.  See RDoc::AnyMethod#calls_super  An RDoc::Attr can show up in the method list in some situations (see Gem::ConfigFile)",
        "label": "How-to-use",
        "id": "1206"
    },
    {
        "raw_code": "def definition\n    case @rw\n    when 'RW' then 'attr_accessor'\n    when 'R'  then 'attr_reader'\n    when 'W'  then 'attr_writer'\n    end",
        "comment": " Returns attr_reader, attr_writer or attr_accessor as appropriate.",
        "label": "Property",
        "id": "1207"
    },
    {
        "raw_code": "def marshal_dump\n    [ MARSHAL_VERSION,\n      @name,\n      full_name,\n      @rw,\n      @visibility,\n      parse(@comment),\n      singleton,\n      @file.relative_name,\n      @parent.full_name,\n      @parent.class,\n      @section.title\n    ]\n  end",
        "comment": " Dumps this Attr for use by ri.  See also #marshal_load",
        "label": "What",
        "id": "1208"
    },
    {
        "raw_code": "def marshal_load(array)\n    initialize_visibility\n\n    @aliases      = []\n    @parent       = nil\n    @parent_name  = nil\n    @parent_class = nil\n    @section      = nil\n    @file         = nil\n\n    version        = array[0]\n    @name          = array[1]\n    @full_name     = array[2]\n    @rw            = array[3]\n    @visibility    = array[4]\n    @comment       = RDoc::Comment.from_document array[5]\n    @singleton     = array[6] || false # MARSHAL_VERSION == 0\n    #                      7 handled below\n    @parent_name   = array[8]\n    @parent_class  = array[9]\n    @section_title = array[10]\n\n    @file = RDoc::TopLevel.new array[7] if version > 1\n\n    @parent_name ||= @full_name.split('#', 2).first\n  end",
        "comment": " Loads this Attr from +array+.  For a loaded Attr the following methods will return cached values:  * #full_name * #parent_name",
        "label": "What",
        "id": "1209"
    },
    {
        "raw_code": "def token_stream # :nodoc:\n  end",
        "comment": " Attributes do not have token streams.  An RDoc::Attr can show up in the method list in some situations (see Gem::ConfigFile)",
        "label": "Property",
        "id": "1210"
    },
    {
        "raw_code": "def ancestors\n    if String === superclass then\n      super << superclass\n    elsif superclass then\n      ancestors = super\n      ancestors << superclass\n      ancestors.concat superclass.ancestors\n    else\n      super\n    end",
        "comment": " The ancestors of this class including modules.  Unlike Module#ancestors, this class is not included in the result.  The result will contain both RDoc::ClassModules and Strings.",
        "label": "What",
        "id": "1211"
    },
    {
        "raw_code": "def definition\n    \"class #{full_name}\"\n  end",
        "comment": " The definition of this class, <tt>class MyClassName</tt>",
        "label": "What",
        "id": "1212"
    },
    {
        "raw_code": "def initialize(absolute_name, relative_name = absolute_name)\n    super()\n    @name = nil\n    @absolute_name = absolute_name\n    @relative_name = relative_name\n    @parser        = nil\n\n    @classes_or_modules = []\n  end",
        "comment": " Creates a new TopLevel for the file at +absolute_name+.  If documentation is being generated outside the source dir +relative_name+ is relative to the source directory.",
        "label": "How-it-is-done",
        "id": "1213"
    },
    {
        "raw_code": "def parser=(val)\n    @parser = val\n    @store.update_parser_of_file(absolute_name, val) if @store\n    @parser\n  end",
        "comment": " Sets the parser for this toplevel context, also the store.",
        "label": "Others",
        "id": "1214"
    },
    {
        "raw_code": "def ==(other)\n    self.class === other and @relative_name == other.relative_name\n  end",
        "comment": " An RDoc::TopLevel is equal to another with the same relative_name",
        "label": "Property",
        "id": "1215"
    },
    {
        "raw_code": "def add_alias(an_alias)\n    object_class.record_location self\n    return an_alias unless @document_self\n    object_class.add_alias an_alias\n  end",
        "comment": " Adds +an_alias+ to +Object+ instead of +self+.",
        "label": "Others",
        "id": "1216"
    },
    {
        "raw_code": "def add_constant(constant)\n    object_class.record_location self\n    return constant unless @document_self\n    object_class.add_constant constant\n  end",
        "comment": " Adds +constant+ to +Object+ instead of +self+.",
        "label": "Others",
        "id": "1217"
    },
    {
        "raw_code": "def add_include(include)\n    object_class.record_location self\n    return include unless @document_self\n    object_class.add_include include\n  end",
        "comment": " Adds +include+ to +Object+ instead of +self+.",
        "label": "Others",
        "id": "1218"
    },
    {
        "raw_code": "def add_method(method)\n    object_class.record_location self\n    return method unless @document_self\n    object_class.add_method method\n  end",
        "comment": " Adds +method+ to +Object+ instead of +self+.",
        "label": "Others",
        "id": "1219"
    },
    {
        "raw_code": "def add_to_classes_or_modules(mod)\n    @classes_or_modules << mod\n  end",
        "comment": " Adds class or module +mod+. Used in the building phase by the Ruby parser.",
        "label": "Others",
        "id": "1220"
    },
    {
        "raw_code": "def base_name\n    File.basename @relative_name\n  end",
        "comment": " Base name of this file",
        "label": "What",
        "id": "1221"
    },
    {
        "raw_code": "def find_class_or_module(name)\n    @store.find_class_or_module name\n  end",
        "comment": " See RDoc::TopLevel::find_class_or_module -- TODO Why do we search through all classes/modules found, not just the ones of this instance?",
        "label": "Why",
        "id": "1222"
    },
    {
        "raw_code": "def find_local_symbol(symbol)\n    find_class_or_module(symbol) || super\n  end",
        "comment": " Finds a class or module named +symbol+",
        "label": "What",
        "id": "1223"
    },
    {
        "raw_code": "def find_module_named(name)\n    find_class_or_module(name)\n  end",
        "comment": " Finds a module or class with +name+",
        "label": "What",
        "id": "1224"
    },
    {
        "raw_code": "def full_name\n    @relative_name\n  end",
        "comment": " Returns the relative name of this file",
        "label": "Property",
        "id": "1225"
    },
    {
        "raw_code": "def hash\n    @relative_name.hash\n  end",
        "comment": " An RDoc::TopLevel has the same hash as another with the same relative_name",
        "label": "Property",
        "id": "1226"
    },
    {
        "raw_code": "def http_url\n    @relative_name.tr('.', '_') + '.html'\n  end",
        "comment": " URL for this with a +prefix+",
        "label": "What",
        "id": "1227"
    },
    {
        "raw_code": "def marshal_dump\n    [\n      MARSHAL_VERSION,\n      @relative_name,\n      @parser,\n      parse(@comment),\n    ]\n  end",
        "comment": " Dumps this TopLevel for use by ri.  See also #marshal_load",
        "label": "What",
        "id": "1228"
    },
    {
        "raw_code": "def marshal_load(array) # :nodoc:\n    initialize array[1]\n\n    @parser  = array[2]\n    @comment = RDoc::Comment.from_document array[3]\n  end",
        "comment": " Loads this TopLevel from +array+.",
        "label": "What",
        "id": "1229"
    },
    {
        "raw_code": "def object_class\n    @object_class ||= begin\n      oc = @store.find_class_named('Object') || add_class(RDoc::NormalClass, 'Object')\n      oc.record_location self\n      oc\n    end",
        "comment": " Returns the NormalClass \"Object\", creating it if not found.  Records +self+ as a location in \"Object\".",
        "label": "Property",
        "id": "1230"
    },
    {
        "raw_code": "def page_name\n    basename = File.basename @relative_name\n    basename =~ /\\.(rb|rdoc|txt|md)$/i\n\n    $` || basename\n  end",
        "comment": " Base name of this file without the extension",
        "label": "What",
        "id": "1231"
    },
    {
        "raw_code": "def path\n    prefix = options.file_path_prefix\n    return http_url unless prefix\n    File.join(prefix, http_url)\n  end",
        "comment": " Path to this file for use with HTML generator output.",
        "label": "How-to-use",
        "id": "1232"
    },
    {
        "raw_code": "def search_record\n    return unless @parser < RDoc::Parser::Text\n\n    [\n      page_name,\n      '',\n      page_name,\n      '',\n      path,\n      '',\n      snippet(@comment),\n    ]\n  end",
        "comment": " Search record used by RDoc::Generator::JsonIndex",
        "label": "Property",
        "id": "1233"
    },
    {
        "raw_code": "def text?\n    @parser and @parser.include? RDoc::Parser::Text\n  end",
        "comment": " Is this TopLevel from a text file instead of a source code file?",
        "label": "What",
        "id": "1234"
    },
    {
        "raw_code": "def self.from_module(class_type, mod)\n    klass = class_type.new mod.name\n\n    mod.comment_location.each do |comment, location|\n      klass.add_comment comment, location\n    end",
        "comment": " Return a RDoc::ClassModule of class +class_type+ that is a copy of module +module+. Used to promote modules to classes. -- TODO move to RDoc::NormalClass (I think)",
        "label": "How-to-use",
        "id": "1235"
    },
    {
        "raw_code": "def initialize(name, superclass = nil)\n    @constant_aliases = []\n    @is_alias_for     = nil\n    @name             = name\n    @superclass       = superclass\n    @comment_location = [] # [[comment, location]]\n\n    super()\n  end",
        "comment": " Creates a new ClassModule with +name+ with optional +superclass+  This is a constructor for subclasses, and must never be called directly.",
        "label": "How-to-use",
        "id": "1236"
    },
    {
        "raw_code": "def add_comment(comment, location)\n    return unless document_self\n\n    original = comment\n\n    comment = case comment\n              when RDoc::Comment then\n                comment.normalize\n              else\n                normalize_comment comment\n              end",
        "comment": " Adds +comment+ to this ClassModule's list of comments at +location+.  This method is preferred over #comment= since it allows ri data to be updated across multiple runs.",
        "label": "How-to-use",
        "id": "1237"
    },
    {
        "raw_code": "def ancestors\n    includes.map { |i| i.module }.reverse\n  end",
        "comment": " Ancestors list for this ClassModule: the list of included modules (classes will add their superclass if any).  Returns the included classes or modules, not the includes themselves. The returned values are either String or RDoc::NormalModule instances (see RDoc::Include#module).  The values are returned in reverse order of their inclusion, which is the order suitable for searching methods/attributes in the ancestors. The superclass, if any, comes last.",
        "label": "Property",
        "id": "1238"
    },
    {
        "raw_code": "def aref\n    \"#{aref_prefix}-#{full_name}\"\n  end",
        "comment": " HTML fragment reference for this module or class.  See RDoc::NormalClass#aref and RDoc::NormalModule#aref",
        "label": "How-to-use",
        "id": "1239"
    },
    {
        "raw_code": "def clear_comment\n    @comment = ''\n  end",
        "comment": " Clears the comment. Used by the Ruby parser.",
        "label": "What",
        "id": "1240"
    },
    {
        "raw_code": "def comment=(comment) # :nodoc:\n    comment = case comment\n              when RDoc::Comment then\n                comment.normalize\n              else\n                normalize_comment comment\n              end",
        "comment": " This method is deprecated, use #add_comment instead.  Appends +comment+ to the current comment, but separated by a rule.  Works more like <tt>+=</tt>.",
        "label": "Property",
        "id": "1241"
    },
    {
        "raw_code": "def complete(min_visibility)\n    update_aliases\n    remove_nodoc_children\n    embed_mixins\n    update_includes\n    update_extends\n    remove_invisible min_visibility\n  end",
        "comment": " Prepares this ClassModule for use by a generator.  See RDoc::Store#complete",
        "label": "How-to-use",
        "id": "1242"
    },
    {
        "raw_code": "def document_self_or_methods\n    document_self || method_list.any?{ |m| m.document_self }\n  end",
        "comment": " Does this ClassModule or any of its methods have document_self set?",
        "label": "How-it-is-done",
        "id": "1243"
    },
    {
        "raw_code": "def documented?\n    return true if @received_nodoc\n    return false if @comment_location.empty?\n    @comment_location.any? { |comment, _| not comment.empty? }\n  end",
        "comment": " Does this class or module have a comment with content or is #received_nodoc true?",
        "label": "How-it-is-done",
        "id": "1244"
    },
    {
        "raw_code": "def each_ancestor # :yields: module\n    return enum_for __method__ unless block_given?\n\n    ancestors.each do |mod|\n      next if String === mod\n      next if self == mod\n      yield mod\n    end",
        "comment": " Iterates the ancestors of this class or module for which an RDoc::ClassModule exists.",
        "label": "How-to-use",
        "id": "1245"
    },
    {
        "raw_code": "def find_ancestor_local_symbol(symbol)\n    each_ancestor do |m|\n      res = m.find_local_symbol(symbol)\n      return res if res\n    end",
        "comment": " Looks for a symbol in the #ancestors. See Context#find_local_symbol.",
        "label": "What",
        "id": "1246"
    },
    {
        "raw_code": "def find_class_named(name)\n    return self if full_name == name\n    return self if @name == name\n\n    @classes.values.find do |klass|\n      next if klass == self\n      klass.find_class_named name\n    end",
        "comment": " Finds a class or module with +name+ in this namespace or its descendants",
        "label": "What",
        "id": "1247"
    },
    {
        "raw_code": "def full_name\n    @full_name ||= if RDoc::ClassModule === parent then\n                     \"#{parent.full_name}::#{@name}\"\n                   else\n                     @name\n                   end",
        "comment": " Return the fully qualified name of this class or module",
        "label": "How-to-use",
        "id": "1248"
    },
    {
        "raw_code": "def nesting_namespaces\n    @namespaces ||= full_name.split(\"::\").reject(&:empty?)\n  end",
        "comment": " Return array of full_name splitted by +::+.",
        "label": "What",
        "id": "1249"
    },
    {
        "raw_code": "def fully_qualified_nesting_namespaces\n    return nesting_namespaces if nesting_namespaces.length < 2\n    @fqns ||= nesting_namespaces.inject([]) do |list, n|\n      list << (list.empty? ? n : \"#{list.last}::#{n}\")\n    end",
        "comment": " Return array of fully qualified nesting namespaces.  For example, if full_name is +A::B::C+, this method returns <code>[\"A\", \"A::B\", \"A::B::C\"]</code>",
        "label": "Property",
        "id": "1250"
    },
    {
        "raw_code": "def marshal_dump # :nodoc:\n    attrs = attributes.sort.map do |attr|\n      next unless attr.display?\n      [ attr.name, attr.rw,\n        attr.visibility, attr.singleton, attr.file_name,\n      ]\n    end.compact\n\n    method_types = methods_by_type.map do |type, visibilities|\n      visibilities = visibilities.map do |visibility, methods|\n        method_names = methods.map do |method|\n          next unless method.display?\n          [method.name, method.file_name]\n        end.compact\n\n        [visibility, method_names.uniq]\n      end",
        "comment": " TODO: filter included items by #display?",
        "label": "How-to-use",
        "id": "1251"
    },
    {
        "raw_code": "def merge(class_module)\n    @parent      = class_module.parent\n    @parent_name = class_module.parent_name\n\n    other_document = parse class_module.comment_location\n\n    if other_document then\n      document = parse @comment_location\n\n      document = document.merge other_document\n\n      @comment = RDoc::Comment.from_document(document)\n      @comment_location = document\n    end",
        "comment": " Merges +class_module+ into this ClassModule.  The data in +class_module+ is preferred over the receiver.",
        "label": "What",
        "id": "1252"
    },
    {
        "raw_code": "def merge_collections(mine, other, other_files, &block) # :nodoc:\n    my_things    = mine. group_by { |thing| thing.file }\n    other_things = other.group_by { |thing| thing.file }\n\n    remove_things my_things, other_files,  &block\n    add_things    my_things, other_things, &block\n  end",
        "comment": " Merges collection +mine+ with +other+ preferring other.  +other_files+ is used to help determine which items should be deleted.  Yields whether the item should be added or removed (true or false) and the item to be added or removed.  merge_collections things, other.things, other.in_files do |add, thing| if add then # add the thing else # remove the thing end end",
        "label": "Others",
        "id": "1253"
    },
    {
        "raw_code": "def merge_sections(cm) # :nodoc:\n    my_sections    =    sections.group_by { |section| section.title }\n    other_sections = cm.sections.group_by { |section| section.title }\n\n    other_files = cm.in_files\n\n    remove_things my_sections, other_files do |_, section|\n      @sections.delete section.title\n    end",
        "comment": " Merges the comments in this ClassModule with the comments in the other ClassModule +cm+.",
        "label": "Others",
        "id": "1254"
    },
    {
        "raw_code": "def module?\n    false\n  end",
        "comment": " Does this object represent a module?",
        "label": "How-it-is-done",
        "id": "1255"
    },
    {
        "raw_code": "def name=(new_name)\n    @name = new_name\n  end",
        "comment": " Allows overriding the initial name.  Used for modules and classes that are constant aliases.",
        "label": "Others",
        "id": "1256"
    },
    {
        "raw_code": "def parse(comment_location)\n    case comment_location\n    when String then\n      super\n    when Array then\n      docs = comment_location.map do |comment, location|\n        doc = super comment\n        doc.file = location\n        doc\n      end",
        "comment": " Parses +comment_location+ into an RDoc::Markup::Document composed of multiple RDoc::Markup::Documents with their file set.",
        "label": "What",
        "id": "1257"
    },
    {
        "raw_code": "def path\n    prefix = options.class_module_path_prefix\n    return http_url unless prefix\n    File.join(prefix, http_url)\n  end",
        "comment": " Path to this class or module for use with HTML generator output.",
        "label": "How-to-use",
        "id": "1258"
    },
    {
        "raw_code": "def name_for_path\n    is_alias_for ? is_alias_for.full_name : full_name\n  end",
        "comment": " Name to use to generate the url: modules and classes that are aliases for another module or class return the name of the latter.",
        "label": "How-to-use",
        "id": "1259"
    },
    {
        "raw_code": "def non_aliases\n    @non_aliases ||= classes_and_modules.reject { |cm| cm.is_alias_for }\n  end",
        "comment": " Returns the classes and modules that are not constants aliasing another class or module. For use by formatters only (caches its result).",
        "label": "Property",
        "id": "1260"
    },
    {
        "raw_code": "def remove_nodoc_children\n    prefix = self.full_name + '::'\n\n    modules_hash.each_key do |name|\n      full_name = prefix + name\n      modules_hash.delete name unless @store.modules_hash[full_name]\n    end",
        "comment": " Updates the child modules or classes of class/module +parent+ by deleting the ones that have been removed from the documentation.  +parent_hash+ is either <tt>parent.modules_hash</tt> or <tt>parent.classes_hash</tt> and +all_hash+ is ::all_modules_hash or ::all_classes_hash.",
        "label": "Property",
        "id": "1261"
    },
    {
        "raw_code": "def search_record\n    [\n      name,\n      full_name,\n      full_name,\n      '',\n      path,\n      '',\n      snippet(@comment_location),\n    ]\n  end",
        "comment": " Search record used by RDoc::Generator::JsonIndex",
        "label": "Property",
        "id": "1262"
    },
    {
        "raw_code": "def store=(store)\n    super\n\n    @attributes .each do |attr|  attr.store  = store end\n    @constants  .each do |const| const.store = store end\n    @includes   .each do |incl|  incl.store  = store end\n    @extends    .each do |ext|   ext.store   = store end\n    @method_list.each do |meth|  meth.store  = store end\n  end",
        "comment": " Sets the store for this class or module and its contained code objects.",
        "label": "What",
        "id": "1263"
    },
    {
        "raw_code": "def superclass\n    @store.find_class_named(@superclass) || @superclass\n  end",
        "comment": " Get the superclass of this class.  Attempts to retrieve the superclass object, returns the name if it is not known.",
        "label": "Property",
        "id": "1264"
    },
    {
        "raw_code": "def superclass=(superclass)\n    raise NoMethodError, \"#{full_name} is a module\" if module?\n    case superclass\n    when RDoc::ClassModule\n      @superclass = superclass.full_name\n    when nil, String\n      @superclass = superclass\n    else\n      raise TypeError, \"superclass must be a String or RDoc::ClassModule, not #{superclass.class}\"\n    end",
        "comment": " Set the superclass of this class to +superclass+  where +superclass+ is one of:  - +nil+ - a String containing the full name of the superclass - the RDoc::ClassModule representing the superclass",
        "label": "How-to-use",
        "id": "1265"
    },
    {
        "raw_code": "def super_classes\n    result = []\n    parent = self\n    while parent = parent.superclass\n      result << parent\n      return result if parent.is_a?(String)\n    end",
        "comment": " Get all super classes of this class in an array. The last element might be a string if the name is unknown.",
        "label": "How-to-use",
        "id": "1266"
    },
    {
        "raw_code": "def type\n    module? ? 'module' : 'class'\n  end",
        "comment": " 'module' or 'class'",
        "label": "What",
        "id": "1267"
    },
    {
        "raw_code": "def update_aliases\n    constants.each do |const|\n      next unless cm = const.is_alias_for\n      cm_alias = cm.dup\n      cm_alias.name = const.name\n\n      # Don't move top-level aliases under Object, they look ugly there\n      unless RDoc::TopLevel === cm_alias.parent then\n        cm_alias.parent = self\n        cm_alias.full_name = nil # force update for new parent\n      end",
        "comment": " Updates the child modules & classes by replacing the ones that are aliases through a constant.  The aliased module/class is replaced in the children and in RDoc::Store#modules_hash or RDoc::Store#classes_hash by a copy that has <tt>RDoc::ClassModule#is_alias_for</tt> set to the aliased module/class, and this copy is added to <tt>#aliases</tt> of the aliased module/class.  Formatters can use the #non_aliases method to retrieve children that are not aliases, for instance to list the namespace content, since the aliased modules are included in the constants of the class/module, that are listed separately.",
        "label": "Others",
        "id": "1268"
    },
    {
        "raw_code": "def update_includes\n    includes.reject! do |include|\n      mod = include.module\n      !(String === mod) && @store.modules_hash[mod.full_name].nil?\n    end",
        "comment": " Deletes from #includes those whose module has been removed from the documentation. -- FIXME: includes are not reliably removed, see _possible_bug test case",
        "label": "What",
        "id": "1269"
    },
    {
        "raw_code": "def update_extends\n    extends.reject! do |ext|\n      mod = ext.module\n\n      !(String === mod) && @store.modules_hash[mod.full_name].nil?\n    end",
        "comment": " Deletes from #extends those whose module has been removed from the documentation. -- FIXME: like update_includes, extends are not reliably removed",
        "label": "What",
        "id": "1270"
    },
    {
        "raw_code": "def initialize(text, old_name, new_name, comment, singleton: false)\n    super()\n\n    @text = text\n    @singleton = singleton\n    @old_name = old_name\n    @new_name = new_name\n    self.comment = comment\n  end",
        "comment": " Creates a new Alias with a token stream of +text+ that aliases +old_name+ to +new_name+, has +comment+ and is a +singleton+ context.",
        "label": "How-it-is-done",
        "id": "1271"
    },
    {
        "raw_code": "def <=>(other)\n    [@singleton ? 0 : 1, new_name] <=> [other.singleton ? 0 : 1, other.new_name]\n  end",
        "comment": " Order by #singleton then #new_name",
        "label": "What",
        "id": "1272"
    },
    {
        "raw_code": "def aref\n    type = singleton ? 'c' : 'i'\n    \"#alias-#{type}-#{html_name}\"\n  end",
        "comment": " HTML fragment reference for this alias",
        "label": "How-to-use",
        "id": "1273"
    },
    {
        "raw_code": "def html_name\n    CGI.escape(@new_name.gsub('-', '-2D')).gsub('%', '-').sub(/^-/, '')\n  end",
        "comment": " HTML id-friendly version of +#new_name+.",
        "label": "How-to-use",
        "id": "1274"
    },
    {
        "raw_code": "def name_prefix\n    singleton ? '::' : '#'\n  end",
        "comment": " '::' for the alias of a singleton method/attribute, '#' for instance-level.",
        "label": "What",
        "id": "1275"
    },
    {
        "raw_code": "def pretty_old_name\n    \"#{singleton ? '::' : '#'}#{@old_name}\"\n  end",
        "comment": " Old name with prefix '::' or '#'.",
        "label": "Others",
        "id": "1276"
    },
    {
        "raw_code": "def pretty_new_name\n    \"#{singleton ? '::' : '#'}#{@new_name}\"\n  end",
        "comment": " New name with prefix '::' or '#'.",
        "label": "Others",
        "id": "1277"
    },
    {
        "raw_code": "def definition\n    \"module #{full_name}\"\n  end",
        "comment": " The definition of this module, <tt>module MyModuleName</tt>",
        "label": "What",
        "id": "1278"
    },
    {
        "raw_code": "def module?\n    true\n  end",
        "comment": " This is a module, returns true",
        "label": "Property",
        "id": "1279"
    },
    {
        "raw_code": "def superclass\n    raise NoMethodError, \"#{full_name} is a module\"\n  end",
        "comment": " Modules don't have one, raises NoMethodError",
        "label": "Why",
        "id": "1280"
    },
    {
        "raw_code": "def ancestors\n    superclass ? super + [superclass] : super\n  end",
        "comment": " Adds the superclass to the included modules.",
        "label": "What",
        "id": "1281"
    },
    {
        "raw_code": "def definition\n    \"class << #{full_name}\"\n  end",
        "comment": " The definition of this singleton class, <tt>class << MyClassName</tt>",
        "label": "What",
        "id": "1282"
    },
    {
        "raw_code": "def initialize(text, name, singleton: false)\n    super(text, name, singleton: singleton)\n\n    @c_function = nil\n    @dont_rename_initialize = false\n    @token_stream = nil\n    @calls_super = false\n    @superclass_method = nil\n  end",
        "comment": " Creates a new AnyMethod with a token stream +text+ and +name+",
        "label": "How-it-is-done",
        "id": "1283"
    },
    {
        "raw_code": "def add_alias(an_alias, context = nil)\n    method = self.class.new an_alias.text, an_alias.new_name, singleton: singleton\n\n    method.record_location an_alias.file\n    method.params = self.params\n    method.visibility = self.visibility\n    method.comment = an_alias.comment\n    method.is_alias_for = self\n    @aliases << method\n    context.add_method method if context\n    method\n  end",
        "comment": " Adds +an_alias+ as an alias for this method in +context+.",
        "label": "What",
        "id": "1284"
    },
    {
        "raw_code": "def aref_prefix\n    'method'\n  end",
        "comment": " Prefix for +aref+ is 'method'.",
        "label": "How-it-is-done",
        "id": "1285"
    },
    {
        "raw_code": "def arglists\n    if @call_seq then\n      @call_seq\n    elsif @params then\n      \"#{name}#{param_seq}\"\n    end",
        "comment": " The call_seq or the param_seq with method name, if there is no call_seq.  Use this for displaying a method's argument lists.",
        "label": "How-to-use",
        "id": "1286"
    },
    {
        "raw_code": "def call_seq\n    unless call_seq = _call_seq\n      call_seq = is_alias_for._call_seq if is_alias_for\n    end",
        "comment": " Different ways to call this method",
        "label": "How-to-use",
        "id": "1287"
    },
    {
        "raw_code": "def call_seq=(call_seq)\n    return if call_seq.nil? || call_seq.empty?\n\n    @call_seq = call_seq\n  end",
        "comment": " Sets the different ways you can call this method.  If an empty +call_seq+ is given nil is assumed.  See also #param_seq",
        "label": "How-to-use",
        "id": "1288"
    },
    {
        "raw_code": "def has_call_seq?\n    !!(@call_seq || is_alias_for&._call_seq)\n  end",
        "comment": " Whether the method has a call-seq.",
        "label": "How-to-use",
        "id": "1289"
    },
    {
        "raw_code": "def is_alias_for # :nodoc:\n    case @is_alias_for\n    when RDoc::MethodAttr then\n      @is_alias_for\n    when Array then\n      return nil unless @store\n\n      klass_name, singleton, method_name = @is_alias_for\n\n      return nil unless klass = @store.find_class_or_module(klass_name)\n\n      @is_alias_for = klass.find_method method_name, singleton\n    end",
        "comment": " Loads is_alias_for from the internal name.  Returns nil if the alias cannot be found.",
        "label": "Property",
        "id": "1290"
    },
    {
        "raw_code": "def marshal_dump\n    aliases = @aliases.map do |a|\n      [a.name, parse(a.comment)]\n    end",
        "comment": " Dumps this AnyMethod for use by ri.  See also #marshal_load",
        "label": "What",
        "id": "1291"
    },
    {
        "raw_code": "def marshal_load(array)\n    initialize_visibility\n\n    @dont_rename_initialize = nil\n    @token_stream           = nil\n    @aliases                = []\n    @parent                 = nil\n    @parent_name            = nil\n    @parent_class           = nil\n    @section                = nil\n    @file                   = nil\n\n    version        = array[0]\n    @name          = array[1]\n    @full_name     = array[2]\n    @singleton     = array[3]\n    @visibility    = array[4]\n    @comment       = RDoc::Comment.from_document array[5]\n    @call_seq      = array[6]\n    @block_params  = array[7]\n    #                      8 handled below\n    @params        = array[9]\n    #                      10 handled below\n    @calls_super   = array[11]\n    @parent_name   = array[12]\n    @parent_title  = array[13]\n    @section_title = array[14]\n    @is_alias_for  = array[15]\n\n    array[8].each do |new_name, document|\n      add_alias RDoc::Alias.new(nil, @name, new_name, RDoc::Comment.from_document(document), singleton: @singleton)\n    end",
        "comment": " Loads this AnyMethod from +array+.  For a loaded AnyMethod the following methods will return cached values:  * #full_name * #parent_name",
        "label": "What",
        "id": "1292"
    },
    {
        "raw_code": "def name\n    return @name if @name\n\n    @name =\n      @call_seq[/^.*?\\.(\\w+)/, 1] ||\n      @call_seq[/^.*?(\\w+)/, 1] ||\n      @call_seq if @call_seq\n  end",
        "comment": " Method name  If the method has no assigned name, it extracts it from #call_seq.",
        "label": "How-to-use",
        "id": "1293"
    },
    {
        "raw_code": "def param_list\n    if @call_seq then\n      params = @call_seq.split(\"\\n\").last\n      params = params.sub(/.*?\\((.*)\\)/, '\\1')\n      params = params.sub(/(\\{|do)\\s*\\|([^|]*)\\|.*/, ',\\2')\n    elsif @params then\n      params = @params.sub(/\\((.*)\\)/, '\\1')\n\n      params << \",#{@block_params}\" if @block_params\n    elsif @block_params then\n      params = @block_params\n    else\n      return []\n    end",
        "comment": " A list of this method's method and yield parameters.  +call-seq+ params are preferred over parsed method and block params.",
        "label": "How-to-use",
        "id": "1294"
    },
    {
        "raw_code": "def param_seq\n    if @call_seq then\n      params = @call_seq.split(\"\\n\").last\n      params = params.sub(/[^( ]+/, '')\n      params = params.sub(/(\\|[^|]+\\|)\\s*\\.\\.\\.\\s*(end|\\})/, '\\1 \\2')\n    elsif @params then\n      params = @params.gsub(/\\s*\\#.*/, '')\n      params = params.tr_s(\"\\n \", \" \")\n      params = \"(#{params})\" unless params[0] == ?(\n    else\n      params = ''\n    end",
        "comment": " Pretty parameter list for this method.  If the method's parameters were given by +call-seq+ it is preferred over the parsed values.",
        "label": "How-to-use",
        "id": "1295"
    },
    {
        "raw_code": "def skip_description?\n    has_call_seq? && call_seq.nil? && !!(is_alias_for || !aliases.empty?)\n  end",
        "comment": " Whether to skip the method description, true for methods that have aliases with a call-seq that doesn't include the method name.",
        "label": "How-to-use",
        "id": "1296"
    },
    {
        "raw_code": "def store=(store)\n    super\n\n    @file = @store.add_file @file.full_name if @file\n  end",
        "comment": " Sets the store for this method and its referenced code objects.",
        "label": "What",
        "id": "1297"
    },
    {
        "raw_code": "def superclass_method\n    return unless @calls_super\n    return @superclass_method if @superclass_method\n\n    parent.each_ancestor do |ancestor|\n      if method = ancestor.method_list.find { |m| m.name == @name } then\n        @superclass_method = method\n        break\n      end",
        "comment": " For methods that +super+, find the superclass method that would be called.",
        "label": "How-to-use",
        "id": "1298"
    },
    {
        "raw_code": "def _call_seq\n    @call_seq if defined?(@call_seq) && @call_seq\n  end",
        "comment": " call_seq without deduplication and alias lookup.",
        "label": "How-to-use",
        "id": "1299"
    },
    {
        "raw_code": "def deduplicate_call_seq(call_seq)\n    return call_seq unless is_alias_for || !aliases.empty?\n\n    method_name = self.name\n    method_name = method_name[0, 1] if method_name =~ /\\A\\[/\n\n    entries = call_seq.split \"\\n\"\n\n    ignore = aliases.map(&:name)\n    if is_alias_for\n      ignore << is_alias_for.name\n      ignore.concat is_alias_for.aliases.map(&:name)\n    end",
        "comment": " call_seq with alias examples information removed, if this method is an alias method.",
        "label": "How-to-use",
        "id": "1300"
    },
    {
        "raw_code": "def initialize(name, comment)\n    super()\n    @name = name\n    self.comment = comment\n    @module = nil # cache for module if found\n  end",
        "comment": " Creates a new Mixin for +name+ with +comment+",
        "label": "How-it-is-done",
        "id": "1301"
    },
    {
        "raw_code": "def <=>(other)\n    return unless self.class === other\n\n    name <=> other.name\n  end",
        "comment": " Mixins are sorted by name",
        "label": "Others",
        "id": "1302"
    },
    {
        "raw_code": "def full_name\n    m = self.module\n    RDoc::ClassModule === m ? m.full_name : @name\n  end",
        "comment": " Full name based on #module",
        "label": "What",
        "id": "1303"
    },
    {
        "raw_code": "def module\n    return @module if @module\n\n    # search the current context\n    return @name unless parent\n    full_name = parent.child_name(@name)\n    @module = @store.modules_hash[full_name]\n    return @module if @module\n    return @name if @name =~ /^::/\n\n    # search the includes before this one, in reverse order\n    searched = parent.includes.take_while { |i| i != self }.reverse\n    searched.each do |i|\n      inc = i.module\n      next if String === inc\n      full_name = inc.child_name(@name)\n      @module = @store.modules_hash[full_name]\n      return @module if @module\n    end",
        "comment": " Attempts to locate the included module object.  Returns the name if not known.  The scoping rules of Ruby to resolve the name of an included module are: - first look into the children of the current context; - if not found, look into the children of included modules, in reverse inclusion order; - if still not found, go up the hierarchy of names.  This method has <code>O(n!)</code> behavior when the module calling include is referencing nonexistent modules.  Avoid calling #module until after all the files are parsed.  This behavior is due to ruby's constant lookup behavior.  As of the beginning of October, 2011, no gem includes nonexistent modules.",
        "label": "How-to-use",
        "id": "1304"
    },
    {
        "raw_code": "def store=(store)\n    super\n\n    @file = @store.add_file @file.full_name if @file\n  end",
        "comment": " Sets the store for this class or module and its contained code objects.",
        "label": "What",
        "id": "1305"
    },
    {
        "raw_code": "def initialize(name, value, comment)\n    super()\n\n    @name  = name\n    @value = value\n\n    @is_alias_for = nil\n    @visibility   = :public\n\n    self.comment = comment\n  end",
        "comment": " Creates a new constant with +name+, +value+ and +comment+",
        "label": "How-it-is-done",
        "id": "1306"
    },
    {
        "raw_code": "def <=>(other)\n    return unless self.class === other\n\n    [parent_name, name] <=> [other.parent_name, other.name]\n  end",
        "comment": " Constants are ordered by name",
        "label": "What",
        "id": "1307"
    },
    {
        "raw_code": "def ==(other)\n    self.class == other.class and\n      @parent == other.parent and\n      @name == other.name\n  end",
        "comment": " Constants are equal when their #parent and #name is the same",
        "label": "What",
        "id": "1308"
    },
    {
        "raw_code": "def documented?\n    return true if super\n    return false unless @is_alias_for\n    case @is_alias_for\n    when String then\n      found = @store.find_class_or_module @is_alias_for\n      return false unless found\n      @is_alias_for = found\n    end",
        "comment": " A constant is documented if it has a comment, or is an alias for a documented class or module.",
        "label": "What",
        "id": "1309"
    },
    {
        "raw_code": "def full_name\n    @full_name ||= \"#{parent_name}::#{@name}\"\n  end",
        "comment": " Full constant name including namespace",
        "label": "Others",
        "id": "1310"
    },
    {
        "raw_code": "def is_alias_for\n    case @is_alias_for\n    when String then\n      found = @store.find_class_or_module @is_alias_for\n      @is_alias_for = found if found\n      @is_alias_for\n    else\n      @is_alias_for\n    end",
        "comment": " The module or class this constant is an alias for",
        "label": "What",
        "id": "1311"
    },
    {
        "raw_code": "def marshal_dump\n    alias_name = case found = is_alias_for\n                 when RDoc::CodeObject then found.full_name\n                 else                       found\n                 end",
        "comment": " Dumps this Constant for use by ri.  See also #marshal_load",
        "label": "Why",
        "id": "1312"
    },
    {
        "raw_code": "def marshal_load(array)\n    initialize array[1], nil, RDoc::Comment.from_document(array[5])\n\n    @full_name     = array[2]\n    @visibility    = array[3] || :public\n    @is_alias_for  = array[4]\n    #                      5 handled above\n    #                      6 handled below\n    @parent_name   = array[7]\n    @parent_class  = array[8]\n    @section_title = array[9]\n\n    @file = RDoc::TopLevel.new array[6]\n  end",
        "comment": " Loads this Constant from +array+.  For a loaded Constant the following methods will return cached values:  * #full_name * #parent_name",
        "label": "Why",
        "id": "1313"
    },
    {
        "raw_code": "def path\n    \"#{@parent.path}##{@name}\"\n  end",
        "comment": " Path to this constant for use with HTML generator output.",
        "label": "How-to-use",
        "id": "1314"
    },
    {
        "raw_code": "def store=(store)\n    super\n\n    @file = @store.add_file @file.full_name if @file\n  end",
        "comment": " Sets the store for this class or module and its contained code objects.",
        "label": "What",
        "id": "1315"
    },
    {
        "raw_code": "def initialize(text, name, singleton: false)\n    super()\n\n    @text = text\n    @name = name\n\n    @aliases      = []\n    @is_alias_for = nil\n    @parent_name  = nil\n    @singleton    = singleton\n    @visibility   = :public\n    @see = false\n\n    @arglists     = nil\n    @block_params = nil\n    @call_seq     = nil\n    @params       = nil\n  end",
        "comment": " Creates a new MethodAttr from token stream +text+ and method or attribute name +name+.  Usually this is called by super from a subclass.",
        "label": "How-to-use",
        "id": "1316"
    },
    {
        "raw_code": "def initialize_copy(other) # :nodoc:\n    @full_name = nil\n  end",
        "comment": " Resets cached data for the object so it can be rebuilt by accessor methods",
        "label": "Why",
        "id": "1317"
    },
    {
        "raw_code": "def <=>(other)\n    return unless other.respond_to?(:singleton) &&\n                  other.respond_to?(:name)\n\n    [@singleton      ? 0 : 1, name_ord_range,       name] <=>\n    [other.singleton ? 0 : 1, other.name_ord_range, other.name]\n  end",
        "comment": " Order by #singleton then #name",
        "label": "What",
        "id": "1318"
    },
    {
        "raw_code": "def documented?\n    super or\n      (is_alias_for and is_alias_for.documented?) or\n      (see and see.documented?)\n  end",
        "comment": " A method/attribute is documented if any of the following is true: - it was marked with :nodoc:; - it has a comment; - it is an alias for a documented method; - it has a +#see+ method that is documented.",
        "label": "What",
        "id": "1319"
    },
    {
        "raw_code": "def see\n    @see = find_see if @see == false\n    @see\n  end",
        "comment": " A method/attribute to look at, in particular if this method/attribute has no documentation.  It can be a method/attribute of the superclass or of an included module, including the Kernel module, which is always appended to the included modules.  Returns +nil+ if there is no such method/attribute. The +#is_alias_for+ method/attribute, if any, is not included.  Templates may generate a \"see also ...\" if this method/attribute has documentation, and \"see ...\" if it does not.",
        "label": "How-it-is-done",
        "id": "1320"
    },
    {
        "raw_code": "def store=(store)\n    super\n\n    @file = @store.add_file @file.full_name if @file\n  end",
        "comment": " Sets the store for this class or module and its contained code objects.",
        "label": "What",
        "id": "1321"
    },
    {
        "raw_code": "def add_alias(an_alias, context)\n    raise NotImplementedError\n  end",
        "comment": " Abstract method. Contexts in their building phase call this to register a new alias for this known method/attribute.  - creates a new AnyMethod/Attribute named <tt>an_alias.new_name</tt>; - adds +self+ as an alias for the new method or attribute - adds the method or attribute to #aliases - adds the method or attribute to +context+.",
        "label": "How-to-use",
        "id": "1322"
    },
    {
        "raw_code": "def aref\n    type = singleton ? 'c' : 'i'\n    # % characters are not allowed in html names => dash instead\n    \"#{aref_prefix}-#{type}-#{html_name}\"\n  end",
        "comment": " HTML fragment reference for this method",
        "label": "How-to-use",
        "id": "1323"
    },
    {
        "raw_code": "def aref_prefix\n    raise NotImplementedError\n  end",
        "comment": " Prefix for +aref+, defined by subclasses.",
        "label": "Property",
        "id": "1324"
    },
    {
        "raw_code": "def block_params=(value)\n    # 'yield.to_s' or 'assert yield, msg'\n    return @block_params = '' if value =~ /^[\\.,]/\n\n    # remove trailing 'if/unless ...'\n    return @block_params = '' if value =~ /^(if|unless)\\s/\n\n    value = $1.strip if value =~ /^(.+)\\s(if|unless)\\s/\n\n    # outer parentheses\n    value = $1 if value =~ /^\\s*\\((.*)\\)\\s*$/\n    value = value.strip\n\n    # proc/lambda\n    return @block_params = $1 if value =~ /^(proc|lambda)(\\s*\\{|\\sdo)/\n\n    # surrounding +...+ or [...]\n    value = $1.strip if value =~ /^\\+(.*)\\+$/\n    value = $1.strip if value =~ /^\\[(.*)\\]$/\n\n    return @block_params = '' if value.empty?\n\n    # global variable\n    return @block_params = 'str' if value =~ /^\\$[&0-9]$/\n\n    # wipe out array/hash indices\n    value.gsub!(/(\\w)\\[[^\\[]+\\]/, '\\1')\n\n    # remove @ from class/instance variables\n    value.gsub!(/@@?([a-z0-9_]+)/, '\\1')\n\n    # method calls => method name\n    value.gsub!(/([A-Z:a-z0-9_]+)\\.([a-z0-9_]+)(\\s*\\(\\s*[a-z0-9_.,\\s]*\\s*\\)\\s*)?/) do\n      case $2\n      when 'to_s'      then $1\n      when 'const_get' then 'const'\n      when 'new' then\n        $1.split('::').last.  # ClassName => class_name\n          gsub(/([A-Z]+)([A-Z][a-z])/, '\\1_\\2').\n          gsub(/([a-z\\d])([A-Z])/, '\\1_\\2').\n          downcase\n      else\n        $2\n      end",
        "comment": " Attempts to sanitize the content passed by the Ruby parser: remove outer parentheses, etc.",
        "label": "What",
        "id": "1325"
    },
    {
        "raw_code": "def html_name\n    require 'cgi/escape'\n    require 'cgi/util' unless defined?(CGI::EscapeExt)\n\n    CGI.escape(@name.gsub('-', '-2D')).gsub('%', '-').sub(/^-/, '')\n  end",
        "comment": " HTML id-friendly method/attribute name",
        "label": "How-to-use",
        "id": "1326"
    },
    {
        "raw_code": "def full_name\n    @full_name ||= \"#{parent_name}#{pretty_name}\"\n  end",
        "comment": " Full method/attribute name including namespace",
        "label": "Property",
        "id": "1327"
    },
    {
        "raw_code": "def name_prefix\n    @singleton ? '::' : '#'\n  end",
        "comment": " '::' for a class method/attribute, '#' for an instance method.",
        "label": "What",
        "id": "1328"
    },
    {
        "raw_code": "def pretty_name\n    \"#{name_prefix}#{@name}\"\n  end",
        "comment": " Method/attribute name with class/instance indicator",
        "label": "Property",
        "id": "1329"
    },
    {
        "raw_code": "def type\n    singleton ? 'class' : 'instance'\n  end",
        "comment": " Type of method/attribute (class or instance)",
        "label": "What",
        "id": "1330"
    },
    {
        "raw_code": "def path\n    \"#{@parent.path}##{aref}\"\n  end",
        "comment": " Path to this method for use with HTML generator output.",
        "label": "How-to-use",
        "id": "1331"
    },
    {
        "raw_code": "def parent_name\n    @parent_name || super\n  end",
        "comment": " Name of our parent with special handling for un-marshaled methods",
        "label": "What",
        "id": "1332"
    },
    {
        "raw_code": "def search_record\n    [\n      @name,\n      full_name,\n      @name,\n      @parent.full_name,\n      path,\n      params,\n      snippet(@comment),\n    ]\n  end",
        "comment": " Used by RDoc::Generator::JsonIndex to create a record for the search engine.",
        "label": "Property",
        "id": "1333"
    },
    {
        "raw_code": "def initialize(parent, title, comment)\n    @parent = parent\n    @title = title ? title.strip : title\n\n    @comments = []\n\n    add_comment comment\n  end",
        "comment": " Creates a new section with +title+ and +comment+",
        "label": "How-it-is-done",
        "id": "1334"
    },
    {
        "raw_code": "def ==(other)\n    self.class === other and @title == other.title\n  end",
        "comment": " Sections are equal when they have the same #title",
        "label": "What",
        "id": "1335"
    },
    {
        "raw_code": "def add_comment(comment)\n    comments = Array(comment)\n    comments.each do |c|\n      extracted_comment = extract_comment(c)\n      @comments << extracted_comment unless extracted_comment.empty?\n    end",
        "comment": " Adds +comment+ to this section",
        "label": "Others",
        "id": "1336"
    },
    {
        "raw_code": "def aref\n    title = @title || '[untitled]'\n\n    CGI.escape(title).gsub('%', '-').sub(/^-/, '')\n  end",
        "comment": " Anchor reference for linking to this section",
        "label": "What",
        "id": "1337"
    },
    {
        "raw_code": "def extract_comment(comment)\n    case comment\n    when nil\n      RDoc::Comment.new ''\n    when RDoc::Comment then\n      if comment.text =~ /^#[ \\t]*:section:.*\\n/ then\n        start = $`\n        rest = $'\n\n        comment.text = if start.empty? then\n                         rest\n                       else\n                         rest.sub(/#{start.chomp}\\Z/, '')\n                       end",
        "comment": " Extracts the comment for this section from the original comment block. If the first line contains :section:, strip it and use the rest. Otherwise remove lines up to the line containing :section:, and look for those lines again at the end and remove them. This lets us write  # :section: The title # The body",
        "label": "How-to-use",
        "id": "1338"
    },
    {
        "raw_code": "def in_files\n    @comments.map(&:file)\n  end",
        "comment": " The files comments in this section come from",
        "label": "What",
        "id": "1339"
    },
    {
        "raw_code": "def marshal_dump\n    [\n      MARSHAL_VERSION,\n      @title,\n      parse,\n    ]\n  end",
        "comment": " Serializes this Section.  The title and parsed comment are saved, but not the section parent which must be restored manually.",
        "label": "What",
        "id": "1340"
    },
    {
        "raw_code": "def marshal_load(array)\n    @parent  = nil\n\n    @title    = array[1]\n    @comments = array[2].parts.map { |doc| RDoc::Comment.from_document(doc) }\n  end",
        "comment": " De-serializes this Section.  The section parent must be restored manually.",
        "label": "Others",
        "id": "1341"
    },
    {
        "raw_code": "def parse\n    RDoc::Markup::Document.new(*@comments.map(&:parse))\n  end",
        "comment": " Parses +comment_location+ into an RDoc::Markup::Document composed of multiple RDoc::Markup::Documents with their file set.",
        "label": "What",
        "id": "1342"
    },
    {
        "raw_code": "def plain_html\n    @title || 'Top Section'\n  end",
        "comment": " The section's title, or 'Top Section' if the title is nil.  This is used by the table of contents template so the name is silly.",
        "label": "What",
        "id": "1343"
    },
    {
        "raw_code": "def remove_comment(target_comment)\n    @comments.delete_if do |stored_comment|\n      stored_comment.file == target_comment.file\n    end",
        "comment": " Removes a comment from this section if it is from the same file as +comment+",
        "label": "What",
        "id": "1344"
    },
    {
        "raw_code": "def self.dummy_singleton_method(foo, bar); end\n\n  # Example instance method.\n  def dummy_instance_method(foo, bar); end;\n\n  alias dummy_instance_alias dummy_instance_method\n\n  # Example attribute.\n  attr_accessor :dummy_attribute\n\n  alias dummy_attribute_alias dummy_attribute\n\n  # Example constant.\n  DUMMY_CONSTANT = ''\n\n  # :call-seq:\n  #   call_seq_directive(foo, bar)\n  #   Can be anything -> bar\n  #   Also anything more -> baz or bat\n  #\n  # The <tt>:call-seq:</tt> directive overrides the actual calling sequence\n  # found in the Ruby code.\n  #\n  # - It can specify anything at all.\n  # - It can have multiple calling sequences.\n  #\n  # This one includes <tt>Can be anything -> foo</tt>, which is nonsense.\n  #\n  # Note that the \"arrow\" is two characters, hyphen and right angle-bracket,\n  # which is made into a single character in the HTML.\n  #\n  # Click on the calling sequence to see the code.\n  #\n  # Here is the <tt>:call-seq:</tt> directive given for the method:\n  #\n  #   :call-seq:\n  #     call_seq_directive(foo, bar)\n  #     Can be anything -> bar\n  #     Also anything more -> baz or bat\n  #\n  def call_seq_directive\n    nil\n  end\n\n  # The <tt>:args:</tt> directive overrides the actual arguments found in the Ruby code.\n  #\n  # Click on the calling sequence to see the code.\n  #\n  def args_directive(foo, bar) # :args: baz\n    nil\n  end\n\n  # The <tt>:yields:</tt> directive overrides the actual yield found in the Ruby code.\n  #\n  # Click on the calling sequence to see the code.\n  #\n  def yields_directive(foo, bar) # :yields: 'bat'\n    yield 'baz'\n  end\n\n  # This method is documented only by \\RDoc, except for these comments.\n  #\n  # Click on the calling sequence to see the code.\n  #\n  def method(foo, bar)\n    yield 'baz'\n  end\n\nend",
        "comment": "Example singleton method.",
        "label": "What",
        "id": "1345"
    },
    {
        "raw_code": "def assert_hard_link(filename)\n    assert_file filename\n\n    src = @g.template_dir + '_head.rhtml'\n    dst = File.join @tmpdir, 'hardlinktest'\n\n    begin\n      FileUtils.ln src, dst\n      nlink = File.stat(dst).nlink if File.identical? src, dst\n      FileUtils.rm dst\n      return if nlink == 1\n    rescue SystemCallError\n      return\n    end",
        "comment": " Asserts that +filename+ has a link count greater than 1 if hard links to @tmpdir are supported.",
        "label": "Property",
        "id": "1346"
    },
    {
        "raw_code": "def test_remove_private_comments\n    parser = util_parser \"foo\\n\\n--\\nbar\\n++\\n\\nbaz\\n\"\n\n    parser.scan\n\n    expected = \"foo\\n\\n\\nbaz\"\n\n    assert_equal expected, @top_level.comment.text\n  end",
        "comment": "RDoc stops processing comments if it finds a comment line CONTAINING '<tt>#--</tt>'. This can be used to separate external from internal comments, or to stop a comment being associated with a method, class, or module. Commenting CAN be turned back on with a line that STARTS '<tt>#++</tt>'.  I've seen guys that comment their code like this: # This method.... #----------------- def method  => either we do it only in ruby code, or we require the leading # (to avoid conflict with rules).  TODO: require the leading #, to provide the feature in simple text files. Note: in ruby & C code, we require '#--' & '#++' or '*--' & '*++', to allow rules:  # this is a comment #--- # private text #+++ # this is a rule: # ---",
        "label": "What",
        "id": "1347"
    },
    {
        "raw_code": "def test_convert_list_note\n    note_list = <<-NOTE_LIST\nfoo ::\nbar ::\n  hi\n    NOTE_LIST\n\n    expected = <<-EXPECTED\n\\e[0mfoo\nbar:\n  hi\n\n    EXPECTED\n\n    assert_equal expected, @to.convert(note_list)\n  end",
        "comment": "functional test",
        "label": "What",
        "id": "1348"
    },
    {
        "raw_code": "def baz1; end\n        end",
        "comment": "class that defines this method is unknown",
        "label": "What",
        "id": "1349"
    },
    {
        "raw_code": "def test_class_can_parse_zip\n    hidden_zip = File.expand_path '../hidden.zip.txt', __FILE__\n    assert_nil @RP.can_parse(hidden_zip)\n  end",
        "comment": " Selenium hides a .jar file using a .txt extension.",
        "label": "What",
        "id": "1350"
    },
    {
        "raw_code": "def test_extract_call_linear_performance\n    pre = ->(n) {[n, RDoc::Comment.new(\"\\n\"*n + 'call-seq:' + 'a'*n)]}\n    method_obj = RDoc::AnyMethod.new nil, 'blah'\n    assert_linear_performance((2..5).map {|i| 10**i}, pre: pre) do |n, comment|\n      method_obj.call_seq = comment.extract_call_seq\n      assert_equal n, method_obj.call_seq.size\n    end",
        "comment": "This test relies on AnyMethod#call_seq's behaviour as well",
        "label": "How-to-use",
        "id": "1351"
    },
    {
        "raw_code": "def test_save_class_merge_constant\n    store = RDoc::Store.new(RDoc::Options.new)\n    tl = store.add_file 'file.rb'\n\n    klass = tl.add_class RDoc::NormalClass, 'C'\n    klass.add_comment 'comment', tl\n\n    const = klass.add_constant RDoc::Constant.new('CONST', nil, nil)\n    const.record_location tl\n\n    @s.save_class klass\n\n    # separate parse run, independent store\n    store = RDoc::Store.new(RDoc::Options.new)\n    tl = store.add_file 'file.rb'\n    klass2 = tl.add_class RDoc::NormalClass, 'C'\n    klass2.record_location tl\n\n    s = RDoc::RI::Store.new(RDoc::Options.new, path: @tmpdir)\n    s.save_class klass2\n\n    # separate `ri` run, independent store\n    s = RDoc::RI::Store.new(RDoc::Options.new, path: @tmpdir)\n\n    result = s.load_class 'C'\n\n    assert_empty result.constants\n  end",
        "comment": "This is a functional test",
        "label": "How-it-is-done",
        "id": "1352"
    },
    {
        "raw_code": "def test_do_methods_in_c\n    content = <<-EOF\nVALUE blah(VALUE klass, VALUE year) {\n}\n\nvoid Init_Blah(void) {\n  cDate = rb_define_class(\"Date\", rb_cObject);\n\n  rb_define_method(cDate, \"blah\", blah, 1); /* in blah.c */\n}\n    EOF\n\n    klass = nil\n\n    _, err = verbose_capture_output do\n      klass = util_get_class content, 'cDate'\n    end",
        "comment": "HACK parsing warning instead of setting up in file",
        "label": "Why",
        "id": "1353"
    },
    {
        "raw_code": "def test_do_methods_in_cpp\n    content = <<-EOF\nVALUE blah(VALUE klass, VALUE year) {\n}\n\nvoid Init_Blah(void) {\n  cDate = rb_define_class(\"Date\", rb_cObject);\n\n  rb_define_method(cDate, \"blah\", blah, 1); /* in blah.cpp */\n}\n    EOF\n\n    klass = nil\n\n    _, err = verbose_capture_output do\n      klass = util_get_class content, 'cDate'\n    end",
        "comment": "HACK parsing warning instead of setting up in file",
        "label": "Why",
        "id": "1354"
    },
    {
        "raw_code": "def test_do_methods_in_y\n    content = <<-EOF\nVALUE blah(VALUE klass, VALUE year) {\n}\n\nvoid Init_Blah(void) {\n  cDate = rb_define_class(\"Date\", rb_cObject);\n\n  rb_define_method(cDate, \"blah\", blah, 1); /* in blah.y */\n}\n    EOF\n\n    klass = nil\n\n    _, err = verbose_capture_output do\n      klass = util_get_class content, 'cDate'\n    end",
        "comment": "HACK parsing warning instead of setting up in file",
        "label": "Why",
        "id": "1355"
    },
    {
        "raw_code": "def test_handle_method_args_minus_2\n    parser = util_parser \"Document-method: BasicObject#==\\n blah */\"\n\n    parser.handle_method 'method', 'rb_cBasicObject', '==', 'rb_obj_equal', -2\n\n    bo = @top_level.find_module_named 'BasicObject'\n\n    assert_equal 1, bo.method_list.length\n\n    equals2 = bo.method_list.first\n\n    assert_equal '(*args)', equals2.params\n  end",
        "comment": "test_handle_args_minus_1 handled by test_handle_method",
        "label": "What",
        "id": "1356"
    },
    {
        "raw_code": "def test_verbatim_normalize\n    v = @RM::Verbatim.new \"foo\\n\", \"\\n\", \"\\n\", \"bar\\n\"\n\n    v.normalize\n\n    assert_equal [\"foo\\n\", \"\\n\", \"bar\\n\"], v.parts\n\n    v = @RM::Verbatim.new \"foo\\n\", \"\\n\"\n\n    v.normalize\n\n    assert_equal [\"foo\\n\"], v.parts\n  end",
        "comment": "HACK move to Verbatim test case",
        "label": "How-it-is-done",
        "id": "1357"
    },
    {
        "raw_code": "def test_find_class_named\n    @c2.classes_hash['C2'] = @c2\n\n    assert_nil @c2.find_class_named('C1')\n  end",
        "comment": "handle making a short module alias of yourself",
        "label": "How-to-use",
        "id": "1358"
    },
    {
        "raw_code": "def test_parse_class_object\n    code = <<-CODE\nmodule A\n  class B\n  end",
        "comment": "TODO this is really a Context#add_class test",
        "label": "Why",
        "id": "1359"
    },
    {
        "raw_code": "def test_parse_top_level_statements_constant_nodoc_integration\n    content = <<-CONTENT\nclass A\n  C = A # :nodoc:\nend",
        "comment": "This tests parse_comment",
        "label": "What",
        "id": "1360"
    },
    {
        "raw_code": "def test_sanity_interpolation_crazy\n    util_parser '\"#{\"#{\"a\")}\" if b}\"'\n\n    assert_equal '\"#{\"#{\"a\")}\" if b}\"', @parser.get_tk[:text]\n    assert_nil @parser.get_tk\n  end",
        "comment": "If you're writing code like this you're doing it wrong",
        "label": "What",
        "id": "1361"
    },
    {
        "raw_code": "def foo() end\nend",
        "comment": "Hello",
        "label": "What",
        "id": "1362"
    },
    {
        "raw_code": "def test_convert_list_note\n    note_list = <<-NOTE_LIST\nfoo ::\nbar ::\n  hi\n    NOTE_LIST\n\n    expected = <<-EXPECTED\nfoo::\nbar::\n  hi\n\n    EXPECTED\n\n    assert_equal expected, @to.convert(note_list)\n  end",
        "comment": "functional test",
        "label": "What",
        "id": "1363"
    },
    {
        "raw_code": "def setup\n    super\n\n    @options = RDoc::Options.new\n\n    @m = @RM.new\n\n    @bullet_list = @RM::List.new(:BULLET,\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l1')),\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l2')))\n\n    @label_list = @RM::List.new(:LABEL,\n      @RM::ListItem.new('cat', @RM::Paragraph.new('cats are cool')),\n      @RM::ListItem.new('dog', @RM::Paragraph.new('dogs are cool too')))\n\n    @lalpha_list = @RM::List.new(:LALPHA,\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l1')),\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l2')))\n\n    @note_list = @RM::List.new(:NOTE,\n      @RM::ListItem.new('cat', @RM::Paragraph.new('cats are cool')),\n      @RM::ListItem.new('dog', @RM::Paragraph.new('dogs are cool too')))\n\n    @number_list = @RM::List.new(:NUMBER,\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l1')),\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l2')))\n\n    @ualpha_list = @RM::List.new(:UALPHA,\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l1')),\n      @RM::ListItem.new(nil, @RM::Paragraph.new('l2')))\n  end",
        "comment": " Call #setup when inheriting from this test case.  Provides the following instance variables:  +@m+::           RDoc::Markup.new +@RM+::          RDoc::Markup # to reduce typing +@bullet_list+:: @RM::List.new :BULLET, # ... +@label_list+::  @RM::List.new :LABEL, # ... +@lalpha_list+:: @RM::List.new :LALPHA, # ... +@note_list+::   @RM::List.new :NOTE, # ... +@number_list+:: @RM::List.new :NUMBER, # ... +@ualpha_list+:: @RM::List.new :UALPHA, # ...",
        "label": "How-to-use",
        "id": "1364"
    },
    {
        "raw_code": "def self.add_visitor_tests\n    class_eval do\n\n      ##\n      # Calls start_accepting which needs to verify startup state\n\n      def test_start_accepting\n        @to.start_accepting\n\n        start_accepting\n      end\n\n      ##\n      # Calls end_accepting on your test case which needs to call\n      # <tt>@to.end_accepting</tt> and verify document generation\n\n      def test_end_accepting\n        @to.start_accepting\n        @to.res << 'hi'\n\n        end_accepting\n      end\n\n      ##\n      # Calls accept_blank_line\n\n      def test_accept_blank_line\n        @to.start_accepting\n\n        @to.accept_blank_line @RM::BlankLine.new\n\n        accept_blank_line\n      end\n\n      ##\n      # Calls accept_block_quote\n\n      def test_accept_block_quote\n        @to.start_accepting\n\n        @to.accept_block_quote block para 'quote'\n\n        accept_block_quote\n      end\n      ##\n      # Test case that calls <tt>@to.accept_document</tt>\n\n      def test_accept_document\n        @to.start_accepting\n        @to.accept_document @RM::Document.new @RM::Paragraph.new 'hello'\n\n        accept_document\n      end\n\n      ##\n      # Calls accept_heading with a level 5 RDoc::Markup::Heading\n\n      def test_accept_heading\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(5, 'Hello')\n\n        accept_heading\n      end\n\n      ##\n      # Calls accept_heading_1 with a level 1 RDoc::Markup::Heading\n\n      def test_accept_heading_1\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(1, 'Hello')\n\n        accept_heading_1\n      end\n\n      ##\n      # Calls accept_heading_2 with a level 2 RDoc::Markup::Heading\n\n      def test_accept_heading_2\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(2, 'Hello')\n\n        accept_heading_2\n      end\n\n      ##\n      # Calls accept_heading_3 with a level 3 RDoc::Markup::Heading\n\n      def test_accept_heading_3\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(3, 'Hello')\n\n        accept_heading_3\n      end\n\n      ##\n      # Calls accept_heading_4 with a level 4 RDoc::Markup::Heading\n\n      def test_accept_heading_4\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(4, 'Hello')\n\n        accept_heading_4\n      end\n\n      ##\n      # Calls accept_heading_b with a bold level 1 RDoc::Markup::Heading\n\n      def test_accept_heading_b\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(1, '*Hello*')\n\n        accept_heading_b\n      end\n\n      ##\n      # Calls accept_heading_suppressed_crossref with a level 1\n      # RDoc::Markup::Heading containing a suppressed crossref\n\n      def test_accept_heading_suppressed_crossref # HACK to_html_crossref test\n        @to.start_accepting\n\n        @to.accept_heading @RM::Heading.new(1, '\\\\Hello')\n\n        accept_heading_suppressed_crossref\n      end\n\n      ##\n      # Calls accept_paragraph\n\n      def test_accept_paragraph\n        @to.start_accepting\n\n        @to.accept_paragraph @RM::Paragraph.new('hi')\n\n        accept_paragraph\n      end\n\n      ##\n      # Calls accept_paragraph_b with a RDoc::Markup::Paragraph containing\n      # bold words\n\n      def test_accept_paragraph_b\n        @to.start_accepting\n\n        @to.accept_paragraph @RM::Paragraph.new('reg <b>bold words</b> reg')\n\n        accept_paragraph_b\n      end\n\n      ##\n      # Calls accept_paragraph_br with a RDoc::Markup::Paragraph containing\n      # a \\<br>\n\n      def test_accept_paragraph_br\n        @to.start_accepting\n\n        @to.accept_paragraph para 'one<br>two'\n\n        accept_paragraph_br\n      end\n\n      ##\n      # Calls accept_paragraph with a Paragraph containing a hard break\n\n      def test_accept_paragraph_break\n        @to.start_accepting\n\n        @to.accept_paragraph para('hello', hard_break, 'world')\n\n        accept_paragraph_break\n      end\n\n      ##\n      # Calls accept_paragraph_i with a RDoc::Markup::Paragraph containing\n      # emphasized words\n\n      def test_accept_paragraph_i\n        @to.start_accepting\n\n        @to.accept_paragraph @RM::Paragraph.new('reg <em>italic words</em> reg')\n\n        accept_paragraph_i\n      end\n\n      ##\n      # Calls accept_paragraph_plus with a RDoc::Markup::Paragraph containing\n      # teletype words\n\n      def test_accept_paragraph_plus\n        @to.start_accepting\n\n        @to.accept_paragraph @RM::Paragraph.new('reg +teletype+ reg')\n\n        accept_paragraph_plus\n      end\n\n      ##\n      # Calls accept_paragraph_star with a RDoc::Markup::Paragraph containing\n      # bold words\n\n      def test_accept_paragraph_star\n        @to.start_accepting\n\n        @to.accept_paragraph @RM::Paragraph.new('reg *bold* reg')\n\n        accept_paragraph_star\n      end\n\n      ##\n      # Calls accept_paragraph_underscore with a RDoc::Markup::Paragraph\n      # containing emphasized words\n\n      def test_accept_paragraph_underscore\n        @to.start_accepting\n\n        @to.accept_paragraph @RM::Paragraph.new('reg _italic_ reg')\n\n        accept_paragraph_underscore\n      end\n\n      ##\n      # Calls accept_verbatim with a RDoc::Markup::Verbatim\n\n      def test_accept_verbatim\n        @to.start_accepting\n\n        @to.accept_verbatim @RM::Verbatim.new(\"hi\\n\", \"  world\\n\")\n\n        accept_verbatim\n      end\n\n      ##\n      # Calls accept_raw with a RDoc::Markup::Raw\n\n      def test_accept_raw\n        @to.start_accepting\n\n        @to.accept_raw @RM::Raw.new(\"<table>\",\n                                    \"<tr><th>Name<th>Count\",\n                                    \"<tr><td>a<td>1\",\n                                    \"<tr><td>b<td>2\",\n                                    \"</table>\")\n\n        accept_raw\n      end\n\n      ##\n      # Calls accept_rule with a RDoc::Markup::Rule\n\n      def test_accept_rule\n        @to.start_accepting\n\n        @to.accept_rule @RM::Rule.new(4)\n\n        accept_rule\n      end\n\n      ##\n      # Calls accept_list_item_start_bullet\n\n      def test_accept_list_item_start_bullet\n        @to.start_accepting\n\n        @to.accept_list_start @bullet_list\n\n        @to.accept_list_item_start @bullet_list.items.first\n\n        accept_list_item_start_bullet\n      end\n\n      ##\n      # Calls accept_list_item_start_label\n\n      def test_accept_list_item_start_label\n        @to.start_accepting\n\n        @to.accept_list_start @label_list\n\n        @to.accept_list_item_start @label_list.items.first\n\n        accept_list_item_start_label\n      end\n\n      ##\n      # Calls accept_list_item_start_lalpha\n\n      def test_accept_list_item_start_lalpha\n        @to.start_accepting\n\n        @to.accept_list_start @lalpha_list\n\n        @to.accept_list_item_start @lalpha_list.items.first\n\n        accept_list_item_start_lalpha\n      end\n\n      ##\n      # Calls accept_list_item_start_note\n\n      def test_accept_list_item_start_note\n        @to.start_accepting\n\n        @to.accept_list_start @note_list\n\n        @to.accept_list_item_start @note_list.items.first\n\n        accept_list_item_start_note\n      end\n\n      ##\n      # Calls accept_list_item_start_note_2\n\n      def test_accept_list_item_start_note_2\n        list = list(:NOTE,\n                 item('<tt>teletype</tt>',\n                   para('teletype description')))\n\n        @to.start_accepting\n\n        list.accept @to\n\n        @to.end_accepting\n\n        accept_list_item_start_note_2\n      end\n\n      ##\n      # Calls accept_list_item_start_note_multi_description\n\n      def test_accept_list_item_start_note_multi_description\n        list = list(:NOTE,\n                 item(%w[label],\n                   para('description one')),\n                 item(nil, para('description two')))\n\n        @to.start_accepting\n\n        list.accept @to\n\n        @to.end_accepting\n\n        accept_list_item_start_note_multi_description\n      end\n\n      ##\n      # Calls accept_list_item_start_note_multi_label\n\n      def test_accept_list_item_start_note_multi_label\n        list = list(:NOTE,\n                 item(%w[one two],\n                   para('two headers')))\n\n        @to.start_accepting\n\n        list.accept @to\n\n        @to.end_accepting\n\n        accept_list_item_start_note_multi_label\n      end\n\n      ##\n      # Calls accept_list_item_start_number\n\n      def test_accept_list_item_start_number\n        @to.start_accepting\n\n        @to.accept_list_start @number_list\n\n        @to.accept_list_item_start @number_list.items.first\n\n        accept_list_item_start_number\n      end\n\n      ##\n      # Calls accept_list_item_start_ualpha\n\n      def test_accept_list_item_start_ualpha\n        @to.start_accepting\n\n        @to.accept_list_start @ualpha_list\n\n        @to.accept_list_item_start @ualpha_list.items.first\n\n        accept_list_item_start_ualpha\n      end\n\n      ##\n      # Calls accept_list_item_end_bullet\n\n      def test_accept_list_item_end_bullet\n        @to.start_accepting\n\n        @to.accept_list_start @bullet_list\n\n        @to.accept_list_item_start @bullet_list.items.first\n\n        @to.accept_list_item_end @bullet_list.items.first\n\n        accept_list_item_end_bullet\n      end\n\n      ##\n      # Calls accept_list_item_end_label\n\n      def test_accept_list_item_end_label\n        @to.start_accepting\n\n        @to.accept_list_start @label_list\n\n        @to.accept_list_item_start @label_list.items.first\n\n        @to.accept_list_item_end @label_list.items.first\n\n        accept_list_item_end_label\n      end\n\n      ##\n      # Calls accept_list_item_end_lalpha\n\n      def test_accept_list_item_end_lalpha\n        @to.start_accepting\n\n        @to.accept_list_start @lalpha_list\n\n        @to.accept_list_item_start @lalpha_list.items.first\n\n        @to.accept_list_item_end @lalpha_list.items.first\n\n        accept_list_item_end_lalpha\n      end\n\n      ##\n      # Calls accept_list_item_end_note\n\n      def test_accept_list_item_end_note\n        @to.start_accepting\n\n        @to.accept_list_start @note_list\n\n        @to.accept_list_item_start @note_list.items.first\n\n        @to.accept_list_item_end @note_list.items.first\n\n        accept_list_item_end_note\n      end\n\n      ##\n      # Calls accept_list_item_end_number\n\n      def test_accept_list_item_end_number\n        @to.start_accepting\n\n        @to.accept_list_start @number_list\n\n        @to.accept_list_item_start @number_list.items.first\n\n        @to.accept_list_item_end @number_list.items.first\n\n        accept_list_item_end_number\n      end\n\n      ##\n      # Calls accept_list_item_end_ualpha\n\n      def test_accept_list_item_end_ualpha\n        @to.start_accepting\n\n        @to.accept_list_start @ualpha_list\n\n        @to.accept_list_item_start @ualpha_list.items.first\n\n        @to.accept_list_item_end @ualpha_list.items.first\n\n        accept_list_item_end_ualpha\n      end\n\n      ##\n      # Calls accept_list_start_bullet\n\n      def test_accept_list_start_bullet\n        @to.start_accepting\n\n        @to.accept_list_start @bullet_list\n\n        accept_list_start_bullet\n      end\n\n      ##\n      # Calls accept_list_start_label\n\n      def test_accept_list_start_label\n        @to.start_accepting\n\n        @to.accept_list_start @label_list\n\n        accept_list_start_label\n      end\n\n      ##\n      # Calls accept_list_start_lalpha\n\n      def test_accept_list_start_lalpha\n        @to.start_accepting\n\n        @to.accept_list_start @lalpha_list\n\n        accept_list_start_lalpha\n      end\n\n      ##\n      # Calls accept_list_start_note\n\n      def test_accept_list_start_note\n        @to.start_accepting\n\n        @to.accept_list_start @note_list\n\n        accept_list_start_note\n      end\n\n      ##\n      # Calls accept_list_start_number\n\n      def test_accept_list_start_number\n        @to.start_accepting\n\n        @to.accept_list_start @number_list\n\n        accept_list_start_number\n      end\n\n      ##\n      # Calls accept_list_start_ualpha\n\n      def test_accept_list_start_ualpha\n        @to.start_accepting\n\n        @to.accept_list_start @ualpha_list\n\n        accept_list_start_ualpha\n      end\n\n      ##\n      # Calls accept_list_end_bullet\n\n      def test_accept_list_end_bullet\n        @to.start_accepting\n\n        @to.accept_list_start @bullet_list\n\n        @to.accept_list_end @bullet_list\n\n        accept_list_end_bullet\n      end\n\n      ##\n      # Calls accept_list_end_label\n\n      def test_accept_list_end_label\n        @to.start_accepting\n\n        @to.accept_list_start @label_list\n\n        @to.accept_list_end @label_list\n\n        accept_list_end_label\n      end\n\n      ##\n      # Calls accept_list_end_lalpha\n\n      def test_accept_list_end_lalpha\n        @to.start_accepting\n\n        @to.accept_list_start @lalpha_list\n\n        @to.accept_list_end @lalpha_list\n\n        accept_list_end_lalpha\n      end\n\n      ##\n      # Calls accept_list_end_number\n\n      def test_accept_list_end_number\n        @to.start_accepting\n\n        @to.accept_list_start @number_list\n\n        @to.accept_list_end @number_list\n\n        accept_list_end_number\n      end\n\n      ##\n      # Calls accept_list_end_note\n\n      def test_accept_list_end_note\n        @to.start_accepting\n\n        @to.accept_list_start @note_list\n\n        @to.accept_list_end @note_list\n\n        accept_list_end_note\n      end\n\n      ##\n      # Calls accept_list_end_ualpha\n\n      def test_accept_list_end_ualpha\n        @to.start_accepting\n\n        @to.accept_list_start @ualpha_list\n\n        @to.accept_list_end @ualpha_list\n\n        accept_list_end_ualpha\n      end\n\n      ##\n      # Calls list_nested with a two-level list\n\n      def test_list_nested\n        doc = @RM::Document.new(\n                @RM::List.new(:BULLET,\n                  @RM::ListItem.new(nil,\n                    @RM::Paragraph.new('l1'),\n                    @RM::List.new(:BULLET,\n                      @RM::ListItem.new(nil,\n                        @RM::Paragraph.new('l1.1')))),\n                  @RM::ListItem.new(nil,\n                    @RM::Paragraph.new('l2'))))\n\n        doc.accept @to\n\n        list_nested\n      end\n\n      ##\n      # Calls list_verbatim with a list containing a verbatim block\n\n      def test_list_verbatim # HACK overblown\n        doc =\n          doc(\n            list(:BULLET,\n              item(nil,\n                para('list stuff'),\n                blank_line,\n                verb(\"* list\\n\",\n                     \"  with\\n\",\n                     \"\\n\",\n                     \"  second\\n\",\n                     \"\\n\",\n                     \"  1. indented\\n\",\n                     \"  2. numbered\\n\",\n                     \"\\n\",\n                     \"  third\\n\",\n                     \"\\n\",\n                     \"* second\\n\"))))\n\n        doc.accept @to\n\n        list_verbatim\n      end\n    end",
        "comment": " Call to add the visitor tests to your test case",
        "label": "How-to-use",
        "id": "1365"
    },
    {
        "raw_code": "def self.add_text_tests\n    self.class_eval do\n\n      ##\n      # Test case that calls <tt>@to.accept_heading</tt>\n\n      def test_accept_heading_indent\n        @to.start_accepting\n        @to.indent = 3\n        @to.accept_heading @RM::Heading.new(1, 'Hello')\n\n        accept_heading_indent\n      end\n\n      ##\n      # Test case that calls <tt>@to.accept_rule</tt>\n\n      def test_accept_rule_indent\n        @to.start_accepting\n        @to.indent = 3\n        @to.accept_rule @RM::Rule.new(1)\n\n        accept_rule_indent\n      end\n\n      ##\n      # Test case that calls <tt>@to.accept_verbatim</tt>\n\n      def test_accept_verbatim_indent\n        @to.start_accepting\n        @to.indent = 2\n        @to.accept_verbatim @RM::Verbatim.new(\"hi\\n\", \" world\\n\")\n\n        accept_verbatim_indent\n      end\n\n      ##\n      # Test case that calls <tt>@to.accept_verbatim</tt> with a big indent\n\n      def test_accept_verbatim_big_indent\n        @to.start_accepting\n        @to.indent = 2\n        @to.accept_verbatim @RM::Verbatim.new(\"hi\\n\", \"world\\n\")\n\n        accept_verbatim_big_indent\n      end\n\n      ##\n      # Test case that calls <tt>@to.accept_paragraph</tt> with an indent\n\n      def test_accept_paragraph_indent\n        @to.start_accepting\n        @to.indent = 3\n        @to.accept_paragraph @RM::Paragraph.new(('words ' * 30).strip)\n\n        accept_paragraph_indent\n      end\n\n      ##\n      # Test case that calls <tt>@to.accept_paragraph</tt> with a long line\n\n      def test_accept_paragraph_wrap\n        @to.start_accepting\n        @to.accept_paragraph @RM::Paragraph.new(('words ' * 30).strip)\n\n        accept_paragraph_wrap\n      end\n\n      ##\n      # Test case that calls <tt>@to.accept_table</tt>\n\n      def test_accept_table_align\n        header = ['AA', 'BB', 'CCCCC', 'DDDDD']\n        body = [\n          ['', 'bbb', 'c', ''],\n          ['aaaa', 'b', '', 'dd'],\n          ['a', '', 'cc', 'dd']\n        ]\n        aligns = [nil, :left, :right, :center]\n        @to.start_accepting\n        @to.accept_table header, body, aligns\n\n        accept_table_align\n      end\n\n      ##\n      # Test case that calls <tt>@to.attributes</tt> with an escaped\n      # cross-reference.  If this test doesn't pass something may be very\n      # wrong.\n\n      def test_attributes\n        assert_equal 'Dog', @to.attributes(\"\\\\Dog\")\n      end\n\n    end",
        "comment": " Adds test cases to the calling TestCase.",
        "label": "How-to-use",
        "id": "1366"
    },
    {
        "raw_code": "def setup\n    super\n\n    @orig_home = ENV[\"HOME\"]\n    FileUtils.mkdir_p(@test_home = Dir.mktmpdir(\"test_rdoc_\"))\n    ENV[\"HOME\"] = @test_home\n\n    @top_level = nil\n\n    @RM = RDoc::Markup\n\n    @pwd = Dir.pwd\n\n    @options = RDoc::Options.new\n    @store = RDoc::Store.new(@options)\n\n    @rdoc = RDoc::RDoc.new\n    @rdoc.store = @store\n    @rdoc.options = @options\n\n    @rdoc.generator = Object.new\n\n    RDoc::Markup::PreProcess.reset\n  end",
        "comment": " Abstract test-case setup",
        "label": "How-it-is-done",
        "id": "1367"
    },
    {
        "raw_code": "def teardown\n    ENV[\"HOME\"] = @orig_home if defined?(@orig_home)\n    defined?(@test_home) and FileUtils.rm_rf @test_home\n\n    super\n  end",
        "comment": " Abstract test-case teardown",
        "label": "How-it-is-done",
        "id": "1368"
    },
    {
        "raw_code": "def assert_file(path)\n    assert File.file?(path), \"#{path} is not a file\"\n  end",
        "comment": " Asserts +path+ is a file",
        "label": "Property",
        "id": "1369"
    },
    {
        "raw_code": "def assert_directory(path)\n    assert File.directory?(path), \"#{path} is not a directory\"\n  end",
        "comment": " Asserts +path+ is a directory",
        "label": "Property",
        "id": "1370"
    },
    {
        "raw_code": "def refute_file(path)\n    refute File.exist?(path), \"#{path} exists\"\n  end",
        "comment": " Refutes +path+ exists",
        "label": "Others",
        "id": "1371"
    },
    {
        "raw_code": "def blank_line\n    @RM::BlankLine.new\n  end",
        "comment": " Shortcut for RDoc::Markup::BlankLine.new",
        "label": "What",
        "id": "1372"
    },
    {
        "raw_code": "def block *contents\n    @RM::BlockQuote.new(*contents)\n  end",
        "comment": " Shortcut for RDoc::Markup::BlockQuote.new with +contents+",
        "label": "Property",
        "id": "1373"
    },
    {
        "raw_code": "def comment(text, top_level = @top_level, language = nil)\n    comment = RDoc::Comment.new text, top_level, language\n    comment\n  end",
        "comment": " Creates an RDoc::Comment with +text+ which was defined on +top_level+. By default the comment has the 'rdoc' format.",
        "label": "How-it-is-done",
        "id": "1374"
    },
    {
        "raw_code": "def doc *contents\n    @RM::Document.new(*contents)\n  end",
        "comment": " Shortcut for RDoc::Markup::Document.new with +contents+",
        "label": "How-to-use",
        "id": "1375"
    },
    {
        "raw_code": "def hard_break\n    @RM::HardBreak.new\n  end",
        "comment": " Shortcut for RDoc::Markup::HardBreak.new",
        "label": "What",
        "id": "1376"
    },
    {
        "raw_code": "def head(level, text)\n    @RM::Heading.new level, text\n  end",
        "comment": " Shortcut for RDoc::Markup::Heading.new with +level+ and +text+",
        "label": "How-to-use",
        "id": "1377"
    },
    {
        "raw_code": "def item label = nil, *parts\n    @RM::ListItem.new label, *parts\n  end",
        "comment": " Shortcut for RDoc::Markup::ListItem.new with +label+ and +parts+",
        "label": "Property",
        "id": "1378"
    },
    {
        "raw_code": "def list type = nil, *items\n    @RM::List.new type, *items\n  end",
        "comment": " Shortcut for RDoc::Markup::List.new with +type+ and +items+",
        "label": "How-to-use",
        "id": "1379"
    },
    {
        "raw_code": "def mu_pp(obj) # :nodoc:\n    s = obj.pretty_inspect\n    s = RDoc::Encoding.change_encoding s, Encoding.default_external\n    s.chomp\n  end",
        "comment": " Enables pretty-print output",
        "label": "How-to-use",
        "id": "1380"
    },
    {
        "raw_code": "def para *a\n    @RM::Paragraph.new(*a)\n  end",
        "comment": " Shortcut for RDoc::Markup::Paragraph.new with +contents+",
        "label": "How-to-use",
        "id": "1381"
    },
    {
        "raw_code": "def rule(weight)\n    @RM::Rule.new weight\n  end",
        "comment": " Shortcut for RDoc::Markup::Rule.new with +weight+",
        "label": "How-to-use",
        "id": "1382"
    },
    {
        "raw_code": "def raw *contents\n    @RM::Raw.new(*contents)\n  end",
        "comment": " Shortcut for RDoc::Markup::Raw.new with +contents+",
        "label": "Property",
        "id": "1383"
    },
    {
        "raw_code": "def temp_dir\n    Dir.mktmpdir do |temp_dir|\n      Dir.chdir temp_dir do\n        yield temp_dir\n      end",
        "comment": " Creates a temporary directory changes the current directory to it for the duration of the block.  Depends upon Dir.mktmpdir",
        "label": "How-it-is-done",
        "id": "1384"
    },
    {
        "raw_code": "def verb *parts\n    @RM::Verbatim.new(*parts)\n  end",
        "comment": " Shortcut for RDoc::Markup::Verbatim.new with +parts+",
        "label": "How-to-use",
        "id": "1385"
    },
    {
        "raw_code": "def verbose_capture_output\n    capture_output do\n      begin\n        orig_verbose = $VERBOSE\n        $VERBOSE = true\n        yield\n      ensure\n        $VERBOSE = orig_verbose\n      end",
        "comment": " run capture_io with setting $VERBOSE = true",
        "label": "What",
        "id": "1386"
    }
]