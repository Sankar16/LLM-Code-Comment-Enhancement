[
  {
    "raw_code": "def init\n  sections :list, [T('docstring')]\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "1"
  },
  {
    "raw_code": "def init\n  super\n  sections.place(:tag_list).after_any(:files)\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "2"
  },
  {
    "raw_code": "def generate_tag_list\n  @list_title = \"Tag List\"\n  @list_type = \"tag\"\n  asset('tag_list.html', erb(:full_list))\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "3"
  },
  {
    "raw_code": "def self.parse(*args) Parser::SourceParser.parse(*args) end\n\n  # An alias to {Parser::SourceParser}'s parsing method\n  #\n  # @example Parse a string of input\n  #   YARD.parse_string('class Foo; end')\n  # @see Parser::SourceParser.parse_string\n  def self.parse_string(*args) Parser::SourceParser.parse_string(*args) end\n\n  # (see YARD::Config.load_plugins)\n  # @deprecated Use {Config.load_plugins}\n  def self.load_plugins; YARD::Config.load_plugins end\n\n  # @return [Boolean] whether YARD is being run inside of Windows\n  def self.windows?\n    return @windows if defined? @windows\n    require 'rbconfig'\n    @windows =\n      ::RbConfig::CONFIG['host_os'] =~ /mingw|win32|cygwin/ ? true : false\n  ensure\n    @windows ||= false\n  end\n\n  # @return [Boolean] whether YARD is being run in Ruby 1.8 mode\n  def self.ruby18?; !ruby19? end\n\n  # @return [Boolean] whether YARD is being run in Ruby 1.9 mode\n  def self.ruby19?; @ruby19 ||= (RUBY_VERSION >= \"1.9.1\") end\n\n  # @return [Boolean] whether YARD is being run in Ruby 2.0\n  def self.ruby2?; @ruby2 ||= (RUBY_VERSION >= '2.0.0') end\n\n  # @return [Boolean] whether YARD is being run in Ruby 3.0\n  def self.ruby3?; @ruby3 ||= (RUBY_VERSION >= '3.0.0') end\n\n  # @return [Boolean] whether YARD is being run in Ruby 3.1\n  def self.ruby31?; @ruby31 ||= (RUBY_VERSION >= '3.1.0') end\nend\n\n# Keep track of Ruby version for compatibility code\n# @deprecated Use {YARD.ruby18?} or {YARD.ruby19?} instead.\nRUBY18 = YARD.ruby18?\nRUBY19 = YARD.ruby19?\n\n# Load Ruby core extension classes\nDir.glob(File.join(YARD::ROOT, 'yard', 'core_ext', '*.rb')).each do |file|\n  require file\nend\n\n# Backport RubyGems SourceIndex and other classes\nrequire File.join(YARD::ROOT, 'yard', 'rubygems', 'backports')\n\nrequire File.join(YARD::ROOT, 'yard', 'globals')\n\n# Load YARD configuration options (and plugins)\nYARD::Config.load",
    "comment": "An alias to {Parser::SourceParser}'s parsing method  @example Parse a glob of files YARD.parse('lib/**/*.rb') @see Parser::SourceParser.parse",
    "label": "",
    "id": "4"
  },
  {
    "raw_code": "def yardoc_file_for_gem(gem, ver_require = \">= 0\", for_writing = false)\n        specs = YARD::GemIndex.find_all_by_name(gem, ver_require)\n        return if specs.empty?\n\n        result = nil\n        specs.reverse.each do |spec|\n          if gem =~ /^yard-doc-/\n            path = File.join(spec.full_gem_path, DEFAULT_YARDOC_FILE)\n            result = File.exist?(path) && !for_writing ? path : nil\n            result ? break : next\n          end",
    "comment": "@group Getting .yardoc File Locations Returns the .yardoc file associated with a gem.  @param [String] gem the name of the gem to search for @param [String] ver_require an optional Gem version requirement @param [Boolean] for_writing whether or not the method should search for writable locations @return [String] if +for_writing+ is set to +true+, returns the best location suitable to write the .yardoc file. Otherwise, the first existing location associated with the gem's .yardoc file. @return [nil] if +for_writing+ is set to false and no yardoc file is found, returns nil.",
    "label": "",
    "id": "5"
  },
  {
    "raw_code": "def load_yardoc(file = yardoc_file)\n        clear\n        thread_local_store.load(file)\n        self\n      end",
    "comment": "Loads a yardoc file directly  @param [String] file the yardoc file to load. @return [Registry] the registry object (for chaining)",
    "label": "",
    "id": "6"
  },
  {
    "raw_code": "def load!(file = yardoc_file)\n        clear\n        thread_local_store.load!(file)\n        self\n      end",
    "comment": "Loads a yardoc file and forces all objects cached on disk into memory. Equivalent to calling {load_yardoc} followed by {load_all}  @param [String] file the yardoc file to load @return [Registry] the registry object (for chaining) @see #load_yardoc @see #load_all @since 0.5.1",
    "label": "",
    "id": "7"
  },
  {
    "raw_code": "def load_all\n        thread_local_store.load_all\n        self\n      end",
    "comment": "Forces all objects cached on disk into memory  @example Loads all objects from disk Registry.load Registry.all.count #=> 0 Registry.load_all Registry.all.count #=> 17 @return [Registry] the registry object (for chaining) @since 0.5.1",
    "label": "",
    "id": "8"
  },
  {
    "raw_code": "def save(merge = false, file = yardoc_file)\n        thread_local_store.save(merge, file)\n      end",
    "comment": "@group Saving and Deleting Data from Disk Saves the registry to +file+  @param [String] file the yardoc file to save to @return [Boolean] true if the file was saved",
    "label": "",
    "id": "9"
  },
  {
    "raw_code": "def delete_from_disk\n        thread_local_store.destroy\n      end",
    "comment": "Deletes the yardoc file from disk @return [void]",
    "label": "",
    "id": "10"
  },
  {
    "raw_code": "def register(object)\n        return if object.is_a?(CodeObjects::Proxy)\n        thread_local_store[object.path] = object\n      end",
    "comment": "@group Adding and Deleting Objects from the Registry Registers a new object with the registry  @param [CodeObjects::Base] object the object to register @return [CodeObjects::Base] the registered object",
    "label": "",
    "id": "11"
  },
  {
    "raw_code": "def delete(object)\n        thread_local_store.delete(object.path)\n      end",
    "comment": "Deletes an object from the registry @param [CodeObjects::Base] object the object to remove @return [void]",
    "label": "",
    "id": "12"
  },
  {
    "raw_code": "def clear\n        self.thread_local_store = RegistryStore.new\n      end",
    "comment": "Clears the registry @return [void]",
    "label": "",
    "id": "13"
  },
  {
    "raw_code": "def lock_for_writing(file = yardoc_file, &block)\n        thread_local_store.lock_for_writing(file, &block)\n      end",
    "comment": "Creates a pessmistic transactional lock on the database for writing. Use with {YARD.parse} to ensure the database is not written multiple times.  @see locked_for_writing?",
    "label": "",
    "id": "14"
  },
  {
    "raw_code": "def locked_for_writing?(file = yardoc_file)\n        thread_local_store.locked_for_writing?(file)\n      end",
    "comment": "(see Serializers::YardocSerializer#locked_for_writing?)",
    "label": "",
    "id": "15"
  },
  {
    "raw_code": "def each(&block)\n        all.each(&block)\n      end",
    "comment": "@group Accessing Objects in the Registry Iterates over {all} with no arguments",
    "label": "",
    "id": "16"
  },
  {
    "raw_code": "def all(*types)\n        if types.empty?\n          thread_local_store.values.select {|obj| obj != root }\n        else\n          list = []\n          types.each do |type|\n            list += thread_local_store.values_for_type(type)\n          end",
    "comment": "Returns all objects in the registry that match one of the types provided in the +types+ list (if +types+ is provided).  @example Returns all objects Registry.all @example Returns all classes and modules Registry.all(:class, :module) @param [Array<Symbol>] types an optional list of types to narrow the objects down by. Equivalent to performing a select: +Registry.all.select {|o| types.include(o.type) }+ @return [Array<CodeObjects::Base>] the list of objects found @see CodeObjects::Base#type",
    "label": "",
    "id": "17"
  },
  {
    "raw_code": "def paths(reload = false)\n        thread_local_store.keys(reload).map(&:to_s)\n      end",
    "comment": "Returns the paths of all of the objects in the registry. @param [Boolean] reload whether to load entire database @return [Array<String>] all of the paths in the registry.",
    "label": "",
    "id": "18"
  },
  {
    "raw_code": "def at(path) path ? thread_local_store[path] : nil end\n      alias [] at\n\n      # The root namespace object.\n      # @return [CodeObjects::RootObject] the root object in the namespace\n      def root; thread_local_store[:root] end\n\n      # @param [String] name the locale name.\n      # @return [I18n::Locale] the locale object for +name+.\n      # @since 0.8.3\n      def locale(name)\n        thread_local_store.locale(name)\n      end\n\n      # Attempts to find an object by name starting at +namespace+, performing\n      # a lookup similar to Ruby's method of resolving a constant in a namespace.\n      #\n      # @example Looks for instance method #reverse starting from A::B::C\n      #   Registry.resolve(P(\"A::B::C\"), \"#reverse\")\n      # @example Looks for a constant in the root namespace\n      #   Registry.resolve(nil, 'CONSTANT')\n      # @example Looks for a class method respecting the inheritance tree\n      #   Registry.resolve(myclass, 'mymethod', true)\n      # @example Looks for a constant but returns a proxy if not found\n      #   Registry.resolve(P('A::B::C'), 'D', false, true) # => #<yardoc proxy A::B::C::D>\n      # @example Looks for a complex path from a namespace\n      #   Registry.resolve(P('A::B'), 'B::D') # => #<yardoc class A::B::D>\n      # @param [CodeObjects::NamespaceObject, nil] namespace the starting namespace\n      #   (module or class). If +nil+ or +:root+, starts from the {root} object.\n      # @param [String, Symbol] name the name (or complex path) to look for from\n      #   +namespace+.\n      # @param [Boolean] inheritance Follows inheritance chain (mixins, superclass)\n      #   when performing name resolution if set to +true+.\n      # @param [Boolean] proxy_fallback If +true+, returns a proxy representing\n      #   the unresolved path (namespace + name) if no object is found.\n      # @param [Symbol, nil] type the {CodeObjects::Base#type} that the resolved\n      #   object must be equal to. No type checking if nil.\n      # @return [CodeObjects::Base] the object if it is found\n      # @return [CodeObjects::Proxy] a Proxy representing the object if\n      #   +proxy_fallback+ is +true+.\n      # @return [nil] if +proxy_fallback+ is +false+ and no object was found.\n      # @see P\n      def resolve(namespace, name, inheritance = false, proxy_fallback = false, type = nil)\n        thread_local_resolver.lookup_by_path name,\n          :namespace => namespace, :inheritance => inheritance,\n          :proxy_fallback => proxy_fallback, :type => type\n      end\n\n      # @group Managing Source File Checksums\n\n      # @return [Hash{String => String}] a set of checksums for files\n      def checksums\n        thread_local_store.checksums\n      end\n\n      # @param [String] data data to checksum\n      # @return [String] the SHA1 checksum for data\n      def checksum_for(data)\n        Digest::SHA1.hexdigest(data)\n      end\n\n      # @group Managing Internal State (Advanced / Testing Only)\n\n      # Whether or not the Registry storage should load everything into a\n      # single object database (for disk efficiency), or spread them out\n      # (for load time efficiency).\n      #\n      # @note Setting this attribute to nil will offload the decision to\n      #   the {RegistryStore storage adapter}.\n      # @return [Boolean, nil] if this value is set to nil, the storage\n      #   adapter will decide how to store the data.\n      attr_accessor :single_object_db\n      undef single_object_db, single_object_db=\n      def single_object_db=(v) Thread.current[:__yard_single_db__] = v end\n      def single_object_db; Thread.current[:__yard_single_db__] end\n\n      # The assumed types of a list of paths. This method is used by CodeObjects::Base\n      # @return [{String => Symbol}] a set of unresolved paths and their assumed type\n      # @private\n      # @deprecated The registry no longer globally tracks proxy types.\n      def proxy_types\n        thread_local_store.proxy_types\n      end\n\n      # @group I18n features\n\n      # Gets/sets the directory that has LANG.po files\n      # @return [String] the directory that has .po files\n      attr_accessor :po_dir\n      undef po_dir, po_dir=\n      def po_dir=(dir) Thread.current[:__yard_po_dir__] = dir end\n\n      def po_dir\n        Thread.current[:__yard_po_dir__] ||= DEFAULT_PO_DIR\n      end\n\n      # @group Legacy Methods\n\n      # The registry singleton instance.\n      #\n      # @deprecated use Registry.methodname directly.\n      # @return [Registry] returns the registry instance\n      def instance; self end\n\n      private\n\n      # @group Accessing Objects in the Registry\n\n      # Attempts to resolve a name in a namespace\n      #\n      # @param [CodeObjects::NamespaceObject] namespace the starting namespace\n      # @param [String] name the name to look for\n      # @param [Symbol, nil] type the {CodeObjects::Base#type} that the resolved\n      #   object must be equal to\n      def partial_resolve(namespace, name, type = nil)\n        obj = at(name) || at('#' + name) if namespace.root?\n        return obj if obj && (type.nil? || obj.type == type)\n        [CodeObjects::NSEP, CodeObjects::CSEP, ''].each do |s|\n          next if s.empty? && name =~ /^\\w/\n          path = name\n          path = [namespace.path, name].join(s) if namespace != root\n          found = at(path)\n          return found if found && (type.nil? || found.type == type)\n        end\n        nil\n      end\n\n      # @group Retrieving yardoc File Locations\n\n      def global_yardoc_file(spec, for_writing = false)\n        path = spec.doc_dir\n        yfile = spec.doc_dir(DEFAULT_YARDOC_FILE)\n        if for_writing\n          if File.writable?(path) ||\n             (!File.directory?(path) && File.writable?(File.dirname(path)))\n            return yfile\n          end\n        elsif !for_writing && File.exist?(yfile)\n          return yfile\n        end\n      end\n\n      def old_global_yardoc_file(spec, for_writing = false)\n        path = spec.full_gem_path\n        yfile = File.join(path, DEFAULT_YARDOC_FILE)\n        return yfile if for_writing && File.writable?(path)\n        return yfile if !for_writing && File.exist?(yfile)\n      end\n\n      def local_yardoc_file(spec, for_writing = false)\n        path = Registry::LOCAL_YARDOC_INDEX\n        FileUtils.mkdir_p(path) if for_writing\n        path = File.join(path, \"#{spec.full_name}.yardoc\")\n        if for_writing\n          path\n        else\n          File.exist?(path) ? path : nil\n        end\n      end\n\n      # @group Threading support\n\n      # @since 0.6.5\n      def thread_local_store\n        Thread.current[:__yard_registry__] ||= clear\n      end\n\n      # @since 0.6.5\n      def thread_local_store=(value)\n        Thread.current[:__yard_registry__] = value\n      end\n\n      # @since 0.9.1\n      def thread_local_resolver\n        Thread.current[:__yard_resolver__] ||= RegistryResolver.new\n      end\n    end\n  end",
    "comment": "Returns the object at a specific path. @param [String, :root] path the pathname to look for. If +path+ is +root+, returns the {root} object. @return [CodeObjects::Base] the object at path @return [nil] if no object is found",
    "label": "",
    "id": "19"
  },
  {
    "raw_code": "def initialize(library = Tags::Library.instance)\n      @text = \"\"\n      @raw_text = \"\"\n      @tags = []\n      @directives = []\n      @library = library\n      @object = nil\n      @reference = nil\n      @handler = nil\n      @state = OpenStruct.new\n    end",
    "comment": "@!group Creation and Conversion Methods Creates a new parser to parse docstring data  @param [Tags::Library] library a tag library for recognizing tags.",
    "label": "",
    "id": "20"
  },
  {
    "raw_code": "def to_docstring\n      Docstring.new!(text, tags, object, raw_text, reference)\n    end",
    "comment": "@return [Docstring] translates parsed text into a Docstring object.",
    "label": "",
    "id": "21"
  },
  {
    "raw_code": "def parse(content, object = nil, handler = nil)\n      @object = object\n      @handler = handler\n      @reference, @raw_text = detect_reference(content)\n      text = parse_content(@raw_text)\n      @text = text.strip\n      call_directives_after_parse\n      post_process\n      self\n    end",
    "comment": "@!group Parsing Methods Parses all content and returns itself.  @param [String] content the docstring text to parse @param [CodeObjects::Base] object the object that the docstring is attached to. Will be passed to directives to act on this object. @param [Handlers::Base, nil] handler the handler object that is parsing this object. May be nil if this parser is not being called from a {Parser::SourceParser} context. @return [self] the parser object. To get the docstring, call {#to_docstring}. @see #to_docstring",
    "label": "",
    "id": "22"
  },
  {
    "raw_code": "def parse_content(content)\n      content = content.split(/\\r?\\n/) if content.is_a?(String)\n      return '' if !content || content.empty?\n      docstring = String.new(\"\")\n\n      indent = content.first[/^\\s*/].length\n      last_indent = 0\n      orig_indent = 0\n      directive = false\n      last_line = \"\"\n      tag_name = nil\n      tag_buf = []\n\n      (content + ['']).each_with_index do |line, index|\n        indent = line[/^\\s*/].length\n        empty = (line =~ /^\\s*$/ ? true : false)\n        done = content.size == index\n\n        if tag_name && (((indent < orig_indent && !empty) || done ||\n            (indent == 0 && !empty)) || (indent <= last_indent && line =~ META_MATCH))\n          buf = tag_buf.join(\"\\n\")\n          if directive || tag_is_directive?(tag_name)\n            directive = create_directive(tag_name, buf)\n            if directive\n              docstring << parse_content(directive.expanded_text).chomp\n            end",
    "comment": "Parses a given block of text.  @param [String] content the content to parse @note Subclasses can override this method to perform custom parsing of content data.",
    "label": "",
    "id": "23"
  },
  {
    "raw_code": "def post_process\n      call_after_parse_callbacks\n    end",
    "comment": "@!group Parser Callback Methods Call post processing callbacks on parser. This is called implicitly by parser. Use this when manually configuring a {Docstring} object.  @return [void]",
    "label": "",
    "id": "24"
  },
  {
    "raw_code": "def create_tag(tag_name, tag_buf = '')\n      if tag_buf =~ /\\A\\s*(?:(\\S+)\\s+)?\\(\\s*see\\s+(\\S+)\\s*\\)\\s*\\Z/\n        return create_ref_tag(tag_name, $1, $2)\n      end",
    "comment": "@!group Tag Manipulation Methods Creates a tag from the {Tags::DefaultFactory tag factory}.  To add an already created tag object, append it to {#tags}.  @param [String] tag_name the tag name @param [String] tag_buf the text attached to the tag with newlines removed. @return [Tags::Tag, Tags::RefTag] a tag",
    "label": "",
    "id": "25"
  },
  {
    "raw_code": "def create_ref_tag(tag_name, name, object_name)\n      @tags << Tags::RefTagList.new(tag_name, P(object, object_name), name)\n    end",
    "comment": "Creates a {Tags::RefTag}",
    "label": "",
    "id": "26"
  },
  {
    "raw_code": "def create_directive(tag_name, tag_buf)\n      if library.has_directive?(tag_name)\n        dir = library.directive_create(tag_name, tag_buf, self)\n        if dir.is_a?(Tags::Directive)\n          @directives << dir\n          dir\n        end",
    "comment": "Creates a new directive using the registered {#library} @return [Tags::Directive] the directive object that is created",
    "label": "",
    "id": "27"
  },
  {
    "raw_code": "def tag_is_directive?(tag_name)\n      list = %w(attribute endgroup group macro method scope visibility)\n      list.include?(tag_name)\n    end",
    "comment": "Backward compatibility to detect old tags that should be specified as directives in 0.8 and onward.",
    "label": "",
    "id": "28"
  },
  {
    "raw_code": "def self.after_parse(&block)\n      after_parse_callbacks << block\n    end",
    "comment": "Creates a callback that is called after a docstring is successfully parsed. Use this method to perform sanity checks on a docstring's tag data, or add any extra tags automatically to a docstring.  @yield [parser] a block to be called after a docstring is parsed @yieldparam [DocstringParser] parser the docstring parser object with all directives and tags created. @yieldreturn [void] @return [void]",
    "label": "",
    "id": "29"
  },
  {
    "raw_code": "def self.after_parse_callbacks\n      @after_parse_callbacks ||= []\n    end",
    "comment": "@return [Array<Proc>] the {after_parse} callback proc objects",
    "label": "",
    "id": "30"
  },
  {
    "raw_code": "def call_directives_after_parse\n      directives.each(&:after_parse)\n    end",
    "comment": "@!group Parser Callback Methods Calls the {Tags::Directive#after_parse} callback on all the created directives.",
    "label": "",
    "id": "31"
  },
  {
    "raw_code": "def call_after_parse_callbacks\n      self.class.after_parse_callbacks.each do |cb|\n        cb.call(self)\n      end",
    "comment": "Calls all {after_parse} callbacks",
    "label": "",
    "id": "32"
  },
  {
    "raw_code": "def initialize(*expressions)\n      @expressions = []\n      add_expressions(*expressions)\n    end",
    "comment": "Creates a verifier from a set of expressions  @param [Array<String>] expressions a list of Ruby expressions to parse.",
    "label": "",
    "id": "33"
  },
  {
    "raw_code": "def add_expressions(*expressions)\n      self.expressions += expressions.flatten\n    end",
    "comment": "Adds a set of expressions and recompiles the verifier  @param [Array<String>] expressions a list of expressions @return [void] @since 0.5.6",
    "label": "",
    "id": "34"
  },
  {
    "raw_code": "def method_missing(sym, *args, &block)\n      if object.respond_to?(sym)\n        object.send(sym, *args, &block)\n      else\n        super\n      end",
    "comment": "Passes any method calls to the object from the {#call}",
    "label": "",
    "id": "35"
  },
  {
    "raw_code": "def call(object)\n      return true if object.is_a?(CodeObjects::Proxy)\n      modify_nilclass\n      @object = object\n      retval = __execute ? true : false\n      unmodify_nilclass\n      retval\n    end",
    "comment": "Tests the expressions on the object.  @note If the object is a {CodeObjects::Proxy} the result will always be true. @param [CodeObjects::Base] object the object to verify @return [Boolean] the result of the expressions",
    "label": "",
    "id": "36"
  },
  {
    "raw_code": "def run(list)\n      list.reject {|item| call(item).is_a?(FalseClass) }\n    end",
    "comment": "Runs a list of objects against the verifier and returns the subset of verified objects.  @param [Array<CodeObjects::Base>] list a list of code objects @return [Array<CodeObjects::Base>] a list of code objects that match the verifier.",
    "label": "",
    "id": "37"
  },
  {
    "raw_code": "def modify_nilclass\n      NILCLASS_METHODS.each do |meth|\n        NilClass.send(:define_method, meth) {|*args| }\n      end",
    "comment": "Modifies nil to not throw NoMethodErrors. This allows syntax like object.tag(:return).text to work if the #tag call returns nil, which means users don't need to perform stringent nil checking  @return [void]",
    "label": "",
    "id": "38"
  },
  {
    "raw_code": "def unmodify_nilclass\n      NILCLASS_METHODS.each do |meth|\n        next unless nil.respond_to?(meth)\n        NilClass.send(:remove_method, meth)\n      end",
    "comment": "Returns the state of NilClass back to normal @return [void]",
    "label": "",
    "id": "39"
  },
  {
    "raw_code": "def create_method_from_expressions\n      expr = expressions.map {|e| \"(#{parse_expression(e)})\" }.join(\" && \")\n\n      instance_eval(<<-eof, __FILE__, __LINE__ + 1)\n        begin; undef __execute; rescue NameError; end\n        def __execute; #{expr}; end\n      eof\n    end\n\n    # Parses a single expression, handling some of the DSL syntax.\n    #\n    # The syntax \"@tag\" should be turned into object.tag(:tag),\n    # and \"@@tag\" should be turned into object.tags(:tag)\n    #\n    # @return [String] the parsed expression\n    def parse_expression(expr)\n      expr = expr.gsub(/@@(?:(\\w+)|\\{([\\w\\.]+)\\})/, 'object.tags(\"\\1\\2\")')\n      expr = expr.gsub(/@(?:(\\w+)|\\{([\\w\\.]+)\\})/, 'object.tag(\"\\1\\2\")')\n      expr\n    end\n  end",
    "comment": "Creates the +__execute+ method by evaluating the expressions as Ruby code @return [void]",
    "label": "",
    "id": "40"
  },
  {
    "raw_code": "def get(key)\n      key = :root if key == ''\n      key = key.to_sym\n      return @store[key] if @store[key]\n      return if @loaded_objects >= @available_objects\n\n      # check disk\n      return if @notfound[key]\n      obj = @serializer.deserialize(key)\n      if obj\n        @loaded_objects += 1\n        put(key, obj)\n      else\n        @notfound[key] = true\n        nil\n      end",
    "comment": "Gets a {CodeObjects::Base} from the store  @param [String, Symbol] key the path name of the object to look for. If it is empty or :root, returns the {#root} object. @return [CodeObjects::Base, nil] a code object or nil if none is found",
    "label": "",
    "id": "41"
  },
  {
    "raw_code": "def put(key, value)\n      if key == ''\n        @object_types[:root] = [:root]\n        @store[:root] = value\n      else\n        @notfound.delete(key.to_sym)\n        (@object_types[value.type] ||= []) << key.to_s\n        if @store[key.to_sym]\n          @object_types[@store[key.to_sym].type].delete(key.to_s)\n        end",
    "comment": "Associates an object with a path @param [String, Symbol] key the path name (:root or '' for root object) @param [CodeObjects::Base] value the object to store @return [CodeObjects::Base] returns +value+",
    "label": "",
    "id": "42"
  },
  {
    "raw_code": "def delete(key)\n      if @store[key.to_sym]\n        @object_types[@store[key.to_sym].type].delete(key.to_s)\n        @store.delete(key.to_sym)\n      end",
    "comment": "Deletes an object at a given path @param [#to_sym] key the key to delete @return [void]",
    "label": "",
    "id": "43"
  },
  {
    "raw_code": "def keys(reload = false) load_all if reload; @store.keys end\n\n    # Gets all code objects from the store. Loads the entire database\n    # if +reload+ is +true+\n    #\n    # @param [Boolean] reload if false, does not load the entire database\n    #   before a lookup.\n    # @return [Array<CodeObjects::Base>] all the code objects\n    def values(reload = false) load_all if reload; @store.values end\n\n    # @param [Symbol] type the type to look for\n    # @return [Array<String>] a list of object paths with a given\n    #   {CodeObjects::Base#type}\n    # @since 0.8.0\n    def paths_for_type(type, reload = false)\n      load_all if reload\n      @object_types[type] || []\n    end\n\n    # @param [Symbol] type the type to look for\n    # @return [Array<CodeObjects::Base>] a list of objects with a given\n    #   {CodeObjects::Base#type}\n    # @since 0.8.0\n    def values_for_type(type, reload = false)\n      load_all if reload\n      paths_for_type(type).map {|t| @store[t.to_sym] }\n    end\n\n    # @return [CodeObjects::RootObject] the root object\n    def root; @store[:root] end\n\n    # @param [String] name the locale name.\n    # @return [I18n::Locale] the locale object for +name+.\n    # @since 0.8.3\n    def locale(name)\n      @locales[name] ||= load_locale(name)\n    end\n\n    # @param [String, nil] file the name of the yardoc db to load\n    # @return [Boolean] whether the database was loaded\n    def load(file = nil)\n      initialize\n      @file = file\n      @serializer = Serializers::YardocSerializer.new(@file)\n      load_yardoc\n    end\n\n    # Loads the .yardoc file and loads all cached objects into memory\n    # automatically.\n    #\n    # @param [String, nil] file the name of the yardoc db to load\n    # @return [Boolean] whether the database was loaded\n    # @see #load_all\n    # @since 0.5.1\n    def load!(file = nil)\n      if load(file)\n        load_all\n        true\n      else\n        false\n      end\n    end\n\n    # Loads all cached objects into memory\n    # @return [void]\n    def load_all\n      return unless @file\n      return if @loaded_objects >= @available_objects\n      log.debug \"Loading entire database: #{@file} ...\"\n      objects = []\n\n      all_disk_objects.sort_by(&:size).each do |path|\n        obj = @serializer.deserialize(path, true)\n        objects << obj if obj\n      end\n\n      objects.each do |obj|\n        put(obj.path, obj)\n      end\n\n      @loaded_objects += objects.size\n      log.debug \"Loaded database (file='#{@file}' count=#{objects.size} total=#{@available_objects})\"\n    end",
    "comment": "Gets all path names from the store. Loads the entire database if +reload+ is +true+  @param [Boolean] reload if false, does not load the entire database before a lookup. @return [Array<Symbol>] the path names of all the code objects",
    "label": "",
    "id": "44"
  },
  {
    "raw_code": "def save(merge = true, file = nil)\n      if file && file != @file\n        @file = file\n        @serializer = Serializers::YardocSerializer.new(@file)\n      end",
    "comment": "Saves the database to disk @param [Boolean] merge if true, merges the data in memory with the data on disk, otherwise the data on disk is deleted. @param [String, nil] file if supplied, the name of the file to save to @return [Boolean] whether the database was saved",
    "label": "",
    "id": "45"
  },
  {
    "raw_code": "def lock_for_writing(file = nil, &block)\n      Serializers::YardocSerializer.new(file || @file).lock_for_writing(&block)\n    end",
    "comment": "(see Serializers::YardocSerializer#lock_for_writing) @param file [String] if supplied, the path to the database",
    "label": "",
    "id": "46"
  },
  {
    "raw_code": "def locked_for_writing?(file = nil)\n      Serializers::YardocSerializer.new(file || @file).locked_for_writing?\n    end",
    "comment": "(see Serializers::YardocSerializer#locked_for_writing?) @param file [String] if supplied, the path to the database",
    "label": "",
    "id": "47"
  },
  {
    "raw_code": "def destroy(force = false)\n      if (!force && file =~ /\\.yardoc$/) || force\n        if File.file?(@file)\n          # Handle silent upgrade of old .yardoc format\n          File.unlink(@file)\n        elsif File.directory?(@file)\n          FileUtils.rm_rf(@file)\n        end",
    "comment": "Deletes the .yardoc database on disk  @param [Boolean] force if force is not set to true, the file/directory will only be removed if it ends with .yardoc. This helps with cases where the directory might have been named incorrectly. @return [Boolean] true if the .yardoc database was deleted, false otherwise.",
    "label": "",
    "id": "48"
  },
  {
    "raw_code": "def proxy_types_path\n      @serializer.proxy_types_path\n    end",
    "comment": "@deprecated The registry no longer tracks proxy types",
    "label": "",
    "id": "49"
  },
  {
    "raw_code": "def load_proxy_types\n      return unless File.file?(proxy_types_path)\n      @proxy_types = Marshal.load(File.read_binary(proxy_types_path))\n    end",
    "comment": "@deprecated The registry no longer tracks proxy types",
    "label": "",
    "id": "50"
  },
  {
    "raw_code": "def write_proxy_types\n      File.open!(proxy_types_path, 'wb') {|f| f.write(Marshal.dump(@proxy_types)) }\n    end",
    "comment": "@deprecated The registry no longer tracks proxy types",
    "label": "",
    "id": "51"
  },
  {
    "raw_code": "def __p(path) File.join(YARD::ROOT, 'yard', *path.split('/')); end\n\nmodule YARD\n  module CLI # Namespace for command-line interface components\n    autoload :Command,         __p('cli/command')\n    autoload :CommandParser,   __p('cli/command_parser')\n    autoload :Config,          __p('cli/config')\n    autoload :Diff,            __p('cli/diff')\n    autoload :Display,         __p('cli/display')\n    autoload :Gems,            __p('cli/gems')\n    autoload :Graph,           __p('cli/graph')\n    autoload :Help,            __p('cli/help')\n    autoload :List,            __p('cli/list')\n    autoload :MarkupTypes,     __p('cli/markup_types')\n    autoload :Server,          __p('cli/server')\n    autoload :Stats,           __p('cli/stats')\n    autoload :Yardoc,          __p('cli/yardoc')\n    autoload :YardoptsCommand, __p('cli/yardopts_command')\n    autoload :YRI,             __p('cli/yri')\n    autoload :I18n,            __p('cli/i18n')\n  end",
    "comment": "frozen_string_literal: true @private",
    "label": "",
    "id": "52"
  },
  {
    "raw_code": "def self.default_attr(key, default)\n      (@defaults ||= {})[key] = default\n      attr_accessor(key)\n    end",
    "comment": "@!macro [attach] yard.default_attr @!attribute $1 Defines an attribute named +key+ and sets a default value for it  @example Defining a default option key default_attr :name, 'Default Name' default_attr :time, lambda { Time.now } @param [Symbol] key the option key name @param [Object, Proc] default the default object value. If the default value is a proc, it is executed upon initialization.",
    "label": "",
    "id": "53"
  },
  {
    "raw_code": "def [](key) send(key) end\n\n    # Delegates setter calls with Hash syntax to the attribute setter with the key name\n    #\n    # @example Setting an option with Hash syntax\n    #   options[:format] = :html # equivalent to: options.format = :html\n    # @param [Symbol, String] key the option to set\n    # @param [Object] value the value to set for the option\n    # @return [Object] the value being set\n    def []=(key, value) send(\"#{key}=\", value) end\n\n    # Updates values from an options hash or options object on this object.\n    # All keys passed should be key names defined by attributes on the class.\n    #\n    # @example Updating a set of options on an Options object\n    #   opts.update(:template => :guide, :type => :fulldoc)\n    # @param [Hash, Options] opts\n    # @return [self]\n    def update(opts)\n      opts = opts.to_hash if Options === opts\n      opts.each do |key, value|\n        self[key] = value\n      end\n      self\n    end\n\n    # Creates a new options object and sets options hash or object value\n    # onto that object.\n    #\n    # @param [Options, Hash] opts\n    # @return [Options] the newly created options object\n    # @see #update\n    def merge(opts)\n      dup.update(opts)\n    end\n\n    # @return [Hash] Converts options object to an options hash. All keys\n    #   will be symbolized.\n    def to_hash\n      opts = {}\n      instance_variables.each do |ivar|\n        name = ivar.to_s.sub(/^@/, '')\n        opts[name.to_sym] = send(name)\n      end\n      opts\n    end",
    "comment": "Delegates calls with Hash syntax to actual method with key name  @example Calling on an option key with Hash syntax options[:format] # equivalent to: options.format @param [Symbol, String] key the option name to access @return the value of the option named +key+",
    "label": "",
    "id": "54"
  },
  {
    "raw_code": "def each\n      instance_variables.each do |ivar|\n        name = ivar.to_s.sub(/^@/, '')\n        yield(name.to_sym, send(name))\n      end",
    "comment": "Yields over every option key and value @yield [key, value] every option key and value @yieldparam [Symbol] key the option key @yieldparam [Object] value the option value @return [void]",
    "label": "",
    "id": "55"
  },
  {
    "raw_code": "def inspect\n      \"<#{self.class}: #{to_hash.inspect}>\"\n    end",
    "comment": "Inspects the object",
    "label": "",
    "id": "56"
  },
  {
    "raw_code": "def ==(other)\n      case other\n      when Options; to_hash == other.to_hash\n      when Hash; to_hash == other\n      else false\n      end",
    "comment": "@return [Boolean] whether another Options object equals the keys and values of this options object",
    "label": "",
    "id": "57"
  },
  {
    "raw_code": "def method_missing(meth, *args, &block)\n      if meth.to_s =~ /^(.+)=$/\n        log.debug \"Attempting to set unregistered key #{$1} on #{self.class}\"\n        instance_variable_set(\"@#{$1}\", args.first)\n      elsif args.empty?\n        log.debug \"Attempting to access unregistered key #{meth} on #{self.class}\"\n        instance_variable_defined?(\"@#{meth}\") ? instance_variable_get(\"@#{meth}\") : nil\n      else\n        super\n      end",
    "comment": "Handles setting and accessing of unregistered keys similar to an OpenStruct object.  @note It is not recommended to set and access unregistered keys on an Options object. Instead, register the attribute before using it.",
    "label": "",
    "id": "58"
  },
  {
    "raw_code": "def reset_defaults\n      names_set = {}\n      self.class.ancestors.each do |klass| # look at all ancestors\n        defaults =\n          klass.instance_variable_defined?(\"@defaults\") &&\n          klass.instance_variable_get(\"@defaults\")\n        next unless defaults\n        defaults.each do |key, value|\n          next if names_set[key]\n          names_set[key] = true\n          self[key] = Proc === value ? value.call : value\n        end",
    "comment": "Resets all values to their defaults.  @abstract Subclasses should override this method to perform custom value initialization if not using {default_attr}. Be sure to call +super+ so that default initialization can take place. @return [void]",
    "label": "",
    "id": "59"
  },
  {
    "raw_code": "def delete(key)\n      val = self[key]\n      if instance_variable_defined?(\"@#{key}\")\n        remove_instance_variable(\"@#{key}\")\n      end",
    "comment": "Deletes an option value for +key+  @param [Symbol, String] key the key to delete a value for @return [Object] the value that was deleted",
    "label": "",
    "id": "60"
  },
  {
    "raw_code": "def initialize(registry = Registry)\n      @registry = registry\n      @default_sep = nil\n\n      # Preload all code objects for separator declarations\n      YARD::CodeObjects.constants.map {|t| YARD::CodeObjects.const_get(t) }\n    end",
    "comment": "Creates a new resolver object for a registry.  @param registry [Registry] only set this if customizing the registry object",
    "label": "",
    "id": "61"
  },
  {
    "raw_code": "def lookup_by_path(path, opts = {})\n      path = path.to_s\n      namespace = opts[:namespace]\n      inheritance = opts[:inheritance] || false\n      proxy_fallback = opts[:proxy_fallback] || false\n      type = opts[:type]\n\n      if namespace.is_a?(CodeObjects::Proxy)\n        return proxy_fallback ? CodeObjects::Proxy.new(namespace, path, type) : nil\n      end",
    "comment": "Performs a lookup on a given path in the registry. Resolution will occur in a similar way to standard Ruby identifier resolution, doing lexical lookup, as well as (optionally) through the inheritance chain. A proxy object can be returned if the lookup fails for future resolution. The proxy will be type hinted with the +type+ used in the original lookup.  @option opts namespace [CodeObjects::Base, :root, nil] (nil) the namespace object to start searching from. If root or nil is provided, {Registry.root} is assumed. @option opts inheritance [Boolean] (false) whether to perform lookups through the inheritance chain (includes mixins) @option opts proxy_fallback [Boolean] (false) when true, a proxy is returned if no match is found @option opts type [Symbol] (nil) an optional type hint for the resolver to consider when performing a lookup. If a type is provided and the resolved object's type does not match the hint, the object is discarded. @return [CodeObjects::Base, CodeObjects::Proxy, nil] the first object that matches the path lookup. If proxy_fallback is provided, a proxy object will be returned in the event of no match, otherwise nil will be returned. @example A lookup from root resolver.lookup_by_path(\"A::B::C\") @example A lookup from the A::B namespace resolver.lookup_by_path(\"C\", namespace: P(\"A::B\")) @example A lookup on a method through the inheritance tree resolver.lookup_by_math(\"A::B#foo\", inheritance: true)",
    "label": "",
    "id": "62"
  },
  {
    "raw_code": "def validate(obj, type)\n      !type || (obj && obj.type == type) ? obj : nil\n    end",
    "comment": "return [Boolean] if the obj's type matches the provided type.",
    "label": "",
    "id": "63"
  },
  {
    "raw_code": "def lookup_path_direct(namespace, path, type)\n      result = namespace.root? && validate(@registry.at(path), type)\n      return result if result\n\n      if path =~ starts_with_separator_match\n        return validate(@registry.at(namespace.path + path), type)\n      end",
    "comment": "Performs a lexical lookup from a namespace for a path and a type hint.",
    "label": "",
    "id": "64"
  },
  {
    "raw_code": "def lookup_path_inherited(namespace, path, type)\n      resolved = nil\n      last_obj = namespace\n      scopes = []\n      last_sep = nil\n      pos = 0\n\n      if path =~ starts_with_separator_match\n        last_sep = $1\n        path = $'\n      end",
    "comment": "Performs a lookup through the inheritance chain on a path with a type hint.",
    "label": "",
    "id": "65"
  },
  {
    "raw_code": "def collect_namespaces(object)\n      return [] unless object.respond_to?(:inheritance_tree)\n\n      nss = object.inheritance_tree(true)\n      if object.respond_to?(:superclass)\n        nss |= [P('Object')] if object.superclass != P('BasicObject')\n        nss |= [P('BasicObject')]\n      end",
    "comment": "Collects and returns all inherited namespaces for a given object",
    "label": "",
    "id": "66"
  },
  {
    "raw_code": "def starts_with_default_separator_match\n      @@starts_with_default_separator_match ||= /\\A#{default_separator}/\n    end",
    "comment": "@return [Regexp] the regexp match of the default separator",
    "label": "",
    "id": "67"
  },
  {
    "raw_code": "def starts_with_separator_match\n      @@starts_with_separator_match ||= /\\A(#{separators_match})/\n    end",
    "comment": "@return [Regexp] the regexp that matches strings starting with a separator",
    "label": "",
    "id": "68"
  },
  {
    "raw_code": "def split_on_separators_match\n      @@split_on_separators_match ||= /(.+?)(#{separators_match}|$)/\n    end",
    "comment": "@return [Regexp] the regexp that can be used to split a string on all occurrences of separator tokens",
    "label": "",
    "id": "69"
  },
  {
    "raw_code": "def parser(*args) default_parser.new(*args) end\n    end",
    "comment": "Creates a parser object using the current {default_parser}. Equivalent to: Docstring.default_parser.new(*args) @param args arguments are passed to the {DocstringParser} class. See {DocstringParser#initialize} for details on arguments. @return [DocstringParser] the parser object used to parse a docstring.",
    "label": "",
    "id": "70"
  },
  {
    "raw_code": "def replace(content, parse = true)\n      content = content.join(\"\\n\") if content.is_a?(Array)\n      @tags = []\n      @ref_tags = []\n      if parse\n        super(parse_comments(content))\n      else\n        @all = content\n        @unresolved_reference = nil\n        super(content)\n      end",
    "comment": "Replaces the docstring with new raw content. Called by {#all=}. @param [String] content the raw comments to be parsed",
    "label": "",
    "id": "71"
  },
  {
    "raw_code": "def dup\n      resolve_reference\n      obj = super\n      %w(all summary tags ref_tags).each do |name|\n        val = instance_variable_defined?(\"@#{name}\") && instance_variable_get(\"@#{name}\")\n        obj.instance_variable_set(\"@#{name}\", val ? val.dup : nil)\n      end",
    "comment": "Deep-copies a docstring  @note This method creates a new docstring with new tag lists, but does not create new individual tags. Modifying the tag objects will still affect the original tags. @return [Docstring] a new copied docstring @since 0.7.0",
    "label": "",
    "id": "72"
  },
  {
    "raw_code": "def line\n      line_range ? line_range.first : nil\n    end",
    "comment": "@endgroup @return [Fixnum] the first line of the {#line_range} @return [nil] if there is no associated {#line_range}",
    "label": "",
    "id": "73"
  },
  {
    "raw_code": "def summary\n      resolve_reference\n      return @summary if defined?(@summary) && @summary\n      stripped = gsub(/[\\r\\n](?![\\r\\n])/, ' ').strip\n      num_parens = 0\n      idx = length.times do |index|\n        case stripped[index, 1]\n        when \".\"\n          next_char = stripped[index + 1, 1].to_s\n          break index - 1 if num_parens <= 0 && next_char =~ /^\\s*$/\n        when \"\\r\", \"\\n\"\n          next_char = stripped[index + 1, 1].to_s\n          if next_char =~ /^\\s*$/\n            break stripped[index - 1, 1] == '.' ? index - 2 : index - 1\n          end",
    "comment": "Gets the first line of a docstring to the period or the first paragraph. @return [String] The first line or paragraph of the docstring; always ends with a period.",
    "label": "",
    "id": "74"
  },
  {
    "raw_code": "def to_raw\n      tag_data = tags.map do |tag|\n        case tag\n        when Tags::OverloadTag\n          tag_text = \"@#{tag.tag_name} #{tag.signature}\\n\"\n          unless tag.docstring.blank?\n            tag_text += \"\\n  \" + tag.docstring.all.gsub(/\\r?\\n/, \"\\n  \")\n          end",
    "comment": "Reformats and returns a raw representation of the tag data using the current tag and docstring data, not the original text.  @return [String] the updated raw formatted docstring data @since 0.7.0 @todo Add Tags::Tag#to_raw and refactor",
    "label": "",
    "id": "75"
  },
  {
    "raw_code": "def add_tag(*tags)\n      tags.each_with_index do |tag, i|\n        case tag\n        when Tags::Tag\n          tag.object = object\n          @tags << tag\n        when Tags::RefTag, Tags::RefTagList\n          @ref_tags << tag\n        else\n          raise ArgumentError, \"expected Tag or RefTag, got #{tag.class} (at index #{i})\"\n        end",
    "comment": "@group Creating and Accessing Meta-data Adds a tag or reftag object to the tag list. If you want to parse tag data based on the {Tags::DefaultFactory} tag factory, use {DocstringParser} instead.  @param [Tags::Tag, Tags::RefTag] tags list of tag objects to add @return [void]",
    "label": "",
    "id": "76"
  },
  {
    "raw_code": "def tag(name)\n      tags.find {|tag| tag.tag_name.to_s == name.to_s }\n    end",
    "comment": "Convenience method to return the first tag object in the list of tag objects of that name  @example doc = Docstring.new(\"@return zero when nil\") doc.tag(:return).text  # => \"zero when nil\"  @param [#to_s] name the tag name to return data for @return [Tags::Tag] the first tag in the list of {#tags}",
    "label": "",
    "id": "77"
  },
  {
    "raw_code": "def tags(name = nil)\n      list = stable_sort_by(@tags + convert_ref_tags, &:tag_name)\n      return list unless name\n      list.select {|tag| tag.tag_name.to_s == name.to_s }\n    end",
    "comment": "Returns a list of tags specified by +name+ or all tags if +name+ is not specified.  @param [#to_s] name the tag name to return data for, or nil for all tags @return [Array<Tags::Tag>] the list of tags by the specified tag name",
    "label": "",
    "id": "78"
  },
  {
    "raw_code": "def has_tag?(name)\n      tags.any? {|tag| tag.tag_name.to_s == name.to_s }\n    end",
    "comment": "Returns true if at least one tag by the name +name+ was declared  @param [String] name the tag name to search for @return [Boolean] whether or not the tag +name+ was declared",
    "label": "",
    "id": "79"
  },
  {
    "raw_code": "def delete_tags(name)\n      delete_tag_if {|tag| tag.tag_name.to_s == name.to_s }\n    end",
    "comment": "Delete all tags with +name+ @param [String] name the tag name @return [void] @since 0.7.0",
    "label": "",
    "id": "80"
  },
  {
    "raw_code": "def delete_tag_if(&block)\n      @tags.delete_if(&block)\n      @ref_tags.delete_if(&block)\n    end",
    "comment": "Deletes all tags where the block returns true @yieldparam [Tags::Tag] tag the tag that is being tested @yieldreturn [Boolean] true if the tag should be deleted @return [void] @since 0.7.0",
    "label": "",
    "id": "81"
  },
  {
    "raw_code": "def blank?(only_visible_tags = true)\n      if only_visible_tags\n        empty? && !tags.any? {|tag| Tags::Library.visible_tags.include?(tag.tag_name.to_sym) }\n      else\n        empty? && @tags.empty? && @ref_tags.empty?\n      end",
    "comment": "Returns true if the docstring has no content that is visible to a template.  @param [Boolean] only_visible_tags whether only {Tags::Library.visible_tags} should be checked, or if all tags should be considered. @return [Boolean] whether or not the docstring has content",
    "label": "",
    "id": "82"
  },
  {
    "raw_code": "def resolve_reference\n      loop do\n        return if defined?(@unresolved_reference).nil? || @unresolved_reference.nil?\n        return if CodeObjects::Proxy === @unresolved_reference\n\n        reference = @unresolved_reference\n        @unresolved_reference = nil\n        self.all = [reference.docstring.all, @all].join(\"\\n\")\n      end",
    "comment": "@endgroup Resolves unresolved other docstring reference if there is unresolved reference. Does nothing if there is no unresolved reference.  Normally, you don't need to call this method explicitly. Resolving unresolved reference is done implicitly.  @return [void]",
    "label": "",
    "id": "83"
  },
  {
    "raw_code": "def convert_ref_tags\n      list = @ref_tags.reject {|t| CodeObjects::Proxy === t.owner }\n\n      @ref_tag_recurse_count ||= 0\n      @ref_tag_recurse_count += 1\n      if @ref_tag_recurse_count > 2\n        log.error \"#{@object.file}:#{@object.line}: Detected circular reference tag in \" \\\n                  \"`#{@object}', ignoring all reference tags for this object \" \\\n                  \"(#{@ref_tags.map {|t| \"@#{t.tag_name}\" }.join(\", \")}).\"\n        @ref_tags = []\n        return @ref_tags\n      end",
    "comment": "Maps valid reference tags  @return [Array<Tags::RefTag>] the list of valid reference tags",
    "label": "",
    "id": "84"
  },
  {
    "raw_code": "def parse_comments(comments)\n      parser = self.class.parser\n      parser.parse(comments, object)\n      @all = parser.raw_text\n      @unresolved_reference = parser.reference\n      add_tag(*parser.tags)\n      parser.text\n    end",
    "comment": "Parses out comments split by newlines into a new code object  @param [String] comments the newline delimited array of comments. If the comments are passed as a String, they will be split by newlines.  @return [String] the non-metadata portion of the comments to be used as a docstring",
    "label": "",
    "id": "85"
  },
  {
    "raw_code": "def stable_sort_by(list)\n      list.each_with_index.sort_by {|tag, i| [yield(tag), i] }.map(&:first)\n    end",
    "comment": "A stable sort_by method.  @param list [Enumerable] the list to sort. @return [Array] a stable sorted list.",
    "label": "",
    "id": "86"
  },
  {
    "raw_code": "def show_backtraces; @show_backtraces || level == DEBUG end\n    attr_writer :show_backtraces\n\n    # @return [DEBUG, INFO, WARN, ERROR, FATAL, UNKNOWN] the logging level\n    attr_accessor :level\n\n    # @return [Boolean] whether a warn message has been emitted. Used for status tracking.\n    attr_accessor :warned\n\n    # @return [Boolean] whether progress indicators should be shown when\n    #   logging CLIs (by default this is off).\n    def show_progress\n      return false if YARD.ruby18? # threading is too ineffective for progress support\n      return false unless io.tty? # no TTY support on IO\n      return false unless level > INFO # no progress in verbose/debug modes\n      @show_progress\n    end\n    attr_writer :show_progress\n\n    # @!group Constructor Methods\n\n    # The logger instance\n    # @return [Logger] the logger instance\n    def self.instance(pipe = STDOUT)\n      @logger ||= new(pipe)\n    end\n\n    # Creates a new logger\n    # @private\n    def initialize(pipe, *args)\n      self.io = pipe\n      self.show_backtraces = true\n      self.show_progress = false\n      self.level = WARN\n      self.warned = false\n      @progress_indicator = 0\n      @mutex = Mutex.new\n      @progress_msg = nil\n      @progress_last_update = Time.now\n    end\n\n    # @!macro [attach] logger.create_log_method\n    #   @method $1(message)\n    #   Logs a message with the $1 severity level.\n    #   @param message [String] the message to log\n    #   @see #log\n    #   @return [void]\n    # @private\n    def self.create_log_method(name)\n      severity = Severity.const_get(name.to_s.upcase)\n      define_method(name) { |message| log(severity, message) }\n    end\n\n    # @!group Logging Methods\n\n    create_log_method :info\n    create_log_method :error\n    create_log_method :fatal\n    create_log_method :unknown\n\n    # Changes the debug level to DEBUG if $DEBUG is set and writes a debugging message.\n    create_log_method :debug\n\n    # Remembers when a warning occurs and writes a warning message.\n    create_log_method :warn\n\n    # Logs a message with a given severity\n    # @param severity [DEBUG, INFO, WARN, ERROR, FATAL, UNKNOWN] the severity level\n    # @param message [String] the message to log\n    def log(severity, message)\n      self.level = DEBUG if $DEBUG\n      return unless severity >= level\n\n      self.warned = true if severity == WARN\n      clear_line\n      puts \"[#{SEVERITIES[severity].to_s.downcase}]: #{message}\"\n    end\n\n    # @!group Level Control Methods\n\n    # Sets the logger level for the duration of the block\n    #\n    # @example\n    #   log.enter_level(Logger::ERROR) do\n    #     YARD.parse_string \"def x; end\"\n    #   end\n    # @param [Fixnum] new_level the logger level for the duration of the block.\n    #   values can be found in Ruby's Logger class.\n    # @yield the block with the logger temporarily set to +new_level+\n    def enter_level(new_level = level)\n      old_level = level\n      self.level = new_level\n      yield\n    ensure\n      self.level = old_level\n    end\n\n    # @!group Utility Printing Methods\n\n    # Displays a progress indicator for a given message. This progress report\n    # is only displayed on TTY displays, otherwise the message is passed to\n    # the +nontty_log+ level.\n    #\n    # @param [String] msg the message to log\n    # @param [Symbol, nil] nontty_log the level to log as if the output\n    #   stream is not a TTY. Use +nil+ for no alternate logging.\n    # @return [void]\n    # @since 0.8.2\n    def progress(msg, nontty_log = :debug)\n      send(nontty_log, msg) if nontty_log\n      return unless show_progress\n      icon = \"\"\n      if defined?(::Encoding)\n        icon = PROGRESS_INDICATORS[@progress_indicator] + \" \"\n      end\n      @mutex.synchronize do\n        print(\"\\e[2K\\e[?25l\\e[1m#{icon}#{msg}\\e[0m\\r\")\n        @progress_msg = msg\n        if Time.now - @progress_last_update > 0.2\n          @progress_indicator += 1\n          @progress_indicator %= PROGRESS_INDICATORS.size\n          @progress_last_update = Time.now\n        end",
    "comment": "@return [Boolean] whether backtraces should be shown (by default this is on).",
    "label": "",
    "id": "87"
  },
  {
    "raw_code": "def clear_progress\n      return unless show_progress\n      io.write(\"\\e[?25h\\e[2K\")\n      @progress_msg = nil\n    end",
    "comment": "Clears the progress indicator in the TTY display. @return [void] @since 0.8.2",
    "label": "",
    "id": "88"
  },
  {
    "raw_code": "def puts(msg = '')\n      print(\"#{msg}\\n\")\n    end",
    "comment": "Displays an unformatted line to the logger output stream, adding a newline. @param [String] msg the message to display @return [void] @since 0.8.2",
    "label": "",
    "id": "89"
  },
  {
    "raw_code": "def print(msg = '')\n      clear_line\n      io.write(msg)\n    end",
    "comment": "Displays an unformatted line to the logger output stream. @param [String] msg the message to display @return [void] @since 0.8.2",
    "label": "",
    "id": "90"
  },
  {
    "raw_code": "def backtrace(exc, level_meth = :error)\n      return unless show_backtraces\n      send(level_meth, \"#{exc.class.class_name}: #{exc.message}\")\n      send(level_meth, \"Stack trace:\" +\n        exc.backtrace[0..5].map {|x| \"\\n\\t#{x}\" }.join + \"\\n\")\n    end",
    "comment": "Prints the backtrace +exc+ to the logger as error data.  @param [Array<String>] exc the backtrace list @param [Symbol] level_meth the level to log backtrace at @return [void]",
    "label": "",
    "id": "91"
  },
  {
    "raw_code": "def capture(msg, nontty_log = :debug)\n      progress(msg, nontty_log)\n      yield\n    ensure\n      clear_progress\n    end",
    "comment": "@!group Benchmarking Methods Captures the duration of a block of code for benchmark analysis. Also calls {#progress} on the message to display it to the user.  @todo Implement capture storage for reporting of benchmarks @param [String] msg the message to display @param [Symbol, nil] nontty_log the level to log as if the output stream is not a TTY. Use +nil+ for no alternate logging. @yield a block of arbitrary code to benchmark @return [void]",
    "label": "",
    "id": "92"
  },
  {
    "raw_code": "def warn_no_continuations\n    end",
    "comment": "@!endgroup Warns that the Ruby environment does not support continuations. Applies to JRuby, Rubinius and MacRuby. This warning will only display once per Ruby process.  @deprecated Continuations are no longer needed by YARD 0.8.0+. @return [void] @private",
    "label": "",
    "id": "93"
  },
  {
    "raw_code": "def method_missing(name, *args)\n      if name.to_s.end_with?('=')\n        varname = name.to_s[0..-2].to_sym\n        __cache_lookup__(varname)\n        send(name, args.first)\n      else\n        __cache_lookup__(name)\n        send(name)\n      end",
    "comment": "@private",
    "label": "",
    "id": "94"
  },
  {
    "raw_code": "def self.load\n      self.options = SymbolHash.new(false)\n      options.update(DEFAULT_CONFIG_OPTIONS)\n      options.update(read_config_file)\n      load_commandline_safemode\n      add_ignored_plugins_file\n      translate_plugin_names\n      load_plugins\n    rescue => e\n      log.error \"Invalid configuration file, using default options.\"\n      log.backtrace(e)\n      options.update(DEFAULT_CONFIG_OPTIONS)\n    end",
    "comment": "Loads settings from {CONFIG_FILE}. This method is called by YARD at load time and should not be called by the user. @return [void]",
    "label": "",
    "id": "95"
  },
  {
    "raw_code": "def self.save\n      require 'yaml'\n      Dir.mkdir(CONFIG_DIR) unless File.directory?(CONFIG_DIR)\n      File.open(CONFIG_FILE, 'w') {|f| f.write(YAML.dump(options)) }\n    end",
    "comment": "Saves settings to {CONFIG_FILE}. @return [void]",
    "label": "",
    "id": "96"
  },
  {
    "raw_code": "def self.load_plugins\n      load_gem_plugins &&\n        load_autoload_plugins &&\n        load_commandline_plugins ? true : false\n    end",
    "comment": "Loads gems that match the name 'yard-*' (recommended) or 'yard_*' except those listed in +~/.yard/ignored_plugins+. This is called immediately after YARD is loaded to allow plugin support.  @return [Boolean] true if all plugins loaded successfully, false otherwise.",
    "label": "",
    "id": "97"
  },
  {
    "raw_code": "def self.load_plugin(name)\n      name = translate_plugin_name(name)\n      return false if options[:ignored_plugins].include?(name)\n      return false if name =~ /^yard-doc-/\n      log.debug \"Loading plugin '#{name}'...\"\n      require name\n      true\n    rescue LoadError => e\n      load_plugin_failed(name, e)\n    end",
    "comment": "Loads an individual plugin by name. It is not necessary to include the +yard-+ plugin prefix here.  @param [String] name the name of the plugin (with or without +yard-+ prefix) @return [Boolean] whether the plugin was successfully loaded",
    "label": "",
    "id": "98"
  },
  {
    "raw_code": "def self.load_gem_plugins\n      return true unless options[:load_plugins]\n      require 'rubygems'\n      result = true\n      YARD::GemIndex.each do |gem|\n        begin\n          next true unless gem.name =~ YARD_PLUGIN_PREFIX\n          load_plugin(gem.name)\n        rescue Gem::LoadError => e\n          tmp = load_plugin_failed(gem.name, e)\n          result = tmp unless tmp\n        end",
    "comment": "Load gem plugins if :load_plugins is true",
    "label": "",
    "id": "99"
  },
  {
    "raw_code": "def self.load_autoload_plugins\n      options[:autoload_plugins].each {|name| load_plugin(name) }\n    end",
    "comment": "Load plugins set in :autoload_plugins",
    "label": "",
    "id": "100"
  },
  {
    "raw_code": "def self.load_commandline_plugins\n      with_yardopts do\n        arguments.each_with_index do |arg, i|\n          next unless arg == '--plugin'\n          load_plugin(arguments[i + 1])\n        end",
    "comment": "Load plugins from {arguments}",
    "label": "",
    "id": "101"
  },
  {
    "raw_code": "def self.load_commandline_safemode\n      with_yardopts do\n        arguments.each_with_index do |arg, _i|\n          options[:safe_mode] = true if arg == '--safe'\n        end",
    "comment": "Check for command-line safe_mode switch in {arguments}",
    "label": "",
    "id": "102"
  },
  {
    "raw_code": "def self.load_plugin_failed(name, exception)\n      log.error \"Error loading plugin '#{name}'\"\n      log.backtrace(exception) if $DEBUG\n      false\n    end",
    "comment": "Print a warning if the plugin failed to load @return [false]",
    "label": "",
    "id": "103"
  },
  {
    "raw_code": "def self.add_ignored_plugins_file\n      if File.file?(IGNORED_PLUGINS)\n        options[:ignored_plugins] += File.read(IGNORED_PLUGINS).split(/\\s+/)\n      end",
    "comment": "Legacy support for {IGNORED_PLUGINS}",
    "label": "",
    "id": "104"
  },
  {
    "raw_code": "def self.translate_plugin_names\n      options[:ignored_plugins].map! {|name| translate_plugin_name(name) }\n      options[:autoload_plugins].map! {|name| translate_plugin_name(name) }\n    end",
    "comment": "Translates plugin names to add yard- prefix.",
    "label": "",
    "id": "105"
  },
  {
    "raw_code": "def self.read_config_file\n      if File.file?(CONFIG_FILE)\n        require 'yaml'\n        if YAML.respond_to?(:safe_load_file)\n          YAML.safe_load_file(CONFIG_FILE, permitted_classes: [SymbolHash, Symbol])\n        else\n          YAML.load_file(CONFIG_FILE)\n        end",
    "comment": "Loads the YAML configuration file into memory @return [Hash] the contents of the YAML file from disk @see CONFIG_FILE",
    "label": "",
    "id": "106"
  },
  {
    "raw_code": "def self.translate_plugin_name(name)\n      name = name.delete('/') # Security sanitization\n      name = \"yard-\" + name unless name =~ YARD_PLUGIN_PREFIX\n      name\n    end",
    "comment": "Sanitizes and normalizes a plugin name to include the 'yard-' prefix. @param [String] name the plugin name @return [String] the sanitized and normalized plugin name.",
    "label": "",
    "id": "107"
  },
  {
    "raw_code": "def self.with_yardopts\n      yfile = CLI::Yardoc::DEFAULT_YARDOPTS_FILE\n      @yardopts = File.file?(yfile) ? File.read_binary(yfile).shell_split : []\n      result = yield\n      @yardopts = nil\n      result\n    end",
    "comment": "Temporarily loads .yardopts file into @yardopts",
    "label": "",
    "id": "108"
  },
  {
    "raw_code": "def self.arguments\n      ARGV + @yardopts\n    end",
    "comment": "@return [Array<String>] arguments from commandline and yardopts file",
    "label": "",
    "id": "109"
  },
  {
    "raw_code": "def self.register_static_path(path)\n      static_paths = Commands::StaticFileCommand::STATIC_PATHS\n      static_paths.push(path) unless static_paths.include?(path)\n    end",
    "comment": "Registers a static path to be used in static asset lookup. @param [String] path the pathname to register @return [void] @since 0.6.2",
    "label": "",
    "id": "110"
  },
  {
    "raw_code": "def P(namespace, name = nil, type = nil) # rubocop:disable Naming/MethodName\n  if name.nil?\n    name = namespace\n    namespace = nil\n  end",
    "comment": "frozen_string_literal: true @group Global Convenience Methods Shortcut for creating a YARD::CodeObjects::Proxy via a path  @see YARD::CodeObjects::Proxy @see YARD::Registry.resolve",
    "label": "",
    "id": "111"
  },
  {
    "raw_code": "def log\n  YARD::Logger.instance\nend",
    "comment": "The global {YARD::Logger} instance  @return [YARD::Logger] the global {YARD::Logger} instance @see YARD::Logger",
    "label": "",
    "id": "112"
  },
  {
    "raw_code": "def clear_subclasses\n          @@subclasses = []\n        end",
    "comment": "Clear all registered subclasses. Testing purposes only @return [void]",
    "label": "",
    "id": "113"
  },
  {
    "raw_code": "def subclasses\n          @@subclasses ||= []\n        end",
    "comment": "Returns all registered handler subclasses. @return [Array<Base>] a list of handlers",
    "label": "",
    "id": "114"
  },
  {
    "raw_code": "def handles(*matches)\n          (@handlers ||= []).concat(matches)\n        end",
    "comment": "Declares the statement type which will be processed by this handler.  A match need not be unique to a handler. Multiple handlers can process the same statement. However, in this case, care should be taken to make sure that {#parse_block} would only be executed by one of the handlers, otherwise the same code will be parsed multiple times and slow YARD down.  @param [Parser::Ruby::Legacy::RubyToken, Symbol, String, Regexp] matches statements that match the declaration will be processed by this handler. A {String} match is equivalent to a +/\\Astring/+ regular expression (match from the beginning of the line), and all token matches match only the first token of the statement. ",
    "label": "",
    "id": "115"
  },
  {
    "raw_code": "def handles?(statement) # rubocop:disable Lint/UnusedMethodArgument\n          raise NotImplementedError, \"override #handles? in a subclass\"\n        end",
    "comment": "This class is implemented by {Ruby::Base} and {Ruby::Legacy::Base}. To implement a base handler class for another language, implement this method to return true if the handler should process the given statement object. Use {handlers} to enumerate the matchers declared for the handler class.  @param statement a statement object or node (depends on language type) @return [Boolean] whether or not this handler object should process the given statement",
    "label": "",
    "id": "116"
  },
  {
    "raw_code": "def handlers\n          @handlers ||= []\n        end",
    "comment": "@return [Array] a list of matchers for the handler object. @see handles?",
    "label": "",
    "id": "117"
  },
  {
    "raw_code": "def namespace_only\n          @namespace_only = true\n        end",
    "comment": "Declares that the handler should only be called when inside a {CodeObjects::NamespaceObject}, not a method body.  @return [void]",
    "label": "",
    "id": "118"
  },
  {
    "raw_code": "def namespace_only?\n          @namespace_only ||= false\n        end",
    "comment": "@return [Boolean] whether the handler should only be processed inside a namespace.",
    "label": "",
    "id": "119"
  },
  {
    "raw_code": "def in_file(filename)\n          (@in_files ||= []) << filename\n        end",
    "comment": "Declares that a handler should only be called when inside a filename by its basename or a regex match for the full path.  @param [String, Regexp] filename a matching filename or regex @return [void] @since 0.6.2",
    "label": "",
    "id": "120"
  },
  {
    "raw_code": "def matches_file?(filename)\n          @in_files ||= nil # avoid ruby warnings\n          return true unless @in_files\n          @in_files.any? do |in_file|\n            case in_file\n            when String\n              File.basename(filename) == in_file\n            when Regexp\n              filename =~ in_file\n            else\n              true\n            end",
    "comment": "@return [Boolean] whether the filename matches the declared file match for a handler. If no file match is specified, returns true. @since 0.6.2",
    "label": "",
    "id": "121"
  },
  {
    "raw_code": "def process(&block)\n          mod = Module.new\n          mod.send(:define_method, :process, &block)\n          include mod\n        end",
    "comment": "Generates a +process+ method, equivalent to +def process; ... end+. Blocks defined with this syntax will be wrapped inside an anonymous module so that the handler class can be extended with mixins that override the +process+ method without alias chaining.  @!macro yard.handlers.process @!method process Main processing callback @return [void] @see #process @return [void] @since 0.5.4",
    "label": "",
    "id": "122"
  },
  {
    "raw_code": "def process\n        raise NotImplementedError, \"#{self} did not implement a #process method for handling.\"\n      end",
    "comment": "The main handler method called by the parser on a statement that matches the {handles} declaration.  Subclasses should override this method to provide the handling functionality for the class.  @return [Array<CodeObjects::Base>, CodeObjects::Base, Object] If this method returns a code object (or a list of them), they are passed to the +#register+ method which adds basic attributes. It is not necessary to return any objects and in some cases you may want to explicitly avoid the returning of any objects for post-processing by the register method.  @see handles @see #register ",
    "label": "",
    "id": "123"
  },
  {
    "raw_code": "def parse_block(*)\n        raise NotImplementedError, \"#{self} did not implement a #parse_block method for handling\"\n      end",
    "comment": "Parses the semantic \"block\" contained in the statement node.  @abstract Subclasses should call {Processor#process parser.process}",
    "label": "",
    "id": "124"
  },
  {
    "raw_code": "def register_handler_namespace(type, ns)\n          namespace_for_handler[type] = ns\n        end",
    "comment": "Registers a new namespace for handlers of the given type. @since 0.6.0",
    "label": "",
    "id": "125"
  },
  {
    "raw_code": "def initialize(parser)\n        @file = parser.file || \"(stdin)\"\n        @namespace = YARD::Registry.root\n        @visibility = :public\n        @scope = :instance\n        @owner = @namespace\n        @parser_type = parser.parser_type\n        @handlers_loaded = {}\n        @globals = parser.globals || OpenStruct.new\n        @extra_state = OpenStruct.new\n        load_handlers\n      end",
    "comment": "Creates a new Processor for a +file+. @param [Parser::SourceParser] parser the parser used to initialize the processor",
    "label": "",
    "id": "126"
  },
  {
    "raw_code": "def process(statements)\n        statements.each_with_index do |stmt, _index|\n          find_handlers(stmt).each do |handler|\n            begin\n              handler.new(self, stmt).process\n            rescue HandlerAborted\n              log.debug \"#{handler} cancelled from #{caller.last}\"\n              log.debug \"\\tin file '#{file}':#{stmt.line}:\\n\\n\" + stmt.show + \"\\n\"\n            rescue NamespaceMissingError => missingerr\n              log.warn \"The #{missingerr.object.type} #{missingerr.object.path} has not yet been recognized.\\n\" \\\n                       \"If this class/method is part of your source tree, this will affect your documentation results.\\n\" \\\n                       \"You can correct this issue by loading the source file for this object before `#{file}'\\n\"\n            rescue Parser::UndocumentableError => undocerr\n              log.warn \"in #{handler}: Undocumentable #{undocerr.message}\\n\" \\\n                       \"\\tin file '#{file}':#{stmt.line}:\\n\\n\" + stmt.show + \"\\n\"\n            rescue => e\n              log.error \"Unhandled exception in #{handler}:\\n\" \\\n                        \"  in `#{file}`:#{stmt.line}:\\n\\n#{stmt.show}\\n\"\n              log.backtrace(e)\n            end",
    "comment": "Processes a list of statements by finding handlers to process each one.  @param [Array] statements a list of statements @return [void]",
    "label": "",
    "id": "127"
  },
  {
    "raw_code": "def parse_remaining_files\n        if globals.ordered_parser\n          globals.ordered_parser.parse\n          log.debug(\"Re-processing #{@file}...\")\n        end",
    "comment": "Continue parsing the remainder of the files in the +globals.ordered_parser+ object. After the remainder of files are parsed, processing will continue on the current file.  @return [void] @see Parser::OrderedParser",
    "label": "",
    "id": "128"
  },
  {
    "raw_code": "def find_handlers(statement)\n        Base.subclasses.find_all do |handler|\n          handler_base_class > handler &&\n            (handler.namespace_only? ? owner.is_a?(CodeObjects::NamespaceObject) : true) &&\n            handles?(handler, statement)\n        end",
    "comment": "Searches for all handlers in {Base.subclasses} that match the +statement+  @param statement the statement object to match. @return [Array<Base>] a list of handlers to process the statement with.",
    "label": "",
    "id": "129"
  },
  {
    "raw_code": "def handler_base_class\n        handler_base_namespace.const_get(:Base)\n      end",
    "comment": "Returns the handler base class @return [Base] the base class",
    "label": "",
    "id": "130"
  },
  {
    "raw_code": "def handler_base_namespace\n        self.class.namespace_for_handler[parser_type]\n      end",
    "comment": "The module holding the handlers to be loaded  @return [Module] the module containing the handlers depending on {#parser_type}.",
    "label": "",
    "id": "131"
  },
  {
    "raw_code": "def load_handlers\n        return if @handlers_loaded[parser_type]\n        handler_base_namespace.constants.each do |c|\n          const = handler_base_namespace.const_get(c)\n          unless Handlers::Base.subclasses.include?(const)\n            Handlers::Base.subclasses << const\n          end",
    "comment": "Loads handlers from {#handler_base_namespace}. This ensures that Ruby1.9 handlers are never loaded into 1.8; also lowers the amount of modules that are loaded @return [void]",
    "label": "",
    "id": "132"
  },
  {
    "raw_code": "def extract_parameters(superclass)\n    members = superclass.parameters.select {|x| x && x.type == :symbol_literal }\n    members.map! {|x| x.source.strip[1..-1] }\n    members\n  end",
    "comment": "Extract the parameters from the Struct.new AST node, returning them as a list of strings  @param [MethodCallNode] superclass the AST node for the Struct.new call @return [Array<String>] the member names to generate methods for",
    "label": "",
    "id": "133"
  },
  {
    "raw_code": "def macro_name_matches(macro)\n          objs = [macro.method_object]\n          if objs.first.type != :proxy && objs.first.respond_to?(:aliases)\n            objs.concat(objs.first.aliases)\n          end",
    "comment": "@return [Boolean] whether caller method matches a macro or its alias names.",
    "label": "",
    "id": "134"
  },
  {
    "raw_code": "def validated_attribute_names(params)\n    params.map do |obj|\n      case obj.type\n      when :symbol_literal\n        obj.jump(:ident, :op, :kw, :const).source\n      when :string_literal\n        obj.jump(:string_content).source\n      else\n        raise YARD::Parser::UndocumentableError, obj.source\n      end",
    "comment": "Strips out any non-essential arguments from the attr statement.  @param [Array<Parser::Ruby::AstNode>] params a list of the parameters in the attr call. @return [Array<String>] the validated attribute names @raise [Parser::UndocumentableError] if the arguments are not valid.",
    "label": "",
    "id": "135"
  },
  {
    "raw_code": "def parse_condition\n    condition = nil\n\n    # Right now we can handle very simple unary conditions like:\n    #   if true\n    #   if false\n    #   if 0\n    #   if 100 (not 0)\n    #   if defined? SOME_CONSTANT\n    #\n    # The last case will do a lookup in the registry and then one\n    # in the Ruby world (using eval).\n    case statement.condition.type\n    when :int\n      condition = statement.condition[0] != \"0\"\n    when :defined\n      # defined? keyword used, let's see if we can look up the name\n      # in the registry, then we'll try using Ruby's powers. eval() is not\n      # *too* dangerous here since code is not actually executed.\n      arg = statement.condition.first\n\n      if arg.type == :var_ref\n        name = arg.source\n        obj = YARD::Registry.resolve(namespace, name, true)\n\n        begin\n          condition = true if obj || (name && Object.instance_eval(\"defined? #{name}\"))\n        rescue SyntaxError, NameError\n          condition = false\n        end",
    "comment": "Parses the condition part of the if/unless statement  @return [true, false, nil] true if the condition can be definitely parsed to true, false if not, and nil if the condition cannot be parsed with certainty (it's dynamic)",
    "label": "",
    "id": "136"
  },
  {
    "raw_code": "def initialize(name) @name = name end\n\n        # Tests if the node matches the handler\n        # @param [Parser::Ruby::AstNode] node a Ruby node\n        # @return [Boolean] whether the +node+ matches the handler\n        def matches?(node) # rubocop:disable Lint/UnusedMethodArgument\n          raise NotImplementedError\n        end\n\n        protected\n\n        # @return [String] the extension matcher value\n        attr_reader :name\n      end",
    "comment": "Creates a new extension with a specific matcher value +name+ @param [Object] name the matcher value to check against {#matches?}",
    "label": "",
    "id": "137"
  },
  {
    "raw_code": "def method_call(name = nil)\n            MethodCallWrapper.new(name ? name.to_s : nil)\n          end",
    "comment": "@group Statement Matcher Extensions Matcher for handling any type of method call. Method calls can be expressed by many {AstNode} types depending on the syntax with which it is called, so YARD allows you to use this matcher to simplify matching a method call.  @example Match the \"describe\" method call handles method_call(:describe)  # The following will be matched: # describe(...) # object.describe(...) # describe \"argument\" do ... end  @param [#to_s] name matches the method call of this name @return [void]",
    "label": "",
    "id": "138"
  },
  {
    "raw_code": "def meta_type(type)\n            TestNodeWrapper.new(type.to_s + \"?\")\n          end",
    "comment": "Matcher for handling a node with a specific meta-type. An {AstNode} has a {AstNode#type} to define its type but can also be associated with a set of types. For instance, +:if+ and +:unless+ are both of the meta-type +:condition+.  A meta-type is any method on the {AstNode} class ending in \"?\", though you should not include the \"?\" suffix in your declaration. Some examples are: \"condition\", \"call\", \"literal\", \"kw\", \"token\", \"ref\".  @example Handling any conditional statement (if, unless) handles meta_type(:condition) @param [Symbol] type the meta-type to match. A meta-type can be any method name + \"?\" that {AstNode} responds to. @return [void]",
    "label": "",
    "id": "139"
  },
  {
    "raw_code": "def handles?(node)\n            handlers.any? do |a_handler|\n              case a_handler\n              when Symbol\n                a_handler == node.type\n              when String\n                node.source == a_handler\n              when Regexp\n                node.source =~ a_handler\n              when Parser::Ruby::AstNode\n                a_handler == node\n              when HandlesExtension\n                a_handler.matches?(node)\n              end",
    "comment": "@group Testing for a Handler @return [Boolean] whether or not an {AstNode} object should be handled by this handler",
    "label": "",
    "id": "140"
  },
  {
    "raw_code": "def parse_block(inner_node, opts = {})\n          push_state(opts) do\n            nodes = inner_node.type == :list ? inner_node.children : [inner_node]\n            parser.process(nodes)\n          end",
    "comment": "@group Parsing an Inner Block",
    "label": "",
    "id": "141"
  },
  {
    "raw_code": "def call_params\n          return [] unless statement.respond_to?(:parameters)\n          statement.parameters(false).compact.map do |param|\n            if param.type == :list\n              param.map {|n| n.jump(:ident, :kw, :tstring_content).source }\n            else\n              param.jump(:ident, :kw, :tstring_content).source\n            end",
    "comment": "@group Macro Handling",
    "label": "",
    "id": "142"
  },
  {
    "raw_code": "def member_tag_for_member(klass, member, type = :read)\n    specific_tag = type == :read ? :attr_reader : :attr_writer\n    (klass.tags(specific_tag) + klass.tags(:attr)).find {|tag| tag.name == member }\n  end",
    "comment": "Extracts the user's defined @member tag for a given class and its member. Returns nil if the user did not define a @member tag for this struct entry.  @param [ClassObject] klass the class whose tags we're searching @param [String] member the name of the struct member we need @param [Symbol] type reader method, or writer method? @return [Tags::Tag, nil] the tag matching the request, or nil if not found",
    "label": "",
    "id": "143"
  },
  {
    "raw_code": "def members_from_tags(klass)\n    tags = klass.tags(:attr) + klass.tags(:attr_reader) + klass.tags(:attr_writer)\n    tags.map(&:name).uniq\n  end",
    "comment": "Retrieves all members defined in @attr* tags  @param [ClassObject] klass the class with the attributes @return [Array<String>] the list of members defined as attributes on the class",
    "label": "",
    "id": "144"
  },
  {
    "raw_code": "def create_member_method?(klass, member, type = :read)\n    return true if (klass.tags(:attr) + klass.tags(:attr_reader) + klass.tags(:attr_writer)).empty?\n    return true if member_tag_for_member(klass, member, type)\n    return !member_tag_for_member(klass, member, :write) if type == :read\n    !member_tag_for_member(klass, member, :read)\n  end",
    "comment": "Determines whether to create an attribute method based on the class's tags.  @param [ClassObject] klass the class whose tags we're searching @param [String] member the name of the struct member we need @param [Symbol] type (:read) reader method, or writer method? @return [Boolean] should the attribute be created?",
    "label": "",
    "id": "145"
  },
  {
    "raw_code": "def return_type_from_tag(member_tag)\n    member_tag && member_tag.types ? member_tag.types : \"Object\"\n  end",
    "comment": "Gets the return type for the member in a nicely formatted string. Used to be injected into auto-generated docstrings.  @param [Tags::Tag] member_tag the tag object to check for types @return [String] the user-declared type of the struct member, or [Object] if the user did not define a type for this member.",
    "label": "",
    "id": "146"
  },
  {
    "raw_code": "def add_reader_tags(klass, new_method, member)\n    member_tag = member_tag_for_member(klass, member, :read)\n    return_type = return_type_from_tag(member_tag)\n    getter_doc_text = member_tag ? member_tag.text : \"Returns the value of attribute #{member}\"\n    new_method.docstring.replace(getter_doc_text)\n    new_method.add_tag YARD::Tags::Tag.new(:return, \"the current value of #{member}\", return_type)\n  end",
    "comment": "Creates the auto-generated docstring for the getter method of a struct's member. This is used so the generated documentation will look just like that of an attribute defined using attr_accessor.  @param [ClassObject] klass the class whose members we're working with @param [String] member the name of the member we're generating documentation for @return [String] a docstring to be attached to the getter method for this member",
    "label": "",
    "id": "147"
  },
  {
    "raw_code": "def add_writer_tags(klass, new_method, member)\n    member_tag = member_tag_for_member(klass, member, :write)\n    return_type = return_type_from_tag(member_tag)\n    setter_doc_text = member_tag ? member_tag.text : \"Sets the attribute #{member}\"\n    new_method.docstring.replace(setter_doc_text)\n    new_method.add_tag YARD::Tags::Tag.new(:param, \"the value to set the attribute #{member} to.\", return_type, \"value\")\n    new_method.add_tag YARD::Tags::Tag.new(:return, \"the newly set value\", return_type)\n  end",
    "comment": "Creates the auto-generated docstring for the setter method of a struct's member. This is used so the generated documentation will look just like that of an attribute defined using attr_accessor.  @param [ClassObject] klass the class whose members we're working with @param [String] member the name of the member we're generating documentation for @return [String] a docstring to be attached to the setter method for this member",
    "label": "",
    "id": "148"
  },
  {
    "raw_code": "def create_class(classname, superclass)\n    register ClassObject.new(namespace, classname) do |o|\n      o.superclass = superclass if superclass\n      o.superclass.type = :class if o.superclass.is_a?(Proxy)\n    end",
    "comment": "Creates and registers a class object with the given name and superclass name. Returns it for further use.  @param [String] classname the name of the class @param [String] superclass the name of the superclass @return [ClassObject] the class object for further processing/method attaching",
    "label": "",
    "id": "149"
  },
  {
    "raw_code": "def create_writer(klass, member)\n    # We want to convert these members into attributes just like\n    # as if they were declared using attr_accessor.\n    new_meth = register MethodObject.new(klass, \"#{member}=\", :instance) do |o|\n      o.parameters = [['value', nil]]\n      o.signature ||= \"def #{member}=(value)\"\n      o.source ||= \"#{o.signature}\\n  @#{member} = value\\nend\"\n    end",
    "comment": "Creates the setter (writer) method and attaches it to the class as an attribute. Also sets up the docstring to prettify the documentation output.  @param [ClassObject] klass the class to attach the method to @param [String] member the name of the member we're generating a method for",
    "label": "",
    "id": "150"
  },
  {
    "raw_code": "def create_reader(klass, member)\n    new_meth = register MethodObject.new(klass, member, :instance) do |o|\n      o.signature ||= \"def #{member}\"\n      o.source ||= \"#{o.signature}\\n  @#{member}\\nend\"\n    end",
    "comment": "Creates the getter (reader) method and attaches it to the class as an attribute. Also sets up the docstring to prettify the documentation output.  @param [ClassObject] klass the class to attach the method to @param [String] member the name of the member we're generating a method for",
    "label": "",
    "id": "151"
  },
  {
    "raw_code": "def create_attributes(klass, members)\n    # For each parameter, add reader and writers\n    members.each do |member|\n      next if klass.attributes[:instance][member]\n      klass.attributes[:instance][member] = SymbolHash[:read => nil, :write => nil]\n      create_writer klass, member if create_member_method?(klass, member, :write)\n      create_reader klass, member if create_member_method?(klass, member, :read)\n    end",
    "comment": "Creates the given member methods and attaches them to the given ClassObject.  @param [ClassObject] klass the class to generate attributes for @param [Array<String>] members a list of member names",
    "label": "",
    "id": "152"
  },
  {
    "raw_code": "def extract_parameters(superclass)\n    return [] unless superclass.parameters\n    members = superclass.parameters.select {|x| x && x.type == :symbol_literal }\n    members.map! {|x| x.source.strip[1..-1] }\n    members\n  end",
    "comment": "Extract the parameters from the Struct.new or Data.define AST node, returning them as a list of strings  @param [MethodCallNode] superclass the AST node for the Struct.new or Data.define call @return [Array<String>] the member names to generate methods for",
    "label": "",
    "id": "153"
  },
  {
    "raw_code": "def process_decorator(*nodes, &block)\n    opts = nodes.last.is_a?(Hash) ? nodes.pop : {}\n\n    all_nodes = statement.parameters.select do |p|\n      p.is_a? YARD::Parser::Ruby::AstNode\n    end",
    "comment": "@overload process_decorator(*nodes, opts = {}, &block) Takes care of parsing method definitions passed to decorators as parameters, as well as parsing chained decorators.  Use this in a handler's process block.  @yieldparam method [YARD::CodeObjects::MethodObject] Method being decorated. @yieldparam node [YARD::Parser::Ruby::AstNode] AST node of the decorated method. @yieldparam name [Symbol] Name of the decorated method. @return [Array<Hash>] Array of hashes containing :method, :node, :name. See yield params.  @param nodes [YARD::Parser::Ruby::AstNode] AST nodes that refer to decorated methods, like indexes of statement.parameter. Defaults to all parameters. Pass nil to specify zero parameters.  @option opts [:instance, :class] :scope (:instance) Scope to use for each MethodObject.  @option opts [true, false] :transfer_docstring Set false to disable transferring the decorator docstring to method definitions passed to the decorator as parameters.  @option opts [true, false] :transfer_source Set false to disable transferring the decorator source code string to method definitions passed to the decorator as parameters.  @example Basic Usage # Simply pass the method docs through to the method definition. process do process_decorator end  @example Setting a method's visibility to private. process do process_decorator :scope => :class do |method| method.visibility = :private if method.respond_to? :visibility end end",
    "label": "",
    "id": "154"
  },
  {
    "raw_code": "def extract_parameters(superstring)\n    paramstring = superstring.match(/\\A(O?Struct)\\.new\\((.*?)\\)/)[2]\n    paramstring.split(\",\").select {|x| x.strip[0, 1] == \":\" }.map {|x| x.strip[1..-1] } # the 1..-1 chops the leading :\n  end",
    "comment": "Extracts the parameter list from the Struct.new declaration and returns it formatted as a list of member names. Expects the user will have used symbols to define the struct member names  @param [String] superstring the string declaring the superclass @return [Array<String>] a list of member names",
    "label": "",
    "id": "155"
  },
  {
    "raw_code": "def parse_condition\n    condition = nil\n\n    # Right now we can handle very simple unary conditions like:\n    #   if true\n    #   if false\n    #   if 0\n    #   if 100 (not 0)\n    #   if defined? SOME_CONSTANT\n    #\n    # The last case will do a lookup in the registry and then one\n    # in the Ruby world (using eval).\n    case statement.tokens[1..-1].to_s.strip\n    when /^(\\d+)$/\n      condition = $1 != \"0\"\n    when /^defined\\?\\s*\\(?\\s*([A-Za-z0-9:_]+?)\\s*\\)?$/\n      # defined? keyword used, let's see if we can look up the name\n      # in the registry, then we'll try using Ruby's powers. eval() is not\n      # *too* dangerous here since code is not actually executed.\n      name = $1\n      obj = YARD::Registry.resolve(namespace, name, true)\n      begin\n        condition = true if obj || Object.instance_eval(\"defined? #{name}\")\n      rescue SyntaxError, NameError\n        condition = false\n      end",
    "comment": "Parses the condition part of the if/unless statement  @return [true, false, nil] true if the condition can be definitely parsed to true, false if not, and nil if the condition cannot be parsed with certainty (it's dynamic) @since 0.5.5",
    "label": "",
    "id": "156"
  },
  {
    "raw_code": "def parse_then_block\n    parse_block(:visibility => visibility)\n  end",
    "comment": "@since 0.5.5",
    "label": "",
    "id": "157"
  },
  {
    "raw_code": "def parse_else_block\n    return unless statement.block\n    stmtlist = YARD::Parser::Ruby::Legacy::StatementList\n    stmtlist.new(statement.block).each do |stmt|\n      next unless TkELSE === stmt.tokens.first\n      push_state(:visibility => visibility) do\n        parser.process(stmtlist.new(stmt.block))\n      end",
    "comment": "@since 0.5.5",
    "label": "",
    "id": "158"
  },
  {
    "raw_code": "def self.handles?(stmt)\n          handlers.any? do |a_handler|\n            case a_handler\n            when String\n              stmt.tokens.first.text == a_handler\n            when Regexp\n              stmt.tokens.to_s =~ a_handler\n            else\n              a_handler == stmt.tokens.first.class\n            end",
    "comment": "@return [Boolean] whether or not a {Parser::Ruby::Legacy::Statement} object should be handled by this handler.",
    "label": "",
    "id": "159"
  },
  {
    "raw_code": "def parse_block(opts = {})\n          push_state(opts) do\n            if statement.block\n              blk = Parser::Ruby::Legacy::StatementList.new(statement.block)\n              parser.process(blk)\n            end",
    "comment": "Parses a statement's block with a set of state values. If the statement has no block, nothing happens. A description of state values can be found at {Handlers::Base#push_state}  @param [Hash] opts State options @option opts (see Handlers::Base#push_state) @see Handlers::Base#push_state #push_state",
    "label": "",
    "id": "160"
  },
  {
    "raw_code": "def extract_method_details\n          if statement.tokens.to_s =~ /^def\\s+(#{METHODMATCH})(?:(?:\\s+|\\s*\\()(.*)(?:\\)\\s*$)?)?/m\n            meth = $1\n            args = $2\n            meth.gsub!(/\\s+/, '')\n            args = tokval_list(Parser::Ruby::Legacy::TokenList.new(args), :all)\n            args.map! {|a| k, v = *a.split('=', 2); [k.strip, (v ? v.strip : nil)] } if args\n            meth = $` if meth =~ /(?:#{NSEPQ}|#{CSEPQ})([^#{NSEP}#{CSEPQ}]+)$/\n            [meth, args]\n          end",
    "comment": "Extracts method information for macro expansion only  @todo This is a duplicate implementation of {MethodHandler}. Refactor. @return [Array<String,Array<Array<String>>>] the method name followed by method arguments (name and optional value)",
    "label": "",
    "id": "161"
  },
  {
    "raw_code": "def tokval(token, *accepted_types)\n          accepted_types = [TkVal] if accepted_types.empty?\n          accepted_types.push(TkNode) if accepted_types.include? TkVal\n\n          if accepted_types.include?(:attr)\n            accepted_types.push(TkSTRING, TkSYMBOL)\n          end",
    "comment": "The string value of a token. For example, the return value for the symbol :sym would be :sym. The return value for a string +\"foo #{ bar}\"+ would be the literal +\"foo #{ bar}\"+ without any interpolation. The return value of the identifier 'test' would be the same value: 'test'. Here is a list of common types and their return values:  @example tokval(TokenList.new('\"foo\"').first) => \"foo\" tokval(TokenList.new(':foo').first) => :foo tokval(TokenList.new('CONSTANT').first, RubyToken::TkId) => \"CONSTANT\" tokval(TokenList.new('identifier').first, RubyToken::TkId) => \"identifier\" tokval(TokenList.new('3.25').first) => 3.25 tokval(TokenList.new('/xyz/i').first) => /xyz/i  @param [Token] token The token of the class  @param [Array<Class<Token>>, Symbol] accepted_types The allowed token types that this token can be. Defaults to [{TkVal}]. A list of types would be, for example, [+TkSTRING+, +TkSYMBOL+], to return the token's value if it is either of those types. If +TkVal+ is accepted, +TkNode+ is also accepted.  Certain symbol keys are allowed to specify multiple types in one fell swoop. These symbols are: :string       => +TkSTRING+, +TkDSTRING+, +TkDXSTRING+ and +TkXSTRING+ :attr         => +TkSYMBOL+ and +TkSTRING+ :identifier   => +TkIDENTIFIER, +TkFID+ and +TkGVAR+. :number       => +TkFLOAT+, +TkINTEGER+  @return [Object] if the token is one of the accepted types, in its real value form. It should be noted that identifiers and constants are kept in String form. @return [nil] if the token is not any of the specified accepted types",
    "label": "",
    "id": "162"
  },
  {
    "raw_code": "def tokval_list(tokenlist, *accepted_types)\n          return [] unless tokenlist\n          out = [[]]\n          parencount = 0\n          beforeparen = 0\n          needcomma = false\n          seen_comma = true\n          tokenlist.each do |token|\n            tokval = accepted_types == [:all] ? token.text : tokval(token, *accepted_types)\n            parencond = !out.last.empty? && !tokval.nil?\n            # puts \"#{seen_comma.inspect} #{parencount} #{token.class.class_name} #{out.inspect}\"\n            case token\n            when TkCOMMA\n              if parencount == 0\n                out << [] unless out.last.empty?\n                needcomma = false\n                seen_comma = true\n              elsif parencond\n                out.last << token.text\n              end",
    "comment": "Returns a list of symbols or string values from a statement. The list must be a valid comma delimited list, and values will only be returned to the end of the list only.  Example: attr_accessor :a, 'b', :c, :d => ['a', 'b', 'c', 'd'] attr_accessor 'a', UNACCEPTED_TYPE, 'c' => ['a', 'c']  The tokval list of a {Parser::Ruby::Legacy::TokenList} of the above code would be the {#tokval} value of :a, 'b', :c and :d.  It should also be noted that this function stops immediately at any ruby keyword encountered: \"attr_accessor :a, :b, :c if x == 5\"  => ['a', 'b', 'c']  @param [TokenList] tokenlist The list of tokens to process. @param [Array<Class<Token>>] accepted_types passed to {#tokval} @return [Array<String>] the list of tokvalues in the list. @return [Array<EMPTY>] if there are no symbols or Strings in the list @see #tokval",
    "label": "",
    "id": "163"
  },
  {
    "raw_code": "def self.handles?(statement, processor)\n          processor.globals.cruby_processed_files ||= {}\n          processor.globals.cruby_processed_files[processor.file] = true\n\n          src = statement.respond_to?(:declaration) ?\n            statement.declaration : statement.source\n\n          handlers.any? do |a_handler|\n            statement_class >= statement.class &&\n              case a_handler\n              when String\n                src == a_handler\n              when Regexp\n                src =~ a_handler\n              end",
    "comment": "@return [Boolean] whether the handler handles this statement",
    "label": "",
    "id": "164"
  },
  {
    "raw_code": "def register_docstring(object, docstring = nil, stmt = nil)\n          super(object, docstring, stmt) if docstring\n        end",
    "comment": "@group Registering objects",
    "label": "",
    "id": "165"
  },
  {
    "raw_code": "def symbols\n          globals.cruby_symbols ||= {}\n        end",
    "comment": "@group Looking up Symbol and Var Values",
    "label": "",
    "id": "166"
  },
  {
    "raw_code": "def parse_block(opts = {})\n          return if !statement.block || statement.block.empty?\n          push_state(opts) do\n            parser.process(statement.block)\n          end",
    "comment": "@group Parsing an Inner Block",
    "label": "",
    "id": "167"
  },
  {
    "raw_code": "def process_file(file, object)\n          file = File.cleanpath(file)\n          return if processed_files[file]\n          processed_files[file] = file\n          begin\n            log.debug \"Processing embedded call to C source #{file}...\"\n            globals.ordered_parser.files.delete(file) if globals.ordered_parser\n            parser.process(Parser::C::CParser.new(File.read(file), file).parse)\n          rescue Errno::ENOENT\n            log.warn \"Missing source file `#{file}' when parsing #{object}\"\n          end",
    "comment": "@group Processing other files",
    "label": "",
    "id": "168"
  },
  {
    "raw_code": "def add_predicate_return_tag(obj)\n        if obj.tag(:return) && (obj.tag(:return).types || []).empty?\n          obj.tag(:return).types = ['Boolean']\n        elsif obj.tag(:return).nil?\n          unless obj.tags(:overload).any? {|overload| overload.tag(:return) }\n            obj.add_tag(YARD::Tags::Tag.new(:return, \"\", \"Boolean\"))\n          end",
    "comment": "@param [MethodObject] obj",
    "label": "",
    "id": "169"
  },
  {
    "raw_code": "def initialize(tag_name, text, types = nil, name = nil)\n        @tag_name = tag_name.to_s\n        @text = text\n        @name = name\n        @types = (types ? [types].flatten.compact : nil)\n      end",
    "comment": "Creates a new tag object with a tag name and text. Optionally, formally declared types and a key name can be specified.  Types are mainly for meta tags that rely on type information, such as +param+, +return+, etc.  Key names are for tags that declare meta data for a specific key or name, such as +param+, +raise+, etc.  @param [#to_s] tag_name        the tag name to create the tag for @param [String, nil] text      the descriptive text for this tag, or nil if none provided @param [Array<String>] types   optional type list of formally declared types for the tag @param [String] name           optional key name which the tag refers to",
    "label": "",
    "id": "170"
  },
  {
    "raw_code": "def type\n        types.first\n      end",
    "comment": "Convenience method to access the first type specified. This should mainly be used for tags that only specify one type.  @return [String] the first of the list of specified types @see #types",
    "label": "",
    "id": "171"
  },
  {
    "raw_code": "def explain_types\n        return nil if !types || types.empty?\n        TypesExplainer.explain(*types)\n      end",
    "comment": "Provides a plain English summary of the type specification, or nil if no types are provided or parsable.  @return [String] a plain English description of the associated types @return [nil] if no types are provided or not parsable",
    "label": "",
    "id": "172"
  },
  {
    "raw_code": "def self.explain(*types)\n        explain!(*types)\n      rescue SyntaxError\n        nil\n      end",
    "comment": "(see Tag#explain_types) @param types [Array<String>] a list of types to parse and summarize",
    "label": "",
    "id": "173"
  },
  {
    "raw_code": "def self.explain!(*types)\n        Parser.parse(types.join(\", \")).join(\"; \")\n      end",
    "comment": "(see explain) @raise [SyntaxError] if the types are not parsable",
    "label": "",
    "id": "174"
  },
  {
    "raw_code": "def parse_tag(tag_name, text)\n        Tag.new(tag_name, text.strip)\n      end",
    "comment": "Parses tag text and creates a new tag with descriptive text  @param tag_name        the name of the tag to parse @param [String] text   the raw tag text @return [Tag]          a tag object with the tag_name and text values filled",
    "label": "",
    "id": "175"
  },
  {
    "raw_code": "def parse_tag_with_name(tag_name, text)\n        name, text = *extract_name_from_text(text)\n        Tag.new(tag_name, text, nil, name)\n      end",
    "comment": "Parses tag text and creates a new tag with a key name and descriptive text  @param tag_name        the name of the tag to parse @param [String] text   the raw tag text @return [Tag]          a tag object with the tag_name, name and text values filled",
    "label": "",
    "id": "176"
  },
  {
    "raw_code": "def parse_tag_with_types(tag_name, text)\n        name, types, text = *extract_types_and_name_from_text(text)\n        raise TagFormatError, \"cannot specify a name before type list for '@#{tag_name}'\" if name\n        Tag.new(tag_name, text, types)\n      end",
    "comment": "Parses tag text and creates a new tag with formally declared types and descriptive text  @param tag_name        the name of the tag to parse @param [String] text   the raw tag text @return [Tag]          a tag object with the tag_name, types and text values filled",
    "label": "",
    "id": "177"
  },
  {
    "raw_code": "def parse_tag_with_types_and_name(tag_name, text)\n        name, types, text = *extract_types_and_name_from_text(text)\n        name, text = *extract_name_from_text(text) unless name\n        Tag.new(tag_name, text, types, name)\n      end",
    "comment": "Parses tag text and creates a new tag with formally declared types, a key name and descriptive text  @param tag_name        the name of the tag to parse @param [String] text   the raw tag text @return [Tag]          a tag object with the tag_name, name, types and text values filled",
    "label": "",
    "id": "178"
  },
  {
    "raw_code": "def parse_tag_with_types_and_title(tag_name, text)\n        name, types, text = *extract_types_and_name_from_text_unstripped(text)\n        if name\n          title = name\n          desc = text\n        else\n          title, desc = *extract_title_and_desc_from_text(text)\n        end",
    "comment": "Parses tag text and creates a new tag with formally declared types, a title on the first line and descriptive text  @param tag_name        the name of the tag to parse @param [String] text   the raw tag text @return [Tag]          a tag object with the tag_name, name, types and text values filled",
    "label": "",
    "id": "179"
  },
  {
    "raw_code": "def extract_name_from_text(text)\n        text.strip.split(/\\s+/, 2)\n      end",
    "comment": "Extracts the name from raw tag text returning the name and remaining value  @param [String] text the raw tag text @return [Array] an array holding the name as the first element and the value as the second element",
    "label": "",
    "id": "180"
  },
  {
    "raw_code": "def extract_types_and_name_from_text(text, opening_types = TYPELIST_OPENING_CHARS, closing_types = TYPELIST_CLOSING_CHARS)\n        before, list, text = *extract_types_and_name_from_text_unstripped(text, opening_types, closing_types)\n        if list.nil?\n          [nil, nil, text.strip]\n        else\n          [before ? before.strip : nil, list.map(&:strip), text.strip]\n        end",
    "comment": "Parses a [], <>, {} or () block at the beginning of a line of text into a list of comma delimited values.  @example obj.parse_types('[String, Array<Hash, String>, nil]') # => [nil, ['String', 'Array<Hash, String>', 'nil'], \"\"] obj.parse_types('b<String> A string') # => ['b', ['String'], 'A string']  @return [Array(String, Array<String>, String)] the text before the type list (or nil), followed by the type list parsed into an array of strings, followed by the text following the type list.",
    "label": "",
    "id": "181"
  },
  {
    "raw_code": "def instance\n          @instance ||= new\n        end",
    "comment": "@!attribute instance @return [Library] the main Library instance object.",
    "label": "",
    "id": "182"
  },
  {
    "raw_code": "def default_factory\n          @default_factory ||= DefaultFactory.new\n        end",
    "comment": "@!attribute default_factory Replace the factory object responsible for parsing tags by setting this to an object (or class) that responds to +parse_TAGNAME+ methods where +TAGNAME+ is the name of the tag.  You should set this value before performing any source parsing with YARD, otherwise your factory class will not be used.  @example YARD::Tags::Library.default_factory = MyFactory  @see DefaultFactory",
    "label": "",
    "id": "183"
  },
  {
    "raw_code": "def factory_method_for(tag)\n          @factory_methods[tag]\n        end",
    "comment": "Returns the factory method used to parse the tag text for a specific tag  @param [Symbol] tag the tag name @return [Symbol] the factory method name for the tag @return [Class<Tag>,Symbol] the Tag class to use to parse the tag or the method to call on the factory class @return [nil] if the tag is freeform text @since 0.6.0",
    "label": "",
    "id": "184"
  },
  {
    "raw_code": "def factory_method_for_directive(directive)\n          @directive_factory_classes[directive]\n        end",
    "comment": "Returns the factory method used to parse the tag text for a specific directive  @param [Symbol] directive the directive name @return [Symbol] the factory method name for the tag @return [Class<Tag>,Symbol] the Tag class to use to parse the tag or the methods to call on the factory class @return [nil] if the tag is freeform text @since 0.8.0",
    "label": "",
    "id": "185"
  },
  {
    "raw_code": "def sorted_labels\n          labels.sort_by {|a| a.last.downcase }\n        end",
    "comment": "Sorts the labels lexically by their label name, often used when displaying the tags.  @return [Array<Symbol>, String] the sorted labels as an array of the tag name and label",
    "label": "",
    "id": "186"
  },
  {
    "raw_code": "def define_tag(label, tag, meth = nil)\n          tag_meth = tag_method_name(tag)\n          if meth.is_a?(Class) && Tag > meth\n            class_eval(<<-eof, __FILE__, __LINE__ + 1)\n              def #{tag_meth}(text)\n                #{meth}.new(#{tag.inspect}, text)\n              end\n            eof\n          else\n            class_eval(<<-eof, __FILE__, __LINE__ + 1)\n              begin; undef #{tag_meth}; rescue NameError; end\n              def #{tag_meth}(text)\n                send_to_factory(#{tag.inspect}, #{meth.inspect}, text)\n              end\n            eof\n          end",
    "comment": "Convenience method to define a new tag using one of {Tag}'s factory methods, or the regular {DefaultFactory#parse_tag} factory method if none is supplied.  @!macro [attach] yard.tag @!method $2_tag @!visibility private @yard.tag $2 [$3] $1 @param [#to_s] label the label used when displaying the tag in templates @param [#to_s] tag the tag name to create @param [#to_s, Class<Tag>] meth the {Tag} factory method to call when creating the tag or the name of the class to directly create a tag for",
    "label": "",
    "id": "187"
  },
  {
    "raw_code": "def define_directive(tag, tag_meth = nil, directive_class = nil)\n          directive_meth = directive_method_name(tag)\n          if directive_class.nil?\n            directive_class = tag_meth\n            tag_meth = nil\n          end",
    "comment": "@macro [attach] yard.directive @!method $1_directive @!visibility private @yard.directive $1 [$2] $-1 @overload define_directive(tag, tag_meth = nil, directive_class) Convenience method to define a new directive using a {Tag} factory method and {Directive} subclass that implements the directive callbacks.  @param [#to_s] tag the tag name of the directive @param [#to_s] tag_meth the tag factory method to use when parsing tag information @param [Class<Directive>] the directive class that implements the directive behaviour @see define_tag",
    "label": "",
    "id": "188"
  },
  {
    "raw_code": "def directive_call(tag, parser)\n        meth = self.class.factory_method_for_directive(tag.tag_name)\n        if meth <= Directive\n          meth = meth.new(tag, parser)\n          meth.call\n          meth\n        else\n          meth.call(tag, parser)\n        end",
    "comment": "@return [Directive]",
    "label": "",
    "id": "189"
  },
  {
    "raw_code": "def has_tag?(tag_name)\n        tag_name && respond_to?(self.class.tag_method_name(tag_name))\n      end",
    "comment": "@param [#to_s] tag_name the name of the tag to look for @return [Boolean] whether a tag by the given name is registered in the library.",
    "label": "",
    "id": "190"
  },
  {
    "raw_code": "def tag_create(tag_name, tag_buf)\n        send(self.class.tag_method_name(tag_name), tag_buf)\n      end",
    "comment": "Creates a new {Tag} object with a given tag name and data @return [Tag] the newly created tag object",
    "label": "",
    "id": "191"
  },
  {
    "raw_code": "def has_directive?(tag_name)\n        tag_name && respond_to?(self.class.directive_method_name(tag_name))\n      end",
    "comment": "@param [#to_s] tag_name the name of the tag to look for @return [Boolean] whether a directive by the given name is registered in the library.",
    "label": "",
    "id": "192"
  },
  {
    "raw_code": "def directive_create(tag_name, tag_buf, parser)\n        meth = self.class.factory_method_for(tag_name)\n        tag = send_to_factory(tag_name, meth, tag_buf)\n        meth = self.class.directive_method_name(tag_name)\n        send(meth, tag, parser)\n      end",
    "comment": "Creates a new directive with tag information and a docstring parser object. @param [String] tag_name the name of the tag @param [String] tag_buf the tag data @param [DocstringParser] parser the parser object parsing the docstring @return [Directive] the newly created directive",
    "label": "",
    "id": "193"
  },
  {
    "raw_code": "def object; parser.object end\n\n      # @!attribute [r] handler\n      # @return [Handlers::Base, nil] the handler object the docstring parser\n      #   might be attached to. May be nil. Only available when parsing\n      #   through {Parser::SourceParser}.\n      def handler; parser.handler end\n\n      # @!endgroup\n\n      # @param [Tag] tag the meta-data tag containing all input to the docstring\n      # @param [DocstringParser] parser the docstring parser object\n      def initialize(tag, parser)\n        self.tag = tag\n        self.parser = parser\n        self.expanded_text = nil\n      end\n\n      # @!group Parser callbacks\n\n      # Called when processing the directive. Subclasses should implement\n      # this method to perform all functionality of the directive.\n      #\n      # @abstract implement this method to perform all data processing for\n      #   the directive.\n      # @return [void]\n      def call; raise NotImplementedError end\n\n      # Called after parsing all directives and tags in the docstring. Used\n      # to perform any cleanup after all directives perform their main task.\n      # @return [void]\n      def after_parse; end\n\n      protected :parser\n\n      protected\n\n      def inside_directive?\n        return true if parser.state.inside_directive\n        parser.directives.any? { |d| d.is_a?(MethodDirective) && d.tag.text.empty? }\n      end\n    end\n\n    # Ends a group listing definition. Group definition automatically end\n    # when class or module blocks are closed, and defining a new group overrides\n    # the last group definition, but occasionally you need to end the current\n    # group to return to the default listing. Use {tag:!group} to begin a\n    # group listing.\n    #\n    # @example\n    #   class Controller\n    #     # @!group Callbacks\n    #\n    #     def before_filter; end\n    #     def after_filter; end\n    #\n    #     # @!endgroup\n    #\n    #     def index; end\n    #   end\n    # @see tag:!group\n    # @since 0.6.0\n    class EndGroupDirective < Directive\n      def call\n        return unless handler\n        handler.extra_state.group = nil\n      end\n    end\n\n    # Defines a group listing. All methods (and attributes) seen after this\n    # directive are placed into a group with the given description as the\n    # group name. The group listing is used by templates to organize methods\n    # and attributes into respective logical groups. To end a group listing\n    # use {tag:!endgroup}.\n    #\n    # @note A group definition only applies to the scope it is defined in.\n    #   If a new class or module is opened after the directive, this directive\n    #   will not apply to methods in that class or module.\n    # @example\n    #   # @!group Callbacks\n    #\n    #   def before_filter; end\n    #   def after_filter; end\n    # @see tag:!endgroup\n    # @since 0.6.0\n    class GroupDirective < Directive\n      def call\n        return unless handler\n        handler.extra_state.group = tag.text\n      end\n    end\n\n    # Defines a block of text to be expanded whenever the macro is called by name\n    # in subsequent docstrings. The macro data can be any arbitrary text data, be\n    # it regular documentation, meta-data tags or directives.\n    #\n    # == Defining a Macro\n    #\n    # A macro must first be defined in order to be used. Note that a macro is also\n    # expanded upon definition if it defined on an object (the docstring of a\n    # method, class, module or constant object as opposed to a free standing\n    # comment). To define a macro, use the \"new\" or \"attach\" identifier in the\n    # types specifier list. A macro will also automatically be created if an\n    # indented macro data block is given, so the keywords are not strictly needed.\n    #\n    # === Anonymous Macros\n    #\n    # In addition to standard named macros, macros can be defined anonymously if\n    # no name is given. In this case, they can not be re-used in future docstrings,\n    # but they will expand in the first definition. This is useful when needing\n    # to take advantage of the macro expansion variables (described below).\n    #\n    # == Using a Macro\n    #\n    # To re-use a macro in another docstring after it is defined, simply use\n    # <tt>@!macro the_name</tt> with no indented block of macro data. The resulting\n    # data will be expanded in place.\n    #\n    # == Attaching a Macro to a DSL Method\n    #\n    # Macros can be defined to auto-expand on DSL-style class method calls. To\n    # define a macro to be auto expanded in this way, use the \"attach\" keyword\n    # in the type specifier list (\"new\" is implied).\n    #\n    # Attached macros can also be attached directly on the class method declaration\n    # that provides the DSL method to its subclasses. The syntax in either case\n    # is the same.\n    #\n    # == Macro Expansion Variables\n    #\n    # In the case of using macros on DSL-style method calls, a number of expansion\n    # variables can be used for interpolation inside of the macro data. The variables,\n    # similar in syntax to Ruby's global variables, are as follows:\n    #\n    # * $0 - the method name being called\n    # * $1, $2, $3, ... - the Nth argument in the method call\n    # * $& - the full source line\n    #\n    # The following example shows what the expansion variables might hold for a given\n    # DSL method call:\n    #\n    #   property :foo, :a, :b, :c, String\n    #   # $0 => \"property\"\n    #   # $1 => \"foo\"\n    #   # $2 => \"a\"\n    #   # $& => \"property :foo, :a, :b, :c, String\"\n    #\n    # === Ranges\n    #\n    # Ranges are also acceptable with the syntax <tt>${N-M}</tt>. Negative values\n    # on either N or M are valid, and refer to indexes from the end of the list.\n    # Consider a DSL method that creates a method using the first argument with\n    # argument names following, ending with the return type of the method. This\n    # could be documented as:\n    #\n    #     # @!macro dsl_method\n    #     #   @!method $1(${2--2})\n    #     #   @return [${-1}] the return value of $0\n    #     create_method_with_args :foo, :a, :b, :c, String\n    #\n    # As described, the method is using the signature <tt>foo(a, b, c)</tt> and the return\n    # type from the last argument, +String+. When using ranges, tokens are joined\n    # with commas. Note that this includes using $0:\n    #\n    #     !!!plain\n    #     $0-1 # => Interpolates to \"create_method_with_args, foo\"\n    #\n    # If you want to separate them with spaces, use <tt>$1 $2 $3 $4 ...</tt>. Note that\n    # if the token cannot be expanded, it will return the empty string (not an error),\n    # so it would be safe to list <tt>$1 $2 ... $10</tt>, for example.\n    #\n    # === Escaping Interpolation\n    #\n    # Interpolation can be escaped by prefixing the +$+ with +\\\\\\+, like so:\n    #\n    #     # @!macro foo\n    #     #   I have \\$2.00 USD.\n    #\n    # @example Defining a simple macro\n    #   # @!macro [new] returnself\n    #   #   @return [self] returns itself\n    # @example Using a simple macro in multiple docstrings\n    #   # Documentation for map\n    #   # ...\n    #   # @macro returnself\n    #   def map; end\n    #\n    #   # Documentation for filter\n    #   # ...\n    #   # @macro returnself\n    #   def filter; end\n    # @example Attaching a macro to a class method (for DSL usage)\n    #     class Resource\n    #       # Defines a new property\n    #       # @param [String] name the property name\n    #       # @param [Class] type the property's type\n    #       # @!macro [attach] property\n    #       #   @return [$2] the $1 property\n    #       def self.property(name, type) end\n    #     end\n    #\n    #     class Post < Resource\n    #       property :title, String\n    #       property :view_count, Integer\n    #     end\n    # @example Attaching a macro directly to a DSL method\n    #     class Post < Resource\n    #       # @!macro [attach] property\n    #       #   @return [$2] the $1 property\n    #       property :title, String\n    #\n    #       # Macro will expand on this definition too\n    #       property :view_count, Integer\n    #     end\n    # @since 0.7.0\n    class MacroDirective < Directive\n      def call\n        raise TagFormatError if tag.name.nil? && tag.text.to_s.empty?\n        macro_data = find_or_create\n        unless macro_data\n          warn\n          return\n        end\n\n        self.expanded_text = expand(macro_data)\n      end",
    "comment": "@!attribute [r] object @return [CodeObjects::Base, nil] the object the parent docstring is attached to. May be nil.",
    "label": "",
    "id": "194"
  },
  {
    "raw_code": "def initialize(name = :yard)\n        @name = name\n        @options = []\n        @stats_options = []\n        @files = []\n\n        yield self if block_given?\n        self.options += ENV['OPTS'].split(/[ ,]/) if ENV['OPTS']\n        self.files   += ENV['FILES'].split(/[ ,]/) if ENV['FILES']\n        self.options << '--no-stats' unless stats_options.empty?\n\n        define\n      end",
    "comment": "Creates a new task with name +name+.  @param [String, Symbol] name the name of the rake task @yield a block to allow any options to be modified on the task @yieldparam [YardocTask] _self the task object to allow any parameters to be changed.",
    "label": "",
    "id": "195"
  },
  {
    "raw_code": "def define\n        desc \"Generate YARD Documentation\" unless ::Rake.application.last_description\n        task(name) do\n          before.call if before.is_a?(Proc)\n          yardoc = YARD::CLI::Yardoc.new\n          yardoc.options[:verifier] = verifier if verifier\n          yardoc.run(*(options + files))\n          YARD::CLI::Stats.run(*(stats_options + ['--use-cache'])) unless stats_options.empty?\n          after.call if after.is_a?(Proc)\n        end",
    "comment": "Defines the rake task @return [void]",
    "label": "",
    "id": "196"
  },
  {
    "raw_code": "def self.generation_hook(installer, specs)\n      start = Time.now\n      types = installer.document\n\n      generate_yard = types.include?('yardoc') || types.include?('yard')\n      generate_yri = types.include? 'yri'\n\n      specs.each do |spec|\n        gen_yard = generate_yard\n        gen_yri = generate_yri\n        gen_yri = false if gen_yard # never generate both, no need\n        unless types.empty? # --no-document is not in effect\n          # look at spec.metadata['yard.run'] for override\n          run_yard = spec.metadata['yard.run']\n          gen_yard = true if run_yard && run_yard != 'yri'\n          gen_yri = true if run_yard == 'yri'\n        end",
    "comment": " Post installs hook that generates documentation for each specification in +specs+",
    "label": "",
    "id": "197"
  },
  {
    "raw_code": "def self.removal_hook(uninstaller)\n      new(uninstaller.spec).remove\n    end",
    "comment": " Pre uninstalls hook that removes documentation ",
    "label": "",
    "id": "198"
  },
  {
    "raw_code": "def self.load_yard\n      return if @yard_version\n\n      require 'yard'\n\n      @yard_version = Gem::Version.new ::YARD::VERSION\n    end",
    "comment": " Loads the YARD generator",
    "label": "",
    "id": "199"
  },
  {
    "raw_code": "def generate\n      return if @spec.default_gem?\n      return unless @generate_yri || @generate_yard\n\n      setup\n\n      install_yri if @generate_yri && (@force || !File.exist?(@yri_dir))\n\n      install_yard if @generate_yard && (@force || !File.exist?(@yard_dir))\n    end",
    "comment": " Generates YARD and yri data",
    "label": "",
    "id": "200"
  },
  {
    "raw_code": "def setup\n      self.class.load_yard\n\n      if File.exist?(@doc_dir)\n        raise Gem::FilePermissionError, @doc_dir unless File.writable?(@doc_dir)\n      else\n        FileUtils.mkdir_p @doc_dir\n      end",
    "comment": " Prepares the spec for documentation generation",
    "label": "",
    "id": "201"
  },
  {
    "raw_code": "def remove\n      uninstall_yri\n      uninstall_yard\n    end",
    "comment": " Removes YARD and yri data",
    "label": "",
    "id": "202"
  },
  {
    "raw_code": "def has_yardoc=(value)\n    @has_rdoc = value ? 'yard' : false\n  end",
    "comment": "@since 0.5.3",
    "label": "",
    "id": "203"
  },
  {
    "raw_code": "def from_installed_gems(*deprecated)\n      if deprecated.empty?\n        from_gems_in(*installed_spec_directories)\n      else\n        from_gems_in(*deprecated) # HACK: warn\n      end",
    "comment": " Factory method to construct a source index instance for a given path.  deprecated:: If supplied, from_installed_gems will act just like +from_gems_in+.  This argument is deprecated and is provided just for backwards compatibility, and should not generally be used.  return:: SourceIndex instance",
    "label": "",
    "id": "204"
  },
  {
    "raw_code": "def installed_spec_directories\n      Gem.path.collect {|dir| File.join(dir, \"specifications\") }\n    end",
    "comment": " Returns a list of directories from Gem.path that contain specifications.",
    "label": "",
    "id": "205"
  },
  {
    "raw_code": "def from_gems_in(*spec_dirs)\n      source_index = new\n      source_index.spec_dirs = spec_dirs\n      source_index.refresh!\n    end",
    "comment": " Creates a new SourceIndex from the ruby format gem specifications in +spec_dirs+.",
    "label": "",
    "id": "206"
  },
  {
    "raw_code": "def load_specification(file_name)\n      Gem::Specification.load file_name\n    end",
    "comment": " Loads a ruby-format specification from +file_name+ and returns the loaded spec.",
    "label": "",
    "id": "207"
  },
  {
    "raw_code": "def initialize(specifications = {})\n    @gems = {}\n    specifications.each {|_full_name, spec| add_spec spec }\n    @spec_dirs = nil\n  end",
    "comment": " Constructs a source index instance from the provided specifications, which is a Hash of gem full names and Gem::Specifications. -- TODO merge @gems and @prerelease_gems and provide a separate method #prerelease_gems",
    "label": "",
    "id": "208"
  },
  {
    "raw_code": "def all_gems\n    @gems\n  end",
    "comment": "TODO: remove method",
    "label": "",
    "id": "209"
  },
  {
    "raw_code": "def load_gems_in(*spec_dirs)\n    @gems.clear\n\n    spec_dirs.reverse_each do |spec_dir|\n      spec_files = Dir.glob File.join(spec_dir, '*.gemspec')\n\n      spec_files.each do |spec_file|\n        gemspec = Gem::Specification.load spec_file\n        add_spec gemspec if gemspec\n      end",
    "comment": " Reconstruct the source index from the specifications in +spec_dirs+.",
    "label": "",
    "id": "210"
  },
  {
    "raw_code": "def latest_specs(include_prerelease = false)\n    result = Hash.new {|h, k| h[k] = [] }\n    latest = {}\n\n    sort.each do |_, spec|\n      name = spec.name\n      curr_ver = spec.version\n      prev_ver = latest.key?(name) ? latest[name].version : nil\n\n      next if !include_prerelease && curr_ver.prerelease?\n      next unless prev_ver.nil? || curr_ver >= prev_ver ||\n                  latest[name].platform != Gem::Platform::RUBY\n\n      if prev_ver.nil? ||\n         (curr_ver > prev_ver && spec.platform == Gem::Platform::RUBY)\n        result[name].clear\n        latest[name] = spec\n      end",
    "comment": " Returns an Array specifications for the latest released versions of each gem in this index.",
    "label": "",
    "id": "211"
  },
  {
    "raw_code": "def prerelease_specs\n    prerelease_gems.values\n  end",
    "comment": " An array including only the prerelease gemspecs",
    "label": "",
    "id": "212"
  },
  {
    "raw_code": "def released_specs\n    released_gems.values\n  end",
    "comment": " An array including only the released gemspecs",
    "label": "",
    "id": "213"
  },
  {
    "raw_code": "def add_spec(gem_spec, name = gem_spec.full_name)\n    # No idea why, but the Indexer wants to insert them using original_name\n    # instead of full_name. So we make it an optional arg.\n    @gems[name] = gem_spec\n  end",
    "comment": " Add a gem specification to the source index.",
    "label": "",
    "id": "214"
  },
  {
    "raw_code": "def add_specs(*gem_specs)\n    gem_specs.each do |spec|\n      add_spec spec\n    end",
    "comment": " Add gem specifications to the source index.",
    "label": "",
    "id": "215"
  },
  {
    "raw_code": "def remove_spec(full_name)\n    @gems.delete full_name\n  end",
    "comment": " Remove a gem specification named +full_name+.",
    "label": "",
    "id": "216"
  },
  {
    "raw_code": "def each(&block) # :yields: gem.full_name, gem\n    @gems.each(&block)\n  end",
    "comment": " Iterate over the specifications in the source index.",
    "label": "",
    "id": "217"
  },
  {
    "raw_code": "def specification(full_name)\n    @gems[full_name]\n  end",
    "comment": " The gem specification given a full gem spec name.",
    "label": "",
    "id": "218"
  },
  {
    "raw_code": "def index_signature\n    require 'digest'\n\n    Digest::SHA256.new.hexdigest(@gems.keys.sort.join(',')).to_s\n  end",
    "comment": " The signature for the source index.  Changes in the signature indicate a change in the index.",
    "label": "",
    "id": "219"
  },
  {
    "raw_code": "def gem_signature(gem_full_name)\n    require 'digest'\n\n    Digest::SHA256.new.hexdigest(@gems[gem_full_name].to_yaml).to_s\n  end",
    "comment": " The signature for the given gem specification.",
    "label": "",
    "id": "220"
  },
  {
    "raw_code": "def find_name(gem_name, requirement = Gem::Requirement.default)\n    dep = Gem::Dependency.new gem_name, requirement\n    search dep\n  end",
    "comment": " Find a gem by an exact match on the short name.",
    "label": "",
    "id": "221"
  },
  {
    "raw_code": "def search(gem_pattern, platform_only = false)\n    requirement = nil\n    only_platform = false\n\n    # TODO: Remove support and warning for legacy arguments after 2008/11\n    unless Gem::Dependency === gem_pattern\n      warn \"#{Gem.location_of_caller.join ':'}:Warning: Gem::SourceIndex#search support for #{gem_pattern.class} patterns is deprecated, use #find_name\"\n    end",
    "comment": " Search for a gem by Gem::Dependency +gem_pattern+.  If +only_platform+ is true, only gems matching Gem::Platform.local will be returned.  An Array of matching Gem::Specification objects is returned.  For backwards compatibility, a String or Regexp pattern may be passed as +gem_pattern+, and a Gem::Requirement for +platform_only+.  This behavior is deprecated and will be removed.",
    "label": "",
    "id": "222"
  },
  {
    "raw_code": "def refresh!\n    raise 'source index not created from disk' if @spec_dirs.nil?\n    load_gems_in(*@spec_dirs)\n  end",
    "comment": " Replaces the gems in the source index from specifications in the directories this source index was created from.  Raises an exception if this source index wasn't created from a directory (via from_gems_in or from_installed_gems, or having spec_dirs set).",
    "label": "",
    "id": "223"
  },
  {
    "raw_code": "def outdated\n    outdateds = []\n\n    latest_specs.each do |local|\n      dependency = Gem::Dependency.new local.name, \">= #{local.version}\"\n\n      fetcher = Gem::SpecFetcher.fetcher\n      remotes = fetcher.find_matching dependency\n      remotes = remotes.map {|(_, version, _), _| version }\n\n      latest = remotes.sort.last\n\n      outdateds << local.name if latest && local.version < latest\n    end",
    "comment": " Returns an Array of Gem::Specifications that are not up to date.",
    "label": "",
    "id": "224"
  },
  {
    "raw_code": "def source_index\n      @@source_index ||= SourceIndex.from_installed_gems\n    end",
    "comment": "Returns the Gem::SourceIndex of specifications that are in the Gem.path",
    "label": "",
    "id": "225"
  },
  {
    "raw_code": "def self.parse(source, filename = nil)\n        new(source, filename).parse\n      end",
    "comment": "Convenience method to create a new parser and {#parse}",
    "label": "",
    "id": "226"
  },
  {
    "raw_code": "def initialize(source, filename) # rubocop:disable Lint/UnusedMethodArgument\n        raise NotImplementedError, \"invalid parser implementation\"\n      end",
    "comment": "This default constructor does nothing. The subclass is responsible for storing the source contents and filename if they are required. @param [String] source the source contents @param [String] filename the name of the file if from disk",
    "label": "",
    "id": "227"
  },
  {
    "raw_code": "def parse\n        raise NotImplementedError, \"#{self.class} must implement #parse\"\n      end",
    "comment": "This method should be implemented to parse the source and return itself. @abstract @return [Base] this method should return itself",
    "label": "",
    "id": "228"
  },
  {
    "raw_code": "def tokenize\n        raise NotImplementedError, \"#{self.class} does not support tokenization\"\n      end",
    "comment": "This method should be implemented to tokenize given source @abstract @return [Array] a list/tree of lexical tokens",
    "label": "",
    "id": "229"
  },
  {
    "raw_code": "def enumerator\n        nil\n      end",
    "comment": "This method should be implemented to return a list of semantic tokens representing the source code to be post-processed. Otherwise the method should return nil.  @abstract @return [Array] a list of semantic tokens representing the source code to be post-processed @return [nil] if no post-processing should be done",
    "label": "",
    "id": "230"
  },
  {
    "raw_code": "def initialize(global_state, files)\n        @global_state = global_state\n        @files = files.dup\n        @global_state.ordered_parser = self\n      end",
    "comment": "Creates a new OrderedParser with the global state and a list of files to parse.  @note OrderedParser sets itself as the +ordered_parser+ key on global_state for later use in {Handlers::Processor}. @param [OpenStruct] global_state a structure containing all global state during parsing @param [Array<String>] files the list of files to parse",
    "label": "",
    "id": "231"
  },
  {
    "raw_code": "def parse\n        until files.empty?\n          file = files.shift\n          log.capture(\"Parsing #{file}\") do\n            SourceParser.new(SourceParser.parser_type, @global_state).parse(file)\n          end",
    "comment": "Parses the remainder of the {#files} list.  @see Processor#parse_remaining_files",
    "label": "",
    "id": "232"
  },
  {
    "raw_code": "def parse(paths = DEFAULT_PATH_GLOB, excluded = [], level = log.level)\n          log.debug(\"Parsing #{paths.inspect} with `#{parser_type}` parser\")\n          excluded = excluded.map do |path|\n            case path\n            when Regexp; path\n            else Regexp.new(path.to_s, Regexp::IGNORECASE)\n            end",
    "comment": "Parses a path or set of paths  @param [String, Array<String>] paths a path, glob, or list of paths to parse @param [Array<String, Regexp>] excluded a list of excluded path matchers @param [Fixnum] level the logger level to use during parsing. See {YARD::Logger} @return [void]",
    "label": "",
    "id": "233"
  },
  {
    "raw_code": "def parse_string(content, ptype = parser_type)\n          new(ptype).parse(StringIO.new(content))\n        end",
    "comment": "Parses a string +content+  @param [String] content the block of code to parse @param [Symbol] ptype the parser type to use. See {parser_type}. @return the parser object that was used to parse +content+",
    "label": "",
    "id": "234"
  },
  {
    "raw_code": "def tokenize(content, ptype = parser_type)\n          new(ptype).tokenize(content)\n        end",
    "comment": "Tokenizes but does not parse the block of code  @param [String] content the block of code to tokenize @param [Symbol] ptype the parser type to use. See {parser_type}. @return [Array] a list of tokens",
    "label": "",
    "id": "235"
  },
  {
    "raw_code": "def register_parser_type(type, parser_klass, extensions = nil)\n          unless Base > parser_klass\n            raise ArgumentError, \"expecting parser_klass to be a subclass of YARD::Parser::Base\"\n          end",
    "comment": "Registers a new parser type.  @example Registering a parser for \"java\" files SourceParser.register_parser_type :java, JavaParser, 'java' @param [Symbol] type a symbolic name for the parser type @param [Base] parser_klass a class that implements parsing and tokenization @param [Array<String>, String, Regexp] extensions a list of extensions or a regex to match against the file extension @return [void] @see Parser::Base",
    "label": "",
    "id": "236"
  },
  {
    "raw_code": "def parser_types; @@parser_types ||= {} end\n        def parser_types=(value) @@parser_types = value end\n\n        # @return [Hash] a list of registered parser type extensions\n        # @private\n        # @since 0.5.6\n        def parser_type_extensions; @@parser_type_extensions ||= {} end\n        def parser_type_extensions=(value) @@parser_type_extensions = value end\n\n        # Finds a parser type that is registered for the extension. If no\n        # type is found, the default Ruby type is returned.\n        #\n        # @return [Symbol] the parser type to be used for the extension\n        # @since 0.5.6\n        def parser_type_for_extension(extension)\n          type = parser_type_extensions.find do |_t, exts|\n            [exts].flatten.any? {|ext| ext === extension }\n          end\n          validated_parser_type(type ? type.first : :ruby)\n        end\n\n        # Returns the validated parser type. Basically, enforces that :ruby\n        # type is never set if the Ripper library is not available\n        #\n        # @param [Symbol] type the parser type to set\n        # @return [Symbol] the validated parser type\n        # @private\n        def validated_parser_type(type)\n          !defined?(::Ripper) && type == :ruby ? :ruby18 : type\n        end\n\n        # @group Parser Callbacks\n\n        # Registers a callback to be called before a list of files is parsed\n        # via {parse}. The block passed to this method will be called on\n        # subsequent parse calls.\n        #\n        # @example Installing a simple callback\n        #   SourceParser.before_parse_list do |files, globals|\n        #     puts \"Starting to parse...\"\n        #   end\n        #   YARD.parse('lib/**/*.rb')\n        #   # prints \"Starting to parse...\"\n        #\n        # @example Setting global state\n        #   SourceParser.before_parse_list do |files, globals|\n        #     globals.method_count = 0\n        #   end\n        #   SourceParser.after_parse_list do |files, globals|\n        #     puts \"Found #{globals.method_count} methods\"\n        #   end\n        #   class MyCountHandler < Handlers::Ruby::Base\n        #     handles :def, :defs\n        #     process { globals.method_count += 1 }\n        #   end\n        #   YARD.parse\n        #   # Prints: \"Found 37 methods\"\n        #\n        # @example Using a global callback to cancel parsing\n        #   SourceParser.before_parse_list do |files, globals|\n        #     return false if files.include?('foo.rb')\n        #   end\n        #\n        #   YARD.parse(['foo.rb', 'bar.rb']) # callback cancels this method\n        #   YARD.parse('bar.rb') # parses normally\n        #\n        # @yield [files, globals] the yielded block is called once before\n        #   parsing all files\n        # @yieldparam [Array<String>] files the list of files that will be parsed.\n        # @yieldparam [OpenStruct] globals a global structure to store arbitrary\n        #   state for post processing (see {Handlers::Processor#globals})\n        # @yieldreturn [Boolean] if the block returns +false+, parsing is\n        #   cancelled.\n        # @return [Proc] the yielded block\n        # @see after_parse_list\n        # @see before_parse_file\n        # @since 0.7.0\n        def before_parse_list(&block)\n          before_parse_list_callbacks << block\n        end\n\n        # Registers a callback to be called after a list of files is parsed\n        # via {parse}. The block passed to this method will be called on\n        # subsequent parse calls.\n        #\n        # @example Printing results after parsing occurs\n        #   SourceParser.after_parse_list do\n        #     puts \"Finished parsing!\"\n        #   end\n        #   YARD.parse\n        #   # Prints \"Finished parsing!\" after parsing files\n        # @yield [files, globals] the yielded block is called once before\n        #   parsing all files\n        # @yieldparam [Array<String>] files the list of files that will be parsed.\n        # @yieldparam [OpenStruct] globals a global structure to store arbitrary\n        #   state for post processing (see {Handlers::Processor#globals})\n        # @yieldreturn [void] the return value for the block is ignored.\n        # @return [Proc] the yielded block\n        # @see before_parse_list\n        # @see before_parse_file\n        # @since 0.7.0\n        def after_parse_list(&block)\n          after_parse_list_callbacks << block\n        end\n\n        # Registers a callback to be called before an individual file is parsed.\n        # The block passed to this method will be called on subsequent parse\n        # calls.\n        #\n        # To register a callback that is called before the entire list of files\n        # is processed, see {before_parse_list}.\n        #\n        # @example Installing a simple callback\n        #   SourceParser.before_parse_file do |parser|\n        #     puts \"I'm parsing #{parser.file}\"\n        #   end\n        #   YARD.parse('lib/**/*.rb')\n        #   # prints:\n        #   \"I'm parsing lib/foo.rb\"\n        #   \"I'm parsing lib/foo_bar.rb\"\n        #   \"I'm parsing lib/last_file.rb\"\n        #\n        # @example Cancel parsing of any test_*.rb files\n        #   SourceParser.before_parse_file do |parser|\n        #     return false if parser.file =~ /^test_.+\\.rb$/\n        #   end\n        #\n        # @yield [parser] the yielded block is called once before each\n        #   file that is parsed. This might happen many times for a single\n        #   codebase.\n        # @yieldparam [SourceParser] parser the parser object that will {#parse}\n        #   the file.\n        # @yieldreturn [Boolean] if the block returns +false+, parsing for\n        #   the file is cancelled.\n        # @return [Proc] the yielded block\n        # @see after_parse_file\n        # @see before_parse_list\n        # @since 0.7.0\n        def before_parse_file(&block)\n          before_parse_file_callbacks << block\n        end\n\n        # Registers a callback to be called after an individual file is parsed.\n        # The block passed to this method will be called on subsequent parse\n        # calls.\n        #\n        # To register a callback that is called after the entire list of files\n        # is processed, see {after_parse_list}.\n        #\n        # @example Printing the length of each file after it is parsed\n        #   SourceParser.after_parse_file do |parser|\n        #     puts \"#{parser.file} is #{parser.contents.size} characters\"\n        #   end\n        #   YARD.parse('lib/**/*.rb')\n        #   # prints:\n        #   \"lib/foo.rb is 1240 characters\"\n        #   \"lib/foo_bar.rb is 248 characters\"\n        #\n        # @yield [parser] the yielded block is called once after each file\n        #   that is parsed. This might happen many times for a single codebase.\n        # @yieldparam [SourceParser] parser the parser object that parsed\n        #   the file.\n        # @yieldreturn [void] the return value for the block is ignored.\n        # @return [Proc] the yielded block\n        # @see before_parse_file\n        # @see after_parse_list\n        # @since 0.7.0\n        def after_parse_file(&block)\n          after_parse_file_callbacks << block\n        end\n\n        # @return [Array<Proc>] the list of callbacks to be called before\n        #   parsing a list of files. Should only be used for testing.\n        # @since 0.7.0\n        def before_parse_list_callbacks\n          @before_parse_list_callbacks ||= []\n        end\n\n        # @return [Array<Proc>] the list of callbacks to be called after\n        #   parsing a list of files. Should only be used for testing.\n        # @since 0.7.0\n        def after_parse_list_callbacks\n          @after_parse_list_callbacks ||= []\n        end\n\n        # @return [Array<Proc>] the list of callbacks to be called before\n        #   parsing a file. Should only be used for testing.\n        # @since 0.7.0\n        def before_parse_file_callbacks\n          @before_parse_file_callbacks ||= []\n        end\n\n        # @return [Array<Proc>] the list of callbacks to be called after\n        #   parsing a file. Should only be used for testing.\n        # @since 0.7.0\n        def after_parse_file_callbacks\n          @after_parse_file_callbacks ||= []\n        end\n\n        # @endgroup\n\n        private\n\n        # Parses a list of files in a queue.\n        #\n        # @param [Array<String>] files a list of files to queue for parsing\n        # @return [void]\n        def parse_in_order(*files)\n          global_state = OpenStruct.new\n\n          return if before_parse_list_callbacks.any? do |cb|\n            cb.call(files, global_state) == false\n          end\n\n          OrderedParser.new(global_state, files).parse\n\n          after_parse_list_callbacks.each do |cb|\n            cb.call(files, global_state)\n          end\n        end\n      end",
    "comment": "@return [Hash{Symbol=>Object}] a list of registered parser types @private @since 0.5.6",
    "label": "",
    "id": "237"
  },
  {
    "raw_code": "def initialize(parser_type = SourceParser.parser_type, globals1 = nil, globals2 = nil)\n        globals = [true, false].include?(globals1) ? globals2 : globals1\n        @file = '(stdin)'\n        @globals = globals || OpenStruct.new\n        self.parser_type = parser_type\n      end",
    "comment": "@overload initialize(parser_type = SourceParser.parser_type, globals = nil) Creates a new parser object for code parsing with a specific parser type.  @param [Symbol] parser_type the parser type to use @param [OpenStruct] globals global state to be re-used across separate source files",
    "label": "",
    "id": "238"
  },
  {
    "raw_code": "def parse(content = __FILE__)\n        case content\n        when String\n          @file = File.cleanpath(content)\n          content = convert_encoding(String.new(File.read_binary(file)))\n          checksum = Registry.checksum_for(content)\n          return if Registry.checksums[file] == checksum\n\n          if Registry.checksums.key?(file)\n            log.info \"File '#{file}' was modified, re-processing...\"\n          end",
    "comment": "The main parser method. This should not be called directly. Instead, use the class methods {parse} and {parse_string}.  @param [String, #read, Object] content the source file to parse @return [Object, nil] the parser object used to parse the source",
    "label": "",
    "id": "239"
  },
  {
    "raw_code": "def tokenize(content)\n        @parser = parser_class.new(content, file)\n        @parser.tokenize\n      end",
    "comment": "Tokenizes but does not parse the block of code using the current {#parser_type}  @param [String] content the block of code to tokenize @return [Array] a list of tokens",
    "label": "",
    "id": "240"
  },
  {
    "raw_code": "def convert_encoding(content)\n        return content unless content.respond_to?(:force_encoding)\n        if content =~ ENCODING_LINE\n          content.force_encoding($1)\n        else\n          content.force_encoding('binary')\n          ENCODING_BYTE_ORDER_MARKS.each do |encoding, bom|\n            bom.force_encoding('binary')\n            if content.start_with?(bom)\n              return content.sub(bom, '').force_encoding(encoding)\n            end",
    "comment": "Searches for encoding line and forces encoding @since 0.5.3",
    "label": "",
    "id": "241"
  },
  {
    "raw_code": "def post_process\n        return unless @parser.respond_to?(:enumerator)\n\n        enumerator = @parser.enumerator\n        if enumerator\n          post = Handlers::Processor.new(self)\n          post.process(enumerator)\n        end",
    "comment": "Runs a {Handlers::Processor} object to post process the parsed statements. @return [void]",
    "label": "",
    "id": "242"
  },
  {
    "raw_code": "def parser_type_for_filename(filename)\n        ext = (File.extname(filename)[1..-1] || \"\").downcase\n        type = self.class.parser_type_for_extension(ext)\n        parser_type == :ruby18 && type == :ruby ? :ruby18 : type\n      end",
    "comment": "Guesses the parser type to use depending on the file extension.  @param [String] filename the filename to use to guess the parser type @return [Symbol] a parser type that matches the filename",
    "label": "",
    "id": "243"
  },
  {
    "raw_code": "def parser_class\n        klass = self.class.parser_types[parser_type]\n        unless klass\n          raise ArgumentError, \"invalid parser type '#{parser_type}' or unrecognized file\", caller[1..-1]\n        end",
    "comment": "@since 0.5.6",
    "label": "",
    "id": "244"
  },
  {
    "raw_code": "def s(*args)\n        type = Symbol === args.first ? args.shift : :list\n        opts = Hash === args.last ? args.pop : {}\n        AstNode.node_class_for(type).new(type, args, opts)\n      end",
    "comment": "Builds and s-expression by creating {AstNode} objects with the type provided by the first argument.  @example An implicit list of keywords ast = s(s(:kw, \"if\"), s(:kw, \"else\")) ast.type # => :list @example A method call s(:command, s(:var_ref, \"mymethod\"))  @overload s(*nodes, opts = {}) @param [Array<AstNode>] nodes a list of nodes. @param [Hash] opts any extra options (docstring, file, source) to set on the object @return [AstNode] an implicit node where node.type == +:list+ @overload s(type, *children, opts = {}) @param [Symbol] type the node type @param [Array<AstNode>] children any child nodes inside this one @param [Hash] opts any extra options to set on the object @return [AstNode] a node of type +type+. @see AstNode#initialize",
    "label": "",
    "id": "245"
  },
  {
    "raw_code": "def source_range\n          reset_line_info unless @source_range\n          @source_range\n        end",
    "comment": "@return [Range] the character range in {#full_source} represented by the node",
    "label": "",
    "id": "246"
  },
  {
    "raw_code": "def line_range\n          reset_line_info unless @line_range\n          @line_range\n        end",
    "comment": "@return [Range] the line range in {#full_source} represented by the node",
    "label": "",
    "id": "247"
  },
  {
    "raw_code": "def file\n          return parent.file if parent\n          @file\n        end",
    "comment": "@return [String] the filename the node was parsed from",
    "label": "",
    "id": "248"
  },
  {
    "raw_code": "def full_source\n          return parent.full_source if parent\n          return @full_source if @full_source\n          return IO.read(@file) if file && File.exist?(file)\n        end",
    "comment": "@return [String] the full source that the node was parsed from",
    "label": "",
    "id": "249"
  },
  {
    "raw_code": "def source\n          return parent.full_source[source_range] if parent\n          full_source\n        end",
    "comment": "@return [String] the parse of {#full_source} that the node represents",
    "label": "",
    "id": "250"
  },
  {
    "raw_code": "def self.node_class_for(type)\n          case type\n          when :params\n            ParameterNode\n          when :call, :fcall, :vcall, :command, :command_call\n            MethodCallNode\n          when :if, :elsif, :if_mod, :unless, :unless_mod\n            ConditionalNode\n          when :for, :while, :while_mod, :until, :until_mod\n            LoopNode\n          when :def, :defs\n            MethodDefinitionNode\n          when :class, :sclass\n            ClassNode\n          when :module\n            ModuleNode\n          else\n            if type.to_s =~ /_ref\\Z/\n              ReferenceNode\n            elsif type.to_s =~ /_literal\\Z/\n              LiteralNode\n            elsif KEYWORDS.key?(type)\n              KeywordNode\n            else\n              AstNode\n            end",
    "comment": "@group Creating an AstNode Finds the node subclass that should be instantiated for a specific node type  @param [Symbol] type the node type to find a subclass for @return [Class] a subclass of AstNode to instantiate the node with.",
    "label": "",
    "id": "251"
  },
  {
    "raw_code": "def initialize(type, arr, opts = {})\n          super(arr)\n          self.type = type\n          self.line_range = opts[:line]\n          self.source_range = opts[:char]\n          @fallback_line = opts[:listline]\n          @fallback_source = opts[:listchar]\n          @token = true if opts[:token]\n          @docstring = nil\n        end",
    "comment": "Creates a new AST node  @param [Symbol] type the type of node being created @param [Array<AstNode>] arr the child nodes @param [Hash] opts any extra line options @option opts [Fixnum] :line (nil) the line the node starts on in source @option opts [String] :char (nil) the character number the node starts on in source @option opts [Fixnum] :listline (nil) a special key like :line but for list nodes @option opts [Fixnum] :listchar (nil) a special key like :char but for list nodes @option opts [Boolean] :token (nil) whether the node represents a token",
    "label": "",
    "id": "252"
  },
  {
    "raw_code": "def ==(other)\n          super && type == other.type\n        end",
    "comment": "@return [Boolean] whether the node is equal to another by checking the list and type @private",
    "label": "",
    "id": "253"
  },
  {
    "raw_code": "def jump(*node_types)\n          traverse {|child| return(child) if node_types.include?(child.type) }\n          self\n        end",
    "comment": "@group Traversing a Node Searches through the node and all descendants and returns the first node with a type matching any of +node_types+, otherwise returns the original node (self).  @example Returns the first method definition in a block of code ast = YARD.parse_string(\"if true; def x; end end\").ast ast.jump(:def) # => s(:def, s(:ident, \"x\"), s(:params, nil, nil, nil, nil, #      nil), s(s(:void_stmt, ))) @example Returns first 'def' or 'class' statement ast = YARD.parse_string(\"class X; def y; end end\") ast.jump(:def, :class).first # => @example If the node types are not present in the AST ast = YARD.parse(\"def x; end\") ast.jump(:def)  @param [Array<Symbol>] node_types a set of node types to match @return [AstNode] the matching node, if one was found @return [self] if no node was found",
    "label": "",
    "id": "254"
  },
  {
    "raw_code": "def children\n          @children ||= select {|e| AstNode === e }\n        end",
    "comment": "@return [Array<AstNode>] the {AstNode} children inside the node",
    "label": "",
    "id": "255"
  },
  {
    "raw_code": "def traverse\n          nodes = [self]\n          until nodes.empty?\n            node = nodes.pop\n            yield node\n            nodes += node.children.reverse unless node.children.empty?\n          end",
    "comment": "Traverses the object and yields each node (including descendants) in order.  @yield each descendant node in order @yieldparam [AstNode] self, or a child/descendant node @return [void]",
    "label": "",
    "id": "256"
  },
  {
    "raw_code": "def token?\n          @token\n        end",
    "comment": "@group Node Meta Types @return [Boolean] whether the node is a token",
    "label": "",
    "id": "257"
  },
  {
    "raw_code": "def ref?\n          false\n        end",
    "comment": "@return [Boolean] whether the node is a reference (variable, constant name)",
    "label": "",
    "id": "258"
  },
  {
    "raw_code": "def literal?\n          false\n        end",
    "comment": "@return [Boolean] whether the node is a literal value",
    "label": "",
    "id": "259"
  },
  {
    "raw_code": "def kw?\n          false\n        end",
    "comment": "@return [Boolean] whether the node is a keyword",
    "label": "",
    "id": "260"
  },
  {
    "raw_code": "def call?\n          false\n        end",
    "comment": "@return [Boolean] whether the node is a method call",
    "label": "",
    "id": "261"
  },
  {
    "raw_code": "def def?\n          false\n        end",
    "comment": "@return [Boolean] whether the node is a method definition",
    "label": "",
    "id": "262"
  },
  {
    "raw_code": "def condition?\n          false\n        end",
    "comment": "@return [Boolean] whether the node is a if/elsif/else condition",
    "label": "",
    "id": "263"
  },
  {
    "raw_code": "def loop?\n          false\n        end",
    "comment": "@return [Boolean] whether the node is a loop",
    "label": "",
    "id": "264"
  },
  {
    "raw_code": "def block?\n          respond_to?(:block) || condition?\n        end",
    "comment": "@return [Boolean] whether the node has a block",
    "label": "",
    "id": "265"
  },
  {
    "raw_code": "def has_line?\n          @line_range ? true : false\n        end",
    "comment": "@group Getting Line Information @return [Boolean] whether the node has a {#line_range} set",
    "label": "",
    "id": "266"
  },
  {
    "raw_code": "def line\n          line_range && (line_range.begin || line_range.end)\n        end",
    "comment": "@return [Fixnum] the starting line number of the node",
    "label": "",
    "id": "267"
  },
  {
    "raw_code": "def first_line\n          full_source.split(/\\r?\\n/)[line - 1].strip\n        end",
    "comment": "@return [String] the first line of source represented by the node.",
    "label": "",
    "id": "268"
  },
  {
    "raw_code": "def show\n          \"\\t#{line}: #{first_line}\"\n        end",
    "comment": "@group Printing a Node @return [String] the first line of source the node represents",
    "label": "",
    "id": "269"
  },
  {
    "raw_code": "def pretty_print(q)\n          objs = dup + [:__last__]\n          objs.unshift(type) if type && type != :list\n\n          options = []\n          options << ['docstring', docstring] if @docstring\n          if @source_range || @line_range\n            options << ['line', line_range]\n            options << ['source', source_range]\n          end",
    "comment": "@return [nil] pretty prints the node",
    "label": "",
    "id": "270"
  },
  {
    "raw_code": "def inspect\n          typeinfo = type && type != :list ? ':' + type.to_s + ', ' : ''\n          's(' + typeinfo + map(&:inspect).join(\", \") + ')'\n        end",
    "comment": "@return [String] inspects the object",
    "label": "",
    "id": "271"
  },
  {
    "raw_code": "def unfreeze\n          @children = nil\n        end",
    "comment": "@group Managing node state Resets node state in tree",
    "label": "",
    "id": "272"
  },
  {
    "raw_code": "def reset_line_info\n          if size == 0\n            self.line_range = @fallback_line\n            self.source_range = @fallback_source\n          elsif !children.empty?\n            f = children.first\n            l = children.last\n            self.line_range = Range.new(f.line_range.begin, l.line_range.end)\n            self.source_range = Range.new(f.source_range.begin, l.source_range.end)\n          elsif @fallback_line || @fallback_source\n            self.line_range = @fallback_line\n            self.source_range = @fallback_source\n          else\n            self.line_range = 0...0\n            self.source_range = 0...0\n          end",
    "comment": "Resets line information @return [void]",
    "label": "",
    "id": "273"
  },
  {
    "raw_code": "def initialize(source, namespace = Registry.root)\n          @tokens = RubyParser.parse(source, '(tokenize)').tokens\n          raise ParserSyntaxError if @tokens.empty? && !source.empty?\n          @default_namespace = namespace\n        end",
    "comment": "Creates a token resolver for given source.  @param source [String] the source code to tokenize @param namespace [CodeObjects::Base] the object/namespace to resolve from",
    "label": "",
    "id": "274"
  },
  {
    "raw_code": "def each\n          @states = []\n          push_state\n          @tokens.each do |token|\n            yield_obj = false\n\n            if skip_group && [:const, :ident, :op, :period].include?(token[0])\n              yield token, nil\n              next\n            else\n              self.skip_group = false\n            end",
    "comment": "Iterates over each token, yielding the token and a possible code object that is associated with the token.  @yieldparam token [Array(Symbol,String,Array(Integer,Integer))] the current token object being iterated @yieldparam object [CodeObjects::Base, nil] the fully qualified code object associated with the current token, or nil if there is no object for the yielded token. @example Yielding code objects r = TokenResolver.new(\"A::B::C\") r.each do |tok, obj| if obj puts \"#{tok[0]} -> #{obj.path.inspect}\" else puts \"No object: #{tok.inspect}\" end end  # Prints: # :const -> \"A\" # No object: [:op, \"::\"] # :const -> \"A::B\" # No object: [:op, \"::\"] # :const -> \"A::B::C\"",
    "label": "",
    "id": "275"
  },
  {
    "raw_code": "def line\n        tokens.first.line_no\n      end",
    "comment": "@return [Fixnum] the first line of Ruby source",
    "label": "",
    "id": "276"
  },
  {
    "raw_code": "def line_range\n        tokens.first.line_no..tokens.last.line_no\n      end",
    "comment": "@return [Range<Fixnum>] the first to last lines of Ruby source @since 0.5.4",
    "label": "",
    "id": "277"
  },
  {
    "raw_code": "def initialize(content)\n        @shebang_line = nil\n        @encoding_line = nil\n        @comments_last_line = nil\n        if content.is_a? TokenList\n          @tokens = content.dup\n        elsif content.is_a? String\n          @tokens = TokenList.new(content.delete(\"\\r\"))\n        else\n          raise ArgumentError, \"Invalid content for StatementList: #{content.inspect}:#{content.class}\"\n        end",
    "comment": "Creates a new statement list  @param [TokenList, String] content the tokens to create the list from",
    "label": "",
    "id": "278"
  },
  {
    "raw_code": "def next_statement\n        @state = :first_statement\n        @statement_stack = []\n        @level = 0\n        @block_num = 0\n        @done = false\n        @current_block = nil\n        @comments_line = nil\n        @comments_hash_flag = nil\n        @statement = TokenList.new\n        @block = nil\n        @comments = nil\n        @last_tk = nil\n        @last_ns_tk = nil\n        @before_last_tk = nil\n        @before_last_ns_tk = nil\n        @first_line = nil\n\n        until @done\n          tk = @tokens.shift\n          break if tk.nil?\n          process_token(tk)\n\n          @before_last_tk = @last_tk\n          @last_tk = tk # Save last token\n          unless [TkSPACE, TkNL, TkEND_OF_SCRIPT].include? tk.class\n            @before_last_ns_tk = @last_ns_tk\n            @last_ns_tk = tk\n          end",
    "comment": "Returns the next statement in the token stream  @return [Statement] the next statement",
    "label": "",
    "id": "279"
  },
  {
    "raw_code": "def process_token(tk)\n        # p tk.class, tk.text, @state, @level, @current_block, \"<br/>\"\n        case @state\n        when :first_statement\n          return if process_initial_comment(tk)\n          return if @statement.empty? && [TkSPACE, TkNL, TkCOMMENT].include?(tk.class)\n          @comments_last_line = nil\n          if @statement.empty? && tk.class == TkALIAS\n            @state = :alias_statement\n            @alias_values = []\n            push_token(tk)\n            return\n          end",
    "comment": "Processes a single token  @param [RubyToken::Token] tk the token to process",
    "label": "",
    "id": "280"
  },
  {
    "raw_code": "def process_block_token(tk)\n        if balances?(tk)\n          @statement << tk\n          @state = :first_statement\n          process_statement_end(tk)\n        elsif @block_num > 1 || (@block.empty? && [TkSPACE, TkNL].include?(tk.class))\n          @statement << tk\n        else\n          if @block.empty?\n            @statement << TkBlockContents.new(tk.line_no, tk.char_no)\n          end",
    "comment": "Processes a token in a block  @param [RubyToken::Token] tk the token to process",
    "label": "",
    "id": "281"
  },
  {
    "raw_code": "def process_initial_comment(tk)\n        if @statement.empty? && (@comments_last_line || 0) < tk.line_no - 2\n          @comments = nil\n        end",
    "comment": "Processes a comment token that comes before a statement  @param [RubyToken::Token] tk the token to process @return [Boolean] whether or not +tk+ was processed as an initial comment",
    "label": "",
    "id": "282"
  },
  {
    "raw_code": "def process_simple_block_opener(tk)\n        return unless [TkLBRACE, TkDO, TkBEGIN, TkELSE].include?(tk.class) &&\n                      # Make sure hashes are parsed as hashes, not as blocks\n                      (@last_ns_tk.nil? || @last_ns_tk.lex_state != EXPR_BEG)\n\n        @level += 1\n        @state = :block\n        @block_num += 1\n        if @block.nil?\n          @block = TokenList.new\n          tokens = [tk, TkStatementEnd.new(tk.line_no, tk.char_no)]\n          tokens = tokens.reverse if TkBEGIN === tk.class\n          @statement.concat(tokens)\n        else\n          @statement << tk\n        end",
    "comment": "Processes a simple block-opening token; that is, a block opener such as +begin+ or +do+ that isn't followed by an expression  @param [RubyToken::Token] tk the token to process",
    "label": "",
    "id": "283"
  },
  {
    "raw_code": "def process_complex_block_opener(tk)\n        return unless OPEN_BLOCK_TOKENS.include?(tk.class)\n\n        @current_block = tk.class\n        @state = :block_statement\n\n        true\n      end",
    "comment": "Processes a complex block-opening token; that is, a block opener such as +while+ or +for+ that is followed by an expression  @param [RubyToken::Token] tk the token to process",
    "label": "",
    "id": "284"
  },
  {
    "raw_code": "def process_statement_end(tk)\n        # Whitespace means that we keep the same value of @new_statement as last token\n        return if tk.class == TkSPACE\n\n        return unless\n          # We might be coming after a statement-ending token...\n          (@last_tk && [TkSEMICOLON, TkNL, TkEND_OF_SCRIPT].include?(tk.class)) ||\n          # Or we might be at the beginning of an argument list\n          (@current_block == TkDEF && tk.class == TkRPAREN)\n\n        # Continue line ending on . or ::\n        return if @last_tk && [EXPR_DOT].include?(@last_tk.lex_state)\n\n        # Continue a possible existing new statement unless we just finished an expression...\n        return unless (@last_tk && [EXPR_END, EXPR_ARG].include?(@last_tk.lex_state)) ||\n                      # Or we've opened a block and are ready to move into the body\n                      (@current_block && [TkNL, TkSEMICOLON].include?(tk.class) &&\n                       # Handle the case where the block statement's expression is on the next line\n                       #\n                       # while\n                       #     foo\n                       # end\n                       @last_ns_tk.class != @current_block &&\n                       # And the case where part of the expression is on the next line\n                       #\n                       # while foo ||\n                       #     bar\n                       # end\n                       @last_tk.lex_state != EXPR_BEG)\n\n        # Continue with the statement if we've hit a comma in a def\n        return if @current_block == TkDEF && peek_no_space.class == TkCOMMA\n\n        if [TkEND_OF_SCRIPT, TkNL, TkSEMICOLON].include?(tk.class) && @state == :block_statement &&\n           [TkRBRACE, TkEND].include?(@last_ns_tk.class) && @level == 0\n          @current_block = nil\n        end",
    "comment": "Processes a token that closes a statement  @param [RubyToken::Token] tk the token to process",
    "label": "",
    "id": "285"
  },
  {
    "raw_code": "def balances?(tk)\n        unless [TkALIAS, TkDEF].include?(@last_ns_tk.class) || @before_last_ns_tk.class == TkALIAS\n          if [TkLPAREN, TkLBRACK, TkLBRACE, TkDO, TkBEGIN].include?(tk.class)\n            @level += 1\n          elsif OPEN_BLOCK_TOKENS.include?(tk.class)\n            @level += 1 unless tk.class == TkELSIF\n          elsif [TkRPAREN, TkRBRACK, TkRBRACE, TkEND].include?(tk.class) && @level > 0\n            @level -= 1\n          end",
    "comment": "Handles the balancing of parentheses and blocks  @param [RubyToken::Token] tk the token to process @return [Boolean] whether or not the current statement's parentheses and blocks are balanced after +tk+",
    "label": "",
    "id": "286"
  },
  {
    "raw_code": "def push_token(tk)\n        @first_line = tk.line_no if @statement.empty?\n        @statement << tk unless @level == 0 && [TkCOMMENT].include?(tk.class)\n      end",
    "comment": "Adds a token to the current statement, unless it's a newline, semicolon, or comment  @param [RubyToken::Token] tk the token to process",
    "label": "",
    "id": "287"
  },
  {
    "raw_code": "def peek_no_space\n        return @tokens.first unless @tokens.first.class == TkSPACE\n        @tokens[1]\n      end",
    "comment": "Returns the next token in the stream that's not a space  @return [RubyToken::Token] the next non-space token",
    "label": "",
    "id": "288"
  },
  {
    "raw_code": "def push(*tokens)\n        tokens.each do |tok|\n          if tok.is_a?(TokenList) || tok.is_a?(Array)\n            concat tok\n          elsif tok.is_a?(Token)\n            super tok\n          elsif tok.is_a?(String)\n            parse_content(tok)\n          else\n            raise ArgumentError, \"Expecting token, list of tokens or string of code to be tokenized. Got #{tok.class}\"\n          end",
    "comment": "@param [TokenList, Token, String] tokens A list of tokens. If the token is a string, it is parsed with {RubyLex}.",
    "label": "",
    "id": "289"
  },
  {
    "raw_code": "def initialize(line_no, char_no)\n          @line_no = line_no\n          @char_no = char_no\n          @text    = NO_TEXT\n        end",
    "comment": "Creates a new Token object @param [Integer] line_no the line number to initialize the token to @param [Integer] char_no the char number to initialize the token to",
    "label": "",
    "id": "290"
  },
  {
    "raw_code": "def set_text(text)\n          @text = text\n          self\n        end",
    "comment": "Chainable way to sets the text attribute  @param [String] text the new text @return [Token] this token object",
    "label": "",
    "id": "291"
  },
  {
    "raw_code": "def set_token_position(line, char)\n        @prev_line_no = line\n        @prev_char_no = char\n      end",
    "comment": "@private",
    "label": "",
    "id": "292"
  },
  {
    "raw_code": "def Token(token, value = nil) # rubocop:disable Style/MethodName\n        tk = nil\n        case token\n        when String, Symbol\n          source = token.is_a?(String) ? TkReading2Token : TkSymbol2Token\n          if (tk = source[token]).nil?\n            raise \"no key #{token}\"\n          end",
    "comment": "@private",
    "label": "",
    "id": "293"
  },
  {
    "raw_code": "def self.def_token(token_n, super_token = Token, reading = nil, *opts)\n        token_n = token_n.id2name unless token_n.is_a?(String)\n        if RubyToken.const_defined?(token_n)\n          # IRB.fail AlreadyDefinedToken, token_n\n        end",
    "comment": "@private",
    "label": "",
    "id": "294"
  },
  {
    "raw_code": "def line_no\n        @reader.line_num\n      end",
    "comment": "io functions",
    "label": "",
    "id": "295"
  },
  {
    "raw_code": "def postproc(token)\n      node = search(token, proc)\n      node.postproc=proc\n    end",
    "comment": "need a check?",
    "label": "",
    "id": "296"
  },
  {
    "raw_code": "def initialize(preproc = nil, postproc = nil)\n        @Tree = {}\n        @preproc = preproc\n        @postproc = postproc\n      end",
    "comment": "if postproc is nil, this node is an abstract node. if postproc is non-nil, this node is a real node.",
    "label": "",
    "id": "297"
  },
  {
    "raw_code": "def match(chrs, op = \"\")\n        D_DETAIL.print \"match>: \", chrs, \"op:\", op, \"\\n\"\n        if chrs.empty?\n          if @preproc.nil? || @preproc.call(op, chrs)\n            DOUT.printf(D_DETAIL, \"op1: %s\\n\", op)\n            @postproc.call(op, chrs)\n          else\n            nil\n          end",
    "comment": " chrs: String character array io must have getc()/ungetc(); and ungetc() must be able to be called arbitrary number of times. ",
    "label": "",
    "id": "298"
  },
  {
    "raw_code": "def included(klass)\n          klass.extend(ClassMethods)\n        end",
    "comment": "@!parse extend ClassMethods @private",
    "label": "",
    "id": "299"
  },
  {
    "raw_code": "def include_extra(template, options)\n          extra_includes.each do |mod|\n            mod = mod.call(options) if mod.is_a?(Proc)\n            next unless mod.is_a?(Module)\n            template.extend(mod)\n          end",
    "comment": "Includes the {extra_includes} modules into the template object.  @param [Template] template the template object to mixin the extra includes. @param [SymbolHash] options the options hash containing all template information @return [void]",
    "label": "",
    "id": "300"
  },
  {
    "raw_code": "def full_paths\n          reset_full_paths unless defined? @cached_included_modules\n          return @full_paths if included_modules == @cached_included_modules\n\n          @cached_included_modules = included_modules\n          @full_paths = included_modules.inject([full_path]) do |paths, mod|\n            paths |= mod.full_paths if mod.respond_to?(:full_paths)\n            paths\n          end",
    "comment": "@return [Array<String>] a list of full paths @note This method caches path results. Paths should not be modified after this method is called; call {#reset_full_paths} to reset cache.",
    "label": "",
    "id": "301"
  },
  {
    "raw_code": "def reset_full_paths\n          @cached_included_modules = nil\n        end",
    "comment": "Resets cache for {#full_paths}",
    "label": "",
    "id": "302"
  },
  {
    "raw_code": "def find_file(basename)\n          find_nth_file(basename)\n        end",
    "comment": "Searches for a file identified by +basename+ in the template's path as well as any mixed in template paths. Equivalent to calling {ClassMethods#find_nth_file} with index of 1.  @param [String] basename the filename to search for @return [String] the full path of a file on disk with filename +basename+ in one of the template's paths. @see find_nth_file",
    "label": "",
    "id": "303"
  },
  {
    "raw_code": "def find_nth_file(basename, index = 1)\n          n = 1\n          full_paths.each do |path|\n            file = File.join(path, basename)\n            if File.file?(file)\n              return file if index == n\n              n += 1\n            end",
    "comment": "Searches for the nth file (where n = +index+) identified by basename in the template's path and any mixed in template paths.  @param [String] basename the filename to search for @param [Fixnum] index the nth existing file to return @return [String] the full path of the nth file on disk with filename +basename+ in one of the template paths",
    "label": "",
    "id": "304"
  },
  {
    "raw_code": "def new(*args)\n          obj = Object.new.extend(self)\n          obj.class = self\n          obj.send(:initialize, *args)\n          obj\n        end",
    "comment": "Creates a new template object to be rendered with {Template#run}",
    "label": "",
    "id": "305"
  },
  {
    "raw_code": "def T(*path)\n          Engine.template(*path)\n        end",
    "comment": "rubocop:disable Style/MethodName Alias for creating {Engine.template}.",
    "label": "",
    "id": "306"
  },
  {
    "raw_code": "def S(*args)\n          Section.new(*args)\n        end",
    "comment": "Alias for creating a {Section} with arguments @see Section#initialize @since 0.6.0",
    "label": "",
    "id": "307"
  },
  {
    "raw_code": "def T(*path) # rubocop:disable Style/MethodName\n        path.unshift(options.template) if options.template\n        path.push(options.format) if options.format\n        self.class.T(*path)\n      end",
    "comment": "Loads a template specified by path. If +:template+ or +:format+ is specified in the {#options} hash, they are prepended and appended to the path respectively.  @param [Array<String, Symbol>] path the path of the template @return [Template] the loaded template module",
    "label": "",
    "id": "308"
  },
  {
    "raw_code": "def sections(*args)\n        @sections = Section.new(nil, *args) unless args.empty?\n        @sections\n      end",
    "comment": "Sets the sections (and subsections) to be rendered for the template  @example Sets a set of erb sections sections :a, :b, :c # searches for a.erb, b.erb, c.erb @example Sets a set of method and erb sections sections :a, :b, :c # a is a method, the rest are erb files @example Sections with subsections sections :header, [:name, :children] # the above will call header.erb and only renders the subsections # if they are yielded by the template (see #yieldall) @param [Array<Symbol, String, Template, Array>] args the sections to use to render the template. For symbols and strings, the section will be executed as a method (if one exists), or rendered from the file \"name.erb\" where name is the section name. For templates, they will have {Template::ClassMethods#run} called on them. Any subsections can be yielded to using yield or {#yieldall}",
    "label": "",
    "id": "309"
  },
  {
    "raw_code": "def init\n      end",
    "comment": "Initialization called on the template. Override this in a 'setup.rb' file in the template's path to implement a template  @example A default set of sections def init sections :section1, :section2, [:subsection1, :etc] end @see #sections",
    "label": "",
    "id": "310"
  },
  {
    "raw_code": "def run(opts = nil, sects = sections, start_at = 0, break_first = false, &block)\n        out = String.new(\"\")\n        return out if sects.nil?\n        sects = sects[start_at..-1] if start_at > 0\n        sects = Section.new(nil, sects) unless sects.is_a?(Section)\n        add_options(opts) do\n          sects.each do |s|\n            self.section = s\n            subsection_index = 0\n            value = render_section(section) do |*args|\n              value = with_section do\n                run(args.first, section, subsection_index, true, &block)\n              end",
    "comment": "Runs a template on +sects+ using extra options. This method should not be called directly. Instead, call the class method {ClassMethods#run}  @param [Hash, nil] opts any extra options to apply to sections @param [Section, Array] sects a section list of sections to render @param [Fixnum] start_at the index in the section list to start from @param [Boolean] break_first if true, renders only the first section @yield [opts] calls for the subsections to be rendered @yieldparam [Hash] opts any extra options to yield @return [String] the rendered sections joined together",
    "label": "",
    "id": "311"
  },
  {
    "raw_code": "def yieldall(opts = nil, &block)\n        with_section { run(opts, section, &block) }\n      end",
    "comment": "Yields all subsections with any extra options  @param [Hash] opts extra options to be applied to subsections",
    "label": "",
    "id": "312"
  },
  {
    "raw_code": "def erb(section, &block)\n        method_name = ErbCache.method_for(cache_filename(section)) do\n          erb_with(cache(section), cache_filename(section))\n        end",
    "comment": "@param [String, Symbol] section the section name @yield calls subsections to be rendered @return [String] the contents of the ERB rendered section",
    "label": "",
    "id": "313"
  },
  {
    "raw_code": "def file(basename, allow_inherited = false)\n        file = self.class.find_file(basename)\n        raise ArgumentError, \"no file for '#{basename}' in #{self.class.path}\" unless file\n\n        data = IO.read(file)\n        if allow_inherited\n          superfile = self.class.find_nth_file(basename, 2)\n          data.gsub!('{{{__super__}}}', superfile ? IO.read(superfile) : \"\")\n        end",
    "comment": "Returns the contents of a file. If +allow_inherited+ is set to +true+, use +{{{__super__}}}+ inside the file contents to insert the contents of the file from an inherited template. For instance, if +templates/b+ inherits from +templates/a+ and file \"test.css\" exists in both directories, both file contents can be retrieved by having +templates/b/test.css+ look like:  {{{__super__}}} ... body { css styles here } p.class { other styles }  @param [String] basename the name of the file @param [Boolean] allow_inherited whether inherited templates can be inserted with +{{{__super__}}}+ @return [String] the contents of a file identified by +basename+. All template paths (including any mixed in templates) are searched for the file @see ClassMethods#find_file @see ClassMethods#find_nth_file",
    "label": "",
    "id": "314"
  },
  {
    "raw_code": "def superb(sect = section, &block)\n        filename = self.class.find_nth_file(erb_file_for(sect), 2)\n        return \"\" unless filename\n        method_name = ErbCache.method_for(filename) { erb_with(IO.read(filename), filename) }\n        send(method_name, &block)\n      end",
    "comment": "Calls the ERB file from the last inherited template with {#section}.erb  @param [Symbol, String] sect if provided, uses a specific section name @return [String] the rendered ERB file in any of the inherited template paths.",
    "label": "",
    "id": "315"
  },
  {
    "raw_code": "def register_template_path(path)\n          template_paths.push(path) unless template_paths.include?(path)\n        end",
    "comment": "Registers a new template path in {template_paths}  @param [String] path a new template path @return [void]",
    "label": "",
    "id": "316"
  },
  {
    "raw_code": "def template(*path)\n          from_template = nil\n          from_template = path.shift if path.first.is_a?(Template)\n          path = path.join('/')\n          full_paths = find_template_paths(from_template, path)\n\n          path = File.cleanpath(path).gsub('../', '')\n          raise ArgumentError, \"No such template for #{path}\" if full_paths.empty?\n          mod = template!(path, full_paths)\n\n          mod\n        end",
    "comment": "Creates a template module representing the path. Searches on disk for the first directory named +path+ (joined by '/') within the template paths and builds a template module for. All other matching directories in other template paths will be included in the generated module as mixins (for overriding).  @param [Array<String, Symbol>] path a list of path components @raise [ArgumentError] if the path does not exist within one of the {template_paths} on disk. @return [Template] the module representing the template",
    "label": "",
    "id": "317"
  },
  {
    "raw_code": "def template!(path, full_paths = nil)\n          full_paths ||= [path]\n          full_paths = [full_paths] unless full_paths.is_a?(Array)\n          name = template_module_name(full_paths.first)\n          begin; return const_get(name); rescue NameError; nil end\n\n          mod = const_set(name, Module.new)\n          mod.send(:include, Template)\n          mod.send(:initialize, path, full_paths)\n          mod\n        end",
    "comment": "Forces creation of a template at +path+ within a +full_path+.  @param [String] path the path name of the template @param [Array<String>] full_paths the full path on disk of the template @return [Template] the template module representing the +path+",
    "label": "",
    "id": "318"
  },
  {
    "raw_code": "def render(options = {})\n          options = set_default_options(options)\n          mod = template(options.template, options.type, options.format)\n\n          if options.serializer && options.serialize != false\n            with_serializer(options.object, options.serializer) { mod.run(options) }\n          else\n            mod.run(options)\n          end",
    "comment": "Renders a template on a {CodeObjects::Base code object} using a set of default (overridable) options. Either the +:object+ or +:type+ keys must be provided.  If a +:serializer+ key is provided and +:serialize+ is not set to false, the rendered contents will be serialized through the {Serializers::Base} object. See {with_serializer}.  @example Renders an object with html formatting Engine.render(:format => :html, :object => obj) @example Renders without an object Engine.render(:type => :fulldoc, :otheropts => somevalue) @param [Hash] options the options hash @option options [Symbol] :format (:text) the default format @option options [Symbol] :type (nil) the :object's type. @option options [Symbol] :template (:default) the default template @return [String] the rendered template",
    "label": "",
    "id": "319"
  },
  {
    "raw_code": "def generate(objects, options = {})\n          options = set_default_options(options)\n          options.objects = objects\n          options.object = Registry.root\n          template(options.template, :fulldoc, options.format).run(options)\n        end",
    "comment": "Passes a set of objects to the +:fulldoc+ template for full documentation generation. This is called by {CLI::Yardoc} to most commonly perform HTML documentation generation.  @param [Array<CodeObjects::Base>] objects a list of {CodeObjects::Base} objects to pass to the template @param [Hash] options (see {render}) @return [void]",
    "label": "",
    "id": "320"
  },
  {
    "raw_code": "def with_serializer(object, serializer)\n          output = nil\n          filename = serializer.serialized_path(object)\n          if serializer.respond_to?(:basepath)\n            filename = File.join(serializer.basepath, filename)\n          end",
    "comment": "Serializes the results of a block with a +serializer+ object.  @param [CodeObjects::Base] object the code object to serialize @param [Serializers::Base] serializer the serializer object @yield a block whose result will be serialize @yieldreturn [String] the contents to serialize @see Serializers::Base",
    "label": "",
    "id": "321"
  },
  {
    "raw_code": "def set_default_options(options = {})\n          if options.is_a?(Hash)\n            options = TemplateOptions.new.tap do |o|\n              o.reset_defaults\n              o.update(options)\n            end",
    "comment": "Sets default options on the options hash  @param [Hash] options the options hash @option options [Symbol] :format (:text) the default format @option options [Symbol] :type (nil) the :object's type, if provided @option options [Symbol] :template (:default) the default template @return [void]",
    "label": "",
    "id": "322"
  },
  {
    "raw_code": "def find_template_paths(from_template, path)\n          paths = template_paths.dup\n          paths = from_template.full_paths + paths if from_template\n\n          paths.inject([]) do |acc, tp|\n            full_path = File.cleanpath(File.join(tp, path))\n            acc.unshift(full_path) if File.directory?(full_path)\n            acc\n          end.uniq\n        end",
    "comment": "Searches through the registered {template_paths} and returns all full directories that have the +path+ within them on disk.  @param [Template] from_template if provided, allows a relative path to be specified from this template's full path. @param [String] path the path component to search for in the {template_paths} @return [Array<String>] a list of full paths that are existing candidates for a template module",
    "label": "",
    "id": "323"
  },
  {
    "raw_code": "def template_module_name(path)\n          'Template_' + path.to_s.gsub(/[^a-z0-9]/i, '_')\n        end",
    "comment": "The name of the module that represents a +path+  @param [String] path the path to generate a module name for @return [String] the module name",
    "label": "",
    "id": "324"
  },
  {
    "raw_code": "def clear_markup_cache\n          self.markup_cache = {}\n        end",
    "comment": "Clears the markup provider cache information. Mainly used for testing. @return [void]",
    "label": "",
    "id": "325"
  },
  {
    "raw_code": "def load_markup_provider(type = options.markup)\n        return true if MarkupHelper.markup_cache[type]\n        MarkupHelper.markup_cache[type] ||= {}\n\n        providers = MARKUP_PROVIDERS[type.to_sym]\n        return true if providers && providers.empty?\n        if providers && options.markup_provider\n          providers = providers.select {|p| p[:lib] == options.markup_provider }\n        end",
    "comment": "Attempts to load the first valid markup provider in {MARKUP_PROVIDERS}. If a provider is specified, immediately try to load it.  On success this sets `@markup_provider` and `@markup_class` to the provider name and library constant class/module respectively for the loaded provider.  On failure this method will inform the user that no provider could be found and exit the program.  @return [Boolean] whether the markup provider was successfully loaded.",
    "label": "",
    "id": "326"
  },
  {
    "raw_code": "def markup_for_file(contents, filename)\n        return $1.to_sym if contents && contents =~ MARKUP_FILE_SHEBANG # Shebang support\n\n        ext = (File.extname(filename)[1..-1] || '').downcase\n        MARKUP_EXTENSIONS.each do |type, exts|\n          return type if exts.include?(ext)\n        end",
    "comment": "Checks for a shebang or looks at the file extension to determine the markup type for the file contents. File extensions are registered for a markup type in {MARKUP_EXTENSIONS}.  A shebang should be on the first line of a file and be in the form:  #!markup_type  Standard markup types are text, html, rdoc, markdown, textile  @param [String] contents Unused. Was necessary prior to 0.7.0. Newer versions of YARD use {CodeObjects::ExtraFileObject#contents} @return [Symbol] the markup type recognized for the file @see MARKUP_EXTENSIONS @since 0.6.0",
    "label": "",
    "id": "327"
  },
  {
    "raw_code": "def markup_file_contents(contents)\n        contents =~ MARKUP_FILE_SHEBANG ? $' : contents\n      end",
    "comment": "Strips any shebang lines on the file contents that pertain to markup or preprocessing data.  @deprecated Use {CodeObjects::ExtraFileObject#contents} instead @return [String] the file contents minus any preprocessing tags @since 0.6.0",
    "label": "",
    "id": "328"
  },
  {
    "raw_code": "def markup_class(type = options.markup)\n        load_markup_provider(type)\n        MarkupHelper.markup_cache[type][:class]\n      end",
    "comment": "Gets the markup provider class/module constant for a markup type Call {#load_markup_provider} before using this method.  @param [Symbol] type the markup type (:rdoc, :markdown, etc.) @return [Class] the markup class",
    "label": "",
    "id": "329"
  },
  {
    "raw_code": "def markup_provider(type = options.markup)\n        MarkupHelper.markup_cache[type][:provider]\n      end",
    "comment": "Gets the markup provider name for a markup type Call {#load_markup_provider} before using this method.  @param [Symbol] type the markup type (:rdoc, :markdown, etc.) @return [Symbol] the markup provider name (usually the gem name of the library)",
    "label": "",
    "id": "330"
  },
  {
    "raw_code": "def h(text)\n        CGI.escapeHTML(text.to_s)\n      end",
    "comment": "@group Escaping Template Data Escapes HTML entities  @param [String] text the text to escape @return [String] the HTML with escaped entities",
    "label": "",
    "id": "331"
  },
  {
    "raw_code": "def urlencode(text)\n        text = text.dup\n        enc = nil\n        if text.respond_to?(:force_encoding)\n          enc = text.encoding\n          text = text.force_encoding('binary')\n        end",
    "comment": "Escapes a URL  @param [String] text the URL @return [String] the escaped URL",
    "label": "",
    "id": "332"
  },
  {
    "raw_code": "def htmlify(text, markup = options.markup)\n        markup_meth = \"html_markup_#{markup}\"\n        return text unless respond_to?(markup_meth)\n        return \"\" unless text\n        return text unless markup\n        html = send(markup_meth, text).dup\n        if html.respond_to?(:encode)\n          html = html.force_encoding(text.encoding) # for libs that mess with encoding\n          html = html.encode(:invalid => :replace, :replace => '?')\n        end",
    "comment": "@group Converting Markup to HTML Turns text into HTML using +markup+ style formatting.  @param [String] text the text to format @param [Symbol] markup examples are +:markdown+, +:textile+, +:rdoc+. To add a custom markup type, see {MarkupHelper} @return [String] the HTML",
    "label": "",
    "id": "333"
  },
  {
    "raw_code": "def html_markup_markdown(text)\n        # TODO: other libraries might be more complex\n        provider = markup_class(:markdown)\n        case provider.to_s\n        when  'RDiscount'\n          provider.new(text, :autolink).to_html\n        when 'RedcarpetCompat'\n          provider.new(text, :autolink,\n                             :fenced_code,\n                             :gh_blockcode,\n                             :lax_spacing,\n                             :tables,\n                             :with_toc_data,\n                             :no_intraemphasis).to_html\n        when 'CommonMarker'\n          CommonMarker.render_html(text, %i[DEFAULT GITHUB_PRE_LANG], %i[autolink table])\n        else\n          provider.new(text).to_html\n        end",
    "comment": "Converts Markdown to HTML @param [String] text input Markdown text @return [String] output HTML @since 0.6.0",
    "label": "",
    "id": "334"
  },
  {
    "raw_code": "def html_markup_org(text)\n        markup_class(:org).new(text).to_html\n      end",
    "comment": "Converts org-mode to HTML @param [String] text input org-mode text @return [String] output HTML",
    "label": "",
    "id": "335"
  },
  {
    "raw_code": "def html_markup_asciidoc(text)\n        options = {:attributes => ASCIIDOC_ATTRIBUTES}\n        markup_class(:asciidoc).convert(text, options)\n      end",
    "comment": "Converts Asciidoc to HTML @param [String] text input Asciidoc text @return [String] output HTML",
    "label": "",
    "id": "336"
  },
  {
    "raw_code": "def html_markup_textile(text)\n        doc = markup_class(:textile).new(text)\n        doc.hard_breaks = false if doc.respond_to?(:hard_breaks=)\n        doc.to_html\n      end",
    "comment": "Converts Textile to HTML @param [String] text the input Textile text @return [String] output HTML @since 0.6.0",
    "label": "",
    "id": "337"
  },
  {
    "raw_code": "def html_markup_textile_strict(text)\n        markup_class(:textile).new(text).to_html\n      end",
    "comment": "Converts plaintext to strict Textile (hard breaks) @param [String] text the input textile data @return [String] the output HTML @since 0.6.0",
    "label": "",
    "id": "338"
  },
  {
    "raw_code": "def html_markup_rdoc(text)\n        doc = markup_class(:rdoc).new(text)\n        doc.from_path = url_for(object) if doc.respond_to?(:from_path=)\n        doc.to_html\n      end",
    "comment": "Converts RDoc formatting (SimpleMarkup) to HTML @param [String] text the input RDoc formatted text @return [String] output HTML @since 0.6.0",
    "label": "",
    "id": "339"
  },
  {
    "raw_code": "def html_markup_pre(text)\n        \"<pre>\" + h(text) + \"</pre>\"\n      end",
    "comment": "Converts plaintext to pre-formatted HTML @param [String] text the input text @return [String] the output HTML @since 0.6.0",
    "label": "",
    "id": "340"
  },
  {
    "raw_code": "def html_markup_text(text)\n        h(text).gsub(/\\r?\\n/, '<br/>')\n      end",
    "comment": "Converts plaintext to regular HTML @param [String] text the input text @return [String] the output HTML @since 0.6.0",
    "label": "",
    "id": "341"
  },
  {
    "raw_code": "def html_markup_none(text)\n        h(text)\n      end",
    "comment": "@return [String] the same text with no markup @since 0.6.6",
    "label": "",
    "id": "342"
  },
  {
    "raw_code": "def html_markup_html(text)\n        text\n      end",
    "comment": "Converts HTML to HTML @param [String] text input html @return [String] output HTML @since 0.6.0",
    "label": "",
    "id": "343"
  },
  {
    "raw_code": "def html_markup_ruby(source)\n        '<pre class=\"code ruby\">' + html_syntax_highlight(source, :ruby) + '</pre>'\n      end",
    "comment": "Highlights Ruby source. Similar to {#html_syntax_highlight}, but this method is meant to be called from {#htmlify} when markup is set to \"ruby\".  @param [String] source the Ruby source @return [String] the highlighted HTML @since 0.7.0",
    "label": "",
    "id": "344"
  },
  {
    "raw_code": "def htmlify_line(*args)\n        \"<div class='inline'>\" + htmlify(*args) + \"</div>\"\n      end",
    "comment": "@return [String] HTMLified text as a single line (paragraphs removed)",
    "label": "",
    "id": "345"
  },
  {
    "raw_code": "def html_syntax_highlight(source, type = nil)\n        return \"\" unless source\n        return h(source) unless options.highlight\n\n        new_type, source = parse_lang_for_codeblock(source)\n        type ||= new_type || :ruby\n        meth = \"html_syntax_highlight_#{type}\"\n        respond_to?(meth) ? send(meth, source) : h(source)\n      end",
    "comment": "@group Syntax Highlighting Source Code Syntax highlights +source+ in language +type+.  @note To support a specific language +type+, implement the method +html_syntax_highlight_TYPE+ in this class.  @param [String] source the source code to highlight @param [Symbol, String] type the language type (:ruby, :plain, etc). Use :plain for no syntax highlighting. @return [String] the highlighted source",
    "label": "",
    "id": "346"
  },
  {
    "raw_code": "def html_syntax_highlight_plain(source)\n        h(source)\n      end",
    "comment": "@return [String] unhighlighted source",
    "label": "",
    "id": "347"
  },
  {
    "raw_code": "def resolve_links(text)\n        code_tags = 0\n        text.gsub(%r{<(/)?(pre|code|tt)|(\\\\|!)?\\{(?!\\})(\\S+?)(?:\\s([^\\}]*?\\S))?\\}(?=[\\W<]|.+</|$)}m) do |str|\n          closed = $1\n          tag = $2\n          escape = $3\n          name = $4\n          title = $5\n          match = $&\n          if tag\n            code_tags += (closed ? -1 : 1)\n            next str\n          end",
    "comment": "@group Linking Objects and URLs Resolves any text in the form of +{Name}+ to the object specified by Name. Also supports link titles in the form +{Name title}+.  @example Linking to an instance method resolve_links(\"{MyClass#method}\") # => \"<a href='...'>MyClass#method</a>\" @example Linking to a class with a title resolve_links(\"{A::B::C the C class}\") # => \"<a href='...'>the c class</a>\" @param [String] text the text to resolve links in @return [String] HTML with linkified references",
    "label": "",
    "id": "348"
  },
  {
    "raw_code": "def link_file(filename, title = nil, anchor = nil)\n        if CodeObjects::ExtraFileObject === filename\n          file = filename\n        else\n          contents = File.file?(filename) ? nil : ''\n          file = CodeObjects::ExtraFileObject.new(filename, contents)\n        end",
    "comment": "(see BaseHelper#link_file)",
    "label": "",
    "id": "349"
  },
  {
    "raw_code": "def link_include_file(file)\n        unless file.is_a?(CodeObjects::ExtraFileObject)\n          file = CodeObjects::ExtraFileObject.new(file)\n        end",
    "comment": "(see BaseHelper#link_include_file)",
    "label": "",
    "id": "350"
  },
  {
    "raw_code": "def link_include_object(obj)\n        insert_include(obj.docstring)\n      end",
    "comment": "(see BaseHelper#link_include_object)",
    "label": "",
    "id": "351"
  },
  {
    "raw_code": "def insert_include(text, markup = options.markup)\n        htmlify(text, markup).gsub(%r{\\A\\s*<p>|</p>\\s*\\Z}, '')\n      end",
    "comment": "Inserts an include link while respecting inlining",
    "label": "",
    "id": "352"
  },
  {
    "raw_code": "def link_object(obj, title = nil, anchor = nil, relative = true)\n        return title if obj.nil?\n        obj = Registry.resolve(object, obj, true, true) if obj.is_a?(String)\n        if title\n          title = title.to_s\n        elsif object.is_a?(CodeObjects::Base)\n          # Check if we're linking to a class method in the current\n          # object. If we are, create a title in the format of\n          # \"CurrentClass.method_name\"\n          if obj.is_a?(CodeObjects::MethodObject) && obj.scope == :class && obj.parent == object\n            title = h([object.name, obj.sep, obj.name].join)\n          elsif obj.title != obj.path\n            title = h(obj.title)\n          else\n            title = h(object.relative_path(obj))\n          end",
    "comment": "(see BaseHelper#link_object)",
    "label": "",
    "id": "353"
  },
  {
    "raw_code": "def link_url(url, title = nil, params = {})\n        title ||= url\n        title = title.gsub(/[\\r\\n]/, ' ')\n        params = SymbolHash.new(false).update(\n          :href => url,\n          :title => h(title)\n        ).update(params)\n        params[:target] ||= '_parent' if url =~ %r{^(\\w+)://}\n        \"<a #{tag_attrs(params)}>#{title}</a>\".gsub(/[\\r\\n]/, ' ')\n      end",
    "comment": "(see BaseHelper#link_url)",
    "label": "",
    "id": "354"
  },
  {
    "raw_code": "def anchor_for(object)\n        case object\n        when CodeObjects::MethodObject\n          \"#{object.name}-#{object.scope}_#{object.type}\"\n        when CodeObjects::ClassVariableObject\n          \"#{object.name.to_s.gsub('@@', '')}-#{object.type}\"\n        when CodeObjects::Base\n          \"#{object.name}-#{object.type}\"\n        when CodeObjects::Proxy\n          object.path\n        else\n          object.to_s\n        end",
    "comment": "@group URL Helpers @param [CodeObjects::Base] object the object to get an anchor for @return [String] the anchor for a specific object",
    "label": "",
    "id": "355"
  },
  {
    "raw_code": "def url_for(obj, anchor = nil, relative = true)\n        link = nil\n        return link unless serializer\n        return link if obj.is_a?(CodeObjects::Base) && run_verifier([obj]).empty?\n\n        if obj.is_a?(CodeObjects::Base) && !obj.is_a?(CodeObjects::NamespaceObject)\n          # If the obj is not a namespace obj make it the anchor.\n          anchor = obj\n          obj = obj.namespace\n        end",
    "comment": "Returns the URL for an object.  @param [String, CodeObjects::Base] obj the object (or object path) to link to @param [String] anchor the anchor to link to @param [Boolean] relative use a relative or absolute link @return [String] the URL location of the object",
    "label": "",
    "id": "356"
  },
  {
    "raw_code": "def url_for_list(type)\n        url_for_file(\"#{type}_list.html\")\n      end",
    "comment": "Returns the URL for a list type  @param [String, Symbol] type the list type to generate a URL for @return [String] the URL pointing to the list @since 0.8.0",
    "label": "",
    "id": "357"
  },
  {
    "raw_code": "def url_for_frameset\n        url_for_file(\"frames.html\")\n      end",
    "comment": "Returns the URL for the frameset page  @return [String] the URL pointing to the frames page @since 0.8.0",
    "label": "",
    "id": "358"
  },
  {
    "raw_code": "def url_for_main\n        url_for_file(\"index.html\")\n      end",
    "comment": "Returns the URL for the main page (README or alphabetic index)  @return [String] the URL pointing to the first main page the user should see.",
    "label": "",
    "id": "359"
  },
  {
    "raw_code": "def url_for_index\n        url_for_file(\"_index.html\")\n      end",
    "comment": "Returns the URL for the alphabetic index page  @return [String] the URL pointing to the first main page the user should see.",
    "label": "",
    "id": "360"
  },
  {
    "raw_code": "def format_object_name_list(objects)\n        objects.sort_by {|o| o.name.to_s.downcase }.map do |o|\n          \"<span class='name'>\" + linkify(o, o.name) + \"</span>\"\n        end.join(\", \")\n      end",
    "comment": "@group Formatting Objects and Attributes Formats a list of objects and links them @return [String] a formatted list of objects",
    "label": "",
    "id": "361"
  },
  {
    "raw_code": "def format_types(typelist, brackets = true)\n        return unless typelist.is_a?(Array)\n        list = typelist.map do |type|\n          type = type.gsub(/([<>])/) { h($1) }\n          type = type.gsub(/([\\w:]+)/) { $1 == \"lt\" || $1 == \"gt\" ? $1 : linkify($1, $1) }\n          \"<tt>\" + type + \"</tt>\"\n        end",
    "comment": "Formats a list of types from a tag.  @param [Array<String>, FalseClass] typelist the list of types to be formatted.  @param [Boolean] brackets omits the surrounding brackets if +brackets+ is set to +false+.  @return [String] the list of types formatted as [Type1, Type2, ...] with the types linked to their respective descriptions. ",
    "label": "",
    "id": "362"
  },
  {
    "raw_code": "def signature_types(meth, link = true)\n        meth = convert_method_to_overload(meth)\n        if meth.respond_to?(:object) && !meth.has_tag?(:return)\n          meth = meth.object\n        end",
    "comment": "Get the return types for a method signature.  @param [CodeObjects::MethodObject] meth the method object @param [Boolean] link whether to link the types @return [String] the signature types @since 0.5.3",
    "label": "",
    "id": "363"
  },
  {
    "raw_code": "def signature(meth, link = true, show_extras = true, full_attr_name = true)\n        meth = convert_method_to_overload(meth)\n\n        type = signature_types(meth, link)\n        type = \"&#x21d2; #{type}\" if type && !type.empty?\n        scope = meth.scope == :class ? \".\" : \"#\"\n        name = full_attr_name ? meth.name : meth.name.to_s.gsub(/^(\\w+)=$/, '\\1')\n        blk = format_block(meth)\n        args = !full_attr_name && meth.writer? ? \"\" : format_args(meth)\n        extras = []\n        extras_text = ''\n        if show_extras\n          rw = meth.attr_info\n          if rw\n            attname = [rw[:read] ? 'read' : nil, rw[:write] ? 'write' : nil].compact\n            attname = attname.size == 1 ? attname.join('') + 'only' : nil\n            extras << attname if attname\n          end",
    "comment": "Formats the signature of method +meth+.  @param [CodeObjects::MethodObject] meth the method object to list the signature of @param [Boolean] link whether to link the method signature to the details view @param [Boolean] show_extras whether to show extra meta-data (visibility, attribute info) @param [Boolean] full_attr_name whether to show the full attribute name (\"name=\" instead of \"name\") @return [String] the formatted method signature",
    "label": "",
    "id": "364"
  },
  {
    "raw_code": "def charset\n        has_encoding = defined?(::Encoding)\n        if defined?(@file) && @file && has_encoding\n          lang = @file.contents.encoding.to_s\n        else\n          return 'utf-8' unless has_encoding || ENV['LANG']\n          lang =\n            if has_encoding\n              ::Encoding.default_external.name.downcase\n            else\n              ENV['LANG'].downcase.split('.').last\n            end",
    "comment": "@group Getting the Character Encoding Returns the current character set. The default value can be overridden by setting the +LANG+ environment variable or by overriding this method. In Ruby 1.9 you can also modify this value by setting +Encoding.default_external+.  @return [String] the current character set @since 0.5.4",
    "label": "",
    "id": "365"
  },
  {
    "raw_code": "def tag_attrs(opts = {})\n        opts.sort_by {|k, _v| k.to_s }.map {|k, v| \"#{k}=#{v.to_s.inspect}\" if v }.join(\" \")\n      end",
    "comment": "Converts a set of hash options into HTML attributes for a tag  @param [Hash{String => String}] opts the tag options @return [String] the tag attributes of an HTML tag",
    "label": "",
    "id": "366"
  },
  {
    "raw_code": "def convert_method_to_overload(meth)\n        # use first overload tag if it has a return type and method itself does not\n        if !meth.tag(:return) && meth.tags(:overload).size == 1 && meth.tag(:overload).tag(:return)\n          return meth.tag(:overload)\n        end",
    "comment": "Converts a {CodeObjects::MethodObject} into an overload object @since 0.5.3",
    "label": "",
    "id": "367"
  },
  {
    "raw_code": "def parse_lang_for_codeblock(source)\n        type = nil\n        if source =~ /\\A(?:[ \\t]*\\r?\\n)?[ \\t]*!!!([\\w.+-]+)[ \\t]*\\r?\\n/\n          type = $1\n          source = $'\n        end",
    "comment": "Parses !!!lang out of codeblock, returning the codeblock language followed by the source code.  @param [String] source the source code whose language to determine @return [Array(String, String)] the language, if any, and the remaining source @since 0.7.5",
    "label": "",
    "id": "368"
  },
  {
    "raw_code": "def parse_codeblocks(html)\n        html.gsub(%r{<pre((?:\\s+\\w+=\"(?:.+?)\")*)\\s*>(?:\\s*<code((?:\\s+\\w+=\"(?:.+?)\")*)\\s*>)?(.+?)(?:</code>\\s*)?</pre>}m) do\n          string = $3\n\n          # handle !!!LANG prefix to send to html_syntax_highlight_LANG\n          language, = parse_lang_for_codeblock(string)\n          language ||= detect_lang_in_codeblock_attributes($1, $2)\n          language ||= object.source_type\n\n          if options.highlight\n            string = html_syntax_highlight(CGI.unescapeHTML(string), language)\n          end",
    "comment": "Parses code blocks out of html and performs syntax highlighting on code inside of the blocks.  @param [String] html the html to search for code in @return [String] highlighted html @see #html_syntax_highlight",
    "label": "",
    "id": "369"
  },
  {
    "raw_code": "def detect_lang_in_codeblock_attributes(pre_html_attrs, code_html_attrs)\n        detected = nil\n        detected ||= (/\\bdata-lang=\"(.+?)\"/ =~ code_html_attrs && $1)\n        detected ||= (/\\blang=\"(.+?)\"/ =~ pre_html_attrs && $1)\n        detected ||= (/\\bclass=\"(.+?)\"/ =~ code_html_attrs && $1)\n        detected\n      end",
    "comment": "Parses code block's HTML attributes in order to detect the programming language of what's enclosed in that code block.  @param [String, nil] pre_html_attrs HTML attribute list of +pre+ element @param [String, nil] code_html_attrs HTML attribute list of +code+ element @return [String, nil] detected programming language",
    "label": "",
    "id": "370"
  },
  {
    "raw_code": "def is_method?(object)\n        object.type == :method\n      end",
    "comment": "@return [Boolean] whether an object is a method",
    "label": "",
    "id": "371"
  },
  {
    "raw_code": "def is_namespace?(object)\n        object.is_a?(CodeObjects::NamespaceObject)\n      end",
    "comment": "@return [Boolean] whether an object is a namespace",
    "label": "",
    "id": "372"
  },
  {
    "raw_code": "def is_class?(object)\n        object.is_a?(CodeObjects::ClassObject)\n      end",
    "comment": "@return [Boolean] whether an object is a class",
    "label": "",
    "id": "373"
  },
  {
    "raw_code": "def is_module?(object)\n        object.is_a?(CodeObjects::ModuleObject)\n      end",
    "comment": "@return [Boolean] whether an object is a module",
    "label": "",
    "id": "374"
  },
  {
    "raw_code": "def link_include_object(obj)\n      obj.docstring\n    end",
    "comment": "Includes an object's docstring into output. @since 0.6.0 @param [CodeObjects::Base] obj the object to include @return [String] the object's docstring (no tags)",
    "label": "",
    "id": "375"
  },
  {
    "raw_code": "def link_include_file(file)\n      File.read(file)\n    end",
    "comment": "Include a file as a docstring in output @since 0.7.0 @param [String] file the filename to include @return [String] the file's contents",
    "label": "",
    "id": "376"
  },
  {
    "raw_code": "def link_object(obj, title = nil)\n      return title if title\n\n      case obj\n      when YARD::CodeObjects::Base, YARD::CodeObjects::Proxy\n        obj.title\n      when String, Symbol\n        P(obj).title\n      else\n        obj\n      end",
    "comment": "Links to an object with an optional title  @param [CodeObjects::Base] obj the object to link to @param [String] title the title to use for the link @return [String] the linked object",
    "label": "",
    "id": "377"
  },
  {
    "raw_code": "def link_url(url, title = nil, params = nil) # rubocop:disable Lint/UnusedMethodArgument\n      url\n    end",
    "comment": "Links to a URL  @param [String] url the URL to link to @param [String] title the optional title to display the link as @param [Hash] params optional parameters for the link @return [String] the linked URL",
    "label": "",
    "id": "378"
  },
  {
    "raw_code": "def link_file(filename, title = nil, anchor = nil) # rubocop:disable Lint/UnusedMethodArgument\n      return filename.filename if CodeObjects::ExtraFileObject === filename\n      filename\n    end",
    "comment": "Links to an extra file  @param [String] filename the filename to link to @param [String] title the title of the link @param [String] anchor optional anchor @return [String] the link to the file @since 0.5.5",
    "label": "",
    "id": "379"
  },
  {
    "raw_code": "def format_types(list, brackets = true)\n      list.nil? || list.empty? ? \"\" : (brackets ? \"(#{list.join(\", \")})\" : list.join(\", \"))\n    end",
    "comment": "@group Formatting Object Attributes Formats a list of return types for output and links each type.  @example Formatting types format_types(['String', 'Array']) #=> \"(String, Array)\" @example Formatting types without surrounding brackets format_types(['String', 'Array'], false) #=> \"String, Array\" @param [Array<String>] list a list of types @param [Boolean] brackets whether to surround the types in brackets @return [String] the formatted list of Ruby types",
    "label": "",
    "id": "380"
  },
  {
    "raw_code": "def format_object_type(object)\n      case object\n      when YARD::CodeObjects::ClassObject\n        object.is_exception? ? \"Exception\" : \"Class\"\n      else\n        object.type.to_s.capitalize\n      end",
    "comment": "@example Formatted type of an exception class o = ClassObject.new(:root, :MyError) o.superclass = P('RuntimeError') format_object_type(o) # => \"Exception\" @example Formatted type of a method o = MethodObject.new(:root, :to_s) format_object_type(o) # => \"Method\" @param [CodeObjects::Base] object the object to retrieve the type for @return [String] the human-readable formatted {CodeObjects::Base#type #type} for the object",
    "label": "",
    "id": "381"
  },
  {
    "raw_code": "def format_object_title(object)\n      case object\n      when YARD::CodeObjects::RootObject\n        \"Top Level Namespace\"\n      else\n        format_object_type(object) + \": \" + object.title\n      end",
    "comment": "@example s = format_object_title ModuleObject.new(:root, :MyModuleName) s # => \"Module: MyModuleName\" @param [CodeObjects::Base] object the object to retrieve a title for @return [String] the page title name for a given object",
    "label": "",
    "id": "382"
  },
  {
    "raw_code": "def format_source(value)\n      sp = value.split(\"\\n\").last[/^(\\s+)/, 1]\n      num = sp ? sp.size : 0\n      value.gsub(/^\\s{#{num}}/, '')\n    end",
    "comment": "Indents and formats source code  @param [String] value the input source code @return [String] formatted source code",
    "label": "",
    "id": "383"
  },
  {
    "raw_code": "def format_args(object)\n        return if object.parameters.nil?\n        params = object.parameters\n        if object.has_tag?(:yield) || object.has_tag?(:yieldparam)\n          params.reject! do |param|\n            param[0].to_s[0, 1] == \"&\" &&\n              !object.tags(:param).any? {|t| t.name == param[0][1..-1] }\n          end",
    "comment": "@return [String] formatted arguments for a method",
    "label": "",
    "id": "384"
  },
  {
    "raw_code": "def format_return_types(object)\n        return unless object.has_tag?(:return) && object.tag(:return).types\n        return if object.tag(:return).types.empty?\n        format_types [object.tag(:return).types.first], false\n      end",
    "comment": "@return [String] formatted and linked return types for a method",
    "label": "",
    "id": "385"
  },
  {
    "raw_code": "def format_block(object)\n        if object.has_tag?(:yield) && object.tag(:yield).types\n          params = object.tag(:yield).types\n        elsif object.has_tag?(:yieldparam)\n          params = object.tags(:yieldparam).map(&:name)\n        elsif object.has_tag?(:yield)\n          return \"{ ... }\"\n        else\n          params = nil\n        end",
    "comment": "@return [String] formatted block if one exists",
    "label": "",
    "id": "386"
  },
  {
    "raw_code": "def format_lines(object)\n        return \"\" if object.source.nil? || object.line.nil?\n        i = -1\n        object.source.split(/\\n/).map { object.line + (i += 1) }.join(\"\\n\")\n      end",
    "comment": "@return [String] formats line numbers for source code of an object",
    "label": "",
    "id": "387"
  },
  {
    "raw_code": "def format_code(object, _show_lines = false)\n        i = -1\n        lines = object.source.split(/\\n/)\n        longestline = (object.line + lines.size).to_s.length\n        lines.map do |line|\n          lineno = object.line + (i += 1)\n          (\" \" * (longestline - lineno.to_s.length)) + lineno.to_s + \"    \" + line\n        end.join(\"\\n\")\n      end",
    "comment": "@return [String] formats source of an object",
    "label": "",
    "id": "388"
  },
  {
    "raw_code": "def format_constant(value)\n        # last can return nil, so default to empty string\n        sp = value.split(\"\\n\").last || \"\"\n        sp = sp[/^(\\s+)/, 1]\n        num = sp ? sp.size : 0\n        html_syntax_highlight value.gsub(/^\\s{#{num}}/, '')\n      end",
    "comment": "@return [String] formats source code of a constant value",
    "label": "",
    "id": "389"
  },
  {
    "raw_code": "def uml_visibility(object)\n        case object.visibility\n        when :public;    '+'\n        when :protected; '#'\n        when :private;   '-'\n        end",
    "comment": "Official UML visibility prefix syntax for an object given its visibility @param [CodeObjects::Base] object the object to retrieve visibility for @return [String] the UML visibility prefix",
    "label": "",
    "id": "390"
  },
  {
    "raw_code": "def format_path(object)\n        object.path.gsub('::', '_')\n      end",
    "comment": "Formats the path of an object for Graphviz syntax @param [CodeObjects::Base] object an object to format the path of @return [String] the encoded path",
    "label": "",
    "id": "391"
  },
  {
    "raw_code": "def h(text)\n        text.to_s.gsub(/(\\W)/, '\\\\\\\\\\1')\n      end",
    "comment": "Encodes text in escaped Graphviz syntax @param [String] text text to encode @return [String] the encoded text",
    "label": "",
    "id": "392"
  },
  {
    "raw_code": "def tidy(data)\n        indent = 0\n        data.split(/\\n/).map do |line|\n          line.gsub!(/^\\s*/, '')\n          next if line.empty?\n          indent -= 1 if line =~ /^\\s*\\}\\s*$/\n          line = (' ' * (indent * 2)) + line\n          indent += 1 if line =~ /\\{\\s*$/\n          line\n        end.compact.join(\"\\n\") + \"\\n\"\n      end",
    "comment": "Tidies data by formatting and indenting text @param [String] data pre-formatted text @return [String] tidied text.",
    "label": "",
    "id": "393"
  },
  {
    "raw_code": "def prune_method_listing(list, hide_attributes = true)\n          list = run_verifier(list)\n          list = list.reject {|o| run_verifier([o.parent]).empty? }\n          list = list.reject {|o| o.is_alias? unless CodeObjects::Proxy === o.namespace }\n          list = list.reject {|o| o.is_attribute? unless CodeObjects::Proxy === o.namespace } if hide_attributes\n          list\n        end",
    "comment": "Prunes the method listing by running the verifier and removing attributes/aliases @param [Array<CodeObjects::Base>] list a list of methods @param [Boolean] hide_attributes whether to prune attribute methods from the list @return [Array<CodeObjects::Base>] a pruned list of methods",
    "label": "",
    "id": "394"
  },
  {
    "raw_code": "def h(text)\n          out = String.new(\"\")\n          text = resolve_links(text)\n          text = text.split(/\\n/)\n          text.each_with_index do |line, i|\n            out <<\n              case line\n              when /^\\s*$/; \"\\n\\n\"\n              when /^\\s+\\S/, /^=/; line + \"\\n\"\n              else; line + (text[i + 1] =~ /^\\s+\\S/ ? \"\\n\" : \" \")\n              end",
    "comment": "@return [String] escapes text",
    "label": "",
    "id": "395"
  },
  {
    "raw_code": "def wrap(text, col = 72)\n          text.gsub(/(.{1,#{col}})( +|$\\n?)|(.{1,#{col}})/, \"\\\\1\\\\3\\n\")\n        end",
    "comment": "@return [String] wraps text at +col+ columns.",
    "label": "",
    "id": "396"
  },
  {
    "raw_code": "def indent(text, len = 4)\n          text.gsub(/^/, ' ' * len)\n        end",
    "comment": "@return [String] indents +text+ by +len+ characters.",
    "label": "",
    "id": "397"
  },
  {
    "raw_code": "def title_align_right(text, col = 72)\n          align_right(text, '-', col)\n        end",
    "comment": "@return [String] aligns a title to the right",
    "label": "",
    "id": "398"
  },
  {
    "raw_code": "def align_right(text, spacer = ' ', col = 72)\n          text = text[0, col - 4] + '...' if (col - 1 - text.length) < 0\n          spacer * (col - 1 - text.length) + \" \" + text\n        end",
    "comment": "@return [String] aligns text to the right",
    "label": "",
    "id": "399"
  },
  {
    "raw_code": "def hr(col = 72, sep = \"-\")\n          sep * col\n        end",
    "comment": "@return [String] returns a horizontal rule for output",
    "label": "",
    "id": "400"
  },
  {
    "raw_code": "def signature(meth)\n          # use first overload tag if it has a return type and method itself does not\n          if !meth.tag(:return) && meth.tag(:overload) && meth.tag(:overload).tag(:return)\n            meth = meth.tag(:overload)\n          end",
    "comment": "@return [String] the formatted signature for a method",
    "label": "",
    "id": "401"
  },
  {
    "raw_code": "def html_syntax_highlight_ruby(source)\n          if Parser::SourceParser.parser_type == :ruby\n            html_syntax_highlight_ruby_ripper(source)\n          else\n            html_syntax_highlight_ruby_legacy(source)\n          end",
    "comment": "Highlights Ruby source @param [String] source the Ruby source code @return [String] the highlighted Ruby source",
    "label": "",
    "id": "402"
  },
  {
    "raw_code": "def initialize(text)\n            @text = text\n\n            @@mutex.synchronize do\n              @@formatter ||= RDocMarkupToHtml.new\n              @@markup ||= MARKUP.new\n            end",
    "comment": "@param text [String]",
    "label": "",
    "id": "403"
  },
  {
    "raw_code": "def to_html\n            html = nil\n            @@mutex.synchronize do\n              @@formatter.from_path = from_path\n              html = @@markup.convert(@text, @@formatter)\n            end",
    "comment": "@return [String]",
    "label": "",
    "id": "404"
  },
  {
    "raw_code": "def fix_typewriter(text)\n            code_tags = 0\n            text.gsub(%r{<(/)?(pre|code|tt)|(\\s|^|>)\\+(?! )([^\\n\\+]{1,900})(?! )\\+}) do |str|\n              closed = $1\n              tag = $2\n              first_text = $3\n              type_text = $4\n\n              if tag\n                code_tags += (closed ? -1 : 1)\n                next str\n              end",
    "comment": "Fixes RDoc behaviour with ++ only supporting alphanumeric text.  @todo Refactor into own SimpleMarkup subclass",
    "label": "",
    "id": "405"
  },
  {
    "raw_code": "def fix_dash_dash(text)\n            text.gsub(/&#8212;(?=\\S)/, '--')\n          end",
    "comment": "Don't allow -- to turn into &#8212; element. The chances of this being some --option is far more likely than the typographical meaning.  @todo Refactor into own SimpleMarkup subclass",
    "label": "",
    "id": "406"
  },
  {
    "raw_code": "def handle_special_HYPERLINK(special) # rubocop:disable Style/MethodName\n            @hyperlink ? special.text : super\n          end",
    "comment": "Disable auto-link of URLs",
    "label": "",
    "id": "407"
  },
  {
    "raw_code": "def initialize(opts = {})\n        @options = SymbolHash.new(false).update(opts)\n      end",
    "comment": "@group Creating a New Serializer Creates a new serializer with options  @param [Hash] opts the options to assign to {#options}",
    "label": "",
    "id": "408"
  },
  {
    "raw_code": "def serialize(object, data) end\n\n      # The serialized path of an object\n      #\n      # @abstract This method should return the path of the object on the\n      #   endpoint. For instance, for a file serializer, this should return\n      #   the filename that represents the object on disk.\n      # @param [CodeObjects::Base] object the object to return a path for\n      # @return [String] the serialized path of an object\n      def serialized_path(object) end\n\n      # Returns whether an object has been serialized\n      #\n      # @abstract This method should return whether the endpoint already exists.\n      #   For instance, a file system serializer would check if the file exists\n      #   on disk. You will most likely use +#basepath+ and {#serialized_path} to\n      #   get the endpoint's location.\n      # @param [CodeObjects::Base] object the object to check existence of\n      # @return [Boolean] whether the endpoint exists.\n      # @since 0.6.0\n      def exists?(object) # rubocop:disable Lint/UnusedMethodArgument\n        false\n      end\n\n      # @group Callbacks\n\n      # Called before serialization.\n      #\n      # @abstract Should run code before serialization. Should return false\n      #   if serialization should not occur.\n      # @return [Boolean] whether or not serialization should occur\n      def before_serialize; end\n\n      # Called after serialization.\n      #\n      # @abstract Should run code after serialization.\n      # @param [String] data the data that was serialized.\n      # @return [void]\n      def after_serialize(data); end\n    end\n  end\nend",
    "comment": "@group Serializing an Object Serializes an object.  @abstract This method should implement the logic that serializes +data+ to the respective endpoint. This method should also call the before and after callbacks {#before_serialize} and {#after_serialize} @param [CodeObjects::Base, String] object the object to serialize the data for. The object can also be a string (for non-object serialization) @param [String] data the contents that should be serialized",
    "label": "",
    "id": "409"
  },
  {
    "raw_code": "def initialize(opts = {})\n        super\n        @name_map = nil\n        @basepath = (options[:basepath] || 'doc').to_s\n        @extension = (options.key?(:extension) ? options[:extension] : 'html').to_s\n      end",
    "comment": "Creates a new FileSystemSerializer with options  @option opts [String] :basepath ('doc') the base path to write data to @option opts [String] :extension ('html') the extension of the serialized path filename. If this is set to the empty string, no extension is used.",
    "label": "",
    "id": "410"
  },
  {
    "raw_code": "def serialize(object, data)\n        path = File.join(basepath, serialized_path(object))\n        log.debug \"Serializing to #{path}\"\n        File.open!(path, \"wb\") {|f| f.write data }\n      end",
    "comment": "Serializes object with data to its serialized path (prefixed by the +#basepath+).  @return [String] the written data (for chaining)",
    "label": "",
    "id": "411"
  },
  {
    "raw_code": "def serialized_path(object)\n        return object if object.is_a?(String)\n\n        if object.is_a?(CodeObjects::ExtraFileObject)\n          fspath = ['file.' + object.name + (extension.empty? ? '' : \".#{extension}\")]\n        else\n          objname = object != YARD::Registry.root ? mapped_name(object) : \"top-level-namespace\"\n          objname += '_' + object.scope.to_s[0, 1] if object.is_a?(CodeObjects::MethodObject)\n          fspath = [objname + (extension.empty? ? '' : \".#{extension}\")]\n          if object.namespace && object.namespace.path != \"\"\n            fspath.unshift(*object.namespace.path.split(CodeObjects::NSEP))\n          end",
    "comment": "Implements the serialized path of a code object.  @param [CodeObjects::Base, CodeObjects::ExtraFileObject, String] object the object to get a path for. The path of a string is the string itself. @return [String] if object is a String, returns object, otherwise the path on disk (without the basepath).",
    "label": "",
    "id": "412"
  },
  {
    "raw_code": "def exists?(object)\n        File.exist?(File.join(basepath, serialized_path(object)))\n      end",
    "comment": "Checks the disk for an object and returns whether it was serialized.  @param [CodeObjects::Base] object the object to check @return [Boolean] whether an object has been serialized to disk",
    "label": "",
    "id": "413"
  },
  {
    "raw_code": "def build_filename_map\n        @name_map = {}\n        YARD::Registry.all.each do |object|\n          lpath = nil\n          if object.parent && object.parent.type != :root\n            lpath = object.parent.path + \"::\" + object.name.to_s.downcase\n          else\n            lpath = object.path.downcase\n          end",
    "comment": "Builds a filename mapping from object paths to filesystem path names. Needed to handle case sensitive YARD objects mapped into a case insensitive filesystem. Uses with {#mapped_name} to determine the mapping name for a given object.  @note In order to use filesystem name mapping, you must initialize the serializer object after preparing the {YARD::Registry}.",
    "label": "",
    "id": "414"
  },
  {
    "raw_code": "def mapped_name(object)\n        build_filename_map unless @name_map\n        map = @name_map[object.path.downcase]\n        map && map[object.name] ? map[object.name] : object.name.to_s\n      end",
    "comment": "@return [String] the filesystem mapped name of a given object.",
    "label": "",
    "id": "415"
  },
  {
    "raw_code": "def encode_path_components(*components)\n        components.map! do |p|\n          p.gsub(/[^\\w\\.-]/) do |x|\n            encoded = String.new('_')\n\n            x.each_byte {|b| encoded << (\"%X\" % b) }\n            encoded\n          end",
    "comment": "Remove special chars from filenames. Windows disallows \\ / : * ? \" < > | but we will just remove any non alphanumeric (plus period, underscore and dash).",
    "label": "",
    "id": "416"
  },
  {
    "raw_code": "def initialize(cmd)\n        @cmd = cmd\n      end",
    "comment": "Creates a new ProcessSerializer for the shell command +cmd+  @param [String] cmd the command that will accept data on stdin",
    "label": "",
    "id": "417"
  },
  {
    "raw_code": "def serialize(_object, data)\n        IO.popen(@cmd, 'w') {|io| io.write(data) }\n      end",
    "comment": "Overrides serialize behaviour and writes data to standard input of the associated command",
    "label": "",
    "id": "418"
  },
  {
    "raw_code": "def initialize(wrap = nil)\n        @wrap = wrap\n      end",
    "comment": "Creates a serializer to print text to stdout  @param [Fixnum, nil] wrap if wrap is a number, wraps text to +wrap+ columns, otherwise no wrapping is done.",
    "label": "",
    "id": "419"
  },
  {
    "raw_code": "def serialize(_object, data)\n        print(@wrap ? word_wrap(data, @wrap) : data)\n      end",
    "comment": "Overrides serialize behaviour to write data to standard output",
    "label": "",
    "id": "420"
  },
  {
    "raw_code": "def word_wrap(text, _length = 80)\n        # See ruby-talk/10655 / Ernest Ellingson\n        text.gsub(/\\t/, \"     \").gsub(/.{1,50}(?:\\s|\\Z)/) do\n          ($& + 5.chr).gsub(/\\n\\005/, \"\\n\").gsub(/\\005/, \"\\n\")\n        end",
    "comment": "Wraps text to a specific column length  @param [String] text the text to wrap @param [Fixnum] _length the column length to wrap to @return [String] the wrapped text",
    "label": "",
    "id": "421"
  },
  {
    "raw_code": "def shell_split\n    out = [String.new(\"\")]\n    state = :none\n    escape_next = false\n    quote = String.new(\"\")\n    strip.split(//).each do |char|\n      case state\n      when :none, :space\n        case char\n        when /\\s/\n          out << String.new(\"\") unless state == :space\n          state = :space\n          escape_next = false\n        when \"\\\\\"\n          if escape_next\n            out.last << char\n            escape_next = false\n          else\n            escape_next = true\n          end",
    "comment": "Splits text into tokens the way a shell would, handling quoted text as a single token. Use '\\\"' and \"\\'\" to escape quotes and '\\\\' to escape a backslash.  @return [Array] an array representing the tokens",
    "label": "",
    "id": "422"
  },
  {
    "raw_code": "def initialize(symbolize_value = true)\n    @symbolize_value = symbolize_value\n  end",
    "comment": "Creates a new SymbolHash object  @param [Boolean] symbolize_value converts any String values into Symbols if this is set to +true+.",
    "label": "",
    "id": "423"
  },
  {
    "raw_code": "def self.[](*hsh)\n    obj = new\n    if hsh.size == 1 && hsh.first.is_a?(Hash)\n      hsh.first.each {|k, v| obj[k] = v }\n    else\n      0.step(hsh.size, 2) {|n| obj[hsh[n]] = hsh[n + 1] }\n    end",
    "comment": "@overload [](hash) Creates a SymbolHash object from an existing Hash  @example SymbolHash['x' => 1, :y => 2] # => #<SymbolHash:0x...> @param [Hash] hash the hash object @return [SymbolHash] a new SymbolHash from a hash object  @overload [](*list) Creates a SymbolHash from an even list of keys and values  @example SymbolHash[key1, value1, key2, value2, ...] @param [Array] list an even list of key followed by value @return [SymbolHash] a new SymbolHash object",
    "label": "",
    "id": "424"
  },
  {
    "raw_code": "def []=(key, value)\n    super(key.to_sym, value.instance_of?(String) && @symbolize_value ? value.to_sym : value)\n  end",
    "comment": "Assigns a value to a symbolized key @param [#to_sym] key the key @param [Object] value the value to be assigned. If this is a String and values are set to be symbolized, it will be converted into a Symbol.",
    "label": "",
    "id": "425"
  },
  {
    "raw_code": "def [](key) super(key.to_sym) end\n\n  # Deleted a key and value associated with it\n  # @param [#to_sym] key the key to delete\n  # @return [void]\n  def delete(key) super(key.to_sym) end\n\n  # Tests if a symbolized key exists\n  # @param [#to_sym] key the key to test\n  # @return [Boolean] whether the key exists\n  def key?(key) super(key.to_sym) end\n  alias has_key? key?\n\n  # Updates the object with the contents of another Hash object.\n  # This method modifies the original SymbolHash object\n  #\n  # @param [Hash] hash the hash object to copy the values from\n  # @return [SymbolHash] self\n  def update(hash) hash.each {|k, v| self[k] = v }; self end\n  alias merge! update\n\n  # Merges the contents of another hash into a new SymbolHash object\n  #\n  # @param [Hash] hash the hash of objects to copy\n  # @return [SymbolHash] a new SymbolHash containing the merged data\n  def merge(hash) dup.merge!(hash) end\nend",
    "comment": "Accessed a symbolized key @param [#to_sym] key the key to access @return [Object] the value associated with the key",
    "label": "",
    "id": "426"
  },
  {
    "raw_code": "def initialize(list, value)\n    @list = list\n    @values = (Array === value ? value : [value])\n  end",
    "comment": "Creates an insertion object on a list with a value to be inserted. To finalize the insertion, call {#before} or {#after} on the object.  @param [Array] list the list to perform the insertion on @param [Object] value the value to insert",
    "label": "",
    "id": "427"
  },
  {
    "raw_code": "def before(val, recursive = false) insertion(val, 0, recursive) end\n\n  # Inserts the value after +val+.\n  #\n  # @example If subsections are ignored\n  #   Insertion.new([1, [2], 3], :X).after(1) # => [1, [2], :X, 3]\n  # @param [Object] val the object the value will be inserted after\n  # @param [Boolean] recursive look inside sublists\n  def after(val, recursive = false) insertion(val, 1, recursive) end\n\n  # Alias for {#before} with +recursive+ set to true\n  # @since 0.6.0\n  def before_any(val) insertion(val, 0, true) end\n\n  # Alias for {#after} with +recursive+ set to true\n  # @since 0.6.0\n  def after_any(val) insertion(val, 1, true) end\n\n  private\n\n  # This method performs the actual insertion\n  #\n  # @param [Object] val the value to insert\n  # @param [Fixnum] rel the relative index (0 or 1) of where the object\n  #   should be placed\n  # @param [Boolean] recursive look inside sublists\n  # @param [Array] list the list to place objects into\n  def insertion(val, rel, recursive = false, list = @list)\n    if recursive\n      list.each do |item|\n        next unless item.is_a?(Array)\n        tmp = item.dup\n        insertion(val, rel, recursive, item)\n        return(list) unless item == tmp\n      end\n    end\n\n    index = list.index(val)\n    list[index + rel, 0] = @values if index\n    list\n  end\nend",
    "comment": "Inserts the value before +val+ @param [Object] val the object the value will be inserted before @param [Boolean] recursive look inside sublists",
    "label": "",
    "id": "428"
  },
  {
    "raw_code": "def place(*values) Insertion.new(self, values) end\nend",
    "comment": "Places values before or after another object (by value) in an array. This is used in tandem with the before and after methods of the {Insertion} class.  @example Places an item before another [1, 2, 3].place(4).before(3) # => [1, 2, 4, 3] @example Places an item after another [:a, :b, :c].place(:x).after(:a) # => [:a, :x, :b, :c] @param [Array] values value to insert @return [Insertion] an insertion object to @see Insertion#before @see Insertion#after",
    "label": "",
    "id": "429"
  },
  {
    "raw_code": "def class_name\n    name.split(\"::\").last\n  end",
    "comment": "Returns the class name of a full module namespace path  @example module A::B::C; class_name end # => \"C\" @return [String] the last part of a module path",
    "label": "",
    "id": "430"
  },
  {
    "raw_code": "def self.relative_path(from, to)\n    from = expand_path(from).split(SEPARATOR)\n    to = expand_path(to).split(SEPARATOR)\n    from.length.times do\n      break if from[0] != to[0]\n      from.shift; to.shift\n    end",
    "comment": "@group Manipulating Paths Turns a path +to+ into a relative path from starting point +from+. The argument +from+ is assumed to be a filename. To treat it as a directory, make sure it ends in +File::SEPARATOR+ ('/' on UNIX filesystems).  @param [String] from the starting filename (or directory with +from_isdir+ set to +true+). @param [String] to the final path that should be made relative. @return [String] the relative path from +from+ to +to+.",
    "label": "",
    "id": "431"
  },
  {
    "raw_code": "def self.cleanpath(path, rel_root = false)\n    path = path.split(SEPARATOR)\n    path = path.inject([]) do |acc, comp|\n      next acc if comp == RELATIVE_SAMEDIR\n      if comp == RELATIVE_PARENTDIR && !acc.empty? && acc.last != RELATIVE_PARENTDIR\n        acc.pop\n        next acc\n      elsif !rel_root && comp == RELATIVE_PARENTDIR && acc.empty?\n        next acc\n      end",
    "comment": "Cleans a path by removing extraneous '..', '.' and '/' characters  @example Clean a path File.cleanpath('a/b//./c/../e') # => \"a/b/e\" @param [String] path the path to clean @param [Boolean] rel_root allows relative path above root value @return [String] the sanitized path",
    "label": "",
    "id": "432"
  },
  {
    "raw_code": "def self.open!(file, *args, &block)\n    dir = dirname(file)\n    FileUtils.mkdir_p(dir) unless directory?(dir)\n    open(file, *args, &block)\n  end",
    "comment": "@group Reading Files Forces opening a file (for writing) by first creating the file's directory @param [String] file the filename to open @since 0.5.2",
    "label": "",
    "id": "433"
  },
  {
    "raw_code": "def self.read_binary(file)\n    File.open(file, 'rb', &:read)\n  end",
    "comment": "Reads a file with binary encoding @return [String] the ascii-8bit encoded data @since 0.5.3",
    "label": "",
    "id": "434"
  },
  {
    "raw_code": "def self.run(*args) new.run(*args) end\n\n      def initialize\n        super\n        @cache = {}\n        @search_paths = []\n        add_default_paths\n        add_gem_paths\n        load_cache\n        @search_paths.uniq!\n      end\n\n      def description\n        \"A tool to view documentation in the console like `ri`\"\n      end\n\n      # Runs the command-line utility.\n      #\n      # @example\n      #   YRI.new.run('String#reverse')\n      # @param [Array<String>] args each tokenized argument\n      def run(*args)\n        optparse(*args)\n\n        if ::RbConfig::CONFIG['host_os'] =~ /mingw|win32/\n          @serializer ||= YARD::Serializers::StdoutSerializer.new\n        else\n          @serializer ||= YARD::Serializers::ProcessSerializer.new('less')\n        end\n\n        if @name.nil? || @name.strip.empty?\n          print_usage\n          return exit(1)\n        end",
    "comment": "Helper method to run the utility on an instance. @see #run",
    "label": "",
    "id": "435"
  },
  {
    "raw_code": "def print_usage\n        log.puts \"Usage: yri [options] <Path to object>\"\n        log.puts \"See yri --help for more options.\"\n      end",
    "comment": "Prints the command usage @return [void] @since 0.5.6",
    "label": "",
    "id": "436"
  },
  {
    "raw_code": "def cache_object(name, path)\n        return if path == Registry.yardoc_file\n        @cache[name] = path\n\n        File.open!(CACHE_FILE, 'w') do |file|\n          @cache.each do |key, value|\n            file.puts(\"#{key} #{value}\")\n          end",
    "comment": "Caches the .yardoc file where an object can be found in the {CACHE_FILE} @return [void]",
    "label": "",
    "id": "437"
  },
  {
    "raw_code": "def print_object(object)\n        if object.type == :method && object.is_alias?\n          tmp = P(object.namespace, (object.scope == :instance ? \"#\" : \"\") +\n            object.namespace.aliases[object].to_s)\n          object = tmp unless YARD::CodeObjects::Proxy === tmp\n        end",
    "comment": "@param [CodeObjects::Base] object the object to print. @return [String] the formatted output for an object.",
    "label": "",
    "id": "438"
  },
  {
    "raw_code": "def find_object(name)\n        @search_paths.unshift(@cache[name]) if @cache[name]\n        @search_paths.unshift(Registry.yardoc_file)\n\n        # Try to load it from in memory cache\n        log.debug \"Searching for #{name} in memory\"\n        obj = try_load_object(name, nil)\n        return obj if obj\n\n        log.debug \"Searching for #{name} in search paths\"\n        @search_paths.each do |path|\n          next unless File.exist?(path)\n          log.debug \"Searching for #{name} in #{path}...\"\n          Registry.load(path)\n          obj = try_load_object(name, path)\n          return obj if obj\n        end",
    "comment": "Locates an object by name starting in the cached paths and then searching through any search paths.  @param [String] name the full name of the object @return [CodeObjects::Base] an object if found @return [nil] if no object is found",
    "label": "",
    "id": "439"
  },
  {
    "raw_code": "def try_load_object(name, cache_path)\n        obj = Registry.at(name)\n        cache_object(name, cache_path) if obj && cache_path\n        obj\n      end",
    "comment": "Tries to load the object with name. If successful, caches the object with the cache_path  @param [String] name the object path @param [String] cache_path the location of the yardoc db containing the object to cache for future lookups. No caching is done if this is nil. @return [void]",
    "label": "",
    "id": "440"
  },
  {
    "raw_code": "def load_cache\n        return unless File.file?(CACHE_FILE)\n        File.readlines(CACHE_FILE).each do |line|\n          line = line.strip.split(/\\s+/)\n          @cache[line[0]] = line[1]\n        end",
    "comment": "Loads {CACHE_FILE} @return [void]",
    "label": "",
    "id": "441"
  },
  {
    "raw_code": "def add_gem_paths\n        require 'rubygems'\n        gem_paths = []\n        YARD::GemIndex.each do |spec|\n          yfile = Registry.yardoc_file_for_gem(spec.name)\n          next if yfile.nil?\n\n          if spec.name =~ /^yard-doc-/\n            gem_paths.unshift(yfile)\n          else\n            gem_paths.push(yfile)\n          end",
    "comment": "Adds all RubyGems yardoc files to search paths @return [void]",
    "label": "",
    "id": "442"
  },
  {
    "raw_code": "def add_default_paths\n        @search_paths.concat(DEFAULT_SEARCH_PATHS)\n        return unless File.file?(SEARCH_PATHS_FILE)\n        paths = File.readlines(SEARCH_PATHS_FILE).map(&:strip)\n        @search_paths.concat(paths)\n      end",
    "comment": "Adds paths in {SEARCH_PATHS_FILE} @since 0.5.1",
    "label": "",
    "id": "443"
  },
  {
    "raw_code": "def optparse(*args)\n        opts = OptionParser.new\n        opts.banner = \"Usage: yri [options] <Path to object>\"\n        opts.separator \"Example: yri String#gsub\"\n        opts.separator \"\"\n        opts.separator \"General Options:\"\n\n        opts.on('-b', '--db FILE', 'Use a specified .yardoc db to search in') do |yfile|\n          @search_paths.unshift(yfile)\n        end",
    "comment": "Parses commandline options. @param [Array<String>] args each tokenized argument",
    "label": "",
    "id": "444"
  },
  {
    "raw_code": "def self.run(*args) new.run(*args) end\n\n      def initialize\n        log.show_backtraces = false\n      end\n\n      # Runs the {Command} object matching the command name of the first\n      # argument.\n      # @return [void]\n      def run(*args)\n        unless args == ['--help']\n          if args.empty? || args.first =~ /^-/\n            command_name = self.class.default_command\n          else\n            command_name = args.first.to_sym\n            args.shift\n          end\n          if commands.key?(command_name)\n            return commands[command_name].run(*args)\n          end",
    "comment": "Convenience method to create a new CommandParser and call {#run} @return (see #run)",
    "label": "",
    "id": "445"
  },
  {
    "raw_code": "def initialize\n        super\n        @options_file = DEFAULT_YARDOPTS_FILE\n        @use_yardopts_file = true\n        @use_document_file = true\n      end",
    "comment": "Creates a new command that reads .yardopts",
    "label": "",
    "id": "446"
  },
  {
    "raw_code": "def parse_arguments(*args)\n        parse_yardopts_options(*args)\n\n        # Parse files and then command line arguments\n        parse_rdoc_document_file\n        parse_yardopts\n        optparse(*args)\n      end",
    "comment": "Parses commandline arguments @param [Array<String>] args the list of arguments @return [Boolean] whether or not arguments are valid @since 0.5.6",
    "label": "",
    "id": "447"
  },
  {
    "raw_code": "def yardopts_options(opts)\n        opts.on('--[no-]yardopts [FILE]',\n                \"If arguments should be read from FILE\",\n                \"  (defaults to yes, FILE defaults to .yardopts)\") do |use_yardopts|\n          if use_yardopts.is_a?(String)\n            self.options_file = use_yardopts\n            self.use_yardopts_file = true\n          else\n            self.use_yardopts_file = (use_yardopts != false)\n          end",
    "comment": "Adds --[no-]yardopts / --[no-]document",
    "label": "",
    "id": "448"
  },
  {
    "raw_code": "def yardopts(file = options_file)\n        return [] unless use_yardopts_file\n        File.read_binary(file).shell_split\n      rescue Errno::ENOENT\n        []\n      end",
    "comment": "Parses the .yardopts file for default yard options @return [Array<String>] an array of options parsed from .yardopts",
    "label": "",
    "id": "449"
  },
  {
    "raw_code": "def parse_yardopts_options(*args)\n        opts = OptionParser.new\n        opts.base.long.clear # HACK: why are --help and --version defined?\n        yardopts_options(opts)\n        begin\n          opts.parse(args)\n        rescue OptionParser::ParseError => err\n          idx = args.index(err.args.first)\n          args = args[(idx + 1)..-1]\n          args.shift while args.first && args.first[0, 1] != '-'\n          retry\n        end",
    "comment": "Parses out the yardopts/document options",
    "label": "",
    "id": "450"
  },
  {
    "raw_code": "def support_rdoc_document_file!(file = '.document')\n        return [] unless use_document_file\n        File.read(file).gsub(/^[ \\t]*#.+/m, '').split(/\\s+/)\n      rescue Errno::ENOENT\n        []\n      end",
    "comment": "Reads a .document file in the directory to get source file globs @return [Array<String>] an array of files parsed from .document",
    "label": "",
    "id": "451"
  },
  {
    "raw_code": "def initialize\n        super\n        @use_document_file = false\n        @options = GraphOptions.new\n        options.reset_defaults\n        options.serializer = YARD::Serializers::StdoutSerializer.new\n      end",
    "comment": "Creates a new instance of the command-line utility",
    "label": "",
    "id": "452"
  },
  {
    "raw_code": "def run(*args)\n        parse_arguments(*args)\n\n        contents = objects.map do |o|\n          o.format(options.merge(:serialize => false))\n        end.join(\"\\n\")\n        opts = {:type => :layout, :contents => contents}\n        options.update(opts)\n        Templates::Engine.render(options)\n      end",
    "comment": "Runs the command-line utility.  @example grapher = Graph.new grapher.run('--private') @param [Array<String>] args each tokenized argument",
    "label": "",
    "id": "453"
  },
  {
    "raw_code": "def self.run(*args) new.run(*args) end\n\n      def description; '' end\n\n      protected\n\n      # Adds a set of common options to the tail of the OptionParser\n      #\n      # @param [OptionParser] opts the option parser object\n      # @return [void]\n      def common_options(opts)\n        opts.separator \"\"\n        opts.separator \"Other options:\"\n        opts.on('-e', '--load FILE', 'A Ruby script to load before running command.') do |file|\n          load_script(file)\n        end\n        opts.on('--plugin PLUGIN', 'Load a YARD plugin (gem with `yard-\\' prefix)') do |name|\n          # Not actually necessary to load here, this is done at boot in YARD::Config.load_plugins\n          # YARD::Config.load_plugin(name)\n        end\n        opts.on('--legacy', 'Use old style Ruby parser and handlers. ',\n                            '  Always on in 1.8.x.') do\n          YARD::Parser::SourceParser.parser_type = :ruby18\n        end",
    "comment": "Helper method to run the utility on an instance. @see #run",
    "label": "",
    "id": "454"
  },
  {
    "raw_code": "def parse_options(opts, args)\n        opts.parse!(args)\n      rescue OptionParser::ParseError => err\n        unrecognized_option(err)\n        args.shift if args.first && args.first[0, 1] != '-'\n        retry\n      end",
    "comment": "Parses the option and gracefully handles invalid switches  @param [OptionParser] opts the option parser object @param [Array<String>] args the arguments passed from input. This array will be modified. @return [void]",
    "label": "",
    "id": "455"
  },
  {
    "raw_code": "def load_script(file)\n        return if YARD::Config.options[:safe_mode]\n        load(file)\n      rescue LoadError => load_exception\n        log.error \"The file `#{file}' could not be loaded:\\n#{load_exception}\"\n        exit 1\n      end",
    "comment": "Loads a Ruby script. If <tt>Config.options[:safe_mode]</tt> is enabled, this method will do nothing.  @param [String] file the path to the script to load @since 0.6.2",
    "label": "",
    "id": "456"
  },
  {
    "raw_code": "def unrecognized_option(err)\n        log.warn \"Unrecognized/#{err.message}\"\n      end",
    "comment": "Callback when an unrecognize option is parsed  @param [OptionParser::ParseError] err the exception raised by the option parser",
    "label": "",
    "id": "457"
  },
  {
    "raw_code": "def optparse(*args)\n        opts = OptionParser.new\n        opts.banner = 'Usage: yard gems [options] [gem_name [version]]'\n        opts.separator \"\"\n        opts.separator \"#{description}. If no gem_name is given,\"\n        opts.separator \"all gems are built.\"\n        opts.separator \"\"\n        opts.on('--rebuild', 'Rebuilds index') do\n          @rebuild = true\n        end",
    "comment": "Parses options",
    "label": "",
    "id": "458"
  },
  {
    "raw_code": "def initialize(parse = true)\n        super()\n        @parse = parse\n        @undoc_list = nil\n        @compact = false\n      end",
    "comment": "@param [Boolean] parse whether to parse and load registry (see {#parse})",
    "label": "",
    "id": "459"
  },
  {
    "raw_code": "def run(*args)\n        parse_arguments(*args)\n\n        if use_cache\n          Registry.load!\n        elsif parse\n          YARD.parse(files, excluded)\n          Registry.save(use_cache) if save_yardoc\n        end",
    "comment": "Runs the commandline utility, parsing arguments and generating output if set.  @param [Array<String>] args the list of arguments @return [void]",
    "label": "",
    "id": "460"
  },
  {
    "raw_code": "def print_statistics\n        @total = 0\n        @undocumented = 0\n        meths = methods.map(&:to_s).grep(/^stats_for_/)\n        STATS_ORDER.each do |meth|\n          mname = \"stats_for_#{meth}\"\n          if meths.include?(mname)\n            send(mname)\n            meths.delete(mname)\n          end",
    "comment": "Prints statistics for different object types  To add statistics for a specific type, add a method +#stats_for_TYPE+ to this class that calls {#output}.",
    "label": "",
    "id": "461"
  },
  {
    "raw_code": "def print_undocumented_objects\n        return if !@undoc_list || @undoc_list.empty?\n        log.puts\n        log.puts \"Undocumented Objects:\"\n\n        # array needed for sort due to unstable sort\n        objects = @undoc_list.sort_by {|o| [o.file.to_s, o.path] }\n        max = objects.max {|a, b| a.path.length <=> b.path.length }.path.length\n        if @compact\n          objects.each do |object|\n            log.puts(\"%-#{max}s     (%s)\" % [object.path,\n              [object.file || \"-unknown-\", object.line].compact.join(\":\")])\n          end",
    "comment": "Prints list of undocumented objects",
    "label": "",
    "id": "462"
  },
  {
    "raw_code": "def all_objects\n        @all_objects ||= run_verifier Registry.all\n      end",
    "comment": "@return [Array<CodeObjects::Base>] all the parsed objects in the registry, removing any objects that are not visible (private, protected) depending on the arguments passed to the command.",
    "label": "",
    "id": "463"
  },
  {
    "raw_code": "def stats_for_files\n        files = []\n        all_objects.each {|o| files |= [o.file] }\n        output \"Files\", files.size\n      end",
    "comment": "Statistics for files",
    "label": "",
    "id": "464"
  },
  {
    "raw_code": "def stats_for_modules\n        output \"Modules\", *type_statistics(:module)\n      end",
    "comment": "Statistics for modules",
    "label": "",
    "id": "465"
  },
  {
    "raw_code": "def stats_for_classes\n        output \"Classes\", *type_statistics(:class)\n      end",
    "comment": "Statistics for classes",
    "label": "",
    "id": "466"
  },
  {
    "raw_code": "def stats_for_constants\n        output \"Constants\", *type_statistics(:constant)\n      end",
    "comment": "Statistics for constants",
    "label": "",
    "id": "467"
  },
  {
    "raw_code": "def stats_for_attributes\n        objs = all_objects.select {|m| m.type == :method && m.is_attribute? }\n        objs.uniq! {|m| m.name.to_s.gsub(/=$/, '') }\n        undoc = objs.select {|m| m.docstring.blank? }\n        @undoc_list |= undoc if @undoc_list\n        output \"Attributes\", objs.size, undoc.size\n      end",
    "comment": "Statistics for attributes",
    "label": "",
    "id": "468"
  },
  {
    "raw_code": "def stats_for_methods\n        objs = all_objects.select {|m| m.type == :method }\n        objs.reject!(&:is_alias?)\n        objs.reject!(&:is_attribute?)\n        undoc = objs.select {|m| m.docstring.blank? }\n        @undoc_list |= undoc if @undoc_list\n        output \"Methods\", objs.size, undoc.size\n      end",
    "comment": "Statistics for methods",
    "label": "",
    "id": "469"
  },
  {
    "raw_code": "def output(name, data, undoc = nil)\n        @total += data if data.is_a?(Integer) && undoc\n        @undocumented += undoc if undoc.is_a?(Integer)\n        data =\n          if undoc\n            (\"%5s (% 5d undocumented)\" % [data, undoc])\n          else\n            \"%5s\" % data\n          end",
    "comment": "Prints a statistic to standard out. This method is optimized for getting Integer values, though it allows any data to be printed.  @param [String] name the statistic name @param [Integer, String] data the numeric (or any) data representing the statistic. If +data+ is an Integer, it should represent the total objects of a type. @param [Integer, nil] undoc number of undocumented objects for the type @return [void]",
    "label": "",
    "id": "470"
  },
  {
    "raw_code": "def optparse(*args)\n        opts = OptionParser.new\n        opts.banner = \"Usage: yard stats [options] [source_files]\"\n\n        opts.separator \"(if a list of source files is omitted, lib/**/*.rb ext/**/*.{c,rb} is used.)\"\n\n        general_options(opts)\n        output_options(opts)\n        tag_options(opts)\n        common_options(opts)\n        parse_options(opts, args)\n        parse_files(*args) unless args.empty?\n      end",
    "comment": "Parses commandline options. @param [Array<String>] args each tokenized argument",
    "label": "",
    "id": "471"
  },
  {
    "raw_code": "def initialize\n        super\n        @options = YardocOptions.new\n        @options.reset_defaults\n        @visibilities = [:public]\n        @apis = []\n        @hidden_apis = []\n        @assets = {}\n        @excluded = []\n        @files = []\n        @hidden_tags = []\n        @use_cache = false\n        @generate = true\n        @statistics = true\n        @list = false\n        @save_yardoc = true\n        @has_markup = false\n        @fail_on_warning = false\n\n        if defined?(::Encoding) && ::Encoding.respond_to?(:default_external=)\n          utf8 = ::Encoding.find('utf-8')\n\n          ::Encoding.default_external = utf8 unless ::Encoding.default_external == utf8\n          ::Encoding.default_internal = utf8 unless ::Encoding.default_internal == utf8\n        end",
    "comment": "Creates a new instance of the commandline utility",
    "label": "",
    "id": "472"
  },
  {
    "raw_code": "def run(*args)\n        log.show_progress = true\n        if args.empty? || !args.first.nil?\n          # fail early if arguments are not valid\n          return unless parse_arguments(*args)\n        end",
    "comment": "Runs the commandline utility, parsing arguments and generating output if set.  @param [Array<String>] args the list of arguments. If the list only contains a single nil value, skip calling of {#parse_arguments} @return [void]",
    "label": "",
    "id": "473"
  },
  {
    "raw_code": "def parse_arguments(*args)\n        super(*args)\n\n        # Last minute modifications\n        self.files = Parser::SourceParser::DEFAULT_PATH_GLOB if files.empty?\n        files.delete_if {|x| x =~ /\\A\\s*\\Z/ } # remove empty ones\n        readme = Dir.glob('README{,*[^~]}').\n          select {|f| extra_file_valid?(f)}.\n          sort_by {|r| [r.count('.'), r.index('.'), r] }.first\n        readme ||= Dir.glob(files.first).first if options.onefile && !files.empty?\n        options.readme ||= CodeObjects::ExtraFileObject.new(readme) if readme && extra_file_valid?(readme)\n        options.files.unshift(options.readme).uniq! if options.readme\n\n        Tags::Library.visible_tags -= hidden_tags\n        add_visibility_verifier\n        add_api_verifier\n\n        apply_locale\n\n        # US-ASCII is invalid encoding for onefile\n        if defined?(::Encoding) && options.onefile\n          if ::Encoding.default_internal == ::Encoding::US_ASCII\n            log.warn \"--one-file is not compatible with US-ASCII encoding, using ASCII-8BIT\"\n            ::Encoding.default_external, ::Encoding.default_internal = ['ascii-8bit'] * 2\n          end",
    "comment": "Parses commandline arguments @param [Array<String>] args the list of arguments @return [Boolean] whether or not arguments are valid @since 0.5.6",
    "label": "",
    "id": "474"
  },
  {
    "raw_code": "def all_objects\n        Registry.all(:root, :module, :class)\n      end",
    "comment": "The list of all objects to process. Override this method to change which objects YARD should generate documentation for.  @deprecated To hide methods use the +@private+ tag instead. @return [Array<CodeObjects::Base>] a list of code objects to process",
    "label": "",
    "id": "475"
  },
  {
    "raw_code": "def run_generate(checksums)\n        if checksums\n          changed_files = []\n          Registry.checksums.each do |file, hash|\n            changed_files << file if checksums[file] != hash\n          end",
    "comment": "Generates output for objects @param [Hash, nil] checksums if supplied, a list of checksums for files. @return [void] @since 0.5.1",
    "label": "",
    "id": "476"
  },
  {
    "raw_code": "def verify_markup_options\n        result = false\n        lvl = has_markup ? log.level : Logger::FATAL\n        obj = Struct.new(:options).new(options)\n        obj.extend(Templates::Helpers::MarkupHelper)\n        options.files.each do |file|\n          markup = file.attributes[:markup] || obj.markup_for_file('', file.filename)\n          result = obj.load_markup_provider(markup)\n          return false if !result && markup != :rdoc\n        end",
    "comment": "Verifies that the markup options are valid before parsing any code. Failing early is better than failing late.  @return (see YARD::Templates::Helpers::MarkupHelper#load_markup_provider)",
    "label": "",
    "id": "477"
  },
  {
    "raw_code": "def copy_assets\n        return unless options.serializer\n        outpath = options.serializer.basepath\n        assets.each do |from, to|\n          to = File.join(outpath, to)\n          log.debug \"Copying asset '#{from}' to '#{to}'\"\n          from += '/.' if File.directory?(from)\n          FileUtils.cp_r(from, to)\n        end",
    "comment": "Copies any assets to the output directory @return [void] @since 0.6.0",
    "label": "",
    "id": "478"
  },
  {
    "raw_code": "def print_list\n        Registry.load_all\n        run_verifier(Registry.all).\n          sort_by {|item| [item.file || '', item.line || 0] }.each do |item|\n          log.puts \"#{item.file}:#{item.line}: #{item.path}\"\n        end",
    "comment": "Prints a list of all objects @return [void] @since 0.5.5",
    "label": "",
    "id": "479"
  },
  {
    "raw_code": "def add_extra_files(*files)\n        files.map! {|f| f.include?(\"*\") ? Dir.glob(f) : f }.flatten!\n        files.each do |file|\n          if extra_file_valid?(file)\n            options.files << CodeObjects::ExtraFileObject.new(file)\n          end",
    "comment": "Adds a set of extra documentation files to be processed @param [Array<String>] files the set of documentation files",
    "label": "",
    "id": "480"
  },
  {
    "raw_code": "def extra_file_valid?(file, check_exists = true)\n        if file =~ %r{^(?:\\.\\./|/)}\n          log.warn \"Invalid file: #{file}\"\n          false\n        elsif check_exists && !File.file?(file)\n          log.warn \"Could not find file: #{file}\"\n          false\n        else\n          true\n        end",
    "comment": "@param file [String] the filename to validate @param check_exists [Boolean] whether the file should exist on disk @return [Boolean] whether the file is allowed to be used",
    "label": "",
    "id": "481"
  },
  {
    "raw_code": "def parse_files(*files)\n        seen_extra_files_marker = false\n\n        files.each do |file|\n          if file == \"-\"\n            seen_extra_files_marker = true\n            next\n          end",
    "comment": "Parses the file arguments into Ruby files and extra files, which are separated by a '-' element.  @example Parses a set of Ruby source files parse_files %w(file1 file2 file3) @example Parses a set of Ruby files with a separator and extra files parse_files %w(file1 file2 - extrafile1 extrafile2) @param [Array<String>] files the list of files to parse @return [void]",
    "label": "",
    "id": "482"
  },
  {
    "raw_code": "def add_visibility_verifier\n        vis_expr = \"#{visibilities.uniq.inspect}.include?(object.visibility)\"\n        options.verifier.add_expressions(vis_expr)\n      end",
    "comment": "Adds verifier rule for visibilities @return [void] @since 0.5.6",
    "label": "",
    "id": "483"
  },
  {
    "raw_code": "def add_api_verifier\n        no_api = true if apis.delete('')\n        exprs = []\n\n        exprs << \"#{apis.uniq.inspect}.include?(@api.text)\" unless apis.empty?\n\n        unless hidden_apis.empty?\n          exprs << \"!#{hidden_apis.uniq.inspect}.include?(@api.text)\"\n        end",
    "comment": "Adds verifier rule for APIs @return [void] @since 0.8.1",
    "label": "",
    "id": "484"
  },
  {
    "raw_code": "def apply_locale\n        YARD::I18n::Locale.default = options.locale\n        options.files.each do |file|\n          file.locale = options.locale\n        end",
    "comment": "Applies the specified locale to collected objects @return [void] @since 0.8.3",
    "label": "",
    "id": "485"
  },
  {
    "raw_code": "def run_verifier(list)\n        options.verifier ? options.verifier.run(list) : list\n      end",
    "comment": "(see Templates::Helpers::BaseHelper#run_verifier)",
    "label": "",
    "id": "486"
  },
  {
    "raw_code": "def add_tag(tag_data, factory_method = nil)\n        tag, title = *tag_data.split(':')\n        title ||= tag.capitalize\n        Tags::Library.define_tag(title, tag.to_sym, factory_method)\n        Tags::Library.visible_tags |= [tag.to_sym]\n      end",
    "comment": "@since 0.6.0",
    "label": "",
    "id": "487"
  },
  {
    "raw_code": "def optparse(*args)\n        opts = OptionParser.new\n        opts.banner = \"Usage: yard doc [options] [source_files [- extra_files]]\"\n\n        opts.separator \"(if a list of source files is omitted, \"\n        opts.separator \"  {lib,app}/**/*.rb ext/**/*.{c,rb} is used.)\"\n        opts.separator \"\"\n        opts.separator \"Example: yardoc -o documentation/ - FAQ LICENSE\"\n        opts.separator \"  The above example outputs documentation for files in\"\n        opts.separator \"  lib/**/*.rb to documentation/ including the extra files\"\n        opts.separator \"  FAQ and LICENSE.\"\n        opts.separator \"\"\n        opts.separator \"A base set of options can be specified by adding a .yardopts\"\n        opts.separator \"file to your base path containing all extra options separated\"\n        opts.separator \"by whitespace.\"\n\n        general_options(opts)\n        output_options(opts)\n        tag_options(opts)\n        common_options(opts)\n        parse_options(opts, args)\n        parse_files(*args) unless args.empty?\n      end",
    "comment": "Parses commandline options. @param [Array<String>] args each tokenized argument",
    "label": "",
    "id": "488"
  },
  {
    "raw_code": "def general_options(opts)\n        opts.separator \"\"\n        opts.separator \"General Options:\"\n\n        opts.on('-b', '--db FILE', 'Use a specified .yardoc db to load from or save to',\n                      '  (defaults to .yardoc)') do |yfile|\n          YARD::Registry.yardoc_file = yfile\n        end",
    "comment": "Adds general options",
    "label": "",
    "id": "489"
  },
  {
    "raw_code": "def output_options(opts)\n        opts.separator \"\"\n        opts.separator \"Output options:\"\n\n        opts.on('--one-file', 'Generates output as a single file') do\n          options.onefile = true\n        end",
    "comment": "Adds output options",
    "label": "",
    "id": "490"
  },
  {
    "raw_code": "def tag_options(opts)\n        opts.separator \"\"\n        opts.separator \"Tag options: (TAG:TITLE looks like: 'overload:Overloaded Method')\"\n\n        opts.on('--tag TAG:TITLE', 'Registers a new free-form metadata @tag') do |tag|\n          add_tag(tag)\n        end",
    "comment": "Adds tag options @since 0.6.0",
    "label": "",
    "id": "491"
  },
  {
    "raw_code": "def initialize\n        super\n        self.scripts = []\n        self.template_paths = []\n        self.libraries = {}\n        self.options = SymbolHash.new(false).update(\n          :single_library => true,\n          :caching => false\n        )\n        self.server_options = {:Port => 8808}\n      end",
    "comment": "Creates a new instance of the Server command line utility",
    "label": "",
    "id": "492"
  },
  {
    "raw_code": "def create_library_version_if_yardopts_exist(library, dir)\n        if dir\n          options_file = File.join(dir, Yardoc::DEFAULT_YARDOPTS_FILE)\n          if File.exist?(options_file)\n            # Found yardopts, extract db path\n            yfile = extract_db_from_options_file(options_file)\n            db = File.expand_path(yfile, dir)\n\n            # Create libver\n            libver = YARD::Server::LibraryVersion.new(library, nil, db)\n            libver.source_path = dir\n            libver\n          end",
    "comment": "@param [String] library The library name. @param [String, nil] dir The argument provided on the CLI after the library name. Is supposed to point to either a project directory with a Yard options file, or a yardoc db. @return [LibraryVersion, nil]",
    "label": "",
    "id": "493"
  },
  {
    "raw_code": "def initialize(namespace, name, scope = :instance, &block)\n      @module_function = false\n      @scope = nil\n\n      # handle module function\n      if scope == :module\n        other = self.class.new(namespace, name, &block)\n        other.visibility = :private\n        scope = :class\n        @module_function = true\n      end",
    "comment": "Creates a new method object in +namespace+ with +name+ and an instance or class +scope+  If scope is +:module+, this object is instantiated as a public method in +:class+ scope, but also creates a new (empty) method as a private +:instance+ method on the same class or module.  @param [NamespaceObject] namespace the namespace @param [String, Symbol] name the method name @param [Symbol] scope +:instance+, +:class+, or +:module+",
    "label": "",
    "id": "494"
  },
  {
    "raw_code": "def scope=(v)\n      reregister = @scope ? true : false\n\n      # handle module function\n      if v == :module\n        other = self.class.new(namespace, name)\n        other.visibility = :private\n        @visibility = :public\n        @module_function = true\n        @path = nil\n      end",
    "comment": "Changes the scope of an object from :instance or :class @param [Symbol] v the new scope",
    "label": "",
    "id": "495"
  },
  {
    "raw_code": "def constructor?\n      name == :initialize && scope == :instance && namespace.is_a?(ClassObject)\n    end",
    "comment": "@return whether or not the method is the #initialize constructor method",
    "label": "",
    "id": "496"
  },
  {
    "raw_code": "def module_function?\n      @module_function\n    end",
    "comment": "@return [Boolean] whether or not this method was created as a module function @since 0.8.0",
    "label": "",
    "id": "497"
  },
  {
    "raw_code": "def attr_info\n      return nil unless namespace.is_a?(NamespaceObject)\n      namespace.attributes[scope][name.to_s.gsub(/=$/, '')]\n    end",
    "comment": "Returns the read/writer info for the attribute if it is one @return [SymbolHash] if there is information about the attribute @return [nil] if the method is not an attribute @since 0.5.3",
    "label": "",
    "id": "498"
  },
  {
    "raw_code": "def writer?\n      info = attr_info\n      info && info[:write] == self ? true : false\n    end",
    "comment": "@return [Boolean] whether the method is a writer attribute @since 0.5.3",
    "label": "",
    "id": "499"
  },
  {
    "raw_code": "def reader?\n      info = attr_info\n      info && info[:read] == self ? true : false\n    end",
    "comment": "@return [Boolean] whether the method is a reader attribute @since 0.5.3",
    "label": "",
    "id": "500"
  },
  {
    "raw_code": "def is_attribute?\n      info = attr_info\n      if info\n        read_or_write = name.to_s =~ /=$/ ? :write : :read\n        info[read_or_write] ? true : false\n      else\n        false\n      end",
    "comment": "Tests if the object is defined as an attribute in the namespace @return [Boolean] whether the object is an attribute",
    "label": "",
    "id": "501"
  },
  {
    "raw_code": "def is_alias?\n      return false unless namespace.is_a?(NamespaceObject)\n      namespace.aliases.key? self\n    end",
    "comment": "Tests if the object is defined as an alias of another method @return [Boolean] whether the object is an alias",
    "label": "",
    "id": "502"
  },
  {
    "raw_code": "def is_explicit?\n      explicit ? true : false\n    end",
    "comment": "Tests boolean {#explicit} value.  @return [Boolean] whether the method is explicitly defined in source",
    "label": "",
    "id": "503"
  },
  {
    "raw_code": "def overridden_method\n      return nil if namespace.is_a?(Proxy)\n      meths = namespace.meths(:all => true)\n      meths.find {|m| m.path != path && m.name == name && m.scope == scope }\n    end",
    "comment": "@return [MethodObject] the object that this method overrides @return [nil] if it does not override a method @since 0.6.0",
    "label": "",
    "id": "504"
  },
  {
    "raw_code": "def aliases\n      list = []\n      return list unless namespace.is_a?(NamespaceObject)\n      namespace.aliases.each do |o, aname|\n        list << o if aname == name && o.scope == scope\n      end",
    "comment": "Returns all alias names of the object @return [Array<MethodObject>] the alias names",
    "label": "",
    "id": "505"
  },
  {
    "raw_code": "def path\n      @path ||= !namespace || namespace.path == \"\" ? sep + super : super\n    end",
    "comment": "Override path handling for instance methods in the root namespace (they should still have a separator as a prefix). @return [String] the path of a method",
    "label": "",
    "id": "506"
  },
  {
    "raw_code": "def name(prefix = false)\n      prefix ? (sep == ISEP ? \"#{sep}#{super}\" : super.to_s) : super\n    end",
    "comment": "Returns the name of the object.  @example The name of an instance method (with prefix) an_instance_method.name(true) # => \"#mymethod\" @example The name of a class method (with prefix) a_class_method.name(true) # => \"mymethod\" @param [Boolean] prefix whether or not to show the prefix @return [String] returns {#sep} + +name+ for an instance method if prefix is true @return [Symbol] the name without {#sep} if prefix is set to false",
    "label": "",
    "id": "507"
  },
  {
    "raw_code": "def sep\n      if scope == :class\n        namespace && namespace != YARD::Registry.root ? CSEP : NSEP\n      else\n        ISEP\n      end",
    "comment": "Override separator to differentiate between class and instance methods. @return [String] \"#\" for an instance method, \".\" for class",
    "label": "",
    "id": "508"
  },
  {
    "raw_code": "def initialize(owner = Registry.root)\n        @owner = owner\n      end",
    "comment": "Creates a new object list associated with a namespace  @param [NamespaceObject] owner the namespace the list should be associated with @return [CodeObjectList]",
    "label": "",
    "id": "509"
  },
  {
    "raw_code": "def push(value)\n        value = Proxy.new(@owner, value) if value.is_a?(String) || value.is_a?(Symbol)\n        if value.is_a?(CodeObjects::Base) || value.is_a?(Proxy)\n          super(value) unless include?(value)\n        else\n          raise ArgumentError, \"#{value.class} is not a valid CodeObject\"\n        end",
    "comment": "Adds a new value to the list  @param [Base] value a code object to add @return [CodeObjectList] self",
    "label": "",
    "id": "510"
  },
  {
    "raw_code": "def ===(other)\n          other.is_a?(self)\n        end",
    "comment": "Compares the class with subclasses  @param [Object] other the other object to compare classes with @return [Boolean] true if other is a subclass of self",
    "label": "",
    "id": "511"
  },
  {
    "raw_code": "def initialize(namespace, name, *)\n        if namespace && namespace != :root &&\n           !namespace.is_a?(NamespaceObject) && !namespace.is_a?(Proxy)\n          raise ArgumentError, \"Invalid namespace object: #{namespace}\"\n        end",
    "comment": "Creates a new code object  @example Create a method in the root namespace CodeObjects::Base.new(:root, '#method') # => #<yardoc method #method> @example Create class Z inside namespace X::Y CodeObjects::Base.new(P(\"X::Y\"), :Z) # or CodeObjects::Base.new(Registry.root, \"X::Y\") @param [NamespaceObject, :root, nil] namespace the namespace the object belongs in, {Registry.root} or :root should be provided if it is associated with the top level namespace. @param [Symbol, String] name the name (or complex path) of the object. @yield [self] a block to perform any extra initialization on the object @yieldparam [Base] self the newly initialized code object @return [Base] the newly created object",
    "label": "",
    "id": "512"
  },
  {
    "raw_code": "def copy_to(other)\n        copyable_attributes.each do |ivar|\n          ivar = \"@#{ivar}\"\n          other.instance_variable_set(ivar, instance_variable_get(ivar))\n        end",
    "comment": "Copies all data in this object to another code object, except for uniquely identifying information (path, namespace, name, scope).  @param [Base] other the object to copy data to @return [Base] the other object @since 0.8.0",
    "label": "",
    "id": "513"
  },
  {
    "raw_code": "def name(prefix = false)\n        prefix ? @name.to_s : (defined?(@name) && @name)\n      end",
    "comment": "The name of the object @param [Boolean] prefix whether to show a prefix. Implement this in a subclass to define how the prefix is showed. @return [Symbol] if prefix is false, the symbolized name @return [String] if prefix is true, prefix + the name as a String. This must be implemented by the subclass.",
    "label": "",
    "id": "514"
  },
  {
    "raw_code": "def add_file(file, line = nil, has_comments = false)\n        raise(ArgumentError, \"file cannot be nil or empty\") if file.nil? || file == ''\n        obj = [file.to_s, line]\n        return if files.include?(obj)\n        if has_comments && !@current_file_has_comments\n          @current_file_has_comments = true\n          @files.unshift(obj)\n        else\n          @files << obj # back of the line\n        end",
    "comment": "Associates a file with a code object, optionally adding the line where it was defined. By convention, '<stdin>' should be used to associate code that comes form standard input.  @param [String] file the filename ('<stdin>' for standard input) @param [Fixnum, nil] line the line number where the object lies in the file @param [Boolean] has_comments whether or not the definition has comments associated. This will allow {#file} to return the definition where the comments were made instead of any empty definitions that might have been parsed before (module namespaces for instance).",
    "label": "",
    "id": "515"
  },
  {
    "raw_code": "def file\n        @files.first ? @files.first[0] : nil\n      end",
    "comment": "Returns the filename the object was first parsed at, taking definitions with docstrings first.  @return [String] a filename @return [nil] if there is no file associated with the object",
    "label": "",
    "id": "516"
  },
  {
    "raw_code": "def line\n        @files.first ? @files.first[1] : nil\n      end",
    "comment": "Returns the line the object was first parsed at (or nil)  @return [Fixnum] the line where the object was first defined. @return [nil] if there is no line associated with the object",
    "label": "",
    "id": "517"
  },
  {
    "raw_code": "def equal?(other)\n        if other.is_a?(Base) || other.is_a?(Proxy)\n          path == other.path\n        else\n          super\n        end",
    "comment": "Tests if another object is equal to this, including a proxy @param [Base, Proxy] other if other is a {Proxy}, tests if the paths are equal @return [Boolean] whether or not the objects are considered the same",
    "label": "",
    "id": "518"
  },
  {
    "raw_code": "def hash; path.hash end\n\n      # @return [nil] this object does not turn into an array\n      def to_ary; nil end\n\n      # Accesses a custom attribute on the object\n      # @param [#to_s] key the name of the custom attribute\n      # @return [Object, nil] the custom attribute or nil if not found.\n      # @see #[]=\n      def [](key)\n        if respond_to?(key)\n          send(key)\n        elsif instance_variable_defined?(\"@#{key}\")\n          instance_variable_get(\"@#{key}\")\n        end\n      end\n\n      # Sets a custom attribute on the object\n      # @param [#to_s] key the name of the custom attribute\n      # @param [Object] value the value to associate\n      # @return [void]\n      # @see #[]\n      def []=(key, value)\n        if respond_to?(\"#{key}=\")\n          send(\"#{key}=\", value)\n        else\n          instance_variable_set(\"@#{key}\", value)\n        end\n      end",
    "comment": "@return [Integer] the object's hash value (for equality checking)",
    "label": "",
    "id": "519"
  },
  {
    "raw_code": "def method_missing(meth, *args, &block)\n        if meth.to_s =~ /=$/\n          self[meth.to_s[0..-2]] = args.first\n        elsif instance_variable_get(\"@#{meth}\")\n          self[meth]\n        else\n          super\n        end",
    "comment": "@overload dynamic_attr_name @return the value of attribute named by the method attribute name @raise [NoMethodError] if no method or custom attribute exists by the attribute name @see #[] @overload dynamic_attr_name=(value) @param value a value to set @return +value+ @see #[]=",
    "label": "",
    "id": "520"
  },
  {
    "raw_code": "def source=(statement)\n        if statement.respond_to?(:source)\n          @source = format_source(statement.source.strip)\n        else\n          @source = format_source(statement.to_s)\n        end",
    "comment": "Attaches source code to a code object with an optional file location  @param [#source, String] statement the +Parser::Statement+ holding the source code or the raw source as a +String+ for the definition of the code object only (not the block)",
    "label": "",
    "id": "521"
  },
  {
    "raw_code": "def docstring(locale = I18n::Locale.default)\n        if locale.nil?\n          @docstring.resolve_reference\n          return @docstring\n        end",
    "comment": "The documentation string associated with the object  @param [String, I18n::Locale] locale (I18n::Locale.default) the locale of the documentation string. @return [Docstring] the documentation string",
    "label": "",
    "id": "522"
  },
  {
    "raw_code": "def docstring=(comments)\n        @docstrings.clear\n        @docstring = Docstring === comments ?\n          comments : Docstring.new(comments, self)\n      end",
    "comment": "Attaches a docstring to a code object by parsing the comments attached to the statement and filling the {#tags} and {#docstring} methods with the parsed information.  @param [String, Array<String>, Docstring] comments the comments attached to the code object to be parsed into a docstring and meta tags.",
    "label": "",
    "id": "523"
  },
  {
    "raw_code": "def type\n        obj_name = self.class.name.split('::').last\n        obj_name.gsub!(/Object$/, '')\n        obj_name.downcase!\n        obj_name.to_sym\n      end",
    "comment": "Default type is the lowercase class name without the \"Object\" suffix. Override this method to provide a custom object type  @return [Symbol] the type of code object this represents",
    "label": "",
    "id": "524"
  },
  {
    "raw_code": "def path\n        @path ||= if parent && !parent.root?\n                    [parent.path, name.to_s].join(sep)\n                  else\n                    name.to_s\n                  end",
    "comment": "Represents the unique path of the object. The default implementation joins the path of {#namespace} with {#name} via the value of {#sep}. Custom code objects should ensure that the path is unique to the code object by either overriding {#sep} or this method.  @example The path of an instance method MethodObject.new(P(\"A::B\"), :c).path # => \"A::B#c\" @return [String] the unique path of the object @see #sep",
    "label": "",
    "id": "525"
  },
  {
    "raw_code": "def title\n        path\n      end",
    "comment": "@note Override this method if your object has a special title that does not match the {#path} attribute value. This title will be used when linking or displaying the object. @return [String] the display title for an object @see 0.8.4",
    "label": "",
    "id": "526"
  },
  {
    "raw_code": "def relative_path(other)\n        other = Registry.at(other) if String === other && Registry.at(other)\n        same_parent = false\n        if other.respond_to?(:path)\n          same_parent = other.parent == parent\n          other = other.path\n        end",
    "comment": "@param [Base, String] other another code object (or object path) @return [String] the shortest relative path from this object to +other+ @since 0.5.3",
    "label": "",
    "id": "527"
  },
  {
    "raw_code": "def format(options = {})\n        options = options.merge(:object => self)\n        options = options.merge(:type => type) unless options[:type]\n        Templates::Engine.render(options)\n      end",
    "comment": "Renders the object using the {Templates::Engine templating system}.  @example Formats a class in plaintext puts P('MyClass').format @example Formats a method in html with rdoc markup puts P('MyClass#meth').format(:format => :html, :markup => :rdoc) @param [Hash] options a set of options to pass to the template @option options [Symbol] :format (:text) :html, :text or another output format @option options [Symbol] :template (:default) a specific template to use @option options [Symbol] :markup (nil) the markup type (:rdoc, :markdown, :textile) @option options [Serializers::Base] :serializer (nil) see Serializers @return [String] the rendered template @see Templates::Engine#render",
    "label": "",
    "id": "528"
  },
  {
    "raw_code": "def inspect\n        \"#<yardoc #{type} #{path}>\"\n      end",
    "comment": "Inspects the object, returning the type and path @return [String] a string describing the object",
    "label": "",
    "id": "529"
  },
  {
    "raw_code": "def namespace=(obj)\n        if @namespace\n          @namespace.children.delete(self)\n          Registry.delete(self)\n        end",
    "comment": "Sets the namespace the object is defined in.  @param [NamespaceObject, :root, nil] obj the new namespace (:root for {Registry.root}). If obj is nil, the object is unregistered from the Registry.",
    "label": "",
    "id": "530"
  },
  {
    "raw_code": "def tag(name); docstring.tag(name) end\n\n      # Gets a list of tags from the {#docstring}\n      # @see Docstring#tags\n      def tags(name = nil); docstring.tags(name) end\n\n      # Tests if the {#docstring} has a tag\n      # @see Docstring#has_tag?\n      def has_tag?(name); docstring.has_tag?(name) end\n\n      # Add tags to the {#docstring}\n      # @see Docstring#add_tag\n      # @since 0.8.4\n      def add_tag(*tags)\n        @docstrings.clear\n        @docstring.add_tag(*tags)\n      end\n\n      # @return whether or not this object is a RootObject\n      def root?; false end\n\n      # Override this method with a custom component separator. For instance,\n      # {MethodObject} implements sep as '#' or '.' (depending on if the\n      # method is instance or class respectively). {#path} depends on this\n      # value to generate the full path in the form: namespace.path + sep + name\n      #\n      # @return [String] the component that separates the namespace path\n      #   and the name (default is {NSEP})\n      def sep; NSEP end\n\n      protected\n\n      # Override this method if your code object subclass does not allow\n      # copying of certain attributes.\n      #\n      # @return [Array<String>] the list of instance variable names (without\n      #   \"@\" prefix) that should be copied when {#copy_to} is called\n      # @see #copy_to\n      # @since 0.8.0\n      def copyable_attributes\n        vars = instance_variables.map {|ivar| ivar.to_s[1..-1] }\n        vars -= %w(docstring docstrings namespace name path)\n        vars\n      end\n\n      private\n\n      # Formats source code by removing leading indentation\n      #\n      # @param [String] source the source code to format\n      # @return [String] formatted source\n      def format_source(source)\n        source = source.chomp\n        last = source.split(/\\r?\\n/).last\n        indent = last ? last[/^([ \\t]*)/, 1].length : 0\n        source.gsub(/^[ \\t]{#{indent}}/, '')\n      end\n\n      def translate_docstring(locale)\n        @docstring.resolve_reference\n        return @docstring if locale.nil?\n\n        text = I18n::Text.new(@docstring)\n        localized_text = text.translate(locale)\n        docstring = Docstring.new(localized_text, self)\n        @docstring.tags.each do |tag|\n          if tag.is_a?(Tags::Tag)\n            localized_tag = tag.clone\n            localized_tag.text = I18n::Text.new(tag.text).translate(locale)\n            docstring.add_tag(localized_tag)\n          else\n            docstring.add_tag(tag)\n          end\n        end\n        docstring\n      end\n    end\n  end\nend",
    "comment": "Gets a tag from the {#docstring} @see Docstring#tag",
    "label": "",
    "id": "531"
  },
  {
    "raw_code": "def initialize(namespace, name, *args, &block)\n      super\n\n      if is_exception?\n        self.superclass ||= \"::Exception\" unless P(namespace, name) == P(:Exception)\n      else\n        case P(namespace, name).path\n        when \"BasicObject\"\n          nil\n        when \"Object\"\n          self.superclass ||= \"::BasicObject\"\n        else\n          self.superclass ||= \"::Object\"\n        end",
    "comment": "Creates a new class object in +namespace+ with +name+  @see Base.new",
    "label": "",
    "id": "532"
  },
  {
    "raw_code": "def is_exception?\n      inheritance_tree.reverse.any? {|o| BUILTIN_EXCEPTIONS_HASH.key? o.path }\n    end",
    "comment": "Whether or not the class is a Ruby Exception  @return [Boolean] whether the object represents a Ruby exception",
    "label": "",
    "id": "533"
  },
  {
    "raw_code": "def inheritance_tree(include_mods = false)\n      list = (include_mods ? mixins(:instance, :class) : [])\n      if superclass.is_a?(Proxy) || superclass.respond_to?(:inheritance_tree)\n        list += [superclass] unless superclass == P(:Object) || superclass == P(:BasicObject)\n      end",
    "comment": "Returns the inheritance tree of the object including self.  @param [Boolean] include_mods whether or not to include mixins in the inheritance tree. @return [Array<NamespaceObject>] the list of code objects that make up the inheritance tree.",
    "label": "",
    "id": "534"
  },
  {
    "raw_code": "def meths(opts = {})\n      opts = SymbolHash[:inherited => true].update(opts)\n      list = super(opts)\n      list += inherited_meths(opts).reject do |o|\n        next(false) if opts[:all]\n        list.find {|o2| o2.name == o.name && o2.scope == o.scope }\n      end if opts[:inherited]\n      list\n    end",
    "comment": "Returns the list of methods matching the options hash. Returns all methods if hash is empty.  @param [Hash] opts the options hash to match @option opts [Boolean] :inherited (true) whether inherited methods should be included in the list @option opts [Boolean] :included (true) whether mixed in methods should be included in the list @return [Array<MethodObject>] the list of methods that matched",
    "label": "",
    "id": "535"
  },
  {
    "raw_code": "def inherited_meths(opts = {})\n      inheritance_tree[1..-1].inject([]) do |list, superclass|\n        if superclass.is_a?(Proxy)\n          list\n        else\n          list += superclass.meths(opts).reject do |o|\n            next(false) if opts[:all]\n            child(:name => o.name, :scope => o.scope) ||\n              list.find {|o2| o2.name == o.name && o2.scope == o.scope }\n          end",
    "comment": "Returns only the methods that were inherited.  @return [Array<MethodObject>] the list of inherited method objects",
    "label": "",
    "id": "536"
  },
  {
    "raw_code": "def constants(opts = {})\n      opts = SymbolHash[:inherited => true].update(opts)\n      super(opts) + (opts[:inherited] ? inherited_constants : [])\n    end",
    "comment": "Returns the list of constants matching the options hash.  @param [Hash] opts the options hash to match @option opts [Boolean] :inherited (true) whether inherited constant should be included in the list @option opts [Boolean] :included (true) whether mixed in constant should be included in the list @return [Array<ConstantObject>] the list of constant that matched",
    "label": "",
    "id": "537"
  },
  {
    "raw_code": "def inherited_constants\n      inheritance_tree[1..-1].inject([]) do |list, superclass|\n        if superclass.is_a?(Proxy)\n          list\n        else\n          list += superclass.constants.reject do |o|\n            child(:name => o.name) || list.find {|o2| o2.name == o.name }\n          end",
    "comment": "Returns only the constants that were inherited.  @return [Array<ConstantObject>] the list of inherited constant objects",
    "label": "",
    "id": "538"
  },
  {
    "raw_code": "def superclass=(object)\n      case object\n      when Base, Proxy, NilClass\n        @superclass = object\n      when String, Symbol\n        @superclass = Proxy.new(namespace, object)\n      else\n        raise ArgumentError, \"superclass must be CodeObject, Proxy, String or Symbol\"\n      end",
    "comment": "Sets the superclass of the object  @param [Base, Proxy, String, Symbol, nil] object the superclass value @return [void]",
    "label": "",
    "id": "539"
  },
  {
    "raw_code": "def inheritance_tree(include_mods = false)\n      return [self] unless include_mods\n      [self] + mixins(:instance, :class).map do |m|\n        next if m == self\n        next m unless m.respond_to?(:inheritance_tree)\n        m.inheritance_tree(true)\n      end.compact.flatten.uniq\n    end",
    "comment": "Returns the inheritance tree of mixins.  @param [Boolean] include_mods if true, will include mixed in modules (which is likely what is wanted). @return [Array<NamespaceObject>] a list of namespace objects",
    "label": "",
    "id": "540"
  },
  {
    "raw_code": "def scope; :class end\n\n    # Sets up a delegate for {MethodObject} obj.\n    #\n    # @param [MethodObject] obj the instance method to treat as a mixed in\n    #   class method on another namespace.\n    def initialize(obj) @del = obj end\n\n    # Sends all methods to the {MethodObject} assigned in {#initialize}\n    # @see #initialize\n    # @see MethodObject\n    def method_missing(sym, *args, &block) @del.__send__(sym, *args, &block) end\n  end\nend",
    "comment": "@return [Symbol] always +:class+",
    "label": "",
    "id": "541"
  },
  {
    "raw_code": "def register_separator(sep, *valid_types)\n        NamespaceMapper.invalidate\n\n        valid_types.each do |t|\n          NamespaceMapper.rev_map[t] ||= []\n          NamespaceMapper.rev_map[t] << sep\n        end",
    "comment": "@!group Registering a Separator for a Namespace Registers a separator with an optional set of valid types that must follow the separator lexically.  Calls all callbacks defined by {NamespaceMapper.on_invalidate} after the separator is registered.  @param sep [String] the separator string for the namespace @param valid_types [Array<Symbol>] a list of object types that must follow the separator. If the list is empty, any type can follow the separator. @example Registering separators for a method object # Anything after a \"#\" denotes a method object register_separator \"#\", :method # Anything after a \".\" denotes a method object register_separator \".\", :method @see .on_invalidate",
    "label": "",
    "id": "542"
  },
  {
    "raw_code": "def unregister_separator_by_type(type)\n        seps = NamespaceMapper.rev_map[type]\n        return unless seps\n        \n        seps.each {|s| NamespaceMapper.map.delete(s) }\n        NamespaceMapper.rev_map.delete(type)\n        NamespaceMapper.invalidate\n      end",
    "comment": "Unregisters a separator by a type.  @param type [Symbol] the type to unregister @see #register_separator",
    "label": "",
    "id": "543"
  },
  {
    "raw_code": "def clear_separators\n        NamespaceMapper.invalidate\n        NamespaceMapper.map = {}\n        NamespaceMapper.rev_map = {}\n      end",
    "comment": "Clears the map of separators.  @return [void]",
    "label": "",
    "id": "544"
  },
  {
    "raw_code": "def default_separator(value = nil)\n        if value\n          NamespaceMapper.invalidate\n          NamespaceMapper.default_separator = Regexp.quote value\n        else\n          NamespaceMapper.default_separator\n        end",
    "comment": "Gets or sets the default separator value to use when no separator for the namespace can be determined.  @param value [String, nil] the default separator, or nil to return the value @example default_separator \"::\"",
    "label": "",
    "id": "545"
  },
  {
    "raw_code": "def separators\n        NamespaceMapper.map.keys\n      end",
    "comment": "@!group Separator and Type Lookup Helpers @return [Array<String>] all of the registered separators",
    "label": "",
    "id": "546"
  },
  {
    "raw_code": "def separators_match\n        NamespaceMapper.map_match\n      end",
    "comment": "@return [Regexp] the regexp match of all separators",
    "label": "",
    "id": "547"
  },
  {
    "raw_code": "def types_for_separator(sep)\n        NamespaceMapper.map[sep] || []\n      end",
    "comment": "@param sep [String] the separator to return types for @return [Array<Symbol>] a list of types registered to a separator",
    "label": "",
    "id": "548"
  },
  {
    "raw_code": "def separators_for_type(type)\n        NamespaceMapper.rev_map[type] || []\n      end",
    "comment": "@param type [String] the type to return separators for @return [Array<Symbol>] a list of separators registered to a type",
    "label": "",
    "id": "549"
  },
  {
    "raw_code": "def on_invalidate(&block)\n          (@invalidation_callbacks ||= []).push(block)\n        end",
    "comment": "@!group Invalidation callbacks Adds a callback that triggers when a new separator is registered or the cache is cleared by invalidation.",
    "label": "",
    "id": "550"
  },
  {
    "raw_code": "def map\n          @map ||= {}\n        end",
    "comment": "@!visibility private @return [Hash] a mapping of types to separators",
    "label": "",
    "id": "551"
  },
  {
    "raw_code": "def rev_map\n          @rev_map ||= {}\n        end",
    "comment": "@return [Hash] a reverse mapping of separators to types",
    "label": "",
    "id": "552"
  },
  {
    "raw_code": "def invalidate\n          @map_match = nil\n          (@invalidation_callbacks || []).each(&:call)\n        end",
    "comment": "Invalidates all separators @return [void]",
    "label": "",
    "id": "553"
  },
  {
    "raw_code": "def map_match\n          @map_match ||= map.keys.map {|k| Regexp.quote k }.join('|')\n        end",
    "comment": "@return [Regexp] the full list of separators as a regexp match",
    "label": "",
    "id": "554"
  },
  {
    "raw_code": "def create(macro_name, data, method_object = nil)\n          obj = new(:root, macro_name)\n          obj.macro_data = data\n          obj.method_object = method_object\n          obj\n        end",
    "comment": "Creates a new macro and fills in the relevant properties. @param [String] macro_name the name of the macro, must be unique. @param [String] data the data the macro should expand when re-used @param [CodeObjects::Base] method_object an object to attach this macro to. If supplied, {#attached?} will be true @return [MacroObject] the newly created object",
    "label": "",
    "id": "555"
  },
  {
    "raw_code": "def find(macro_name)\n          Registry.at('.macro.' + macro_name.to_s)\n        end",
    "comment": "Finds a macro using +macro_name+ @param [#to_s] macro_name the name of the macro @return [MacroObject] if a macro is found @return [nil] if there is no registered macro by that name",
    "label": "",
    "id": "556"
  },
  {
    "raw_code": "def find_or_create(macro_name, data, method_object = nil)\n          find(name) || create(macro_name, data, method_object)\n        end",
    "comment": "Parses a given docstring and determines if the macro is \"new\" or not. If the macro has $variable names or if it has a @!macro tag with the [new] or [attached] flag, it is considered new.  If a new macro is found, the macro is created and registered. Otherwise the macro name is searched and returned. If a macro is not found, nil is returned.  @param [#to_s] macro_name the name of the macro @param [CodeObjects::Base] method_object an optional method to attach the macro to. Only used if the macro is being created, otherwise this argument is ignored. @return [MacroObject] the newly created or existing macro, depending on whether the @!macro tag was a new tag or not. @return [nil] if the +data+ has no macro tag or if the macro is not new and no macro by the macro name is found.",
    "label": "",
    "id": "557"
  },
  {
    "raw_code": "def expand(macro_data, call_params = [], full_source = '', block_source = '') # rubocop:disable Lint/UnusedMethodArgument\n          macro_data = macro_data.all if macro_data.is_a?(Docstring)\n          macro_data.gsub(MACRO_MATCH) do\n            escape = $1\n            first = $2 || $5\n            last = $4\n            rng = $3 ? true : false\n            next $&[1..-1] if escape\n            if first == '*'\n              last ? $& : full_source\n            else\n              first_i = first.to_i\n              last_i = (last ? last.to_i : call_params.size)\n              last_i = first_i unless rng\n              params = call_params[first_i..last_i]\n              params ? params.join(\", \") : ''\n            end",
    "comment": "Expands +macro_data+ using the interpolation parameters.  Interpolation rules: * $0, $1, $2, ... = the Nth parameter in +call_params+ * $* = the full statement source (excluding block) * Also supports $!{N-M} ranges, as well as negative indexes on N or M * Use \\$ to escape the variable name in a macro.  @!macro [new] macro.expand @param [Array<String>] call_params the method name and parameters to the method call. These arguments will fill \\$0-N @param [String] full_source the full source line (excluding block) interpolated as \\$* @param [String] block_source Currently unused. Will support interpolating the block data as a variable. @return [String] the expanded macro data @param [String] macro_data the macro data to expand (taken from {#macro_data})",
    "label": "",
    "id": "558"
  },
  {
    "raw_code": "def apply(docstring, call_params = [], full_source = '', block_source = '', _method_object = nil) # rubocop:disable Lint/UnusedMethodArgument\n          docstring = docstring.all if Docstring === docstring\n          parser = Docstring.parser\n          handler = OpenStruct.new\n          handler.call_params = call_params[1..-1]\n          handler.caller_method = call_params.first\n          handler.statement = OpenStruct.new(:source => full_source)\n          parser.parse(docstring, nil, handler).to_docstring.to_raw\n        end",
    "comment": "Applies a macro on a docstring by creating any macro data inside of the docstring first. Equivalent to calling {find_or_create} and {apply_macro} on the new macro object.  @param [Docstring] docstring the docstring to create a macro out of @!macro macro.expand @see find_or_create",
    "label": "",
    "id": "559"
  },
  {
    "raw_code": "def apply_macro(macro, docstring, call_params = [], full_source = '', block_source = '') # rubocop:disable Lint/UnusedMethodArgument\n          apply(docstring, call_params, full_source, block_source)\n        end",
    "comment": "Applies a macro to a docstring, interpolating the macro's data on the docstring and appending any extra local docstring data that was in the original +docstring+ object.  @param [MacroObject] macro the macro object @!macro macro.expand",
    "label": "",
    "id": "560"
  },
  {
    "raw_code": "def attached?; method_object ? true : false end\n\n      # Overrides {Base#path} so the macro path is \".macro.MACRONAME\"\n      def path; '.macro.' + name.to_s end\n\n      # Overrides the separator to be '.'\n      def sep; '.' end\n\n      # Expands the macro using\n      # @param [Array<String>] call_params a list of tokens that are passed\n      #   to the method call\n      # @param [String] full_source the full method call (not including the block)\n      # @param [String] block_source the source passed in the block of the method\n      #   call, if there is a block.\n      # @example Expanding a Macro\n      #   macro.expand(%w(property foo bar), 'property :foo, :bar', '') #=>\n      #     \"...macro data interpolating this line of code...\"\n      # @see expand\n      def expand(call_params = [], full_source = '', block_source = '')\n        self.class.expand(macro_data, call_params, full_source, block_source)\n      end\n    end\n  end\nend",
    "comment": "@return [Boolean] whether this macro is attached to a method",
    "label": "",
    "id": "561"
  },
  {
    "raw_code": "def initialize(filename, contents = nil)\n      self.filename = filename\n      self.name = File.basename(filename).gsub(/\\.[^.]+$/, '')\n      self.attributes = SymbolHash.new(false)\n      @original_contents = contents\n      @parsed = false\n      @locale = nil\n      ensure_parsed\n    end",
    "comment": "Creates a new extra file object. @param [String] filename the location on disk of the file @param [String] contents the file contents. If not set, the contents will be read from disk using the +filename+.",
    "label": "",
    "id": "562"
  },
  {
    "raw_code": "def locale=(locale)\n      @locale = locale\n      @parsed = false\n    end",
    "comment": "@param [String] locale the locale name to be translated. @return [void] @since 0.8.3",
    "label": "",
    "id": "563"
  },
  {
    "raw_code": "def initialize(namespace, name, *args, &block)\n      @children = CodeObjectList.new(self)\n      @class_mixins = CodeObjectList.new(self)\n      @instance_mixins = CodeObjectList.new(self)\n      @attributes = SymbolHash[:class => SymbolHash.new, :instance => SymbolHash.new]\n      @aliases = {}\n      @groups = []\n      super\n    end",
    "comment": "Creates a new namespace object inside +namespace+ with +name+. @see Base#initialize",
    "label": "",
    "id": "564"
  },
  {
    "raw_code": "def class_attributes\n      attributes[:class]\n    end",
    "comment": "Only the class attributes @return [Hash] a list of method names and their read/write objects @see #attributes",
    "label": "",
    "id": "565"
  },
  {
    "raw_code": "def instance_attributes\n      attributes[:instance]\n    end",
    "comment": "Only the instance attributes @return [Hash] a list of method names and their read/write objects @see #attributes",
    "label": "",
    "id": "566"
  },
  {
    "raw_code": "def child(opts = {})\n      if !opts.is_a?(Hash)\n        children.find {|o| o.name == opts.to_sym }\n      else\n        opts = SymbolHash[opts]\n        children.find do |obj|\n          opts.each do |meth, value|\n            break false unless value.is_a?(Array) ? value.include?(obj[meth]) : obj[meth] == value\n          end",
    "comment": "Looks for a child that matches the attributes specified by +opts+.  @example Finds a child by name and scope namespace.child(:name => :to_s, :scope => :instance) # => #<yardoc method MyClass#to_s> @return [Base, nil] the first matched child object, or nil",
    "label": "",
    "id": "567"
  },
  {
    "raw_code": "def meths(opts = {})\n      opts = SymbolHash[\n        :visibility => [:public, :private, :protected],\n        :scope => [:class, :instance],\n        :included => true\n      ].update(opts)\n\n      opts[:visibility] = [opts[:visibility]].flatten\n      opts[:scope] = [opts[:scope]].flatten\n\n      ourmeths = children.select do |o|\n        o.is_a?(MethodObject) &&\n          opts[:visibility].include?(o.visibility) &&\n          opts[:scope].include?(o.scope)\n      end",
    "comment": "Returns all methods that match the attributes specified by +opts+. If no options are provided, returns all methods.  @example Finds all private and protected class methods namespace.meths(:visibility => [:private, :protected], :scope => :class) # => [#<yardoc method MyClass.privmeth>, #<yardoc method MyClass.protmeth>] @option opts [Array<Symbol>, Symbol] :visibility ([:public, :private, :protected]) the visibility of the methods to list. Can be an array or single value. @option opts [Array<Symbol>, Symbol] :scope ([:class, :instance]) the scope of the methods to list. Can be an array or single value. @option opts [Boolean] :included (true) whether to include mixed in methods in the list. @return [Array<MethodObject>] a list of method objects",
    "label": "",
    "id": "568"
  },
  {
    "raw_code": "def included_meths(opts = {})\n      opts = SymbolHash[:scope => [:instance, :class]].update(opts)\n      [opts[:scope]].flatten.map do |scope|\n        mixins(scope).inject([]) do |list, mixin|\n          next list if mixin.is_a?(Proxy)\n          arr = mixin.meths(opts.merge(:scope => :instance)).reject do |o|\n            next false if opts[:all]\n            child(:name => o.name, :scope => scope) || list.find {|o2| o2.name == o.name }\n          end",
    "comment": "Returns methods included from any mixins that match the attributes specified by +opts+. If no options are specified, returns all included methods.  @option opts [Array<Symbol>, Symbol] :visibility ([:public, :private, :protected]) the visibility of the methods to list. Can be an array or single value. @option opts [Array<Symbol>, Symbol] :scope ([:class, :instance]) the scope of the methods to list. Can be an array or single value. @option opts [Boolean] :included (true) whether to include mixed in methods in the list. @see #meths",
    "label": "",
    "id": "569"
  },
  {
    "raw_code": "def constants(opts = {})\n      opts = SymbolHash[:included => true].update(opts)\n      consts = children.select {|o| o.is_a? ConstantObject }\n      consts + (opts[:included] ? included_constants : [])\n    end",
    "comment": "Returns all constants in the namespace  @option opts [Boolean] :included (true) whether or not to include mixed in constants in list @return [Array<ConstantObject>] a list of constant objects",
    "label": "",
    "id": "570"
  },
  {
    "raw_code": "def included_constants\n      instance_mixins.inject([]) do |list, mixin|\n        if mixin.respond_to? :constants\n          list += mixin.constants.reject do |o|\n            child(:name => o.name) || list.find {|o2| o2.name == o.name }\n          end",
    "comment": "Returns constants included from any mixins @return [Array<ConstantObject>] a list of constant objects",
    "label": "",
    "id": "571"
  },
  {
    "raw_code": "def cvars\n      children.select {|o| o.is_a? ClassVariableObject }\n    end",
    "comment": "Returns class variables defined in this namespace. @return [Array<ClassVariableObject>] a list of class variable objects",
    "label": "",
    "id": "572"
  },
  {
    "raw_code": "def mixins(*scopes)\n      return class_mixins if scopes == [:class]\n      return instance_mixins if scopes == [:instance]\n      class_mixins | instance_mixins\n    end",
    "comment": "Returns for specific scopes. If no scopes are provided, returns all mixins. @param [Array<Symbol>] scopes a list of scopes (:class, :instance) to return mixins for. If this is empty, all scopes will be returned. @return [Array<ModuleObject>] a list of mixins",
    "label": "",
    "id": "573"
  },
  {
    "raw_code": "def name(prefix = false)\n        prefix ? \"#{@imethod && ISEP}#{@name}\" : @name\n      end",
    "comment": "(see Base#name)",
    "label": "",
    "id": "574"
  },
  {
    "raw_code": "def inspect\n        to_obj ? to_obj.inspect : \"P(#{path})\"\n      end",
    "comment": "Returns a text representation of the Proxy @return [String] the object's #inspect method or P(OBJECTPATH)",
    "label": "",
    "id": "575"
  },
  {
    "raw_code": "def path\n        to_obj ? to_obj.path : proxy_path\n      end",
    "comment": "If the proxy resolves to an object, returns its path, otherwise guesses at the correct path using the original namespace and name.  @return [String] the assumed path of the proxy (or the real path of the resolved object)",
    "label": "",
    "id": "576"
  },
  {
    "raw_code": "def is_a?(klass)\n        to_obj ? to_obj.is_a?(klass) : self.class <= klass\n      end",
    "comment": "@return [Boolean]",
    "label": "",
    "id": "577"
  },
  {
    "raw_code": "def ===(other)\n        to_obj ? to_obj === other : self.class <= other.class\n      end",
    "comment": "@return [Boolean]",
    "label": "",
    "id": "578"
  },
  {
    "raw_code": "def <=>(other)\n        if other.respond_to? :path\n          path <=> other.path\n        else\n          false\n        end",
    "comment": "@return [Boolean]",
    "label": "",
    "id": "579"
  },
  {
    "raw_code": "def equal?(other)\n        if other.respond_to? :path\n          path == other.path\n        else\n          false\n        end",
    "comment": "@return [Boolean]",
    "label": "",
    "id": "580"
  },
  {
    "raw_code": "def hash; path.hash end\n\n      # Returns the class name of the object the proxy is mimicking, if\n      # resolved. Otherwise returns +Proxy+.\n      # @return [Class] the resolved object's class or +Proxy+\n      def class\n        to_obj ? to_obj.class : Proxy\n      end\n\n      # Returns the type of the proxy. If it cannot be resolved at the\n      # time of the call, it will either return the inferred proxy type\n      # (see {#type=}) or +:proxy+\n      # @return [Symbol] the Proxy's type\n      # @see #type=\n      def type\n        to_obj ? to_obj.type : @type || :proxy\n      end\n\n      # Allows a parser to infer the type of the proxy by its path.\n      # @param [#to_sym] type the proxy's inferred type\n      # @return [void]\n      def type=(type) @type = type ? type.to_sym : nil end\n\n      # @return [Boolean]\n      def instance_of?(klass)\n        self.class == klass\n      end\n\n      # @return [Boolean]\n      def kind_of?(klass)\n        self.class <= klass\n      end\n\n      # @return [Boolean]\n      def respond_to?(meth, include_private = false)\n        to_obj ? to_obj.respond_to?(meth, include_private) : super\n      end\n\n      # Dispatches the method to the resolved object.\n      #\n      # @raise [ProxyMethodError] if the proxy cannot find the real object\n      def method_missing(meth, *args, &block)\n        if to_obj\n          to_obj.__send__(meth, *args, &block)\n        else\n          log.warn \"Load Order / Name Resolution Problem on #{path}:\\n\" \\\n                   \"-\\n\" \\\n                   \"Something is trying to call #{meth} on object #{path} before it has been recognized.\\n\" \\\n                   \"This error usually means that you need to modify the order in which you parse files\\n\" \\\n                   \"so that #{path} is parsed before methods or other objects attempt to access it.\\n\" \\\n                   \"-\\n\" \\\n                   \"YARD will recover from this error and continue to parse but you *may* have problems\\n\" \\\n                   \"with your generated documentation. You should probably fix this.\\n\" \\\n                   \"-\\n\"\n          begin\n            super\n          rescue NoMethodError\n            raise ProxyMethodError, \"Proxy cannot call method ##{meth} on object '#{path}'\"\n          end\n        end\n      end",
    "comment": "@return [Integer] the object's hash value (for equality checking)",
    "label": "",
    "id": "581"
  },
  {
    "raw_code": "def root?; false end\n\n      private\n\n      # @note this method fixes a bug in 1.9.2: http://gist.github.com/437136\n      def to_ary; nil end\n\n      # Attempts to find the object that this unresolved object\n      # references by checking if any objects by this name are\n      # registered all the way up the namespace tree.\n      #\n      # @return [Base, nil] the registered code object or nil\n      def to_obj\n        return @obj if @obj\n        @obj = Registry.resolve(@namespace, (@imethod ? ISEP : '') + @name.to_s, false, false, @type)\n        if @obj\n          if @origname && @origname.include?(\"::\") && !@obj.path.include?(@origname)\n            # the object's path should include the original proxy namespace,\n            # otherwise it's (probably) not the right object.\n            @obj = nil\n          else\n            @namespace = @obj.namespace\n            @name = @obj.name\n          end\n        end\n        @obj\n      end",
    "comment": "This class is never a root object",
    "label": "",
    "id": "582"
  },
  {
    "raw_code": "def start\n        server_options[:ServerType] = WEBrick::Daemon if server_options[:daemonize]\n        server = WEBrick::HTTPServer.new(server_options)\n        server.mount('/', WebrickServlet, self)\n        trap(\"INT\") { server.shutdown }\n        server.start\n      end",
    "comment": "Initializes a WEBrick server. If {Adapter#server_options} contains a +:daemonize+ key set to true, the server will be daemonized.",
    "label": "",
    "id": "583"
  },
  {
    "raw_code": "def do_GET(request, response) # rubocop:disable Style/MethodName\n        status, headers, body = *adapter.router.call(request)\n        response.status = status\n        response.body = body.is_a?(Array) ? body[0] : body\n        headers.each do |key, value|\n          response[key] = value\n        end",
    "comment": "@private",
    "label": "",
    "id": "584"
  },
  {
    "raw_code": "def yardoc_file\n        @yardoc_file ||= load_yardoc_file\n      end",
    "comment": "@return [String] the location of the yardoc file used to load the object information from. @return [nil] if no yardoc file exists yet. In this case, {#prepare!} will be called on this library to build the yardoc file. @note To implement a custom yardoc file getter, implement",
    "label": "",
    "id": "585"
  },
  {
    "raw_code": "def source_path\n        @source_path ||= load_source_path\n      end",
    "comment": "@return [String] the location of the source code for a library. This value is filled by calling +#source_path_for_SOURCE+ on this class. @return [nil] if there is no source code @see LibraryVersion LibraryVersion documentation for \"Implementing a Custom Library Source\"",
    "label": "",
    "id": "586"
  },
  {
    "raw_code": "def initialize(name, version = nil, yardoc = nil, source = :disk)\n        self.name = name\n        self.yardoc_file = yardoc\n        self.version = version\n        self.source = source\n      end",
    "comment": "@param [String] name the name of the library @param [String] version the specific (usually, but not always, numeric) library version @param [String] yardoc the location of the yardoc file, or nil if it is generated later @param [Symbol] source the location of the files used to build the yardoc. Builtin source types are +:disk+ or +:gem+.",
    "label": "",
    "id": "587"
  },
  {
    "raw_code": "def to_s(url_format = true)\n        version ? \"#{name}#{url_format ? '/' : '-'}#{version}\" : name.to_s\n      end",
    "comment": "@param [Boolean] url_format if true, returns the string in a URI-compatible format (for appending to a URL). Otherwise, it is given in a more human readable format. @return [String] the string representation of the library.",
    "label": "",
    "id": "588"
  },
  {
    "raw_code": "def hash; to_s.hash end\n\n      # @return [Boolean] whether another LibraryVersion is equal to this one\n      def eql?(other)\n        other.is_a?(LibraryVersion) && other.name == name &&\n          other.version == version && other.yardoc_file == yardoc_file\n      end\n      alias == eql?\n      alias equal? eql?\n\n      # @return [Boolean] whether the library has been completely processed\n      #   and is ready to be served\n      def ready?\n        return false if yardoc_file.nil?\n        serializer.complete?\n      end\n\n      # @note You should not directly override this method. Instead, implement\n      #   +load_yardoc_from_SOURCENAME+ when implementing loading for a specific\n      #   source type. See the {LibraryVersion} documentation for \"Implementing\n      #   a Custom Library Source\"\n      #\n      # Prepares a library to be displayed by the server. This callback is\n      # performed before each request on a library to ensure that it is loaded\n      # and ready to be viewed. If any steps need to be performed prior to loading,\n      # they are performed through this method (though they should be implemented\n      # through the +load_yardoc_from_SOURCE+ method).\n      #\n      # @raise [LibraryNotPreparedError] if the library is not ready to be\n      #   displayed. Usually when raising this error, you would simultaneously\n      #   begin preparing the library for subsequent requests, although this\n      #   is not necessary.\n      def prepare!\n        return if ready?\n        meth = \"load_yardoc_from_#{source}\"\n        send(meth) if respond_to?(meth, true)\n      end\n\n      # @return [Gem::Specification] a gemspec object for a given library. Used\n      #   for :gem source types.\n      # @return [nil] if there is no installed gem for the library\n      def gemspec\n        ver = version ? \"= #{version}\" : \">= 0\"\n        YARD::GemIndex.find_all_by_name(name, ver).last\n      end\n\n      protected\n\n      @@chdir_mutex = Mutex.new\n\n      # Called when a library of source type \"disk\" is to be prepared. In this\n      # case, the {#yardoc_file} should already be set, but the library may not\n      # be prepared. Run preparation if not done.\n      #\n      # @raise [LibraryNotPreparedError] if the yardoc file has not been\n      #   prepared.\n      def load_yardoc_from_disk\n        return if ready?\n\n        @@chdir_mutex.synchronize do\n          Dir.chdir(source_path_for_disk) do\n            Thread.new do\n              CLI::Yardoc.run('--no-stats', '-n', '-b', yardoc_file)\n            end\n          end",
    "comment": "@return [Fixnum] used for Hash mapping.",
    "label": "",
    "id": "589"
  },
  {
    "raw_code": "def load_yardoc_from_gem\n        return if ready?\n        ver = version ? \"= #{version}\" : \">= 0\"\n\n        @@chdir_mutex.synchronize do\n          Thread.new do\n            # Build gem docs on demand\n            log.debug \"Building gem docs for #{to_s(false)}\"\n            CLI::Gems.run(name, ver)\n            log.debug \"Done building gem docs for #{to_s(false)}\"\n          end",
    "comment": "Called when a library of source type \"gem\" is to be prepared. In this case, the {#yardoc_file} needs to point to the correct location for the installed gem. The yardoc file is built if it has not been done.  @raise [LibraryNotPreparedError] if the gem does not have an existing yardoc file.",
    "label": "",
    "id": "590"
  },
  {
    "raw_code": "def source_path_for_disk\n        File.dirname(yardoc_file) if yardoc_file\n      end",
    "comment": "@return [String] the source path for a disk source",
    "label": "",
    "id": "591"
  },
  {
    "raw_code": "def source_path_for_gem\n        gemspec.full_gem_path if gemspec\n      end",
    "comment": "@return [String] the source path for a gem source",
    "label": "",
    "id": "592"
  },
  {
    "raw_code": "def yardoc_file_for_gem\n        require 'rubygems'\n        ver = version ? \"= #{version}\" : \">= 0\"\n        Registry.yardoc_file_for_gem(name, ver)\n      end",
    "comment": "@return [String] the yardoc file for a gem source",
    "label": "",
    "id": "593"
  },
  {
    "raw_code": "def self.setup\n        Templates::Template.extra_includes |= [YARD::Server::DocServerHelper]\n        Templates::Engine.template_paths |= [File.dirname(__FILE__) + '/templates']\n      end",
    "comment": "Performs any global initialization for the adapter. @note If you subclass this method, make sure to call +super+. @return [void]",
    "label": "",
    "id": "594"
  },
  {
    "raw_code": "def self.shutdown\n        Templates::Template.extra_includes -= [YARD::Server::DocServerHelper]\n        Templates::Engine.template_paths -= [File.dirname(__FILE__) + '/templates']\n      end",
    "comment": "Performs any global shutdown procedures for the adapter. @note If you subclass this method, make sure to call +super+. @return [void]",
    "label": "",
    "id": "595"
  },
  {
    "raw_code": "def initialize(libs, opts = {}, server_opts = {})\n        self.class.setup\n        self.libraries = libs\n        self.options = opts\n        self.server_options = server_opts\n        self.document_root = server_options[:DocumentRoot]\n        self.router = (options[:router] || Router).new(self)\n        options[:adapter] = self\n        log.debug \"Serving libraries using #{self.class}: #{libraries.keys.join(', ')}\"\n        log.debug \"Caching on\" if options[:caching]\n        log.debug \"Document root: #{document_root}\" if document_root\n      end",
    "comment": "Creates a new adapter object  @param [Hash{String=>Array<LibraryVersion>}] libs a list of libraries, see {#libraries} for formulating this list. @param [Hash] opts extra options to pass to the adapter @option opts [Class] :router (Router) the router class to initialize as the adapter's router. @option opts [Boolean] :caching (false) whether or not caching is enabled @option opts [Boolean] :single_library (false) whether to server documentation for a single or multiple libraries (changes URL structure)",
    "label": "",
    "id": "596"
  },
  {
    "raw_code": "def add_library(library)\n        libraries[library.name] ||= []\n        libraries[library.name] |= [library]\n      end",
    "comment": "Adds a library to the {#libraries} mapping for a given library object. @example Adding a new library to an adapter adapter.add_library LibraryVersion.new('mylib', '1.0', '/path/to/.yardoc') @param [LibraryVersion] library a library to add",
    "label": "",
    "id": "597"
  },
  {
    "raw_code": "def start\n        raise NotImplementedError\n      end",
    "comment": "Implement this method to connect your adapter to your server. @abstract",
    "label": "",
    "id": "598"
  },
  {
    "raw_code": "def check_static_cache\n        return nil unless adapter.document_root\n        cache_path = File.join(adapter.document_root, request.path.sub(/\\.html$/, '') + '.html')\n        cache_path = cache_path.sub(%r{/\\.html$}, '.html')\n        if File.file?(cache_path)\n          log.debug \"Loading cache from disk: #{cache_path}\"\n          return [200, {'Content-Type' => 'text/html'}, [File.read_binary(cache_path)]]\n        end",
    "comment": "Called by a router to return the cached object. By default, this method performs disk-based caching. To perform other forms of caching, implement your own +#check_static_cache+ method and mix the module into the Router class.  Note that caching does not occur here. This method simply checks for the existence of cached data. To actually cache a response, see {Commands::Base#cache}.  @example Implementing In-Memory Cache Checking module MemoryCaching def check_static_cache # $memory_cache is filled by {Commands::Base#cache} cached_data = $memory_cache[request.path] if cached_data [200, {'Content-Type' => 'text/html'}, [cached_data]] else nil end end end  class YARD::Server::Router; include MemoryCaching; end @return [Array(Numeric,Hash,Array)] the Rack-style response @return [nil] if no cache is available and routing should continue @see Commands::Base#cache",
    "label": "",
    "id": "599"
  },
  {
    "raw_code": "def initialize(adapter)\n        self.adapter = adapter\n      end",
    "comment": "Creates a new router for a specific adapter  @param [Adapter] adapter the adapter to route requests to",
    "label": "",
    "id": "600"
  },
  {
    "raw_code": "def call(request)\n        self.request = request\n        result = check_static_cache || route\n        result ? result : RootRequestCommand.new(adapter.options).call(request)\n      end",
    "comment": "Perform routing on a specific request, serving the request as a static file through {Commands::RootRequestCommand} if no route is found.  @param [Adapter Dependent] request the request object @return [Array(Numeric,Hash,Array)] the Rack-style server response data",
    "label": "",
    "id": "601"
  },
  {
    "raw_code": "def docs_prefix; 'docs' end\n\n      # @return [String] the URI prefix for all class/method/file list requests\n      def list_prefix; 'list' end\n\n      # @return [String] the URI prefix for all search requests\n      def search_prefix; 'search' end\n\n      # @return [String] the URI prefix for all static assets (templates)\n      def static_prefix; 'static' end\n\n      # @group Routing Methods\n\n      # @return [Array(LibraryVersion, Array<String>)] the library followed\n      #   by the rest of the path components in the request path. LibraryVersion\n      #   will be nil if no matching library was found.\n      def parse_library_from_path(paths)\n        return [adapter.libraries.values.first.first, paths] if adapter.options[:single_library]\n        library = nil\n        paths = paths.dup\n        libs = adapter.libraries[paths.first]\n        if libs\n          paths.shift\n          library = libs.find {|l| l.version == paths.first }\n          if library\n            request.version_supplied = true if request\n            paths.shift\n          else # use the last lib in the list\n            request.version_supplied = false if request\n            library = libs.last\n          end\n        end\n        [library, paths]\n      end\n\n      protected\n\n      # Performs routing algorithm to find which prefix is called, first\n      # parsing out library name/version information.\n      #\n      # @return [Array(Numeric,Hash,Array<String>)] the Rack-style response\n      # @return [nil] if no route is matched\n      def route(path = request.path_info)\n        path = path.gsub(%r{//+}, '/').gsub(%r{^/|/$}, '')\n        return route_index if path.empty? || path == docs_prefix\n        case path\n        when %r{^(#{docs_prefix}|#{list_prefix}|#{search_prefix}|#{static_prefix})(/.*|$)}\n          prefix = $1\n          paths = $2.gsub(%r{^/|/$}, '').split('/')\n          library, paths = *parse_library_from_path(paths)\n          return unless library\n          return case prefix\n                 when docs_prefix;   route_docs(library, paths)\n                 when list_prefix;   route_list(library, paths)\n                 when search_prefix; route_search(library, paths)\n                 when static_prefix; route_static(library, paths)\n                 end\n        end\n        nil\n      end",
    "comment": "@group Route Prefixes @return [String] the URI prefix for all object documentation requests",
    "label": "",
    "id": "602"
  },
  {
    "raw_code": "def route_docs(library, paths)\n        return route_index if library.nil?\n        case paths.first\n        when \"frames\"\n          paths.shift\n          cmd = DisplayObjectCommand\n        when \"file\"\n          paths.shift\n          cmd = DisplayFileCommand\n        else\n          cmd = DisplayObjectCommand\n        end",
    "comment": "Routes requests from {#docs_prefix} and calls the appropriate command @param [LibraryVersion] library the library to route for @param [Array<String>] paths path components (split by '/') @return (see #route)",
    "label": "",
    "id": "603"
  },
  {
    "raw_code": "def route_index\n        if adapter.options[:single_library]\n          route_docs(adapter.libraries.values.first.first, [])\n        else\n          LibraryIndexCommand.new(adapter.options.merge(:path => '')).call(request)\n        end",
    "comment": "Routes for the index of a library / multiple libraries @return (see #route)",
    "label": "",
    "id": "604"
  },
  {
    "raw_code": "def route_list(library, paths)\n        return if paths.empty?\n        ListCommand.new(final_options(library, paths)).call(request)\n      end",
    "comment": "Routes requests from {#list_prefix} and calls the appropriate command @param (see #route_docs) @return (see #route_docs)",
    "label": "",
    "id": "605"
  },
  {
    "raw_code": "def route_search(library, paths)\n        return unless paths.empty?\n        SearchCommand.new(final_options(library, paths)).call(request)\n      end",
    "comment": "Routes requests from {#search_prefix} and calls the appropriate command @param (see #route_docs) @return (see #route_docs)",
    "label": "",
    "id": "606"
  },
  {
    "raw_code": "def final_options(library, paths)\n        path = File.cleanpath(paths.join('/')).gsub(%r{^(\\.\\./)+}, '')\n        adapter.options.merge(:library => library, :path => path)\n      end",
    "comment": "@group Utility Methods Adds extra :library/:path option keys to the adapter options. Use this method when passing options to a command.  @param (see #route_docs) @return [Hash] finalized options",
    "label": "",
    "id": "607"
  },
  {
    "raw_code": "def normalize_path(path)\n      raise \"abnormal path `#{path}'\" if path[0] != ?/\n      ret = path.dup\n\n      ret.gsub!(%r{/+}o, '/')                    # //      => /\n      while ret.sub!(%r'/\\.(?:/|\\Z)', '/'); end  # /.      => /\n      while ret.sub!(%r'/(?!\\.\\./)[^/]+/\\.\\.(?:/|\\Z)', '/'); end # /foo/.. => /foo\n\n      raise \"abnormal path `#{path}'\" if %r{/\\.\\.(/|\\Z)} =~ ret\n      ret\n    end",
    "comment": " Normalizes a request path.  Raises an exception if the path cannot be normalized.",
    "label": "",
    "id": "608"
  },
  {
    "raw_code": "def load_mime_types(file)\n      # note: +file+ may be a \"| command\" for now; some people may\n      # rely on this, but currently we do not use this method by default.\n      open(file){ |io|\n        hash = Hash.new\n        io.each{ |line|\n          next if /^#/ =~ line\n          line.chomp!\n          mimetype, ext0 = line.split(/\\s+/, 2)\n          next unless ext0\n          next if ext0.empty?\n          ext0.split(/\\s+/).each{ |ext| hash[ext] = mimetype }\n        }\n        hash\n      }\n    end",
    "comment": " Loads Apache-compatible mime.types in +file+.",
    "label": "",
    "id": "609"
  },
  {
    "raw_code": "def mime_type(filename, mime_tab)\n      suffix1 = (/\\.(\\w+)$/ =~ filename && $1.downcase)\n      suffix2 = (/\\.(\\w+)\\.[\\w\\-]+$/ =~ filename && $1.downcase)\n      mime_tab[suffix1] || mime_tab[suffix2] || \"application/octet-stream\"\n    end",
    "comment": " Returns the mime type of +filename+ from the list in +mime_tab+.  If no mime type was found application/octet-stream is returned.",
    "label": "",
    "id": "610"
  },
  {
    "raw_code": "def parse_header(raw)\n      header = Hash.new([].freeze)\n      field = nil\n      raw.each_line{|line|\n        case line\n        when /^([A-Za-z0-9!\\#$%&'*+\\-.^_`|~]+):\\s*(.*?)\\s*\\z/om\n          field, value = $1, $2\n          field.downcase!\n          header[field] = [] unless header.has_key?(field)\n          header[field] << value\n        when /^\\s+(.*?)\\s*\\z/om\n          value = $1\n          unless field\n            raise HTTPStatus::BadRequest, \"bad header '#{line}'.\"\n          end",
    "comment": " Parses an HTTP header +raw+ into a hash of header fields with an Array of values.",
    "label": "",
    "id": "611"
  },
  {
    "raw_code": "def split_header_value(str)\n      str.scan(%r'\\G((?:\"(?:\\\\.|[^\"])+?\"|[^\",]+)+)\n                    (?:,\\s*|\\Z)'xn).flatten\n    end",
    "comment": " Splits a header value +str+ according to HTTP specification.",
    "label": "",
    "id": "612"
  },
  {
    "raw_code": "def parse_range_header(ranges_specifier)\n      if /^bytes=(.*)/ =~ ranges_specifier\n        byte_range_set = split_header_value($1)\n        byte_range_set.collect{|range_spec|\n          case range_spec\n          when /^(\\d+)-(\\d+)/ then $1.to_i .. $2.to_i\n          when /^(\\d+)-/      then $1.to_i .. -1\n          when /^-(\\d+)/      then -($1.to_i) .. -1\n          else return nil\n          end",
    "comment": " Parses a Range header value +ranges_specifier+",
    "label": "",
    "id": "613"
  },
  {
    "raw_code": "def parse_qvalues(value)\n      tmp = []\n      if value\n        parts = value.split(/,\\s*/)\n        parts.each {|part|\n          if m = %r{^([^\\s,]+?)(?:;\\s*q=(\\d+(?:\\.\\d+)?))?$}.match(part)\n            val = m[1]\n            q = (m[2] or 1).to_f\n            tmp.push([val, q])\n          end",
    "comment": " Parses q values in +value+ as used in Accept headers.",
    "label": "",
    "id": "614"
  },
  {
    "raw_code": "def dequote(str)\n      ret = (/\\A\"(.*)\"\\Z/ =~ str) ? $1 : str.dup\n      ret.gsub!(/\\\\(.)/, \"\\\\1\")\n      ret\n    end",
    "comment": " Removes quotes and escapes from +str+",
    "label": "",
    "id": "615"
  },
  {
    "raw_code": "def quote(str)\n      '\"' << str.gsub(/[\\\\\\\"]/o, \"\\\\\\1\") << '\"'\n    end",
    "comment": " Quotes and escapes quotes in +str+",
    "label": "",
    "id": "616"
  },
  {
    "raw_code": "def initialize(*args)\n        @name = @filename = @next_data = nil\n        if args.empty?\n          @raw_header = []\n          @header = nil\n          super(\"\")\n        else\n          @raw_header = EmptyRawHeader\n          @header = EmptyHeader\n          super(args.shift)\n          unless args.empty?\n            @next_data = self.class.new(*args)\n          end",
    "comment": " Creates a new FormData object.  +args+ is an Array of form data entries.  One FormData will be created for each entry.  This is called by WEBrick::HTTPUtils.parse_form_data for you",
    "label": "",
    "id": "617"
  },
  {
    "raw_code": "def [](*key)\n        begin\n          @header[key[0].downcase].join(\", \")\n        rescue StandardError, NameError\n          super\n        end",
    "comment": " Retrieves the header at the first entry in +key+",
    "label": "",
    "id": "618"
  },
  {
    "raw_code": "def <<(str)\n        if @header\n          super\n        elsif str == CRLF\n          @header = HTTPUtils::parse_header(@raw_header.join)\n          if cd = self['content-disposition']\n            if /\\s+name=\"(.*?)\"/ =~ cd then @name = $1 end\n            if /\\s+filename=\"(.*?)\"/ =~ cd then @filename = $1 end\n          end",
    "comment": " Adds +str+ to this FormData which may be the body, a header or a header entry.  This is called by WEBrick::HTTPUtils.parse_form_data for you",
    "label": "",
    "id": "619"
  },
  {
    "raw_code": "def append_data(data)\n        tmp = self\n        while tmp\n          unless tmp.next_data\n            tmp.next_data = data\n            break\n          end",
    "comment": " Adds +data+ at the end of the chain of entries  This is called by WEBrick::HTTPUtils.parse_form_data for you.",
    "label": "",
    "id": "620"
  },
  {
    "raw_code": "def each_data\n        tmp = self\n        while tmp\n          next_data = tmp.next_data\n          yield(tmp)\n          tmp = next_data\n        end",
    "comment": " Yields each entry in this FormData",
    "label": "",
    "id": "621"
  },
  {
    "raw_code": "def list\n        ret = []\n        each_data{|data|\n          ret << data.to_s\n        }\n        ret\n      end",
    "comment": " Returns all the FormData as an Array",
    "label": "",
    "id": "622"
  },
  {
    "raw_code": "def to_s\n        String.new(self)\n      end",
    "comment": " This FormData's body",
    "label": "",
    "id": "623"
  },
  {
    "raw_code": "def parse_query(str)\n      query = Hash.new\n      if str\n        str.split(/[&;]/).each{|x|\n          next if x.empty?\n          key, val = x.split(/=/,2)\n          key = unescape_form(key)\n          val = unescape_form(val.to_s)\n          val = FormData.new(val)\n          val.name = key\n          if query.has_key?(key)\n            query[key].append_data(val)\n            next\n          end",
    "comment": " Parses the query component of a URI in +str+",
    "label": "",
    "id": "624"
  },
  {
    "raw_code": "def parse_form_data(io, boundary)\n      boundary_regexp = /\\A--#{Regexp.quote(boundary)}(--)?#{CRLF}\\z/\n      form_data = Hash.new\n      return form_data unless io\n      data = nil\n      io.each_line{|line|\n        if boundary_regexp =~ line\n          if data\n            data.chop!\n            key = data.name\n            if form_data.has_key?(key)\n              form_data[key].append_data(data)\n            else\n              form_data[key] = data\n            end",
    "comment": " Parses form data in +io+ with the given +boundary+",
    "label": "",
    "id": "625"
  },
  {
    "raw_code": "def _make_regex(str) /([#{Regexp.escape(str)}])/n end\n    def _make_regex!(str) /([^#{Regexp.escape(str)}])/n end\n    def _escape(str, regex)\n      str = str.b\n      str.gsub!(regex) {\"%%%02X\" % $1.ord}\n      # %-escaped string should contain US-ASCII only\n      str.force_encoding(Encoding::US_ASCII)\n    end\n    def _unescape(str, regex)\n      str = str.b\n      str.gsub!(regex) {$1.hex.chr}\n      # encoding of %-unescaped string is unknown\n      str\n    end\n\n    UNESCAPED = _make_regex(control+space+delims+unwise+nonascii)\n    UNESCAPED_FORM = _make_regex(reserved+control+delims+unwise+nonascii)\n    NONASCII  = _make_regex(nonascii)\n    ESCAPED   = /%([0-9a-fA-F]{2})/\n    UNESCAPED_PCHAR = _make_regex!(unreserved+\":@&=+$,\")\n\n    # :startdoc:\n\n    ##\n    # Escapes HTTP reserved and unwise characters in +str+\n\n    def escape(str)\n      _escape(str, UNESCAPED)\n    end\n\n    ##\n    # Unescapes HTTP reserved and unwise characters in +str+\n\n    def unescape(str)\n      _unescape(str, ESCAPED)\n    end\n\n    ##\n    # Escapes form reserved characters in +str+\n\n    def escape_form(str)\n      ret = _escape(str, UNESCAPED_FORM)\n      ret.gsub!(/ /, \"+\")\n      ret\n    end\n\n    ##\n    # Unescapes form reserved characters in +str+\n\n    def unescape_form(str)\n      _unescape(str.gsub(/\\+/, \" \"), ESCAPED)\n    end\n\n    ##\n    # Escapes path +str+\n\n    def escape_path(str)\n      result = \"\"\n      str.scan(%r{/([^/]*)}).each{|i|\n        result << \"/\" << _escape(i[0], UNESCAPED_PCHAR)\n      }\n      return result\n    end\n\n    ##\n    # Escapes 8 bit characters in +str+\n\n    def escape8bit(str)\n      _escape(str, NONASCII)\n    end\n  end\nend",
    "comment": ":stopdoc:",
    "label": "",
    "id": "626"
  },
  {
    "raw_code": "def url_for(obj, anchor = nil, relative = false) # rubocop:disable Lint/UnusedMethodArgument\n        return '' if obj.nil?\n        return url_for_index if obj == '_index.html'\n        return abs_url(base_path(router.static_prefix), obj) if String === obj\n        url = super(obj, anchor, false)\n        return unless url\n        abs_url(base_path(router.docs_prefix), url)\n      end",
    "comment": "Modifies {Templates::Helpers::HtmlHelper#url_for} to return a URL instead of a disk location. @param (see Templates::Helpers::HtmlHelper#url_for) @return (see Templates::Helpers::HtmlHelper#url_for)",
    "label": "",
    "id": "627"
  },
  {
    "raw_code": "def url_for_file(filename, anchor = nil)\n        if filename.is_a?(CodeObjects::ExtraFileObject)\n          filename = filename.filename\n        end",
    "comment": "Modifies {Templates::Helpers::HtmlHelper#url_for_file} to return a URL instead of a disk location. @param (see Templates::Helpers::HtmlHelper#url_for_file) @return (see Templates::Helpers::HtmlHelper#url_for_file)",
    "label": "",
    "id": "628"
  },
  {
    "raw_code": "def url_for_list(type)\n        abs_url(base_path(router.list_prefix), type.to_s)\n      end",
    "comment": "Modifies {Templates::Helpers::HtmlHelper#url_for_list} to return a URL based on the list prefix instead of a HTML filename. @param (see Templates::Helpers::HtmlHelper#url_for_list) @return (see Templates::Helpers::HtmlHelper#url_for_list)",
    "label": "",
    "id": "629"
  },
  {
    "raw_code": "def url_for_frameset\n        options.file ? url_for_file(options.file) : url_for(object)\n      end",
    "comment": "Returns the frames URL for the page @return (see Templates::Helpers::HtmlHelper#url_for_frameset)",
    "label": "",
    "id": "630"
  },
  {
    "raw_code": "def url_for_main\n        options.readme ? url_for_file(options.readme) : url_for_index\n      end",
    "comment": "Returns the main URL, first checking a readme and then linking to the index @return (see Templates::Helpers::HtmlHelper#url_for_main)",
    "label": "",
    "id": "631"
  },
  {
    "raw_code": "def url_for_index\n        abs_url(base_path(router.docs_prefix), 'index')\n      end",
    "comment": "Returns the URL for the alphabetic index page @return (see Templates::Helpers::HtmlHelper#url_for_index)",
    "label": "",
    "id": "632"
  },
  {
    "raw_code": "def abs_url(*path_components)\n        File.join(router.request.script_name, *path_components)\n      end",
    "comment": "@param path_components [Array<String>] components of a URL @return [String] the absolute path from any mounted base URI.",
    "label": "",
    "id": "633"
  },
  {
    "raw_code": "def base_path(path)\n        libname = router.request.version_supplied ? @library.to_s : @library.name\n        path + (@single_library ? '' : \"/#{libname}\")\n      end",
    "comment": "@example The base path for a library 'foo' base_path('docs') # => 'docs/foo' @param [String] path the path prefix for a base path URI @return [String] the base URI for a library with an extra +path+ prefix",
    "label": "",
    "id": "634"
  },
  {
    "raw_code": "def router; @adapter.router end\n\n      # @return [String] a timestamp for a given file\n      def mtime(file)\n        file = YARD::Server::Commands::StaticFileHelpers.find_file(@adapter, file)\n        file ? File.mtime(file).to_i : nil\n      end\n\n      # @return [String] a URL for a file with a timestamp\n      def mtime_url(file)\n        url = url_for(file)\n        time = mtime(file)\n        url + (time ? \"?#{time}\" : \"\")\n      end\n    end",
    "comment": "@return [Router] convenience method for accessing the router",
    "label": "",
    "id": "635"
  },
  {
    "raw_code": "def initialize(app, opts = {})\n        args = [opts[:libraries] || {}, opts[:options] || {}, opts[:server_options] || {}]\n        @app = app\n        @adapter = RackAdapter.new(*args)\n      end",
    "comment": "Creates a new Rack-based middleware for serving YARD documentation.  @param app the next Rack middleware in the stack @option opts [Hash{String=>Array<LibraryVersion>}] :libraries ({}) the map of libraries to serve through the adapter. This option is *required*. @option opts [Hash] :options ({}) a list of options to pass to the adapter. See {Adapter#options} for a list. @option opts [Hash] :server_options ({}) a list of options to pass to the server. See {Adapter#server_options} for a list.",
    "label": "",
    "id": "636"
  },
  {
    "raw_code": "def call(env)\n        request = Rack::Request.new(env)\n        request.path_info = unescape(request.path_info) # unescape things like %3F\n        router.call(request)\n      rescue StandardError => ex\n        log.backtrace(ex)\n        [500, {'Content-Type' => 'text/plain'},\n          [ex.message + \"\\n\" + ex.backtrace.join(\"\\n\")]]\n      end",
    "comment": "Responds to Rack requests and builds a response with the {Router}. @return [Array(Numeric,Hash,Array)] the Rack-style response",
    "label": "",
    "id": "637"
  },
  {
    "raw_code": "def start\n        server = RackServer.new(server_options)\n        server.instance_variable_set(\"@app\", self)\n        print_start_message(server)\n        server.start\n      end",
    "comment": "Starts the Rack server. This method will pass control to the server and block. @return [void]",
    "label": "",
    "id": "638"
  },
  {
    "raw_code": "def javascripts\n  super + %w(js/autocomplete.js)\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "639"
  },
  {
    "raw_code": "def init\n  super\n  sections.place(:permalink).after_any(:method_signature)\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "640"
  },
  {
    "raw_code": "def init\n  sections :processing\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "641"
  },
  {
    "raw_code": "def init\n  sections :search, [T('../default/layout')]\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "642"
  },
  {
    "raw_code": "def favicon?\n          return unless request.path == '/favicon.ico'\n          headers['Content-Type'] = 'image/png'\n          self.status = 200\n          self.body = ''\n          raise FinishRequest\n        end",
    "comment": "Serves an empty favicon. @raise [FinishRequest] finalizes an empty body if the path matches /favicon.ico so browsers don't complain.",
    "label": "",
    "id": "643"
  },
  {
    "raw_code": "def static_template_file?\n          # this const was defined in StaticFileCommand originally\n          default_mime_types = StaticFileCommand::DefaultMimeTypes\n\n          file = find_file(adapter, path)\n\n          if file\n            ext = \".\" + (path[/\\.(\\w+)$/, 1] || \"html\")\n            headers['Content-Type'] = mime_type(ext, default_mime_types)\n            self.body = File.read(file)\n            raise FinishRequest\n          end",
    "comment": "Attempts to route a path to a static template file.  @raise [FinishRequest] if a file was found and served @return [void]",
    "label": "",
    "id": "644"
  },
  {
    "raw_code": "def initialize(opts = {})\n          opts.each do |key, value|\n            send(\"#{key}=\", value) if respond_to?(\"#{key}=\")\n          end",
    "comment": "@group Instance Method Summary Creates a new command object, setting attributes named by keys in the options hash. After initialization, the options hash is saved in {#command_options} for further inspection.  @example Creating a Command cmd = DisplayObjectCommand.new(:caching => true, :library => mylib) cmd.library # => mylib cmd.command_options # => {:caching => true, :library => mylib} @param [Hash] opts the options hash, saved to {#command_options} after initialization.",
    "label": "",
    "id": "645"
  },
  {
    "raw_code": "def call(request)\n          self.request = request\n          self.path ||= request.path_info[1..-1]\n          self.headers = {'Content-Type' => 'text/html'}\n          self.body = ''\n          self.status = 200\n          add_cache_control\n          begin\n            run\n          rescue FinishRequest\n            nil # noop\n          rescue NotFoundError => e\n            self.body = e.message if e.message != e.class.to_s\n            not_found\n          end",
    "comment": "The main method called by a router with a request object.  @note This command should not be overridden by subclasses. Implement the callback method {#run} instead. @param [Adapter Dependent] request the request object @return [Array(Numeric,Hash,Array<String>)] a Rack-style response of status, headers, and body wrapped in an array.",
    "label": "",
    "id": "646"
  },
  {
    "raw_code": "def run\n          raise NotImplementedError\n        end",
    "comment": "@group Abstract Methods Subclass this method to implement a custom command. This method should set the {#status} and {#body}, and optionally modify the {#headers}. Note that +#status+ defaults to 200.  @example A custom command class ErrorCommand < Base def run self.body = 'ERROR! The System is down!' self.status = 500 self.headers['Content-Type'] = 'text/plain' end end  @abstract @return [void]",
    "label": "",
    "id": "647"
  },
  {
    "raw_code": "def render(object = nil)\n          case object\n          when CodeObjects::Base\n            cache object.format(options)\n          when nil\n            cache Templates::Engine.render(options)\n          else\n            cache object\n          end",
    "comment": "@group Helper Methods Renders a specific object if provided, or a regular template rendering if object is not provided.  @todo This method is dependent on +#options+, it should be in {LibraryCommand}. @param [CodeObjects::Base, nil] object calls {CodeObjects::Base#format} if an object is provided, or {Templates::Engine.render} if object is nil. Both receive +#options+ as an argument. @return [String] the resulting output to display",
    "label": "",
    "id": "648"
  },
  {
    "raw_code": "def cache(data)\n          if caching && adapter.document_root\n            path = File.join(adapter.document_root, request.path_info.sub(/\\.html$/, '') + '.html')\n            path = path.sub(%r{/\\.html$}, '.html')\n            FileUtils.mkdir_p(File.dirname(path))\n            log.debug \"Caching data to #{path}\"\n            File.open(path, 'wb') {|f| f.write(data) }\n          end",
    "comment": "Override this method to implement custom caching mechanisms for  @example Caching to memory $memory_cache = {} def cache(data) $memory_cache[path] = data end @param [String] data the data to cache @return [String] the same cached data (for chaining) @see StaticCaching",
    "label": "",
    "id": "649"
  },
  {
    "raw_code": "def not_found\n          self.status = 404\n          return unless body.empty?\n          self.body = \"Not found: #{request.path}\"\n          headers['Content-Type'] = 'text/plain'\n          headers['X-Cascade'] = 'pass'\n          headers['Cache-Control'] = 'nocache'\n        end",
    "comment": "Sets the body and headers for a 404 response. Does not modify the body if already set.  @return [void]",
    "label": "",
    "id": "650"
  },
  {
    "raw_code": "def redirect(url)\n          headers['Location'] = url\n          self.status = 302\n          raise FinishRequest\n        end",
    "comment": "Sets the headers and status code for a redirection to a given URL @param [String] url the URL to redirect to @raise [FinishRequest] causes the request to terminate.",
    "label": "",
    "id": "651"
  },
  {
    "raw_code": "def add_cache_control\n          return if request.query_string.to_i == 0\n          headers['Cache-Control'] ||= 'public, max-age=300'\n        end",
    "comment": "Add a conservative cache control policy to reduce load on requests served with \"?1234567890\" style timestamp query strings.",
    "label": "",
    "id": "652"
  },
  {
    "raw_code": "def fulldoc_template\n          tplopts = [options.template, :fulldoc, options.format]\n          tplclass = Templates::Engine.template(*tplopts)\n          obj = Object.new.extend(tplclass)\n          class << obj; define_method(:init) {} end\n          obj.class = tplclass\n          obj.send(:initialize, options)\n          class << obj\n            attr_reader :contents\n            define_method(:asset) {|_, contents| @contents = contents }\n          end",
    "comment": "Hack to load a custom fulldoc template object that does not do any rendering/generation. We need this to access the generate_*_list methods.",
    "label": "",
    "id": "653"
  },
  {
    "raw_code": "def initialize(relative_base_path)\n        @relative_base_path = relative_base_path\n        @extracted_objects = {}\n        @messages = Messages.new\n      end",
    "comment": "Creates a POT generator that uses +relative_base_path+ to generate locations for a msgid. +relative_base_path+ is prepended to all locations.  @param [String] relative_base_path a relative working directory path from a directory path that has created .pot file.",
    "label": "",
    "id": "654"
  },
  {
    "raw_code": "def parse_objects(objects)\n        objects.each do |object|\n          extract_documents(object)\n        end",
    "comment": "Parses {CodeObjects::Base} objects and stores extracted msgids into {#messages}  @param [Array<CodeObjects::Base>] objects a list of {CodeObjects::Base} to be parsed. @return [void]",
    "label": "",
    "id": "655"
  },
  {
    "raw_code": "def parse_files(files)\n        files.each do |file|\n          extract_paragraphs(file)\n        end",
    "comment": "Parses {CodeObjects::ExtraFileObject} objects and stores extracted msgids into {#messages}.  @param [Array<CodeObjects::ExtraFileObject>] files a list of {CodeObjects::ExtraFileObject} objects to be parsed. @return [void]",
    "label": "",
    "id": "656"
  },
  {
    "raw_code": "def generate\n        pot = String.new(header)\n        sorted_messages = @messages.sort_by do |message|\n          sorted_locations = message.locations.sort\n          sorted_locations.first || []\n        end",
    "comment": "Generates POT from +@messages+.  One PO file entry is generated from a +Message+ in +@messages+.  Locations of the +Message+ are used to generate the reference line that is started with \"#: \". +relative_base_path+ passed when the generator is created is prepended to each path in location.  Comments of the +Message+ are used to generate the translator-comment line that is started with \"# \".  @return [String] POT format string",
    "label": "",
    "id": "657"
  },
  {
    "raw_code": "def initialize(id)\n        @id = id\n        @locations = Set.new\n        @comments = Set.new\n      end",
    "comment": "Creates a translate target message for message ID +id+.  @param [String] id the message ID of the translate target message.",
    "label": "",
    "id": "658"
  },
  {
    "raw_code": "def add_location(path, line)\n        @locations << [path, line]\n      end",
    "comment": "Adds location information for the message.  @param [String] path the path where the message appears. @param [Integer] line the line number where the message appears. @return [void]",
    "label": "",
    "id": "659"
  },
  {
    "raw_code": "def add_comment(comment)\n        @comments << comment unless comment.nil?\n      end",
    "comment": "Adds a comment for the message.  @param [String] comment the comment for the message to be added. @return [void]",
    "label": "",
    "id": "660"
  },
  {
    "raw_code": "def ==(other)\n        other.is_a?(self.class) &&\n          @id == other.id &&\n          @locations == other.locations &&\n          @comments == other.comments\n      end",
    "comment": "@param [Message] other the +Message+ to be compared. @return [Boolean] checks whether this message is equal to another.",
    "label": "",
    "id": "661"
  },
  {
    "raw_code": "def available?\n          !@@gettext_version.nil?\n        end",
    "comment": "@return [Boolean] true if gettext is available, false otherwise.",
    "label": "",
    "id": "662"
  },
  {
    "raw_code": "def parse(file)\n        case @@gettext_version\n        when 2\n          parser = GetText::PoParser.new\n          data = GetText::MoFile.new\n        when 3\n          parser = GetText::POParser.new\n          data = GetText::MO.new\n        end",
    "comment": "Parses PO file.  @param [String] file path of PO file to be parsed. @return [Hash<String, String>] parsed messages.",
    "label": "",
    "id": "663"
  },
  {
    "raw_code": "def initialize(input, options = {})\n        @input = input\n        @options = options\n      end",
    "comment": "Creates a text object that has translation related features for the input text.  @param [#each_line] input a text to be translated. @option options [Boolean] :have_header (false) whether the input text has header or not.",
    "label": "",
    "id": "664"
  },
  {
    "raw_code": "def extract_messages\n        parse do |part|\n          case part[:type]\n          when :markup, :empty_line\n            # ignore\n          when :attribute\n            yield(:attribute, part[:name], part[:value], part[:line_no])\n          when :paragraph\n            yield(:paragraph, part[:paragraph], part[:line_no])\n          end",
    "comment": "Extracts translation target messages from +@input+.  @yield [:attribute, name, value, line_no] the block that receives extracted an attribute in header. It may called many times. @yieldparam [String] name the name of extracted attribute. @yieldparam [String] value the value of extracted attribute. @yieldparam [Integer] line_no the defined line number of extracted attribute. @yield [:paragraph, text, start_line_no] the block that receives extracted a paragraph in body. Paragraph is a text block separated by one or more empty lines. Empty line is a line that contains only zero or more whitespaces. It may called many times. @yieldparam [String] text the text of extracted paragraph. @yieldparam [Integer] start_line_no the start line number of extracted paragraph. @return [void]",
    "label": "",
    "id": "665"
  },
  {
    "raw_code": "def translate(locale)\n        translated_text = String.new(\"\")\n        parse do |part|\n          case part[:type]\n          when :markup\n            translated_text << part[:line]\n          when :attribute\n            prefix = \"#{part[:prefix]}#{part[:name]}#{part[:infix]}\"\n            value = locale.translate(part[:value])\n            suffix = part[:suffix]\n            translated_text << \"#{prefix}#{value}#{suffix}\"\n          when :paragraph\n            translated_text << locale.translate(part[:paragraph])\n          when :empty_line\n            translated_text << part[:line]\n          else\n            raise \"should not reach here: unexpected type: #{type}\"\n          end",
    "comment": "Translates into +locale+.  @param [Locale] locale the translation target locale. @return [String] translated text.",
    "label": "",
    "id": "666"
  },
  {
    "raw_code": "def initialize(name)\n        @name = name\n        @messages = {}\n      end",
    "comment": "Creates a locale for +name+ locale.  @param [String] name the locale name.",
    "label": "",
    "id": "667"
  },
  {
    "raw_code": "def load(locale_directory)\n        return false if @name.nil?\n\n        po_file = File.join(locale_directory, \"#{@name}.po\")\n        return false unless File.exist?(po_file)\n\n        require \"yard/i18n/po_parser\"\n        return false unless POParser.available?\n\n        po_parser = POParser.new\n        @messages.merge!(po_parser.parse(po_file))\n\n        true\n      end",
    "comment": "Loads translation messages from +locale_directory+/{#name}.po.  @param [String] locale_directory the directory path that has {#name}.po. @return [Boolean] +true+ if PO file exists, +false+ otherwise.",
    "label": "",
    "id": "668"
  },
  {
    "raw_code": "def translate(message)\n        @messages[message] || message\n      end",
    "comment": "@param [String] message the translation target message. @return [String] translated message. If translation isn't registered, the +message+ is returned.",
    "label": "",
    "id": "669"
  },
  {
    "raw_code": "def initialize\n        @messages = {}\n      end",
    "comment": "Creates a new container.",
    "label": "",
    "id": "670"
  },
  {
    "raw_code": "def each(&block)\n        @messages.each_value(&block)\n      end",
    "comment": "Enumerates each {Message} in the container.  @yieldparam [Message] message the next message object in the enumeration. @return [void]",
    "label": "",
    "id": "671"
  },
  {
    "raw_code": "def [](id)\n        @messages[id]\n      end",
    "comment": "@param [String] id the message ID to perform a lookup on. @return [Message, nil] a registered message for the given +id+, or nil if no message for the ID is found.",
    "label": "",
    "id": "672"
  },
  {
    "raw_code": "def register(id)\n        @messages[id] ||= Message.new(id)\n      end",
    "comment": "Registers a {Message}, the message ID of which is +id+. If corresponding +Message+ is already registered, the previously registered object is returned.  @param [String] id the ID of the message to be registered. @return [Message] the registered +Message+.",
    "label": "",
    "id": "673"
  },
  {
    "raw_code": "def ==(other)\n        other.is_a?(self.class) &&\n          @messages == other.messages\n      end",
    "comment": "Checks if this messages list is equal to another messages list.  @param [Messages] other the container to compare. @return [Boolean] whether +self+ and +other+ is equivalence or not.",
    "label": "",
    "id": "674"
  },
  {
    "raw_code": "def init\n  sections :header, [T('docstring')]\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "675"
  },
  {
    "raw_code": "def init\n  tags = Tags::Library.visible_tags - [:abstract, :deprecated, :note, :todo]\n  create_tag_methods(tags - [:example, :option, :overload, :see])\n  sections :index, tags.map {|t| t.to_s.tr('.', '_').to_sym }\n  sections.any(:overload).push(T('docstring'))\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "676"
  },
  {
    "raw_code": "def init\n  sections :header, [T('method_details')]\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "677"
  },
  {
    "raw_code": "def init\n  sections :header, [T('docstring')]\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "678"
  },
  {
    "raw_code": "def init\n  @breadcrumb = []\n  @page_title = ''\n  @breadcrumb_title = ''\n  if @onefile\n    sections :layout\n  elsif defined?(@file) && @file\n    if @file.attributes[:namespace]\n      @object = options.object = Registry.at(@file.attributes[:namespace]) || Registry.root\n    end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "679"
  },
  {
    "raw_code": "def javascripts\n  %w(js/jquery.js js/app.js)\nend",
    "comment": "@return [Array<String>] core javascript files for layout @since 0.7.0",
    "label": "",
    "id": "680"
  },
  {
    "raw_code": "def stylesheets\n  %w(css/style.css css/common.css)\nend",
    "comment": "@return [Array<String>] core stylesheets for the layout @since 0.7.0",
    "label": "",
    "id": "681"
  },
  {
    "raw_code": "def menu_lists\n  [{:type => 'class', :title => 'Classes', :search_title => 'Class List'},\n    {:type => 'method', :title => 'Methods', :search_title => 'Method List'},\n    {:type => 'file', :title => 'Files', :search_title => 'File List'}]\nend",
    "comment": "@return [Array<Hash{Symbol=>String}>] the list of search links and drop-down menus @since 0.7.0",
    "label": "",
    "id": "682"
  },
  {
    "raw_code": "def init\n  sections :header, [:method_signature, T('docstring'), :source]\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "683"
  },
  {
    "raw_code": "def init\n  super\n  sections.last.pop\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "684"
  },
  {
    "raw_code": "def init\n  @modules = object.children.select {|o| o.type == :module }\n  @classes = object.children.select {|o| o.type == :class }\n  sections :child, [:info], :classes, [T('class')], :header, [T('module')], :dependencies\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "685"
  },
  {
    "raw_code": "def init\n  sections :header, [T('docstring')], :children, :includes, :extends,\n    :class_meths_list, :instance_meths_list\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "686"
  },
  {
    "raw_code": "def init\n  return if object.docstring.blank? && !object.has_tag?(:api)\n  sections :index, [:private, :deprecated, :abstract, :todo, :note, :returns_void, :text], T('tags')\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "687"
  },
  {
    "raw_code": "def serialize(object)\n  options.object = object\n  serialize_index(options) if object == '_index.html' && options.readme.nil?\n  Templates::Engine.with_serializer(object, options.serializer) do\n    T('layout').run(options)\n  end",
    "comment": "Generate an HTML document for the specified object. This method is used by most of the objects found in the Registry. @param [CodeObject] object to be saved to HTML",
    "label": "",
    "id": "688"
  },
  {
    "raw_code": "def serialize_onefile\n  Templates::Engine.with_serializer('index.html', options.serializer) do\n    T('onefile').run(options)\n  end",
    "comment": "Generate the documentation output in one file (--one-file) which will load the contents of all the javascript and css and output the entire contents without depending on any additional files",
    "label": "",
    "id": "689"
  },
  {
    "raw_code": "def serialize_index(options)\n  Templates::Engine.with_serializer('index.html', options.serializer) do\n    T('layout').run(options.merge(:index => true))\n  end",
    "comment": "Generate the index document for the output @params [Hash] options contains data and flags that influence the output",
    "label": "",
    "id": "690"
  },
  {
    "raw_code": "def serialize_file(file, title = nil) # rubocop:disable Lint/UnusedMethodArgument\n  options.object = Registry.root\n  options.file = file\n  outfile = 'file.' + file.name + '.html'\n\n  serialize_index(options) if file == options.readme\n  Templates::Engine.with_serializer(outfile, options.serializer) do\n    T('layout').run(options)\n  end",
    "comment": "Generate a single HTML file with the layout template applied. This is generally the README file or files specified on the command-line.  @param [File] file object to be saved to the output @param [String] title currently unused  @see layout#diskfile",
    "label": "",
    "id": "691"
  },
  {
    "raw_code": "def asset(path, content)\n  if options.serializer\n    log.capture(\"Generating asset #{path}\") do\n      options.serializer.serialize(path, content)\n    end",
    "comment": " Generates a file to the output with the specified contents.  @example saving a custom html file to the documentation root  asset('my_custom.html','<html><body>Custom File</body></html>')  @param [String] path relative to the document output where the file will be created. @param [String] content the contents that are saved to the file.",
    "label": "",
    "id": "692"
  },
  {
    "raw_code": "def stylesheets_full_list\n  %w(css/full_list.css css/common.css)\nend",
    "comment": "@return [Array<String>] Stylesheet files that are additionally loaded for the searchable full lists, e.g., Class List, Method List, File List @since 0.7.0",
    "label": "",
    "id": "693"
  },
  {
    "raw_code": "def javascripts_full_list\n  %w(js/jquery.js js/full_list.js)\nend",
    "comment": "@return [Array<String>] Javascript files that are additionally loaded for the searchable full lists, e.g., Class List, Method List, File List. @since 0.7.0",
    "label": "",
    "id": "694"
  },
  {
    "raw_code": "def html_lang\n  nil\nend",
    "comment": "Sets the HTML language lang=\"value\" where value is the value returned from this method. Defaults to nil which does not set the lang attribute.",
    "label": "",
    "id": "695"
  },
  {
    "raw_code": "def generate_assets\n  @object = Registry.root\n\n  layout = Object.new.extend(T('layout'))\n  (layout.javascripts + javascripts_full_list +\n      layout.stylesheets + stylesheets_full_list).uniq.each do |file|\n    asset(file, file(file, true))\n  end",
    "comment": "Generates all the javascript files, stylesheet files, menu lists (i.e. class, method, and file) based on the the values returned from the layout's menu_list method, and the frameset in the documentation output ",
    "label": "",
    "id": "696"
  },
  {
    "raw_code": "def generate_method_list\n  @items = prune_method_listing(Registry.all(:method), false)\n  @items = @items.reject {|m| m.name.to_s =~ /=$/ && m.is_attribute? }\n  @items = @items.sort_by {|m| m.name.to_s }\n  @list_title = \"Method List\"\n  @list_type = \"method\"\n  generate_list_contents\nend",
    "comment": "Generate a searchable method list in the output @see ModuleHelper#prune_method_listing",
    "label": "",
    "id": "697"
  },
  {
    "raw_code": "def generate_class_list\n  @items = options.objects if options.objects\n  @list_title = \"Class List\"\n  @list_type = \"class\"\n  generate_list_contents\nend",
    "comment": "Generate a searchable class list in the output",
    "label": "",
    "id": "698"
  },
  {
    "raw_code": "def generate_file_list\n  @file_list = true\n  @items = options.files\n  @list_title = \"File List\"\n  @list_type = \"file\"\n  generate_list_contents\n  @file_list = nil\nend",
    "comment": "Generate a searchable file list in the output",
    "label": "",
    "id": "699"
  },
  {
    "raw_code": "def generate_frameset\n  @javascripts = javascripts_full_list\n  @stylesheets = stylesheets_full_list\n  asset(url_for_frameset, erb(:frames))\nend",
    "comment": "Generate the frame documentation in the output",
    "label": "",
    "id": "700"
  },
  {
    "raw_code": "def indent\n    \"#{(@depth + 2) * 15}px\"\n  end",
    "comment": "@return [String] Returns a css pixel offset, e.g. \"30px\"",
    "label": "",
    "id": "701"
  },
  {
    "raw_code": "def class_list(root = Registry.root, tree = TreeContext.new)\n  out = String.new(\"\")\n  children = run_verifier(root.children)\n  if root == Registry.root\n    children += @items.select {|o| o.namespace.is_a?(CodeObjects::Proxy) }\n  end",
    "comment": "@return [String] HTML output of the classes to be displayed in the full_list_class template.",
    "label": "",
    "id": "702"
  },
  {
    "raw_code": "def a; end\n          # @param (see #a)\n          def b; end\n        end\n      eof\n\n      expect(log.io.string).to match(/error.*circular reference tag in `Foo#b'/)\n      expect(Registry.at('Foo#a').tags).to be_empty\n      expect(Registry.at('Foo#b').tags).to be_empty\n    end",
    "comment": "@param (see #b)",
    "label": "",
    "id": "703"
  },
  {
    "raw_code": "def bar; end\n        end",
    "comment": "@param (see #bar)",
    "label": "",
    "id": "704"
  },
  {
    "raw_code": "def a; end\n          # (see #a)\n          def b; end\n        end\n      eof\n\n      object = YARD::Registry.at('A#b')\n      expect(object.docstring).to eq 'Docstring'\n      expect(object.tags.map(&:tag_name)).to eq ['return']\n\n      YARD::Registry.clear\n    end",
    "comment": "Docstring @return [Boolean]",
    "label": "",
    "id": "705"
  },
  {
    "raw_code": "def foo(a) end\n      eof\n    end",
    "comment": "@param notaparam foo",
    "label": "",
    "id": "706"
  },
  {
    "raw_code": "def foo(a) end\n      eof\n    end",
    "comment": "@param a foo @param a foo",
    "label": "",
    "id": "707"
  },
  {
    "raw_code": "def foo(a) end\n        alias bar foo\n      eof\n    end",
    "comment": "@param a foo",
    "label": "",
    "id": "708"
  },
  {
    "raw_code": "def create_test_handler(name)\n      data[name] = {}\n\n      local_mock_handler_opts = mock_handler_opts\n      local_nodes = nodes\n      local_data = data[name]\n\n      Class.new YARD::Handlers::Ruby::Base do\n        include YARD::Handlers::Ruby::DecoratorHandlerMethods\n\n        handles method_call(:\"#{name}_decorator\")\n        namespace_only\n\n        process do\n          # process_decorator params written like this due to Ruby 1.8.\n          # A modern handler should splat local_nodes.\n          local_data[:return] =\n            process_decorator(*(local_nodes + [local_mock_handler_opts])) do |method, node, mname|\n              local_data[:method] = method\n              local_data[:node] = node\n              local_data[:name] = mname\n            end",
    "comment": "Create a YARD decorator handler. @param name [Symbol] name of the mock decorator",
    "label": "",
    "id": "709"
  },
  {
    "raw_code": "def make_defs(*symbols)\n      symbols.map do |s|\n        s = \"self.#{s}\" if mock_handler_opts[:scope] == :class\n        \"def #{s}; end\"\n      end.join(\"\\n\")\n    end",
    "comment": "Generate method definition. @param symbols [Symbol] method names @return [String] method definition code",
    "label": "",
    "id": "710"
  },
  {
    "raw_code": "def make_ast(code)\n      YARD::Parser::Ruby::RubyParser.new(code, nil).parse.ast\n    end",
    "comment": "Generate an AST for the given source code string.",
    "label": "",
    "id": "711"
  },
  {
    "raw_code": "def foo; end\n\n              # #{docstring}\n              mock_decorator :foo\n            end",
    "comment": "original docstring",
    "label": "",
    "id": "712"
  },
  {
    "raw_code": "def self.foo\n            'foo'\n          end",
    "comment": "{'private' unless visibility.to_sym == :private} != visibility",
    "label": "",
    "id": "713"
  },
  {
    "raw_code": "def self.bar\n          end",
    "comment": "== visibility",
    "label": "",
    "id": "714"
  },
  {
    "raw_code": "def self.baz\n          end",
    "comment": "== visibility from reopening class.",
    "label": "",
    "id": "715"
  },
  {
    "raw_code": "def self.bat\n          end",
    "comment": "{visibility}_class_method :baz {'private' unless visibility.to_sym == :private} != visibility from reopened class. (Verifies class was reopened.)",
    "label": "",
    "id": "716"
  },
  {
    "raw_code": "def parse(src, file = '(stdin)')\n  YARD::Registry.clear\n  parser = YARD::Parser::SourceParser.new(:c)\n  parser.file = file\n  parser.parse(StringIO.new(src))\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "717"
  },
  {
    "raw_code": "def tag_parse(content, object = nil, handler = nil)\n  @parser = DocstringParser.new\n  @parser.parse(content, object, handler)\n  @parser\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "718"
  },
  {
    "raw_code": "def foo; end\n      )\n      expect(Registry.at('#foo').docstring).to eq \"Docstring here\"\n      expect(Registry.at('#foo').file).to eq '(stdin)'\n    end",
    "comment": "Docstring here",
    "label": "",
    "id": "719"
  },
  {
    "raw_code": "def foo; end\n          def bar; end\n          def baz; end\n        end\n      eof\n      %w(foo bar baz).each do |name|\n        expect(Registry.at(\"Foo##{name}\").visibility).to eq :private\n      end\n    end if YARD::Parser::SourceParser.parser_type == :ruby\n  end",
    "comment": "@!visibility private",
    "label": "",
    "id": "720"
  },
  {
    "raw_code": "def me; \"VALUE\" end\n          end",
    "comment": "Docstring Docstring2",
    "label": "",
    "id": "721"
  },
  {
    "raw_code": "def me; \"VALUE\" end\n            end",
    "comment": "Docstring",
    "label": "",
    "id": "722"
  },
  {
    "raw_code": "def x; end\n        end",
    "comment": "ANOTHER PASS",
    "label": "",
    "id": "723"
  },
  {
    "raw_code": "def foo; end\n        end",
    "comment": "@!macro foo",
    "label": "",
    "id": "724"
  },
  {
    "raw_code": "def foo; end\n          def foo2; end\n\n          # @endgroup\n\n          def bar; end\n\n          # @group Group 2\n          def baz; end\n        end\n      eof\n\n      expect(Registry.at('A').groups).to eq ['Group Name', 'Group 2']\n      expect(Registry.at('A#bar').group).to be nil\n      expect(Registry.at('A#foo').group).to eq \"Group Name\"\n      expect(Registry.at('A#foo2').group).to eq \"Group Name\"\n      expect(Registry.at('A#baz').group).to eq \"Group 2\"\n    end\n\n    it \"handles multi-line class/module references\" do\n      YARD.parse_string <<-eof\n        class A::\n          B::C; end\n      eof\n      expect(Registry.all).to eq [P('A::B::C')]\n    end\n\n    it \"handles sclass definitions of multi-line class/module references\" do\n      YARD.parse_string <<-eof\n        class << A::\n          B::C\n          def foo; end\n        end\n      eof\n      expect(Registry.all.size).to eq 2\n      expect(Registry.at('A::B::C')).not_to be nil\n      expect(Registry.at('A::B::C.foo')).not_to be nil\n    end",
    "comment": "@group Group Name",
    "label": "",
    "id": "725"
  },
  {
    "raw_code": "def method; end\n      eof\n      expect(s.comments).to eq \"comment\\ncomment\\ncomment\"\n      expect(s.comments_range).to eq(1..3)\n\n      s = stmt <<-eof\n\n        # comment\n        # comment\n        def method; end\n      eof\n      expect(s.comments).to eq \"comment\\ncomment\"\n      expect(s.comments_range).to eq(2..3)\n\n      s = stmt <<-eof\n        # comment\n        # comment\n\n        def method; end\n      eof\n      expect(s.comments).to eq \"comment\\ncomment\"\n      expect(s.comments_range).to eq(1..2)\n\n      s = stmt <<-eof\n        # comment\n        def method; end\n      eof\n      expect(s.comments).to eq \"comment\"\n      expect(s.comments_range).to eq(1..1)\n\n      s = stmt <<-eof\n        def method; end # comment\n      eof\n      expect(s.comments).to eq \"comment\"\n      expect(s.comments_range).to eq(1..1)\n    end\n\n    it \"only looks up to two lines back for comments\" do\n      s = stmts <<-eof\n        # comments\n\n        # comments\n\n        def method; end\n      eof\n      expect(s[1].comments).to eq \"comments\"\n\n      s = stmts <<-eof\n        # comments\n\n\n        def method; end\n      eof\n      expect(s[1].comments).to eq nil\n\n      ss = stmts <<-eof\n        # comments\n\n\n        def method; end\n\n        # hello\n        def method2; end\n      eof\n      expect(ss[1].comments).to eq nil\n      expect(ss[2].comments).to eq 'hello'\n    end\n\n    it \"handles block comment followed by line comment\" do\n      ss = stmts <<-eof\n# comments1\n\n=begin\ncomments2\n=end\n# comments3\ndef hello; end\neof\n      expect(ss.last.comments).to eq \"comments3\"\n    end\n\n    it \"handles block comment followed by block comment\" do\n      ss = stmts <<-eof\n=begin\ncomments1\n=end\n=begin\ncomments2\n=end\ndef hello; end\neof\n      expect(ss.last.comments.strip).to eq \"comments2\"\n    end\n\n    it \"handles 1.9 lambda syntax with args\" do\n      src = \"->(a,b,c=1,*args,&block) { hello_world }\"\n      expect(stmt(src).source).to eq src\n    end\n\n    it \"handles 1.9 lambda syntax\" do\n      src = \"-> { hello_world }\"\n      expect(stmt(src).source).to eq src\n    end\n\n    it \"handles standard lambda syntax\" do\n      src = \"lambda { hello_world }\"\n      expect(stmt(src).source).to eq src\n    end\n\n    it \"throws a ParserSyntaxError on invalid code\" do\n      expect { stmt(\"Foo, bar.\") }.to raise_error(YARD::Parser::ParserSyntaxError)\n    end\n\n    it \"handles bare hashes as method parameters\" do\n      src = \"command :a => 1, :b => 2, :c => 3\"\n      expect(stmt(src).jump(:command)[1].source).to eq \":a => 1, :b => 2, :c => 3\"\n\n      src = \"command a: 1, b: 2, c: 3\"\n      expect(stmt(src).jump(:command)[1].source).to eq \"a: 1, b: 2, c: 3\"\n    end\n\n    it \"handles source for hash syntax\" do\n      src = \"{ :a => 1, :b => 2, :c => 3 }\"\n      expect(stmt(src).jump(:hash).source).to eq \"{ :a => 1, :b => 2, :c => 3 }\"\n    end\n\n    it \"handles an empty hash\" do\n      expect(stmt(\"{}\").jump(:hash).source).to eq \"{}\"\n    end",
    "comment": "comment comment comment",
    "label": "",
    "id": "726"
  },
  {
    "raw_code": "def foo; end\n\n          # end comment\n        end",
    "comment": " comment here",
    "label": "",
    "id": "727"
  },
  {
    "raw_code": "def foo\n                  x #{type} true\n                end",
    "comment": "Docstring2",
    "label": "",
    "id": "728"
  },
  {
    "raw_code": "def bar; end if true\n          end",
    "comment": "Docstring",
    "label": "",
    "id": "729"
  },
  {
    "raw_code": "def add(x) = x + 1\n        end",
    "comment": "Adds two numbers",
    "label": "",
    "id": "730"
  },
  {
    "raw_code": "def m(opts = {}) end\n      eof\n    end",
    "comment": "Comments @abstract override me @param [Hash] opts the options @option opts :key ('') hello @option opts :key2 (X) hello @return [String] the result @raise [Exception] Exception class @deprecated for great justice @see A @see http://url.com @see http://url.com Example @author Name @since 1.0 @version 1.0 @yield a block @yieldparam [String] a a value @yieldreturn [Hash] a hash @example Wash your car car.wash @example To kill a mockingbird a = String.new flip(a.reverse)",
    "label": "",
    "id": "731"
  },
  {
    "raw_code": "def foo; end\n\n        include Foo\n        extend Bar\n        include BarFooBar\n        include Baz::XYZ\n        include Baz::ABC\n      end",
    "comment": "This method is in A",
    "label": "",
    "id": "732"
  },
  {
    "raw_code": "def method_missing(*args) end\n        # @deprecated\n        def a; end\n\n        # constructor method!\n        def initialize(test) end\n      end\n\n      class C < A; end\n\n      class D\n        # @private\n        def initialize; end\n      end\n    eof\n  end\n\n  it \"renders html format correctly\" do\n    html_equals(Registry.at('A').format(html_options), :class001)\n  end",
    "comment": "HI",
    "label": "",
    "id": "733"
  },
  {
    "raw_code": "def m(x) end\n        alias x m\n      eof\n    end",
    "comment": "Comments @param [Hash] x the x argument @option x [String] :key1 (default) first key @option x [Symbol] :key2 second key @return [String] the result @raise [Exception] hi! @deprecated for great justice",
    "label": "",
    "id": "734"
  },
  {
    "raw_code": "def m(x) end\n      eof\n    end",
    "comment": "Comments @overload m(x, y) @param [String] x parameter x @param [Boolean] y parameter y",
    "label": "",
    "id": "735"
  },
  {
    "raw_code": "def m(*args) end\n      eof\n    end",
    "comment": "Method comments @overload m(x, y) Overload docstring @param [String] x parameter x @param [Boolean] y parameter y @overload m(x, y, z) @param [String] x parameter x @param [Boolean] y parameter y @param [Boolean] z parameter z",
    "label": "",
    "id": "736"
  },
  {
    "raw_code": "def m(*args) end\n      eof\n    end",
    "comment": "@return [void]",
    "label": "",
    "id": "737"
  },
  {
    "raw_code": "def m(*args) end\n      eof\n    end",
    "comment": "@overload m(a) @return [void] @overload m(b) @param [String] b hi",
    "label": "",
    "id": "738"
  },
  {
    "raw_code": "def m(x, y, *args, kword1: 123, kword2:, **) end\n      eof\n    end",
    "comment": "@param [String] x the x argument @param [Boolean] y the y argument @param [kword1] keyword 1 @param [kword2] keyword 2",
    "label": "",
    "id": "739"
  },
  {
    "raw_code": "def highlighted_ruby_regexp(*identifiers)\n    prefix = Regexp.escape '<pre class=\"code ruby\"><code class=\"ruby\">'\n    any_span_tag = '<span\\b'\n    escaped_identifiers = identifiers.map {|a| Regexp.escape(a) }\n\n    regexp_parts = [prefix, any_span_tag, escaped_identifiers]\n    regexp_str = regexp_parts.flatten.join(\".*\")\n    Regexp.compile(regexp_str)\n  end",
    "comment": "Works only with one-liners.",
    "label": "",
    "id": "740"
  },
  {
    "raw_code": "def a; end\n          end",
    "comment": "@overload a",
    "label": "",
    "id": "741"
  },
  {
    "raw_code": "def foo(&block); end\n      eof\n      expect(format_args(Registry.at('#foo'))).to eq ''\n    end",
    "comment": "@yield blah",
    "label": "",
    "id": "742"
  },
  {
    "raw_code": "def foo(&block); end\n      eof\n      expect(format_args(Registry.at('#foo'))).to eq ''\n    end",
    "comment": "@yieldparam blah test",
    "label": "",
    "id": "743"
  },
  {
    "raw_code": "def foo(&block) end\n      eof\n      expect(format_args(Registry.at('#foo'))).to eq '(&block)'\n    end",
    "comment": "@yield [a,b] @yieldparam a test @param block test",
    "label": "",
    "id": "744"
  },
  {
    "raw_code": "def foo; end\n      eof\n      expect(format_block(Registry.at('#foo'))).to eq \"{|_self| ... }\"\n    end",
    "comment": "@yieldparam _self me!",
    "label": "",
    "id": "745"
  },
  {
    "raw_code": "def foo; end\n\n        # @yield blah\n        def foo2; end\n      eof\n      expect(format_block(Registry.at('#foo'))).to eq \"{|a| ... }\"\n      expect(format_block(Registry.at('#foo2'))).to eq \"{ ... }\"\n    end\n\n    it \"shows block for method with @yield and types\" do\n      YARD.parse_string <<-'eof'\n        # @yield [a, b, c] blah\n        # @yieldparam a\n        def foo; end\n      eof\n      expect(format_block(Registry.at('#foo'))).to eq \"{|a, b, c| ... }\"\n    end\n  end",
    "comment": "@yield blah @yieldparam a",
    "label": "",
    "id": "746"
  },
  {
    "raw_code": "def foo; end\n    eof\n    expect(trim(signature(Registry.at('#foo')))).to eq @results[:single]\n  end",
    "comment": "@return [String]",
    "label": "",
    "id": "747"
  },
  {
    "raw_code": "def foo; end\n    eof\n    expect(trim(signature(Registry.at('#foo')))).to eq @results[:two_types]\n  end",
    "comment": "@return [String, Symbol]",
    "label": "",
    "id": "748"
  },
  {
    "raw_code": "def foo; end\n    eof\n    expect(trim(signature(Registry.at('#foo')))).to eq @results[:two_types_multitag]\n  end",
    "comment": "@return [String] @return [Symbol]",
    "label": "",
    "id": "749"
  },
  {
    "raw_code": "def foo; end\n    eof\n    expect(trim(signature(Registry.at('#foo')))).to eq @results[:type_nil]\n  end",
    "comment": "@return [Type, nil]",
    "label": "",
    "id": "750"
  },
  {
    "raw_code": "def foo; end\n    eof\n    expect(trim(signature(Registry.at('#foo')))).to eq @results[:type_nil]\n  end",
    "comment": "@return [Type, nil] @return [nil]",
    "label": "",
    "id": "751"
  },
  {
    "raw_code": "def foo; end\n    eof\n    expect(trim(signature(Registry.at('#foo')))).to eq @results[:type_array]\n  end",
    "comment": "@return [Type, <Type>]",
    "label": "",
    "id": "752"
  },
  {
    "raw_code": "def foo; end\n    eof\n    expect(trim(signature(Registry.at('#foo')))).to eq @results[:multitype]\n  end",
    "comment": "@return [Type, <Type>] @return [AnotherType]",
    "label": "",
    "id": "753"
  },
  {
    "raw_code": "def foo; end\n    eof\n    expect(trim(signature(Registry.at('#foo')))).to eq @results[:void]\n  end",
    "comment": "@return [void]",
    "label": "",
    "id": "754"
  },
  {
    "raw_code": "def foo; end\n    eof\n    expect(trim(signature(Registry.at('#foo')))).to eq @results[:hide_void]\n  end",
    "comment": "@return [void]",
    "label": "",
    "id": "755"
  },
  {
    "raw_code": "def foo; end\n    eof\n    expect(trim(signature(Registry.at('#foo').tag(:overload)))).to eq @results[:empty_overload]\n  end",
    "comment": "@overload foobar Hello world @return [String]",
    "label": "",
    "id": "756"
  },
  {
    "raw_code": "def bar; end\n        end",
    "comment": "@overload bar",
    "label": "",
    "id": "757"
  },
  {
    "raw_code": "def foo; end\n    eof\n    @stats.run('--list-undoc')\n    expect(@output.string).to eq \"Files:           1\\n\" \\\n                                 \"Modules:         0 (    0 undocumented)\\n\" \\\n                                 \"Classes:         0 (    0 undocumented)\\n\" \\\n                                 \"Constants:       0 (    0 undocumented)\\n\" \\\n                                 \"Attributes:      0 (    0 undocumented)\\n\" \\\n                                 \"Methods:         1 (    0 undocumented)\\n\" \\\n                                 \" 100.00% documented\\n\"\n  end",
    "comment": "documentation",
    "label": "",
    "id": "758"
  },
  {
    "raw_code": "def mock_file(filename, content = nil)\n    allow(File).to receive(:exist?).with(filename).and_return(true)\n    allow(File).to receive(:read_binary).with(filename).and_return(content) if content\n    filename_e = File.expand_path(filename)\n    mock_file(filename_e) unless filename_e == filename\n  end",
    "comment": "Mocks the existence of a file.",
    "label": "",
    "id": "759"
  },
  {
    "raw_code": "def foo(a, b, c)\n          source_code_here\n        end",
    "comment": "A docstring @return [String] a tag",
    "label": "",
    "id": "760"
  },
  {
    "raw_code": "def foo; end\n      eof\n      foo_c = MethodObject.new(:root, :foo, :class)\n      foo_i = Registry.at('#foo')\n      foo_i.copy_to(foo_c)\n      expect(foo_i.tags).not_to eq foo_c.tags\n      expect(foo_c.tags.first.object).to eq foo_c\n    end",
    "comment": "@return [String] a tag",
    "label": "",
    "id": "761"
  }
]