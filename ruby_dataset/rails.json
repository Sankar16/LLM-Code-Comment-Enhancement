[
  {
    "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of Action Cable as a `Gem::Version`.",
    "label": "",
    "id": "1"
  },
  {
    "raw_code": "def disconnect(reconnect: true)\n        server.broadcast internal_channel, { type: \"disconnect\", reconnect: reconnect }\n      end",
    "comment": "Uses the internal channel to disconnect the connection.",
    "label": "",
    "id": "2"
  },
  {
    "raw_code": "def assert_broadcasts(stream, number, &block)\n      if block_given?\n        new_messages = new_broadcasts_from(broadcasts(stream), stream, \"assert_broadcasts\", &block)\n\n        actual_count = new_messages.size\n        assert_equal number, actual_count, \"#{number} broadcasts to #{stream} expected, but #{actual_count} were sent\"\n      else\n        actual_count = broadcasts(stream).size\n        assert_equal number, actual_count, \"#{number} broadcasts to #{stream} expected, but #{actual_count} were sent\"\n      end",
    "comment": "Asserts that the number of broadcasted messages to the stream matches the given number.  def test_broadcasts assert_broadcasts 'messages', 0 ActionCable.server.broadcast 'messages', { text: 'hello' } assert_broadcasts 'messages', 1 ActionCable.server.broadcast 'messages', { text: 'world' } assert_broadcasts 'messages', 2 end  If a block is passed, that block should cause the specified number of messages to be broadcasted.  def test_broadcasts_again assert_broadcasts('messages', 1) do ActionCable.server.broadcast 'messages', { text: 'hello' } end  assert_broadcasts('messages', 2) do ActionCable.server.broadcast 'messages', { text: 'hi' } ActionCable.server.broadcast 'messages', { text: 'how are you?' } end end ",
    "label": "",
    "id": "3"
  },
  {
    "raw_code": "def assert_no_broadcasts(stream, &block)\n      assert_broadcasts stream, 0, &block\n    end",
    "comment": "Asserts that no messages have been sent to the stream.  def test_no_broadcasts assert_no_broadcasts 'messages' ActionCable.server.broadcast 'messages', { text: 'hi' } assert_broadcasts 'messages', 1 end  If a block is passed, that block should not cause any message to be sent.  def test_broadcasts_again assert_no_broadcasts 'messages' do # No job messages should be sent from this block end end  Note: This assertion is simply a shortcut for:  assert_broadcasts 'messages', 0, &block ",
    "label": "",
    "id": "4"
  },
  {
    "raw_code": "def capture_broadcasts(stream, &block)\n      new_broadcasts_from(broadcasts(stream), stream, \"capture_broadcasts\", &block).map { |m| ActiveSupport::JSON.decode(m) }\n    end",
    "comment": "Returns the messages that are broadcasted in the block.  def test_broadcasts messages = capture_broadcasts('messages') do ActionCable.server.broadcast 'messages', { text: 'hi' } ActionCable.server.broadcast 'messages', { text: 'how are you?' } end assert_equal 2, messages.length assert_equal({ text: 'hi' }, messages.first) assert_equal({ text: 'how are you?' }, messages.last) end ",
    "label": "",
    "id": "5"
  },
  {
    "raw_code": "def assert_broadcast_on(stream, data, &block)\n      # Encode to JSON and back–we want to use this value to compare with decoded\n      # JSON. Comparing JSON strings doesn't work due to the order if the keys.\n      serialized_msg =\n        ActiveSupport::JSON.decode(ActiveSupport::JSON.encode(data))\n\n      new_messages = broadcasts(stream)\n      if block_given?\n        new_messages = new_broadcasts_from(new_messages, stream, \"assert_broadcast_on\", &block)\n      end",
    "comment": "Asserts that the specified message has been sent to the stream.  def test_assert_transmitted_message ActionCable.server.broadcast 'messages', text: 'hello' assert_broadcast_on('messages', text: 'hello') end  If a block is passed, that block should cause a message with the specified data to be sent.  def test_assert_broadcast_on_again assert_broadcast_on('messages', text: 'hello') do ActionCable.server.broadcast 'messages', text: 'hello' end end ",
    "label": "",
    "id": "6"
  },
  {
    "raw_code": "def self.version\n    gem_version\n  end",
    "comment": "Returns the currently loaded version of Action Cable as a `Gem::Version`.",
    "label": "",
    "id": "7"
  },
  {
    "raw_code": "def action_methods\n          @action_methods ||= begin\n            # All public instance methods of this class, including ancestors\n            methods = (public_instance_methods(true) -\n              # Except for public instance methods of Base and its ancestors\n              ActionCable::Channel::Base.public_instance_methods(true) +\n              # Be sure to include shadowed public instance methods of this class\n              public_instance_methods(false)).uniq\n\n            methods.reject! { |m| m.start_with?(\"_\") }\n            methods.map!(&:name)\n            methods.to_set\n          end",
    "comment": "A list of method names that should be considered actions. This includes all public instance methods on a channel, less any internal methods (defined on Base), adding back in any methods that are internal, but still exist on the class itself.  #### Returns *   `Set` - A set of all methods that should be considered actions.",
    "label": "",
    "id": "8"
  },
  {
    "raw_code": "def clear_action_methods! # :doc:\n            @action_methods = nil\n          end",
    "comment": "action_methods are cached and there is sometimes need to refresh them. ::clear_action_methods! allows you to do that, so next time you run action_methods, they will be recalculated.",
    "label": "",
    "id": "9"
  },
  {
    "raw_code": "def method_added(name) # :doc:\n            super\n            clear_action_methods!\n          end",
    "comment": "Refresh the cached action_methods when a new action_method is added.",
    "label": "",
    "id": "10"
  },
  {
    "raw_code": "def perform_action(data)\n        action = extract_action(data)\n\n        if processable_action?(action)\n          payload = { channel_class: self.class.name, action: action, data: data }\n          ActiveSupport::Notifications.instrument(\"perform_action.action_cable\", payload) do\n            dispatch_action(action, data)\n          end",
    "comment": "Extract the action name from the passed data and process it via the channel. The process will ensure that the action requested is a public method on the channel declared by the user (so not one of the callbacks like #subscribed).",
    "label": "",
    "id": "11"
  },
  {
    "raw_code": "def subscribe_to_channel\n        run_callbacks :subscribe do\n          subscribed\n        end",
    "comment": "This method is called after subscription has been added to the connection and confirms or rejects the subscription.",
    "label": "",
    "id": "12"
  },
  {
    "raw_code": "def unsubscribe_from_channel # :nodoc:\n        @unsubscribed = true\n        run_callbacks :unsubscribe do\n          unsubscribed\n        end",
    "comment": "Called by the cable connection when it's cut, so the channel has a chance to cleanup with callbacks. This method is not intended to be called directly by the user. Instead, override the #unsubscribed callback.",
    "label": "",
    "id": "13"
  },
  {
    "raw_code": "def subscribed # :doc:\n          # Override in subclasses\n        end",
    "comment": "Called once a consumer has become a subscriber of the channel. Usually the place to set up any streams you want this channel to be sending to the subscriber.",
    "label": "",
    "id": "14"
  },
  {
    "raw_code": "def unsubscribed # :doc:\n          # Override in subclasses\n        end",
    "comment": "Called once a consumer has cut its cable connection. Can be used for cleaning up connections or marking users as offline or the like.",
    "label": "",
    "id": "15"
  },
  {
    "raw_code": "def transmit(data, via: nil) # :doc:\n          logger.debug do\n            status = \"#{self.class.name} transmitting #{data.inspect.truncate(300)}\"\n            status += \" (via #{via})\" if via\n            status\n          end",
    "comment": "Transmit a hash of data to the subscriber. The hash will automatically be wrapped in a JSON envelope with the proper channel identifier marked as the recipient.",
    "label": "",
    "id": "16"
  },
  {
    "raw_code": "def broadcast_to(broadcastables, message)\n          ActionCable.server.broadcast(broadcasting_for(broadcastables), message)\n        end",
    "comment": "Broadcast a hash to a unique broadcasting for this array of `broadcastables` in this channel.",
    "label": "",
    "id": "17"
  },
  {
    "raw_code": "def broadcasting_for(broadcastables)\n          serialize_broadcasting([ channel_name ] + Array(broadcastables))\n        end",
    "comment": "Returns a unique broadcasting identifier for this `model` in this channel:  CommentsChannel.broadcasting_for(\"all\") # => \"comments:all\"  You can pass an array of objects as a target (e.g. Active Record model), and it would be serialized into a string under the hood.",
    "label": "",
    "id": "18"
  },
  {
    "raw_code": "def after_subscribe(*methods, &block)\n          set_callback(:subscribe, :after, *methods, &block)\n        end",
    "comment": "This callback will be triggered after the Base#subscribed method is called, even if the subscription was rejected with the Base#reject method.  To trigger the callback only on successful subscriptions, use the Base#subscription_rejected? method:  after_subscribe :my_method, unless: :subscription_rejected? ",
    "label": "",
    "id": "19"
  },
  {
    "raw_code": "def channel_name\n          @channel_name ||= name.delete_suffix(\"Channel\").gsub(\"::\", \":\").underscore\n        end",
    "comment": "Returns the name of the channel, underscored, without the `Channel` ending. If the channel is in a namespace, then the namespaces are represented by single colon separators in the channel name.  ChatChannel.channel_name # => 'chat' Chats::AppearancesChannel.channel_name # => 'chats:appearances' FooChats::BarAppearancesChannel.channel_name # => 'foo_chats:bar_appearances'",
    "label": "",
    "id": "20"
  },
  {
    "raw_code": "def periodically(callback_or_method_name = nil, every:, &block)\n          callback =\n            if block_given?\n              raise ArgumentError, \"Pass a block or provide a callback arg, not both\" if callback_or_method_name\n              block\n            else\n              case callback_or_method_name\n              when Proc\n                callback_or_method_name\n              when Symbol\n                -> { __send__ callback_or_method_name }\n              else\n                raise ArgumentError, \"Expected a Symbol method name or a Proc, got #{callback_or_method_name.inspect}\"\n              end",
    "comment": "Periodically performs a task on the channel, like updating an online user counter, polling a backend for new status messages, sending regular \"heartbeat\" messages, or doing some internal work and giving progress updates.  Pass a method name or lambda argument or provide a block to call. Specify the calling period in seconds using the `every:` keyword argument.  periodically :transmit_progress, every: 5.seconds  periodically every: 3.minutes do transmit action: :update_count, count: current_count end ",
    "label": "",
    "id": "21"
  },
  {
    "raw_code": "def stream_from(broadcasting, callback = nil, coder: nil, &block)\n        return if unsubscribed?\n\n        broadcasting = String(broadcasting)\n\n        # Don't send the confirmation until pubsub#subscribe is successful\n        defer_subscription_confirmation!\n\n        # Build a stream handler by wrapping the user-provided callback with a decoder\n        # or defaulting to a JSON-decoding retransmitter.\n        handler = worker_pool_stream_handler(broadcasting, callback || block, coder: coder)\n        streams[broadcasting] = handler\n\n        connection.server.event_loop.post do\n          pubsub.subscribe(broadcasting, handler, lambda do\n            ensure_confirmation_sent\n            logger.info \"#{self.class.name} is streaming from #{broadcasting}\"\n          end)\n        end",
    "comment": "Start streaming from the named `broadcasting` pubsub queue. Optionally, you can pass a `callback` that'll be used instead of the default of just transmitting the updates straight to the subscriber. Pass `coder: ActiveSupport::JSON` to decode messages as JSON before passing to the callback. Defaults to `coder: nil` which does no decoding, passes raw messages.",
    "label": "",
    "id": "22"
  },
  {
    "raw_code": "def stream_for(broadcastables, callback = nil, coder: nil, &block)\n        stream_from(broadcasting_for(broadcastables), callback || block, coder: coder)\n      end",
    "comment": "Start streaming the pubsub queue for the `broadcastables` in this channel. Optionally, you can pass a `callback` that'll be used instead of the default of just transmitting the updates straight to the subscriber.  Pass `coder: ActiveSupport::JSON` to decode messages as JSON before passing to the callback. Defaults to `coder: nil` which does no decoding, passes raw messages.",
    "label": "",
    "id": "23"
  },
  {
    "raw_code": "def stop_stream_from(broadcasting)\n        callback = streams.delete(broadcasting)\n        if callback\n          pubsub.unsubscribe(broadcasting, callback)\n          logger.info \"#{self.class.name} stopped streaming from #{broadcasting}\"\n        end",
    "comment": "Unsubscribes streams from the named `broadcasting`.",
    "label": "",
    "id": "24"
  },
  {
    "raw_code": "def stop_stream_for(model)\n        stop_stream_from(broadcasting_for(model))\n      end",
    "comment": "Unsubscribes streams for the `model`.",
    "label": "",
    "id": "25"
  },
  {
    "raw_code": "def stop_all_streams\n        streams.each do |broadcasting, callback|\n          pubsub.unsubscribe broadcasting, callback\n          logger.info \"#{self.class.name} stopped streaming from #{broadcasting}\"\n        end.clear\n      end",
    "comment": "Unsubscribes all streams associated with this channel from the pubsub queue.",
    "label": "",
    "id": "26"
  },
  {
    "raw_code": "def stream_or_reject_for(model)\n        if model\n          stream_for model\n        else\n          reject\n        end",
    "comment": "Calls stream_for with the given `model` if it's present to start streaming, otherwise rejects the subscription.",
    "label": "",
    "id": "27"
  },
  {
    "raw_code": "def worker_pool_stream_handler(broadcasting, user_handler, coder: nil)\n          handler = stream_handler(broadcasting, user_handler, coder: coder)\n\n          -> message do\n            connection.worker_pool.async_invoke handler, :call, message, connection: connection\n          end",
    "comment": "Always wrap the outermost handler to invoke the user handler on the worker pool rather than blocking the event loop.",
    "label": "",
    "id": "28"
  },
  {
    "raw_code": "def stream_handler(broadcasting, user_handler, coder: nil)\n          if user_handler\n            stream_decoder user_handler, coder: coder\n          else\n            default_stream_handler broadcasting, coder: coder\n          end",
    "comment": "May be overridden to add instrumentation, logging, specialized error handling, or other forms of handler decoration.  TODO: Tests demonstrating this.",
    "label": "",
    "id": "29"
  },
  {
    "raw_code": "def default_stream_handler(broadcasting, coder:)\n          coder ||= ActiveSupport::JSON\n          stream_transmitter stream_decoder(coder: coder), broadcasting: broadcasting\n        end",
    "comment": "May be overridden to change the default stream handling behavior which decodes JSON and transmits to the client.  TODO: Tests demonstrating this.  TODO: Room for optimization. Update transmit API to be coder-aware so we can no-op when pubsub and connection are both JSON-encoded. Then we can skip decode+encode if we're just proxying messages.",
    "label": "",
    "id": "30"
  },
  {
    "raw_code": "def start_periodic_timers; end\n      alias stop_periodic_timers start_periodic_timers\n    end",
    "comment": "Make periodic timers no-op",
    "label": "",
    "id": "31"
  },
  {
    "raw_code": "def stub_connection(identifiers = {})\n          @connection = ConnectionStub.new(identifiers)\n        end",
    "comment": "Set up test connection with the specified identifiers:  class ApplicationCable < ActionCable::Connection::Base identified_by :user, :token end  stub_connection(user: users[:john], token: 'my-secret-token')",
    "label": "",
    "id": "32"
  },
  {
    "raw_code": "def subscribe(params = {})\n          @connection ||= stub_connection\n          @subscription = self.class.channel_class.new(connection, CHANNEL_IDENTIFIER, params.with_indifferent_access)\n          @subscription.singleton_class.include(ChannelStub)\n          @subscription.subscribe_to_channel\n          @subscription\n        end",
    "comment": "Subscribe to the channel under test. Optionally pass subscription parameters as a Hash.",
    "label": "",
    "id": "33"
  },
  {
    "raw_code": "def unsubscribe\n          check_subscribed!\n          subscription.unsubscribe_from_channel\n        end",
    "comment": "Unsubscribe the subscription under test.",
    "label": "",
    "id": "34"
  },
  {
    "raw_code": "def perform(action, data = {})\n          check_subscribed!\n          subscription.perform_action(data.stringify_keys.merge(\"action\" => action.to_s))\n        end",
    "comment": "Perform action on a channel.  NOTE: Must be subscribed.",
    "label": "",
    "id": "35"
  },
  {
    "raw_code": "def transmissions\n          # Return only directly sent message (via #transmit)\n          connection.transmissions.filter_map { |data| data[\"message\"] }\n        end",
    "comment": "Returns messages transmitted into channel",
    "label": "",
    "id": "36"
  },
  {
    "raw_code": "def assert_broadcasts(stream_or_object, *args)\n          super(broadcasting_for(stream_or_object), *args)\n        end",
    "comment": "Enhance TestHelper assertions to handle non-String broadcastings",
    "label": "",
    "id": "37"
  },
  {
    "raw_code": "def assert_no_streams\n          assert subscription.streams.empty?, \"No streams started was expected, but #{subscription.streams.count} found\"\n        end",
    "comment": "Asserts that no streams have been started.  def test_assert_no_started_stream subscribe assert_no_streams end ",
    "label": "",
    "id": "38"
  },
  {
    "raw_code": "def assert_has_stream(stream)\n          assert subscription.streams.include?(stream), \"Stream #{stream} has not been started\"\n        end",
    "comment": "Asserts that the specified stream has been started.  def test_assert_started_stream subscribe assert_has_stream 'messages' end ",
    "label": "",
    "id": "39"
  },
  {
    "raw_code": "def assert_has_stream_for(object)\n          assert_has_stream(broadcasting_for(object))\n        end",
    "comment": "Asserts that the specified stream for a model has started.  def test_assert_started_stream_for subscribe id: 42 assert_has_stream_for User.find(42) end ",
    "label": "",
    "id": "40"
  },
  {
    "raw_code": "def assert_has_no_stream(stream)\n          assert subscription.streams.exclude?(stream), \"Stream #{stream} has been started\"\n        end",
    "comment": "Asserts that the specified stream has not been started.  def test_assert_no_started_stream subscribe assert_has_no_stream 'messages' end ",
    "label": "",
    "id": "41"
  },
  {
    "raw_code": "def assert_has_no_stream_for(object)\n          assert_has_no_stream(broadcasting_for(object))\n        end",
    "comment": "Asserts that the specified stream for a model has not started.  def test_assert_no_started_stream_for subscribe id: 41 assert_has_no_stream_for User.find(42) end ",
    "label": "",
    "id": "42"
  },
  {
    "raw_code": "def reject_unauthorized_connection\n        logger.error \"An unauthorized connection attempt was rejected\"\n        raise UnauthorizedError\n      end",
    "comment": "Closes the WebSocket connection if it is open and returns an \"unauthorized\" reason.",
    "label": "",
    "id": "43"
  },
  {
    "raw_code": "def process # :nodoc:\n        logger.info started_request_message\n\n        if websocket.possible? && allow_request_origin?\n          respond_to_successful_request\n        else\n          respond_to_invalid_request\n        end",
    "comment": "Called by the server when a new WebSocket connection is established. This configures the callbacks intended for overwriting by the user. This method should not be called directly -- instead rely upon on the #connect (and #disconnect) callbacks.",
    "label": "",
    "id": "44"
  },
  {
    "raw_code": "def receive(websocket_message) # :nodoc:\n        send_async :dispatch_websocket_message, websocket_message\n      end",
    "comment": "Decodes WebSocket messages and dispatches them to subscribed channels. WebSocket message transfer encoding is always JSON.",
    "label": "",
    "id": "45"
  },
  {
    "raw_code": "def close(reason: nil, reconnect: true)\n        transmit(\n          type: ActionCable::INTERNAL[:message_types][:disconnect],\n          reason: reason,\n          reconnect: reconnect\n        )\n        websocket.close\n      end",
    "comment": "Close the WebSocket connection.",
    "label": "",
    "id": "46"
  },
  {
    "raw_code": "def send_async(method, *arguments)\n        worker_pool.async_invoke(self, method, *arguments)\n      end",
    "comment": "Invoke a method on the connection asynchronously through the pool of thread workers.",
    "label": "",
    "id": "47"
  },
  {
    "raw_code": "def statistics\n        {\n          identifier: connection_identifier,\n          started_at: @started_at,\n          subscriptions: subscriptions.identifiers,\n          request_id: @env[\"action_dispatch.request_id\"]\n        }\n      end",
    "comment": "Return a basic hash of statistics for the connection keyed with `identifier`, `started_at`, `subscriptions`, and `request_id`. This can be returned by a health check against the connection.",
    "label": "",
    "id": "48"
  },
  {
    "raw_code": "def request # :doc:\n          @request ||= begin\n            environment = Rails.application.env_config.merge(env) if defined?(Rails.application) && Rails.application\n            ActionDispatch::Request.new(environment || env)\n          end",
    "comment": "The request that initiated the WebSocket connection is available here. This gives access to the environment, cookies, etc.",
    "label": "",
    "id": "49"
  },
  {
    "raw_code": "def cookies # :doc:\n          request.cookie_jar\n        end",
    "comment": "The cookies of the request that initiated the WebSocket connection. Useful for performing authorization checks.",
    "label": "",
    "id": "50"
  },
  {
    "raw_code": "def new_tagged_logger\n          TaggedLoggerProxy.new server.logger,\n            tags: server.config.log_tags.map { |tag| tag.respond_to?(:call) ? tag.call(request) : tag.to_s.camelize }\n        end",
    "comment": "Tags are declared in the server but computed in the connection. This allows us per-connection tailored tags.",
    "label": "",
    "id": "51"
  },
  {
    "raw_code": "def identified_by(*identifiers)\n          Array(identifiers).each { |identifier| attr_accessor identifier }\n          self.identifiers += identifiers\n        end",
    "comment": "Mark a key as being a connection identifier index that can then be used to find the specific connection again later. Common identifiers are current_user and current_account, but could be anything, really.  Note that anything marked as an identifier will automatically create a delegate by the same name on any channel instances created off the connection.",
    "label": "",
    "id": "52"
  },
  {
    "raw_code": "def connection_identifier\n        unless defined? @connection_identifier\n          @connection_identifier = connection_gid identifiers.filter_map { |id| instance_variable_get(\"@#{id}\") }\n        end",
    "comment": "Return a single connection identifier that combines the value of all the registered identifiers into a single gid.",
    "label": "",
    "id": "53"
  },
  {
    "raw_code": "def assert_reject_connection(&block)\n        assert_raises(Authorization::UnauthorizedError, \"Expected to reject connection but no rejection was made\", &block)\n      end",
    "comment": "Asserts that the connection is rejected (via `reject_unauthorized_connection`).  # Asserts that connection without user_id fails assert_reject_connection { connect params: { user_id: '' } }",
    "label": "",
    "id": "54"
  },
  {
    "raw_code": "def connect(path = ActionCable.server.config.mount_path, **request_params)\n          path ||= DEFAULT_PATH\n\n          connection = self.class.connection_class.allocate\n          connection.singleton_class.include(TestConnection)\n          connection.send(:initialize, build_test_request(path, **request_params))\n          connection.connect if connection.respond_to?(:connect)\n\n          # Only set instance variable if connected successfully\n          @connection = connection\n        end",
    "comment": "Performs connection attempt to exert #connect on the connection under test.  Accepts request path as the first argument and the following request options:  *   params – URL parameters (Hash) *   headers – request headers (Hash) *   session – session data (Hash) *   env – additional Rack env configuration (Hash)",
    "label": "",
    "id": "55"
  },
  {
    "raw_code": "def disconnect\n          raise \"Must be connected!\" if connection.nil?\n\n          connection.disconnect if connection.respond_to?(:disconnect)\n          @connection = nil\n        end",
    "comment": "Exert #disconnect on the connection under test.",
    "label": "",
    "id": "56"
  },
  {
    "raw_code": "def action_cable_meta_tag\n        tag \"meta\", name: \"action-cable-url\", content: (\n          ActionCable.server.config.url ||\n          ActionCable.server.config.mount_path ||\n          raise(\"No Action Cable URL configured -- please configure this at config.action_cable.url\")\n        )\n      end",
    "comment": "Returns an \"action-cable-url\" meta tag with the value of the URL specified in your configuration. Ensure this is above your JavaScript tag:  <head> <%= action_cable_meta_tag %> <%= javascript_include_tag 'application', 'data-turbo-track' => 'reload' %> </head>  This is then used by Action Cable to determine the URL of your WebSocket server. Your JavaScript can then connect to the server without needing to specify the URL directly:  import Cable from \"@rails/actioncable\" window.Cable = Cable window.App = {} App.cable = Cable.createConsumer()  Make sure to specify the correct server location in each of your environment config files:  config.action_cable.mount_path = \"/cable123\" <%= action_cable_meta_tag %> would render: => <meta name=\"action-cable-url\" content=\"/cable123\" />  config.action_cable.url = \"ws://actioncable.com\" <%= action_cable_meta_tag %> would render: => <meta name=\"action-cable-url\" content=\"ws://actioncable.com\" /> ",
    "label": "",
    "id": "57"
  },
  {
    "raw_code": "def remote_connections\n        @remote_connections || @mutex.synchronize { @remote_connections ||= RemoteConnections.new(self) }\n      end",
    "comment": "Gateway to RemoteConnections. See that class for details.",
    "label": "",
    "id": "58"
  },
  {
    "raw_code": "def worker_pool\n        @worker_pool || @mutex.synchronize { @worker_pool ||= ActionCable::Server::Worker.new(max_size: config.worker_pool_size) }\n      end",
    "comment": "The worker pool is where we run connection callbacks and channel actions. We do as little as possible on the server's main thread. The worker pool is an executor service that's backed by a pool of threads working from a task queue. The thread pool size maxes out at 4 worker threads by default. Tune the size yourself with `config.action_cable.worker_pool_size`.  Using Active Record, Redis, etc within your channel actions means you'll get a separate connection from each thread in the worker pool. Plan your deployment accordingly: 5 servers each running 5 Puma workers each running an 8-thread worker pool means at least 200 database connections.  Also, ensure that your database connection pool size is as least as large as your worker pool size. Otherwise, workers may oversubscribe the database connection pool and block while they wait for other workers to release their connections. Use a smaller worker pool or a larger database connection pool instead.",
    "label": "",
    "id": "59"
  },
  {
    "raw_code": "def pubsub\n        @pubsub || @mutex.synchronize { @pubsub ||= config.pubsub_adapter.new(self) }\n      end",
    "comment": "Adapter used for all streams/broadcasting.",
    "label": "",
    "id": "60"
  },
  {
    "raw_code": "def connection_identifiers\n        config.connection_class.call.identifiers\n      end",
    "comment": "All of the identifiers applied to the connection class associated with this server.",
    "label": "",
    "id": "61"
  },
  {
    "raw_code": "def broadcast(broadcasting, message, coder: ActiveSupport::JSON)\n        broadcaster_for(broadcasting, coder: coder).broadcast(message)\n      end",
    "comment": "Broadcast a hash directly to a named `broadcasting`. This will later be JSON encoded.",
    "label": "",
    "id": "62"
  },
  {
    "raw_code": "def broadcaster_for(broadcasting, coder: ActiveSupport::JSON)\n        Broadcaster.new(self, String(broadcasting), coder: coder)\n      end",
    "comment": "Returns a broadcaster for a named `broadcasting` that can be reused. Useful when you have an object that may need multiple spots to transmit to a specific broadcasting over and over.",
    "label": "",
    "id": "63"
  },
  {
    "raw_code": "def pubsub_adapter\n        adapter = (cable.fetch(\"adapter\") { \"redis\" })\n\n        # Require the adapter itself and give useful feedback about\n        #     1. Missing adapter gems and\n        #     2. Adapter gems' missing dependencies.\n        path_to_adapter = \"action_cable/subscription_adapter/#{adapter}\"\n        begin\n          require path_to_adapter\n        rescue LoadError => e\n          # We couldn't require the adapter itself. Raise an exception that points out\n          # config typos and missing gems.\n          if e.path == path_to_adapter\n            # We can assume that a non-builtin adapter was specified, so it's either\n            # misspelled or missing from Gemfile.\n            raise e.class, \"Could not load the '#{adapter}' Action Cable pubsub adapter. Ensure that the adapter is spelled correctly in config/cable.yml and that you've added the necessary adapter gem to your Gemfile.\", e.backtrace\n\n          # Bubbled up from the adapter require. Prefix the exception message with some\n          # guidance about how to address it and reraise.\n          else\n            raise e.class, \"Error loading the '#{adapter}' Action Cable pubsub adapter. Missing a gem it depends on? #{e.message}\", e.backtrace\n          end",
    "comment": "Returns constant of subscription adapter specified in config/cable.yml. If the adapter cannot be found, this will default to the Redis adapter. Also makes sure proper dependencies are required.",
    "label": "",
    "id": "64"
  },
  {
    "raw_code": "def setup_heartbeat_timer\n        @heartbeat_timer ||= event_loop.timer(BEAT_INTERVAL) do\n          event_loop.post { connections.each(&:beat) }\n        end",
    "comment": "WebSocket connection implementations differ on when they'll mark a connection as stale. We basically never want a connection to go stale, as you then can't rely on being able to communicate with the connection. To solve this, a 3 second heartbeat runs on all connections. If the beat fails, we automatically disconnect.",
    "label": "",
    "id": "65"
  },
  {
    "raw_code": "def halt\n        @executor.shutdown\n      end",
    "comment": "Stop processing work: any work that has not already started running will be discarded from the queue",
    "label": "",
    "id": "66"
  },
  {
    "raw_code": "def channel_with_prefix(channel)\n          [@server.config.cable[:channel_prefix], channel].compact.join(\":\")\n        end",
    "comment": "Returns the channel name, including channel_prefix specified in cable.yml",
    "label": "",
    "id": "67"
  },
  {
    "raw_code": "def recent?\n            Time.at(timestamp) >= 2.minutes.ago\n          end",
    "comment": "Allow for 2 minutes of drift between Mailgun time and local server time.",
    "label": "",
    "id": "68"
  },
  {
    "raw_code": "def create_and_extract_message_id!(source, **options)\n      message_checksum = OpenSSL::Digest::SHA1.hexdigest(source)\n      message_id = extract_message_id(source) || generate_missing_message_id(message_checksum)\n\n      create! raw_email: create_and_upload_raw_email!(source),\n        message_id: message_id, message_checksum: message_checksum, **options\n    rescue ActiveRecord::RecordNotUnique\n      nil\n    end",
    "comment": "Create a new +InboundEmail+ from the raw +source+ of the email, which is uploaded as an Active Storage attachment called +raw_email+. Before the upload, extract the Message-ID from the +source+ and set it as an attribute on the new +InboundEmail+.",
    "label": "",
    "id": "69"
  },
  {
    "raw_code": "def route_later\n    ActionMailbox::RoutingJob.perform_later self\n  end",
    "comment": "Enqueue a +RoutingJob+ for this +InboundEmail+.",
    "label": "",
    "id": "70"
  },
  {
    "raw_code": "def route\n    ApplicationMailbox.route self\n  end",
    "comment": "Route this +InboundEmail+ using the routing rules declared on the +ApplicationMailbox+.",
    "label": "",
    "id": "71"
  },
  {
    "raw_code": "def bounce_with(message)\n      inbound_email.bounced!\n      message.deliver_later\n    end",
    "comment": "Enqueues the given +message+ for delivery and changes the inbound email's status to +:bounced+.",
    "label": "",
    "id": "72"
  },
  {
    "raw_code": "def bounce_now_with(message)\n      inbound_email.bounced!\n      message.deliver_now\n    end",
    "comment": "Immediately sends the given +message+ and changes the inbound email's status to +:bounced+.",
    "label": "",
    "id": "73"
  },
  {
    "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of Action Mailbox as a +Gem::Version+.",
    "label": "",
    "id": "74"
  },
  {
    "raw_code": "def create_inbound_email_from_fixture(fixture_name, status: :processing)\n      create_inbound_email_from_source file_fixture(fixture_name).read, status: status\n    end",
    "comment": "Create an InboundEmail record using an eml fixture in the format of message/rfc822 referenced with +fixture_name+ located in +test/fixtures/files/fixture_name+.",
    "label": "",
    "id": "75"
  },
  {
    "raw_code": "def create_inbound_email_from_mail(status: :processing, **mail_options, &block)\n      mail = Mail.new(mail_options, &block)\n      # Bcc header is not encoded by default\n      mail[:bcc].include_in_headers = true if mail[:bcc]\n\n      create_inbound_email_from_source mail.to_s, status: status\n    end",
    "comment": "Creates an InboundEmail by specifying through options or a block.  ==== Options  * <tt>:status</tt> - The +status+ to set for the created InboundEmail. For possible statuses, see its documentation.  ==== Creating a simple email  When you only need to set basic fields like +from+, +to+, +subject+, and +body+, you can pass them directly as options.  create_inbound_email_from_mail(from: \"david@loudthinking.com\", subject: \"Hello!\")  ==== Creating a multi-part email  When you need to create a more intricate email, like a multi-part email that contains both a plaintext version and an HTML version, you can pass a block.  create_inbound_email_from_mail do to \"David Heinemeier Hansson <david@loudthinking.com>\" from \"Bilbo Baggins <bilbo@bagend.com>\" subject \"Come down to the Shire!\"  text_part do body \"Please join us for a party at Bag End\" end  html_part do body \"<h1>Please join us for a party at Bag End</h1>\" end end  As with +Mail.new+, you can also use a block parameter to define the parts of the message:  create_inbound_email_from_mail do |mail| mail.to \"David Heinemeier Hansson <david@loudthinking.com>\" mail.from \"Bilbo Baggins <bilbo@bagend.com>\" mail.subject \"Come down to the Shire!\"  mail.text_part do |part| part.body \"Please join us for a party at Bag End\" end  mail.html_part do |part| part.body \"<h1>Please join us for a party at Bag End</h1>\" end end",
    "label": "",
    "id": "76"
  },
  {
    "raw_code": "def create_inbound_email_from_source(source, status: :processing)\n      ActionMailbox::InboundEmail.create_and_extract_message_id! source, status: status\n    end",
    "comment": "Create an InboundEmail using the raw rfc822 +source+ as text.",
    "label": "",
    "id": "77"
  },
  {
    "raw_code": "def receive_inbound_email_from_fixture(*args)\n      create_inbound_email_from_fixture(*args).tap(&:route)\n    end",
    "comment": "Create an InboundEmail from fixture using the same arguments as create_inbound_email_from_fixture and immediately route it to processing.",
    "label": "",
    "id": "78"
  },
  {
    "raw_code": "def receive_inbound_email_from_mail(**kwargs, &block)\n      create_inbound_email_from_mail(**kwargs, &block).tap(&:route)\n    end",
    "comment": "Create an InboundEmail using the same options or block as create_inbound_email_from_mail, then immediately route it for processing.",
    "label": "",
    "id": "79"
  },
  {
    "raw_code": "def receive_inbound_email_from_source(*args)\n      create_inbound_email_from_source(*args).tap(&:route)\n    end",
    "comment": "Create an InboundEmail using the same arguments as create_inbound_email_from_source and immediately route it to processing.",
    "label": "",
    "id": "80"
  },
  {
    "raw_code": "def self.version\n    gem_version\n  end",
    "comment": "Returns the currently loaded version of Action Mailbox as a +Gem::Version+.",
    "label": "",
    "id": "81"
  },
  {
    "raw_code": "def register_observers(*observers)\n        observers.flatten.compact.each { |observer| register_observer(observer) }\n      end",
    "comment": "Register one or more Observers which will be notified when mail is delivered.",
    "label": "",
    "id": "82"
  },
  {
    "raw_code": "def unregister_observers(*observers)\n        observers.flatten.compact.each { |observer| unregister_observer(observer) }\n      end",
    "comment": "Unregister one or more previously registered Observers.",
    "label": "",
    "id": "83"
  },
  {
    "raw_code": "def register_interceptors(*interceptors)\n        interceptors.flatten.compact.each { |interceptor| register_interceptor(interceptor) }\n      end",
    "comment": "Register one or more Interceptors which will be called before mail is sent.",
    "label": "",
    "id": "84"
  },
  {
    "raw_code": "def unregister_interceptors(*interceptors)\n        interceptors.flatten.compact.each { |interceptor| unregister_interceptor(interceptor) }\n      end",
    "comment": "Unregister one or more previously registered Interceptors.",
    "label": "",
    "id": "85"
  },
  {
    "raw_code": "def register_observer(observer)\n        Mail.register_observer(observer_class_for(observer))\n      end",
    "comment": "Register an Observer which will be notified when mail is delivered. Either a class, string, or symbol can be passed in as the Observer. If a string or symbol is passed in it will be camelized and constantized.",
    "label": "",
    "id": "86"
  },
  {
    "raw_code": "def unregister_observer(observer)\n        Mail.unregister_observer(observer_class_for(observer))\n      end",
    "comment": "Unregister a previously registered Observer. Either a class, string, or symbol can be passed in as the Observer. If a string or symbol is passed in it will be camelized and constantized.",
    "label": "",
    "id": "87"
  },
  {
    "raw_code": "def register_interceptor(interceptor)\n        Mail.register_interceptor(observer_class_for(interceptor))\n      end",
    "comment": "Register an Interceptor which will be called before mail is sent. Either a class, string, or symbol can be passed in as the Interceptor. If a string or symbol is passed in it will be camelized and constantized.",
    "label": "",
    "id": "88"
  },
  {
    "raw_code": "def unregister_interceptor(interceptor)\n        Mail.unregister_interceptor(observer_class_for(interceptor))\n      end",
    "comment": "Unregister a previously registered Interceptor. Either a class, string, or symbol can be passed in as the Interceptor. If a string or symbol is passed in it will be camelized and constantized.",
    "label": "",
    "id": "89"
  },
  {
    "raw_code": "def mailer_name\n        @mailer_name ||= anonymous? ? \"anonymous\" : name.underscore\n      end",
    "comment": "Returns the name of the current mailer. This method is also being used as a path for a view lookup. If this is an anonymous mailer, this method will return +anonymous+ instead.",
    "label": "",
    "id": "90"
  },
  {
    "raw_code": "def default(value = nil)\n        self.default_params = default_params.merge(value).freeze if value\n        default_params\n      end",
    "comment": "Allows to set defaults through app configuration:  config.action_mailer.default_options = { from: \"no-reply@example.org\" }",
    "label": "",
    "id": "91"
  },
  {
    "raw_code": "def deliver_mail(mail) # :nodoc:\n        ActiveSupport::Notifications.instrument(\"deliver.action_mailer\") do |payload|\n          set_payload_for_mail(payload, mail)\n          yield # Let Mail do the delivery actions\n        end",
    "comment": "Wraps an email delivery inside of ActiveSupport::Notifications instrumentation.  This method is actually called by the +Mail::Message+ object itself through a callback when you call <tt>:deliver</tt> on the +Mail::Message+, calling +deliver_mail+ directly and passing a +Mail::Message+ will do nothing except tell the logger you sent the email.",
    "label": "",
    "id": "92"
  },
  {
    "raw_code": "def email_address_with_name(address, name)\n        Mail::Address.new.tap do |builder|\n          builder.address = address\n          builder.display_name = name.presence\n        end.to_s\n      end",
    "comment": "Returns an email in the format \"Name <email@example.com>\".  If the name is a blank string, it returns just the address.",
    "label": "",
    "id": "93"
  },
  {
    "raw_code": "def attachments\n      if @_mail_was_called\n        LateAttachmentsProxy.new(@_message.attachments)\n      else\n        @_message.attachments\n      end",
    "comment": "Allows you to add attachments to an email, like so:  mail.attachments['filename.jpg'] = File.read('/path/to/filename.jpg')  If you do this, then Mail will take the file name and work out the mime type. It will also set the +Content-Type+, +Content-Disposition+, and +Content-Transfer-Encoding+, and encode the contents of the attachment in Base64.  You can also specify overrides if you want by passing a hash instead of a string:  mail.attachments['filename.jpg'] = {mime_type: 'application/gzip', content: File.read('/path/to/filename.jpg')}  If you want to use encoding other than Base64 then you will need to pass encoding type along with the pre-encoded content as Mail doesn't know how to decode the data:  file_content = SpecialEncode(File.read('/path/to/filename.jpg')) mail.attachments['filename.jpg'] = {mime_type: 'application/gzip', encoding: 'SpecialEncoding', content: file_content }  You can also search for specific attachments:  # By Filename mail.attachments['filename.jpg']   # => Mail::Part object or nil  # or by index mail.attachments[0]                # => Mail::Part (first attachment) ",
    "label": "",
    "id": "94"
  },
  {
    "raw_code": "def set_content_type(m, user_content_type, class_default) # :doc:\n        params = m.content_type_parameters || {}\n        case\n        when user_content_type.present?\n          user_content_type\n        when m.has_attachments?\n          if m.attachments.all?(&:inline?)\n            [\"multipart\", \"related\", params]\n          else\n            [\"multipart\", \"mixed\", params]\n          end",
    "comment": "Used by #mail to set the content type of the message.  It will use the given +user_content_type+, or multipart if the mail message has any attachments. If the attachments are inline, the content type will be \"multipart/related\", otherwise \"multipart/mixed\".  If there is no content type passed in via headers, and there are no attachments, or the message is multipart, then the default content type is used.",
    "label": "",
    "id": "95"
  },
  {
    "raw_code": "def default_i18n_subject(interpolations = {}) # :doc:\n        mailer_scope = self.class.mailer_name.tr(\"/\", \".\")\n        I18n.t(:subject, **interpolations, scope: [mailer_scope, action_name], default: action_name.humanize)\n      end",
    "comment": "Translates the +subject+ using \\Rails I18n class under <tt>[mailer_scope, action_name]</tt> scope. If it does not find a translation for the +subject+ under the specified scope it will default to a humanized version of the <tt>action_name</tt>. If the subject has interpolations, you can pass them through the +interpolations+ parameter.",
    "label": "",
    "id": "96"
  },
  {
    "raw_code": "def self.supports_path? # :doc:\n        false\n      end",
    "comment": "Emails do not support relative path links.",
    "label": "",
    "id": "97"
  },
  {
    "raw_code": "def instrument_payload(key)\n        {\n          mailer: mailer_name,\n          key: key\n        }\n      end",
    "comment": "This and #instrument_name is for caching instrument",
    "label": "",
    "id": "98"
  },
  {
    "raw_code": "def before_deliver(*filters, &blk)\n        set_callback(:deliver, :before, *filters, &blk)\n      end",
    "comment": "Defines a callback that will get called right before the message is sent to the delivery method.",
    "label": "",
    "id": "99"
  },
  {
    "raw_code": "def after_deliver(*filters, &blk)\n        set_callback(:deliver, :after, *filters, &blk)\n      end",
    "comment": "Defines a callback that will get called right after the message's delivery method is finished.",
    "label": "",
    "id": "100"
  },
  {
    "raw_code": "def around_deliver(*filters, &blk)\n        set_callback(:deliver, :around, *filters, &blk)\n      end",
    "comment": "Defines a callback that will get called around the message's deliver method.",
    "label": "",
    "id": "101"
  },
  {
    "raw_code": "def add_delivery_method(symbol, klass, default_options = {})\n        class_attribute(:\"#{symbol}_settings\") unless respond_to?(:\"#{symbol}_settings\")\n        public_send(:\"#{symbol}_settings=\", default_options)\n        self.delivery_methods = delivery_methods.merge(symbol.to_sym => klass).freeze\n      end",
    "comment": "Adds a new delivery method through the given class using the given symbol as alias and the default options supplied.  add_delivery_method :sendmail, Mail::Sendmail, location:  '/usr/sbin/sendmail', arguments: %w[ -i ]",
    "label": "",
    "id": "102"
  },
  {
    "raw_code": "def default_form_builder(builder)\n        self._default_form_builder = builder\n      end",
    "comment": "Set the form builder to be used as the default for all forms in the views rendered by this mailer and its subclasses.  ==== Parameters * <tt>builder</tt> - Default form builder. Accepts a subclass of ActionView::Helpers::FormBuilder",
    "label": "",
    "id": "103"
  },
  {
    "raw_code": "def default_form_builder\n      self.class._default_form_builder\n    end",
    "comment": "Default form builder for the mailer",
    "label": "",
    "id": "104"
  },
  {
    "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of Action Mailer as a +Gem::Version+.",
    "label": "",
    "id": "105"
  },
  {
    "raw_code": "def deliver(event)\n      info do\n        if exception = event.payload[:exception_object]\n          \"Failed delivery of mail #{event.payload[:message_id]} error_class=#{exception.class} error_message=#{exception.message.inspect}\"\n        elsif event.payload[:perform_deliveries]\n          \"Delivered mail #{event.payload[:message_id]} (#{event.duration.round(1)}ms)\"\n        else\n          \"Skipped delivery of mail #{event.payload[:message_id]} as `perform_deliveries` is false\"\n        end",
    "comment": "An email was delivered.",
    "label": "",
    "id": "106"
  },
  {
    "raw_code": "def process(event)\n      debug do\n        mailer = event.payload[:mailer]\n        action = event.payload[:action]\n        \"#{mailer}##{action}: processed outbound mail in #{event.duration.round(1)}ms\"\n      end",
    "comment": "An email was generated.",
    "label": "",
    "id": "107"
  },
  {
    "raw_code": "def logger\n      ActionMailer::Base.logger\n    end",
    "comment": "Use the logger configured for ActionMailer::Base.",
    "label": "",
    "id": "108"
  },
  {
    "raw_code": "def mailer_class\n        if mailer = Array(@serialized_arguments).first || Array(arguments).first\n          mailer.constantize\n        end",
    "comment": "\"Deserialize\" the mailer class name by hand in case another argument (like a Global ID reference) raised DeserializationError.",
    "label": "",
    "id": "109"
  },
  {
    "raw_code": "def block_format(text)\n      formatted = text.split(/\\n\\r?\\n/).collect { |paragraph|\n        format_paragraph(paragraph)\n      }.join(\"\\n\\n\")\n\n      # Make list points stand on their own line\n      output = +\"\"\n      splits = formatted.split(/(\\*+|\\#+)/)\n      while line = splits.shift\n        if line.start_with?(\"*\", \"#\") && splits.first&.start_with?(\" \")\n          output.chomp!(\" \") while output.end_with?(\" \")\n          output << \"  #{line} #{splits.shift.strip}\\n\"\n        else\n          output << line\n        end",
    "comment": "Take the text and format it, indented two spaces for each line, and wrapped at 72 columns:  text = <<-TEXT This is the      paragraph.  * item1 * item2 TEXT  block_format text # => \"  This is the paragraph.\\n\\n  * item1\\n  * item2\\n\"",
    "label": "",
    "id": "110"
  },
  {
    "raw_code": "def mailer\n      @_controller\n    end",
    "comment": "Access the mailer instance.",
    "label": "",
    "id": "111"
  },
  {
    "raw_code": "def message\n      @_message\n    end",
    "comment": "Access the message instance.",
    "label": "",
    "id": "112"
  },
  {
    "raw_code": "def attachments\n      mailer.attachments\n    end",
    "comment": "Access the message attachments list.",
    "label": "",
    "id": "113"
  },
  {
    "raw_code": "def format_paragraph(text, len = 72, indent = 2)\n      sentences = [[]]\n\n      text.split.each do |word|\n        if sentences.first.present? && (sentences.last + [word]).join(\" \").length > len\n          sentences << [word]\n        else\n          sentences.last << word\n        end",
    "comment": "Returns +text+ wrapped at +len+ columns and indented +indent+ spaces. By default column length +len+ equals 72 characters and indent +indent+ equal two spaces.  my_text = 'Here is a sample text with more than 40 characters'  format_paragraph(my_text, 25, 4) # => \"    Here is a sample text with\\n    more than 40 characters\"",
    "label": "",
    "id": "114"
  },
  {
    "raw_code": "def deliver_all_later(*deliveries, **options)\n      _deliver_all_later(\"deliver_now\", *deliveries, **options)\n    end",
    "comment": "Enqueue many emails at once to be delivered through Active Job. When the individual job runs, it will send the email using +deliver_now+.",
    "label": "",
    "id": "115"
  },
  {
    "raw_code": "def deliver_all_later!(*deliveries, **options)\n      _deliver_all_later(\"deliver_now!\", *deliveries, **options)\n    end",
    "comment": "Enqueue many emails at once to be delivered through Active Job. When the individual job runs, it will send the email using +deliver_now!+. That means that the message will be sent bypassing checking +perform_deliveries+ and +raise_delivery_errors+, so use with caution.",
    "label": "",
    "id": "116"
  },
  {
    "raw_code": "def __getobj__ # :nodoc:\n      @mail_message ||= processed_mailer.message\n    end",
    "comment": "Method calls are delegated to the Mail::Message that's ready to deliver.",
    "label": "",
    "id": "117"
  },
  {
    "raw_code": "def __setobj__(mail_message) # :nodoc:\n      @mail_message = mail_message\n    end",
    "comment": "Unused except for delegator internals (dup, marshalling).",
    "label": "",
    "id": "118"
  },
  {
    "raw_code": "def message\n      __getobj__\n    end",
    "comment": "Returns the resulting Mail::Message",
    "label": "",
    "id": "119"
  },
  {
    "raw_code": "def processed?\n      @processed_mailer || @mail_message\n    end",
    "comment": "Was the delegate loaded, causing the mailer action to be processed?",
    "label": "",
    "id": "120"
  },
  {
    "raw_code": "def deliver_later!(options = {})\n      enqueue_delivery :deliver_now!, options\n    end",
    "comment": "Enqueues the email to be delivered through Active Job. When the job runs it will send the email using +deliver_now!+. That means that the message will be sent bypassing checking +perform_deliveries+ and +raise_delivery_errors+, so use with caution.  Notifier.welcome(User.first).deliver_later! Notifier.welcome(User.first).deliver_later!(wait: 1.hour) Notifier.welcome(User.first).deliver_later!(wait_until: 10.hours.from_now) Notifier.welcome(User.first).deliver_later!(priority: 10)  Options:  * <tt>:wait</tt> - Enqueue the email to be delivered with a delay * <tt>:wait_until</tt> - Enqueue the email to be delivered at (after) a specific date / time * <tt>:queue</tt> - Enqueue the email on the specified queue * <tt>:priority</tt> - Enqueues the email with the specified priority  By default, the email will be enqueued using ActionMailer::MailDeliveryJob on the default queue. Mailer classes can customize the queue name used for the default job by assigning a +deliver_later_queue_name+ class variable, or provide a custom job by assigning a +delivery_job+. When a custom job is used, it controls the queue name.  class AccountRegistrationMailer < ApplicationMailer self.delivery_job = RegistrationDeliveryJob end",
    "label": "",
    "id": "121"
  },
  {
    "raw_code": "def deliver_later(options = {})\n      enqueue_delivery :deliver_now, options\n    end",
    "comment": "Enqueues the email to be delivered through Active Job. When the job runs it will send the email using +deliver_now+.  Notifier.welcome(User.first).deliver_later Notifier.welcome(User.first).deliver_later(wait: 1.hour) Notifier.welcome(User.first).deliver_later(wait_until: 10.hours.from_now) Notifier.welcome(User.first).deliver_later(priority: 10)  Options:  * <tt>:wait</tt> - Enqueue the email to be delivered with a delay. * <tt>:wait_until</tt> - Enqueue the email to be delivered at (after) a specific date / time. * <tt>:queue</tt> - Enqueue the email on the specified queue. * <tt>:priority</tt> - Enqueues the email with the specified priority  By default, the email will be enqueued using ActionMailer::MailDeliveryJob on the default queue. Mailer classes can customize the queue name used for the default job by assigning a +deliver_later_queue_name+ class variable, or provide a custom job by assigning a +delivery_job+. When a custom job is used, it controls the queue name.  class AccountRegistrationMailer < ApplicationMailer self.delivery_job = RegistrationDeliveryJob end",
    "label": "",
    "id": "122"
  },
  {
    "raw_code": "def deliver_now!\n      processed_mailer.handle_exceptions do\n        processed_mailer.run_callbacks(:deliver) do\n          message.deliver!\n        end",
    "comment": "Delivers an email without checking +perform_deliveries+ and +raise_delivery_errors+, so use with caution.  Notifier.welcome(User.first).deliver_now! ",
    "label": "",
    "id": "123"
  },
  {
    "raw_code": "def deliver_now\n      processed_mailer.handle_exceptions do\n        processed_mailer.run_callbacks(:deliver) do\n          message.deliver\n        end",
    "comment": "Delivers an email:  Notifier.welcome(User.first).deliver_now ",
    "label": "",
    "id": "124"
  },
  {
    "raw_code": "def processed_mailer\n        @processed_mailer ||= @mailer_class.new.tap do |mailer|\n          mailer.process @action, *@args\n        end",
    "comment": "Returns the processed Mailer instance. We keep this instance on hand so we can run callbacks and delegate exception handling to it.",
    "label": "",
    "id": "125"
  },
  {
    "raw_code": "def with(params)\n        ActionMailer::Parameterized::Mailer.new(self, params)\n      end",
    "comment": "Provide the parameters to the mailer in order to use them in the instance methods and callbacks.  InvitationsMailer.with(inviter: person_a, invitee: person_b).account_invitation.deliver_later  See Parameterized documentation for full example.",
    "label": "",
    "id": "126"
  },
  {
    "raw_code": "def register_preview_interceptors(*interceptors)\n        interceptors.flatten.compact.each { |interceptor| register_preview_interceptor(interceptor) }\n      end",
    "comment": "Register one or more Interceptors which will be called before mail is previewed.",
    "label": "",
    "id": "127"
  },
  {
    "raw_code": "def unregister_preview_interceptors(*interceptors)\n        interceptors.flatten.compact.each { |interceptor| unregister_preview_interceptor(interceptor) }\n      end",
    "comment": "Unregister one or more previously registered Interceptors.",
    "label": "",
    "id": "128"
  },
  {
    "raw_code": "def register_preview_interceptor(interceptor)\n        preview_interceptor = interceptor_class_for(interceptor)\n\n        unless preview_interceptors.include?(preview_interceptor)\n          preview_interceptors << preview_interceptor\n        end",
    "comment": "Register an Interceptor which will be called before mail is previewed. Either a class or a string can be passed in as the Interceptor. If a string is passed in it will be constantized.",
    "label": "",
    "id": "129"
  },
  {
    "raw_code": "def unregister_preview_interceptor(interceptor)\n        preview_interceptors.delete(interceptor_class_for(interceptor))\n      end",
    "comment": "Unregister a previously registered Interceptor. Either a class or a string can be passed in as the Interceptor. If a string is passed in it will be constantized.",
    "label": "",
    "id": "130"
  },
  {
    "raw_code": "def all\n        load_previews if descendants.empty?\n        descendants.sort_by { |mailer| mailer.name.titleize }\n      end",
    "comment": "Returns all mailer preview classes.",
    "label": "",
    "id": "131"
  },
  {
    "raw_code": "def call(email, params = {})\n        preview = new(params)\n        message = preview.public_send(email)\n        inform_preview_interceptors(message)\n        message\n      end",
    "comment": "Returns the mail object for the given email name. The registered preview interceptors will be informed so that they can transform the message as they would if the mail was actually being delivered.",
    "label": "",
    "id": "132"
  },
  {
    "raw_code": "def emails\n        public_instance_methods(false).map(&:to_s).sort\n      end",
    "comment": "Returns all of the available email previews.",
    "label": "",
    "id": "133"
  },
  {
    "raw_code": "def email_exists?(email)\n        emails.include?(email)\n      end",
    "comment": "Returns +true+ if the email exists.",
    "label": "",
    "id": "134"
  },
  {
    "raw_code": "def exists?(preview)\n        all.any? { |p| p.preview_name == preview }\n      end",
    "comment": "Returns +true+ if the preview exists.",
    "label": "",
    "id": "135"
  },
  {
    "raw_code": "def find(preview)\n        all.find { |p| p.preview_name == preview }\n      end",
    "comment": "Find a mailer preview by its underscored class name.",
    "label": "",
    "id": "136"
  },
  {
    "raw_code": "def preview_name\n        name.delete_suffix(\"Preview\").underscore\n      end",
    "comment": "Returns the underscored name of the mailer preview without the suffix.",
    "label": "",
    "id": "137"
  },
  {
    "raw_code": "def deliver(event)\n      exception = event.payload[:exception_object]\n      payload = {\n        message_id: event.payload[:message_id],\n        duration: event.duration.round(2),\n        mail: event.payload[:mail],\n        perform_deliveries: event.payload[:perform_deliveries],\n      }\n\n      if exception\n        payload[:exception_class] = exception.class.name\n        payload[:exception_message] = exception.message\n      end",
    "comment": "An email was delivered.",
    "label": "",
    "id": "138"
  },
  {
    "raw_code": "def process(event)\n      emit_debug_event(\"action_mailer.processed\",\n        mailer: event.payload[:mailer],\n        action: event.payload[:action],\n        duration: event.duration.round(2),\n      )\n    end",
    "comment": "An email was generated.",
    "label": "",
    "id": "139"
  },
  {
    "raw_code": "def read_fixture(action)\n        IO.readlines(File.join(Rails.root, \"test\", \"fixtures\", self.class.mailer_class.name.underscore, action))\n      end",
    "comment": "Reads the fixture file for the given mailer.  This is useful when testing mailers by being able to write the body of an email inside a fixture. See the testing guide for a concrete example: https://guides.rubyonrails.org/testing.html#revenge-of-the-fixtures",
    "label": "",
    "id": "140"
  },
  {
    "raw_code": "def assert_emails(number, &block)\n      if block_given?\n        diff = capture_emails(&block).length\n        assert_equal number, diff, \"#{number} emails expected, but #{diff} were sent\"\n      else\n        assert_equal number, ActionMailer::Base.deliveries.size\n      end",
    "comment": "Asserts that the number of emails sent matches the given number.  def test_emails assert_emails 0 ContactMailer.welcome.deliver_now assert_emails 1 ContactMailer.welcome.deliver_now assert_emails 2 end  If a block is passed, that block should cause the specified number of emails to be sent.  def test_emails_again assert_emails 1 do ContactMailer.welcome.deliver_now end  assert_emails 2 do ContactMailer.welcome.deliver_now ContactMailer.welcome.deliver_later end end",
    "label": "",
    "id": "141"
  },
  {
    "raw_code": "def assert_no_emails(&block)\n      assert_emails 0, &block\n    end",
    "comment": "Asserts that no emails have been sent.  def test_emails assert_no_emails ContactMailer.welcome.deliver_now assert_emails 1 end  If a block is passed, that block should not cause any emails to be sent.  def test_emails_again assert_no_emails do # No emails should be sent from this block end end  Note: This assertion is simply a shortcut for:  assert_emails 0, &block",
    "label": "",
    "id": "142"
  },
  {
    "raw_code": "def assert_enqueued_emails(number, &block)\n      assert_enqueued_jobs(number, only: ->(job) { delivery_job_filter(job) }, &block)\n    end",
    "comment": "Asserts that the number of emails enqueued for later delivery matches the given number.  def test_emails assert_enqueued_emails 0 ContactMailer.welcome.deliver_later assert_enqueued_emails 1 ContactMailer.welcome.deliver_later assert_enqueued_emails 2 end  If a block is passed, that block should cause the specified number of emails to be enqueued.  def test_emails_again assert_enqueued_emails 1 do ContactMailer.welcome.deliver_later end  assert_enqueued_emails 2 do ContactMailer.welcome.deliver_later ContactMailer.welcome.deliver_later end end",
    "label": "",
    "id": "143"
  },
  {
    "raw_code": "def assert_enqueued_email_with(mailer, method, params: nil, args: nil, queue: nil, &block)\n      if mailer.is_a? ActionMailer::Parameterized::Mailer\n        params = mailer.instance_variable_get(:@params)\n        mailer = mailer.instance_variable_get(:@mailer)\n      end",
    "comment": "Asserts that a specific email has been enqueued, optionally matching arguments and/or params.  def test_email ContactMailer.welcome.deliver_later assert_enqueued_email_with ContactMailer, :welcome end  def test_email_with_parameters ContactMailer.with(greeting: \"Hello\").welcome.deliver_later assert_enqueued_email_with ContactMailer, :welcome, args: { greeting: \"Hello\" } end  def test_email_with_arguments ContactMailer.welcome(\"Hello\", \"Goodbye\").deliver_later assert_enqueued_email_with ContactMailer, :welcome, args: [\"Hello\", \"Goodbye\"] end  def test_email_with_named_arguments ContactMailer.welcome(greeting: \"Hello\", farewell: \"Goodbye\").deliver_later assert_enqueued_email_with ContactMailer, :welcome, args: [{ greeting: \"Hello\", farewell: \"Goodbye\" }] end  def test_email_with_parameters_and_arguments ContactMailer.with(greeting: \"Hello\").welcome(\"Cheers\", \"Goodbye\").deliver_later assert_enqueued_email_with ContactMailer, :welcome, params: { greeting: \"Hello\" }, args: [\"Cheers\", \"Goodbye\"] end  def test_email_with_parameters_and_named_arguments ContactMailer.with(greeting: \"Hello\").welcome(farewell: \"Goodbye\").deliver_later assert_enqueued_email_with ContactMailer, :welcome, params: { greeting: \"Hello\" }, args: [{farewell: \"Goodbye\"}] end  def test_email_with_parameterized_mailer ContactMailer.with(greeting: \"Hello\").welcome.deliver_later assert_enqueued_email_with ContactMailer.with(greeting: \"Hello\"), :welcome end  def test_email_with_matchers ContactMailer.with(greeting: \"Hello\").welcome(\"Cheers\", \"Goodbye\").deliver_later assert_enqueued_email_with ContactMailer, :welcome, params: ->(params) { /hello/i.match?(params[:greeting]) }, args: ->(args) { /cheers/i.match?(args[0]) } end  If a block is passed, that block should cause the specified email to be enqueued.  def test_email_in_block assert_enqueued_email_with ContactMailer, :welcome do ContactMailer.welcome.deliver_later end end  If +args+ is provided as a Hash, a parameterized email is matched.  def test_parameterized_email assert_enqueued_email_with ContactMailer, :welcome, args: {email: 'user@example.com'} do ContactMailer.with(email: 'user@example.com').welcome.deliver_later end end",
    "label": "",
    "id": "144"
  },
  {
    "raw_code": "def assert_no_enqueued_emails(&block)\n      assert_enqueued_emails 0, &block\n    end",
    "comment": "Asserts that no emails are enqueued for later delivery.  def test_no_emails assert_no_enqueued_emails ContactMailer.welcome.deliver_later assert_enqueued_emails 1 end  If a block is provided, it should not cause any emails to be enqueued.  def test_no_emails assert_no_enqueued_emails do # No emails should be enqueued from this block end end",
    "label": "",
    "id": "145"
  },
  {
    "raw_code": "def deliver_enqueued_emails(queue: nil, at: nil, &block)\n      perform_enqueued_jobs(only: ->(job) { delivery_job_filter(job) }, queue: queue, at: at, &block)\n    end",
    "comment": "Delivers all enqueued emails. If a block is given, delivers all of the emails that were enqueued throughout the duration of the block. If a block is not given, delivers all the enqueued emails up to this point in the test.  def test_deliver_enqueued_emails deliver_enqueued_emails do ContactMailer.welcome.deliver_later end  assert_emails 1 end  def test_deliver_enqueued_emails_without_block ContactMailer.welcome.deliver_later  deliver_enqueued_emails  assert_emails 1 end  If the +:queue+ option is specified, then only the emails(s) enqueued to a specific queue will be performed.  def test_deliver_enqueued_emails_with_queue deliver_enqueued_emails queue: :external_mailers do CustomerMailer.deliver_later_queue_name = :external_mailers CustomerMailer.welcome.deliver_later # will be performed EmployeeMailer.deliver_later_queue_name = :internal_mailers EmployeeMailer.welcome.deliver_later # will not be performed end  assert_emails 1 end  If the +:at+ option is specified, then only delivers emails enqueued to deliver immediately or before the given time.",
    "label": "",
    "id": "146"
  },
  {
    "raw_code": "def capture_emails(&block)\n      original_count = ActionMailer::Base.deliveries.size\n      deliver_enqueued_emails(&block)\n      new_count = ActionMailer::Base.deliveries.size\n      diff = new_count - original_count\n      ActionMailer::Base.deliveries.last(diff)\n    end",
    "comment": "Returns any emails that are sent in the block.  def test_emails emails = capture_emails do ContactMailer.welcome.deliver_now end assert_equal \"Hi there\", emails.first.subject  emails = capture_emails do ContactMailer.welcome.deliver_now ContactMailer.welcome.deliver_later end assert_equal \"Hi there\", emails.first.subject end",
    "label": "",
    "id": "147"
  },
  {
    "raw_code": "def self.version\n    gem_version\n  end",
    "comment": "Returns the currently loaded version of Action Mailer as a +Gem::Version+.",
    "label": "",
    "id": "148"
  },
  {
    "raw_code": "def test_assert_select_email\n    assert_raise ActiveSupport::TestCase::Assertion do\n      assert_select_email { }\n    end",
    "comment": " Test assert_select_email ",
    "label": "",
    "id": "149"
  },
  {
    "raw_code": "def swap(klass, new_values)\n      old_values = {}\n      new_values.each do |key, value|\n        old_values[key] = klass.public_send key\n        klass.public_send :\"#{key}=\", value\n      end",
    "comment": "Execute the block setting the given values and restoring old values after the block is executed.",
    "label": "",
    "id": "150"
  },
  {
    "raw_code": "def abstract!\n        @abstract = true\n      end",
    "comment": "Define a controller as abstract. See internal_methods for more details.",
    "label": "",
    "id": "151"
  },
  {
    "raw_code": "def internal_methods\n        controller = self\n        methods = []\n\n        until controller.abstract?\n          methods += controller.public_instance_methods(false)\n          controller = controller.superclass\n        end",
    "comment": "A list of all internal methods for a controller. This finds the first abstract superclass of a controller, and gets a list of all public instance methods on that abstract class. Public instance methods of a controller would normally be considered action methods, so methods declared on abstract classes are being removed. (ActionController::Metal and ActionController::Base are defined as abstract)",
    "label": "",
    "id": "152"
  },
  {
    "raw_code": "def action_methods\n        @action_methods ||= begin\n          # All public instance methods of this class, including ancestors except for\n          # public instance methods of Base and its ancestors.\n          methods = public_instance_methods(true) - internal_methods\n          # Be sure to include shadowed public instance methods of this class.\n          methods.concat(public_instance_methods(false))\n          methods.reject! { |m| m.start_with?(\"_\") }\n          methods.map!(&:name)\n          methods.to_set\n        end",
    "comment": "A `Set` of method names that should be considered actions. This includes all public instance methods on a controller, less any internal methods (see internal_methods), adding back in any methods that are internal, but still exist on the class itself.",
    "label": "",
    "id": "153"
  },
  {
    "raw_code": "def clear_action_methods!\n        @action_methods = nil\n      end",
    "comment": "action_methods are cached and there is sometimes a need to refresh them. ::clear_action_methods! allows you to do that, so next time you run action_methods, they will be recalculated.",
    "label": "",
    "id": "154"
  },
  {
    "raw_code": "def controller_path\n        @controller_path ||= name.delete_suffix(\"Controller\").underscore unless anonymous?\n      end",
    "comment": "Returns the full controller name, underscored, without the ending Controller.  class MyApp::MyPostsController < AbstractController::Base  end  MyApp::MyPostsController.controller_path # => \"my_app/my_posts\" ",
    "label": "",
    "id": "155"
  },
  {
    "raw_code": "def method_added(name)\n        super\n        clear_action_methods!\n      end",
    "comment": "Refresh the cached action_methods when a new action_method is added.",
    "label": "",
    "id": "156"
  },
  {
    "raw_code": "def process(action, ...)\n      @_action_name = action.to_s\n\n      unless action_name = _find_action_name(@_action_name)\n        raise ActionNotFound.new(\"The action '#{action}' could not be found for #{self.class.name}\", self, action)\n      end",
    "comment": "Calls the action going through the entire Action Dispatch stack.  The actual method that is called is determined by calling #method_for_action. If no method can handle the action, then an AbstractController::ActionNotFound error is raised.",
    "label": "",
    "id": "157"
  },
  {
    "raw_code": "def controller_path\n      self.class.controller_path\n    end",
    "comment": "Delegates to the class's ::controller_path.",
    "label": "",
    "id": "158"
  },
  {
    "raw_code": "def action_methods\n      self.class.action_methods\n    end",
    "comment": "Delegates to the class's ::action_methods.",
    "label": "",
    "id": "159"
  },
  {
    "raw_code": "def available_action?(action_name)\n      _find_action_name(action_name)\n    end",
    "comment": "Returns true if a method for the action is available and can be dispatched, false otherwise.  Notice that `action_methods.include?(\"foo\")` may return false and `available_action?(\"foo\")` returns true because this method considers actions that are also available through other means, for example, implicit render ones.  #### Parameters *   `action_name` - The name of an action to be tested ",
    "label": "",
    "id": "160"
  },
  {
    "raw_code": "def performed?\n      response_body\n    end",
    "comment": "Tests if a response body is set. Used to determine if the `process_action` callback needs to be terminated in AbstractController::Callbacks.",
    "label": "",
    "id": "161"
  },
  {
    "raw_code": "def self.supports_path?\n      true\n    end",
    "comment": "Returns true if the given controller is capable of rendering a path. A subclass of `AbstractController::Base` may return false. An Email controller for example does not support paths, only full URLs.",
    "label": "",
    "id": "162"
  },
  {
    "raw_code": "def action_method?(name)\n        self.class.action_methods.include?(name)\n      end",
    "comment": "Returns true if the name can be considered an action because it has a method defined in the controller.  #### Parameters *   `name` - The name of an action to be tested ",
    "label": "",
    "id": "163"
  },
  {
    "raw_code": "def process_action(...)\n        send_action(...)\n      end",
    "comment": "Call the action. Override this in a subclass to modify the behavior around processing an action. This, and not #process, is the intended way to override action dispatching.  Notice that the first argument is the method to be dispatched which is **not** necessarily the same as the action name.",
    "label": "",
    "id": "164"
  },
  {
    "raw_code": "def _handle_action_missing(*args)\n        action_missing(@_action_name, *args)\n      end",
    "comment": "If the action name was not found, but a method called \"action_missing\" was found, #method_for_action will return \"_handle_action_missing\". This method calls #action_missing with the current action name.",
    "label": "",
    "id": "165"
  },
  {
    "raw_code": "def _find_action_name(action_name)\n        _valid_action_name?(action_name) && method_for_action(action_name)\n      end",
    "comment": "Takes an action name and returns the name of the method that will handle the action.  It checks if the action name is valid and returns false otherwise.  See method_for_action for more information.  #### Parameters *   `action_name` - An action name to find a method name for   #### Returns *   `string` - The name of the method that handles the action *   false           - No valid method name could be found.  Raise `AbstractController::ActionNotFound`.",
    "label": "",
    "id": "166"
  },
  {
    "raw_code": "def method_for_action(action_name)\n        if action_method?(action_name)\n          action_name\n        elsif respond_to?(:action_missing, true)\n          \"_handle_action_missing\"\n        end",
    "comment": "Takes an action name and returns the name of the method that will handle the action. In normal cases, this method returns the same name as it receives. By default, if #method_for_action receives a name that is not an action, it will look for an #action_missing method and return \"_handle_action_missing\" if one is found.  Subclasses may override this method to add additional conditions that should be considered an action. For instance, an HTTP controller with a template matching the action name is considered to exist.  If you override this method to handle additional cases, you may also provide a method (like `_handle_method_missing`) to handle the case.  If none of these conditions are true, and `method_for_action` returns `nil`, an `AbstractController::ActionNotFound` exception will be raised.  #### Parameters *   `action_name` - An action name to find a method name for   #### Returns *   `string` - The name of the method that handles the action *   `nil`    - No method name could be found. ",
    "label": "",
    "id": "167"
  },
  {
    "raw_code": "def _valid_action_name?(action_name)\n        !action_name.to_s.include? File::SEPARATOR\n      end",
    "comment": "Checks if the action name is valid and returns false otherwise.",
    "label": "",
    "id": "168"
  },
  {
    "raw_code": "def cache(key, options = {}, &block) # :doc:\n        if cache_configured?\n          cache_store.fetch(ActiveSupport::Cache.expand_cache_key(key, :controller), options, &block)\n        else\n          yield\n        end",
    "comment": "Convenience accessor.",
    "label": "",
    "id": "169"
  },
  {
    "raw_code": "def _normalize_callback_options(options)\n        _normalize_callback_option(options, :only, :if)\n        _normalize_callback_option(options, :except, :unless)\n      end",
    "comment": "If `:only` or `:except` are used, convert the options into the `:if` and `:unless` options of ActiveSupport::Callbacks.  The basic idea is that `:only => :index` gets converted to `:if => proc {|c| c.action_name == \"index\" }`.  Note that `:only` has priority over `:if` in case they are used together.  only: :index, if: -> { true } # the :if option will be ignored.  Note that `:if` has priority over `:except` in case they are used together.  except: :index, if: -> { true } # the :except option will be ignored.  #### Options *   `only`   - The callback should be run only for this action. *   `except`  - The callback should be run for all actions except this action. ",
    "label": "",
    "id": "170"
  },
  {
    "raw_code": "def _insert_callbacks(callbacks, block = nil)\n        options = callbacks.extract_options!\n        callbacks.push(block) if block\n        options[:filters] = callbacks\n        _normalize_callback_options(options)\n        options.delete(:filters)\n        callbacks.each do |callback|\n          yield callback, options\n        end",
    "comment": "Take callback names and an optional callback proc, normalize them, then call the block with each callback. This allows us to abstract the normalization across several methods that use it.  #### Parameters *   `callbacks` - An array of callbacks, with an optional options hash as the last parameter. *   `block`    - A proc that should be added to the callbacks.   #### Block Parameters *   `name`     - The callback to be added. *   `options`  - A hash of options to be used when adding the callback. ",
    "label": "",
    "id": "171"
  },
  {
    "raw_code": "def process_action(...)\n        run_callbacks(:process_action) do\n          super\n        end",
    "comment": "Override `AbstractController::Base#process_action` to run the `process_action` callbacks around the normal behavior.",
    "label": "",
    "id": "172"
  },
  {
    "raw_code": "def inherited(klass)\n        # Inherited from parent by default\n        klass._helpers = nil\n\n        klass.class_eval { default_helper_module! } unless klass.anonymous?\n        super\n      end",
    "comment": "When a class is inherited, wrap its helper module in a new module. This ensures that the parent class's module can be changed independently of the child class's.",
    "label": "",
    "id": "173"
  },
  {
    "raw_code": "def helper_method(*methods)\n        methods.flatten!\n        self._helper_methods += methods\n\n        location = caller_locations(1, 1).first\n        file, line = location.path, location.lineno\n\n        methods.each do |method|\n          # def current_user(...)\n          #   controller.send(:'current_user', ...)\n          # end\n          _helpers_for_modification.class_eval <<~ruby_eval.lines.map(&:strip).join(\";\"), file, line\n            def #{method}(...)\n              controller.send(:'#{method}', ...)\n            end\n          ruby_eval\n        end",
    "comment": " :method: modules_for_helpers :call-seq: modules_for_helpers(modules_or_helper_prefixes)  Given an array of values like the ones accepted by `helper`, this method returns an array with the corresponding modules, in the same order.  ActionController::Base.modules_for_helpers([\"application\", \"chart\", \"rubygems\"]) # => [ApplicationHelper, ChartHelper, RubygemsHelper]  -- Implemented by Resolution#modules_for_helpers. :method: # all_helpers_from_path :call-seq: all_helpers_from_path(path)  Returns a list of helper names in a given path.  ActionController::Base.all_helpers_from_path 'app/helpers' # => [\"application\", \"chart\", \"rubygems\"]  -- Implemented by Resolution#all_helpers_from_path. Declare a controller method as a helper. For example, the following makes the `current_user` and `logged_in?` controller methods available to the view:  class ApplicationController < ActionController::Base helper_method :current_user, :logged_in?  private def current_user @current_user ||= User.find_by(id: session[:user]) end  def logged_in? current_user != nil end end  In a view:  <% if logged_in? -%>Welcome, <%= current_user.name %><% end -%>  #### Parameters *   `method[, method]` - A name or names of a method on the controller to be made available on the view.",
    "label": "",
    "id": "174"
  },
  {
    "raw_code": "def helper(*args, &block)\n        modules_for_helpers(args).each do |mod|\n          next if _helpers.include?(mod)\n          _helpers_for_modification.include(mod)\n        end",
    "comment": "Includes the given modules in the template class.  Modules can be specified in different ways. All of the following calls include `FooHelper`:  # Module, recommended. helper FooHelper  # String/symbol without the \"helper\" suffix, camel or snake case. helper \"Foo\" helper :Foo helper \"foo\" helper :foo  The last two assume that `\"foo\".camelize` returns \"Foo\".  When strings or symbols are passed, the method finds the actual module object using String#constantize. Therefore, if the module has not been yet loaded, it has to be autoloadable, which is normally the case.  Namespaces are supported. The following calls include `Foo::BarHelper`:  # Module, recommended. helper Foo::BarHelper  # String/symbol without the \"helper\" suffix, camel or snake case. helper \"Foo::Bar\" helper :\"Foo::Bar\" helper \"foo/bar\" helper :\"foo/bar\"  The last two assume that `\"foo/bar\".camelize` returns \"Foo::Bar\".  The method accepts a block too. If present, the block is evaluated in the context of the controller helper module. This simple call makes the `wadus` method available in templates of the enclosing controller:  helper do def wadus \"wadus\" end end  Furthermore, all the above styles can be mixed together:  helper FooHelper, \"woo\", \"bar/baz\" do def wadus \"wadus\" end end ",
    "label": "",
    "id": "175"
  },
  {
    "raw_code": "def clear_helpers\n        inherited_helper_methods = _helper_methods\n        self._helpers = Module.new\n        self._helper_methods = Array.new\n\n        inherited_helper_methods.each { |meth| helper_method meth }\n        default_helper_module! unless anonymous?\n      end",
    "comment": "Clears up all existing helpers in this class, only keeping the helper with the same name as this class.",
    "label": "",
    "id": "176"
  },
  {
    "raw_code": "def render(*args, &block)\n      options = _normalize_render(*args, &block)\n      rendered_body = render_to_body(options)\n      if options[:html]\n        _set_html_content_type\n      else\n        _set_rendered_content_type rendered_format\n      end",
    "comment": "Normalizes arguments and options, and then delegates to render_to_body and sticks the result in `self.response_body`.  Supported options depend on the underlying `render_to_body` implementation.",
    "label": "",
    "id": "177"
  },
  {
    "raw_code": "def render_to_string(*args, &block)\n      options = _normalize_render(*args, &block)\n      render_to_body(options)\n    end",
    "comment": "Similar to #render, but only returns the rendered template as a string, instead of setting `self.response_body`.  If a component extends the semantics of `response_body` (as ActionController extends it to be anything that responds to the method each), this method needs to be overridden in order to still return a string.",
    "label": "",
    "id": "178"
  },
  {
    "raw_code": "def render_to_body(options = {})\n    end",
    "comment": "Performs the actual template rendering.",
    "label": "",
    "id": "179"
  },
  {
    "raw_code": "def rendered_format\n      Mime[:text]\n    end",
    "comment": "Returns `Content-Type` of rendered content.",
    "label": "",
    "id": "180"
  },
  {
    "raw_code": "def view_assigns\n      variables = instance_variables - _protected_ivars\n\n      variables.each_with_object({}) do |name, hash|\n        hash[name.slice(1, name.length)] = instance_variable_get(name)\n      end",
    "comment": "This method should return a hash with assigns. You can overwrite this configuration per controller.",
    "label": "",
    "id": "181"
  },
  {
    "raw_code": "def _normalize_args(action = nil, options = {}) # :doc:\n      if action.respond_to?(:permitted?)\n        if action.permitted?\n          action\n        else\n          raise ArgumentError, \"render parameters are not permitted\"\n        end",
    "comment": "Normalize args by converting `render \"foo\"` to `render action: \"foo\"` and `render \"foo/bar\"` to `render file: \"foo/bar\"`.",
    "label": "",
    "id": "182"
  },
  {
    "raw_code": "def _normalize_options(options) # :doc:\n      options\n    end",
    "comment": "Normalize options.",
    "label": "",
    "id": "183"
  },
  {
    "raw_code": "def _process_options(options) # :doc:\n      options\n    end",
    "comment": "Process extra options.",
    "label": "",
    "id": "184"
  },
  {
    "raw_code": "def _process_format(format) # :nodoc:\n    end",
    "comment": "Process the rendered format.",
    "label": "",
    "id": "185"
  },
  {
    "raw_code": "def _normalize_render(*args, &block) # :nodoc:\n      options = _normalize_args(*args, &block)\n      _process_variant(options)\n      _normalize_options(options)\n      options\n    end",
    "comment": "Normalize args and options.",
    "label": "",
    "id": "186"
  },
  {
    "raw_code": "def translate(key, **options)\n      if key&.start_with?(\".\")\n        path = controller_path.tr(\"/\", \".\")\n        defaults = [:\"#{path}#{key}\"]\n        defaults << options[:default] if options[:default]\n        options[:default] = defaults.flatten\n        key = \"#{path}.#{action_name}#{key}\"\n      end",
    "comment": "Delegates to `I18n.translate`.  When the given key starts with a period, it will be scoped by the current controller and action. So if you call `translate(\".foo\")` from `PeopleController#index`, it will convert the call to `I18n.translate(\"people.index.foo\")`. This makes it less repetitive to translate many keys within the same controller / action and gives you a simple framework for scoping them consistently.",
    "label": "",
    "id": "187"
  },
  {
    "raw_code": "def localize(object, **options)\n      I18n.localize(object, **options)\n    end",
    "comment": "Delegates to `I18n.localize`.",
    "label": "",
    "id": "188"
  },
  {
    "raw_code": "def fragment_cache_key(value = nil, &key)\n          self.fragment_cache_keys += [key || -> { value }]\n        end",
    "comment": "Allows you to specify controller-wide key prefixes for cache fragments. Pass either a constant `value`, or a block which computes a value each time a cache key is generated.  For example, you may want to prefix all fragment cache keys with a global version identifier, so you can easily invalidate all caches.  class ApplicationController fragment_cache_key \"v1\" end  When it's time to invalidate all fragments, simply change the string constant. Or, progressively roll out the cache invalidation using a computed value:  class ApplicationController fragment_cache_key do @account.id.odd? ? \"v1\" : \"v2\" end end",
    "label": "",
    "id": "189"
  },
  {
    "raw_code": "def combined_fragment_cache_key(key)\n        head = self.class.fragment_cache_keys.map { |k| instance_exec(&k) }\n        tail = key.is_a?(Hash) ? url_for(key).split(\"://\").last : key\n\n        cache_key = [:views, ENV[\"RAILS_CACHE_ID\"] || ENV[\"RAILS_APP_VERSION\"], head, tail]\n        cache_key.flatten!(1)\n        cache_key.compact!\n        cache_key\n      end",
    "comment": "Given a key (as described in `expire_fragment`), returns a key array suitable for use in reading, writing, or expiring a cached fragment. All keys begin with `:views`, followed by `ENV[\"RAILS_CACHE_ID\"]` or `ENV[\"RAILS_APP_VERSION\"]` if set, followed by any controller-wide key prefix values, ending with the specified `key` value.",
    "label": "",
    "id": "190"
  },
  {
    "raw_code": "def write_fragment(key, content, options = nil)\n        return content unless cache_configured?\n\n        key = combined_fragment_cache_key(key)\n        instrument_fragment_cache :write_fragment, key do\n          content = content.to_str\n          cache_store.write(key, content, options)\n        end",
    "comment": "Writes `content` to the location signified by `key` (see `expire_fragment` for acceptable formats).",
    "label": "",
    "id": "191"
  },
  {
    "raw_code": "def read_fragment(key, options = nil)\n        return unless cache_configured?\n\n        key = combined_fragment_cache_key(key)\n        instrument_fragment_cache :read_fragment, key do\n          result = cache_store.read(key, options)\n          result.respond_to?(:html_safe) ? result.html_safe : result\n        end",
    "comment": "Reads a cached fragment from the location signified by `key` (see `expire_fragment` for acceptable formats).",
    "label": "",
    "id": "192"
  },
  {
    "raw_code": "def fragment_exist?(key, options = nil)\n        return unless cache_configured?\n        key = combined_fragment_cache_key(key)\n\n        instrument_fragment_cache :exist_fragment?, key do\n          cache_store.exist?(key, options)\n        end",
    "comment": "Check if a cached fragment from the location signified by `key` exists (see `expire_fragment` for acceptable formats).",
    "label": "",
    "id": "193"
  },
  {
    "raw_code": "def expire_fragment(key, options = nil)\n        return unless cache_configured?\n        key = combined_fragment_cache_key(key) unless key.is_a?(Regexp)\n\n        instrument_fragment_cache :expire_fragment, key do\n          if key.is_a?(Regexp)\n            cache_store.delete_matched(key, options)\n          else\n            cache_store.delete(key, options)\n          end",
    "comment": "Removes fragments from the cache.  `key` can take one of three forms:  *   String - This would normally take the form of a path, like `pages/45/notes`. *   Hash - Treated as an implicit call to `url_for`, like `{ controller: 'pages', action: 'notes', id: 45}` *   Regexp - Will remove any fragment that matches, so `%r{pages/\\d*/notes}` might remove all notes. Make sure you don't use anchors in the regex (`^` or `$`) because the actual filename matched looks like `./cache/filename/path.cache`. Note: Regexp expiration is only supported on caches that can iterate over all keys (unlike memcached).   `options` is passed through to the cache store's `delete` method (or `delete_matched`, for Regexp keys).",
    "label": "",
    "id": "194"
  },
  {
    "raw_code": "def self.without_modules(*modules)\n      modules = modules.map do |m|\n        m.is_a?(Symbol) ? ActionController.const_get(m) : m\n      end",
    "comment": "Shortcut helper that returns all the ActionController::API modules except the ones passed as arguments:  class MyAPIBaseController < ActionController::Metal ActionController::API.without_modules(:UrlFor).each do |left| include left end end  This gives better control over what you want to exclude and makes it easier to create an API controller class, instead of listing the modules required manually.",
    "label": "",
    "id": "195"
  },
  {
    "raw_code": "def self.without_modules(*modules)\n      modules = modules.map do |m|\n        m.is_a?(Symbol) ? ActionController.const_get(m) : m\n      end",
    "comment": "Shortcut helper that returns all the modules included in ActionController::Base except the ones passed as arguments:  class MyBaseController < ActionController::Metal ActionController::Base.without_modules(:ParamsWrapper, :Streaming).each do |left| include left end end  This gives better control over what you want to exclude and makes it easier to create a bare controller class, instead of listing the modules required manually.",
    "label": "",
    "id": "196"
  },
  {
    "raw_code": "def default_form_builder(builder)\n        self._default_form_builder = builder\n      end",
    "comment": "Set the form builder to be used as the default for all forms in the views rendered by this controller and its subclasses.  #### Parameters *   `builder` - Default form builder. Accepts a subclass of ActionView::Helpers::FormBuilder",
    "label": "",
    "id": "197"
  },
  {
    "raw_code": "def default_form_builder\n      self.class._default_form_builder\n    end",
    "comment": "Default form builder for the controller",
    "label": "",
    "id": "198"
  },
  {
    "raw_code": "def rescue_from_callback(event)\n      exception = event.payload[:exception]\n      info { \"rescue_from handled #{exception.class} (#{exception.message}) - #{exception.backtrace.first.delete_prefix(\"#{Rails.root}/\")}\" }\n    end",
    "comment": "Manually subscribed below",
    "label": "",
    "id": "199"
  },
  {
    "raw_code": "def #{method}(event)\n          return unless ActionController::Base.enable_fragment_cache_logging\n          key         = ActiveSupport::Cache.expand_cache_key(event.payload[:key] || event.payload[:path])\n          human_name  = #{method.to_s.humanize.inspect}\n          info(\"\\#{human_name} \\#{key} (\\#{event.duration.round(1)}ms)\")\n        end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "200"
  },
  {
    "raw_code": "def self.controller_name\n      @controller_name ||= (name.demodulize.delete_suffix(\"Controller\").underscore unless anonymous?)\n    end",
    "comment": "Returns the last part of the controller's name, underscored, without the ending `Controller`. For instance, `PostsController` returns `posts`. Namespaces are left out, so `Admin::PostsController` returns `posts` as well.  #### Returns *   `string`",
    "label": "",
    "id": "201"
  },
  {
    "raw_code": "def controller_name\n      self.class.controller_name\n    end",
    "comment": "Delegates to the class's ::controller_name.",
    "label": "",
    "id": "202"
  },
  {
    "raw_code": "def url_for(string)\n      string\n    end",
    "comment": "Basic `url_for` that can be overridden for more robust functionality.",
    "label": "",
    "id": "203"
  },
  {
    "raw_code": "def performed?\n      response_body || response.committed?\n    end",
    "comment": "Tests if render or redirect has already happened.",
    "label": "",
    "id": "204"
  },
  {
    "raw_code": "def response=(response)\n      set_response!(response)\n\n      # Force `performed?` to return true:\n      @_response_body = true\n    end",
    "comment": "Assign the response and mark it as committed. No further processing will occur.",
    "label": "",
    "id": "205"
  },
  {
    "raw_code": "def use(...)\n        middleware_stack.use(...)\n      end",
    "comment": "Pushes the given Rack middleware and its arguments to the bottom of the middleware stack.",
    "label": "",
    "id": "206"
  },
  {
    "raw_code": "def self.middleware\n      middleware_stack\n    end",
    "comment": "The middleware stack used by this controller.  By default uses a variation of ActionDispatch::MiddlewareStack which allows for the following syntax:  class PostsController < ApplicationController use AuthenticationMiddleware, except: [:index, :show] end  Read more about [Rails middleware stack] (https://guides.rubyonrails.org/rails_on_rack.html#action-dispatcher-middleware-stack) in the guides.",
    "label": "",
    "id": "207"
  },
  {
    "raw_code": "def self.action(name)\n      app = lambda { |env|\n        req = ActionDispatch::Request.new(env)\n        res = make_response! req\n        new.dispatch(name, req, res)\n      }\n\n      if middleware_stack.any?\n        middleware_stack.build(name, app)\n      else\n        app\n      end",
    "comment": "Returns a Rack endpoint for the given action name.",
    "label": "",
    "id": "208"
  },
  {
    "raw_code": "def self.dispatch(name, req, res)\n      if middleware_stack.any?\n        middleware_stack.build(name) { |env| new.dispatch(name, req, res) }.call req.env\n      else\n        new.dispatch(name, req, res)\n      end",
    "comment": "Direct dispatch to the controller. Instantiates the controller, then executes the action named `name`.",
    "label": "",
    "id": "209"
  },
  {
    "raw_code": "def self.for(controller, env = nil, defaults = DEFAULTS)\n      new(controller, env, defaults)\n    end",
    "comment": "Creates a new renderer using the given controller class. See ::new.",
    "label": "",
    "id": "210"
  },
  {
    "raw_code": "def new(env = nil)\n      self.class.new controller, env, @defaults\n    end",
    "comment": "Creates a new renderer using the same controller, but with a new Rack env.  ApplicationController.renderer.new(method: \"post\") ",
    "label": "",
    "id": "211"
  },
  {
    "raw_code": "def with_defaults(defaults)\n      self.class.new controller, @env, @defaults.merge(defaults)\n    end",
    "comment": "Creates a new renderer using the same controller, but with the given defaults merged on top of the previous defaults.",
    "label": "",
    "id": "212"
  },
  {
    "raw_code": "def initialize(controller, env, defaults)\n      @controller = controller\n      @defaults = defaults\n      if env.blank? && @defaults == DEFAULTS\n        @env = DEFAULT_ENV\n      else\n        @env = normalize_env(@defaults)\n        @env.merge!(normalize_env(env)) unless env.blank?\n      end",
    "comment": "Initializes a new Renderer.  #### Parameters  *   `controller` - The controller class to instantiate for rendering. *   `env` - The Rack env to use for mocking a request when rendering. Entries can be typical Rack env keys and values, or they can be any of the following, which will be converted appropriately: *   `:http_host` - The HTTP host for the incoming request. Converts to Rack's `HTTP_HOST`. *   `:https` - Boolean indicating whether the incoming request uses HTTPS. Converts to Rack's `HTTPS`. *   `:method` - The HTTP method for the incoming request, case-insensitive. Converts to Rack's `REQUEST_METHOD`. *   `:script_name` - The portion of the incoming request's URL path that corresponds to the application. Converts to Rack's `SCRIPT_NAME`. *   `:input` - The input stream. Converts to Rack's `rack.input`. *   `defaults` - Default values for the Rack env. Entries are specified in the same format as `env`. `env` will be merged on top of these values. `defaults` will be retained when calling #new on a renderer instance.   If no `http_host` is specified, the env HTTP host will be derived from the routes' `default_url_options`. In this case, the `https` boolean and the `script_name` will also be derived from `default_url_options` if they were not specified. Additionally, the `https` boolean will fall back to `Rails.application.config.force_ssl` if `default_url_options` does not specify a `protocol`.",
    "label": "",
    "id": "213"
  },
  {
    "raw_code": "def render(*args)\n      request = ActionDispatch::Request.new(env_for_request)\n      request.routes = controller._routes\n\n      instance = controller.new\n      instance.set_request! request\n      instance.set_response! controller.make_response!(request)\n      instance.render_to_string(*args)\n    end",
    "comment": "Renders a template to a string, just like ActionController::Rendering#render_to_string.",
    "label": "",
    "id": "214"
  },
  {
    "raw_code": "def self.create(controller_class)\n      env = {}\n      env = Rails.application.env_config.merge(env) if defined?(Rails.application) && Rails.application\n      env[\"rack.request.cookie_hash\"] = {}.with_indifferent_access\n      new(default_env.merge(env), new_session, controller_class)\n    end",
    "comment": "Create a new test request with default `env` values.",
    "label": "",
    "id": "215"
  },
  {
    "raw_code": "def tests(controller_class)\n          case controller_class\n          when String, Symbol\n            self.controller_class = \"#{controller_class.to_s.camelize}Controller\".constantize\n          when Class\n            self.controller_class = controller_class\n          else\n            raise ArgumentError, \"controller class must be a String, Symbol, or Class\"\n          end",
    "comment": "Sets the controller class name. Useful if the name can't be inferred from test class. Normalizes `controller_class` before using.  tests WidgetController tests :widget tests 'widget'",
    "label": "",
    "id": "216"
  },
  {
    "raw_code": "def get(action, **args)\n        process(action, method: \"GET\", **args)\n      end",
    "comment": "Simulate a GET request with the given parameters.  *   `action`: The controller action to call. *   `params`: The hash with HTTP parameters that you want to pass. This may be `nil`. *   `body`: The request body with a string that is appropriately encoded (`application/x-www-form-urlencoded` or `multipart/form-data`). *   `session`: A hash of parameters to store in the session. This may be `nil`. *   `flash`: A hash of parameters to store in the flash. This may be `nil`.   You can also simulate POST, PATCH, PUT, DELETE, and HEAD requests with `post`, `patch`, `put`, `delete`, and `head`. Example sending parameters, session, and setting a flash message:  get :show, params: { id: 7 }, session: { user_id: 1 }, flash: { notice: 'This is flash message' }  Note that the request method is not verified. The different methods are available to make the tests more expressive.",
    "label": "",
    "id": "217"
  },
  {
    "raw_code": "def post(action, **args)\n        process(action, method: \"POST\", **args)\n      end",
    "comment": "Simulate a POST request with the given parameters and set/volley the response. See `get` for more details.",
    "label": "",
    "id": "218"
  },
  {
    "raw_code": "def patch(action, **args)\n        process(action, method: \"PATCH\", **args)\n      end",
    "comment": "Simulate a PATCH request with the given parameters and set/volley the response. See `get` for more details.",
    "label": "",
    "id": "219"
  },
  {
    "raw_code": "def put(action, **args)\n        process(action, method: \"PUT\", **args)\n      end",
    "comment": "Simulate a PUT request with the given parameters and set/volley the response. See `get` for more details.",
    "label": "",
    "id": "220"
  },
  {
    "raw_code": "def delete(action, **args)\n        process(action, method: \"DELETE\", **args)\n      end",
    "comment": "Simulate a DELETE request with the given parameters and set/volley the response. See `get` for more details.",
    "label": "",
    "id": "221"
  },
  {
    "raw_code": "def head(action, **args)\n        process(action, method: \"HEAD\", **args)\n      end",
    "comment": "Simulate a HEAD request with the given parameters and set/volley the response. See `get` for more details.",
    "label": "",
    "id": "222"
  },
  {
    "raw_code": "def process(action, method: \"GET\", params: nil, session: nil, body: nil, flash: {}, format: nil, xhr: false, as: nil)\n        check_required_ivars\n        @controller.clear_instance_variables_between_requests\n\n        action = +action.to_s\n        http_method = method.to_s.upcase\n\n        @html_document = nil\n\n        cookies.update(@request.cookies)\n        cookies.update_cookies_from_jar\n        @request.set_header \"HTTP_COOKIE\", cookies.to_header\n        @request.delete_header \"action_dispatch.cookies\"\n\n        @request          = TestRequest.new scrub_env!(@request.env), @request.session, @controller.class\n        @response         = build_response @response_klass\n        @response.request = @request\n        @controller.recycle!\n\n        if body\n          @request.set_header \"RAW_POST_DATA\", body\n        end",
    "comment": "Simulate an HTTP request to `action` by specifying request method, parameters and set/volley the response.  *   `action`: The controller action to call. *   `method`: Request method used to send the HTTP request. Possible values are `GET`, `POST`, `PATCH`, `PUT`, `DELETE`, `HEAD`. Defaults to `GET`. Can be a symbol. *   `params`: The hash with HTTP parameters that you want to pass. This may be `nil`. *   `body`: The request body with a string that is appropriately encoded (`application/x-www-form-urlencoded` or `multipart/form-data`). *   `session`: A hash of parameters to store in the session. This may be `nil`. *   `flash`: A hash of parameters to store in the flash. This may be `nil`. *   `format`: Request format. Defaults to `nil`. Can be string or symbol. *   `as`: Content type. Defaults to `nil`. Must be a symbol that corresponds to a mime type.   Example calling `create` action and sending two params:  process :create, method: 'POST', params: { user: { name: 'Gaurish Sharma', email: 'user@example.com' } }, session: { user_id: 1 }, flash: { notice: 'This is flash message' }  To simulate `GET`, `POST`, `PATCH`, `PUT`, `DELETE`, and `HEAD` requests prefer using #get, #post, #patch, #put, #delete and #head methods respectively which will make tests more expressive.  It's not recommended to make more than one request in the same test. Instance variables that are set in one request will not persist to the next request, but it's not guaranteed that all Rails internal state will be reset. Prefer ActionDispatch::IntegrationTest for making multiple requests in the same test.  Note that the request method is not verified.",
    "label": "",
    "id": "223"
  },
  {
    "raw_code": "def allow_browser(versions:, block: -> { render file: Rails.root.join(\"public/406-unsupported-browser.html\"), layout: false, status: :not_acceptable }, **options)\n        before_action -> { allow_browser(versions: versions, block: block) }, **options\n      end",
    "comment": "Specify the browser versions that will be allowed to access all actions (or some, as limited by `only:` or `except:`). Only browsers matched in the hash or named set passed to `versions:` will be blocked if they're below the versions specified. This means that all other browsers, as well as agents that aren't reporting a user-agent header, will be allowed access.  A browser that's blocked will by default be served the file in public/406-unsupported-browser.html with an HTTP status code of \"406 Not Acceptable\".  In addition to specifically named browser versions, you can also pass `:modern` as the set to restrict support to browsers natively supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has. This includes Safari 17.2+, Chrome 120+, Firefox 121+, Opera 106+.  You can use https://caniuse.com to check for browser versions supporting the features you use.  You can use `ActiveSupport::Notifications` to subscribe to events of browsers being blocked using the `browser_block.action_controller` event name.  Examples:  class ApplicationController < ActionController::Base # Allow only browsers natively supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has allow_browser versions: :modern end  class ApplicationController < ActionController::Base # Allow only browsers natively supporting webp images, web push, badges, import maps, CSS nesting, and CSS :has allow_browser versions: :modern, block: :handle_outdated_browser  private def handle_outdated_browser render file: Rails.root.join(\"public/custom-error.html\"), status: :not_acceptable end end  class ApplicationController < ActionController::Base # All versions of Chrome and Opera will be allowed, but no versions of \"internet explorer\" (ie). Safari needs to be 16.4+ and Firefox 121+. allow_browser versions: { safari: 16.4, firefox: 121, ie: false } end  class MessagesController < ApplicationController # In addition to the browsers blocked by ApplicationController, also block Opera below 104 and Chrome below 119 for the show action. allow_browser versions: { opera: 104, chrome: 119 }, only: :show end",
    "label": "",
    "id": "224"
  },
  {
    "raw_code": "def etag(&etagger)\n        self.etaggers += [etagger]\n      end",
    "comment": "Allows you to consider additional controller-wide information when generating an ETag. For example, if you serve pages tailored depending on who's logged in at the moment, you may want to add the current user id to be part of the ETag to prevent unauthorized displaying of cached pages.  class InvoicesController < ApplicationController etag { current_user&.id }  def show # Etag will differ even for the same invoice when it's viewed by a different current_user @invoice = Invoice.find(params[:id]) fresh_when etag: @invoice end end",
    "label": "",
    "id": "225"
  },
  {
    "raw_code": "def fresh_when(object = nil, etag: nil, weak_etag: nil, strong_etag: nil, last_modified: nil, public: false, cache_control: {}, template: nil)\n      response.cache_control.delete(:no_store)\n      weak_etag ||= etag || object unless strong_etag\n      last_modified ||= object.try(:updated_at) || object.try(:maximum, :updated_at)\n\n      if strong_etag\n        response.strong_etag = combine_etags strong_etag,\n          last_modified: last_modified, public: public, template: template\n      elsif weak_etag || template\n        response.weak_etag = combine_etags weak_etag,\n          last_modified: last_modified, public: public, template: template\n      end",
    "comment": "Sets the `etag`, `last_modified`, or both on the response, and renders a `304 Not Modified` response if the request is already fresh.  #### Options  `:etag` :   Sets a \"weak\" ETag validator on the response. See the `:weak_etag` option.  `:weak_etag` :   Sets a \"weak\" ETag validator on the response. Requests that specify an `If-None-Match` header may receive a `304 Not Modified` response if the ETag matches exactly.  :   A weak ETag indicates semantic equivalence, not byte-for-byte equality, so they're good for caching HTML pages in browser caches. They can't be used for responses that must be byte-identical, like serving `Range` requests within a PDF file.  `:strong_etag` :   Sets a \"strong\" ETag validator on the response. Requests that specify an `If-None-Match` header may receive a `304 Not Modified` response if the ETag matches exactly.  :   A strong ETag implies exact equality -- the response must match byte for byte. This is necessary for serving `Range` requests within a large video or PDF file, for example, or for compatibility with some CDNs that don't support weak ETags.  `:last_modified` :   Sets a \"weak\" last-update validator on the response. Subsequent requests that specify an `If-Modified-Since` header may receive a `304 Not Modified` response if `last_modified` <= `If-Modified-Since`.  `:public` :   By default the `Cache-Control` header is private. Set this option to `true` if you want your application to be cacheable by other devices, such as proxy caches.  `:cache_control` :   When given, will overwrite an existing `Cache-Control` header. For a list of `Cache-Control` directives, see the [article on MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control).  `:template` :   By default, the template digest for the current controller/action is included in ETags. If the action renders a different template, you can include its digest instead. If the action doesn't render a template at all, you can pass `template: false` to skip any attempt to check for a template digest.   #### Examples  def show @article = Article.find(params[:id]) fresh_when(etag: @article, last_modified: @article.updated_at, public: true) end  This will send a `304 Not Modified` response if the request specifies a matching ETag and `If-Modified-Since` header. Otherwise, it will render the `show` template.  You can also just pass a record:  def show @article = Article.find(params[:id]) fresh_when(@article) end  `etag` will be set to the record, and `last_modified` will be set to the record's `updated_at`.  You can also pass an object that responds to `maximum`, such as a collection of records:  def index @articles = Article.all fresh_when(@articles) end  In this case, `etag` will be set to the collection, and `last_modified` will be set to `maximum(:updated_at)` (the timestamp of the most recently updated record).  When passing a record or a collection, you can still specify other options, such as `:public` and `:cache_control`:  def show @article = Article.find(params[:id]) fresh_when(@article, public: true, cache_control: { no_cache: true }) end  The above will set `Cache-Control: public, no-cache` in the response.  When rendering a different template than the controller/action's default template, you can indicate which digest to include in the ETag:  before_action { fresh_when @article, template: \"widgets/show\" } ",
    "label": "",
    "id": "226"
  },
  {
    "raw_code": "def stale?(object = nil, **freshness_kwargs)\n      fresh_when(object, **freshness_kwargs)\n      !request.fresh?(response)\n    end",
    "comment": "Sets the `etag` and/or `last_modified` on the response and checks them against the request. If the request doesn't match the provided options, it is considered stale, and the response should be rendered from scratch. Otherwise, it is fresh, and a `304 Not Modified` is sent.  #### Options  See #fresh_when for supported options.  #### Examples  def show @article = Article.find(params[:id])  if stale?(etag: @article, last_modified: @article.updated_at) @statistics = @article.really_expensive_call respond_to do |format| # all the supported formats end end end  You can also just pass a record:  def show @article = Article.find(params[:id])  if stale?(@article) @statistics = @article.really_expensive_call respond_to do |format| # all the supported formats end end end  `etag` will be set to the record, and `last_modified` will be set to the record's `updated_at`.  You can also pass an object that responds to `maximum`, such as a collection of records:  def index @articles = Article.all  if stale?(@articles) @statistics = @articles.really_expensive_call respond_to do |format| # all the supported formats end end end  In this case, `etag` will be set to the collection, and `last_modified` will be set to `maximum(:updated_at)` (the timestamp of the most recently updated record).  When passing a record or a collection, you can still specify other options, such as `:public` and `:cache_control`:  def show @article = Article.find(params[:id])  if stale?(@article, public: true, cache_control: { no_cache: true }) @statistics = @articles.really_expensive_call respond_to do |format| # all the supported formats end end end  The above will set `Cache-Control: public, no-cache` in the response.  When rendering a different template than the controller/action's default template, you can indicate which digest to include in the ETag:  def show super if stale?(@article, template: \"widgets/show\") end ",
    "label": "",
    "id": "227"
  },
  {
    "raw_code": "def expires_in(seconds, options = {})\n      response.cache_control.delete(:no_store)\n      response.cache_control.merge!(\n        max_age: seconds,\n        public: options.delete(:public),\n        must_revalidate: options.delete(:must_revalidate),\n        stale_while_revalidate: options.delete(:stale_while_revalidate),\n        stale_if_error: options.delete(:stale_if_error),\n        immutable: options.delete(:immutable),\n      )\n      options.delete(:private)\n\n      response.cache_control[:extras] = options.map { |k, v| \"#{k}=#{v}\" }\n      response.date = Time.now unless response.date?\n    end",
    "comment": "Sets the `Cache-Control` header, overwriting existing directives. This method will also ensure an HTTP `Date` header for client compatibility.  Defaults to issuing the `private` directive, so that intermediate caches must not cache the response.  #### Options  `:public` :   If true, replaces the default `private` directive with the `public` directive.  `:must_revalidate` :   If true, adds the `must-revalidate` directive.  `:stale_while_revalidate` :   Sets the value of the `stale-while-revalidate` directive.  `:stale_if_error` :   Sets the value of the `stale-if-error` directive.  `:immutable` :   If true, adds the `immutable` directive.   Any additional key-value pairs are concatenated as directives. For a list of supported `Cache-Control` directives, see the [article on MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control).  #### Examples  expires_in 10.minutes # => Cache-Control: max-age=600, private  expires_in 10.minutes, public: true # => Cache-Control: max-age=600, public  expires_in 10.minutes, public: true, must_revalidate: true # => Cache-Control: max-age=600, public, must-revalidate  expires_in 1.hour, stale_while_revalidate: 60.seconds # => Cache-Control: max-age=3600, private, stale-while-revalidate=60  expires_in 1.hour, stale_if_error: 5.minutes # => Cache-Control: max-age=3600, private, stale-if-error=300  expires_in 1.hour, public: true, \"s-maxage\": 3.hours, \"no-transform\": true # => Cache-Control: max-age=3600, public, s-maxage=10800, no-transform=true ",
    "label": "",
    "id": "228"
  },
  {
    "raw_code": "def expires_now\n      response.cache_control.replace(no_cache: true)\n    end",
    "comment": "Sets an HTTP 1.1 `Cache-Control` header of `no-cache`. This means the resource will be marked as stale, so clients must always revalidate. Intermediate/browser caches may still store the asset.",
    "label": "",
    "id": "229"
  },
  {
    "raw_code": "def http_cache_forever(public: false)\n      expires_in 100.years, public: public, immutable: true\n\n      yield if stale?(etag: request.fullpath,\n                      last_modified: Time.new(2011, 1, 1).utc,\n                      public: public)\n    end",
    "comment": "Cache or yield the block. The cache is supposed to never expire.  You can use this method when you have an HTTP response that never changes, and the browser and proxies should cache it indefinitely.  *   `public`: By default, HTTP responses are private, cached only on the user's web browser. To allow proxies to cache the response, set `true` to indicate that they can serve the cached response to all users.",
    "label": "",
    "id": "230"
  },
  {
    "raw_code": "def no_store\n      response.cache_control.replace(no_store: true)\n    end",
    "comment": "Sets an HTTP 1.1 `Cache-Control` header of `no-store`. This means the resource may not be stored in any cache.",
    "label": "",
    "id": "231"
  },
  {
    "raw_code": "def must_understand\n      response.cache_control[:must_understand] = true\n      response.cache_control[:no_store] = true\n    end",
    "comment": "Adds the `must-understand` directive to the `Cache-Control` header, which indicates that a cache MUST understand the semantics of the response status code that has been received, or discard the response.  This is particularly useful when returning responses with new or uncommon status codes that might not be properly interpreted by older caches.  #### Example  def show @article = Article.find(params[:id])  if @article.early_access? must_understand render status: 203 # Non-Authoritative Information else fresh_when @article end end ",
    "label": "",
    "id": "232"
  },
  {
    "raw_code": "def content_security_policy(enabled = true, **options, &block)\n        before_action(options) do\n          if block_given?\n            policy = current_content_security_policy\n            instance_exec(policy, &block)\n            request.content_security_policy = policy\n          end",
    "comment": "Overrides parts of the globally configured `Content-Security-Policy` header:  class PostsController < ApplicationController content_security_policy do |policy| policy.base_uri \"https://www.example.com\" end end  Options can be passed similar to `before_action`. For example, pass `only: :index` to override the header on the index action only:  class PostsController < ApplicationController content_security_policy(only: :index) do |policy| policy.default_src :self, :https end end  Pass `false` to remove the `Content-Security-Policy` header:  class PostsController < ApplicationController content_security_policy false, only: :index end",
    "label": "",
    "id": "233"
  },
  {
    "raw_code": "def content_security_policy_report_only(report_only = true, **options)\n        before_action(options) do\n          request.content_security_policy_report_only = report_only\n        end",
    "comment": "Overrides the globally configured `Content-Security-Policy-Report-Only` header:  class PostsController < ApplicationController content_security_policy_report_only only: :index end  Pass `false` to remove the `Content-Security-Policy-Report-Only` header:  class PostsController < ApplicationController content_security_policy_report_only false, only: :index end",
    "label": "",
    "id": "234"
  },
  {
    "raw_code": "def cookies # :doc:\n        request.cookie_jar\n      end",
    "comment": "The cookies for the current request. See ActionDispatch::Cookies for more information.",
    "label": "",
    "id": "235"
  },
  {
    "raw_code": "def send_file(path, options = {}) # :doc:\n        raise MissingFile, \"Cannot read file #{path}\" unless File.file?(path) && File.readable?(path)\n\n        options[:filename] ||= File.basename(path) unless options[:url_based_filename]\n        send_file_headers! options\n\n        self.status = options[:status] || 200\n        self.content_type = options[:content_type] if options.key?(:content_type)\n        response.send_file path\n      end",
    "comment": "Sends the file. This uses a server-appropriate method (such as `X-Sendfile`) via the `Rack::Sendfile` middleware. The header to use is set via `config.action_dispatch.x_sendfile_header`. Your server can also configure this for you by setting the `X-Sendfile-Type` header.  Be careful to sanitize the path parameter if it is coming from a web page. `send_file(params[:path])` allows a malicious user to download any file on your server.  #### Options:  *   `:filename` - suggests a filename for the browser to use. Defaults to `File.basename(path)`. *   `:type` - specifies an HTTP content type. You can specify either a string or a symbol for a registered type with `Mime::Type.register`, for example `:json`. If omitted, the type will be inferred from the file extension specified in `:filename`. If no content type is registered for the extension, the default type `application/octet-stream` will be used. *   `:disposition` - specifies whether the file will be shown inline or downloaded. Valid values are `\"inline\"` and `\"attachment\"` (default). *   `:status` - specifies the status code to send with the response. Defaults to 200. *   `:url_based_filename` - set to `true` if you want the browser to guess the filename from the URL, which is necessary for i18n filenames on certain browsers (setting `:filename` overrides this option).   The default `Content-Type` and `Content-Disposition` headers are set to download arbitrary binary files in as many browsers as possible. IE versions 4, 5, 5.5, and 6 are all known to have a variety of quirks (especially when downloading over SSL).  Simple download:  send_file '/path/to.zip'  Show a JPEG in the browser:  send_file '/path/to.jpeg', type: 'image/jpeg', disposition: 'inline'  Show a 404 page in the browser:  send_file '/path/to/404.html', type: 'text/html; charset=utf-8', disposition: 'inline', status: 404  You can use other `Content-*` HTTP headers to provide additional information to the client. See MDN for a [list of HTTP headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers).  Also be aware that the document may be cached by proxies and browsers. The `Pragma` and `Cache-Control` headers declare how the file may be cached by intermediaries. They default to require clients to validate with the server before releasing cached responses. See https://www.mnot.net/cache_docs/ for an overview of web caching and [RFC 9111](https://www.rfc-editor.org/rfc/rfc9111.html#name-cache-control) for the `Cache-Control` header spec.",
    "label": "",
    "id": "236"
  },
  {
    "raw_code": "def send_data(data, options = {}) # :doc:\n        send_file_headers! options\n        render options.slice(:status, :content_type).merge(body: data)\n      end",
    "comment": "Sends the given binary data to the browser. This method is similar to `render plain: data`, but also allows you to specify whether the browser should display the response as a file attachment (i.e. in a download dialog) or as inline data. You may also set the content type, the file name, and other things.  #### Options:  *   `:filename` - suggests a filename for the browser to use. *   `:type` - specifies an HTTP content type. Defaults to `application/octet-stream`. You can specify either a string or a symbol for a registered type with `Mime::Type.register`, for example `:json`. If omitted, type will be inferred from the file extension specified in `:filename`. If no content type is registered for the extension, the default type `application/octet-stream` will be used. *   `:disposition` - specifies whether the file will be shown inline or downloaded. Valid values are `\"inline\"` and `\"attachment\"` (default). *   `:status` - specifies the status code to send with the response. Defaults to 200.   Generic data download:  send_data buffer  Download a dynamically-generated tarball:  send_data generate_tgz('dir'), filename: 'dir.tgz'  Display an image Active Record in the browser:  send_data image.data, type: image.content_type, disposition: 'inline'  See `send_file` for more information on HTTP `Content-*` headers and caching.",
    "label": "",
    "id": "237"
  },
  {
    "raw_code": "def pick_template_for_etag(options)\n        unless options[:template] == false\n          options[:template] || lookup_context.find_all(action_name, _prefixes).first&.virtual_path\n        end",
    "comment": "Pick the template digest to include in the ETag. If the `:template` option is present, use the named template. If `:template` is `nil` or absent, use the default controller/action template. If `:template` is false, omit the template digest from the ETag.",
    "label": "",
    "id": "238"
  },
  {
    "raw_code": "def add_flash_types(*types)\n        types.each do |type|\n          next if _flash_types.include?(type)\n\n          define_method(type) do\n            request.flash[type]\n          end",
    "comment": "Creates new flash types. You can pass as many types as you want to create flash types other than the default `alert` and `notice` in your controllers and views. For instance:  # in application_controller.rb class ApplicationController < ActionController::Base add_flash_types :warning end  # in your controller redirect_to user_path(@user), warning: \"Incomplete profile\"  # in your view <%= warning %>  This method will automatically define a new method for each of the given names, and it will be available in your views.",
    "label": "",
    "id": "239"
  },
  {
    "raw_code": "def head(status, options = nil)\n      if status.is_a?(Hash)\n        raise ArgumentError, \"#{status.inspect} is not a valid value for `status`.\"\n      end",
    "comment": "Returns a response that has no content (merely headers). The options argument is interpreted to be a hash of header names and values. This allows you to easily return a response that consists only of significant headers:  head :created, location: person_path(@person)  head :created, location: @person  It can also be used to return exceptional conditions:  return head(:method_not_allowed) unless request.post? return head(:bad_request) unless valid_request? render  See `Rack::Utils::SYMBOL_TO_STATUS_CODE` for a full list of valid `status` symbols.",
    "label": "",
    "id": "240"
  },
  {
    "raw_code": "def helper_attr(*attrs)\n        attrs.flatten.each { |attr| helper_method(attr, \"#{attr}=\") }\n      end",
    "comment": "Declares helper accessors for controller attributes. For example, the following adds new `name` and `name=` instance methods to a controller and makes them available to the view: attr_accessor :name helper_attr :name  #### Parameters *   `attrs` - Names of attributes to be converted into helpers. ",
    "label": "",
    "id": "241"
  },
  {
    "raw_code": "def helpers\n        @helper_proxy ||= begin\n          proxy = ActionView::Base.empty\n          proxy.config = config.inheritable_copy\n          proxy.extend(_helpers)\n        end",
    "comment": "Provides a proxy to access helper methods from outside the view.  Note that the proxy is rendered under a different view context. This may cause incorrect behavior with capture methods. Consider using [helper](rdoc-ref:AbstractController::Helpers::ClassMethods#helper) instead when using `capture`.",
    "label": "",
    "id": "242"
  },
  {
    "raw_code": "def modules_for_helpers(args)\n        args += all_application_helpers if args.delete(:all)\n        super(args)\n      end",
    "comment": "Override modules_for_helpers to accept `:all` as argument, which loads all helpers in helpers_path.  #### Parameters *   `args` - A list of helpers   #### Returns *   `array` - A normalized list of modules for the list of helpers provided. ",
    "label": "",
    "id": "243"
  },
  {
    "raw_code": "def all_application_helpers\n          all_helpers_from_path(helpers_path)\n        end",
    "comment": "Extract helper names from files in `app/helpers/***/**_helper.rb`",
    "label": "",
    "id": "244"
  },
  {
    "raw_code": "def helpers\n      @_helper_proxy ||= view_context\n    end",
    "comment": "Provides a proxy to access helper methods from outside the view.",
    "label": "",
    "id": "245"
  },
  {
    "raw_code": "def http_basic_authenticate_with(name:, password:, realm: nil, **options)\n            raise ArgumentError, \"Expected name: to be a String, got #{name.class}\" unless name.is_a?(String)\n            raise ArgumentError, \"Expected password: to be a String, got #{password.class}\" unless password.is_a?(String)\n            before_action(options) { http_basic_authenticate_or_request_with name: name, password: password, realm: realm }\n          end",
    "comment": "Enables HTTP Basic authentication.  See ActionController::HttpAuthentication::Basic for example usage.",
    "label": "",
    "id": "246"
  },
  {
    "raw_code": "def authenticate_or_request_with_http_digest(realm = \"Application\", message = nil, &password_procedure)\n          authenticate_with_http_digest(realm, &password_procedure) || request_http_digest_authentication(realm, message)\n        end",
    "comment": "Authenticate using an HTTP Digest, or otherwise render an HTTP header requesting the client to send a Digest.  See ActionController::HttpAuthentication::Digest for example usage.",
    "label": "",
    "id": "247"
  },
  {
    "raw_code": "def authenticate_with_http_digest(realm = \"Application\", &password_procedure)\n          HttpAuthentication::Digest.authenticate(request, realm, &password_procedure)\n        end",
    "comment": "Authenticate using an HTTP Digest. Returns true if authentication is successful, false otherwise.",
    "label": "",
    "id": "248"
  },
  {
    "raw_code": "def request_http_digest_authentication(realm = \"Application\", message = nil)\n          HttpAuthentication::Digest.authentication_request(self, realm, message)\n        end",
    "comment": "Render an HTTP header requesting the client to send a Digest for authentication.",
    "label": "",
    "id": "249"
  },
  {
    "raw_code": "def authenticate(request, realm, &password_procedure)\n        request.authorization && validate_digest_response(request, realm, &password_procedure)\n      end",
    "comment": "Returns true on a valid response, false otherwise.",
    "label": "",
    "id": "250"
  },
  {
    "raw_code": "def validate_digest_response(request, realm, &password_procedure)\n        secret_key  = secret_token(request)\n        credentials = decode_credentials_header(request)\n        valid_nonce = validate_nonce(secret_key, request, credentials[:nonce])\n\n        if valid_nonce && realm == credentials[:realm] && opaque(secret_key) == credentials[:opaque]\n          password = password_procedure.call(credentials[:username])\n          return false unless password\n\n          method = request.get_header(\"rack.methodoverride.original_method\") || request.get_header(\"REQUEST_METHOD\")\n          uri    = credentials[:uri]\n\n          [true, false].any? do |trailing_question_mark|\n            [true, false].any? do |password_is_ha1|\n              _uri = trailing_question_mark ? uri + \"?\" : uri\n              expected = expected_response(method, _uri, credentials, password, password_is_ha1)\n              expected == credentials[:response]\n            end",
    "comment": "Returns false unless the request credentials response value matches the expected value. First try the password as a ha1 digest password. If this fails, then try it as a plain text password.",
    "label": "",
    "id": "251"
  },
  {
    "raw_code": "def expected_response(http_method, uri, credentials, password, password_is_ha1 = true)\n        ha1 = password_is_ha1 ? password : ha1(credentials, password)\n        ha2 = OpenSSL::Digest::MD5.hexdigest([http_method.to_s.upcase, uri].join(\":\"))\n        OpenSSL::Digest::MD5.hexdigest([ha1, credentials[:nonce], credentials[:nc], credentials[:cnonce], credentials[:qop], ha2].join(\":\"))\n      end",
    "comment": "Returns the expected response for a request of `http_method` to `uri` with the decoded `credentials` and the expected `password` Optional parameter `password_is_ha1` is set to `true` by default, since best practice is to store ha1 digest instead of a plain-text password.",
    "label": "",
    "id": "252"
  },
  {
    "raw_code": "def nonce(secret_key, time = Time.now)\n        t = time.to_i\n        hashed = [t, secret_key]\n        digest = OpenSSL::Digest::MD5.hexdigest(hashed.join(\":\"))\n        ::Base64.strict_encode64(\"#{t}:#{digest}\")\n      end",
    "comment": "Uses an MD5 digest based on time to generate a value to be used only once.  A server-specified data string which should be uniquely generated each time a 401 response is made. It is recommended that this string be base64 or hexadecimal data. Specifically, since the string is passed in the header lines as a quoted string, the double-quote character is not allowed.  The contents of the nonce are implementation dependent. The quality of the implementation depends on a good choice. A nonce might, for example, be constructed as the base 64 encoding of  time-stamp H(time-stamp \":\" ETag \":\" private-key)  where time-stamp is a server-generated time or other non-repeating value, ETag is the value of the HTTP ETag header associated with the requested entity, and private-key is data known only to the server. With a nonce of this form a server would recalculate the hash portion after receiving the client authentication header and reject the request if it did not match the nonce from that header or if the time-stamp value is not recent enough. In this way the server can limit the time of the nonce's validity. The inclusion of the ETag prevents a replay request for an updated version of the resource. (Note: including the IP address of the client in the nonce would appear to offer the server the ability to limit the reuse of the nonce to the same client that originally got it. However, that would break proxy farms, where requests from a single user often go through different proxies in the farm. Also, IP address spoofing is not that hard.)  An implementation might choose not to accept a previously used nonce or a previously used digest, in order to protect against a replay attack. Or, an implementation might choose to use one-time nonces or digests for POST, PUT, or PATCH requests, and a time-stamp for GET requests. For more details on the issues involved see Section 4 of this document.  The nonce is opaque to the client. Composed of Time, and hash of Time with secret key from the Rails session secret generated upon creation of project. Ensures the time cannot be modified by client.",
    "label": "",
    "id": "253"
  },
  {
    "raw_code": "def validate_nonce(secret_key, request, value, seconds_to_timeout = 5 * 60)\n        return false if value.nil?\n        t = ::Base64.decode64(value).split(\":\").first.to_i\n        nonce(secret_key, t) == value && (t - Time.now.to_i).abs <= seconds_to_timeout\n      end",
    "comment": "Might want a shorter timeout depending on whether the request is a PATCH, PUT, or POST, and if the client is a browser or web service. Can be much shorter if the Stale directive is implemented. This would allow a user to use new nonce without prompting the user again for their username and password.",
    "label": "",
    "id": "254"
  },
  {
    "raw_code": "def opaque(secret_key)\n        OpenSSL::Digest::MD5.hexdigest(secret_key)\n      end",
    "comment": "Opaque based on digest of secret key",
    "label": "",
    "id": "255"
  },
  {
    "raw_code": "def authenticate_or_request_with_http_token(realm = \"Application\", message = nil, &login_procedure)\n          authenticate_with_http_token(&login_procedure) || request_http_token_authentication(realm, message)\n        end",
    "comment": "Authenticate using an HTTP Bearer token, or otherwise render an HTTP header requesting the client to send a Bearer token. For the authentication to be considered successful, `login_procedure` must not return a false value. Typically, the authenticated user is returned.  See ActionController::HttpAuthentication::Token for example usage.",
    "label": "",
    "id": "256"
  },
  {
    "raw_code": "def authenticate_with_http_token(&login_procedure)\n          Token.authenticate(self, &login_procedure)\n        end",
    "comment": "Authenticate using an HTTP Bearer token. Returns the return value of `login_procedure` if a token is found. Returns `nil` if no token is found.  See ActionController::HttpAuthentication::Token for example usage.",
    "label": "",
    "id": "257"
  },
  {
    "raw_code": "def request_http_token_authentication(realm = \"Application\", message = nil)\n          Token.authentication_request(self, realm, message)\n        end",
    "comment": "Render an HTTP header requesting the client to send a Bearer token for authentication.",
    "label": "",
    "id": "258"
  },
  {
    "raw_code": "def authenticate(controller, &login_procedure)\n        token, options = token_and_options(controller.request)\n        unless token.blank?\n          login_procedure.call(token, options)\n        end",
    "comment": "If token Authorization header is present, call the login procedure with the present token and options.  Returns the return value of `login_procedure` if a token is found. Returns `nil` if no token is found.  #### Parameters  *   `controller` - ActionController::Base instance for the current request. *   `login_procedure` - Proc to call if a token is present. The Proc should take two arguments:  authenticate(controller) { |token, options| ... }  ",
    "label": "",
    "id": "259"
  },
  {
    "raw_code": "def token_and_options(request)\n        authorization_request = request.authorization.to_s\n        if authorization_request[TOKEN_REGEX]\n          params = token_params_from authorization_request\n          [params.shift[1], Hash[params].with_indifferent_access]\n        end",
    "comment": "Parses the token and options out of the token Authorization header. The value for the Authorization header is expected to have the prefix `\"Token\"` or `\"Bearer\"`. If the header looks like this:  Authorization: Token token=\"abc\", nonce=\"def\"  Then the returned token is `\"abc\"`, and the options are `{nonce: \"def\"}`.  Returns an `Array` of `[String, Hash]` if a token is present. Returns `nil` if no token is found.  #### Parameters  *   `request` - ActionDispatch::Request instance with the current headers. ",
    "label": "",
    "id": "260"
  },
  {
    "raw_code": "def params_array_from(raw_params)\n        raw_params.map { |param| param.split %r/=(.+)?/ }\n      end",
    "comment": "Takes `raw_params` and turns it into an array of parameters.",
    "label": "",
    "id": "261"
  },
  {
    "raw_code": "def rewrite_param_values(array_params)\n        array_params.each { |param| (param[1] || +\"\").gsub! %r/^\"|\"$/, \"\" }\n      end",
    "comment": "This removes the `\"` characters wrapping the value.",
    "label": "",
    "id": "262"
  },
  {
    "raw_code": "def raw_params(auth)\n        _raw_params = auth.sub(TOKEN_REGEX, \"\").split(AUTHN_PAIR_DELIMITERS).map(&:strip)\n        _raw_params.reject!(&:empty?)\n\n        if !_raw_params.first&.start_with?(TOKEN_KEY)\n          _raw_params[0] = \"#{TOKEN_KEY}#{_raw_params.first}\"\n        end",
    "comment": "This method takes an authorization body and splits up the key-value pairs by the standardized `:`, `;`, or `\\t` delimiters defined in `AUTHN_PAIR_DELIMITERS`.",
    "label": "",
    "id": "263"
  },
  {
    "raw_code": "def encode_credentials(token, options = {})\n        values = [\"#{TOKEN_KEY}#{token.to_s.inspect}\"] + options.map do |key, value|\n          \"#{key}=#{value.to_s.inspect}\"\n        end",
    "comment": "Encodes the given token and options into an Authorization header value.  Returns String.  #### Parameters  *   `token` - String token. *   `options` - Optional Hash of the options. ",
    "label": "",
    "id": "264"
  },
  {
    "raw_code": "def authentication_request(controller, realm, message = nil)\n        message ||= \"HTTP Token: Access denied.\\n\"\n        controller.headers[\"WWW-Authenticate\"] = %(Token realm=\"#{realm.tr('\"', \"\")}\")\n        controller.__send__ :render, plain: message, status: :unauthorized\n      end",
    "comment": "Sets a WWW-Authenticate header to let the client know a token is desired.  Returns nothing.  #### Parameters  *   `controller` - ActionController::Base instance for the outgoing response. *   `realm` - String realm to use in the header. ",
    "label": "",
    "id": "265"
  },
  {
    "raw_code": "def halted_callback_hook(filter, _)\n        ActiveSupport::Notifications.instrument(\"halted_callback.action_controller\", filter: filter)\n      end",
    "comment": "A hook invoked every time a before callback is halted.",
    "label": "",
    "id": "266"
  },
  {
    "raw_code": "def cleanup_view_runtime # :doc:\n        yield\n      end",
    "comment": "A hook which allows you to clean up any time, wrongly taken into account in views, like database querying time.  def cleanup_view_runtime super - time_taken_in_something_expensive end",
    "label": "",
    "id": "267"
  },
  {
    "raw_code": "def append_info_to_payload(payload) # :doc:\n        payload[:view_runtime] = view_runtime\n      end",
    "comment": "Every time after an action is processed, this method is invoked with the payload, so you can add more information.",
    "label": "",
    "id": "268"
  },
  {
    "raw_code": "def log_process_action(payload) # :nodoc:\n          messages, view_runtime = [], payload[:view_runtime]\n          messages << (\"Views: %.1fms\" % view_runtime.to_f) if view_runtime\n          messages\n        end",
    "comment": "A hook which allows other frameworks to log what happened during controller process action. This method should return an array with the messages to be added.",
    "label": "",
    "id": "269"
  },
  {
    "raw_code": "def writeln(string)\n        write string.end_with?(\"\\n\") ? string : \"#{string}\\n\"\n      end",
    "comment": "Same as `write` but automatically include a newline at the end of the string.",
    "label": "",
    "id": "270"
  },
  {
    "raw_code": "def close\n        synchronize do\n          super\n          @buf.push nil\n          @cv.broadcast\n        end",
    "comment": "Write a 'close' event to the buffer; the producer/writing thread uses this to notify us that it's finished supplying content.  See also #abort.",
    "label": "",
    "id": "271"
  },
  {
    "raw_code": "def abort\n        synchronize do\n          @aborted = true\n          @buf.clear\n        end",
    "comment": "Inform the producer/writing thread that the client has disconnected; the reading thread is no longer interested in anything that's being written.  See also #close.",
    "label": "",
    "id": "272"
  },
  {
    "raw_code": "def connected?\n        !@aborted\n      end",
    "comment": "Is the client still connected and waiting for content?  The result of calling `write` when this is `false` is determined by `ignore_disconnect`.",
    "label": "",
    "id": "273"
  },
  {
    "raw_code": "def send_stream(filename:, disposition: \"attachment\", type: nil)\n      payload = { filename: filename, disposition: disposition, type: type }\n      ActiveSupport::Notifications.instrument(\"send_stream.action_controller\", payload) do\n        response.headers[\"Content-Type\"] =\n          (type.is_a?(Symbol) ? Mime[type].to_s : type) ||\n          Mime::Type.lookup_by_extension(File.extname(filename).downcase.delete(\".\"))&.to_s ||\n          \"application/octet-stream\"\n\n        response.headers[\"Content-Disposition\"] =\n          ActionDispatch::Http::ContentDisposition.format(disposition: disposition, filename: filename)\n\n        yield response.stream\n      end",
    "comment": "Sends a stream to the browser, which is helpful when you're generating exports or other running data where you don't want the entire file buffered in memory first. Similar to send_data, but where the data is generated live.  #### Options:  *   `:filename` - suggests a filename for the browser to use. *   `:type` - specifies an HTTP content type. You can specify either a string or a symbol for a registered type with `Mime::Type.register`, for example :json. If omitted, type will be inferred from the file extension specified in `:filename`. If no content type is registered for the extension, the default type 'application/octet-stream' will be used. *   `:disposition` - specifies whether the file will be shown inline or downloaded. Valid values are 'inline' and 'attachment' (default).   Example of generating a csv export:  send_stream(filename: \"subscribers.csv\") do |stream| stream.write \"email_address,updated_at\\n\"  @subscribers.find_each do |subscriber| stream.write \"#{subscriber.email_address},#{subscriber.updated_at}\\n\" end end",
    "label": "",
    "id": "274"
  },
  {
    "raw_code": "def new_controller_thread # :nodoc:\n        ActionController::Live.live_thread_pool_executor.post do\n          t2 = Thread.current\n          t2.abort_on_exception = true\n          yield\n        end",
    "comment": "Spawn a new thread to serve up the controller in. This is to get around the fact that Rack isn't based around IOs and we need to use a thread to stream data from the response bodies. Nobody should call this method except in Rails internals. Seriously!",
    "label": "",
    "id": "275"
  },
  {
    "raw_code": "def clean_up_thread_locals(locals, thread) # :nodoc:\n        locals.each { |k, _| thread[k] = nil }\n      end",
    "comment": "Ensure we clean up any thread locals we copied so that the thread can reused.",
    "label": "",
    "id": "276"
  },
  {
    "raw_code": "def log_at(level, **options)\n        around_action ->(_, action) { logger.log_at(level, &action) }, **options\n      end",
    "comment": "Set a different log level per request.  # Use the debug log level if a particular cookie is set. class ApplicationController < ActionController::Base log_at :debug, if: -> { cookies[:debug] } end ",
    "label": "",
    "id": "277"
  },
  {
    "raw_code": "def respond_to(*mimes)\n      raise ArgumentError, \"respond_to takes either types or a block, never both\" if mimes.any? && block_given?\n\n      collector = Collector.new(mimes, request.variant)\n      yield collector if block_given?\n\n      if format = collector.negotiate_format(request)\n        if media_type && media_type != format\n          raise ActionController::RespondToMismatchError\n        end",
    "comment": "Without web-service support, an action which collects the data for displaying a list of people might look something like this:  def index @people = Person.all end  That action implicitly responds to all formats, but formats can also be explicitly enumerated:  def index @people = Person.all respond_to :html, :js end  Here's the same action, with web-service support baked in:  def index @people = Person.all  respond_to do |format| format.html format.js format.xml { render xml: @people } end end  What that says is, \"if the client wants HTML or JS in response to this action, just respond as we would have before, but if the client wants XML, return them the list of people in XML format.\" (Rails determines the desired response format from the HTTP Accept header submitted by the client.)  Supposing you have an action that adds a new person, optionally creating their company (by name) if it does not already exist, without web-services, it might look like this:  def create @company = Company.find_or_create_by(name: params[:company][:name]) @person  = @company.people.create(params[:person])  redirect_to(person_list_url) end  Here's the same action, with web-service support baked in:  def create company  = params[:person].delete(:company) @company = Company.find_or_create_by(name: company[:name]) @person  = @company.people.create(params[:person])  respond_to do |format| format.html { redirect_to(person_list_url) } format.js format.xml  { render xml: @person.to_xml(include: @company) } end end  If the client wants HTML, we just redirect them back to the person list. If they want JavaScript, then it is an Ajax request and we render the JavaScript template associated with this action. Lastly, if the client wants XML, we render the created person as XML, but with a twist: we also include the person's company in the rendered XML, so you get something like this:  <person> <id>...</id> ... <company> <id>...</id> <name>...</name> ... </company> </person>  Note, however, the extra bit at the top of that action:  company  = params[:person].delete(:company) @company = Company.find_or_create_by(name: company[:name])  This is because the incoming XML document (if a web-service request is in process) can only contain a single root-node. So, we have to rearrange things so that the request looks like this (url-encoded):  person[name]=...&person[company][name]=...&...  And, like this (xml-encoded):  <person> <name>...</name> <company> <name>...</name> </company> </person>  In other words, we make the request so that it operates on a single entity's person. Then, in the action, we extract the company data from the request, find or create the company, and then create the new person with the remaining data.  Note that you can define your own XML parameter parser which would allow you to describe multiple entities in a single request (i.e., by wrapping them all in a single root node), but if you just go with the flow and accept Rails' defaults, life will be much easier.  If you need to use a MIME type which isn't supported by default, you can register your own handlers in `config/initializers/mime_types.rb` as follows.  Mime::Type.register \"image/jpeg\", :jpg  `respond_to` also allows you to specify a common block for different formats by using `any`:  def index @people = Person.all  respond_to do |format| format.html format.any(:xml, :json) { render request.format.to_sym => @people } end end  In the example above, if the format is xml, it will render:  render xml: @people  Or if the format is json:  render json: @people  `any` can also be used with no arguments, in which case it will be used for any format requested by the user:  respond_to do |format| format.html format.any { redirect_to support_path } end  Formats can have different variants.  The request variant is a specialization of the request format, like `:tablet`, `:phone`, or `:desktop`.  We often want to render different html/json/xml templates for phones, tablets, and desktop browsers. Variants make it easy.  You can set the variant in a `before_action`:  request.variant = :tablet if /iPad/.match?(request.user_agent)  Respond to variants in the action just like you respond to formats:  respond_to do |format| format.html do |variant| variant.tablet # renders app/views/projects/show.html+tablet.erb variant.phone { extra_setup; render ... } variant.none  { special_setup } # executed only if there is no variant set end end  Provide separate templates for each format and variant:  app/views/projects/show.html.erb app/views/projects/show.html+tablet.erb app/views/projects/show.html+phone.erb  When you're not sharing any code within the format, you can simplify defining variants using the inline syntax:  respond_to do |format| format.js         { render \"trash\" } format.html.phone { redirect_to progress_path } format.html.none  { render \"trash\" } end  Variants also support common `any`/`all` block that formats have.  It works for both inline:  respond_to do |format| format.html.any   { render html: \"any\"   } format.html.phone { render html: \"phone\" } end  and block syntax:  respond_to do |format| format.html do |variant| variant.any(:tablet, :phablet){ render html: \"any\" } variant.phone { render html: \"phone\" } end end  You can also set an array of variants:  request.variant = [:tablet, :phone]  This will work similarly to formats and MIME types negotiation. If there is no `:tablet` variant declared, the `:phone` variant will be used:  respond_to do |format| format.html.none format.html.phone # this gets rendered end",
    "label": "",
    "id": "278"
  },
  {
    "raw_code": "def skip_parameter_encoding(action)\n        @_parameter_encodings[action.to_s] = Hash.new { Encoding::ASCII_8BIT }\n      end",
    "comment": "Specify that a given action's parameters should all be encoded as ASCII-8BIT (it \"skips\" the encoding default of UTF-8).  For example, a controller would use it like this:  class RepositoryController < ActionController::Base skip_parameter_encoding :show  def show @repo = Repository.find_by_filesystem_path params[:file_path]  # `repo_name` is guaranteed to be UTF-8, but was ASCII-8BIT, so # tag it as such @repo_name = params[:repo_name].force_encoding 'UTF-8' end  def index @repositories = Repository.all end end  The show action in the above controller would have all parameter values encoded as ASCII-8BIT. This is useful in the case where an application must handle data but encoding of the data is unknown, like file system data.",
    "label": "",
    "id": "279"
  },
  {
    "raw_code": "def param_encoding(action, param, encoding)\n        @_parameter_encodings[action.to_s][param.to_s] = encoding\n      end",
    "comment": "Specify the encoding for a parameter on an action. If not specified the default is UTF-8.  You can specify a binary (ASCII_8BIT) parameter with:  class RepositoryController < ActionController::Base # This specifies that file_path is not UTF-8 and is instead ASCII_8BIT param_encoding :show, :file_path, Encoding::ASCII_8BIT  def show @repo = Repository.find_by_filesystem_path params[:file_path]  # params[:repo_name] remains UTF-8 encoded @repo_name = params[:repo_name] end  def index @repositories = Repository.all end end  The file_path parameter on the show action would be encoded as ASCII-8BIT, but all other arguments will remain UTF-8 encoded. This is useful in the case where an application must handle data but encoding of the data is unknown, like file system data.",
    "label": "",
    "id": "280"
  },
  {
    "raw_code": "def _default_wrap_model\n          return nil if klass.anonymous?\n          model_name = klass.name.delete_suffix(\"Controller\").classify\n\n          begin\n            if model_klass = model_name.safe_constantize\n              model_klass\n            else\n              namespaces = model_name.split(\"::\")\n              namespaces.delete_at(-2)\n              break if namespaces.last == model_name\n              model_name = namespaces.join(\"::\")\n            end",
    "comment": "Determine the wrapper model from the controller's name. By convention, this could be done by trying to find the defined model that has the same singular name as the controller. For example, `UsersController` will try to find if the `User` model exists.  This method also does namespace lookup. Foo::Bar::UsersController will try to find Foo::Bar::User, Foo::User and finally User.",
    "label": "",
    "id": "281"
  },
  {
    "raw_code": "def wrap_parameters(name_or_model_or_options, options = {})\n        model = nil\n\n        case name_or_model_or_options\n        when Hash\n          options = name_or_model_or_options\n        when false\n          options = options.merge(format: [])\n        when Symbol, String\n          options = options.merge(name: name_or_model_or_options)\n        else\n          model = name_or_model_or_options\n        end",
    "comment": "Sets the name of the wrapper key, or the model which `ParamsWrapper` would use to determine the attribute names from.  #### Examples wrap_parameters format: :xml # enables the parameter wrapper for XML format  wrap_parameters :person # wraps parameters into params[:person] hash  wrap_parameters Person # wraps parameters by determining the wrapper key from Person class # (:person, in this case) and the list of attribute names  wrap_parameters include: [:username, :title] # wraps only :username and :title attributes from parameters.  wrap_parameters false # disables parameters wrapping for this controller altogether.  #### Options *   `:format` - The list of formats in which the parameters wrapper will be enabled. *   `:include` - The list of attribute names which parameters wrapper will wrap into a nested hash. *   `:exclude` - The list of attribute names which parameters wrapper will exclude from a nested hash. ",
    "label": "",
    "id": "282"
  },
  {
    "raw_code": "def inherited(klass)\n        if klass._wrapper_options.format.any?\n          params = klass._wrapper_options.dup\n          params.klass = klass\n          klass._wrapper_options = params\n        end",
    "comment": "Sets the default wrapper key or model which will be used to determine wrapper key and attribute names. Called automatically when the module is inherited.",
    "label": "",
    "id": "283"
  },
  {
    "raw_code": "def process_action(*)\n        _perform_parameter_wrapping if _wrapper_enabled?\n        super\n      end",
    "comment": "Performs parameters wrapping upon the request. Called automatically by the metal call stack.",
    "label": "",
    "id": "284"
  },
  {
    "raw_code": "def _wrapper_key\n        _wrapper_options.name\n      end",
    "comment": "Returns the wrapper key which will be used to store wrapped parameters.",
    "label": "",
    "id": "285"
  },
  {
    "raw_code": "def _wrapper_formats\n        _wrapper_options.format\n      end",
    "comment": "Returns the list of enabled formats.",
    "label": "",
    "id": "286"
  },
  {
    "raw_code": "def _wrap_parameters(parameters)\n        { _wrapper_key => _extract_parameters(parameters) }\n      end",
    "comment": "Returns the list of parameters which will be selected for wrapped.",
    "label": "",
    "id": "287"
  },
  {
    "raw_code": "def _wrapper_enabled?\n        return false unless request.has_content_type?\n\n        ref = request.content_mime_type.ref\n\n        _wrapper_formats.include?(ref) && _wrapper_key && !request.parameters.key?(_wrapper_key)\n      rescue ActionDispatch::Http::Parameters::ParseError\n        false\n      end",
    "comment": "Checks if we should perform parameters wrapping.",
    "label": "",
    "id": "288"
  },
  {
    "raw_code": "def permissions_policy(**options, &block)\n        before_action(options) do\n          unless request.respond_to?(:permissions_policy)\n            raise \"Cannot override permissions_policy if no global permissions_policy configured.\"\n          end",
    "comment": "Overrides parts of the globally configured `Feature-Policy` header:  class PagesController < ApplicationController permissions_policy do |policy| policy.geolocation \"https://example.com\" end end  Options can be passed similar to `before_action`. For example, pass `only: :index` to override the header on the index action only:  class PagesController < ApplicationController permissions_policy(only: :index) do |policy| policy.camera :self end end  Requires a global policy defined in an initializer, which can be empty:  Rails.application.config.permissions_policy do |policy| # policy.gyroscope :none end",
    "label": "",
    "id": "289"
  },
  {
    "raw_code": "def rate_limit(to:, within:, by: -> { request.remote_ip }, with: -> { raise TooManyRequests }, store: cache_store, name: nil, scope: nil, **options)\n        before_action -> { rate_limiting(to: to, within: within, by: by, with: with, store: store, name: name, scope: scope || controller_path) }, **options\n      end",
    "comment": "Applies a rate limit to all actions or those specified by the normal `before_action` filters with `only:` and `except:`.  The maximum number of requests allowed is specified `to:` and constrained to the window of time given by `within:`.  Rate limits are by default unique to the ip address making the request, but you can provide your own identity function by passing a callable in the `by:` parameter. It's evaluated within the context of the controller processing the request.  By default, rate limits are scoped to the controller's path. If you want to share rate limits across multiple controllers, you can provide your own scope, by passing value in the `scope:` parameter.  Requests that exceed the rate limit will raise an `ActionController::TooManyRequests` error. By default, Action Dispatch will rescue from the error and refuse the request with a `429 Too Many Requests` response. You can specialize this by passing a callable in the `with:` parameter. It's evaluated within the context of the controller processing the request.  Rate limiting relies on a backing `ActiveSupport::Cache` store and defaults to `config.action_controller.cache_store`, which itself defaults to the global `config.cache_store`. If you don't want to store rate limits in the same datastore as your general caches, you can pass a custom store in the `store` parameter.  If you want to use multiple rate limits per controller, you need to give each of them an explicit name via the `name:` option.  Examples:  class SessionsController < ApplicationController rate_limit to: 10, within: 3.minutes, only: :create end  class SignupsController < ApplicationController rate_limit to: 1000, within: 10.seconds, by: -> { request.domain }, with: :redirect_to_busy, only: :new  private def redirect_to_busy redirect_to busy_controller_url, alert: \"Too many signups on domain!\" end end  class APIController < ApplicationController RATE_LIMIT_STORE = ActiveSupport::Cache::RedisCacheStore.new(url: ENV[\"REDIS_URL\"]) rate_limit to: 10, within: 3.minutes, store: RATE_LIMIT_STORE rate_limit to: 100, within: 5.minutes, scope: :api_global end  class SessionsController < ApplicationController rate_limit to: 3, within: 2.seconds, name: \"short-term\" rate_limit to: 10, within: 5.minutes, name: \"long-term\" end",
    "label": "",
    "id": "290"
  },
  {
    "raw_code": "def redirect_to(options = {}, response_options = {})\n      raise ActionControllerError.new(\"Cannot redirect to nil!\") unless options\n      raise AbstractController::DoubleRenderError if response_body\n\n      allow_other_host = response_options.delete(:allow_other_host)\n\n      proposed_status = _extract_redirect_to_status(options, response_options)\n\n      redirect_to_location = _compute_redirect_to_location(request, options)\n      _ensure_url_is_http_header_safe(redirect_to_location)\n\n      self.location      = _enforce_open_redirect_protection(redirect_to_location, allow_other_host: allow_other_host)\n      self.response_body = \"\"\n      self.status        = proposed_status\n    end",
    "comment": "Redirects the browser to the target specified in `options`. This parameter can be any one of:  *   `Hash` - The URL will be generated by calling url_for with the `options`. *   `Record` - The URL will be generated by calling url_for with the `options`, which will reference a named URL for that record. *   `String` starting with `protocol://` (like `http://`) or a protocol relative reference (like `//`) - Is passed straight through as the target for redirection. *   `String` not containing a protocol - The current protocol and host is prepended to the string. *   `Proc` - A block that will be executed in the controller's context. Should return any option accepted by `redirect_to`.   ### Examples  redirect_to action: \"show\", id: 5 redirect_to @post redirect_to \"http://www.rubyonrails.org\" redirect_to \"/images/screenshot.jpg\" redirect_to posts_url redirect_to proc { edit_post_url(@post) }  The redirection happens as a `302 Found` header unless otherwise specified using the `:status` option:  redirect_to post_url(@post), status: :found redirect_to action: 'atom', status: :moved_permanently redirect_to post_url(@post), status: 301 redirect_to action: 'atom', status: 302  The status code can either be a standard [HTTP Status code](https://www.iana.org/assignments/http-status-codes) as an integer, or a symbol representing the downcased, underscored and symbolized description. Note that the status code must be a 3xx HTTP code, or redirection will not occur.  If you are using XHR requests other than GET or POST and redirecting after the request then some browsers will follow the redirect using the original request method. This may lead to undesirable behavior such as a double DELETE. To work around this you can return a `303 See Other` status code which will be followed using a GET request.  redirect_to posts_url, status: :see_other redirect_to action: 'index', status: 303  It is also possible to assign a flash message as part of the redirection. There are two special accessors for the commonly used flash names `alert` and `notice` as well as a general purpose `flash` bucket.  redirect_to post_url(@post), alert: \"Watch it, mister!\" redirect_to post_url(@post), status: :found, notice: \"Pay attention to the road\" redirect_to post_url(@post), status: 301, flash: { updated_post_id: @post.id } redirect_to({ action: 'atom' }, alert: \"Something serious happened\")  Statements after `redirect_to` in our controller get executed, so `redirect_to` doesn't stop the execution of the function. To terminate the execution of the function immediately after the `redirect_to`, use return.  redirect_to post_url(@post) and return  ### Open Redirect protection  By default, Rails protects against redirecting to external hosts for your app's safety, so called open redirects. Note: this was a new default in Rails 7.0, after upgrading opt-in by uncommenting the line with `raise_on_open_redirects` in `config/initializers/new_framework_defaults_7_0.rb`  Here #redirect_to automatically validates the potentially-unsafe URL:  redirect_to params[:redirect_url]  The `action_on_open_redirect` configuration option controls the behavior when an unsafe redirect is detected: * `:log` - Logs a warning but allows the redirect * `:notify` - Sends an ActiveSupport notification for monitoring * `:raise` - Raises an UnsafeRedirectError  To allow any external redirects pass `allow_other_host: true`, though using a user-provided param in that case is unsafe.  redirect_to \"https://rubyonrails.org\", allow_other_host: true  See #url_from for more information on what an internal and safe URL is, or how to fall back to an alternate redirect URL in the unsafe case.  ### Path Relative URL Redirect Protection  Rails also protects against potentially unsafe path relative URL redirects that don't start with a leading slash. These can create security vulnerabilities:  redirect_to \"example.com\"     # Creates http://yourdomain.comexample.com redirect_to \"@attacker.com\"   # Creates http://yourdomain.com@attacker.com # which browsers interpret as user@host  You can configure how Rails handles these cases using:  config.action_controller.action_on_path_relative_redirect = :log    # default config.action_controller.action_on_path_relative_redirect = :notify config.action_controller.action_on_path_relative_redirect = :raise  * `:log` - Logs a warning but allows the redirect * `:notify` - Sends an ActiveSupport notification but allows the redirect (includes stack trace to help identify the source) * `:raise` - Raises an UnsafeRedirectError",
    "label": "",
    "id": "291"
  },
  {
    "raw_code": "def redirect_back(fallback_location:, allow_other_host: _allow_other_host, **args)\n      redirect_back_or_to fallback_location, allow_other_host: allow_other_host, **args\n    end",
    "comment": "Soft deprecated alias for #redirect_back_or_to where the `fallback_location` location is supplied as a keyword argument instead of the first positional argument.",
    "label": "",
    "id": "292"
  },
  {
    "raw_code": "def redirect_back_or_to(fallback_location, allow_other_host: _allow_other_host, **options)\n      if request.referer && (allow_other_host || _url_host_allowed?(request.referer))\n        redirect_to request.referer, allow_other_host: allow_other_host, **options\n      else\n        # The method level `allow_other_host` doesn't apply in the fallback case, omit\n        # and let the `redirect_to` handling take over.\n        redirect_to fallback_location, **options\n      end",
    "comment": "Redirects the browser to the page that issued the request (the referrer) if possible, otherwise redirects to the provided default fallback location.  The referrer information is pulled from the HTTP `Referer` (sic) header on the request. This is an optional header and its presence on the request is subject to browser security settings and user preferences. If the request is missing this header, the `fallback_location` will be used.  redirect_back_or_to({ action: \"show\", id: 5 }) redirect_back_or_to @post redirect_back_or_to \"http://www.rubyonrails.org\" redirect_back_or_to \"/images/screenshot.jpg\" redirect_back_or_to posts_url redirect_back_or_to proc { edit_post_url(@post) } redirect_back_or_to '/', allow_other_host: false  #### Options *   `:allow_other_host` - Allow or disallow redirection to the host that is different to the current host, defaults to true.   All other options that can be passed to #redirect_to are accepted as options, and the behavior is identical.",
    "label": "",
    "id": "293"
  },
  {
    "raw_code": "def url_from(location)\n      location = location.presence\n      location if location && _url_host_allowed?(location)\n    end",
    "comment": "Verifies the passed `location` is an internal URL that's safe to redirect to and returns it, or nil if not. Useful to wrap a params provided redirect URL and fall back to an alternate URL to redirect to:  redirect_to url_from(params[:redirect_url]) || root_url  The `location` is considered internal, and safe, if it's on the same host as `request.host`:  # If request.host is example.com: url_from(\"https://example.com/profile\") # => \"https://example.com/profile\" url_from(\"http://example.com/profile\")  # => \"http://example.com/profile\" url_from(\"http://evil.com/profile\")     # => nil  Subdomains are considered part of the host:  # If request.host is on https://example.com or https://app.example.com, you'd get: url_from(\"https://dev.example.com/profile\") # => nil  NOTE: there's a similarity with [url_for](rdoc-ref:ActionDispatch::Routing::UrlFor#url_for), which generates an internal URL from various options from within the app, e.g. `url_for(@post)`. However, #url_from is meant to take an external parameter to verify as in `url_from(params[:redirect_url])`.",
    "label": "",
    "id": "294"
  },
  {
    "raw_code": "def self.add_renderer(key, &block)\n    Renderers.add(key, &block)\n  end",
    "comment": "See Renderers.add",
    "label": "",
    "id": "295"
  },
  {
    "raw_code": "def self.remove_renderer(key)\n    Renderers.remove(key)\n  end",
    "comment": "See Renderers.remove",
    "label": "",
    "id": "296"
  },
  {
    "raw_code": "def self.add(key, &block)\n      define_method(_render_with_renderer_method_name(key), &block)\n      RENDERERS << key.to_sym\n    end",
    "comment": "Adds a new renderer to call within controller actions. A renderer is invoked by passing its name as an option to AbstractController::Rendering#render. To create a renderer pass it a name and a block. The block takes two arguments, the first is the value paired with its key and the second is the remaining hash of options passed to `render`.  Create a csv renderer:  ActionController::Renderers.add :csv do |obj, options| filename = options[:filename] || 'data' str = obj.respond_to?(:to_csv) ? obj.to_csv : obj.to_s send_data str, type: Mime[:csv], disposition: \"attachment; filename=#{filename}.csv\" end  Note that we used [Mime](:csv) for the csv mime type as it comes with Rails. For a custom renderer, you'll need to register a mime type with `Mime::Type.register`.  To use the csv renderer in a controller action:  def show @csvable = Csvable.find(params[:id]) respond_to do |format| format.html format.csv { render csv: @csvable, filename: @csvable.name } end end",
    "label": "",
    "id": "297"
  },
  {
    "raw_code": "def self.remove(key)\n      RENDERERS.delete(key.to_sym)\n      method_name = _render_with_renderer_method_name(key)\n      remove_possible_method(method_name)\n    end",
    "comment": "This method is the opposite of add method.  To remove a csv renderer:  ActionController::Renderers.remove(:csv)",
    "label": "",
    "id": "298"
  },
  {
    "raw_code": "def use_renderers(*args)\n        renderers = _renderers + args\n        self._renderers = renderers.freeze\n      end",
    "comment": "Adds, by name, a renderer or renderers to the `_renderers` available to call within controller actions.  It is useful when rendering from an ActionController::Metal controller or otherwise to add an available renderer proc to a specific controller.  Both ActionController::Base and ActionController::API include ActionController::Renderers::All, making all renderers available in the controller. See Renderers::RENDERERS and Renderers.add.  Since ActionController::Metal controllers cannot render, the controller must include AbstractController::Rendering, ActionController::Rendering, and ActionController::Renderers, and have at least one renderer.  Rather than including ActionController::Renderers::All and including all renderers, you may specify which renderers to include by passing the renderer name or names to `use_renderers`. For example, a controller that includes only the `:json` renderer (`_render_with_renderer_json`) might look like:  class MetalRenderingController < ActionController::Metal include AbstractController::Rendering include ActionController::Rendering include ActionController::Renderers  use_renderers :json  def show render json: record end end  You must specify a `use_renderer`, else the `controller.renderer` and `controller._renderers` will be `nil`, and the action will fail.",
    "label": "",
    "id": "299"
  },
  {
    "raw_code": "def render_to_body(options)\n      _render_to_body_with_renderer(options) || super\n    end",
    "comment": "Called by `render` in AbstractController::Rendering which sets the return value as the `response_body`.  If no renderer is found, `super` returns control to `ActionView::Rendering.render_to_body`, if present.",
    "label": "",
    "id": "300"
  },
  {
    "raw_code": "def render(*args)\n      raise ::AbstractController::DoubleRenderError if response_body\n      super\n    end",
    "comment": "Renders a template and assigns the result to `self.response_body`.  If no rendering mode option is specified, the template will be derived from the first argument.  render \"posts/show\" # => renders app/views/posts/show.html.erb  # In a PostsController action... render :show # => renders app/views/posts/show.html.erb  If the first argument responds to `render_in`, the template will be rendered by calling `render_in` with the current view context.  class Greeting def render_in(view_context) view_context.render html: \"<h1>Hello, World</h1>\" end  def format :html end end  render(Greeting.new) # => \"<h1>Hello, World</h1>\"  render(renderable: Greeting.new) # => \"<h1>Hello, World</h1>\"  #### Rendering Mode  `:partial` :   See ActionView::PartialRenderer for details.  render partial: \"posts/form\", locals: { post: Post.new } # => renders app/views/posts/_form.html.erb  `:file` :   Renders the contents of a file. This option should **not** be used with unsanitized user input.  render file: \"/path/to/some/file\" # => renders /path/to/some/file  `:inline` :   Renders an ERB template string.  @name = \"World\" render inline: \"<h1>Hello, <%= @name %>!</h1>\" # => renders \"<h1>Hello, World!</h1>\"  `:body` :   Renders the provided text, and sets the content type as `text/plain`.  render body: \"Hello, World!\" # => renders \"Hello, World!\"  `:plain` :   Renders the provided text, and sets the content type as `text/plain`.  render plain: \"Hello, World!\" # => renders \"Hello, World!\"  `:html` :   Renders the provided HTML string, and sets the content type as `text/html`. If the string is not `html_safe?`, performs HTML escaping on the string before rendering.  render html: \"<h1>Hello, World!</h1>\".html_safe # => renders \"<h1>Hello, World!</h1>\"  render html: \"<h1>Hello, World!</h1>\" # => renders \"&lt;h1&gt;Hello, World!&lt;/h1&gt;\"  `:json` :   Renders the provided object as JSON, and sets the content type as `application/json`. If the object is not a string, it will be converted to JSON by calling `to_json`.  render json: { hello: \"world\" } # => renders \"{\\\"hello\\\":\\\"world\\\"}\"  `:renderable` :   Renders the provided object by calling `render_in` with the current view context. The response format is determined by calling `format` on the renderable if it responds to `format`, falling back to `text/html` by default.  render renderable: Greeting.new # => renders \"<h1>Hello, World</h1>\"   By default, when a rendering mode is specified, no layout template is rendered.  #### Options  `:assigns` :   Hash of instance variable assignments for the template.  render inline: \"<h1>Hello, <%= @name %>!</h1>\", assigns: { name: \"World\" } # => renders \"<h1>Hello, World!</h1>\"  `:locals` :   Hash of local variable assignments for the template.  render inline: \"<h1>Hello, <%= name %>!</h1>\", locals: { name: \"World\" } # => renders \"<h1>Hello, World!</h1>\"  `:layout` :   The layout template to render. Can also be `false` or `true` to disable or (re)enable the default layout template.  render \"posts/show\", layout: \"holiday\" # => renders app/views/posts/show.html.erb with the app/views/layouts/holiday.html.erb layout  render \"posts/show\", layout: false # => renders app/views/posts/show.html.erb with no layout  render inline: \"<h1>Hello, World!</h1>\", layout: true # => renders \"<h1>Hello, World!</h1>\" with the default layout  `:status` :   The HTTP status code to send with the response. Can be specified as a number or as the status name in Symbol form. Defaults to 200.  render \"posts/new\", status: 422 # => renders app/views/posts/new.html.erb with HTTP status code 422  render \"posts/new\", status: :unprocessable_entity # => renders app/views/posts/new.html.erb with HTTP status code 422  `:variants` :  This tells Rails to look for the first template matching any of the variations.  render \"posts/index\", variants: [:mobile] # => renders app/views/posts/index.html+mobile.erb  -- Check for double render errors and set the content_type after rendering.",
    "label": "",
    "id": "301"
  },
  {
    "raw_code": "def render_to_string(*)\n      result = super\n      if result.respond_to?(:each)\n        string = +\"\"\n        result.each { |r| string << r }\n        string\n      else\n        result\n      end",
    "comment": "Similar to #render, but only returns the rendered template as a string, instead of setting `self.response_body`. -- Override render_to_string because body can now be set to a Rack body.",
    "label": "",
    "id": "302"
  },
  {
    "raw_code": "def process_action(*) # :nodoc:\n        self.formats = request.formats.filter_map(&:ref)\n        super\n      end",
    "comment": "Before processing, set the request formats in current controller formats.",
    "label": "",
    "id": "303"
  },
  {
    "raw_code": "def _normalize_options(options)\n        _normalize_text(options)\n\n        if options[:html]\n          options[:html] = ERB::Util.html_escape(options[:html])\n        end",
    "comment": "Normalize both text and status options.",
    "label": "",
    "id": "304"
  },
  {
    "raw_code": "def _process_options(options)\n        status, content_type, location = options.values_at(:status, :content_type, :location)\n\n        self.status = status if status\n        self.content_type = content_type if content_type\n        headers[\"Location\"] = url_for(location) if location\n\n        super\n      end",
    "comment": "Process controller specific options, as status, content-type and location.",
    "label": "",
    "id": "305"
  },
  {
    "raw_code": "def protect_from_forgery(options = {})\n        options = options.reverse_merge(prepend: false)\n\n        self.forgery_protection_strategy = protection_method_class(options[:with] || :null_session)\n        self.request_forgery_protection_token ||= :authenticity_token\n\n        self.csrf_token_storage_strategy = storage_strategy(options[:store] || SessionStore.new)\n\n        before_action :verify_authenticity_token, options\n        append_after_action :verify_same_origin_request\n      end",
    "comment": "Turn on request forgery protection. Bear in mind that GET and HEAD requests are not checked.  class ApplicationController < ActionController::Base protect_from_forgery end  class FooController < ApplicationController protect_from_forgery except: :index end  You can disable forgery protection on a controller using skip_forgery_protection:  class BarController < ApplicationController skip_forgery_protection end  Valid Options:  *   `:only` / `:except` - Only apply forgery protection to a subset of actions. For example `only: [ :create, :create_all ]`. *   `:if` / `:unless` - Turn off the forgery protection entirely depending on the passed Proc or method reference. *   `:prepend` - By default, the verification of the authentication token will be added at the position of the protect_from_forgery call in your application. This means any callbacks added before are run first. This is useful when you want your forgery protection to depend on other callbacks, like authentication methods (Oauth vs Cookie auth).  If you need to add verification to the beginning of the callback chain, use `prepend: true`. *   `:with` - Set the method to handle unverified request. Note if `default_protect_from_forgery` is true, Rails call protect_from_forgery with `with :exception`.   Built-in unverified request handling methods are:  *   `:exception` - Raises ActionController::InvalidAuthenticityToken exception. *   `:reset_session` - Resets the session. *   `:null_session` - Provides an empty session during request but doesn't reset it completely. Used as default if `:with` option is not specified.   You can also implement custom strategy classes for unverified request handling:  class CustomStrategy def initialize(controller) @controller = controller end  def handle_unverified_request # Custom behavior for unverfied request end end  class ApplicationController < ActionController::Base protect_from_forgery with: CustomStrategy end  *   `:store` - Set the strategy to store and retrieve CSRF tokens.   Built-in session token strategies are:  *   `:session` - Store the CSRF token in the session.  Used as default if `:store` option is not specified. *   `:cookie` - Store the CSRF token in an encrypted cookie.   You can also implement custom strategy classes for CSRF token storage:  class CustomStore def fetch(request) # Return the token from a custom location end  def store(request, csrf_token) # Store the token in a custom location end  def reset(request) # Delete the stored session token end end  class ApplicationController < ActionController::Base protect_from_forgery store: CustomStore.new end",
    "label": "",
    "id": "306"
  },
  {
    "raw_code": "def skip_forgery_protection(options = {})\n        skip_before_action :verify_authenticity_token, options.reverse_merge(raise: false)\n      end",
    "comment": "Turn off request forgery protection. This is a wrapper for:  skip_before_action :verify_authenticity_token  See `skip_before_action` for allowed options.",
    "label": "",
    "id": "307"
  },
  {
    "raw_code": "def handle_unverified_request\n          request = @controller.request\n          request.session = NullSessionHash.new(request)\n          request.flash = nil\n          request.session_options = { skip: true }\n          request.cookie_jar = NullCookieJar.build(request, {})\n        end",
    "comment": "This is the method that defines the application behavior when a request is found to be unverified.",
    "label": "",
    "id": "308"
  },
  {
    "raw_code": "def destroy; end\n\n            def exists?\n              true\n            end\n\n            def enabled?\n              false\n            end\n          end",
    "comment": "no-op",
    "label": "",
    "id": "309"
  },
  {
    "raw_code": "def verify_authenticity_token # :doc:\n        mark_for_same_origin_verification!\n\n        if !verified_request?\n          logger.warn unverified_request_warning_message if logger && log_warning_on_csrf_failure\n\n          handle_unverified_request\n        end",
    "comment": "The actual before_action that is used to verify the CSRF token. Don't override this directly. Provide your own forgery protection strategy instead. If you override, you'll disable same-origin `<script>` verification.  Lean on the protect_from_forgery declaration to mark which actions are due for same-origin request verification. If protect_from_forgery is enabled on an action, this before_action flags its after_action to verify that JavaScript responses are for XHR requests, ensuring they follow the browser's same-origin policy.",
    "label": "",
    "id": "310"
  },
  {
    "raw_code": "def verify_same_origin_request # :doc:\n        if marked_for_same_origin_verification? && non_xhr_javascript_response?\n          if logger && log_warning_on_csrf_failure\n            logger.warn CROSS_ORIGIN_JAVASCRIPT_WARNING\n          end",
    "comment": ":startdoc: If `verify_authenticity_token` was run (indicating that we have forgery protection enabled for this request) then also verify that we aren't serving an unauthorized cross-origin response.",
    "label": "",
    "id": "311"
  },
  {
    "raw_code": "def mark_for_same_origin_verification! # :doc:\n        @_marked_for_same_origin_verification = request.get?\n      end",
    "comment": "GET requests are checked for cross-origin JavaScript after rendering.",
    "label": "",
    "id": "312"
  },
  {
    "raw_code": "def marked_for_same_origin_verification? # :doc:\n        @_marked_for_same_origin_verification ||= false\n      end",
    "comment": "If the `verify_authenticity_token` before_action ran, verify that JavaScript responses are only served to same-origin GET requests.",
    "label": "",
    "id": "313"
  },
  {
    "raw_code": "def non_xhr_javascript_response? # :doc:\n        %r(\\A(?:text|application)/javascript).match?(media_type) && !request.xhr?\n      end",
    "comment": "Check for cross-origin JavaScript responses.",
    "label": "",
    "id": "314"
  },
  {
    "raw_code": "def verified_request? # :doc:\n        request.get? || request.head? || !protect_against_forgery? ||\n          (valid_request_origin? && any_authenticity_token_valid?)\n      end",
    "comment": "Returns true or false if a request is verified. Checks:  *   Is it a GET or HEAD request? GETs should be safe and idempotent *   Does the form_authenticity_token match the given token value from the params? *   Does the `X-CSRF-Token` header match the form_authenticity_token? ",
    "label": "",
    "id": "315"
  },
  {
    "raw_code": "def any_authenticity_token_valid? # :doc:\n        request_authenticity_tokens.any? do |token|\n          valid_authenticity_token?(session, token)\n        end",
    "comment": "Checks if any of the authenticity tokens from the request are valid.",
    "label": "",
    "id": "316"
  },
  {
    "raw_code": "def request_authenticity_tokens # :doc:\n        [form_authenticity_param, request.x_csrf_token]\n      end",
    "comment": "Possible authenticity tokens sent in the request.",
    "label": "",
    "id": "317"
  },
  {
    "raw_code": "def form_authenticity_token(form_options: {}) # :doc:\n        masked_authenticity_token(form_options: form_options)\n      end",
    "comment": "Creates the authenticity token for the current request.",
    "label": "",
    "id": "318"
  },
  {
    "raw_code": "def masked_authenticity_token(form_options: {})\n        action, method = form_options.values_at(:action, :method)\n\n        raw_token = if per_form_csrf_tokens && action && method\n          action_path = normalize_action_path(action)\n          per_form_csrf_token(nil, action_path, method)\n        else\n          global_csrf_token\n        end",
    "comment": "Creates a masked version of the authenticity token that varies on each request. The masking is used to mitigate SSL attacks like BREACH.",
    "label": "",
    "id": "319"
  },
  {
    "raw_code": "def valid_authenticity_token?(session, encoded_masked_token) # :doc:\n        if !encoded_masked_token.is_a?(String) || encoded_masked_token.empty?\n          return false\n        end",
    "comment": "Checks the client's masked token to see if it matches the session token. Essentially the inverse of `masked_authenticity_token`.",
    "label": "",
    "id": "320"
  },
  {
    "raw_code": "def form_authenticity_param # :doc:\n        params[request_forgery_protection_token]\n      end",
    "comment": "The form's authenticity parameter. Override to provide your own.",
    "label": "",
    "id": "321"
  },
  {
    "raw_code": "def protect_against_forgery? # :doc:\n        allow_forgery_protection && (!session.respond_to?(:enabled?) || session.enabled?)\n      end",
    "comment": "Checks if the controller allows forgery protection.",
    "label": "",
    "id": "322"
  },
  {
    "raw_code": "def valid_request_origin? # :doc:\n        if forgery_protection_origin_check\n          # We accept blank origin headers because some user agents don't send it.\n          raise InvalidAuthenticityToken, NULL_ORIGIN_MESSAGE if request.origin == \"null\"\n          request.origin.nil? || request.origin == request.base_url\n        else\n          true\n        end",
    "comment": "Checks if the request originated from the same origin by looking at the Origin header.",
    "label": "",
    "id": "323"
  },
  {
    "raw_code": "def show_detailed_exceptions?\n      false\n    end",
    "comment": "Override this method if you want to customize when detailed exceptions must be shown. This method is only called when `consider_all_requests_local` is `false`. By default, it returns `false`, but someone may set it to `request.local?` so local requests in production still show the detailed exception pages.",
    "label": "",
    "id": "324"
  },
  {
    "raw_code": "def _render_template(options)\n        if options.delete(:stream)\n          # It shouldn't be necessary to set this.\n          headers[\"cache-control\"] ||= \"no-cache\"\n\n          view_renderer.render_body(view_context, options)\n        else\n          super\n        end",
    "comment": "Call render_body if we are streaming instead of usual `render`.",
    "label": "",
    "id": "325"
  },
  {
    "raw_code": "def initialize(parameters = {}, logging_context = {})\n      parameters.each_key do |key|\n        unless key.is_a?(String) || key.is_a?(Symbol)\n          raise InvalidParameterKey, \"all keys must be Strings or Symbols, got: #{key.class}\"\n        end",
    "comment": "Returns a new `ActionController::Parameters` instance. Also, sets the `permitted` attribute to the default value of `ActionController::Parameters.permit_all_parameters`.  class Person < ActiveRecord::Base end  params = ActionController::Parameters.new(name: \"Francesco\") params.permitted?  # => false Person.new(params) # => ActiveModel::ForbiddenAttributesError  ActionController::Parameters.permit_all_parameters = true  params = ActionController::Parameters.new(name: \"Francesco\") params.permitted?  # => true Person.new(params) # => #<Person id: nil, name: \"Francesco\">",
    "label": "",
    "id": "326"
  },
  {
    "raw_code": "def ==(other)\n      if other.respond_to?(:permitted?)\n        permitted? == other.permitted? && parameters == other.parameters\n      else\n        super\n      end",
    "comment": "Returns true if another `Parameters` object contains the same content and permitted flag.",
    "label": "",
    "id": "327"
  },
  {
    "raw_code": "def to_h(&block)\n      if permitted?\n        convert_parameters_to_hashes(@parameters, :to_h, &block)\n      else\n        raise UnfilteredParameters\n      end",
    "comment": "Returns a safe ActiveSupport::HashWithIndifferentAccess representation of the parameters with all unpermitted keys removed.  params = ActionController::Parameters.new({ name: \"Senjougahara Hitagi\", oddity: \"Heavy stone crab\" }) params.to_h # => ActionController::UnfilteredParameters: unable to convert unpermitted parameters to hash  safe_params = params.permit(:name) safe_params.to_h # => {\"name\"=>\"Senjougahara Hitagi\"}",
    "label": "",
    "id": "328"
  },
  {
    "raw_code": "def to_hash\n      to_h.to_hash\n    end",
    "comment": "Returns a safe `Hash` representation of the parameters with all unpermitted keys removed.  params = ActionController::Parameters.new({ name: \"Senjougahara Hitagi\", oddity: \"Heavy stone crab\" }) params.to_hash # => ActionController::UnfilteredParameters: unable to convert unpermitted parameters to hash  safe_params = params.permit(:name) safe_params.to_hash # => {\"name\"=>\"Senjougahara Hitagi\"}",
    "label": "",
    "id": "329"
  },
  {
    "raw_code": "def to_query(*args)\n      to_h.to_query(*args)\n    end",
    "comment": "Returns a string representation of the receiver suitable for use as a URL query string:  params = ActionController::Parameters.new({ name: \"David\", nationality: \"Danish\" }) params.to_query # => ActionController::UnfilteredParameters: unable to convert unpermitted parameters to hash  safe_params = params.permit(:name, :nationality) safe_params.to_query # => \"name=David&nationality=Danish\"  An optional namespace can be passed to enclose key names:  params = ActionController::Parameters.new({ name: \"David\", nationality: \"Danish\" }) safe_params = params.permit(:name, :nationality) safe_params.to_query(\"user\") # => \"user%5Bname%5D=David&user%5Bnationality%5D=Danish\"  The string pairs `\"key=value\"` that conform the query string are sorted lexicographically in ascending order.",
    "label": "",
    "id": "330"
  },
  {
    "raw_code": "def to_unsafe_h\n      convert_parameters_to_hashes(@parameters, :to_unsafe_h)\n    end",
    "comment": "Returns an unsafe, unfiltered ActiveSupport::HashWithIndifferentAccess representation of the parameters.  params = ActionController::Parameters.new({ name: \"Senjougahara Hitagi\", oddity: \"Heavy stone crab\" }) params.to_unsafe_h # => {\"name\"=>\"Senjougahara Hitagi\", \"oddity\" => \"Heavy stone crab\"}",
    "label": "",
    "id": "331"
  },
  {
    "raw_code": "def each_pair(&block)\n      return to_enum(__callee__) unless block_given?\n      @parameters.each_pair do |key, value|\n        yield [key, convert_hashes_to_parameters(key, value)]\n      end",
    "comment": "Convert all hashes in values into parameters, then yield each pair in the same way as `Hash#each_pair`.",
    "label": "",
    "id": "332"
  },
  {
    "raw_code": "def each_value(&block)\n      return to_enum(:each_value) unless block_given?\n      @parameters.each_pair do |key, value|\n        yield convert_hashes_to_parameters(key, value)\n      end",
    "comment": "Convert all hashes in values into parameters, then yield each value in the same way as `Hash#each_value`.",
    "label": "",
    "id": "333"
  },
  {
    "raw_code": "def values\n      to_enum(:each_value).to_a\n    end",
    "comment": "Returns a new array of the values of the parameters.",
    "label": "",
    "id": "334"
  },
  {
    "raw_code": "def converted_arrays\n      @converted_arrays ||= Set.new\n    end",
    "comment": "Attribute that keeps track of converted arrays, if any, to avoid double looping in the common use case permit + mass-assignment. Defined in a method to instantiate it only if needed.  Testing membership still loops, but it's going to be faster than our own loop that converts values. Also, we are not going to build a new array object per fetch.",
    "label": "",
    "id": "335"
  },
  {
    "raw_code": "def permitted?\n      @permitted\n    end",
    "comment": "Returns `true` if the parameter is permitted, `false` otherwise.  params = ActionController::Parameters.new params.permitted? # => false params.permit! params.permitted? # => true",
    "label": "",
    "id": "336"
  },
  {
    "raw_code": "def permit!\n      each_pair do |key, value|\n        Array.wrap(value).flatten.each do |v|\n          v.permit! if v.respond_to? :permit!\n        end",
    "comment": "Sets the `permitted` attribute to `true`. This can be used to pass mass assignment. Returns `self`.  class Person < ActiveRecord::Base end  params = ActionController::Parameters.new(name: \"Francesco\") params.permitted?  # => false Person.new(params) # => ActiveModel::ForbiddenAttributesError params.permit! params.permitted?  # => true Person.new(params) # => #<Person id: nil, name: \"Francesco\">",
    "label": "",
    "id": "337"
  },
  {
    "raw_code": "def require(key)\n      return key.map { |k| require(k) } if key.is_a?(Array)\n      value = self[key]\n      if value.present? || value == false\n        value\n      else\n        raise ParameterMissing.new(key, @parameters.keys)\n      end",
    "comment": "This method accepts both a single key and an array of keys.  When passed a single key, if it exists and its associated value is either present or the singleton `false`, returns said value:  ActionController::Parameters.new(person: { name: \"Francesco\" }).require(:person) # => #<ActionController::Parameters {\"name\"=>\"Francesco\"} permitted: false>  Otherwise raises ActionController::ParameterMissing:  ActionController::Parameters.new.require(:person) # ActionController::ParameterMissing: param is missing or the value is empty or invalid: person  ActionController::Parameters.new(person: nil).require(:person) # ActionController::ParameterMissing: param is missing or the value is empty or invalid: person  ActionController::Parameters.new(person: \"\\t\").require(:person) # ActionController::ParameterMissing: param is missing or the value is empty or invalid: person  ActionController::Parameters.new(person: {}).require(:person) # ActionController::ParameterMissing: param is missing or the value is empty or invalid: person  When given an array of keys, the method tries to require each one of them in order. If it succeeds, an array with the respective return values is returned:  params = ActionController::Parameters.new(user: { ... }, profile: { ... }) user_params, profile_params = params.require([:user, :profile])  Otherwise, the method re-raises the first exception found:  params = ActionController::Parameters.new(user: {}, profile: {}) user_params, profile_params = params.require([:user, :profile]) # ActionController::ParameterMissing: param is missing or the value is empty or invalid: user  This method is not recommended for fetching terminal values because it does not permit the values. For example, this can cause problems:  # CAREFUL params = ActionController::Parameters.new(person: { name: \"Finn\" }) name = params.require(:person).require(:name) # CAREFUL  It is recommended to use `expect` instead:  def person_params params.expect(person: :name).require(:name) end ",
    "label": "",
    "id": "338"
  },
  {
    "raw_code": "def permit(*filters)\n      permit_filters(filters, on_unpermitted: self.class.action_on_unpermitted_parameters, explicit_arrays: false)\n    end",
    "comment": "Returns a new `ActionController::Parameters` instance that includes only the given `filters` and sets the `permitted` attribute for the object to `true`. This is useful for limiting which attributes should be allowed for mass updating.  params = ActionController::Parameters.new(name: \"Francesco\", age: 22, role: \"admin\") permitted = params.permit(:name, :age) permitted.permitted?      # => true permitted.has_key?(:name) # => true permitted.has_key?(:age)  # => true permitted.has_key?(:role) # => false  Only permitted scalars pass the filter. For example, given  params.permit(:name)  `:name` passes if it is a key of `params` whose associated value is of type `String`, `Symbol`, `NilClass`, `Numeric`, `TrueClass`, `FalseClass`, `Date`, `Time`, `DateTime`, `StringIO`, `IO`, ActionDispatch::Http::UploadedFile or `Rack::Test::UploadedFile`. Otherwise, the key `:name` is filtered out.  You may declare that the parameter should be an array of permitted scalars by mapping it to an empty array:  params = ActionController::Parameters.new(tags: [\"rails\", \"parameters\"]) params.permit(tags: [])  Sometimes it is not possible or convenient to declare the valid keys of a hash parameter or its internal structure. Just map to an empty hash:  params.permit(preferences: {})  Be careful because this opens the door to arbitrary input. In this case, `permit` ensures values in the returned structure are permitted scalars and filters out anything else.  You can also use `permit` on nested parameters:  params = ActionController::Parameters.new({ person: { name: \"Francesco\", age:  22, pets: [{ name: \"Purplish\", category: \"dogs\" }] } })  permitted = params.permit(person: [ :name, { pets: :name } ]) permitted.permitted?                    # => true permitted[:person][:name]               # => \"Francesco\" permitted[:person][:age]                # => nil permitted[:person][:pets][0][:name]     # => \"Purplish\" permitted[:person][:pets][0][:category] # => nil  This has the added benefit of rejecting user-modified inputs that send a string when a hash is expected.  When followed by `require`, you can both filter and require parameters following the typical pattern of a Rails form. The `expect` method was made specifically for this use case and is the recommended way to require and permit parameters.  permitted = params.expect(person: [:name, :age])  When using `permit` and `require` separately, pay careful attention to the order of the method calls.  params = ActionController::Parameters.new(person: { name: \"Martin\", age: 40, role: \"admin\" }) permitted = params.permit(person: [:name, :age]).require(:person) # correct  When require is used first, it is possible for users of your application to trigger a NoMethodError when the user, for example, sends a string for :person.  params = ActionController::Parameters.new(person: \"tampered\") permitted = params.require(:person).permit(:name, :age) # not recommended # => NoMethodError: undefined method `permit' for an instance of String  Note that if you use `permit` in a key that points to a hash, it won't allow all the hash. You also need to specify which attributes inside the hash should be permitted.  params = ActionController::Parameters.new({ person: { contact: { email: \"none@test.com\", phone: \"555-1234\" } } })  params.permit(person: :contact).require(:person) # => ActionController::ParameterMissing: param is missing or the value is empty or invalid: person  params.permit(person: { contact: :phone }).require(:person) # => #<ActionController::Parameters {\"contact\"=>#<ActionController::Parameters {\"phone\"=>\"555-1234\"} permitted: true>} permitted: true>  params.permit(person: { contact: [ :email, :phone ] }).require(:person) # => #<ActionController::Parameters {\"contact\"=>#<ActionController::Parameters {\"email\"=>\"none@test.com\", \"phone\"=>\"555-1234\"} permitted: true>} permitted: true>  If your parameters specify multiple parameters indexed by a number, you can permit each set of parameters under the numeric key to be the same using the same syntax as permitting a single item.  params = ActionController::Parameters.new({ person: { '0': { email: \"none@test.com\", phone: \"555-1234\" }, '1': { email: \"nothing@test.com\", phone: \"555-6789\" }, } }) params.permit(person: [:email]).to_h # => {\"person\"=>{\"0\"=>{\"email\"=>\"none@test.com\"}, \"1\"=>{\"email\"=>\"nothing@test.com\"}}}  If you want to specify what keys you want from each numeric key, you can instead specify each one individually  params = ActionController::Parameters.new({ person: { '0': { email: \"none@test.com\", phone: \"555-1234\" }, '1': { email: \"nothing@test.com\", phone: \"555-6789\" }, } }) params.permit(person: { '0': [:email], '1': [:phone]}).to_h # => {\"person\"=>{\"0\"=>{\"email\"=>\"none@test.com\"}, \"1\"=>{\"phone\"=>\"555-6789\"}}}",
    "label": "",
    "id": "339"
  },
  {
    "raw_code": "def expect(*filters)\n      params = permit_filters(filters)\n      keys = filters.flatten.flat_map { |f| f.is_a?(Hash) ? f.keys : f }\n      values = params.require(keys)\n      values.size == 1 ? values.first : values\n    end",
    "comment": "`expect` is the preferred way to require and permit parameters. It is safer than the previous recommendation to call `permit` and `require` in sequence, which could allow user triggered 500 errors.  `expect` is more strict with types to avoid a number of potential pitfalls that may be encountered with the `.require.permit` pattern.  For example:  params = ActionController::Parameters.new(comment: { text: \"hello\" }) params.expect(comment: [:text]) # => #<ActionController::Parameters { text: \"hello\" } permitted: true>  params = ActionController::Parameters.new(comment: [{ text: \"hello\" }, { text: \"world\" }]) params.expect(comment: [:text]) # => ActionController::ParameterMissing: param is missing or the value is empty or invalid: comment  In order to permit an array of parameters, the array must be defined explicitly. Use double array brackets, an array inside an array, to declare that an array of parameters is expected.  params = ActionController::Parameters.new(comments: [{ text: \"hello\" }, { text: \"world\" }]) params.expect(comments: [[:text]]) # => [#<ActionController::Parameters { \"text\" => \"hello\" } permitted: true>, #     #<ActionController::Parameters { \"text\" => \"world\" } permitted: true>]  params = ActionController::Parameters.new(comments: { text: \"hello\" }) params.expect(comments: [[:text]]) # => ActionController::ParameterMissing: param is missing or the value is empty or invalid: comments  `expect` is intended to protect against array tampering.  params = ActionController::Parameters.new(user: \"hack\") # The previous way of requiring and permitting parameters will error params.require(:user).permit(:name, pets: [:name]) # wrong # => NoMethodError: undefined method `permit' for an instance of String  # similarly with nested parameters params = ActionController::Parameters.new(user: { name: \"Martin\", pets: { name: \"hack\" } }) user_params = params.require(:user).permit(:name, pets: [:name]) # wrong # user_params[:pets] is expected to be an array but is a hash  `expect` solves this by being more strict with types.  params = ActionController::Parameters.new(user: \"hack\") params.expect(user: [ :name, pets: [[:name]] ]) # => ActionController::ParameterMissing: param is missing or the value is empty or invalid: user  # with nested parameters params = ActionController::Parameters.new(user: { name: \"Martin\", pets: { name: \"hack\" } }) user_params = params.expect(user: [:name, pets: [[:name]] ]) user_params[:pets] # => nil  As the examples show, `expect` requires the `:user` key, and any root keys similar to the `.require.permit` pattern. If multiple root keys are expected, they will all be required.  params = ActionController::Parameters.new(name: \"Martin\", pies: [{ type: \"dessert\", flavor: \"pumpkin\"}]) name, pies = params.expect(:name, pies: [[:type, :flavor]]) name # => \"Martin\" pies # => [#<ActionController::Parameters {\"type\"=>\"dessert\", \"flavor\"=>\"pumpkin\"} permitted: true>]  When called with a hash with multiple keys, `expect` will permit the parameters and require the keys in the order they are given in the hash, returning an array of the permitted parameters.  params = ActionController::Parameters.new(subject: { name: \"Martin\" }, object: { pie: \"pumpkin\" }) subject, object = params.expect(subject: [:name], object: [:pie]) subject # => #<ActionController::Parameters {\"name\"=>\"Martin\"} permitted: true> object  # => #<ActionController::Parameters {\"pie\"=>\"pumpkin\"} permitted: true>  Besides being more strict about array vs hash params, `expect` uses permit internally, so it will behave similarly.  params = ActionController::Parameters.new({ person: { name: \"Francesco\", age:  22, pets: [{ name: \"Purplish\", category: \"dogs\" }] } })  permitted = params.expect(person: [ :name, { pets: [[:name]] } ]) permitted.permitted?           # => true permitted[:name]               # => \"Francesco\" permitted[:age]                # => nil permitted[:pets][0][:name]     # => \"Purplish\" permitted[:pets][0][:category] # => nil  An array of permitted scalars may be expected with the following:  params = ActionController::Parameters.new(tags: [\"rails\", \"parameters\"]) permitted = params.expect(tags: []) permitted                 # => [\"rails\", \"parameters\"] permitted.is_a?(Array)    # => true permitted.size            # => 2 ",
    "label": "",
    "id": "340"
  },
  {
    "raw_code": "def expect!(*filters)\n      expect(*filters)\n    rescue ParameterMissing => e\n      raise ExpectedParameterMissing.new(e.param, e.keys)\n    end",
    "comment": "Same as `expect`, but raises an `ActionController::ExpectedParameterMissing` instead of `ActionController::ParameterMissing`. Unlike `expect` which will render a 400 response, `expect!` will raise an exception that is not handled. This is intended for debugging invalid params for an internal API where incorrectly formatted params would indicate a bug in a client library that should be fixed. ",
    "label": "",
    "id": "341"
  },
  {
    "raw_code": "def [](key)\n      convert_hashes_to_parameters(key, @parameters[key])\n    end",
    "comment": "Returns a parameter for the given `key`. If not found, returns `nil`.  params = ActionController::Parameters.new(person: { name: \"Francesco\" }) params[:person] # => #<ActionController::Parameters {\"name\"=>\"Francesco\"} permitted: false> params[:none]   # => nil",
    "label": "",
    "id": "342"
  },
  {
    "raw_code": "def []=(key, value)\n      @parameters[key] = value\n    end",
    "comment": "Assigns a value to a given `key`. The given key may still get filtered out when #permit is called.",
    "label": "",
    "id": "343"
  },
  {
    "raw_code": "def fetch(key, *args)\n      convert_value_to_parameters(\n        @parameters.fetch(key) {\n          if block_given?\n            yield\n          else\n            args.fetch(0) { raise ActionController::ParameterMissing.new(key, @parameters.keys) }\n          end",
    "comment": "Returns a parameter for the given `key`. If the `key` can't be found, there are several options: With no other arguments, it will raise an ActionController::ParameterMissing error; if a second argument is given, then that is returned (converted to an instance of `ActionController::Parameters` if possible); if a block is given, then that will be run and its result returned.  params = ActionController::Parameters.new(person: { name: \"Francesco\" }) params.fetch(:person)               # => #<ActionController::Parameters {\"name\"=>\"Francesco\"} permitted: false> params.fetch(:none)                 # => ActionController::ParameterMissing: param is missing or the value is empty or invalid: none params.fetch(:none, {})             # => #<ActionController::Parameters {} permitted: false> params.fetch(:none, \"Francesco\")    # => \"Francesco\" params.fetch(:none) { \"Francesco\" } # => \"Francesco\"",
    "label": "",
    "id": "344"
  },
  {
    "raw_code": "def dig(*keys)\n      convert_hashes_to_parameters(keys.first, @parameters[keys.first])\n      @parameters.dig(*keys)\n    end",
    "comment": "Extracts the nested parameter from the given `keys` by calling `dig` at each step. Returns `nil` if any intermediate step is `nil`.  params = ActionController::Parameters.new(foo: { bar: { baz: 1 } }) params.dig(:foo, :bar, :baz) # => 1 params.dig(:foo, :zot, :xyz) # => nil  params2 = ActionController::Parameters.new(foo: [10, 11, 12]) params2.dig(:foo, 1) # => 11",
    "label": "",
    "id": "345"
  },
  {
    "raw_code": "def slice(*keys)\n      new_instance_with_inherited_permitted_status(@parameters.slice(*keys))\n    end",
    "comment": "Returns a new `ActionController::Parameters` instance that includes only the given `keys`. If the given `keys` don't exist, returns an empty hash.  params = ActionController::Parameters.new(a: 1, b: 2, c: 3) params.slice(:a, :b) # => #<ActionController::Parameters {\"a\"=>1, \"b\"=>2} permitted: false> params.slice(:d)     # => #<ActionController::Parameters {} permitted: false>",
    "label": "",
    "id": "346"
  },
  {
    "raw_code": "def slice!(*keys)\n      @parameters.slice!(*keys)\n      self\n    end",
    "comment": "Returns the current `ActionController::Parameters` instance which contains only the given `keys`.",
    "label": "",
    "id": "347"
  },
  {
    "raw_code": "def except(*keys)\n      new_instance_with_inherited_permitted_status(@parameters.except(*keys))\n    end",
    "comment": "Returns a new `ActionController::Parameters` instance that filters out the given `keys`.  params = ActionController::Parameters.new(a: 1, b: 2, c: 3) params.except(:a, :b) # => #<ActionController::Parameters {\"c\"=>3} permitted: false> params.except(:d)     # => #<ActionController::Parameters {\"a\"=>1, \"b\"=>2, \"c\"=>3} permitted: false>",
    "label": "",
    "id": "348"
  },
  {
    "raw_code": "def extract!(*keys)\n      new_instance_with_inherited_permitted_status(@parameters.extract!(*keys))\n    end",
    "comment": "Removes and returns the key/value pairs matching the given keys.  params = ActionController::Parameters.new(a: 1, b: 2, c: 3) params.extract!(:a, :b) # => #<ActionController::Parameters {\"a\"=>1, \"b\"=>2} permitted: false> params                  # => #<ActionController::Parameters {\"c\"=>3} permitted: false>",
    "label": "",
    "id": "349"
  },
  {
    "raw_code": "def transform_values\n      return to_enum(:transform_values) unless block_given?\n      new_instance_with_inherited_permitted_status(\n        @parameters.transform_values { |v| yield convert_value_to_parameters(v) }\n      )\n    end",
    "comment": "Returns a new `ActionController::Parameters` instance with the results of running `block` once for every value. The keys are unchanged.  params = ActionController::Parameters.new(a: 1, b: 2, c: 3) params.transform_values { |x| x * 2 } # => #<ActionController::Parameters {\"a\"=>2, \"b\"=>4, \"c\"=>6} permitted: false>",
    "label": "",
    "id": "350"
  },
  {
    "raw_code": "def transform_values!\n      return to_enum(:transform_values!) unless block_given?\n      @parameters.transform_values! { |v| yield convert_value_to_parameters(v) }\n      self\n    end",
    "comment": "Performs values transformation and returns the altered `ActionController::Parameters` instance.",
    "label": "",
    "id": "351"
  },
  {
    "raw_code": "def transform_keys(&block)\n      return to_enum(:transform_keys) unless block_given?\n      new_instance_with_inherited_permitted_status(\n        @parameters.transform_keys(&block)\n      )\n    end",
    "comment": "Returns a new `ActionController::Parameters` instance with the results of running `block` once for every key. The values are unchanged.",
    "label": "",
    "id": "352"
  },
  {
    "raw_code": "def transform_keys!(&block)\n      return to_enum(:transform_keys!) unless block_given?\n      @parameters.transform_keys!(&block)\n      self\n    end",
    "comment": "Performs keys transformation and returns the altered `ActionController::Parameters` instance.",
    "label": "",
    "id": "353"
  },
  {
    "raw_code": "def deep_transform_keys(&block)\n      new_instance_with_inherited_permitted_status(\n        _deep_transform_keys_in_object(@parameters, &block).to_unsafe_h\n      )\n    end",
    "comment": "Returns a new `ActionController::Parameters` instance with the results of running `block` once for every key. This includes the keys from the root hash and from all nested hashes and arrays. The values are unchanged.",
    "label": "",
    "id": "354"
  },
  {
    "raw_code": "def deep_transform_keys!(&block)\n      @parameters = _deep_transform_keys_in_object(@parameters, &block).to_unsafe_h\n      self\n    end",
    "comment": "Returns the same `ActionController::Parameters` instance with changed keys. This includes the keys from the root hash and from all nested hashes and arrays. The values are unchanged.",
    "label": "",
    "id": "355"
  },
  {
    "raw_code": "def delete(key, &block)\n      convert_value_to_parameters(@parameters.delete(key, &block))\n    end",
    "comment": "Deletes a key-value pair from `Parameters` and returns the value. If `key` is not found, returns `nil` (or, with optional code block, yields `key` and returns the result). This method is similar to #extract!, which returns the corresponding `ActionController::Parameters` object.",
    "label": "",
    "id": "356"
  },
  {
    "raw_code": "def select(&block)\n      new_instance_with_inherited_permitted_status(@parameters.select(&block))\n    end",
    "comment": "Returns a new `ActionController::Parameters` instance with only items that the block evaluates to true.",
    "label": "",
    "id": "357"
  },
  {
    "raw_code": "def select!(&block)\n      @parameters.select!(&block)\n      self\n    end",
    "comment": "Equivalent to Hash#keep_if, but returns `nil` if no changes were made.",
    "label": "",
    "id": "358"
  },
  {
    "raw_code": "def reject(&block)\n      new_instance_with_inherited_permitted_status(@parameters.reject(&block))\n    end",
    "comment": "Returns a new `ActionController::Parameters` instance with items that the block evaluates to true removed.",
    "label": "",
    "id": "359"
  },
  {
    "raw_code": "def reject!(&block)\n      @parameters.reject!(&block)\n      self\n    end",
    "comment": "Removes items that the block evaluates to true and returns self.",
    "label": "",
    "id": "360"
  },
  {
    "raw_code": "def compact\n      new_instance_with_inherited_permitted_status(@parameters.compact)\n    end",
    "comment": "Returns a new `ActionController::Parameters` instance with `nil` values removed.",
    "label": "",
    "id": "361"
  },
  {
    "raw_code": "def compact!\n      self if @parameters.compact!\n    end",
    "comment": "Removes all `nil` values in place and returns `self`, or `nil` if no changes were made.",
    "label": "",
    "id": "362"
  },
  {
    "raw_code": "def compact_blank\n      reject { |_k, v| v.blank? }\n    end",
    "comment": "Returns a new `ActionController::Parameters` instance without the blank values. Uses Object#blank? for determining if a value is blank.",
    "label": "",
    "id": "363"
  },
  {
    "raw_code": "def compact_blank!\n      reject! { |_k, v| v.blank? }\n    end",
    "comment": "Removes all blank values in place and returns self. Uses Object#blank? for determining if a value is blank.",
    "label": "",
    "id": "364"
  },
  {
    "raw_code": "def has_value?(value)\n      each_value.include?(convert_value_to_parameters(value))\n    end",
    "comment": "Returns true if the given value is present for some key in the parameters.",
    "label": "",
    "id": "365"
  },
  {
    "raw_code": "def values_at(*keys)\n      convert_value_to_parameters(@parameters.values_at(*keys))\n    end",
    "comment": "Returns values that were assigned to the given `keys`. Note that all the `Hash` objects will be converted to `ActionController::Parameters`.",
    "label": "",
    "id": "366"
  },
  {
    "raw_code": "def merge(other_hash)\n      new_instance_with_inherited_permitted_status(\n        @parameters.merge(other_hash.to_h)\n      )\n    end",
    "comment": "Returns a new `ActionController::Parameters` instance with all keys from `other_hash` merged into current hash.",
    "label": "",
    "id": "367"
  },
  {
    "raw_code": "def merge!(other_hash, &block)\n      @parameters.merge!(other_hash.to_h, &block)\n      self\n    end",
    "comment": " :call-seq: merge!(other_hash)  Returns the current `ActionController::Parameters` instance with `other_hash` merged into current hash.",
    "label": "",
    "id": "368"
  },
  {
    "raw_code": "def reverse_merge(other_hash)\n      new_instance_with_inherited_permitted_status(\n        other_hash.to_h.merge(@parameters)\n      )\n    end",
    "comment": "Returns a new `ActionController::Parameters` instance with all keys from current hash merged into `other_hash`.",
    "label": "",
    "id": "369"
  },
  {
    "raw_code": "def reverse_merge!(other_hash)\n      @parameters.merge!(other_hash.to_h) { |key, left, right| left }\n      self\n    end",
    "comment": "Returns the current `ActionController::Parameters` instance with current hash merged into `other_hash`.",
    "label": "",
    "id": "370"
  },
  {
    "raw_code": "def stringify_keys # :nodoc:\n      dup\n    end",
    "comment": "This is required by ActiveModel attribute assignment, so that user can pass `Parameters` to a mass assignment methods in a model. It should not matter as we are using `HashWithIndifferentAccess` internally.",
    "label": "",
    "id": "371"
  },
  {
    "raw_code": "def deep_dup\n      self.class.new(@parameters.deep_dup, @logging_context).tap do |duplicate|\n        duplicate.permitted = @permitted\n      end",
    "comment": "Returns a duplicate `ActionController::Parameters` instance with the same permitted parameters.",
    "label": "",
    "id": "372"
  },
  {
    "raw_code": "def extract_value(key, delimiter: \"_\")\n      @parameters[key]&.split(delimiter, -1)\n    end",
    "comment": "Returns parameter value for the given `key` separated by `delimiter`.  params = ActionController::Parameters.new(id: \"1_123\", tags: \"ruby,rails\") params.extract_value(:id) # => [\"1\", \"123\"] params.extract_value(:tags, delimiter: \",\") # => [\"ruby\", \"rails\"] params.extract_value(:non_existent_key) # => nil  Note that if the given `key`'s value contains blank elements, then the returned array will include empty strings.  params = ActionController::Parameters.new(tags: \"ruby,rails,,web\") params.extract_value(:tags, delimiter: \",\") # => [\"ruby\", \"rails\", \"\", \"web\"]",
    "label": "",
    "id": "373"
  },
  {
    "raw_code": "def permit_filters(filters, on_unpermitted: nil, explicit_arrays: true)\n        params = self.class.new\n\n        filters.flatten.each do |filter|\n          case filter\n          when Symbol, String\n            # Declaration [:name, \"age\"]\n            permitted_scalar_filter(params, filter)\n          when Hash\n            # Declaration [{ person: ... }]\n            hash_filter(params, filter, on_unpermitted:, explicit_arrays:)\n          end",
    "comment": "Filters self and optionally checks for unpermitted keys",
    "label": "",
    "id": "374"
  },
  {
    "raw_code": "def array_filter?(filter)\n        filter.is_a?(Array) && filter.size == 1 && filter.first.is_a?(Array)\n      end",
    "comment": "When an array is expected, you must specify an array explicitly using the following format:  params.expect(comments: [[:flavor]])  Which will match only the following array formats:  { pies: [{ flavor: \"rhubarb\" }, { flavor: \"apple\" }] } { pies: { \"0\" => { flavor: \"key lime\" }, \"1\" =>  { flavor: \"mince\" } } }  When using `permit`, arrays are specified the same way as hashes:  params.expect(pies: [:flavor])  In this case, `permit` would also allow matching with a hash (or vice versa):  { pies: { flavor: \"cherry\" } } ",
    "label": "",
    "id": "375"
  },
  {
    "raw_code": "def each_array_element(object, filter, &block)\n        case object\n        when Array\n          object.grep(Parameters).filter_map(&block)\n        when Parameters\n          if object.nested_attributes? && !specify_numeric_keys?(filter)\n            object.each_nested_attribute(&block)\n          end",
    "comment": "Called when an explicit array filter is encountered.",
    "label": "",
    "id": "376"
  },
  {
    "raw_code": "def permitted_scalar_filter(params, permitted_key)\n        permitted_key = permitted_key.to_s\n\n        if has_key?(permitted_key) && permitted_scalar?(self[permitted_key])\n          params[permitted_key] = self[permitted_key]\n        end",
    "comment": "Adds existing keys to the params if their values are scalar.  For example:  puts self.keys #=> [\"zipcode(90210i)\"] params = {}  permitted_scalar_filter(params, \"zipcode\")  puts params.keys # => [\"zipcode\"]",
    "label": "",
    "id": "377"
  },
  {
    "raw_code": "def params\n      @_params ||= begin\n        context = {\n          controller: self.class.name,\n          action: action_name,\n          request: request,\n          params: request.filtered_parameters\n        }\n        Parameters.new(request.parameters, context)\n      end",
    "comment": "Returns a new ActionController::Parameters object that has been instantiated with the `request.parameters`.",
    "label": "",
    "id": "378"
  },
  {
    "raw_code": "def params=(value)\n      @_params = value.is_a?(Hash) ? Parameters.new(value) : value\n    end",
    "comment": "Assigns the given `value` to the `params` hash. If `value` is a Hash, this will create an ActionController::Parameters object that has been instantiated with the given `value` hash.",
    "label": "",
    "id": "379"
  },
  {
    "raw_code": "def self.driven_by(driver, using: :chrome, screen_size: [1400, 1400], options: {}, &capabilities)\n      driver_options = { using: using, screen_size: screen_size, options: options }\n\n      self.driver = SystemTesting::Driver.new(driver, **driver_options, &capabilities)\n    end",
    "comment": "System Test configuration options  The default settings are Selenium, using Chrome, with a screen size of 1400x1400.  Examples:  driven_by :cuprite  driven_by :selenium, screen_size: [800, 800]  driven_by :selenium, using: :chrome  driven_by :selenium, using: :headless_chrome  driven_by :selenium, using: :firefox  driven_by :selenium, using: :headless_firefox",
    "label": "",
    "id": "380"
  },
  {
    "raw_code": "def self.served_by(host:, port:)\n      Capybara.server_host = host\n      Capybara.server_port = port\n    end",
    "comment": "Configuration for the System Test application server.  By default this is localhost. This method allows the host and port to be specified manually.",
    "label": "",
    "id": "381"
  },
  {
    "raw_code": "def fresh?(response)\n          if Request.strict_freshness\n            if if_none_match\n              etag_matches?(response.etag)\n            elsif if_modified_since\n              not_modified?(response.last_modified)\n            else\n              false\n            end",
    "comment": "Check response freshness (`Last-Modified` and `ETag`) against request `If-Modified-Since` and `If-None-Match` conditions. If both headers are supplied, based on configuration, either `ETag` is preferred over `Last-Modified` or both are considered equally. You can adjust the preference with `config.action_dispatch.strict_freshness`. Reference: http://tools.ietf.org/html/rfc7232#section-6",
    "label": "",
    "id": "382"
  },
  {
    "raw_code": "def only_if_cached?\n            @only_if_cached\n          end",
    "comment": "Returns true if the only-if-cached directive is present. This directive indicates that the client only wishes to obtain a stored response. If a valid stored response is not available, the server should respond with a 504 (Gateway Timeout) status.",
    "label": "",
    "id": "383"
  },
  {
    "raw_code": "def no_cache?\n            @no_cache\n          end",
    "comment": "Returns true if the no-cache directive is present. This directive indicates that a cache must not use the response to satisfy subsequent requests without successful validation on the origin server.",
    "label": "",
    "id": "384"
  },
  {
    "raw_code": "def no_store?\n            @no_store\n          end",
    "comment": "Returns true if the no-store directive is present. This directive indicates that a cache must not store any part of the request or response.",
    "label": "",
    "id": "385"
  },
  {
    "raw_code": "def no_transform?\n            @no_transform\n          end",
    "comment": "Returns true if the no-transform directive is present. This directive indicates that a cache or proxy must not transform the payload.",
    "label": "",
    "id": "386"
  },
  {
    "raw_code": "def max_stale?\n            !@max_stale.nil?\n          end",
    "comment": "Returns true if max-stale directive is present (with or without a value)",
    "label": "",
    "id": "387"
  },
  {
    "raw_code": "def max_stale_unlimited?\n            @max_stale == true\n          end",
    "comment": "Returns true if max-stale directive is present without a value (unlimited staleness)",
    "label": "",
    "id": "388"
  },
  {
    "raw_code": "def etag=(weak_validators)\n          self.weak_etag = weak_validators\n        end",
    "comment": "This method sets a weak ETag validator on the response so browsers and proxies may cache the response, keyed on the ETag. On subsequent requests, the `If-None-Match` header is set to the cached ETag. If it matches the current ETag, we can return a `304 Not Modified` response with no body, letting the browser or proxy know that their cache is current. Big savings in request time and network bandwidth.  Weak ETags are considered to be semantically equivalent but not byte-for-byte identical. This is perfect for browser caching of HTML pages where we don't care about exact equality, just what the user is viewing.  Strong ETags are considered byte-for-byte identical. They allow a browser or proxy cache to support `Range` requests, useful for paging through a PDF file or scrubbing through a video. Some CDNs only support strong ETags and will ignore weak ETags entirely.  Weak ETags are what we almost always need, so they're the default. Check out #strong_etag= to provide a strong ETag validator.",
    "label": "",
    "id": "389"
  },
  {
    "raw_code": "def block_all_mixed_content(enabled = true)\n      if enabled\n        @directives[\"block-all-mixed-content\"] = true\n      else\n        @directives.delete(\"block-all-mixed-content\")\n      end",
    "comment": "Specify whether to prevent the user agent from loading any assets over HTTP when the page uses HTTPS:  policy.block_all_mixed_content  Pass `false` to allow it again:  policy.block_all_mixed_content false ",
    "label": "",
    "id": "390"
  },
  {
    "raw_code": "def plugin_types(*types)\n      if types.first\n        @directives[\"plugin-types\"] = types\n      else\n        @directives.delete(\"plugin-types\")\n      end",
    "comment": "Restricts the set of plugins that can be embedded:  policy.plugin_types \"application/x-shockwave-flash\"  Leave empty to allow all plugins:  policy.plugin_types ",
    "label": "",
    "id": "391"
  },
  {
    "raw_code": "def report_uri(uri)\n      @directives[\"report-uri\"] = [uri]\n    end",
    "comment": "Enable the [report-uri](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-uri) directive. Violation reports will be sent to the specified URI:  policy.report_uri \"/csp-violation-report-endpoint\" ",
    "label": "",
    "id": "392"
  },
  {
    "raw_code": "def require_sri_for(*types)\n      if types.first\n        @directives[\"require-sri-for\"] = types\n      else\n        @directives.delete(\"require-sri-for\")\n      end",
    "comment": "Specify asset types for which [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity) is required:  policy.require_sri_for :script, :style  Leave empty to not require Subresource Integrity:  policy.require_sri_for ",
    "label": "",
    "id": "393"
  },
  {
    "raw_code": "def sandbox(*values)\n      if values.empty?\n        @directives[\"sandbox\"] = true\n      elsif values.first\n        @directives[\"sandbox\"] = values\n      else\n        @directives.delete(\"sandbox\")\n      end",
    "comment": "Specify whether a [sandbox](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/sandbox) should be enabled for the requested resource:  policy.sandbox  Values can be passed as arguments:  policy.sandbox \"allow-scripts\", \"allow-modals\"  Pass `false` to disable the sandbox:  policy.sandbox false ",
    "label": "",
    "id": "394"
  },
  {
    "raw_code": "def upgrade_insecure_requests(enabled = true)\n      if enabled\n        @directives[\"upgrade-insecure-requests\"] = true\n      else\n        @directives.delete(\"upgrade-insecure-requests\")\n      end",
    "comment": "Specify whether user agents should treat any assets over HTTP as HTTPS:  policy.upgrade_insecure_requests  Pass `false` to disable it:  policy.upgrade_insecure_requests false ",
    "label": "",
    "id": "395"
  },
  {
    "raw_code": "def initialize\n        super\n        @filtered_parameters = nil\n        @filtered_env        = nil\n        @filtered_path       = nil\n        @parameter_filter    = nil\n      end",
    "comment": ":startdoc:",
    "label": "",
    "id": "396"
  },
  {
    "raw_code": "def filtered_parameters\n        @filtered_parameters ||= parameter_filter.filter(parameters)\n      rescue ActionDispatch::Http::Parameters::ParseError\n        @filtered_parameters = {}\n      end",
    "comment": "Returns a hash of parameters with all sensitive data replaced.",
    "label": "",
    "id": "397"
  },
  {
    "raw_code": "def filtered_env\n        @filtered_env ||= env_filter.filter(@env)\n      end",
    "comment": "Returns a hash of request.env with all sensitive data replaced.",
    "label": "",
    "id": "398"
  },
  {
    "raw_code": "def filtered_path\n        @filtered_path ||= query_string.empty? ? path : \"#{path}?#{filtered_query_string}\"\n      end",
    "comment": "Reconstructs a path with all sensitive GET parameters replaced.",
    "label": "",
    "id": "399"
  },
  {
    "raw_code": "def parameter_filter\n        @parameter_filter ||= if has_header?(\"action_dispatch.parameter_filter\")\n          parameter_filter_for get_header(\"action_dispatch.parameter_filter\")\n        else\n          NULL_PARAM_FILTER\n        end",
    "comment": "Returns the `ActiveSupport::ParameterFilter` object used to filter in this request.",
    "label": "",
    "id": "400"
  },
  {
    "raw_code": "def [](key)\n        @req.get_header env_name(key)\n      end",
    "comment": "Returns the value for the given key mapped to @env.",
    "label": "",
    "id": "401"
  },
  {
    "raw_code": "def []=(key, value)\n        @req.set_header env_name(key), value\n      end",
    "comment": "Sets the given value for the key mapped to @env.",
    "label": "",
    "id": "402"
  },
  {
    "raw_code": "def add(key, value)\n        @req.add_header env_name(key), value\n      end",
    "comment": "Add a value to a multivalued header like `Vary` or `Accept-Encoding`.",
    "label": "",
    "id": "403"
  },
  {
    "raw_code": "def fetch(key, default = DEFAULT)\n        @req.fetch_header(env_name(key)) do\n          return default unless default == DEFAULT\n          return yield if block_given?\n          raise KeyError, key\n        end",
    "comment": "Returns the value for the given key mapped to @env.  If the key is not found and an optional code block is not provided, raises a `KeyError` exception.  If the code block is provided, then it will be run and its result returned.",
    "label": "",
    "id": "404"
  },
  {
    "raw_code": "def merge(headers_or_env)\n        headers = @req.dup.headers\n        headers.merge!(headers_or_env)\n        headers\n      end",
    "comment": "Returns a new Http::Headers instance containing the contents of `headers_or_env` and the original instance.",
    "label": "",
    "id": "405"
  },
  {
    "raw_code": "def merge!(headers_or_env)\n        headers_or_env.each do |key, value|\n          @req.set_header env_name(key), value\n        end",
    "comment": "Adds the contents of `headers_or_env` to original instance entries; duplicate keys are overwritten with the values from `headers_or_env`.",
    "label": "",
    "id": "406"
  },
  {
    "raw_code": "def content_mime_type\n        fetch_header(\"action_dispatch.request.content_type\") do |k|\n          v = if get_header(\"CONTENT_TYPE\") =~ /^([^,;]*)/\n            Mime::Type.lookup($1.strip.downcase)\n          else\n            nil\n          end",
    "comment": "The MIME type of the HTTP request, such as [Mime](:xml).",
    "label": "",
    "id": "407"
  },
  {
    "raw_code": "def accepts\n        fetch_header(\"action_dispatch.request.accepts\") do |k|\n          header = get_header(\"HTTP_ACCEPT\").to_s.strip\n\n          v = if header.empty?\n            [content_mime_type]\n          else\n            Mime::Type.parse(header)\n          end",
    "comment": "Returns the accepted MIME type for the request.",
    "label": "",
    "id": "408"
  },
  {
    "raw_code": "def format(_view_path = nil)\n        formats.first || Mime::NullType.instance\n      end",
    "comment": "Returns the MIME type for the format used in the request.  # GET /posts/5.xml request.format # => Mime[:xml]  # GET /posts/5.xhtml request.format # => Mime[:html]  # GET /posts/5 request.format # => Mime[:html] or Mime[:js], or request.accepts.first ",
    "label": "",
    "id": "409"
  },
  {
    "raw_code": "def variant=(variant)\n        variant = Array(variant)\n\n        if variant.all?(Symbol)\n          @variant = ActiveSupport::ArrayInquirer.new(variant)\n        else\n          raise ArgumentError, \"request.variant must be set to a Symbol or an Array of Symbols.\"\n        end",
    "comment": "Sets the variant for template.",
    "label": "",
    "id": "410"
  },
  {
    "raw_code": "def format=(extension)\n        parameters[:format] = extension.to_s\n        set_header \"action_dispatch.request.formats\", [Mime::Type.lookup_by_extension(parameters[:format])]\n      end",
    "comment": "Sets the format by string extension, which can be used to force custom formats that are not controlled by the extension.  class ApplicationController < ActionController::Base before_action :adjust_format_for_iphone  private def adjust_format_for_iphone request.format = :iphone if request.env[\"HTTP_USER_AGENT\"][/iPhone/] end end",
    "label": "",
    "id": "411"
  },
  {
    "raw_code": "def formats=(extensions)\n        parameters[:format] = extensions.first.to_s\n        set_header \"action_dispatch.request.formats\", extensions.collect { |extension|\n          Mime::Type.lookup_by_extension(extension)\n        }\n      end",
    "comment": "Sets the formats by string extensions. This differs from #format= by allowing you to set multiple, ordered formats, which is useful when you want to have a fallback.  In this example, the `:iphone` format will be used if it's available, otherwise it'll fall back to the `:html` format.  class ApplicationController < ActionController::Base before_action :adjust_format_for_iphone_with_html_fallback  private def adjust_format_for_iphone_with_html_fallback request.formats = [ :iphone, :html ] if request.env[\"HTTP_USER_AGENT\"][/iPhone/] end end",
    "label": "",
    "id": "412"
  },
  {
    "raw_code": "def negotiate_mime(order)\n        formats.each do |priority|\n          if priority == Mime::ALL\n            return order.first\n          elsif order.include?(priority)\n            return priority\n          end",
    "comment": "Returns the first MIME type that matches the provided array of MIME types.",
    "label": "",
    "id": "413"
  },
  {
    "raw_code": "def register_alias(string, symbol, extension_synonyms = [])\n        register(string, symbol, [], extension_synonyms, true)\n      end",
    "comment": "Registers an alias that's not used on MIME type lookup, but can be referenced directly. Especially useful for rendering different HTML versions depending on the user agent, like an iPhone.",
    "label": "",
    "id": "414"
  },
  {
    "raw_code": "def parse_data_with_trailing_star(type)\n        Mime::SET.select { |m| m.match?(type) }\n      end",
    "comment": "For an input of `'text'`, returns `[Mime[:json], Mime[:xml], Mime[:ics], Mime[:html], Mime[:css], Mime[:csv], Mime[:js], Mime[:yaml], Mime[:text]]`.  For an input of `'application'`, returns `[Mime[:html], Mime[:js], Mime[:xml], Mime[:yaml], Mime[:atom], Mime[:json], Mime[:rss], Mime[:url_encoded_form]]`.",
    "label": "",
    "id": "415"
  },
  {
    "raw_code": "def unregister(symbol)\n        symbol = symbol.downcase\n        if mime = Mime[symbol]\n          SET.delete_if { |v| v.eql?(mime) }\n          LOOKUP.delete_if { |_, v| v.eql?(mime) }\n          EXTENSION_LOOKUP.delete_if { |_, v| v.eql?(mime) }\n        end",
    "comment": "This method is opposite of register method.  To unregister a MIME type:  Mime::Type.unregister(:mobile)",
    "label": "",
    "id": "416"
  },
  {
    "raw_code": "def parameter_parsers=(parsers)\n          @parameter_parsers = parsers.transform_keys { |key| key.respond_to?(:symbol) ? key.symbol : key }\n        end",
    "comment": "Configure the parameter parser for a given MIME type.  It accepts a hash where the key is the symbol of the MIME type and the value is a proc.  original_parsers = ActionDispatch::Request.parameter_parsers xml_parser = -> (raw_post) { Hash.from_xml(raw_post) || {} } new_parsers = original_parsers.merge(xml: xml_parser) ActionDispatch::Request.parameter_parsers = new_parsers",
    "label": "",
    "id": "417"
  },
  {
    "raw_code": "def parameters\n        params = get_header(\"action_dispatch.request.parameters\")\n        return params if params\n\n        params = begin\n                   request_parameters.merge(query_parameters)\n                 rescue EOFError\n                   query_parameters.dup\n                 end",
    "comment": "Returns both GET and POST parameters in a single hash.",
    "label": "",
    "id": "418"
  },
  {
    "raw_code": "def path_parameters\n        @env[PARAMETERS_KEY] ||= {}\n      end",
    "comment": "Returns a hash with the parameters used to form the path of the request. Returned hash keys are symbols:  { action: \"my_action\", controller: \"my_controller\" }",
    "label": "",
    "id": "419"
  },
  {
    "raw_code": "def self.make_default(param_depth_limit)\n      new param_depth_limit\n    end",
    "comment": "-- This implementation is based on Rack::QueryParser, Copyright (C) 2007-2021 Leah Neukirchen <http://leahneukirchen.org/infopage.html>",
    "label": "",
    "id": "420"
  },
  {
    "raw_code": "def self.each_pair(s, separator = nil)\n      return enum_for(:each_pair, s, separator) unless block_given?\n\n      s ||= \"\"\n\n      splitter =\n        if separator\n          COMMON_SEP[separator] || /[#{separator}] */n\n        else\n          DEFAULT_SEP\n        end",
    "comment": "-- Note this departs from WHATWG's specified parsing algorithm by giving a nil value for keys that do not use '='. Callers that need the standard's interpretation can use `v.to_s`.",
    "label": "",
    "id": "421"
  },
  {
    "raw_code": "def #{env.delete_prefix(\"HTTP_\").downcase}  # def accept_charset\n          get_header \"#{env}\"                       #   get_header \"HTTP_ACCEPT_CHARSET\"\n        end                                         # end\n      METHOD\n    end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "422"
  },
  {
    "raw_code": "def key?(key)\n      has_header? key\n    end",
    "comment": "Returns true if the request has a header matching the given key parameter.  request.key? :ip_spoofing_check # => true",
    "label": "",
    "id": "423"
  },
  {
    "raw_code": "def request_method\n      @request_method ||= check_method(super)\n    end",
    "comment": "Returns the HTTP method that the application should see. In the case where the method was overridden by a middleware (for instance, if a HEAD request was converted to a GET, or if a _method parameter was used to determine the method the application should use), this method returns the overridden value, not the original.",
    "label": "",
    "id": "424"
  },
  {
    "raw_code": "def route_uri_pattern\n      unless pattern = get_header(\"action_dispatch.route_uri_pattern\")\n        route = get_header(\"action_dispatch.route\")\n        return if route.nil?\n        pattern = route.path.spec.to_s\n        set_header(\"action_dispatch.route_uri_pattern\", pattern)\n      end",
    "comment": "Returns the URI pattern of the matched route for the request, using the same format as `bin/rails routes`:  request.route_uri_pattern # => \"/:controller(/:action(/:id))(.:format)\"",
    "label": "",
    "id": "425"
  },
  {
    "raw_code": "def request_method_symbol\n      HTTP_METHOD_LOOKUP[request_method]\n    end",
    "comment": "Returns a symbol form of the #request_method.",
    "label": "",
    "id": "426"
  },
  {
    "raw_code": "def method(*args)\n      if args.empty?\n        @method ||= check_method(\n          get_header(\"rack.methodoverride.original_method\") ||\n          get_header(\"REQUEST_METHOD\")\n        )\n      else\n        super\n      end",
    "comment": "Returns the original value of the environment's REQUEST_METHOD, even if it was overridden by middleware. See #request_method for more information.  For debugging purposes, when called with arguments this method will fall back to Object#method",
    "label": "",
    "id": "427"
  },
  {
    "raw_code": "def method_symbol\n      HTTP_METHOD_LOOKUP[method]\n    end",
    "comment": "Returns a symbol form of the #method.",
    "label": "",
    "id": "428"
  },
  {
    "raw_code": "def headers\n      @headers ||= Http::Headers.new(self)\n    end",
    "comment": "Provides access to the request's HTTP headers, for example:  request.headers[\"Content-Type\"] # => \"text/plain\"",
    "label": "",
    "id": "429"
  },
  {
    "raw_code": "def send_early_hints(links)\n      env[\"rack.early_hints\"]&.call(links)\n    end",
    "comment": "Early Hints is an HTTP/2 status code that indicates hints to help a client start making preparations for processing the final response.  If the env contains `rack.early_hints` then the server accepts HTTP2 push for link headers.  The `send_early_hints` method accepts a hash of links as follows:  send_early_hints(\"link\" => \"</style.css>; rel=preload; as=style,</script.js>; rel=preload\")  If you are using {javascript_include_tag}[rdoc-ref:ActionView::Helpers::AssetTagHelper#javascript_include_tag] or {stylesheet_link_tag}[rdoc-ref:ActionView::Helpers::AssetTagHelper#stylesheet_link_tag] the Early Hints headers are included by default if supported.",
    "label": "",
    "id": "430"
  },
  {
    "raw_code": "def original_fullpath\n      @original_fullpath ||= (get_header(\"ORIGINAL_FULLPATH\") || fullpath)\n    end",
    "comment": "Returns a `String` with the last requested path including their params.  # get '/foo' request.original_fullpath # => '/foo'  # get '/foo?bar' request.original_fullpath # => '/foo?bar'",
    "label": "",
    "id": "431"
  },
  {
    "raw_code": "def fullpath\n      @fullpath ||= super\n    end",
    "comment": "Returns the `String` full path including params of the last URL requested.  # get \"/articles\" request.fullpath # => \"/articles\"  # get \"/articles?page=2\" request.fullpath # => \"/articles?page=2\"",
    "label": "",
    "id": "432"
  },
  {
    "raw_code": "def original_url\n      base_url + original_fullpath\n    end",
    "comment": "Returns the original request URL as a `String`.  # get \"/articles?page=2\" request.original_url # => \"http://www.example.com/articles?page=2\"",
    "label": "",
    "id": "433"
  },
  {
    "raw_code": "def media_type\n      content_mime_type&.to_s\n    end",
    "comment": "The `String` MIME type of the request.  # get \"/articles\" request.media_type # => \"application/x-www-form-urlencoded\"",
    "label": "",
    "id": "434"
  },
  {
    "raw_code": "def content_length\n      return raw_post.bytesize if has_header?(TRANSFER_ENCODING)\n      super.to_i\n    end",
    "comment": "Returns the content length of the request as an integer.",
    "label": "",
    "id": "435"
  },
  {
    "raw_code": "def xml_http_request?\n      /XMLHttpRequest/i.match?(get_header(\"HTTP_X_REQUESTED_WITH\"))\n    end",
    "comment": "Returns true if the `X-Requested-With` header contains \"XMLHttpRequest\" (case-insensitive), which may need to be manually added depending on the choice of JavaScript libraries and frameworks.",
    "label": "",
    "id": "436"
  },
  {
    "raw_code": "def ip\n      @ip ||= super\n    end",
    "comment": "Returns the IP address of client as a `String`.",
    "label": "",
    "id": "437"
  },
  {
    "raw_code": "def remote_ip\n      @remote_ip ||= (get_header(\"action_dispatch.remote_ip\") || ip).to_s\n    end",
    "comment": "Returns the IP address of client as a `String`, usually set by the RemoteIp middleware.",
    "label": "",
    "id": "438"
  },
  {
    "raw_code": "def request_id\n      get_header ACTION_DISPATCH_REQUEST_ID\n    end",
    "comment": "Returns the unique request id, which is based on either the `X-Request-Id` header that can be generated by a firewall, load balancer, or web server, or by the RequestId middleware (which sets the `action_dispatch.request_id` environment variable).  This unique ID is useful for tracing a request from end-to-end as part of logging or debugging. This relies on the Rack variable set by the ActionDispatch::RequestId middleware.",
    "label": "",
    "id": "439"
  },
  {
    "raw_code": "def server_software\n      (get_header(\"SERVER_SOFTWARE\") && /^([a-zA-Z]+)/ =~ get_header(\"SERVER_SOFTWARE\")) ? $1.downcase : nil\n    end",
    "comment": "Returns the lowercase name of the HTTP server software.",
    "label": "",
    "id": "440"
  },
  {
    "raw_code": "def raw_post\n      unless has_header? \"RAW_POST_DATA\"\n        set_header(\"RAW_POST_DATA\", read_body_stream)\n      end",
    "comment": "Read the request body. This is useful for web services that need to work with raw requests directly.",
    "label": "",
    "id": "441"
  },
  {
    "raw_code": "def body\n      if raw_post = get_header(\"RAW_POST_DATA\")\n        raw_post = (+raw_post).force_encoding(Encoding::BINARY)\n        StringIO.new(raw_post)\n      else\n        body_stream\n      end",
    "comment": "The request body is an IO input stream. If the RAW_POST_DATA environment variable is already set, wrap it in a StringIO.",
    "label": "",
    "id": "442"
  },
  {
    "raw_code": "def form_data?\n      FORM_DATA_MEDIA_TYPES.include?(media_type)\n    end",
    "comment": "Determine whether the request body contains form-data by checking the request `Content-Type` for one of the media-types: `application/x-www-form-urlencoded` or `multipart/form-data`. The list of form-data media types can be modified through the `FORM_DATA_MEDIA_TYPES` array.  A request body is not assumed to contain form-data when no `Content-Type` header is provided and the request_method is POST.",
    "label": "",
    "id": "443"
  },
  {
    "raw_code": "def GET\n      fetch_header(\"action_dispatch.request.query_parameters\") do |k|\n        encoding_template = Request::Utils::CustomParamEncoder.action_encoding_template(self, path_parameters[:controller], path_parameters[:action])\n        rack_query_params = ActionDispatch::ParamBuilder.from_query_string(rack_request.query_string, encoding_template: encoding_template)\n\n        set_header k, rack_query_params\n      end",
    "comment": "Override Rack's GET method to support indifferent access.",
    "label": "",
    "id": "444"
  },
  {
    "raw_code": "def POST\n      fetch_header(\"action_dispatch.request.request_parameters\") do\n        encoding_template = Request::Utils::CustomParamEncoder.action_encoding_template(self, path_parameters[:controller], path_parameters[:action])\n\n        param_list = nil\n        pr = parse_formatted_parameters(params_parsers) do\n          if param_list = request_parameters_list\n            ActionDispatch::ParamBuilder.from_pairs(param_list, encoding_template: encoding_template)\n          else\n            # We're not using a version of Rack that provides raw form\n            # pairs; we must use its hash (and thus post-process it below).\n            fallback_request_parameters\n          end",
    "comment": "Override Rack's POST method to support indifferent access.",
    "label": "",
    "id": "445"
  },
  {
    "raw_code": "def authorization\n      get_header(\"HTTP_AUTHORIZATION\")   ||\n      get_header(\"X-HTTP_AUTHORIZATION\") ||\n      get_header(\"X_HTTP_AUTHORIZATION\") ||\n      get_header(\"REDIRECT_X_HTTP_AUTHORIZATION\")\n    end",
    "comment": "Returns the authorization header regardless of whether it was specified directly or through one of the proxy alternatives.",
    "label": "",
    "id": "446"
  },
  {
    "raw_code": "def local?\n      LOCALHOST.match?(remote_addr) && LOCALHOST.match?(remote_ip)\n    end",
    "comment": "True if the request came from localhost, 127.0.0.1, or ::1.",
    "label": "",
    "id": "447"
  },
  {
    "raw_code": "def charset\n      header_info = parsed_content_type_header\n      header_info.charset || self.class.default_charset\n    end",
    "comment": "The charset of the response. HTML wants to know the encoding of the content you're giving them, so we need to send that along.",
    "label": "",
    "id": "448"
  },
  {
    "raw_code": "def response_code\n      @status\n    end",
    "comment": "The response code of the request.",
    "label": "",
    "id": "449"
  },
  {
    "raw_code": "def code\n      @status.to_s\n    end",
    "comment": "Returns a string to ensure compatibility with `Net::HTTPResponse`.",
    "label": "",
    "id": "450"
  },
  {
    "raw_code": "def message\n      Rack::Utils::HTTP_STATUS_CODES[@status]\n    end",
    "comment": "Returns the corresponding message for the current HTTP status code:  response.status = 200 response.message # => \"OK\"  response.status = 404 response.message # => \"Not Found\" ",
    "label": "",
    "id": "451"
  },
  {
    "raw_code": "def body\n      if @stream.respond_to?(:to_ary)\n        @stream.to_ary.join\n      elsif @stream.respond_to?(:body)\n        @stream.body\n      else\n        @stream\n      end",
    "comment": "Returns the content of the response as a string. This contains the contents of any calls to `render`.",
    "label": "",
    "id": "452"
  },
  {
    "raw_code": "def body=(body)\n      # Prevent ActionController::Metal::Live::Response from committing the response prematurely.\n      synchronize do\n        if body.respond_to?(:to_str)\n          @stream = build_buffer(self, [body])\n        elsif body.respond_to?(:to_path)\n          @stream = body\n        elsif body.respond_to?(:to_ary)\n          @stream = build_buffer(self, body)\n        else\n          @stream = body\n        end",
    "comment": "Allows you to manually set or override the response body.",
    "label": "",
    "id": "453"
  },
  {
    "raw_code": "def each\n        File.open(to_path, \"rb\") do |file|\n          while chunk = file.read(16384)\n            yield chunk\n          end",
    "comment": "Stream the file's contents if Rack::Sendfile isn't present.",
    "label": "",
    "id": "454"
  },
  {
    "raw_code": "def send_file(path)\n      commit!\n      @stream = FileBody.new(path)\n    end",
    "comment": "Send the file stored at `path` as the response body.",
    "label": "",
    "id": "455"
  },
  {
    "raw_code": "def to_a\n      commit!\n      rack_response @status, @headers.to_hash\n    end",
    "comment": "Turns the Response into a Rack-compatible array of the status, headers, and body. Allows explicit splatting:  status, headers, body = *response",
    "label": "",
    "id": "456"
  },
  {
    "raw_code": "def cookies\n      cookies = {}\n      if header = get_header(SET_COOKIE)\n        header = header.split(\"\\n\") if header.respond_to?(:to_str)\n        header.each do |cookie|\n          if pair = cookie.split(\";\").first\n            key, value = pair.split(\"=\").map { |v| Rack::Utils.unescape(v) }\n            cookies[key] = value\n          end",
    "comment": "Returns the response cookies, converted to a Hash of (name => value) pairs  assert_equal 'AuthorOfNewPage', r.cookies['author']",
    "label": "",
    "id": "457"
  },
  {
    "raw_code": "def parsed_content_type_header\n      parse_content_type(get_header(CONTENT_TYPE))\n    end",
    "comment": "Small internal convenience method to get the parsed version of the current content type header.",
    "label": "",
    "id": "458"
  },
  {
    "raw_code": "def read(length = nil, buffer = nil)\n        @tempfile.read(length, buffer)\n      end",
    "comment": "Shortcut for `tempfile.read`.",
    "label": "",
    "id": "459"
  },
  {
    "raw_code": "def open\n        @tempfile.open\n      end",
    "comment": "Shortcut for `tempfile.open`.",
    "label": "",
    "id": "460"
  },
  {
    "raw_code": "def close(unlink_now = false)\n        @tempfile.close(unlink_now)\n      end",
    "comment": "Shortcut for `tempfile.close`.",
    "label": "",
    "id": "461"
  },
  {
    "raw_code": "def path\n        @tempfile.path\n      end",
    "comment": "Shortcut for `tempfile.path`.",
    "label": "",
    "id": "462"
  },
  {
    "raw_code": "def to_path\n        @tempfile.to_path\n      end",
    "comment": "Shortcut for `tempfile.to_path`.",
    "label": "",
    "id": "463"
  },
  {
    "raw_code": "def rewind\n        @tempfile.rewind\n      end",
    "comment": "Shortcut for `tempfile.rewind`.",
    "label": "",
    "id": "464"
  },
  {
    "raw_code": "def size\n        @tempfile.size\n      end",
    "comment": "Shortcut for `tempfile.size`.",
    "label": "",
    "id": "465"
  },
  {
    "raw_code": "def eof?\n        @tempfile.eof?\n      end",
    "comment": "Shortcut for `tempfile.eof?`.",
    "label": "",
    "id": "466"
  },
  {
    "raw_code": "def domain_from(host, tld_length)\n          host.split(\".\").last(1 + tld_length).join(\".\")\n        end",
    "comment": "Extracts the domain part from a host string, including the specified number of top-level domain components.  The domain includes the main domain name plus the TLD components. The +tld_length+ parameter specifies how many components from the right should be considered part of the TLD.  ==== Parameters  [+host+] The host string to extract the domain from.  [+tld_length+] The number of domain components that make up the TLD. For example, use 1 for \".com\" or 2 for \".co.uk\".  ==== Examples  # Standard TLD (tld_length = 1) DomainExtractor.domain_from(\"www.example.com\", 1) # => \"example.com\"  # Country-code TLD (tld_length = 2) DomainExtractor.domain_from(\"www.example.co.uk\", 2) # => \"example.co.uk\"  # Multiple subdomains DomainExtractor.domain_from(\"api.staging.myapp.herokuapp.com\", 1) # => \"herokuapp.com\"  # Single component (returns the host itself) DomainExtractor.domain_from(\"localhost\", 1) # => \"localhost\"",
    "label": "",
    "id": "467"
  },
  {
    "raw_code": "def subdomains_from(host, tld_length)\n          parts = host.split(\".\")\n          parts[0..-(tld_length + 2)]\n        end",
    "comment": "Extracts the subdomain components from a host string as an Array.  Returns all the components that come before the domain and TLD parts. The +tld_length+ parameter is used to determine where the domain begins so that everything before it is considered a subdomain.  ==== Parameters  [+host+] The host string to extract subdomains from.  [+tld_length+] The number of domain components that make up the TLD. This affects where the domain boundary is calculated.  ==== Examples  # Standard TLD (tld_length = 1) DomainExtractor.subdomains_from(\"www.example.com\", 1) # => [\"www\"]  # Country-code TLD (tld_length = 2) DomainExtractor.subdomains_from(\"api.staging.example.co.uk\", 2) # => [\"api\", \"staging\"]  # No subdomains DomainExtractor.subdomains_from(\"example.com\", 1) # => []  # Single subdomain with complex TLD DomainExtractor.subdomains_from(\"www.mysite.co.uk\", 2) # => [\"www\"]  # Multiple levels of subdomains DomainExtractor.subdomains_from(\"dev.api.staging.example.com\", 1) # => [\"dev\", \"api\", \"staging\"]",
    "label": "",
    "id": "468"
  },
  {
    "raw_code": "def extract_domain(host, tld_length)\n          extract_domain_from(host, tld_length) if named_host?(host)\n        end",
    "comment": "Returns the domain part of a host given the domain level.  # Top-level domain example extract_domain('www.example.com', 1) # => \"example.com\" # Second-level domain example extract_domain('dev.www.example.co.uk', 2) # => \"example.co.uk\"",
    "label": "",
    "id": "469"
  },
  {
    "raw_code": "def extract_subdomains(host, tld_length)\n          if named_host?(host)\n            extract_subdomains_from(host, tld_length)\n          else\n            []\n          end",
    "comment": "Returns the subdomains of a host as an Array given the domain level.  # Top-level domain example extract_subdomains('www.example.com', 1) # => [\"www\"] # Second-level domain example extract_subdomains('dev.www.example.co.uk', 2) # => [\"dev\", \"www\"]",
    "label": "",
    "id": "470"
  },
  {
    "raw_code": "def extract_subdomain(host, tld_length)\n          extract_subdomains(host, tld_length).join(\".\")\n        end",
    "comment": "Returns the subdomains of a host as a String given the domain level.  # Top-level domain example extract_subdomain('www.example.com', 1) # => \"www\" # Second-level domain example extract_subdomain('dev.www.example.co.uk', 2) # => \"dev.www\"",
    "label": "",
    "id": "471"
  },
  {
    "raw_code": "def url\n        protocol + host_with_port + fullpath\n      end",
    "comment": "Returns the complete URL used for this request.  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com' req.url # => \"http://example.com\"",
    "label": "",
    "id": "472"
  },
  {
    "raw_code": "def protocol\n        @protocol ||= ssl? ? \"https://\" : \"http://\"\n      end",
    "comment": "Returns 'https://' if this is an SSL request and 'http://' otherwise.  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com' req.protocol # => \"http://\"  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com', 'HTTPS' => 'on' req.protocol # => \"https://\"",
    "label": "",
    "id": "473"
  },
  {
    "raw_code": "def raw_host_with_port\n        if forwarded = x_forwarded_host.presence\n          forwarded.split(/,\\s?/).last\n        else\n          get_header(\"HTTP_HOST\") || \"#{server_name}:#{get_header('SERVER_PORT')}\"\n        end",
    "comment": "Returns the host and port for this request, such as \"example.com:8080\".  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com' req.raw_host_with_port # => \"example.com\"  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:80' req.raw_host_with_port # => \"example.com:80\"  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080' req.raw_host_with_port # => \"example.com:8080\"",
    "label": "",
    "id": "474"
  },
  {
    "raw_code": "def host\n        raw_host_with_port.sub(/:\\d+$/, \"\")\n      end",
    "comment": "Returns the host for this request, such as \"example.com\".  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080' req.host # => \"example.com\"",
    "label": "",
    "id": "475"
  },
  {
    "raw_code": "def host_with_port\n        \"#{host}#{port_string}\"\n      end",
    "comment": "Returns a host:port string for this request, such as \"example.com\" or \"example.com:8080\". Port is only included if it is not a default port (80 or 443)  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com' req.host_with_port # => \"example.com\"  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:80' req.host_with_port # => \"example.com\"  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080' req.host_with_port # => \"example.com:8080\"",
    "label": "",
    "id": "476"
  },
  {
    "raw_code": "def port\n        @port ||= if raw_host_with_port =~ /:(\\d+)$/\n          $1.to_i\n        else\n          standard_port\n        end",
    "comment": "Returns the port number of this request as an integer.  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com' req.port # => 80  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080' req.port # => 8080",
    "label": "",
    "id": "477"
  },
  {
    "raw_code": "def standard_port\n        if \"https://\" == protocol\n          443\n        else\n          80\n        end",
    "comment": "Returns the standard port number for this request's protocol.  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080' req.standard_port # => 80",
    "label": "",
    "id": "478"
  },
  {
    "raw_code": "def standard_port?\n        port == standard_port\n      end",
    "comment": "Returns whether this request is using the standard port.  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:80' req.standard_port? # => true  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080' req.standard_port? # => false",
    "label": "",
    "id": "479"
  },
  {
    "raw_code": "def optional_port\n        standard_port? ? nil : port\n      end",
    "comment": "Returns a number port suffix like 8080 if the port number of this request is not the default HTTP port 80 or HTTPS port 443.  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:80' req.optional_port # => nil  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080' req.optional_port # => 8080",
    "label": "",
    "id": "480"
  },
  {
    "raw_code": "def port_string\n        standard_port? ? \"\" : \":#{port}\"\n      end",
    "comment": "Returns a string port suffix, including colon, like \":8080\" if the port number of this request is not the default HTTP port 80 or HTTPS port 443.  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:80' req.port_string # => \"\"  req = ActionDispatch::Request.new 'HTTP_HOST' => 'example.com:8080' req.port_string # => \":8080\"",
    "label": "",
    "id": "481"
  },
  {
    "raw_code": "def server_port\n        get_header(\"SERVER_PORT\").to_i\n      end",
    "comment": "Returns the requested port, such as 8080, based on SERVER_PORT.  req = ActionDispatch::Request.new 'SERVER_PORT' => '80' req.server_port # => 80  req = ActionDispatch::Request.new 'SERVER_PORT' => '8080' req.server_port # => 8080",
    "label": "",
    "id": "482"
  },
  {
    "raw_code": "def domain(tld_length = @@tld_length)\n        ActionDispatch::Http::URL.extract_domain(host, tld_length)\n      end",
    "comment": "Returns the domain part of a host, such as \"rubyonrails.org\" in \"www.rubyonrails.org\". You can specify a different `tld_length`, such as 2 to catch rubyonrails.co.uk in \"www.rubyonrails.co.uk\".",
    "label": "",
    "id": "483"
  },
  {
    "raw_code": "def subdomains(tld_length = @@tld_length)\n        ActionDispatch::Http::URL.extract_subdomains(host, tld_length)\n      end",
    "comment": "Returns all the subdomains as an array, so `[\"dev\", \"www\"]` would be returned for \"dev.www.rubyonrails.org\". You can specify a different `tld_length`, such as 2 to catch `[\"www\"]` instead of `[\"www\", \"rubyonrails\"]` in \"www.rubyonrails.co.uk\".",
    "label": "",
    "id": "484"
  },
  {
    "raw_code": "def subdomain(tld_length = @@tld_length)\n        ActionDispatch::Http::URL.extract_subdomain(host, tld_length)\n      end",
    "comment": "Returns all the subdomains as a string, so `\"dev.www\"` would be returned for \"dev.www.rubyonrails.org\". You can specify a different `tld_length`, such as 2 to catch `\"www\"` instead of `\"www.rubyonrails\"` in \"www.rubyonrails.co.uk\".",
    "label": "",
    "id": "485"
  },
  {
    "raw_code": "def missing_keys(route, parts)\n          missing_keys = nil\n          tests = route.path.requirements_for_missing_keys_check\n          route.required_parts.each { |key|\n            case tests[key]\n            when nil\n              unless parts[key]\n                missing_keys ||= []\n                missing_keys << key\n              end",
    "comment": "Returns an array populated with missing keys if any are present.",
    "label": "",
    "id": "486"
  },
  {
    "raw_code": "def initialize(name:, app: nil, path:, constraints: {}, required_defaults: [], defaults: {}, via: nil, precedence: 0, scope_options: {}, internal: false, source_location: nil)\n        @name        = name\n        @app         = app\n        @path        = path\n\n        @request_method_match = via && VerbMatchers.for(via)\n        @constraints = constraints\n        @defaults    = defaults\n        @required_defaults = nil\n        @_required_defaults = required_defaults\n        @required_parts    = nil\n        @parts             = nil\n        @precedence        = precedence\n        @path_formatter    = @path.build_formatter\n        @scope_options     = scope_options\n        @internal          = internal\n        @source_location   = source_location\n\n        @ast = @path.ast.root\n        @path.ast.route = self\n      end",
    "comment": " +path+ is a path constraint. `constraints` is a hash of constraints to be applied to this route.",
    "label": "",
    "id": "487"
  },
  {
    "raw_code": "def requirements\n        @defaults.merge(path.requirements).delete_if { |_, v|\n          /.+?/m == v\n        }\n      end",
    "comment": "Needed for `bin/rails routes`. Picks up succinctly defined requirements for a route, for example route  get 'photo/:id', :controller => 'photos', :action => 'show', :id => /[A-Z]\\d{5}/  will have {:controller=>\"photos\", :action=>\"show\", :[id=>/](A-Z){5}/} as requirements.",
    "label": "",
    "id": "488"
  },
  {
    "raw_code": "def self.normalize_path(path)\n          return \"/\".dup unless path\n\n          # Fast path for the overwhelming majority of paths that don't need to be normalized\n          if path == \"/\" || (path.start_with?(\"/\") && !path.end_with?(\"/\") && !path.match?(%r{%|//}))\n            return path.dup\n          end",
    "comment": "Normalizes URI path.  Strips off trailing slash and ensures there is a leading slash. Also converts downcase URL encoded string to uppercase.  normalize_path(\"/foo\")  # => \"/foo\" normalize_path(\"/foo/\") # => \"/foo\" normalize_path(\"foo\")   # => \"/foo\" normalize_path(\"\")      # => \"/\" normalize_path(\"/%ab\")  # => \"/%AB\"",
    "label": "",
    "id": "489"
  },
  {
    "raw_code": "def permanent\n        @permanent ||= PermanentCookieJar.new(self)\n      end",
    "comment": "Returns a jar that'll automatically set the assigned cookies to have an expiration date 20 years from now. Example:  cookies.permanent[:prefers_open_id] = true # => Set-Cookie: prefers_open_id=true; path=/; expires=Sun, 16-Dec-2029 03:24:16 GMT  This jar is only meant for writing. You'll read permanent cookies through the regular accessor.  This jar allows chaining with the signed jar as well, so you can set permanent, signed cookies. Examples:  cookies.permanent.signed[:remember_me] = current_user.id # => Set-Cookie: remember_me=BAhU--848956038e692d7046deab32b7131856ab20e14e; path=/; expires=Sun, 16-Dec-2029 03:24:16 GMT",
    "label": "",
    "id": "490"
  },
  {
    "raw_code": "def signed\n        @signed ||= SignedKeyRotatingCookieJar.new(self)\n      end",
    "comment": "Returns a jar that'll automatically generate a signed representation of cookie value and verify it when reading from the cookie again. This is useful for creating cookies with values that the user is not supposed to change. If a signed cookie was tampered with by the user (or a 3rd party), `nil` will be returned.  This jar requires that you set a suitable secret for the verification on your app's `secret_key_base`.  Example:  cookies.signed[:discount] = 45 # => Set-Cookie: discount=BAhpMg==--2c1c6906c90a3bc4fd54a51ffb41dffa4bf6b5f7; path=/  cookies.signed[:discount] # => 45",
    "label": "",
    "id": "491"
  },
  {
    "raw_code": "def encrypted\n        @encrypted ||= EncryptedKeyRotatingCookieJar.new(self)\n      end",
    "comment": "Returns a jar that'll automatically encrypt cookie values before sending them to the client and will decrypt them for read. If the cookie was tampered with by the user (or a 3rd party), `nil` will be returned.  If `config.action_dispatch.encrypted_cookie_salt` and `config.action_dispatch.encrypted_signed_cookie_salt` are both set, legacy cookies encrypted with HMAC AES-256-CBC will be transparently upgraded.  This jar requires that you set a suitable secret for the verification on your app's `secret_key_base`.  Example:  cookies.encrypted[:discount] = 45 # => Set-Cookie: discount=DIQ7fw==--K3n//8vvnSbGq9dA--7Xh91HfLpwzbj1czhBiwOg==; path=/  cookies.encrypted[:discount] # => 45",
    "label": "",
    "id": "492"
  },
  {
    "raw_code": "def signed_or_encrypted\n        @signed_or_encrypted ||=\n          if request.secret_key_base.present?\n            encrypted\n          else\n            signed\n          end",
    "comment": "Returns the `signed` or `encrypted` jar, preferring `encrypted` if `secret_key_base` is set. Used by ActionDispatch::Session::CookieStore to avoid the need to introduce new cookie stores.",
    "label": "",
    "id": "493"
  },
  {
    "raw_code": "def delete(name, options = {})\n        return unless @cookies.has_key? name.to_s\n\n        options.symbolize_keys!\n        handle_options(options)\n\n        value = @cookies.delete(name.to_s)\n        @delete_cookies[name.to_s] = options\n        value\n      end",
    "comment": "Removes the cookie on the client machine by setting the value to an empty string and the expiration date in the past. Like `[]=`, you can pass in an options hash to delete cookies with extra data such as a `:path`.  Returns the value of the cookie, or `nil` if the cookie does not exist.",
    "label": "",
    "id": "494"
  },
  {
    "raw_code": "def deleted?(name, options = {})\n        options.symbolize_keys!\n        handle_options(options)\n        @delete_cookies[name.to_s] == options\n      end",
    "comment": "Whether the given cookie is to be deleted by this CookieJar. Like `[]=`, you can pass in an options hash to test if a deletion applies to a specific `:path`, `:domain` etc.",
    "label": "",
    "id": "495"
  },
  {
    "raw_code": "def clear(options = {})\n        @cookies.each_key { |k| delete(k, options) }\n      end",
    "comment": "Removes all cookies on the client machine by calling `delete` for each cookie.",
    "label": "",
    "id": "496"
  },
  {
    "raw_code": "def flash\n        flash = flash_hash\n        return flash if flash\n        self.flash = Flash::FlashHash.from_session_value(session[\"flash\"])\n      end",
    "comment": "Access the contents of the flash. Returns a ActionDispatch::Flash::FlashHash.  See ActionDispatch::Flash for example usage.",
    "label": "",
    "id": "497"
  },
  {
    "raw_code": "def alert=(message)\n        self[:alert] = message\n      end",
    "comment": "Convenience accessor for `flash.now[:alert]=`.",
    "label": "",
    "id": "498"
  },
  {
    "raw_code": "def notice=(message)\n        self[:notice] = message\n      end",
    "comment": "Convenience accessor for `flash.now[:notice]=`.",
    "label": "",
    "id": "499"
  },
  {
    "raw_code": "def to_session_value # :nodoc:\n        flashes_to_keep = @flashes.except(*@discard)\n        return nil if flashes_to_keep.empty?\n        { \"discard\" => [], \"flashes\" => flashes_to_keep }\n      end",
    "comment": "Builds a hash containing the flashes to keep for the next request. If there are none to keep, returns `nil`.",
    "label": "",
    "id": "500"
  },
  {
    "raw_code": "def delete(key)\n        key = key.to_s\n        @discard.delete key\n        @flashes.delete key\n        self\n      end",
    "comment": "Immediately deletes the single flash entry. Use this method when you want remove the message within the current action. See also #discard.",
    "label": "",
    "id": "501"
  },
  {
    "raw_code": "def now\n        @now ||= FlashNow.new(self)\n      end",
    "comment": "Sets a flash that will not be available to the next action, only to the current.  flash.now[:message] = \"Hello current action\"  This method enables you to use the flash as a central messaging system in your app. When you need to pass an object to the next action, you use the standard flash assign (`[]=`). When you need to pass an object to the current action, you use `now`, and your object will vanish when the current action is done.  Entries set via `now` are accessed the same way as standard entries: `flash['my-key']`.  Also, brings two convenience accessors:  flash.now.alert = \"Beware now!\" # Equivalent to flash.now[:alert] = \"Beware now!\"  flash.now.notice = \"Good luck now!\" # Equivalent to flash.now[:notice] = \"Good luck now!\"",
    "label": "",
    "id": "502"
  },
  {
    "raw_code": "def keep(k = nil)\n        k = k.to_s if k\n        @discard.subtract Array(k || keys)\n        k ? self[k] : self\n      end",
    "comment": "Keeps either the entire current flash or a specific flash entry available for the next action:  flash.keep            # keeps the entire flash flash.keep(:notice)   # keeps only the \"notice\" entry, the rest of the flash is discarded",
    "label": "",
    "id": "503"
  },
  {
    "raw_code": "def discard(k = nil)\n        k = k.to_s if k\n        @discard.merge Array(k || keys)\n        k ? self[k] : self\n      end",
    "comment": "Marks the entire flash or a single flash entry to be discarded by the end of the current action:  flash.discard              # discard the entire flash at the end of the current action flash.discard(:warning)    # discard only the \"warning\" entry at the end of the current action  Use this method when you want to display the message in the current action but not in the next one. See also #delete.",
    "label": "",
    "id": "504"
  },
  {
    "raw_code": "def sweep # :nodoc:\n        @discard.each { |k| @flashes.delete k }\n        @discard.replace @flashes.keys\n      end",
    "comment": "Mark for removal entries that were kept, and delete unkept ones.  This method is called automatically by filters, so you generally don't need to care about it.",
    "label": "",
    "id": "505"
  },
  {
    "raw_code": "def alert\n        self[:alert]\n      end",
    "comment": "Convenience accessor for `flash[:alert]`.",
    "label": "",
    "id": "506"
  },
  {
    "raw_code": "def alert=(message)\n        self[:alert] = message\n      end",
    "comment": "Convenience accessor for `flash[:alert]=`.",
    "label": "",
    "id": "507"
  },
  {
    "raw_code": "def notice\n        self[:notice]\n      end",
    "comment": "Convenience accessor for `flash[:notice]`.",
    "label": "",
    "id": "508"
  },
  {
    "raw_code": "def notice=(message)\n        self[:notice] = message\n      end",
    "comment": "Convenience accessor for `flash[:notice]=`.",
    "label": "",
    "id": "509"
  },
  {
    "raw_code": "def initialize(app, ip_spoofing_check = true, custom_proxies = nil)\n      @app = app\n      @check_ip = ip_spoofing_check\n      @proxies = if custom_proxies.blank?\n        TRUSTED_PROXIES\n      elsif custom_proxies.respond_to?(:any?)\n        custom_proxies\n      else\n        raise(ArgumentError, <<~EOM)\n          Setting config.action_dispatch.trusted_proxies to a single value isn't\n          supported. Please set this to an enumerable instead. For\n          example, instead of:\n\n          config.action_dispatch.trusted_proxies = IPAddr.new(\"10.0.0.0/8\")\n\n          Wrap the value in an Array:\n\n          config.action_dispatch.trusted_proxies = [IPAddr.new(\"10.0.0.0/8\")]\n\n          Note that passing an enumerable will *replace* the default set of trusted proxies.\n        EOM\n      end",
    "comment": "Create a new `RemoteIp` middleware instance.  The `ip_spoofing_check` option is on by default. When on, an exception is raised if it looks like the client is trying to lie about its own IP address. It makes sense to turn off this check on sites aimed at non-IP clients (like WAP devices), or behind proxies that set headers in an incorrect or confusing way (like AWS ELB).  The `custom_proxies` argument can take an enumerable which will be used instead of `TRUSTED_PROXIES`. Any proxy setup will put the value you want in the middle (or at the beginning) of the `X-Forwarded-For` list, with your proxy servers after it. If your proxies aren't removed, pass them in via the `custom_proxies` parameter. That way, the middleware will ignore those IP addresses, and return the one that you want.",
    "label": "",
    "id": "510"
  },
  {
    "raw_code": "def call(env)\n      req = ActionDispatch::Request.new env\n      req.remote_ip = GetIp.new(req, check_ip, proxies)\n      @app.call(req.env)\n    end",
    "comment": "Since the IP address may not be needed, we store the object here without calculating the IP to keep from slowing down the majority of requests. For those requests that do need to know the IP, the GetIp#calculate_ip method will calculate the memoized client IP address.",
    "label": "",
    "id": "511"
  },
  {
    "raw_code": "def calculate_ip\n        # Set by the Rack web server, this is a single value.\n        remote_addr = ips_from(@req.remote_addr).last\n\n        # Could be a CSV list and/or repeated headers that were concatenated.\n        client_ips    = ips_from(@req.client_ip).reverse!\n        forwarded_ips = ips_from(@req.x_forwarded_for).reverse!\n\n        # `Client-Ip` and `X-Forwarded-For` should not, generally, both be set. If they\n        # are both set, it means that either:\n        #\n        # 1) This request passed through two proxies with incompatible IP header\n        #     conventions.\n        #\n        # 2) The client passed one of `Client-Ip` or `X-Forwarded-For`\n        #     (whichever the proxy servers weren't using) themselves.\n        #\n        # Either way, there is no way for us to determine which header is the right one\n        # after the fact. Since we have no idea, if we are concerned about IP spoofing\n        # we need to give up and explode. (If you're not concerned about IP spoofing you\n        # can turn the `ip_spoofing_check` option off.)\n        should_check_ip = @check_ip && client_ips.last && forwarded_ips.last\n        if should_check_ip && !forwarded_ips.include?(client_ips.last)\n          # We don't know which came from the proxy, and which from the user\n          raise IpSpoofAttackError, \"IP spoofing attack?! \" \\\n            \"HTTP_CLIENT_IP=#{@req.client_ip.inspect} \" \\\n            \"HTTP_X_FORWARDED_FOR=#{@req.x_forwarded_for.inspect}\"\n        end",
    "comment": "Sort through the various IP address headers, looking for the IP most likely to be the address of the actual remote client making this request.  REMOTE_ADDR will be correct if the request is made directly against the Ruby process, on e.g. Heroku. When the request is proxied by another server like HAProxy or NGINX, the IP address that made the original request will be put in an `X-Forwarded-For` header. If there are multiple proxies, that header may contain a list of IPs. Other proxy services set the `Client-Ip` header instead, so we check that too.  As discussed in [this post about Rails IP Spoofing](https://web.archive.org/web/20170626095448/https://blog.gingerlime.com/2012/rails-ip-spoofing-vulnerabilities-and-protection/), while the first IP in the list is likely to be the \"originating\" IP, it could also have been set by the client maliciously.  In order to find the first address that is (probably) accurate, we take the list of IPs, remove known and trusted proxies, and then take the last address left, which was presumably set by one of those proxies.",
    "label": "",
    "id": "512"
  },
  {
    "raw_code": "def to_s\n        @ip ||= calculate_ip\n      end",
    "comment": "Memoizes the value returned by #calculate_ip and returns it for ActionDispatch::Request to use.",
    "label": "",
    "id": "513"
  },
  {
    "raw_code": "def build_hsts_header(hsts)\n        value = +\"max-age=#{hsts[:expires].to_i}\"\n        value << \"; includeSubDomains\" if hsts[:subdomains]\n        value << \"; preload\" if hsts[:preload]\n        value\n      end",
    "comment": "https://tools.ietf.org/html/rfc6797#section-6.1",
    "label": "",
    "id": "514"
  },
  {
    "raw_code": "def delete(target)\n      middlewares.reject! { |m| m.name == target.name }\n    end",
    "comment": "Deletes a middleware from the middleware stack.  Returns the array of middlewares not including the deleted item, or returns nil if the target is not found.",
    "label": "",
    "id": "515"
  },
  {
    "raw_code": "def delete!(target)\n      delete(target) || (raise \"No such middleware to remove: #{target.inspect}\")\n    end",
    "comment": "Deletes a middleware from the middleware stack.  Returns the array of middlewares not including the deleted item, or raises `RuntimeError` if the target is not found.",
    "label": "",
    "id": "516"
  },
  {
    "raw_code": "def find_file(path_info, accept_encoding:)\n        each_candidate_filepath(path_info) do |filepath, content_type|\n          if response = try_files(filepath, content_type, accept_encoding: accept_encoding)\n            return response\n          end",
    "comment": "Match a URI path to a static file to be served.  Used by the `Static` class to negotiate a servable file in the `public/` directory (see Static#call).  Checks for `path`, `path`.html, and `path`/index.html files, in that order, including .br and .gzip compressed extensions.  If a matching file is found, the path and necessary response headers (Content-Type, Content-Encoding) are returned.",
    "label": "",
    "id": "517"
  },
  {
    "raw_code": "def find_session(env, sid)\n        unless sid && (session = get_session_with_fallback(sid))\n          sid, session = generate_sid, {}\n        end",
    "comment": "Get a session from the cache.",
    "label": "",
    "id": "518"
  },
  {
    "raw_code": "def write_session(env, sid, session, options)\n        key = cache_key(sid.private_id)\n        if session\n          @cache.write(key, session, expires_in: options[:expire_after])\n        else\n          @cache.delete(key)\n        end",
    "comment": "Set a session in the cache.",
    "label": "",
    "id": "519"
  },
  {
    "raw_code": "def delete_session(env, sid, options)\n        @cache.delete(cache_key(sid.private_id))\n        @cache.delete(cache_key(sid.public_id))\n        generate_sid\n      end",
    "comment": "Remove a session from the cache.",
    "label": "",
    "id": "520"
  },
  {
    "raw_code": "def cache_key(id)\n          \"_session_id:#{id}\"\n        end",
    "comment": "Turn the session id into a cache key.",
    "label": "",
    "id": "521"
  },
  {
    "raw_code": "def self.create(store, req, default_options)\n        session_was = find req\n        session     = Request::Session.new(store, req)\n        session.merge! session_was if session_was\n\n        set(req, session)\n        Options.set(req, Request::Session::Options.new(store, default_options))\n        session\n      end",
    "comment": "Creates a session hash, merging the properties of the previous session if any.",
    "label": "",
    "id": "522"
  },
  {
    "raw_code": "def dig(*keys)\n        load_for_read!\n        keys = keys.map.with_index { |key, i| i.zero? ? key.to_s : key }\n        @delegate.dig(*keys)\n      end",
    "comment": "Returns the nested value specified by the sequence of keys, returning `nil` if any intermediate step is `nil`.",
    "label": "",
    "id": "523"
  },
  {
    "raw_code": "def has_key?(key)\n        load_for_read!\n        @delegate.key?(key.to_s)\n      end",
    "comment": "Returns true if the session has the given key or false.",
    "label": "",
    "id": "524"
  },
  {
    "raw_code": "def keys\n        load_for_read!\n        @delegate.keys\n      end",
    "comment": "Returns keys of the session as Array.",
    "label": "",
    "id": "525"
  },
  {
    "raw_code": "def values\n        load_for_read!\n        @delegate.values\n      end",
    "comment": "Returns values of the session as Array.",
    "label": "",
    "id": "526"
  },
  {
    "raw_code": "def []=(key, value)\n        load_for_write!\n        @delegate[key.to_s] = value\n      end",
    "comment": "Writes given value to given key of the session.",
    "label": "",
    "id": "527"
  },
  {
    "raw_code": "def clear\n        load_for_delete!\n        @delegate.clear\n      end",
    "comment": "Clears the session.",
    "label": "",
    "id": "528"
  },
  {
    "raw_code": "def to_hash\n        load_for_read!\n        @delegate.dup.delete_if { |_, v| v.nil? }\n      end",
    "comment": "Returns the session as Hash.",
    "label": "",
    "id": "529"
  },
  {
    "raw_code": "def update(hash)\n        unless hash.respond_to?(:to_hash)\n          raise TypeError, \"no implicit conversion of #{hash.class.name} into Hash\"\n        end",
    "comment": "Updates the session with given Hash.  session.to_hash # => {\"session_id\"=>\"e29b9ea315edf98aad94cc78c34cc9b2\"}  session.update({ \"foo\" => \"bar\" }) # => {\"session_id\"=>\"e29b9ea315edf98aad94cc78c34cc9b2\", \"foo\" => \"bar\"}  session.to_hash # => {\"session_id\"=>\"e29b9ea315edf98aad94cc78c34cc9b2\", \"foo\" => \"bar\"}",
    "label": "",
    "id": "530"
  },
  {
    "raw_code": "def delete(key)\n        load_for_delete!\n        @delegate.delete key.to_s\n      end",
    "comment": "Deletes given key from the session.",
    "label": "",
    "id": "531"
  },
  {
    "raw_code": "def fetch(key, default = Unspecified, &block)\n        load_for_read!\n        if default == Unspecified\n          @delegate.fetch(key.to_s, &block)\n        else\n          @delegate.fetch(key.to_s, default, &block)\n        end",
    "comment": "Returns value of the given key from the session, or raises `KeyError` if can't find the given key and no default value is set. Returns default value if specified.  session.fetch(:foo) # => KeyError: key not found: \"foo\"  session.fetch(:foo, :bar) # => :bar  session.fetch(:foo) do :bar end # => :bar",
    "label": "",
    "id": "532"
  },
  {
    "raw_code": "def self.normalize_encode_params(params)\n          case params\n          when Array\n            handle_array params\n          when Hash\n            if params.has_key?(:tempfile)\n              ActionDispatch::Http::UploadedFile.new(params)\n            else\n              hwia = ActiveSupport::HashWithIndifferentAccess.new\n              params.each_pair do |key, val|\n                hwia[key] = normalize_encode_params(val)\n              end",
    "comment": "Convert nested Hash to HashWithIndifferentAccess.",
    "label": "",
    "id": "533"
  },
  {
    "raw_code": "def header(routes)\n      end",
    "comment": "The header is part of the HTML page, so we don't construct it here.",
    "label": "",
    "id": "534"
  },
  {
    "raw_code": "def self.normalize_path(path)\n        path = Journey::Router::Utils.normalize_path(path)\n\n        # the path for a root URL at this point can be something like\n        # \"/(/:locale)(/:platform)/(:browser)\", and we would want\n        # \"/(:locale)(/:platform)(/:browser)\" reverse \"/(\", \"/((\" etc to \"(/\", \"((/\" etc\n        path.gsub!(%r{/(\\(+)/?}, '\\1/')\n        # if a path is all optional segments, change the leading \"(/\" back to \"/(\" so it\n        # evaluates to \"/\" when interpreted with no options. Unless, however, at least\n        # one secondary segment consists of a static part, ex.\n        # \"(/:locale)(/pages/:page)\"\n        path.sub!(%r{^(\\(+)/}, '/\\1') if %r{^(\\(+[^)]+\\))(\\(+/:[^)]+\\))*$}.match?(path)\n        path\n      end",
    "comment": "Invokes Journey::Router::Utils.normalize_path, then ensures that /(:locale) becomes (/:locale). Except for root cases, where the former is the correct one.",
    "label": "",
    "id": "535"
  },
  {
    "raw_code": "def match(path, options = nil)\n        end",
    "comment": "Matches a URL pattern to one or more routes.  You should not use the `match` method in your router without specifying an HTTP method.  If you want to expose your action to both GET and POST, use:  # sets :controller, :action, and :id in params match ':controller/:action/:id', via: [:get, :post]  Note that `:controller`, `:action`, and `:id` are interpreted as URL query parameters and thus available through `params` in an action.  If you want to expose your action to GET, use `get` in the router:  Instead of:  match \":controller/:action/:id\"  Do:  get \":controller/:action/:id\"  Two of these symbols are special, `:controller` maps to the controller and `:action` to the controller's action. A pattern can also map wildcard segments (globs) to params:  get 'songs/*category/:title', to: 'songs#show'  # 'songs/rock/classic/stairway-to-heaven' sets #  params[:category] = 'rock/classic' #  params[:title] = 'stairway-to-heaven'  To match a wildcard parameter, it must have a name assigned to it. Without a variable name to attach the glob parameter to, the route can't be parsed.  When a pattern points to an internal route, the route's `:action` and `:controller` should be set in options or hash shorthand. Examples:  match 'photos/:id', to: 'photos#show', via: :get match 'photos/:id', controller: 'photos', action: 'show', via: :get  A pattern can also point to a `Rack` endpoint i.e. anything that responds to `call`:  match 'photos/:id', to: -> (hash) { [200, {}, [\"Coming soon\"]] }, via: :get match 'photos/:id', to: PhotoRackApp, via: :get # Yes, controller actions are just rack endpoints match 'photos/:id', to: PhotosController.action(:show), via: :get  Because requesting various HTTP verbs with a single action has security implications, you must either specify the actions in the via options or use one of the [HttpHelpers](rdoc-ref:HttpHelpers) instead `match`  ### Options  Any options not seen here are passed on as params with the URL.  :controller :   The route's controller.  :action :   The route's action.  :param :   Overrides the default resource identifier `:id` (name of the dynamic segment used to generate the routes). You can access that segment from your controller using `params[<:param>]`. In your router:  resources :users, param: :name  The `users` resource here will have the following routes generated for it:  GET       /users(.:format) POST      /users(.:format) GET       /users/new(.:format) GET       /users/:name/edit(.:format) GET       /users/:name(.:format) PATCH/PUT /users/:name(.:format) DELETE    /users/:name(.:format)  You can override `ActiveRecord::Base#to_param` of a related model to construct a URL:  class User < ActiveRecord::Base def to_param name end end  user = User.find_by(name: 'Phusion') user_path(user)  # => \"/users/Phusion\"  :path :   The path prefix for the routes.  :module :   The namespace for :controller.  match 'path', to: 'c#a', module: 'sekret', controller: 'posts', via: :get # => Sekret::PostsController  See `Scoping#namespace` for its scope equivalent.  :as :   The name used to generate routing helpers.  :via :   Allowed HTTP verb(s) for route.  match 'path', to: 'c#a', via: :get match 'path', to: 'c#a', via: [:get, :post] match 'path', to: 'c#a', via: :all  :to :   Points to a `Rack` endpoint. Can be an object that responds to `call` or a string representing a controller's action.  match 'path', to: 'controller#action', via: :get match 'path', to: -> (env) { [200, {}, [\"Success!\"]] }, via: :get match 'path', to: RackApp, via: :get  :on :   Shorthand for wrapping routes in a specific RESTful context. Valid values are `:member`, `:collection`, and `:new`. Only use within `resource(s)` block. For example:  resource :bar do match 'foo', to: 'c#a', on: :member, via: [:get, :post] end  Is equivalent to:  resource :bar do member do match 'foo', to: 'c#a', via: [:get, :post] end end  :constraints :   Constrains parameters with a hash of regular expressions or an object that responds to `matches?`. In addition, constraints other than path can also be specified with any object that responds to `===` (e.g. String, Array, Range, etc.).  match 'path/:id', constraints: { id: /[A-Z]\\d{5}/ }, via: :get  match 'json_only', constraints: { format: 'json' }, via: :get  class PermitList def matches?(request) request.remote_ip == '1.2.3.4' end end match 'path', to: 'c#a', constraints: PermitList.new, via: :get  See `Scoping#constraints` for more examples with its scope equivalent.  :defaults :   Sets defaults for parameters  # Sets params[:format] to 'jpg' by default match 'path', to: 'c#a', defaults: { format: 'jpg' }, via: :get  See `Scoping#defaults` for its scope equivalent.  :anchor :   Boolean to anchor a `match` pattern. Default is true. When set to false, the pattern matches any request prefixed with the given path.  # Matches any request starting with 'path' match 'path', to: 'c#a', anchor: false, via: :get  :format :   Allows you to specify the default value for optional `format` segment or disable it by supplying `false`. ",
    "label": "",
    "id": "536"
  },
  {
    "raw_code": "def mount(app = nil, deprecated_options = nil, as: DEFAULT, via: nil, at: nil, defaults: nil, constraints: nil, anchor: false, format: false, path: nil, internal: nil, **mapping, &block)\n          if deprecated_options.is_a?(Hash)\n            as = assign_deprecated_option(deprecated_options, :as, :mount) if deprecated_options.key?(:as)\n            via ||= assign_deprecated_option(deprecated_options, :via, :mount)\n            at ||= assign_deprecated_option(deprecated_options, :at, :mount)\n            defaults ||= assign_deprecated_option(deprecated_options, :defaults, :mount)\n            constraints ||= assign_deprecated_option(deprecated_options, :constraints, :mount)\n            anchor = assign_deprecated_option(deprecated_options, :anchor, :mount) if deprecated_options.key?(:anchor)\n            format = assign_deprecated_option(deprecated_options, :format, :mount) if deprecated_options.key?(:format)\n            path ||= assign_deprecated_option(deprecated_options, :path, :mount)\n            internal ||= assign_deprecated_option(deprecated_options, :internal, :mount)\n            assign_deprecated_options(deprecated_options, mapping, :mount)\n          end",
    "comment": "Mount a Rack-based application to be used within the application.  mount SomeRackApp, at: \"some_route\"  For options, see `match`, as `mount` uses it internally.  All mounted applications come with routing helpers to access them. These are named after the class specified, so for the above example the helper is either `some_rack_app_path` or `some_rack_app_url`. To customize this helper's name, use the `:as` option:  mount(SomeRackApp, at: \"some_route\", as: \"exciting\")  This will generate the `exciting_path` and `exciting_url` helpers which can be used to navigate to this mounted app.",
    "label": "",
    "id": "537"
  },
  {
    "raw_code": "def has_named_route?(name)\n          @set.named_routes.key?(name)\n        end",
    "comment": "Query if the following named route was already defined.",
    "label": "",
    "id": "538"
  },
  {
    "raw_code": "def get(*path_or_actions, as: DEFAULT, to: nil, controller: nil, action: nil, on: nil, defaults: nil, constraints: nil, anchor: nil, format: nil, path: nil, internal: nil, **mapping, &block)\n          if path_or_actions.grep(Hash).any? && (deprecated_options = path_or_actions.extract_options!)\n            as = assign_deprecated_option(deprecated_options, :as, :get) if deprecated_options.key?(:as)\n            to ||= assign_deprecated_option(deprecated_options, :to, :get)\n            controller ||= assign_deprecated_option(deprecated_options, :controller, :get)\n            action ||= assign_deprecated_option(deprecated_options, :action, :get)\n            on ||= assign_deprecated_option(deprecated_options, :on, :get)\n            defaults ||= assign_deprecated_option(deprecated_options, :defaults, :get)\n            constraints ||= assign_deprecated_option(deprecated_options, :constraints, :get)\n            anchor = assign_deprecated_option(deprecated_options, :anchor, :get) if deprecated_options.key?(:anchor)\n            format = assign_deprecated_option(deprecated_options, :format, :get) if deprecated_options.key?(:format)\n            path ||= assign_deprecated_option(deprecated_options, :path, :get)\n            internal ||= assign_deprecated_option(deprecated_options, :internal, :get)\n            assign_deprecated_options(deprecated_options, mapping, :get)\n          end",
    "comment": "Define a route that only recognizes HTTP GET. For supported arguments, see [match](rdoc-ref:Base#match)  get 'bacon', to: 'food#bacon'",
    "label": "",
    "id": "539"
  },
  {
    "raw_code": "def post(*path_or_actions, as: DEFAULT, to: nil, controller: nil, action: nil, on: nil, defaults: nil, constraints: nil, anchor: nil, format: nil, path: nil, internal: nil, **mapping, &block)\n          if path_or_actions.grep(Hash).any? && (deprecated_options = path_or_actions.extract_options!)\n            as = assign_deprecated_option(deprecated_options, :as, :post) if deprecated_options.key?(:as)\n            to ||= assign_deprecated_option(deprecated_options, :to, :post)\n            controller ||= assign_deprecated_option(deprecated_options, :controller, :post)\n            action ||= assign_deprecated_option(deprecated_options, :action, :post)\n            on ||= assign_deprecated_option(deprecated_options, :on, :post)\n            defaults ||= assign_deprecated_option(deprecated_options, :defaults, :post)\n            constraints ||= assign_deprecated_option(deprecated_options, :constraints, :post)\n            anchor = assign_deprecated_option(deprecated_options, :anchor, :post) if deprecated_options.key?(:anchor)\n            format = assign_deprecated_option(deprecated_options, :format, :post) if deprecated_options.key?(:format)\n            path ||= assign_deprecated_option(deprecated_options, :path, :post)\n            internal ||= assign_deprecated_option(deprecated_options, :internal, :post)\n            assign_deprecated_options(deprecated_options, mapping, :post)\n          end",
    "comment": "Define a route that only recognizes HTTP POST. For supported arguments, see [match](rdoc-ref:Base#match)  post 'bacon', to: 'food#bacon'",
    "label": "",
    "id": "540"
  },
  {
    "raw_code": "def patch(*path_or_actions, as: DEFAULT, to: nil, controller: nil, action: nil, on: nil, defaults: nil, constraints: nil, anchor: nil, format: nil, path: nil, internal: nil, **mapping, &block)\n          if path_or_actions.grep(Hash).any? && (deprecated_options = path_or_actions.extract_options!)\n            as = assign_deprecated_option(deprecated_options, :as, :patch) if deprecated_options.key?(:as)\n            to ||= assign_deprecated_option(deprecated_options, :to, :patch)\n            controller ||= assign_deprecated_option(deprecated_options, :controller, :patch)\n            action ||= assign_deprecated_option(deprecated_options, :action, :patch)\n            on ||= assign_deprecated_option(deprecated_options, :on, :patch)\n            defaults ||= assign_deprecated_option(deprecated_options, :defaults, :patch)\n            constraints ||= assign_deprecated_option(deprecated_options, :constraints, :patch)\n            anchor = assign_deprecated_option(deprecated_options, :anchor, :patch) if deprecated_options.key?(:anchor)\n            format = assign_deprecated_option(deprecated_options, :format, :patch) if deprecated_options.key?(:format)\n            path ||= assign_deprecated_option(deprecated_options, :path, :patch)\n            internal ||= assign_deprecated_option(deprecated_options, :internal, :patch)\n            assign_deprecated_options(deprecated_options, mapping, :patch)\n          end",
    "comment": "Define a route that only recognizes HTTP PATCH. For supported arguments, see [match](rdoc-ref:Base#match)  patch 'bacon', to: 'food#bacon'",
    "label": "",
    "id": "541"
  },
  {
    "raw_code": "def put(*path_or_actions, as: DEFAULT, to: nil, controller: nil, action: nil, on: nil, defaults: nil, constraints: nil, anchor: nil, format: nil, path: nil, internal: nil, **mapping, &block)\n          if path_or_actions.grep(Hash).any? && (deprecated_options = path_or_actions.extract_options!)\n            as = assign_deprecated_option(deprecated_options, :as, :put) if deprecated_options.key?(:as)\n            to ||= assign_deprecated_option(deprecated_options, :to, :put)\n            controller ||= assign_deprecated_option(deprecated_options, :controller, :put)\n            action ||= assign_deprecated_option(deprecated_options, :action, :put)\n            on ||= assign_deprecated_option(deprecated_options, :on, :put)\n            defaults ||= assign_deprecated_option(deprecated_options, :defaults, :put)\n            constraints ||= assign_deprecated_option(deprecated_options, :constraints, :put)\n            anchor = assign_deprecated_option(deprecated_options, :anchor, :put) if deprecated_options.key?(:anchor)\n            format = assign_deprecated_option(deprecated_options, :format, :put) if deprecated_options.key?(:format)\n            path ||= assign_deprecated_option(deprecated_options, :path, :put)\n            internal ||= assign_deprecated_option(deprecated_options, :internal, :put)\n            assign_deprecated_options(deprecated_options, mapping, :put)\n          end",
    "comment": "Define a route that only recognizes HTTP PUT. For supported arguments, see [match](rdoc-ref:Base#match)  put 'bacon', to: 'food#bacon'",
    "label": "",
    "id": "542"
  },
  {
    "raw_code": "def delete(*path_or_actions, as: DEFAULT, to: nil, controller: nil, action: nil, on: nil, defaults: nil, constraints: nil, anchor: nil, format: nil, path: nil, internal: nil, **mapping, &block)\n          if path_or_actions.grep(Hash).any? && (deprecated_options = path_or_actions.extract_options!)\n            as = assign_deprecated_option(deprecated_options, :as, :delete) if deprecated_options.key?(:as)\n            to ||= assign_deprecated_option(deprecated_options, :to, :delete)\n            controller ||= assign_deprecated_option(deprecated_options, :controller, :delete)\n            action ||= assign_deprecated_option(deprecated_options, :action, :delete)\n            on ||= assign_deprecated_option(deprecated_options, :on, :delete)\n            defaults ||= assign_deprecated_option(deprecated_options, :defaults, :delete)\n            constraints ||= assign_deprecated_option(deprecated_options, :constraints, :delete)\n            anchor = assign_deprecated_option(deprecated_options, :anchor, :delete) if deprecated_options.key?(:anchor)\n            format = assign_deprecated_option(deprecated_options, :format, :delete) if deprecated_options.key?(:format)\n            path ||= assign_deprecated_option(deprecated_options, :path, :delete)\n            internal ||= assign_deprecated_option(deprecated_options, :internal, :delete)\n            assign_deprecated_options(deprecated_options, mapping, :delete)\n          end",
    "comment": "Define a route that only recognizes HTTP DELETE. For supported arguments, see [match](rdoc-ref:Base#match)  delete 'broccoli', to: 'food#broccoli'",
    "label": "",
    "id": "543"
  },
  {
    "raw_code": "def options(*path_or_actions, as: DEFAULT, to: nil, controller: nil, action: nil, on: nil, defaults: nil, constraints: nil, anchor: false, format: false, path: nil, internal: nil, **mapping, &block)\n          if path_or_actions.grep(Hash).any? && (deprecated_options = path_or_actions.extract_options!)\n            as = assign_deprecated_option(deprecated_options, :as, :options) if deprecated_options.key?(:as)\n            to ||= assign_deprecated_option(deprecated_options, :to, :options)\n            controller ||= assign_deprecated_option(deprecated_options, :controller, :options)\n            action ||= assign_deprecated_option(deprecated_options, :action, :options)\n            on ||= assign_deprecated_option(deprecated_options, :on, :options)\n            defaults ||= assign_deprecated_option(deprecated_options, :defaults, :options)\n            constraints ||= assign_deprecated_option(deprecated_options, :constraints, :options)\n            anchor = assign_deprecated_option(deprecated_options, :anchor, :options) if deprecated_options.key?(:anchor)\n            format = assign_deprecated_option(deprecated_options, :format, :options) if deprecated_options.key?(:format)\n            path ||= assign_deprecated_option(deprecated_options, :path, :options)\n            internal ||= assign_deprecated_option(deprecated_options, :internal, :options)\n            assign_deprecated_options(deprecated_options, mapping, :options)\n          end",
    "comment": "Define a route that only recognizes HTTP OPTIONS. For supported arguments, see [match](rdoc-ref:Base#match)  options 'carrots', to: 'food#carrots'",
    "label": "",
    "id": "544"
  },
  {
    "raw_code": "def connect(*path_or_actions, as: DEFAULT, to: nil, controller: nil, action: nil, on: nil, defaults: nil, constraints: nil, anchor: false, format: false, path: nil, internal: nil, **mapping, &block)\n          if path_or_actions.grep(Hash).any? && (deprecated_options = path_or_actions.extract_options!)\n            as = assign_deprecated_option(deprecated_options, :as, :connect) if deprecated_options.key?(:as)\n            to ||= assign_deprecated_option(deprecated_options, :to, :connect)\n            controller ||= assign_deprecated_option(deprecated_options, :controller, :connect)\n            action ||= assign_deprecated_option(deprecated_options, :action, :connect)\n            on ||= assign_deprecated_option(deprecated_options, :on, :connect)\n            defaults ||= assign_deprecated_option(deprecated_options, :defaults, :connect)\n            constraints ||= assign_deprecated_option(deprecated_options, :constraints, :connect)\n            anchor = assign_deprecated_option(deprecated_options, :anchor, :connect) if deprecated_options.key?(:anchor)\n            format = assign_deprecated_option(deprecated_options, :format, :connect) if deprecated_options.key?(:format)\n            path ||= assign_deprecated_option(deprecated_options, :path, :connect)\n            internal ||= assign_deprecated_option(deprecated_options, :internal, :connect)\n            assign_deprecated_options(deprecated_options, mapping, :connect)\n          end",
    "comment": "Define a route that recognizes HTTP CONNECT (and GET) requests. More specifically this recognizes HTTP/1 protocol upgrade requests and HTTP/2 CONNECT requests with the protocol pseudo header. For supported arguments, see [match](rdoc-ref:Base#match)  connect 'live', to: 'live#index'",
    "label": "",
    "id": "545"
  },
  {
    "raw_code": "def scope(*args, only: nil, except: nil, **options)\n          if args.grep(Hash).any? && (deprecated_options = args.extract_options!)\n            only ||= assign_deprecated_option(deprecated_options, :only, :scope)\n            only ||= assign_deprecated_option(deprecated_options, :except, :scope)\n            assign_deprecated_options(deprecated_options, options, :scope)\n          end",
    "comment": "Scopes a set of routes to the given default options.  Take the following route definition as an example:  scope path: \":account_id\", as: \"account\" do resources :projects end  This generates helpers such as `account_projects_path`, just like `resources` does. The difference here being that the routes generated are like /:account_id/projects, rather than /accounts/:account_id/projects.  ### Options  Takes same options as `Base#match` and `Resources#resources`.  # route /posts (without the prefix /admin) to Admin::PostsController scope module: \"admin\" do resources :posts end  # prefix the posts resource's requests with '/admin' scope path: \"/admin\" do resources :posts end  # prefix the routing helper name: sekret_posts_path instead of posts_path scope as: \"sekret\" do resources :posts end",
    "label": "",
    "id": "546"
  },
  {
    "raw_code": "def controller(controller)\n          @scope = @scope.new(controller: controller)\n          yield\n        ensure\n          @scope = @scope.parent\n        end",
    "comment": "Scopes routes to a specific controller  controller \"food\" do match \"bacon\", action: :bacon, via: :get end",
    "label": "",
    "id": "547"
  },
  {
    "raw_code": "def namespace(name, deprecated_options = nil, as: DEFAULT, path: DEFAULT, shallow_path: DEFAULT, shallow_prefix: DEFAULT, **options, &block)\n          if deprecated_options.is_a?(Hash)\n            as = assign_deprecated_option(deprecated_options, :as, :namespace) if deprecated_options.key?(:as)\n            path ||= assign_deprecated_option(deprecated_options, :path, :namespace)  if deprecated_options.key?(:path)\n            shallow_path ||= assign_deprecated_option(deprecated_options, :shallow_path, :namespace) if deprecated_options.key?(:shallow_path)\n            shallow_prefix ||= assign_deprecated_option(deprecated_options, :shallow_prefix, :namespace)  if deprecated_options.key?(:shallow_prefix)\n            assign_deprecated_options(deprecated_options, options, :namespace)\n          end",
    "comment": "Scopes routes to a specific namespace. For example:  namespace :admin do resources :posts end  This generates the following routes:  admin_posts GET       /admin/posts(.:format)          admin/posts#index admin_posts POST      /admin/posts(.:format)          admin/posts#create new_admin_post GET       /admin/posts/new(.:format)      admin/posts#new edit_admin_post GET       /admin/posts/:id/edit(.:format) admin/posts#edit admin_post GET       /admin/posts/:id(.:format)      admin/posts#show admin_post PATCH/PUT /admin/posts/:id(.:format)      admin/posts#update admin_post DELETE    /admin/posts/:id(.:format)      admin/posts#destroy  ### Options  The `:path`, `:as`, `:module`, `:shallow_path`, and `:shallow_prefix` options all default to the name of the namespace.  For options, see `Base#match`. For `:shallow_path` option, see `Resources#resources`.  # accessible through /sekret/posts rather than /admin/posts namespace :admin, path: \"sekret\" do resources :posts end  # maps to Sekret::PostsController rather than Admin::PostsController namespace :admin, module: \"sekret\" do resources :posts end  # generates sekret_posts_path rather than admin_posts_path namespace :admin, as: \"sekret\" do resources :posts end",
    "label": "",
    "id": "548"
  },
  {
    "raw_code": "def constraints(constraints = {}, &block)\n          scope(constraints: constraints, &block)\n        end",
    "comment": "### Parameter Restriction Allows you to constrain the nested routes based on a set of rules. For instance, in order to change the routes to allow for a dot character in the `id` parameter:  constraints(id: /\\d+\\.\\d+/) do resources :posts end  Now routes such as `/posts/1` will no longer be valid, but `/posts/1.1` will be. The `id` parameter must match the constraint passed in for this example.  You may use this to also restrict other parameters:  resources :posts do constraints(post_id: /\\d+\\.\\d+/) do resources :comments end end  ### Restricting based on IP  Routes can also be constrained to an IP or a certain range of IP addresses:  constraints(ip: /192\\.168\\.\\d+\\.\\d+/) do resources :posts end  Any user connecting from the 192.168.* range will be able to see this resource, where as any user connecting outside of this range will be told there is no such route.  ### Dynamic request matching  Requests to routes can be constrained based on specific criteria:  constraints(-> (req) { /iPhone/.match?(req.env[\"HTTP_USER_AGENT\"]) }) do resources :iphones end  You are able to move this logic out into a class if it is too complex for routes. This class must have a `matches?` method defined on it which either returns `true` if the user should be given access to that route, or `false` if the user should not.  class Iphone def self.matches?(request) /iPhone/.match?(request.env[\"HTTP_USER_AGENT\"]) end end  An expected place for this code would be `lib/constraints`.  This class is then used like this:  constraints(Iphone) do resources :iphones end",
    "label": "",
    "id": "549"
  },
  {
    "raw_code": "def defaults(defaults = {})\n          @scope = @scope.new(defaults: merge_defaults_scope(@scope[:defaults], defaults))\n          yield\n        ensure\n          @scope = @scope.parent\n        end",
    "comment": "Allows you to set default parameters for a route, such as this:  defaults id: 'home' do match 'scoped_pages/(:id)', to: 'pages#show' end  Using this, the `:id` parameter here will default to 'home'.",
    "label": "",
    "id": "550"
  },
  {
    "raw_code": "def collection_name\n            singular == plural ? \"#{plural}_index\" : plural\n          end",
    "comment": "Checks for uncountable plurals, and appends \"_index\" if the plural and singular form are the same.",
    "label": "",
    "id": "551"
  },
  {
    "raw_code": "def resource(*resources, concerns: nil, **options, &block)\n          if resources.grep(Hash).any? && (deprecated_options = resources.extract_options!)\n            concerns = assign_deprecated_option(deprecated_options, :concerns, :resource) if deprecated_options.key?(:concerns)\n            assign_deprecated_options(deprecated_options, options, :resource)\n          end",
    "comment": "Sometimes, you have a resource that clients always look up without referencing an ID. A common example, /profile always shows the profile of the currently logged in user. In this case, you can use a singular resource to map /profile (rather than /profile/:id) to the show action:  resource :profile  This creates six different routes in your application, all mapping to the `Profiles` controller (note that the controller is named after the plural):  GET       /profile/new GET       /profile GET       /profile/edit PATCH/PUT /profile DELETE    /profile POST      /profile  If you want instances of a model to work with this resource via record identification (e.g. in `form_with` or `redirect_to`), you will need to call [resolve](rdoc-ref:CustomUrls#resolve):  resource :profile resolve('Profile') { [:profile] }  # Enables this to work with singular routes: form_with(model: @profile) {}  ### Options Takes same options as [resources](rdoc-ref:#resources)",
    "label": "",
    "id": "552"
  },
  {
    "raw_code": "def resources(*resources, concerns: nil, **options, &block)\n          if resources.grep(Hash).any? && (deprecated_options = resources.extract_options!)\n            concerns = assign_deprecated_option(deprecated_options, :concerns, :resources) if deprecated_options.key?(:concerns)\n            assign_deprecated_options(deprecated_options, options, :resources)\n          end",
    "comment": "In Rails, a resourceful route provides a mapping between HTTP verbs and URLs and controller actions. By convention, each action also maps to particular CRUD operations in a database. A single entry in the routing file, such as  resources :photos  creates seven different routes in your application, all mapping to the `Photos` controller:  GET       /photos GET       /photos/new POST      /photos GET       /photos/:id GET       /photos/:id/edit PATCH/PUT /photos/:id DELETE    /photos/:id  Resources can also be nested infinitely by using this block syntax:  resources :photos do resources :comments end  This generates the following comments routes:  GET       /photos/:photo_id/comments GET       /photos/:photo_id/comments/new POST      /photos/:photo_id/comments GET       /photos/:photo_id/comments/:id GET       /photos/:photo_id/comments/:id/edit PATCH/PUT /photos/:photo_id/comments/:id DELETE    /photos/:photo_id/comments/:id  ### Options Takes same options as [match](rdoc-ref:Base#match) as well as:  :path_names :   Allows you to change the segment component of the `edit` and `new` actions. Actions not specified are not changed.  resources :posts, path_names: { new: \"brand_new\" }  The above example will now change /posts/new to /posts/brand_new.  :path :   Allows you to change the path prefix for the resource.  resources :posts, path: 'postings'  The resource and all segments will now route to /postings instead of /posts.  :only :   Only generate routes for the given actions.  resources :cows, only: :show resources :cows, only: [:show, :index]  :except :   Generate all routes except for the given actions.  resources :cows, except: :show resources :cows, except: [:show, :index]  :shallow :   Generates shallow routes for nested resource(s). When placed on a parent resource, generates shallow routes for all nested resources.  resources :posts, shallow: true do resources :comments end  Is the same as:  resources :posts do resources :comments, except: [:show, :edit, :update, :destroy] end resources :comments, only: [:show, :edit, :update, :destroy]  This allows URLs for resources that otherwise would be deeply nested such as a comment on a blog post like `/posts/a-long-permalink/comments/1234` to be shortened to just `/comments/1234`.  Set `shallow: false` on a child resource to ignore a parent's shallow parameter.  :shallow_path :   Prefixes nested shallow routes with the specified path.  scope shallow_path: \"sekret\" do resources :posts do resources :comments, shallow: true end end  The `comments` resource here will have the following routes generated for it:  post_comments    GET       /posts/:post_id/comments(.:format) post_comments    POST      /posts/:post_id/comments(.:format) new_post_comment GET       /posts/:post_id/comments/new(.:format) edit_comment     GET       /sekret/comments/:id/edit(.:format) comment          GET       /sekret/comments/:id(.:format) comment          PATCH/PUT /sekret/comments/:id(.:format) comment          DELETE    /sekret/comments/:id(.:format)  :shallow_prefix :   Prefixes nested shallow route names with specified prefix.  scope shallow_prefix: \"sekret\" do resources :posts do resources :comments, shallow: true end end  The `comments` resource here will have the following routes generated for it:  post_comments           GET       /posts/:post_id/comments(.:format) post_comments           POST      /posts/:post_id/comments(.:format) new_post_comment        GET       /posts/:post_id/comments/new(.:format) edit_sekret_comment     GET       /comments/:id/edit(.:format) sekret_comment          GET       /comments/:id(.:format) sekret_comment          PATCH/PUT /comments/:id(.:format) sekret_comment          DELETE    /comments/:id(.:format)  :format :   Allows you to specify the default value for optional `format` segment or disable it by supplying `false`.  :param :   Allows you to override the default param name of `:id` in the URL.   ### Examples  # routes call Admin::PostsController resources :posts, module: \"admin\"  # resource actions are at /admin/posts. resources :posts, path: \"admin/posts\"",
    "label": "",
    "id": "553"
  },
  {
    "raw_code": "def collection(&block)\n          unless resource_scope?\n            raise ArgumentError, \"can't use collection outside resource(s) scope\"\n          end",
    "comment": "To add a route to the collection:  resources :photos do collection do get 'search' end end  This will enable Rails to recognize paths such as `/photos/search` with GET, and route to the search action of `PhotosController`. It will also create the `search_photos_url` and `search_photos_path` route helpers.",
    "label": "",
    "id": "554"
  },
  {
    "raw_code": "def member(&block)\n          unless resource_scope?\n            raise ArgumentError, \"can't use member outside resource(s) scope\"\n          end",
    "comment": "To add a member route, add a member block into the resource block:  resources :photos do member do get 'preview' end end  This will recognize `/photos/1/preview` with GET, and route to the preview action of `PhotosController`. It will also create the `preview_photo_url` and `preview_photo_path` helpers.",
    "label": "",
    "id": "555"
  },
  {
    "raw_code": "def namespace(name, deprecated_options = nil, as: DEFAULT, path: DEFAULT, shallow_path: DEFAULT, shallow_prefix: DEFAULT, **options, &block)\n          if resource_scope?\n            nested { super }\n          else\n            super\n          end",
    "comment": "See ActionDispatch::Routing::Mapper::Scoping#namespace.",
    "label": "",
    "id": "556"
  },
  {
    "raw_code": "def draw(name)\n          path = @draw_paths.find do |_path|\n            File.exist? \"#{_path}/#{name}.rb\"\n          end",
    "comment": "Loads another routes file with the given `name` located inside the `config/routes` directory. In that file, you can use the normal routing DSL, but *do not* surround it with a `Rails.application.routes.draw` block.  # config/routes.rb Rails.application.routes.draw do draw :admin                 # Loads `config/routes/admin.rb` draw \"third_party/some_gem\" # Loads `config/routes/third_party/some_gem.rb` end  # config/routes/admin.rb namespace :admin do resources :accounts end  # config/routes/third_party/some_gem.rb mount SomeGem::Engine, at: \"/some_gem\"  **CAUTION:** Use this feature with care. Having multiple routes files can negatively impact discoverability and readability. For most applications — even those with a few hundred routes — it's easier for developers to have a single routes file.",
    "label": "",
    "id": "557"
  },
  {
    "raw_code": "def match(*path_or_actions, as: DEFAULT, via: nil, to: nil, controller: nil, action: nil, on: nil, defaults: nil, constraints: nil, anchor: nil, format: nil, path: nil, internal: nil, **mapping, &block)\n          if path_or_actions.grep(Hash).any? && (deprecated_options = path_or_actions.extract_options!)\n            as = assign_deprecated_option(deprecated_options, :as, :match) if deprecated_options.key?(:as)\n            via ||= assign_deprecated_option(deprecated_options, :via, :match)\n            to ||= assign_deprecated_option(deprecated_options, :to, :match)\n            controller ||= assign_deprecated_option(deprecated_options, :controller, :match)\n            action ||= assign_deprecated_option(deprecated_options, :action, :match)\n            on ||= assign_deprecated_option(deprecated_options, :on, :match)\n            defaults ||= assign_deprecated_option(deprecated_options, :defaults, :match)\n            constraints ||= assign_deprecated_option(deprecated_options, :constraints, :match)\n            anchor = assign_deprecated_option(deprecated_options, :anchor, :match) if deprecated_options.key?(:anchor)\n            format = assign_deprecated_option(deprecated_options, :format, :match) if deprecated_options.key?(:format)\n            path ||= assign_deprecated_option(deprecated_options, :path, :match)\n            internal ||= assign_deprecated_option(deprecated_options, :internal, :match)\n            assign_deprecated_options(deprecated_options, mapping, :match)\n          end",
    "comment": "Matches a URL pattern to one or more routes. For more information, see [match](rdoc-ref:Base#match).  match 'path', to: 'controller#action', via: :post match 'otherpath', on: :member, via: :get",
    "label": "",
    "id": "558"
  },
  {
    "raw_code": "def root(path, options = {})\n          if path.is_a?(String)\n            options[:to] = path\n          elsif path.is_a?(Hash) && options.empty?\n            options = path\n          else\n            raise ArgumentError, \"must be called with a path and/or options\"\n          end",
    "comment": "You can specify what Rails should route \"/\" to with the root method:  root to: 'pages#main'  For options, see `match`, as `root` uses it internally.  You can also pass a string which will expand  root 'pages#main'  You should put the root route at the top of `config/routes.rb`, because this means it will be matched first. As this is the most popular route of most Rails applications, this is beneficial.",
    "label": "",
    "id": "559"
  },
  {
    "raw_code": "def concern(name, callable = nil, &block)\n          callable ||= lambda { |mapper, options| mapper.instance_exec(options, &block) }\n          @concerns[name] = callable\n        end",
    "comment": "Define a routing concern using a name.  Concerns may be defined inline, using a block, or handled by another object, by passing that object as the second parameter.  The concern object, if supplied, should respond to `call`, which will receive two parameters:  * The current mapper * A hash of options which the concern object may use  Options may also be used by concerns defined in a block by accepting a block parameter. So, using a block, you might do something as simple as limit the actions available on certain resources, passing standard resource options through the concern:  concern :commentable do |options| resources :comments, options end  resources :posts, concerns: :commentable resources :archived_posts do # Don't allow comments on archived posts concerns :commentable, only: [:index, :show] end  Or, using a callable object, you might implement something more specific to your application, which would be out of place in your routes file.  # purchasable.rb class Purchasable def initialize(defaults = {}) @defaults = defaults end  def call(mapper, options = {}) options = @defaults.merge(options) mapper.resources :purchases mapper.resources :receipts mapper.resources :returns if options[:returnable] end end  # routes.rb concern :purchasable, Purchasable.new(returnable: true)  resources :toys, concerns: :purchasable resources :electronics, concerns: :purchasable resources :pets do concerns :purchasable, returnable: false end  Any routing helpers can be used inside a concern. If using a callable, they're accessible from the Mapper that's passed to `call`.",
    "label": "",
    "id": "560"
  },
  {
    "raw_code": "def concerns(*args, **options)\n          args.flatten.each do |name|\n            if concern = @concerns[name]\n              concern.call(self, options)\n            else\n              raise ArgumentError, \"No concern named #{name} was found!\"\n            end",
    "comment": "Use the named concerns  resources :posts do concerns :commentable end  Concerns also work in any routes helper that you want to use:  namespace :posts do concerns :commentable end",
    "label": "",
    "id": "561"
  },
  {
    "raw_code": "def direct(name, options = {}, &block)\n          unless @scope.root?\n            raise RuntimeError, \"The direct method can't be used inside a routes scope block\"\n          end",
    "comment": "Define custom URL helpers that will be added to the application's routes. This allows you to override and/or replace the default behavior of routing helpers, e.g:  direct :homepage do \"https://rubyonrails.org\" end  direct :commentable do |model| [ model, anchor: model.dom_id ] end  direct :main do { controller: \"pages\", action: \"index\", subdomain: \"www\" } end  The return value from the block passed to `direct` must be a valid set of arguments for `url_for` which will actually build the URL string. This can be one of the following:  *   A string, which is treated as a generated URL *   A hash, e.g. `{ controller: \"pages\", action: \"index\" }` *   An array, which is passed to `polymorphic_url` *   An Active Model instance *   An Active Model class   NOTE: Other URL helpers can be called in the block but be careful not to invoke your custom URL helper again otherwise it will result in a stack overflow error.  You can also specify default options that will be passed through to your URL helper definition, e.g:  direct :browse, page: 1, size: 10 do |options| [ :products, options.merge(params.permit(:page, :size).to_h.symbolize_keys) ] end  In this instance the `params` object comes from the context in which the block is executed, e.g. generating a URL inside a controller action or a view. If the block is executed where there isn't a `params` object such as this:  Rails.application.routes.url_helpers.browse_path  then it will raise a `NameError`. Because of this you need to be aware of the context in which you will use your custom URL helper when defining it.  NOTE: The `direct` method can't be used inside of a scope block such as `namespace` or `scope` and will raise an error if it detects that it is.",
    "label": "",
    "id": "562"
  },
  {
    "raw_code": "def resolve(*args, &block)\n          unless @scope.root?\n            raise RuntimeError, \"The resolve method can't be used inside a routes scope block\"\n          end",
    "comment": "Define custom polymorphic mappings of models to URLs. This alters the behavior of `polymorphic_url` and consequently the behavior of `link_to`, `form_with` and `form_for` when passed a model instance, e.g:  resource :basket  resolve \"Basket\" do [:basket] end  This will now generate \"/basket\" when a `Basket` instance is passed to `link_to`, `form_with` or `form_for` instead of the standard \"/baskets/:id\".  NOTE: This custom behavior only applies to simple polymorphic URLs where a single model instance is passed and not more complicated forms, e.g:  # config/routes.rb resource :profile namespace :admin do resources :users end  resolve(\"User\") { [:profile] }  # app/views/application/_menu.html.erb link_to \"Profile\", @current_user link_to \"Profile\", [:admin, @current_user]  The first `link_to` will generate \"/profile\" but the second will generate the standard polymorphic URL of \"/admin/users/1\".  You can pass options to a polymorphic mapping - the arity for the block needs to be two as the instance is passed as the first argument, e.g:  resolve \"Basket\", anchor: \"items\" do |basket, options| [:basket, options] end  This generates the URL \"/basket#items\" because when the last item in an array passed to `polymorphic_url` is a hash then it's treated as options to the URL helper that gets called.  NOTE: The `resolve` method can't be used inside of a scope block such as `namespace` or `scope` and will raise an error if it detects that it is.",
    "label": "",
    "id": "563"
  },
  {
    "raw_code": "def polymorphic_url(record_or_hash_or_array, options = {})\n        if Hash === record_or_hash_or_array\n          options = record_or_hash_or_array.merge(options)\n          record  = options.delete :id\n          return polymorphic_url record, options\n        end",
    "comment": "Constructs a call to a named RESTful route for the given record and returns the resulting URL string. For example:  # calls post_url(post) polymorphic_url(post) # => \"http://example.com/posts/1\" polymorphic_url([blog, post]) # => \"http://example.com/blogs/1/posts/1\" polymorphic_url([:admin, blog, post]) # => \"http://example.com/admin/blogs/1/posts/1\" polymorphic_url([user, :blog, post]) # => \"http://example.com/users/1/blog/posts/1\" polymorphic_url(Comment) # => \"http://example.com/comments\"  #### Options  *   `:action` - Specifies the action prefix for the named route: `:new` or `:edit`. Default is no prefix. *   `:routing_type` - Allowed values are `:path` or `:url`. Default is `:url`.   Also includes all the options from `url_for`. These include such things as `:anchor` or `:trailing_slash`. Example usage is given below:  polymorphic_url([blog, post], anchor: 'my_anchor') # => \"http://example.com/blogs/1/posts/1#my_anchor\" polymorphic_url([blog, post], anchor: 'my_anchor', script_name: \"/my_app\") # => \"http://example.com/my_app/blogs/1/posts/1#my_anchor\"  For all of these options, see the documentation for [url_for](rdoc-ref:ActionDispatch::Routing::UrlFor).  #### Functionality  # an Article record polymorphic_url(record)  # same as article_url(record)  # a Comment record polymorphic_url(record)  # same as comment_url(record)  # it recognizes new records and maps to the collection record = Comment.new polymorphic_url(record)  # same as comments_url()  # the class of a record will also map to the collection polymorphic_url(Comment) # same as comments_url() ",
    "label": "",
    "id": "564"
  },
  {
    "raw_code": "def polymorphic_path(record_or_hash_or_array, options = {})\n        if Hash === record_or_hash_or_array\n          options = record_or_hash_or_array.merge(options)\n          record  = options.delete :id\n          return polymorphic_path record, options\n        end",
    "comment": "Returns the path component of a URL for the given record.",
    "label": "",
    "id": "565"
  },
  {
    "raw_code": "def #{action}_polymorphic_url(record_or_hash, options = {})\n            polymorphic_url_for_action(\"#{action}\", record_or_hash, options)\n          end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "566"
  },
  {
    "raw_code": "def redirect(*args, &block)\n        options = args.extract_options!\n        status  = options.delete(:status) || 301\n        path    = args.shift\n\n        return OptionRedirect.new(status, options) if options.any?\n        return PathRedirect.new(status, path) if String === path\n\n        block = path if path.respond_to? :call\n        raise ArgumentError, \"redirection argument not supported\" unless block\n        Redirect.new status, block\n      end",
    "comment": "Redirect any path to another path:  get \"/stories\" => redirect(\"/posts\")  This will redirect the user, while ignoring certain parts of the request, including query string, etc. `/stories`, `/stories?foo=bar`, etc all redirect to `/posts`.  The redirect will use a `301 Moved Permanently` status code by default. This can be overridden with the `:status` option:  get \"/stories\" => redirect(\"/posts\", status: 307)  You can also use interpolation in the supplied redirect argument:  get 'docs/:article', to: redirect('/wiki/%{article}')  Note that if you return a path without a leading slash then the URL is prefixed with the current SCRIPT_NAME environment variable. This is typically '/' but may be different in a mounted engine or where the application is deployed to a subdirectory of a website.  Alternatively you can use one of the other syntaxes:  The block version of redirect allows for the easy encapsulation of any logic associated with the redirect in question. Either the params and request are supplied as arguments, or just params, depending of how many arguments your block accepts. A string is required as a return value.  get 'jokes/:number', to: redirect { |params, request| path = (params[:number].to_i.even? ? \"wheres-the-beef\" : \"i-love-lamp\") \"http://#{request.host_with_port}/#{path}\" }  Note that the `do end` syntax for the redirect block wouldn't work, as Ruby would pass the block to `get` instead of `redirect`. Use `{ ... }` instead.  The options version of redirect allows you to supply only the parts of the URL which need to change, it also supports interpolation of the path similar to the first example.  get 'stores/:name',       to: redirect(subdomain: 'stores', path: '/%{name}') get 'stores/:name(*all)', to: redirect(subdomain: 'stores', path: '/%{name}%{all}') get '/stories', to: redirect(path: '/posts')  This will redirect the user, while changing only the specified parts of the request, for example the `path` option in the last example. `/stories`, `/stories?foo=bar`, redirect to `/posts` and `/posts?foo=bar` respectively.  Finally, an object which responds to call can be supplied to redirect, allowing you to reuse common redirect routes. The call method must accept two arguments, params and request, and return a string.  get 'accounts/:name' => redirect(SubdomainRedirector.new('api')) ",
    "label": "",
    "id": "567"
  },
  {
    "raw_code": "def merge_script_names(previous_script_name, new_script_name)\n        return new_script_name unless previous_script_name\n        new_script_name = new_script_name.chomp(\"/\")\n\n        resolved_parts = new_script_name.count(\"/\")\n        previous_parts = previous_script_name.count(\"/\")\n        context_parts = previous_parts - resolved_parts + 1\n\n        (previous_script_name.split(\"/\").slice(0, context_parts).join(\"/\")) + new_script_name\n      end",
    "comment": "Keeps the part of the script name provided by the global context via [ENV](\"SCRIPT_NAME\"), which `mount` doesn't know about since it depends on the specific request, but use our script name resolver for the mount point dependent part.",
    "label": "",
    "id": "568"
  },
  {
    "raw_code": "def from_requirements(requirements)\n        routes.find { |route| route.requirements == requirements }\n      end",
    "comment": "Returns a Route matching the given requirements, or `nil` if none are found.  This is intended for use by tools such as Language Servers.  Given the routes are defined as:  resources :posts  Then the following will return the Route for the `show` action:  Rails.application.routes.from_requirements(controller: \"posts\", action: \"show\")",
    "label": "",
    "id": "569"
  },
  {
    "raw_code": "def add_url_helper(name, defaults, &block)\n          helper = CustomUrlHelper.new(name, defaults, &block)\n          path_name = :\"#{name}_path\"\n          url_name = :\"#{name}_url\"\n\n          @path_helpers_module.module_eval do\n            redefine_method(path_name) do |*args|\n              helper.call(self, args, true)\n            end",
    "comment": "Given a `name`, defines name_path and name_url helpers. Used by 'direct', 'resolve', and 'polymorphic' route helpers.",
    "label": "",
    "id": "570"
  },
  {
    "raw_code": "def define_url_helper(mod, name, helper, url_strategy)\n            mod.define_method(name) do |*args|\n              last = args.last\n              options = \\\n                case last\n                when Hash\n                  args.pop\n                when ActionController::Parameters\n                  args.pop.to_h\n                end",
    "comment": "Create a URL helper allowing ordered parameters to be associated with corresponding dynamic segments, so you can do:  foo_url(bar, baz, bang)  Instead of:  foo_url(bar: bar, baz: baz, bang: bang)  Also allow options hash, so you can do:  foo_url(bar, baz, bang, sort_by: 'baz') ",
    "label": "",
    "id": "571"
  },
  {
    "raw_code": "def mounted_helpers\n        MountedHelpers\n      end",
    "comment": "Contains all the mounted helpers across different engines and the `main_app` helper for the application. You can include this in your classes if you want to access routes for other engines.",
    "label": "",
    "id": "572"
  },
  {
    "raw_code": "def self.included(base)\n            super\n            if base.respond_to?(:_routes) && !base._routes.equal?(@_proxy._routes)\n              @dup_for_reinclude ||= self.dup\n              base.include @dup_for_reinclude\n            end",
    "comment": "If the module is included more than once (for example, in a subclass of an ancestor that includes the module), ensure that the `_routes` singleton and instance methods return the desired route set by including a new copy of the module (recursively if necessary). Note that this method is called for each inclusion, whereas the above `included` block is run only for the initial inclusion of each copy.",
    "label": "",
    "id": "573"
  },
  {
    "raw_code": "def normalize_controller_action_id!\n          use_recall_for(:controller) || return\n          use_recall_for(:action) || return\n          use_recall_for(:id)\n        end",
    "comment": "This pulls :controller, :action, and :id out of the recall. The recall key is only used if there is no key in the options or if the key in the options is identical. If any of :controller, :action or :id is not found, don't pull any more keys from the recall.",
    "label": "",
    "id": "574"
  },
  {
    "raw_code": "def use_relative_controller!\n          if !named_route && different_controller? && !controller.start_with?(\"/\")\n            old_parts = current_controller.split(\"/\")\n            size = controller.count(\"/\") + 1\n            parts = old_parts[0...-size] << controller\n            @options[:controller] = parts.join(\"/\")\n          end",
    "comment": "if the current controller is \"foo/bar/baz\" and controller: \"baz/bat\" is specified, the controller becomes \"foo/baz/bat\"",
    "label": "",
    "id": "575"
  },
  {
    "raw_code": "def normalize_controller!\n          if controller\n            if controller.start_with?(\"/\")\n              @options[:controller] = controller[1..-1]\n            else\n              @options[:controller] = controller\n            end",
    "comment": "Remove leading slashes from controllers",
    "label": "",
    "id": "576"
  },
  {
    "raw_code": "def generate\n          @set.formatter.generate(named_route, options, recall)\n        end",
    "comment": "Generates a path from routes, returns a RouteWithParams or MissingRoute. MissingRoute will raise ActionController::UrlGenerationError.",
    "label": "",
    "id": "577"
  },
  {
    "raw_code": "def extra_keys(options, recall = {})\n        generate_extras(options, recall).last\n      end",
    "comment": "Generate the path indicated by the arguments, and return an array of the keys that were not used to generate it.",
    "label": "",
    "id": "578"
  },
  {
    "raw_code": "def url_for(options, route_name = nil, url_strategy = UNKNOWN, method_name = nil, reserved = RESERVED_OPTIONS)\n        options = default_url_options.merge options\n\n        user = password = nil\n\n        if options[:user] && options[:password]\n          user     = options.delete :user\n          password = options.delete :password\n        end",
    "comment": "The `options` argument must be a hash whose keys are **symbols**.",
    "label": "",
    "id": "579"
  },
  {
    "raw_code": "def url_options\n        default_url_options\n      end",
    "comment": "Hook overridden in controller to add request information with `default_url_options`. Application logic should not go into url_options.",
    "label": "",
    "id": "580"
  },
  {
    "raw_code": "def url_for(options = nil)\n        full_url_for(options)\n      end",
    "comment": "Generate a URL based on the options provided, `default_url_options`, and the routes defined in `config/routes.rb`. The following options are supported:  *   `:only_path` - If true, the relative URL is returned. Defaults to `false`. *   `:protocol` - The protocol to connect to. Defaults to `\"http\"`. *   `:host` - Specifies the host the link should be targeted at. If `:only_path` is false, this option must be provided either explicitly, or via `default_url_options`. *   `:subdomain` - Specifies the subdomain of the link, using the `tld_length` to split the subdomain from the host. If false, removes all subdomains from the host part of the link. *   `:domain` - Specifies the domain of the link, using the `tld_length` to split the domain from the host. *   `:tld_length` - Number of labels the TLD id composed of, only used if `:subdomain` or `:domain` are supplied. Defaults to `ActionDispatch::Http::URL.tld_length`, which in turn defaults to 1. *   `:port` - Optionally specify the port to connect to. *   `:anchor` - An anchor name to be appended to the path. *   `:params` - The query parameters to be appended to the path. *   `:path_params` - The query parameters that will only be used for the named dynamic segments of path. If unused, they will be discarded. *   `:trailing_slash` - If true, adds a trailing slash, as in `\"/archive/2009/\"`. *   `:script_name` - Specifies application path relative to domain root. If provided, prepends application path.   Any other key (`:controller`, `:action`, etc.) given to `url_for` is forwarded to the Routes module.  url_for controller: 'tasks', action: 'testing', host: 'somehost.org', port: '8080' # => 'http://somehost.org:8080/tasks/testing' url_for controller: 'tasks', action: 'testing', host: 'somehost.org', anchor: 'ok', only_path: true # => '/tasks/testing#ok' url_for controller: 'tasks', action: 'testing', trailing_slash: true # => 'http://somehost.org/tasks/testing/' url_for controller: 'tasks', action: 'testing', host: 'somehost.org', number: '33' # => 'http://somehost.org/tasks/testing?number=33' url_for controller: 'tasks', action: 'testing', host: 'somehost.org', script_name: \"/myapp\" # => 'http://somehost.org/myapp/tasks/testing' url_for controller: 'tasks', action: 'testing', host: 'somehost.org', script_name: \"/myapp\", only_path: true # => '/myapp/tasks/testing'  Missing routes keys may be filled in from the current request's parameters (e.g. `:controller`, `:action`, `:id`, and any other parameters that are placed in the path). Given that the current action has been reached through `GET /users/1`:  url_for(only_path: true)                        # => '/users/1' url_for(only_path: true, action: 'edit')        # => '/users/1/edit' url_for(only_path: true, action: 'edit', id: 2) # => '/users/2/edit'  Notice that no `:id` parameter was provided to the first `url_for` call and the helper used the one from the route's path. Any path parameter implicitly used by `url_for` can always be overwritten like shown on the last `url_for` calls.",
    "label": "",
    "id": "581"
  },
  {
    "raw_code": "def route_for(name, *args)\n        public_send(:\"#{name}_url\", *args)\n      end",
    "comment": "Allows calling direct or regular named route.  resources :buckets  direct :recordable do |recording| route_for(:bucket, recording.bucket) end  direct :threadable do |threadable| route_for(:recordable, threadable.parent) end  This maintains the context of the original caller on whether to return a path or full URL, e.g:  threadable_path(threadable)  # => \"/buckets/1\" threadable_url(threadable)   # => \"http://example.com/buckets/1\" ",
    "label": "",
    "id": "582"
  },
  {
    "raw_code": "def preload\n        case type\n        when :chrome\n          resolve_driver_path(::Selenium::WebDriver::Chrome)\n        when :firefox\n          resolve_driver_path(::Selenium::WebDriver::Firefox)\n        end",
    "comment": "driver_path is lazily initialized by default. Eagerly set it to avoid race conditions when using parallel tests.",
    "label": "",
    "id": "583"
  },
  {
    "raw_code": "def take_screenshot(html: false, screenshot: nil)\n          showing_html = html || html_from_env?\n\n          increment_unique\n          save_html if showing_html\n          save_image\n          show display_image(html: showing_html, screenshot_output: screenshot)\n        end",
    "comment": "Takes a screenshot of the current page in the browser.  `take_screenshot` can be used at any point in your system tests to take a screenshot of the current state. This can be useful for debugging or automating visual testing. You can take multiple screenshots per test to investigate changes at different points during your test. These will be named with a sequential prefix (or 'failed' for failing tests)  The default screenshots directory is `tmp/screenshots` but you can set a different one with `Capybara.save_path`  You can use the `html` argument or set the `RAILS_SYSTEM_TESTING_SCREENSHOT_HTML` environment variable to save the HTML from the page that is being screenshotted so you can investigate the elements on the page at the time of the screenshot  You can use the `screenshot` argument or set the `RAILS_SYSTEM_TESTING_SCREENSHOT` environment variable to control the output. Possible values are: `simple` (default) :       Only displays the screenshot path. This is the default value.  `inline` :       Display the screenshot in the terminal using the iTerm image protocol (https://iterm2.com/documentation-images.html).  `artifact` :       Display the screenshot in the terminal, using the terminal artifact format (https://buildkite.github.io/terminal-to-html/inline-images/).  ",
    "label": "",
    "id": "584"
  },
  {
    "raw_code": "def take_failed_screenshot\n          return unless failed? && supports_screenshot? && Capybara::Session.instance_created?\n\n          take_screenshot\n          metadata[:failure_screenshot_path] = relative_image_path if Minitest::Runnable.method_defined?(:metadata)\n        end",
    "comment": "Takes a screenshot of the current page in the browser if the test failed.  `take_failed_screenshot` is called during system test teardown.",
    "label": "",
    "id": "585"
  },
  {
    "raw_code": "def save_html\n            page.save_page(absolute_html_path)\n          end",
    "comment": "rubocop:disable Lint/Debugger",
    "label": "",
    "id": "586"
  },
  {
    "raw_code": "def output_type\n            # Environment variables have priority\n            output_type = ENV[\"RAILS_SYSTEM_TESTING_SCREENSHOT\"] || ENV[\"CAPYBARA_INLINE_SCREENSHOT\"]\n\n            # Default to outputting a path to the screenshot\n            output_type ||= \"simple\"\n\n            output_type\n          end",
    "comment": "rubocop:enable Lint/Debugger",
    "label": "",
    "id": "587"
  },
  {
    "raw_code": "def initialize(code_or_name)\n      if code_or_name.is_a?(Symbol)\n        @name = code_or_name\n        @code = code_from_name(code_or_name)\n      else\n        @name = name_from_code(code_or_name)\n        @code = code_or_name\n      end",
    "comment": "Accepts a specific response status code as an Integer (404) or String ('404') or a response status range as a Symbol pseudo-code (:success, indicating any 200-299 status code).",
    "label": "",
    "id": "588"
  },
  {
    "raw_code": "def get(path, **args)\n        process(:get, path, **args)\n      end",
    "comment": "Performs a GET request with the given parameters. See ActionDispatch::Integration::Session#process for more details.",
    "label": "",
    "id": "589"
  },
  {
    "raw_code": "def post(path, **args)\n        process(:post, path, **args)\n      end",
    "comment": "Performs a POST request with the given parameters. See ActionDispatch::Integration::Session#process for more details.",
    "label": "",
    "id": "590"
  },
  {
    "raw_code": "def patch(path, **args)\n        process(:patch, path, **args)\n      end",
    "comment": "Performs a PATCH request with the given parameters. See ActionDispatch::Integration::Session#process for more details.",
    "label": "",
    "id": "591"
  },
  {
    "raw_code": "def put(path, **args)\n        process(:put, path, **args)\n      end",
    "comment": "Performs a PUT request with the given parameters. See ActionDispatch::Integration::Session#process for more details.",
    "label": "",
    "id": "592"
  },
  {
    "raw_code": "def delete(path, **args)\n        process(:delete, path, **args)\n      end",
    "comment": "Performs a DELETE request with the given parameters. See ActionDispatch::Integration::Session#process for more details.",
    "label": "",
    "id": "593"
  },
  {
    "raw_code": "def head(path, **args)\n        process(:head, path, **args)\n      end",
    "comment": "Performs a HEAD request with the given parameters. See ActionDispatch::Integration::Session#process for more details.",
    "label": "",
    "id": "594"
  },
  {
    "raw_code": "def options(path, **args)\n        process(:options, path, **args)\n      end",
    "comment": "Performs an OPTIONS request with the given parameters. See ActionDispatch::Integration::Session#process for more details.",
    "label": "",
    "id": "595"
  },
  {
    "raw_code": "def follow_redirect!(headers: {}, **args)\n        raise \"not a redirect! #{status} #{status_message}\" unless redirect?\n\n        method =\n          if [307, 308].include?(response.status)\n            request.method.downcase\n          else\n            :get\n          end",
    "comment": "Follow a single redirect response. If the last response was not a redirect, an exception will be raised. Otherwise, the redirect is performed on the location header. If the redirection is a 307 or 308 redirect, the same HTTP verb will be used when redirecting, otherwise a GET request will be performed. Any arguments are passed to the underlying request.  The HTTP_REFERER header will be set to the previous url.",
    "label": "",
    "id": "596"
  },
  {
    "raw_code": "def host\n        @host || DEFAULT_HOST\n      end",
    "comment": "The hostname used in the last request.",
    "label": "",
    "id": "597"
  },
  {
    "raw_code": "def cookies\n        _mock_session.cookie_jar\n      end",
    "comment": "A map of the cookies returned by the last response, and which will be sent with the next request.",
    "label": "",
    "id": "598"
  },
  {
    "raw_code": "def initialize(app)\n        super()\n        @app = app\n\n        reset!\n      end",
    "comment": "Create and initialize a new Session instance.",
    "label": "",
    "id": "599"
  },
  {
    "raw_code": "def reset!\n        @https = false\n        @controller = @request = @response = nil\n        @_mock_session = nil\n        @request_count = 0\n        @url_options = nil\n\n        self.host        = DEFAULT_HOST\n        self.remote_addr = \"127.0.0.1\"\n        self.accept      = \"text/xml,application/xml,application/xhtml+xml,\" \\\n                           \"text/html;q=0.9,text/plain;q=0.8,image/png,\" \\\n                           \"*/*;q=0.5\"\n\n        unless defined? @named_routes_configured\n          # the helpers are made protected by default--we make them public for easier\n          # access during testing and troubleshooting.\n          @named_routes_configured = true\n        end",
    "comment": "Resets the instance. This can be used to reset the state information in an existing session instance, so it can be used from a clean-slate condition.  session.reset!",
    "label": "",
    "id": "600"
  },
  {
    "raw_code": "def https!(flag = true)\n        @https = flag\n      end",
    "comment": "Specify whether or not the session should mimic a secure HTTPS request.  session.https! session.https!(false)",
    "label": "",
    "id": "601"
  },
  {
    "raw_code": "def https?\n        @https\n      end",
    "comment": "Returns `true` if the session is mimicking a secure HTTPS request.  if session.https? ... end",
    "label": "",
    "id": "602"
  },
  {
    "raw_code": "def process(method, path, params: nil, headers: nil, env: nil, xhr: false, as: nil)\n        request_encoder = RequestEncoder.encoder(as)\n        headers ||= {}\n\n        if method == :get && as == :json && params\n          headers[\"X-Http-Method-Override\"] = \"GET\"\n          method = :post\n        end",
    "comment": "Performs the actual request.  *   `method`: The HTTP method (GET, POST, PATCH, PUT, DELETE, HEAD, OPTIONS) as a symbol. *   `path`: The URI (as a String) on which you want to perform the request. *   `params`: The HTTP parameters that you want to pass. This may be `nil`, a Hash, or a String that is appropriately encoded (`application/x-www-form-urlencoded` or `multipart/form-data`). *   `headers`: Additional headers to pass, as a Hash. The headers will be merged into the Rack env hash. *   `env`: Additional env to pass, as a Hash. The headers will be merged into the Rack env hash. *   `xhr`: Set to `true` if you want to make an Ajax request. Adds request headers characteristic of XMLHttpRequest e.g. HTTP_X_REQUESTED_WITH. The headers will be merged into the Rack env hash. *   `as`: Used for encoding the request with different content type. Supports `:json` by default and will set the appropriate request headers. The headers will be merged into the Rack env hash.   This method is rarely used directly. Use RequestHelpers#get, RequestHelpers#post, or other standard HTTP methods in integration tests. `#process` is only required when using a request method that doesn't have a method defined in the integration tests.  This method returns the response status, after performing the request. Furthermore, if this method was called from an ActionDispatch::IntegrationTest object, then that object's `@response` instance variable will point to a Response object which one can use to inspect the details of the response.  Example: process :get, '/author', params: { since: 201501011400 }",
    "label": "",
    "id": "603"
  },
  {
    "raw_code": "def reset!\n        @integration_session = create_session(app)\n      end",
    "comment": "Reset the current session. This is useful for testing multiple sessions in a single test case.",
    "label": "",
    "id": "604"
  },
  {
    "raw_code": "def open_session\n        dup.tap do |session|\n          session.reset!\n          session.root_session = self.root_session || self\n          yield session if block_given?\n        end",
    "comment": "Open a new session instance. If a block is given, the new session is yielded to the block before being returned.  session = open_session do |sess| sess.extend(CustomAssertions) end  By default, a single session is automatically created for you, but you can use this method to open multiple sessions that ought to be tested simultaneously.",
    "label": "",
    "id": "605"
  },
  {
    "raw_code": "def copy_session_variables! # :nodoc:\n        @controller = @integration_session.controller\n        @response   = @integration_session.response\n        @request    = @integration_session.request\n      end",
    "comment": "Copy the instance variables from the current session instance into the test instance.",
    "label": "",
    "id": "606"
  },
  {
    "raw_code": "def method_missing(method, ...)\n        if integration_session.respond_to?(method)\n          integration_session.public_send(method, ...).tap do\n            copy_session_variables!\n          end",
    "comment": "Delegate unhandled messages to the current session instance.",
    "label": "",
    "id": "607"
  },
  {
    "raw_code": "def file_fixture_upload(path, mime_type = nil, binary = false)\n        if self.class.file_fixture_path && !File.exist?(path)\n          path = file_fixture(path)\n        end",
    "comment": "Shortcut for `Rack::Test::UploadedFile.new(File.join(ActionDispatch::IntegrationTest.file_fixture_path, path), type)`:  post :change_avatar, params: { avatar: file_fixture_upload('david.png', 'image/png') }  Default fixture files location is `test/fixtures/files`.  To upload binary files on Windows, pass `:binary` as the last parameter. This will not affect other platforms:  post :change_avatar, params: { avatar: file_fixture_upload('david.png', 'image/png', :binary) }",
    "label": "",
    "id": "608"
  },
  {
    "raw_code": "def self.create(env = {})\n      env = Rails.application.env_config.merge(env) if defined?(Rails.application) && Rails.application\n      env[\"rack.request.cookie_hash\"] ||= {}.with_indifferent_access\n      new(default_env.merge(env))\n    end",
    "comment": "Create a new test request with default `env` values.",
    "label": "",
    "id": "609"
  },
  {
    "raw_code": "def parsed_body\n      @parsed_body ||= response_parser.call(body)\n    end",
    "comment": "Returns a parsed body depending on the response MIME type. When a parser corresponding to the MIME type is not found, it returns the raw body.  #### Examples get \"/posts\" response.content_type         # => \"text/html; charset=utf-8\" response.parsed_body.class    # => Nokogiri::HTML5::Document response.parsed_body.to_html  # => \"<!DOCTYPE html>\\n<html>\\n...\"  assert_pattern { response.parsed_body.at(\"main\") => { content: \"Hello, world\" } }  response.parsed_body.at(\"main\") => {name:, content:} assert_equal \"main\", name assert_equal \"Some main content\", content  get \"/posts.json\" response.content_type         # => \"application/json; charset=utf-8\" response.parsed_body.class    # => Array response.parsed_body          # => [{\"id\"=>42, \"title\"=>\"Title\"},...  assert_pattern { response.parsed_body => [{ id: 42 }] }  get \"/posts/42.json\" response.content_type         # => \"application/json; charset=utf-8\" response.parsed_body.class    # => ActiveSupport::HashWithIndifferentAccess response.parsed_body          # => {\"id\"=>42, \"title\"=>\"Title\"}  assert_pattern { response.parsed_body => [{ title: /title/i }] }  response.parsed_body => {id:, title:} assert_equal 42, id assert_equal \"Title\", title",
    "label": "",
    "id": "610"
  },
  {
    "raw_code": "def assert_response(type, message = nil)\n        message ||= generate_response_message(type)\n\n        if RESPONSE_PREDICATES.key?(type)\n          assert @response.public_send(RESPONSE_PREDICATES[type]), message\n        else\n          assert_equal AssertionResponse.new(type).code, @response.response_code, message\n        end",
    "comment": "Asserts that the response is one of the following types:  *   `:success`   - Status code was in the 200-299 range *   `:redirect`  - Status code was in the 300-399 range *   `:missing`   - Status code was 404 *   `:error`     - Status code was in the 500-599 range   You can also pass an explicit status number like `assert_response(501)` or its symbolic equivalent `assert_response(:not_implemented)`. See `Rack::Utils::SYMBOL_TO_STATUS_CODE` for a full list.  # Asserts that the response was a redirection assert_response :redirect  # Asserts that the response code was status code 401 (unauthorized) assert_response 401",
    "label": "",
    "id": "611"
  },
  {
    "raw_code": "def assert_redirected_to(url_options = {}, options = {}, message = nil)\n        options, message = {}, options unless options.is_a?(Hash)\n\n        status = options[:status] || :redirect\n        assert_response(status, message)\n        return true if url_options === @response.location\n\n        redirect_is       = normalize_argument_to_redirection(@response.location)\n        redirect_expected = normalize_argument_to_redirection(url_options)\n\n        message ||= \"Expected response to be a redirect to <#{redirect_expected}> but was a redirect to <#{redirect_is}>\"\n        assert_operator redirect_expected, :===, redirect_is, message\n      end",
    "comment": "Asserts that the response is a redirect to a URL matching the given options.  # Asserts that the redirection was to the \"index\" action on the WeblogController assert_redirected_to controller: \"weblog\", action: \"index\"  # Asserts that the redirection was to the named route login_url assert_redirected_to login_url  # Asserts that the redirection was to the URL for @customer assert_redirected_to @customer  # Asserts that the redirection matches the regular expression assert_redirected_to %r(\\Ahttp://example.org)  # Asserts that the redirection has the HTTP status code 301 (Moved # Permanently). assert_redirected_to \"/some/path\", status: :moved_permanently",
    "label": "",
    "id": "612"
  },
  {
    "raw_code": "def assert_in_body(text)\n        assert_match(/#{Regexp.escape(text)}/, @response.body)\n      end",
    "comment": "Asserts that the given +text+ is present somewhere in the response body.  assert_in_body fixture(:name).description",
    "label": "",
    "id": "613"
  },
  {
    "raw_code": "def assert_not_in_body(text)\n        assert_no_match(/#{Regexp.escape(text)}/, @response.body)\n      end",
    "comment": "Asserts that the given +text+ is not present anywhere in the response body.  assert_not_in_body fixture(:name).description",
    "label": "",
    "id": "614"
  },
  {
    "raw_code": "def parameterize(value)\n          value.respond_to?(:to_param) ? value.to_param : value\n        end",
    "comment": "Proxy to to_param if the object will respond to it.",
    "label": "",
    "id": "615"
  },
  {
    "raw_code": "def with_routing(&block)\n          old_routes, old_controller = nil\n\n          setup do\n            old_routes, old_controller = @routes, @controller\n            create_routes(&block)\n          end",
    "comment": "A helper to make it easier to test different route configurations. This method temporarily replaces @routes with a new RouteSet instance before each test.  The new instance is yielded to the passed block. Typically the block will create some routes using `set.draw { match ... }`:  with_routing do |set| set.draw do resources :users end end ",
    "label": "",
    "id": "616"
  },
  {
    "raw_code": "def with_routing(config = nil, &block)\n        old_routes, old_controller = @routes, @controller\n        create_routes(config, &block)\n      ensure\n        reset_routes(old_routes, old_controller)\n      end",
    "comment": "A helper to make it easier to test different route configurations. This method temporarily replaces @routes with a new RouteSet instance.  The new instance is yielded to the passed block. Typically the block will create some routes using `set.draw { match ... }`:  with_routing do |set| set.draw do resources :users end assert_equal \"/users\", users_path end ",
    "label": "",
    "id": "617"
  },
  {
    "raw_code": "def assert_recognizes(expected_options, path, extras = {}, msg = nil)\n        if path.is_a?(Hash) && path[:method].to_s == \"all\"\n          [:get, :post, :put, :delete].each do |method|\n            assert_recognizes(expected_options, path.merge(method: method), extras, msg)\n          end",
    "comment": "Asserts that the routing of the given `path` was handled correctly and that the parsed options (given in the `expected_options` hash) match `path`. Basically, it asserts that Rails recognizes the route given by `expected_options`.  Pass a hash in the second argument (`path`) to specify the request method. This is useful for routes requiring a specific HTTP method. The hash should contain a `:path` with the incoming request path and a `:method` containing the required HTTP verb.  # Asserts that POSTing to /items will call the create action on ItemsController assert_recognizes({controller: 'items', action: 'create'}, {path: 'items', method: :post})  You can also pass in `extras` with a hash containing URL parameters that would normally be in the query string. This can be used to assert that values in the query string will end up in the params hash correctly. To test query strings you must use the extras argument because appending the query string on the path directly will not work. For example:  # Asserts that a path of '/items/list/1?view=print' returns the correct options assert_recognizes({controller: 'items', action: 'list', id: '1', view: 'print'}, 'items/list/1', { view: \"print\" })  The `message` parameter allows you to pass in an error message that is displayed upon failure.  # Check the default route (i.e., the index action) assert_recognizes({controller: 'items', action: 'index'}, 'items')  # Test a specific action assert_recognizes({controller: 'items', action: 'list'}, 'items/list')  # Test an action with a parameter assert_recognizes({controller: 'items', action: 'destroy', id: '1'}, 'items/destroy/1')  # Test a custom route assert_recognizes({controller: 'items', action: 'show', id: '1'}, 'view/item1')",
    "label": "",
    "id": "618"
  },
  {
    "raw_code": "def assert_generates(expected_path, options, defaults = {}, extras = {}, message = nil)\n        if expected_path.include?(\"://\")\n          fail_on(URI::InvalidURIError, message) do\n            uri = URI.parse(expected_path)\n            expected_path = uri.path.to_s.empty? ? \"/\" : uri.path\n          end",
    "comment": "Asserts that the provided options can be used to generate the provided path. This is the inverse of `assert_recognizes`. The `extras` parameter is used to tell the request the names and values of additional request parameters that would be in a query string. The `message` parameter allows you to specify a custom error message for assertion failures.  The `defaults` parameter is unused.  # Asserts that the default action is generated for a route with no action assert_generates \"/items\", controller: \"items\", action: \"index\"  # Tests that the list action is properly routed assert_generates \"/items/list\", controller: \"items\", action: \"list\"  # Tests the generation of a route with a parameter assert_generates \"/items/list/1\", { controller: \"items\", action: \"list\", id: \"1\" }  # Asserts that the generated route gives us our custom route assert_generates \"changesets/12\", { controller: 'scm', action: 'show_diff', revision: \"12\" }",
    "label": "",
    "id": "619"
  },
  {
    "raw_code": "def assert_routing(path, options, defaults = {}, extras = {}, message = nil)\n        assert_recognizes(options, path, extras, message)\n\n        controller, default_controller = options[:controller], defaults[:controller]\n        if controller && controller.include?(?/) && default_controller && default_controller.include?(?/)\n          options[:controller] = \"/#{controller}\"\n        end",
    "comment": "Asserts that path and options match both ways; in other words, it verifies that `path` generates `options` and then that `options` generates `path`. This essentially combines `assert_recognizes` and `assert_generates` into one step.  The `extras` hash allows you to specify options that would normally be provided as a query string to the action. The `message` parameter allows you to specify a custom error message to display upon failure.  # Asserts a basic route: a controller with the default action (index) assert_routing '/home', controller: 'home', action: 'index'  # Test a route generated with a specific controller, action, and parameter (id) assert_routing '/entries/show/23', controller: 'entries', action: 'show', id: 23  # Asserts a basic route (controller + default action), with an error message if it fails assert_routing '/store', { controller: 'store', action: 'index' }, {}, {}, 'Route for store index not generated properly'  # Tests a route, providing a defaults hash assert_routing 'controller/action/9', {id: \"9\", item: \"square\"}, {controller: \"controller\", action: \"action\"}, {}, {item: \"square\"}  # Tests a route with an HTTP method assert_routing({ method: 'put', path: '/product/321' }, { controller: \"product\", action: \"update\", id: \"321\" })",
    "label": "",
    "id": "620"
  },
  {
    "raw_code": "def method_missing(selector, ...)\n        if @controller && @routes&.named_routes&.route_defined?(selector)\n          @controller.public_send(selector, ...)\n        else\n          super\n        end",
    "comment": "ROUTES TODO: These assertions should really work in an integration context",
    "label": "",
    "id": "621"
  },
  {
    "raw_code": "def recognized_request_for(path, extras = {}, msg)\n          if path.is_a?(Hash)\n            method = path[:method]\n            path   = path[:path]\n          else\n            method = :get\n          end",
    "comment": "Recognizes the route for a given path.",
    "label": "",
    "id": "622"
  },
  {
    "raw_code": "def save_and_open_page(path = html_dump_default_path)\n        save_page(path).tap { |s_path| open_file(s_path) }\n      end",
    "comment": "Saves the content of response body to a file and tries to open it in your browser. Launchy must be present in your Gemfile for the page to open automatically.",
    "label": "",
    "id": "623"
  },
  {
    "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of Action Pack as a `Gem::Version`.",
    "label": "",
    "id": "624"
  },
  {
    "raw_code": "def self.version\n    gem_version\n  end",
    "comment": "Returns the currently loaded version of Action Pack as a `Gem::Version`.",
    "label": "",
    "id": "625"
  },
  {
    "raw_code": "def stderr_logger\n        nil\n      end",
    "comment": "Silence logger",
    "label": "",
    "id": "626"
  },
  {
    "raw_code": "def parse_set_cookies_headers(set_cookies)\n    if set_cookies.is_a?(String)\n      set_cookies = set_cookies.split(\"\\n\")\n    end",
    "comment": "Parse the set-cookie header and return a hash of cookie names and values.  Example: set_cookies = headers[\"set-cookie\"] parse_set_cookies_headers(set_cookies)",
    "label": "",
    "id": "627"
  },
  {
    "raw_code": "def normalized_join_header(header)\n    header.is_a?(Array) ? header.join(\",\") : header\n  end",
    "comment": "This works for most headers, but not all, e.g. `set-cookie`.",
    "label": "",
    "id": "628"
  },
  {
    "raw_code": "def render_content_type_from_body\n    response.content_type = Mime[:rss]\n    render body: \"hello world!\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "629"
  },
  {
    "raw_code": "def render_defaults\n    render body: \"hello world!\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "630"
  },
  {
    "raw_code": "def render_content_type_from_render\n    render body: \"hello world!\", content_type: Mime[:rss]\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "631"
  },
  {
    "raw_code": "def render_charset_from_body\n    response.charset = \"utf-16\"\n    render body: \"hello world!\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "632"
  },
  {
    "raw_code": "def render_nil_charset_from_body\n    response.charset = nil\n    render body: \"hello world!\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "633"
  },
  {
    "raw_code": "def test_render_defaults\n    get :render_defaults\n    assert_equal \"utf-8\", @response.charset\n    assert_equal Mime[:text], @response.media_type\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "634"
  },
  {
    "raw_code": "def test_content_type_from_body\n    get :render_content_type_from_body\n    assert_equal Mime[:rss], @response.media_type\n    assert_equal \"utf-8\", @response.charset\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "635"
  },
  {
    "raw_code": "def test_content_type_from_render\n    get :render_content_type_from_render\n    assert_equal Mime[:rss], @response.media_type\n    assert_equal \"utf-8\", @response.charset\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "636"
  },
  {
    "raw_code": "def test_charset_from_body\n    get :render_charset_from_body\n    assert_equal Mime[:text], @response.media_type\n    assert_equal \"utf-16\", @response.charset\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "637"
  },
  {
    "raw_code": "def test_nil_charset_from_body\n    get :render_nil_charset_from_body\n    assert_equal Mime[:text], @response.media_type\n    assert_equal \"utf-8\", @response.charset, @response.headers.inspect\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "638"
  },
  {
    "raw_code": "def get(path, **options)\n      options[:env] ||= {}\n      options[:env][\"action_dispatch.key_generator\"] ||= Generator\n      options[:env][\"action_dispatch.cookies_rotations\"] = Rotations\n      options[:env][\"action_dispatch.signed_cookie_salt\"] = SIGNED_COOKIE_SALT\n      super(path, **options)\n    end",
    "comment": "Overwrite get to send SessionSecret in env hash",
    "label": "",
    "id": "639"
  },
  {
    "raw_code": "def test_does_not_prevent_method_missing_passing_up_to_ancestors\n    mixin = Module.new do\n      def method_missing(name, ...)\n        name == :foo ? \"pass\" : super\n      end\n    end",
    "comment": "RSpec mixes Matchers (which has a #method_missing) into IntegrationTest's superclass.  Make sure IntegrationTest does not try to delegate these methods to the session object.",
    "label": "",
    "id": "640"
  },
  {
    "raw_code": "def status; raise \"Should not be called!\"; end\n  def location; raise \"Should not be called!\"; end\n\n  def simple_redirect\n    redirect_to action: \"hello_world\"\n  end\n\n  def redirect_with_status\n    redirect_to(action: \"hello_world\", status: 301)\n  end\n\n  def redirect_with_status_hash\n    redirect_to({ action: \"hello_world\" }, { status: 301 })\n  end\n\n  def redirect_with_protocol\n    redirect_to action: \"hello_world\", protocol: \"https\"\n  end\n\n  def url_redirect_with_status\n    redirect_to(\"http://www.example.com\", status: :moved_permanently)\n  end\n\n  def url_redirect_with_status_hash\n    redirect_to(\"http://www.example.com\", status: 301)\n  end\n\n  def relative_url_redirect_with_status\n    redirect_to(\"/things/stuff\", status: :found)\n  end\n\n  def relative_url_redirect_with_status_hash\n    redirect_to(\"/things/stuff\", status: 301)\n  end\n\n  def redirect_back_with_status\n    redirect_back_or_to \"/things/stuff\", status: 307\n  end\n\n  def redirect_back_with_status_and_fallback_location_to_another_host\n    redirect_back_or_to \"http://www.rubyonrails.org/\", status: 307\n  end\n\n  def safe_redirect_back_with_status\n    redirect_back_or_to \"/things/stuff\", status: 307, allow_other_host: false\n  end\n\n  def safe_redirect_back_with_status_and_fallback_location_to_another_host\n    redirect_back_or_to \"http://www.rubyonrails.org/\", status: 307, allow_other_host: false\n  end\n\n  def safe_redirect_to_root\n    redirect_to url_from(\"/\")\n  end\n\n  def unsafe_redirect\n    redirect_to \"http://www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_back\n    redirect_back_or_to \"http://www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_malformed\n    redirect_to \"http:///www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_protocol_relative_double_slash\n    redirect_to \"//www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_protocol_relative_triple_slash\n    redirect_to \"///www.rubyonrails.org/\"\n  end\n\n  def unsafe_redirect_with_illegal_http_header_value_character\n    redirect_to \"javascript:alert(document.domain)\\b\", allow_other_host: true\n  end\n\n  def only_path_redirect\n    redirect_to action: \"other_host\", only_path: true\n  end\n\n  def safe_redirect_with_fallback\n    redirect_to url_from(params[:redirect_url]) || \"/fallback\"\n  end\n\n  def redirect_back_with_explicit_fallback_kwarg\n    redirect_back(fallback_location: \"/things/stuff\", status: 307)\n  end\n\n  def host_redirect\n    redirect_to action: \"other_host\", only_path: false, host: \"other.test.host\"\n  end\n\n  def module_redirect\n    redirect_to controller: \"module_test/module_redirect\", action: \"hello_world\"\n  end\n\n  def redirect_to_url\n    redirect_to \"http://www.rubyonrails.org/\"\n  end\n\n  def redirect_to_url_with_stringlike\n    stringlike = Object.new\n\n    def stringlike.to_str\n      \"http://www.rubyonrails.org/\"\n    end\n\n    redirect_to stringlike\n  end\n\n  def redirect_to_url_with_unescaped_query_string\n    redirect_to \"http://example.com/query?status=new\"\n  end\n\n  def redirect_to_url_with_complex_scheme\n    redirect_to \"x-test+scheme.complex:redirect\"\n  end\n\n  def redirect_to_url_with_network_path_reference\n    redirect_to \"//www.rubyonrails.org/\"\n  end\n\n  def redirect_to_path_relative_url\n    redirect_to \"example.com\"\n  end\n\n  def redirect_to_path_relative_url_starting_with_an_at\n    redirect_to \"@example.com\"\n  end\n\n  def redirect_to_query_string_url\n    redirect_to \"?foo=bar\"\n  end\n\n  def redirect_to_existing_record\n    redirect_to Workshop.new(5)\n  end\n\n  def redirect_to_new_record\n    redirect_to Workshop.new(nil)\n  end\n\n  def redirect_to_nil\n    redirect_to nil\n  end\n\n  def redirect_to_polymorphic\n    redirect_to [:internal, Workshop.new(5)]\n  end\n\n  def redirect_to_polymorphic_string_args\n    redirect_to [\"internal\", Workshop.new(5)]\n  end\n\n  def redirect_to_params\n    redirect_to ActionController::Parameters.new(status: 200, protocol: \"javascript\", f: \"%0Aeval(name)\")\n  end\n\n  def redirect_to_with_block\n    redirect_to proc { \"http://www.rubyonrails.org/\" }\n  end\n\n  def redirect_to_with_block_and_assigns\n    @url = \"http://www.rubyonrails.org/\"\n    redirect_to proc { @url }\n  end\n\n  def redirect_to_with_block_and_options\n    redirect_to proc { { action: \"hello_world\" } }\n  end\n\n  def redirect_to_out_of_scope_block\n    redirect_to Workshop::OUT_OF_SCOPE_BLOCK\n  end\n\n  def redirect_with_header_break\n    redirect_to \"/lol\\r\\nwat\"\n  end\n\n  def redirect_with_null_bytes\n    redirect_to \"\\000/lol\\r\\nwat\"\n  end\n\n  def redirect_to_external_with_rescue\n    redirect_to \"http://www.rubyonrails.org/\", allow_other_host: false\n  rescue ActionController::Redirecting::UnsafeRedirectError\n    render plain: \"caught error\"\n  end\n\n  def rescue_errors(e) raise e end\n\n  private\n    def dashboard_url(id, message)\n      url_for action: \"dashboard\", params: { \"id\" => id, \"message\" => message }\n    end\nend\n\nclass RedirectTest < ActionController::TestCase\n  tests RedirectController\n\n  def test_simple_redirect\n    get :simple_redirect\n    assert_response :redirect\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_header_break\n    get :redirect_with_header_break\n    assert_response :redirect\n    assert_equal \"http://test.host/lolwat\", redirect_to_url\n  end\n\n  def test_redirect_with_null_bytes\n    get :redirect_with_null_bytes\n    assert_response :redirect\n    assert_equal \"http://test.host/lolwat\", redirect_to_url\n  end\n\n  def test_redirect_with_no_status\n    get :simple_redirect\n    assert_response 302\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_status\n    get :redirect_with_status\n    assert_response 301\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_status_hash\n    get :redirect_with_status_hash\n    assert_response 301\n    assert_equal \"http://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_redirect_with_protocol\n    get :redirect_with_protocol\n    assert_response 302\n    assert_equal \"https://test.host/redirect/hello_world\", redirect_to_url\n  end\n\n  def test_url_redirect_with_status\n    get :url_redirect_with_status\n    assert_response 301\n    assert_equal \"http://www.example.com\", redirect_to_url\n  end\n\n  def test_url_redirect_with_status_hash\n    get :url_redirect_with_status_hash\n    assert_response 301\n    assert_equal \"http://www.example.com\", redirect_to_url\n  end\n\n  def test_relative_url_redirect_with_status\n    get :relative_url_redirect_with_status\n    assert_response 302\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_relative_url_redirect_with_status_hash\n    get :relative_url_redirect_with_status_hash\n    assert_response 301\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_relative_url_redirect_host_with_port\n    request.host = \"test.host:1234\"\n    get :relative_url_redirect_with_status\n    assert_response 302\n    assert_equal \"http://test.host:1234/things/stuff\", redirect_to_url\n  end\n\n  def test_simple_redirect_using_options\n    get :host_redirect\n    assert_response :redirect\n    assert_redirected_to action: \"other_host\", only_path: false, host: \"other.test.host\"\n  end\n\n  def test_module_redirect\n    get :module_redirect\n    assert_response :redirect\n    assert_redirected_to \"http://test.host/module_test/module_redirect/hello_world\"\n  end\n\n  def test_module_redirect_using_options\n    get :module_redirect\n    assert_response :redirect\n    assert_redirected_to controller: \"module_test/module_redirect\", action: \"hello_world\"\n  end\n\n  def test_redirect_to_url\n    get :redirect_to_url\n    assert_response :redirect\n    assert_redirected_to \"http://www.rubyonrails.org/\"\n  end\n\n  def test_redirect_to_url_with_stringlike\n    get :redirect_to_url_with_stringlike\n    assert_response :redirect\n    assert_redirected_to \"http://www.rubyonrails.org/\"\n  end\n\n  def test_redirect_to_url_with_unescaped_query_string\n    get :redirect_to_url_with_unescaped_query_string\n    assert_response :redirect\n    assert_redirected_to \"http://example.com/query?status=new\"\n  end\n\n  def test_redirect_to_url_with_complex_scheme\n    get :redirect_to_url_with_complex_scheme\n    assert_response :redirect\n    assert_equal \"x-test+scheme.complex:redirect\", redirect_to_url\n  end\n\n  def test_redirect_to_path_relative_url\n    get :redirect_to_path_relative_url\n    assert_response :redirect\n    assert_equal \"http://test.hostexample.com\", redirect_to_url\n  end\n\n  def test_redirect_to_url_with_path_relative_url_starting_with_an_at\n    get :redirect_to_path_relative_url_starting_with_an_at\n    assert_response :redirect\n    assert_equal \"http://test.host@example.com\", redirect_to_url\n  end\n\n  def test_redirect_to_query_string_url\n    get :redirect_to_query_string_url\n    assert_response :redirect\n    assert_equal \"http://test.host?foo=bar\", redirect_to_url\n  end\n\n  def test_redirect_to_url_with_network_path_reference\n    get :redirect_to_url_with_network_path_reference\n    assert_response :redirect\n    assert_equal \"//www.rubyonrails.org/\", redirect_to_url\n  end\n\n  def test_redirect_back\n    referer = \"http://www.example.com/coming/from\"\n    @request.env[\"HTTP_REFERER\"] = referer\n\n    get :redirect_back_with_status\n\n    assert_response 307\n    assert_equal referer, redirect_to_url\n  end\n\n  def test_redirect_back_with_no_referer\n    get :redirect_back_with_status\n\n    assert_response 307\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_redirect_back_with_no_referer_redirects_to_another_host\n    get :redirect_back_with_status_and_fallback_location_to_another_host\n\n    assert_response 307\n    assert_equal \"http://www.rubyonrails.org/\", redirect_to_url\n  end\n\n  def test_safe_redirect_back_from_other_host\n    @request.env[\"HTTP_REFERER\"] = \"http://another.host/coming/from\"\n    get :safe_redirect_back_with_status\n\n    assert_response 307\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_safe_redirect_back_from_the_same_host\n    referer = \"http://test.host/coming/from\"\n    @request.env[\"HTTP_REFERER\"] = referer\n    get :safe_redirect_back_with_status\n\n    assert_response 307\n    assert_equal referer, redirect_to_url\n  end\n\n  def test_safe_redirect_back_with_no_referer\n    get :safe_redirect_back_with_status\n\n    assert_response 307\n    assert_equal \"http://test.host/things/stuff\", redirect_to_url\n  end\n\n  def test_safe_redirect_back_with_no_referer_redirects_to_another_host\n    get :safe_redirect_back_with_status_and_fallback_location_to_another_host\n\n    assert_response 307\n    assert_equal \"http://www.rubyonrails.org/\", redirect_to_url\n  end\n\n  def test_safe_redirect_to_root\n    get :safe_redirect_to_root\n\n    assert_equal \"http://test.host/\", redirect_to_url\n  end\n\n  def test_redirect_back_with_explicit_fallback_kwarg\n    referer = \"http://www.example.com/coming/from\"\n    @request.env[\"HTTP_REFERER\"] = referer\n\n    get :redirect_back_with_explicit_fallback_kwarg\n\n    assert_response 307\n    assert_equal referer, redirect_to_url\n  end\n\n  def test_redirect_to_record\n    with_routing do |set|\n      set.draw do\n        resources :workshops\n\n        ActionDispatch.deprecator.silence do\n          get \":controller/:action\"\n        end\n      end\n\n      get :redirect_to_existing_record\n      assert_equal \"http://test.host/workshops/5\", redirect_to_url\n      assert_redirected_to Workshop.new(5)\n\n      get :redirect_to_new_record\n      assert_equal \"http://test.host/workshops\", redirect_to_url\n      assert_redirected_to Workshop.new(nil)\n    end",
    "comment": "empty method not used anywhere to ensure methods like `status` and `location` aren't called on `redirect_to` calls",
    "label": "",
    "id": "641"
  },
  {
    "raw_code": "def test_should_allow_non_get_js_without_xhr_header\n    initialize_csrf_token\n    assert_cross_origin_not_blocked { post :same_origin_js, params: { custom_authenticity_token: @token } }\n    assert_cross_origin_not_blocked { post :same_origin_js, params: { format: \"js\", custom_authenticity_token: @token } }\n    assert_cross_origin_not_blocked do\n      @request.accept = \"text/javascript\"\n      post :negotiate_same_origin, params: { custom_authenticity_token: @token }\n    end",
    "comment": "Allow non-GET requests since GET is all a remote <script> tag can muster.",
    "label": "",
    "id": "642"
  },
  {
    "raw_code": "def assert_simply_restful_for(controller_name, options = {})\n      assert_restful_routes_for       controller_name, options\n      assert_restful_named_routes_for controller_name, nil, options\n    end",
    "comment": "runs assert_restful_routes_for and assert_restful_named_routes for on the controller_name and options, without passing a block.",
    "label": "",
    "id": "643"
  },
  {
    "raw_code": "def assert_restful_named_routes_for(controller_name, singular_name = nil, options = {})\n      if singular_name.is_a?(Hash)\n        options       = singular_name\n        singular_name = nil\n      end",
    "comment": "test named routes like foo_path and foos_path map to the correct options.",
    "label": "",
    "id": "644"
  },
  {
    "raw_code": "def test_route_with_text_default\n    rs.draw do\n      get \"page/:id\" => \"content#show_page\", :id => 1\n\n      ActionDispatch.deprecator.silence do\n        get \":controller/:action/:id\"\n      end",
    "comment": "For newer revision",
    "label": "",
    "id": "645"
  },
  {
    "raw_code": "def test_send_file_headers_bang\n    # Do it a few times: the resulting headers should be identical\n    # no matter how many times you send with the same options.\n    # Test resolving Ticket #458.\n    5.times do\n      get :test_send_file_headers_bang\n\n      assert_equal \"image/png\", response.content_type\n      assert_equal %(disposition; filename=\"filename\"; filename*=UTF-8''filename), response.get_header(\"Content-Disposition\")\n      assert_equal \"binary\", response.get_header(\"Content-Transfer-Encoding\")\n    end",
    "comment": "Test that send_file_headers! is setting the correct HTTP headers.",
    "label": "",
    "id": "646"
  },
  {
    "raw_code": "def leave_alone\n      head :ok\n    end",
    "comment": "Render a head response, but don't touch default headers",
    "label": "",
    "id": "647"
  },
  {
    "raw_code": "def each\n    end",
    "comment": "We're obliged to implement this (even though it doesn't actually get called here) to properly comply with the Rack SPEC",
    "label": "",
    "id": "648"
  },
  {
    "raw_code": "def test_url_for_with_no_side_effects\n    draw do\n      get \"/projects/status(.:format)\"\n    end",
    "comment": "tests the use of dup in url_for",
    "label": "",
    "id": "649"
  },
  {
    "raw_code": "def test_named_route_with_no_side_effects\n    draw do\n      resources :customers do\n        get \"profile\", on: :member\n      end",
    "comment": "tests the arguments modification free version of define_hash_access",
    "label": "",
    "id": "650"
  },
  {
    "raw_code": "def get(path, **options)\n      options[:headers] ||= {}\n      options[:headers].tap do |config|\n        config[\"action_dispatch.secret_key_base\"] = SessionSecret\n        config[\"action_dispatch.authenticated_encrypted_cookie_salt\"] = SessionSalt\n        config[\"action_dispatch.use_authenticated_cookie_encryption\"] = true\n\n        config[\"action_dispatch.key_generator\"] ||= Generator\n        config[\"action_dispatch.cookies_rotations\"] ||= Rotations\n\n        config[\"action_dispatch.cookies_same_site_protection\"] ||= SameSite\n      end",
    "comment": "Overwrite `get` to set env hash",
    "label": "",
    "id": "651"
  },
  {
    "raw_code": "def test_match_same_paths\n          table = tt %w{\n            /articles/new(.:format)\n            /articles/new(.:format)\n          }\n\n          sim = Simulator.new table\n\n          memos = sim.memos \"/articles/new\"\n          assert_equal 2, memos.length\n        end",
    "comment": " Identical Routes may have different restrictions.",
    "label": "",
    "id": "652"
  },
  {
    "raw_code": "def self.permitted_caller?\n      caller_locations.any? do |loc|\n        # Our parser calls Rack's to prepopulate caches\n        loc.path.end_with?(\"lib/action_dispatch/http/request.rb\") && loc.base_label == \"request_parameters_list\" ||\n          # and as a fallback for older Rack versions\n          loc.path.end_with?(\"lib/action_dispatch/http/request.rb\") && loc.base_label == \"fallback_request_parameters\" ||\n          # This specifically tests that a \"pure\" Rack middleware\n          # doesn't interfere with our parsing\n          (loc.path.end_with?(\"test/dispatch/request/query_string_parsing_test.rb\") && loc.base_label == \"populate_rack_cache\") ||\n          # Rack::MethodOverride obviously uses Rack's parsing, and\n          # that's fine: it's looking for a simple top-level key.\n          # Checking for a specific internal method is fragile, but we\n          # don't want to ignore any app that happens to have\n          # MethodOverride on its call stack!\n          (loc.path.end_with?(\"lib/rack/method_override.rb\") && loc.base_label == \"method_override_param\")\n      end",
    "comment": "Single list of permitted callers -- we don't care about GET vs POST",
    "label": "",
    "id": "653"
  },
  {
    "raw_code": "def rich_textarea_tag(name, value = nil, options = {})\n      options = options.symbolize_keys\n      form = options.delete(:form)\n\n      options[:input] ||= \"trix_input_#{ActionText::TagHelper.id += 1}\"\n      options[:class] ||= \"trix-content\"\n\n      options[:data] ||= {}\n      options[:data][:direct_upload_url] ||= main_app.rails_direct_uploads_url\n      options[:data][:blob_url_template] ||= main_app.rails_service_blob_url(\":signed_id\", \":filename\")\n\n      editor_tag = content_tag(\"trix-editor\", \"\", options)\n      input_tag = hidden_field_tag(name, value.try(:to_trix_html) || value, id: options[:input], form: form)\n\n      input_tag + editor_tag\n    end",
    "comment": "Returns a `trix-editor` tag that instantiates the Trix JavaScript editor as well as a hidden field that Trix will write to on changes, so the content will be sent on form submissions.  #### Options *   `:class` - Defaults to \"trix-content\" so that default styles will be applied. Setting this to a different value will prevent default styles from being applied. *   `[:data][:direct_upload_url]` - Defaults to `rails_direct_uploads_url`. *   `[:data][:blob_url_template]` - Defaults to `rails_service_blob_url(\":signed_id\", \":filename\")`.   #### Example  rich_textarea_tag \"content\", message.content # <input type=\"hidden\" name=\"content\" id=\"trix_input_post_1\"> # <trix-editor id=\"content\" input=\"trix_input_post_1\" class=\"trix-content\" ...></trix-editor>",
    "label": "",
    "id": "654"
  },
  {
    "raw_code": "def rich_textarea(object_name, method, options = {})\n      Tags::ActionText.new(object_name, method, self, options).render\n    end",
    "comment": "Returns a `trix-editor` tag that instantiates the Trix JavaScript editor as well as a hidden field that Trix will write to on changes, so the content will be sent on form submissions.  #### Options *   `:class` - Defaults to \"trix-content\" which ensures default styling is applied. *   `:value` - Adds a default value to the HTML input tag. *   `[:data][:direct_upload_url]` - Defaults to `rails_direct_uploads_url`. *   `[:data][:blob_url_template]` - Defaults to `rails_service_blob_url(\":signed_id\", \":filename\")`.   #### Example rich_textarea :message, :content # <input type=\"hidden\" name=\"message[content]\" id=\"message_content_trix_input_message_1\"> # <trix-editor id=\"content\" input=\"message_content_trix_input_message_1\" class=\"trix-content\" ...></trix-editor>  rich_textarea :message, :content, value: \"<h1>Default message</h1>\" # <input type=\"hidden\" name=\"message[content]\" id=\"message_content_trix_input_message_1\" value=\"<h1>Default message</h1>\"> # <trix-editor id=\"content\" input=\"message_content_trix_input_message_1\" class=\"trix-content\" ...></trix-editor>",
    "label": "",
    "id": "655"
  },
  {
    "raw_code": "def rich_textarea(method, options = {})\n      @template.rich_textarea(@object_name, method, objectify_options(options))\n    end",
    "comment": "Wraps ActionView::Helpers::FormHelper#rich_textarea for form builders:  <%= form_with model: @message do |f| %> <%= f.rich_textarea :content %> <% end %>  Please refer to the documentation of the base helper for details.",
    "label": "",
    "id": "656"
  },
  {
    "raw_code": "def to_plain_text\n      body&.to_plain_text.to_s\n    end",
    "comment": "Returns a plain-text version of the markup contained by the `body` attribute, with tags removed but HTML entities encoded.  message = Message.create!(content: \"<h1>Funny times!</h1>\") message.content.to_plain_text # => \"Funny times!\"  NOTE: that the returned string is not HTML safe and should not be rendered in browsers.  message = Message.create!(content: \"&lt;script&gt;alert()&lt;/script&gt;\") message.content.to_plain_text # => \"<script>alert()</script>\"",
    "label": "",
    "id": "657"
  },
  {
    "raw_code": "def to_trix_html\n      body&.to_trix_html\n    end",
    "comment": "Returns the `body` attribute in a format that makes it editable in the Trix editor. Previews of attachments are rendered inline.  content = \"<h1>Funny Times!</h1><figure data-trix-attachment='{\\\"sgid\\\":\\\"...\"\\}'></figure>\" message = Message.create!(content: content) message.content.to_trix_html # => # <div class=\"trix-content\"> #   <h1>Funny times!</h1> #   <figure data-trix-attachment='{\\\"sgid\\\":\\\"...\"\\}'> #      <img src=\"http://example.org/rails/active_storage/.../funny.jpg\"> #   </figure> # </div>",
    "label": "",
    "id": "658"
  },
  {
    "raw_code": "def from_node(node)\n        if attachable = attachable_from_sgid(node[\"sgid\"])\n          attachable\n        elsif attachable = ActionText::Attachables::ContentAttachment.from_node(node)\n          attachable\n        elsif attachable = ActionText::Attachables::RemoteImage.from_node(node)\n          attachable\n        else\n          ActionText::Attachables::MissingAttachable.new(node[\"sgid\"])\n        end",
    "comment": "Extracts the `ActionText::Attachable` from the attachment HTML node:  person = Person.create! name: \"Javan\" html = %Q(<action-text-attachment sgid=\"#{person.attachable_sgid}\"></action-text-attachment>) fragment = ActionText::Fragment.wrap(html) attachment_node = fragment.find_all(ActionText::Attachment.tag_name).first ActionText::Attachable.from_node(attachment_node) # => person",
    "label": "",
    "id": "659"
  },
  {
    "raw_code": "def to_missing_attachable_partial_path\n        ActionText::Attachables::MissingAttachable::DEFAULT_PARTIAL_PATH\n      end",
    "comment": "Returns the path to the partial that is used for rendering missing attachables. Defaults to \"action_text/attachables/missing_attachable\".  Override to render a different partial:  class User < ApplicationRecord def self.to_missing_attachable_partial_path \"users/missing_attachable\" end end",
    "label": "",
    "id": "660"
  },
  {
    "raw_code": "def attachable_sgid\n      to_sgid(expires_in: nil, for: LOCATOR_NAME).to_s\n    end",
    "comment": "Returns the Signed Global ID for the attachable. The purpose of the ID is set to 'attachable' so it can't be reused for other purposes.",
    "label": "",
    "id": "661"
  },
  {
    "raw_code": "def to_trix_content_attachment_partial_path\n      to_partial_path\n    end",
    "comment": "Returns the path to the partial that is used for rendering the attachable in Trix. Defaults to `to_partial_path`.  Override to render a different partial:  class User < ApplicationRecord def to_trix_content_attachment_partial_path \"users/trix_content_attachment\" end end",
    "label": "",
    "id": "662"
  },
  {
    "raw_code": "def to_attachable_partial_path\n      to_partial_path\n    end",
    "comment": "Returns the path to the partial that is used for rendering the attachable. Defaults to `to_partial_path`.  Override to render a different partial:  class User < ApplicationRecord def to_attachable_partial_path \"users/attachable\" end end",
    "label": "",
    "id": "663"
  },
  {
    "raw_code": "def to_plain_text\n      if respond_to?(:attachable_plain_text_representation)\n        attachable_plain_text_representation(caption)\n      else\n        caption.to_s\n      end",
    "comment": "Converts the attachment to plain text.  attachable = ActiveStorage::Blob.find_by filename: \"racecar.jpg\" attachment = ActionText::Attachment.from_attachable(attachable) attachment.to_plain_text # => \"[racecar.jpg]\"  Use the `caption` when set:  attachment = ActionText::Attachment.from_attachable(attachable, caption: \"Vroom vroom\") attachment.to_plain_text # => \"[Vroom vroom]\"  The presentation can be overridden by implementing the `attachable_plain_text_representation` method:  class Person < ApplicationRecord include ActionText::Attachable  def attachable_plain_text_representation \"[#{name}]\" end end  attachable = Person.create! name: \"Javan\" attachment = ActionText::Attachment.from_attachable(attachable) attachment.to_plain_text # => \"[Javan]\"",
    "label": "",
    "id": "664"
  },
  {
    "raw_code": "def to_html\n      HtmlConversion.node_to_html(node)\n    end",
    "comment": "Converts the attachment to HTML.  attachable = Person.create! name: \"Javan\" attachment = ActionText::Attachment.from_attachable(attachable) attachment.to_html # => \"<action-text-attachment sgid=\\\"BAh7CEk...",
    "label": "",
    "id": "665"
  },
  {
    "raw_code": "def has_rich_text(name, encrypted: false, strict_loading: strict_loading_by_default, store_if_blank: true)\n        class_eval <<-CODE, __FILE__, __LINE__ + 1\n          def #{name}\n            rich_text_#{name} || build_rich_text_#{name}\n          end\n\n          def #{name}?\n            rich_text_#{name}.present?\n          end\n        CODE\n\n        if store_if_blank\n          class_eval <<-CODE, __FILE__, __LINE__ + 1\n            def #{name}=(body)\n              self.#{name}.body = body\n            end\n          CODE\n        else\n          class_eval <<-CODE, __FILE__, __LINE__ + 1\n            def #{name}=(body)\n              if body.present?\n                self.#{name}.body = body\n              else\n                if #{name}?\n                  self.#{name}.body = body\n                  self.#{name}.mark_for_destruction\n                end\n              end",
    "comment": "Provides access to a dependent RichText model that holds the body and attachments for a single named rich text attribute. This dependent attribute is lazily instantiated and will be auto-saved when it's been changed. Example:  class Message < ActiveRecord::Base has_rich_text :content end  message = Message.create!(content: \"<h1>Funny times!</h1>\") message.content? #=> true message.content.to_s # => \"<h1>Funny times!</h1>\" message.content.to_plain_text # => \"Funny times!\"  The dependent RichText model will also automatically process attachments links as sent via the Trix-powered editor. These attachments are associated with the RichText model using Active Storage.  If you wish to preload the dependent RichText model, you can use the named scope:  Message.all.with_rich_text_content # Avoids N+1 queries when you just want the body, not the attachments. Message.all.with_rich_text_content_and_embeds # Avoids N+1 queries when you just want the body and attachments. Message.all.with_all_rich_text # Loads all rich text associations.  #### Options  *   `:encrypted` - Pass true to encrypt the rich text attribute. The encryption will be non-deterministic. See `ActiveRecord::Encryption::EncryptableRecord.encrypts`. Default: false.  *   `:strict_loading` - Pass true to force strict loading. When omitted, `strict_loading:` will be set to the value of the `strict_loading_by_default` class attribute (false by default).  *   `:store_if_blank` - Pass false to not create RichText records with empty values, if a blank value is provided. Default: true.   Note: Action Text relies on polymorphic associations, which in turn store class names in the database. When renaming classes that use `has_rich_text`, make sure to also update the class names in the `action_text_rich_texts.record_type` polymorphic type column of the corresponding rows.",
    "label": "",
    "id": "666"
  },
  {
    "raw_code": "def with_all_rich_text\n        includes(rich_text_association_names)\n      end",
    "comment": "Eager load all dependent RichText models in bulk.",
    "label": "",
    "id": "667"
  },
  {
    "raw_code": "def rich_text_association_names\n        reflect_on_all_associations(:has_one).collect(&:name).select { |n| n.start_with?(\"rich_text_\") }\n      end",
    "comment": "Returns the names of all rich text associations.",
    "label": "",
    "id": "668"
  },
  {
    "raw_code": "def links\n      @links ||= fragment.find_all(\"a[href]\").map { |a| a[\"href\"] }.uniq\n    end",
    "comment": "Extracts links from the HTML fragment:  html = '<a href=\"http://example.com/\">Example</a>' content = ActionText::Content.new(html) content.links # => [\"http://example.com/\"]",
    "label": "",
    "id": "669"
  },
  {
    "raw_code": "def attachments\n      @attachments ||= attachment_nodes.map do |node|\n        attachment_for_node(node)\n      end",
    "comment": "Extracts ActionText::Attachment objects from the HTML fragment:  attachable = ActiveStorage::Blob.first html = %Q(<action-text-attachment sgid=\"#{attachable.attachable_sgid}\" caption=\"Captioned\"></action-text-attachment>) content = ActionText::Content.new(html) content.attachments # => [#<ActionText::Attachment attachable=#<ActiveStorage::Blob...",
    "label": "",
    "id": "670"
  },
  {
    "raw_code": "def attachables\n      @attachables ||= attachment_nodes.map do |node|\n        ActionText::Attachable.from_node(node)\n      end",
    "comment": "Extracts ActionText::Attachable objects from the HTML fragment:  attachable = ActiveStorage::Blob.first html = %Q(<action-text-attachment sgid=\"#{attachable.attachable_sgid}\" caption=\"Captioned\"></action-text-attachment>) content = ActionText::Content.new(html) content.attachables # => [attachable]",
    "label": "",
    "id": "671"
  },
  {
    "raw_code": "def to_plain_text\n      render_attachments(with_full_attributes: false, &:to_plain_text).fragment.to_plain_text\n    end",
    "comment": "Returns a plain-text version of the markup contained by the content, with tags removed but HTML entities encoded.  content = ActionText::Content.new(\"<h1>Funny times!</h1>\") content.to_plain_text # => \"Funny times!\"  content = ActionText::Content.new(\"<div onclick='action()'>safe<script>unsafe</script></div>\") content.to_plain_text # => \"safeunsafe\"  NOTE: that the returned string is not HTML safe and should not be rendered in browsers without additional sanitization.  content = ActionText::Content.new(\"&lt;script&gt;alert()&lt;/script&gt;\") content.to_plain_text # => \"<script>alert()</script>\" ActionText::ContentHelper.sanitizer.sanitize(content.to_plain_text) # => \"\"",
    "label": "",
    "id": "672"
  },
  {
    "raw_code": "def to_s\n      to_rendered_html_with_layout\n    end",
    "comment": "Safely transforms Content into an HTML String.  content = ActionText::Content.new(content: \"<h1>Funny times!</h1>\") content.to_s # => \"<h1>Funny times!</h1>\"  content = ActionText::Content.new(\"<div onclick='action()'>safe<script>unsafe</script></div>\") content.to_s # => \"<div>safeunsafe</div>\"",
    "label": "",
    "id": "673"
  },
  {
    "raw_code": "def self.attachment(fixture_set_name, label, column_type: :integer)\n      signed_global_id = ActiveRecord::FixtureSet.signed_global_id fixture_set_name, label,\n        column_type: column_type, for: ActionText::Attachable::LOCATOR_NAME\n\n      %(<#{Attachment.tag_name} sgid=\"#{signed_global_id}\"></#{Attachment.tag_name}>)\n    end",
    "comment": "Fixtures support Action Text attachments as part of their `body` HTML.  ### Examples  For example, consider a second `Article` fixture declared in `test/fixtures/articles.yml`:  second: title: Another Article  You can attach a mention of `articles(:first)` to `second`'s `content` by embedding a call to `ActionText::FixtureSet.attachment` in the `body:` value in `test/fixtures/action_text/rich_texts.yml`:  second: record: second (Article) name: content body: <div>Hello, <%= ActionText::FixtureSet.attachment(\"articles\", :first) %></div> ",
    "label": "",
    "id": "674"
  },
  {
    "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of Action Text as a `Gem::Version`.",
    "label": "",
    "id": "675"
  },
  {
    "raw_code": "def fill_in_rich_textarea(locator = nil, with:, **)\n      find(:rich_textarea, locator, **).execute_script(<<~JS, with.to_s)\n        if (\"value\" in this) {\n          this.value = arguments[0]\n        } else {\n          this.editor.loadHTML(arguments[0])\n        }\n      JS\n    end",
    "comment": "Locates a Trix editor and fills it in with the given HTML.  The editor can be found by:  *   its `id` *   its `placeholder` *   the text from its `label` element *   its `aria-label` *   the `name` of its input  Additional options are forwarded to Capybara as filters  Examples:  # <trix-editor id=\"message_content\" ...></trix-editor> fill_in_rich_textarea \"message_content\", with: \"Hello <em>world!</em>\"  # <trix-editor placeholder=\"Your message here\" ...></trix-editor> fill_in_rich_textarea \"Your message here\", with: \"Hello <em>world!</em>\"  # <label for=\"message_content\">Message content</label> # <trix-editor id=\"message_content\" ...></trix-editor> fill_in_rich_textarea \"Message content\", with: \"Hello <em>world!</em>\"  # <trix-editor aria-label=\"Message content\" ...></trix-editor> fill_in_rich_textarea \"Message content\", with: \"Hello <em>world!</em>\"  # <input id=\"trix_input_1\" name=\"message[content]\" type=\"hidden\"> # <trix-editor input=\"trix_input_1\"></trix-editor> fill_in_rich_textarea \"message[content]\", with: \"Hello <em>world!</em>\"",
    "label": "",
    "id": "676"
  },
  {
    "raw_code": "def self.version\n    gem_version\n  end",
    "comment": "Returns the currently loaded version of Action Text as a `Gem::Version`.",
    "label": "",
    "id": "677"
  },
  {
    "raw_code": "def index\n    @messages = Message.all\n  end",
    "comment": "GET /messages",
    "label": "",
    "id": "678"
  },
  {
    "raw_code": "def show\n  end",
    "comment": "GET /messages/1",
    "label": "",
    "id": "679"
  },
  {
    "raw_code": "def new\n    @message = Message.new\n  end",
    "comment": "GET /messages/new",
    "label": "",
    "id": "680"
  },
  {
    "raw_code": "def edit\n  end",
    "comment": "GET /messages/1/edit",
    "label": "",
    "id": "681"
  },
  {
    "raw_code": "def create\n    @message = Message.new(message_params)\n\n    if @message.save\n      redirect_to @message, notice: 'Message was successfully created.'\n    else\n      render :new, status: :unprocessable_entity\n    end",
    "comment": "POST /messages",
    "label": "",
    "id": "682"
  },
  {
    "raw_code": "def update\n    if @message.update(message_params)\n      redirect_to @message, notice: 'Message was successfully updated.'\n    else\n      render :edit, status: :unprocessable_entity\n    end",
    "comment": "PATCH/PUT /messages/1",
    "label": "",
    "id": "683"
  },
  {
    "raw_code": "def destroy\n    @message.destroy\n    redirect_to messages_url, notice: 'Message was successfully destroyed.'\n  end",
    "comment": "DELETE /messages/1",
    "label": "",
    "id": "684"
  },
  {
    "raw_code": "def set_message\n      @message = Message.find(params[:id])\n    end",
    "comment": "Use callbacks to share common setup or constraints between actions.",
    "label": "",
    "id": "685"
  },
  {
    "raw_code": "def message_params\n      params.expect(message: [:subject, :content])\n    end",
    "comment": "Only allow a trusted parameter list through.",
    "label": "",
    "id": "686"
  },
  {
    "raw_code": "def self.empty\n      with_view_paths([])\n    end",
    "comment": ":stopdoc:",
    "label": "",
    "id": "687"
  },
  {
    "raw_code": "def initialize(lookup_context, assigns, controller) # :nodoc:\n      @lookup_context = lookup_context\n\n      @view_renderer = ActionView::Renderer.new @lookup_context\n      @current_template = nil\n\n      assign_controller(controller)\n      _prepare_context\n\n      super()\n\n      # Assigns must be called last to minimize the number of shapes\n      assign(assigns)\n    end",
    "comment": ":startdoc:",
    "label": "",
    "id": "688"
  },
  {
    "raw_code": "def _prepare_context\n      @view_flow     = OutputFlow.new\n      @output_buffer = ActionView::OutputBuffer.new\n      @virtual_path  = nil\n    end",
    "comment": "Prepares the context by setting the appropriate instance variables.",
    "label": "",
    "id": "689"
  },
  {
    "raw_code": "def _layout_for(name = nil)\n      name ||= :layout\n      view_flow.get(name).html_safe\n    end",
    "comment": "Encapsulates the interaction with the view flow so it returns the correct buffer on +yield+. This is usually overwritten by helpers to add more behavior.",
    "label": "",
    "id": "690"
  },
  {
    "raw_code": "def digest(name:, format: nil, finder:, dependencies: nil)\n        if dependencies.nil? || dependencies.empty?\n          cache_key = \"#{name}.#{format}\"\n        else\n          dependencies_suffix = dependencies.flatten.tap(&:compact!).join(\".\")\n          cache_key = \"#{name}.#{format}.#{dependencies_suffix}\"\n        end",
    "comment": "Supported options:  * <tt>name</tt>         - Template name * <tt>format</tt>       - Template format * +finder+              - An instance of ActionView::LookupContext * <tt>dependencies</tt> - An array of dependent views",
    "label": "",
    "id": "691"
  },
  {
    "raw_code": "def tree(name, finder, partial = false, seen = {})\n        logical_name = name.gsub(%r|/_|, \"/\")\n        interpolated = name.include?(\"#\")\n\n        path = TemplatePath.parse(name)\n\n        if !interpolated && (template = find_template(finder, path.name, [path.prefix], partial, []))\n          if node = seen[template.identifier] # handle cycles in the tree\n            node\n          else\n            node = seen[template.identifier] = Node.create(name, logical_name, template, partial)\n\n            deps = DependencyTracker.find_dependencies(name, template, finder.view_paths)\n            deps.uniq { |n| n.gsub(%r|/_|, \"/\") }.each do |dep_file|\n              node.children << tree(dep_file, finder, true, seen)\n            end",
    "comment": "Create a dependency tree for template named +name+.",
    "label": "",
    "id": "692"
  },
  {
    "raw_code": "def get(key)\n      @content[key]\n    end",
    "comment": "Called by _layout_for to read stored values.",
    "label": "",
    "id": "693"
  },
  {
    "raw_code": "def set(key, value)\n      @content[key] = ActiveSupport::SafeBuffer.new(value.to_s)\n    end",
    "comment": "Called by each renderer object to set the layout contents.",
    "label": "",
    "id": "694"
  },
  {
    "raw_code": "def append(key, value)\n      @content[key] << value.to_s\n    end",
    "comment": "Called by content_for",
    "label": "",
    "id": "695"
  },
  {
    "raw_code": "def get(key)\n      return super if @content.key?(key)\n\n      if inside_fiber?\n        view = @view\n\n        begin\n          @waiting_for = key\n          view.output_buffer, @parent = @child, view.output_buffer\n          Fiber.yield\n        ensure\n          @waiting_for = nil\n          view.output_buffer, @child = @parent, view.output_buffer\n        end",
    "comment": "Try to get stored content. If the content is not available and we're inside the layout fiber, then it will begin waiting for the given key and yield.",
    "label": "",
    "id": "696"
  },
  {
    "raw_code": "def append!(key, value)\n      super\n      @fiber.resume if @waiting_for == key\n    end",
    "comment": "Appends the contents for the given key. This is called by providing and resuming back to the fiber, if that's the key it's waiting for.",
    "label": "",
    "id": "697"
  },
  {
    "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of Action View as a +Gem::Version+.",
    "label": "",
    "id": "698"
  },
  {
    "raw_code": "def _conditional_layout?\n            return unless super\n\n            conditions = _layout_conditions\n\n            if only = conditions[:only]\n              only.include?(action_name)\n            elsif except = conditions[:except]\n              !except.include?(action_name)\n            else\n              true\n            end",
    "comment": "Determines whether the current action has a layout definition by checking the action name against the :only and :except conditions set by the <tt>layout</tt> method.  ==== Returns * <tt>Boolean</tt> - True if the action has a layout definition, false otherwise.",
    "label": "",
    "id": "699"
  },
  {
    "raw_code": "def layout(layout, conditions = {})\n        include LayoutConditions unless conditions.empty?\n\n        conditions.each { |k, v| conditions[k] = Array(v).map(&:to_s) }\n        self._layout_conditions = conditions\n\n        self._layout = layout\n        _write_layout_method\n      end",
    "comment": "Specify the layout to use for this class.  If the specified layout is a: String:: the String is the template name Symbol:: call the method specified by the symbol Proc::   call the passed Proc false::  There is no layout true::   raise an ArgumentError nil::    Force default layout behavior with inheritance  Return value of +Proc+ and +Symbol+ arguments should be +String+, +false+, +true+, or +nil+ with the same meaning as described above.  ==== Parameters  * <tt>layout</tt> - The layout to use.  ==== Options (conditions)  * +:only+   - A list of actions to apply this layout to. * +:except+ - Apply this layout to all actions but this one.",
    "label": "",
    "id": "700"
  },
  {
    "raw_code": "def _write_layout_method # :nodoc:\n        silence_redefinition_of_method(:_layout)\n\n        prefixes = /\\blayouts/.match?(_implied_layout_name) ? [] : [\"layouts\"]\n        default_behavior = \"lookup_context.find_all('#{_implied_layout_name}', #{prefixes.inspect}, false, keys, { formats: formats }).first || super\"\n        name_clause = if name\n          default_behavior\n        else\n          <<-RUBY\n            super\n          RUBY\n        end",
    "comment": "Creates a _layout method to be called by _default_layout .  If a layout is not explicitly mentioned then look for a layout with the controller's name. if nothing is found then try same procedure to find super class's layout.",
    "label": "",
    "id": "701"
  },
  {
    "raw_code": "def _layout(lookup_context, formats, keys)\n            if _conditional_layout?\n              #{layout_definition}\n            else\n              #{name_clause}\n            end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "702"
  },
  {
    "raw_code": "def _implied_layout_name\n          controller_path\n        end",
    "comment": "If no layout is supplied, look for a template named the return value of this method.  ==== Returns * <tt>String</tt> - A template name",
    "label": "",
    "id": "703"
  },
  {
    "raw_code": "def action_has_layout?\n      @_action_has_layout\n    end",
    "comment": "Controls whether an action should be rendered using a layout. If you want to disable any <tt>layout</tt> settings for the current action so that it is rendered without a layout then either override this method in your controller to return false for that action or set the <tt>action_has_layout</tt> attribute to false before rendering.",
    "label": "",
    "id": "704"
  },
  {
    "raw_code": "def _layout(*); end\n\n    # Determine the layout for a given name, taking into account the name type.\n    #\n    # ==== Parameters\n    # * <tt>name</tt> - The name of the template\n    def _layout_for_option(name)\n      case name\n      when String     then _normalize_layout(name)\n      when Proc       then name\n      when true       then Proc.new { |lookup_context, formats, keys| _default_layout(lookup_context, formats, keys, true)  }\n      when :default   then Proc.new { |lookup_context, formats, keys| _default_layout(lookup_context, formats, keys, false) }\n      when false, nil then nil\n      else\n        raise ArgumentError,\n          \"String, Proc, :default, true, or false, expected for `layout'; you passed #{name.inspect}\"\n      end\n    end",
    "comment": "This will be overwritten by _write_layout_method",
    "label": "",
    "id": "705"
  },
  {
    "raw_code": "def _default_layout(lookup_context, formats, keys, require_layout = false)\n      begin\n        value = _layout(lookup_context, formats, keys) if action_has_layout?\n      rescue NameError => e\n        raise e, \"Could not render layout: #{e.message}\"\n      end",
    "comment": "Returns the default layout for this controller. Optionally raises an exception if the layout could not be found.  ==== Parameters * <tt>formats</tt> - The formats accepted to this layout * <tt>require_layout</tt> - If set to +true+ and layout is not found, an +ArgumentError+ exception is raised (defaults to +false+)  ==== Returns * <tt>template</tt> - The template object for the default layout (or +nil+)",
    "label": "",
    "id": "706"
  },
  {
    "raw_code": "def details_key # :nodoc:\n        @details_key ||= DetailsKey.details_cache_key(@details) if @cache\n      end",
    "comment": "Calculate the details key. Remove the handlers from calculation to improve performance since the user cannot modify it explicitly.",
    "label": "",
    "id": "707"
  },
  {
    "raw_code": "def disable_cache\n        old_value, @cache = @cache, false\n        yield\n      ensure\n        @cache = old_value\n      end",
    "comment": "Temporary skip passing the details_key forward.",
    "label": "",
    "id": "708"
  },
  {
    "raw_code": "def build_view_paths(paths)\n        if ActionView::PathSet === paths\n          paths\n        else\n          ActionView::PathSet.new(Array(paths))\n        end",
    "comment": "Whenever setting view paths, makes a copy so that we can manipulate them in instance objects as we wish.",
    "label": "",
    "id": "709"
  },
  {
    "raw_code": "def detail_args_for(options) # :doc:\n        return @details, details_key if options.empty? # most common path.\n        user_details = @details.merge(options)\n\n        if @cache\n          details_key = DetailsKey.details_cache_key(user_details)\n        else\n          details_key = nil\n        end",
    "comment": "Compute details hash and key according to user options (e.g. passed from #render).",
    "label": "",
    "id": "710"
  },
  {
    "raw_code": "def normalize_name(name, prefixes)\n        name = name.to_s\n        idx = name.rindex(\"/\")\n        return name, prefixes.presence || [\"\"] unless idx\n\n        path_prefix = name[0, idx]\n        path_prefix = path_prefix.from(1) if path_prefix.start_with?(\"/\")\n        name = name.from(idx + 1)\n\n        if !prefixes || prefixes.empty?\n          prefixes = [path_prefix]\n        else\n          prefixes = prefixes.map { |p| \"#{p}/#{path_prefix}\" }\n        end",
    "comment": "Fix when prefix is specified as part of the template name",
    "label": "",
    "id": "711"
  },
  {
    "raw_code": "def formats=(values)\n      if values\n        values = values.dup\n        values.concat(default_formats) if values.delete \"*/*\"\n        values.uniq!\n\n        unless Template::Types.valid_symbols?(values)\n          invalid_values = values - Template::Types.symbols\n          raise ArgumentError, \"Invalid formats: #{invalid_values.map(&:inspect).join(\", \")}\"\n        end",
    "comment": "Override formats= to expand [\"*/*\"] values and automatically add :html as fallback to :js.",
    "label": "",
    "id": "712"
  },
  {
    "raw_code": "def locale\n      @details[:locale].first\n    end",
    "comment": "Override locale to return a symbol instead of array.",
    "label": "",
    "id": "713"
  },
  {
    "raw_code": "def locale=(value)\n      if value\n        config = I18n.config.respond_to?(:original_config) ? I18n.config.original_config : I18n.config\n        config.locale = value\n      end",
    "comment": "Overload locale= to also set the I18n.locale. If the current I18n.config object responds to original_config, it means that it has a copy of the original I18n configuration and it's acting as proxy, which we need to skip.",
    "label": "",
    "id": "714"
  },
  {
    "raw_code": "def convert_to_model(object)\n      object.respond_to?(:to_model) ? object.to_model : object\n    end",
    "comment": "Converts the given object to an Active Model compliant one.",
    "label": "",
    "id": "715"
  },
  {
    "raw_code": "def dom_class(record_or_class, prefix = nil)\n      singular = model_name_from_record_or_class(record_or_class).param_key\n      prefix ? \"#{prefix}#{JOIN}#{singular}\" : singular\n    end",
    "comment": "The DOM class convention is to use the singular form of an object or class.  dom_class(post)   # => \"post\" dom_class(Person) # => \"person\"  If you need to address multiple instances of the same class in the same view, you can prefix the dom_class:  dom_class(post, :edit)   # => \"edit_post\" dom_class(Person, :edit) # => \"edit_person\"",
    "label": "",
    "id": "716"
  },
  {
    "raw_code": "def dom_id(record_or_class, prefix = nil)\n      raise ArgumentError, \"dom_id must be passed a record_or_class as the first argument, you passed #{record_or_class.inspect}\" unless record_or_class\n\n      record_id = record_key_for_dom_id(record_or_class) unless record_or_class.is_a?(Class)\n      if record_id\n        \"#{dom_class(record_or_class, prefix)}#{JOIN}#{record_id}\"\n      else\n        dom_class(record_or_class, prefix || NEW)\n      end",
    "comment": "The DOM id convention is to use the singular form of an object or class with the id following an underscore. If no id is found, prefix with \"new_\" instead.  dom_id(Post.find(45)) # => \"post_45\" dom_id(Post)          # => \"new_post\"  If you need to address multiple instances of the same class in the same view, you can prefix the dom_id:  dom_id(Post.find(45), :edit) # => \"edit_post_45\" dom_id(Post, :custom)        # => \"custom_post\"",
    "label": "",
    "id": "717"
  },
  {
    "raw_code": "def dom_target(*objects)\n      objects.map! do |object|\n        case object\n        when Symbol, String\n          object\n        when Class\n          dom_class(object)\n        else\n          dom_id(object)\n        end",
    "comment": "The DOM target convention is to concatenate any number of parameters into a string. Records are passed through dom_id, while string and symbols are retained.  dom_target(Post.find(45))                  # => \"post_45\" dom_target(Post.find(45), :edit)           # => \"post_45_edit\" dom_target(Post.find(45), :edit, :special) # => \"post_45_edit_special\" dom_target(Post.find(45), Comment.find(1)) # => \"post_45_comment_1\"",
    "label": "",
    "id": "718"
  },
  {
    "raw_code": "def record_key_for_dom_id(record) # :doc:\n      key = convert_to_model(record).to_key\n      key && key.all? ? key.join(JOIN) : nil\n    end",
    "comment": "Returns a string representation of the key attribute(s) that is suitable for use in an HTML DOM id. This can be overwritten to customize the default generated string representation if desired. If you need to read back a key from a dom_id in order to query for the underlying database record, you should write a helper like 'person_record_from_dom_id' that will extract the key either based on the default implementation (which just joins all key attributes with '_') or on your own overwritten version of the method. By default, this implementation passes the key string through a method that replaces all characters that are invalid inside DOM ids, with valid ones. You need to make sure yourself that your dom ids are valid, in case you override this method.",
    "label": "",
    "id": "719"
  },
  {
    "raw_code": "def process(...) # :nodoc:\n      old_config, I18n.config = I18n.config, I18nProxy.new(I18n.config, lookup_context)\n      super\n    ensure\n      I18n.config = old_config\n    end",
    "comment": "Override process to set up I18n proxy.",
    "label": "",
    "id": "720"
  },
  {
    "raw_code": "def view_context\n      view_context_class.new(lookup_context, view_assigns, self)\n    end",
    "comment": "An instance of a view class. The default view class is ActionView::Base.  The view class must have the following methods:  * <tt>View.new(lookup_context, assigns, controller)</tt> — Create a new ActionView instance for a controller and we can also pass the arguments.  * <tt>View#render(option)</tt> — Returns String with the rendered template.  Override this method in a module to change the default behavior.",
    "label": "",
    "id": "721"
  },
  {
    "raw_code": "def view_renderer # :nodoc:\n      # Lifespan: Per controller\n      @_view_renderer ||= ActionView::Renderer.new(lookup_context)\n    end",
    "comment": "Returns an object that is able to render templates.",
    "label": "",
    "id": "722"
  },
  {
    "raw_code": "def _render_template(options)\n        variant = options.delete(:variant)\n        assigns = options.delete(:assigns)\n        context = view_context\n\n        context.assign assigns if assigns\n        lookup_context.variants = variant if variant\n\n        rendered_template = context.in_rendering_context(options) do |renderer|\n          renderer.render_to_object(context, options)\n        end",
    "comment": "Find and render a template based on the options given.",
    "label": "",
    "id": "723"
  },
  {
    "raw_code": "def _process_format(format)\n        super\n        lookup_context.formats = [format.to_sym] if format.to_sym\n      end",
    "comment": "Assign the rendered format to look up context.",
    "label": "",
    "id": "724"
  },
  {
    "raw_code": "def _normalize_args(action = nil, options = {})\n        options = super(action, options)\n        case action\n        when NilClass\n        when Hash\n          options = action\n        when String, Symbol\n          action = action.to_s\n          key = action.include?(?/) ? :template : :action\n          options[key] = action\n        else\n          if action.respond_to?(:permitted?) && action.permitted?\n            options = action\n          elsif action.respond_to?(:render_in)\n            options[:renderable] = action\n          else\n            options[:partial] = action\n          end",
    "comment": "Normalize args by converting render \"foo\" to render action: \"foo\" and render \"foo/bar\" to render template: \"foo/bar\".",
    "label": "",
    "id": "725"
  },
  {
    "raw_code": "def _process_render_template_options(options)\n        if options[:partial] == true\n          options[:partial] = action_name\n        end",
    "comment": "Normalize options.",
    "label": "",
    "id": "726"
  },
  {
    "raw_code": "def url_for(options = nil)\n      case options\n      when String\n        options\n      when nil\n        super(only_path: _generate_paths_by_default)\n      when Hash\n        options = options.symbolize_keys\n        ensure_only_path_option(options)\n\n        super(options)\n      when ActionController::Parameters\n        ensure_only_path_option(options)\n\n        super(options)\n      when :back\n        _back_url\n      when Array\n        components = options.dup\n        options = components.extract_options!\n        ensure_only_path_option(options)\n\n        if options[:only_path]\n          polymorphic_path(components, options)\n        else\n          polymorphic_url(components, options)\n        end",
    "comment": "Returns the URL for the set of +options+ provided. This takes the same options as +url_for+ in Action Controller (see the documentation for ActionDispatch::Routing::UrlFor#url_for). Note that by default <tt>:only_path</tt> is <tt>true</tt> so you'll get the relative <tt>\"/controller/action\"</tt> instead of the fully qualified URL like <tt>\"http://example.com/controller/action\"</tt>.  ==== Options * <tt>:anchor</tt> - Specifies the anchor name to be appended to the path. * <tt>:only_path</tt> - If true, returns the relative URL (omitting the protocol, host name, and port) (<tt>true</tt> by default unless <tt>:host</tt> is specified). * <tt>:trailing_slash</tt> - If true, adds a trailing slash, as in <tt>\"/archive/2005/\"</tt>. Note that this is currently not recommended since it breaks caching. * <tt>:host</tt> - Overrides the default (current) host if provided. * <tt>:protocol</tt> - Overrides the default (current) protocol if provided. * <tt>:user</tt> - Inline HTTP authentication (only plucked out if <tt>:password</tt> is also present). * <tt>:password</tt> - Inline HTTP authentication (only plucked out if <tt>:user</tt> is also present).  ==== Relying on named routes  Passing a record (like an Active Record) instead of a hash as the options parameter will trigger the named route for that record. The lookup will happen on the name of the class. So passing a Workshop object will attempt to use the +workshop_path+ route. If you have a nested route, such as +admin_workshop_path+ you'll have to call that explicitly (it's impossible for +url_for+ to guess that route).  ==== Implicit Controller Namespacing  Controllers passed in using the +:controller+ option will retain their namespace unless it is an absolute one.  ==== Examples <%= url_for(action: 'index') %> # => /blogs/  <%= url_for(action: 'find', controller: 'books') %> # => /books/find  <%= url_for(action: 'login', controller: 'members', only_path: false, protocol: 'https') %> # => https://www.example.com/members/login/  <%= url_for(action: 'play', anchor: 'player') %> # => /messages/play/#player  <%= url_for(action: 'jump', anchor: 'tax&ship') %> # => /testing/jump/#tax&ship  <%= url_for(Workshop) %> # => /workshops  <%= url_for(Workshop.new) %> # relies on Workshop answering a persisted? call (and in this case returning false) # => /workshops  <%= url_for(@workshop) %> # calls @workshop.to_param which by default returns the id # => /workshops/5  # to_param can be re-defined in a model to provide different URL names: # => /workshops/1-workshop-name  <%= url_for(\"http://www.example.com\") %> # => http://www.example.com  <%= url_for(:back) %> # if request.env[\"HTTP_REFERER\"] is set to \"http://www.example.com\" # => http://www.example.com  <%= url_for(:back) %> # if request.env[\"HTTP_REFERER\"] is not set or is blank # => javascript:history.back()  <%= url_for(action: 'index', controller: 'users') %> # Assuming an \"admin\" namespace # => /admin/users  <%= url_for(action: 'index', controller: '/users') %> # Specify absolute path with beginning slash # => /users",
    "label": "",
    "id": "727"
  },
  {
    "raw_code": "def locals\n      if strict_locals?\n        nil\n      else\n        @locals\n      end",
    "comment": "The locals this template has been or will be compiled for, or nil if this is a strict locals template.",
    "label": "",
    "id": "728"
  },
  {
    "raw_code": "def translate_location(backtrace_location, spot)\n      if handler.respond_to?(:translate_location)\n        handler.translate_location(spot, backtrace_location, encode!) || spot\n      else\n        spot\n      end",
    "comment": "Translate an error location returned by ErrorHighlight to the correct source location inside the template.",
    "label": "",
    "id": "729"
  },
  {
    "raw_code": "def supports_streaming?\n      handler.respond_to?(:supports_streaming?) && handler.supports_streaming?\n    end",
    "comment": "Returns whether the underlying handler supports streaming. If so, a streaming buffer *may* be passed when it starts rendering.",
    "label": "",
    "id": "730"
  },
  {
    "raw_code": "def render(view, locals, buffer = nil, implicit_locals: [], add_to_stack: true, &block)\n      instrument_render_template do\n        compile!(view)\n\n        if strict_locals? && @strict_local_keys && !implicit_locals.empty?\n          locals_to_ignore = implicit_locals - @strict_local_keys\n          locals.except!(*locals_to_ignore)\n        end",
    "comment": "Render a template. If the template was not compiled yet, it is done exactly before rendering.  This method is instrumented as \"!render_template.action_view\". Notice that we use a bang in this instrumentation because you don't want to consume this in production. This is only slow if it's being listened to.",
    "label": "",
    "id": "731"
  },
  {
    "raw_code": "def encode!\n      source = self.source\n\n      return source unless source.encoding == Encoding::BINARY\n\n      # Look for # encoding: *. If we find one, we'll encode the\n      # String in that encoding, otherwise, we'll use the\n      # default external encoding.\n      if source.sub!(LEADING_ENCODING_REGEXP, \"\")\n        encoding = magic_encoding = $1\n      else\n        encoding = Encoding.default_external\n      end",
    "comment": "This method is responsible for properly setting the encoding of the source. Until this point, we assume that the source is BINARY data. If no additional information is supplied, we assume the encoding is the same as <tt>Encoding.default_external</tt>.  The user can also specify the encoding via a comment on the first line of the template (<tt># encoding: NAME-OF-ENCODING</tt>). This will work with any template engine, as we process out the encoding comment before passing the source on to the template engine, leaving a blank line in its stead.",
    "label": "",
    "id": "732"
  },
  {
    "raw_code": "def strict_locals!\n      if @strict_locals == NONE\n        self.source.sub!(STRICT_LOCALS_REGEX, \"\")\n        @strict_locals = $1\n\n        return if @strict_locals.nil? # Magic comment not found\n\n        @strict_locals = \"**nil\" if @strict_locals.blank?\n      end",
    "comment": "This method is responsible for marking a template as having strict locals which means the template can only accept the locals defined in a magic comment. For example, if your template accepts the locals +title+ and +comment_count+, add the following to your template file:  <%# locals: (title: \"Default title\", comment_count: 0) %>  Strict locals are useful for validating template arguments and for specifying defaults.",
    "label": "",
    "id": "733"
  },
  {
    "raw_code": "def strict_locals?\n      strict_locals!\n    end",
    "comment": "Returns whether a template is using strict locals.",
    "label": "",
    "id": "734"
  },
  {
    "raw_code": "def marshal_dump # :nodoc:\n      [ @source, @identifier, @handler, @compiled, @locals, @virtual_path, @format, @variant ]\n    end",
    "comment": "Exceptions are marshalled when using the parallel test runner with DRb, so we need to ensure that references to the template object can be marshalled as well. This means forgoing the marshalling of the compiler mutex and instantiating that again on unmarshalling.",
    "label": "",
    "id": "735"
  },
  {
    "raw_code": "def compile!(view)\n        return if @compiled\n\n        # Templates can be used concurrently in threaded environments\n        # so compilation and any instance variable modification must\n        # be synchronized\n        @compile_mutex.synchronize do\n          # Any thread holding this lock will be compiling the template needed\n          # by the threads waiting. So re-check the @compiled flag to avoid\n          # re-compilation\n          return if @compiled\n\n          mod = view.compiled_method_container\n\n          instrument(\"!compile_template\") do\n            compile(mod)\n          end",
    "comment": "Compile a template. This method ensures a template is compiled just once and removes the source after it is compiled.",
    "label": "",
    "id": "736"
  },
  {
    "raw_code": "def compiled_source\n        set_strict_locals = strict_locals!\n        source = encode!\n        code = @handler.call(self, source)\n\n        method_arguments =\n          if set_strict_locals\n            if set_strict_locals.include?(\"&\")\n              \"local_assigns, output_buffer, #{set_strict_locals}\"\n            else\n              \"local_assigns, output_buffer, #{set_strict_locals}, &_\"\n            end",
    "comment": "This method compiles the source of the template. The compilation of templates involves setting strict_locals! if applicable, encoding the template, and setting frozen string literal.",
    "label": "",
    "id": "737"
  },
  {
    "raw_code": "def compile(mod)\n        begin\n          mod.module_eval(compiled_source, identifier, offset)\n        rescue SyntaxError\n          # Account for when code in the template is not syntactically valid; e.g. if we're using\n          # ERB and the user writes <%= foo( %>, attempting to call a helper `foo` and interpolate\n          # the result into the template, but missing an end parenthesis.\n          raise SyntaxErrorInTemplate.new(self, encode!)\n        end",
    "comment": "Among other things, this method is responsible for properly setting the encoding of the compiled template.  If the template engine handles encodings, we send the encoded String to the engine without further processing. This allows the template engine to support additional mechanisms for specifying the encoding. For instance, ERB supports <%# encoding: %>  Otherwise, after we figure out the correct encoding, we then encode the source into <tt>Encoding.default_internal</tt>. In general, this means that templates will be UTF-8 inside of Rails, regardless of the original source encoding.",
    "label": "",
    "id": "738"
  },
  {
    "raw_code": "def self.virtual(name, prefix, partial)\n      if prefix.empty?\n        \"#{partial ? \"_\" : \"\"}#{name}\"\n      elsif partial\n        \"#{prefix}/_#{name}\"\n      else\n        \"#{prefix}/#{name}\"\n      end",
    "comment": "Convert name, prefix, and partial into a virtual path string",
    "label": "",
    "id": "739"
  },
  {
    "raw_code": "def self.parse(virtual)\n      if nameidx = virtual.rindex(\"/\")\n        prefix = virtual[0, nameidx]\n        name = virtual.from(nameidx + 1)\n        prefix = prefix[1..] if prefix.start_with?(\"/\")\n      else\n        prefix = \"\"\n        name = virtual\n      end",
    "comment": "Build a TemplatePath form a virtual path",
    "label": "",
    "id": "740"
  },
  {
    "raw_code": "def self.build(name, prefix, partial)\n      new name, prefix, partial, virtual(name, prefix, partial)\n    end",
    "comment": "Convert name, prefix, and partial into a TemplatePath",
    "label": "",
    "id": "741"
  },
  {
    "raw_code": "def register_parser(format, callable = nil, &block)\n          parser = callable || block || :itself.to_proc\n          content_class.redefine_method(format) do\n            parser.call(to_s)\n          end",
    "comment": "Register a callable to parse rendered content for a given template format.  Each registered parser will also define a +#rendered.[FORMAT]+ helper method, where +[FORMAT]+ corresponds to the value of the +format+ argument.  By default, ActionView::TestCase defines parsers for:  * +:html+ - returns an instance of +Nokogiri::XML::Node+ * +:json+ - returns an instance of ActiveSupport::HashWithIndifferentAccess  These pre-registered parsers also define corresponding helpers:  * +:html+ - defines +rendered.html+ * +:json+ - defines +rendered.json+  ==== Parameters  [+format+] The name (as a +Symbol+) of the format used to render the content.  [+callable+] The parser. A callable object that accepts the rendered string as its sole argument. Alternatively, the parser can be specified as a block.  ==== Examples  test \"renders HTML\" do article = Article.create!(title: \"Hello, world\")  render partial: \"articles/article\", locals: { article: article }  assert_pattern { rendered.html.at(\"main h1\") => { content: \"Hello, world\" } } end  test \"renders JSON\" do article = Article.create!(title: \"Hello, world\")  render formats: :json, partial: \"articles/article\", locals: { article: article }  assert_pattern { rendered.json => { title: \"Hello, world\" } } end  To parse the rendered content into RSS, register a call to +RSS::Parser.parse+:  register_parser :rss, -> rendered { RSS::Parser.parse(rendered) }  test \"renders RSS\" do article = Article.create!(title: \"Hello, world\")  render formats: :rss, partial: article  assert_equal \"Hello, world\", rendered.rss.items.last.title end  To parse the rendered content into a +Capybara::Simple::Node+, re-register an +:html+ parser with a call to +Capybara.string+:  register_parser :html, -> rendered { Capybara.string(rendered) }  test \"renders HTML\" do article = Article.create!(title: \"Hello, world\")  render partial: article  rendered.html.assert_css \"h1\", text: \"Hello, world\" end ",
    "label": "",
    "id": "742"
  },
  {
    "raw_code": "def document_root_element\n        Rails::Dom::Testing.html_document.parse(@rendered.blank? ? @output_buffer.to_str : @rendered).root\n      end",
    "comment": "Need to experiment if this priority is the best one: rendered => output_buffer",
    "label": "",
    "id": "743"
  },
  {
    "raw_code": "def view\n        @view ||= begin\n          view = @controller.view_context\n          view.singleton_class.include(_helpers)\n          view.extend(Locals)\n          view.rendered_views = rendered_views\n          view.output_buffer = output_buffer\n          view\n        end",
    "comment": "The instance of ActionView::Base that is used by +render+.",
    "label": "",
    "id": "744"
  },
  {
    "raw_code": "def view_assigns\n        Hash[_user_defined_ivars.map do |ivar|\n          [ivar[1..-1].to_sym, instance_variable_get(ivar)]\n        end]\n      end",
    "comment": "Returns a Hash of instance variables and their values, as defined by the user in the test case, which are then assigned to the view being rendered. This is generally intended for internal use and extension frameworks.",
    "label": "",
    "id": "745"
  },
  {
    "raw_code": "def self.version\n    gem_version\n  end",
    "comment": "Returns the currently loaded version of Action View as a +Gem::Version+.",
    "label": "",
    "id": "746"
  },
  {
    "raw_code": "def append_view_path(path)\n        self._view_paths = view_paths + _build_view_paths(path)\n      end",
    "comment": "Append a path to the list of view paths for this controller.  ==== Parameters * <tt>path</tt> - If a String is provided, it gets converted into the default view path. You may also provide a custom view path (see ActionView::PathSet for more information)",
    "label": "",
    "id": "747"
  },
  {
    "raw_code": "def prepend_view_path(path)\n        self._view_paths = _build_view_paths(path) + view_paths\n      end",
    "comment": "Prepend a path to the list of view paths for this controller.  ==== Parameters * <tt>path</tt> - If a String is provided, it gets converted into the default view path. You may also provide a custom view path (see ActionView::PathSet for more information)",
    "label": "",
    "id": "748"
  },
  {
    "raw_code": "def view_paths\n        _view_paths\n      end",
    "comment": "A list of all of the default view paths for this controller.",
    "label": "",
    "id": "749"
  },
  {
    "raw_code": "def view_paths=(paths)\n        self._view_paths = _build_view_paths(paths)\n      end",
    "comment": "Set the view paths.  ==== Parameters * <tt>paths</tt> - If a PathSet is provided, use that; otherwise, process the parameter into a PathSet.",
    "label": "",
    "id": "750"
  },
  {
    "raw_code": "def local_prefixes\n          [controller_path]\n        end",
    "comment": "Override this method in your controller if you want to change paths prefixes for finding views. Prefixes defined here will still be added to parents' <tt>._prefixes</tt>.",
    "label": "",
    "id": "751"
  },
  {
    "raw_code": "def _prefixes # :nodoc:\n      self.class._prefixes\n    end",
    "comment": "The prefixes used in render \"foo\" shortcuts.",
    "label": "",
    "id": "752"
  },
  {
    "raw_code": "def lookup_context\n      @_lookup_context ||=\n        ActionView::LookupContext.new(self.class._view_paths, details_for_lookup, _prefixes)\n    end",
    "comment": "LookupContext is the object responsible for holding all information required for looking up templates, i.e. view paths and details. Check ActionView::LookupContext for more information.",
    "label": "",
    "id": "753"
  },
  {
    "raw_code": "def append_view_path(path)\n      lookup_context.append_view_paths(self.class._build_view_paths(path))\n    end",
    "comment": "Append a path to the list of view paths for the current LookupContext.  ==== Parameters * <tt>path</tt> - If a String is provided, it gets converted into the default view path. You may also provide a custom view path (see ActionView::PathSet for more information)",
    "label": "",
    "id": "754"
  },
  {
    "raw_code": "def prepend_view_path(path)\n      lookup_context.prepend_view_paths(self.class._build_view_paths(path))\n    end",
    "comment": "Prepend a path to the list of view paths for the current LookupContext.  ==== Parameters * <tt>path</tt> - If a String is provided, it gets converted into the default view path. You may also provide a custom view path (see ActionView::PathSet for more information)",
    "label": "",
    "id": "755"
  },
  {
    "raw_code": "def javascript_include_tag(*sources)\n        options = sources.extract_options!.stringify_keys\n        path_options = options.extract!(\"protocol\", \"extname\", \"host\", \"skip_pipeline\").symbolize_keys\n        preload_links = []\n        use_preload_links_header = options[\"preload_links_header\"].nil? ? preload_links_header : options.delete(\"preload_links_header\")\n        nopush = options[\"nopush\"].nil? || options.delete(\"nopush\")\n        crossorigin = options.delete(\"crossorigin\")\n        crossorigin = \"anonymous\" if crossorigin == true\n        integrity = options[\"integrity\"]\n        rel = options[\"type\"] == \"module\" || options[\"type\"] == :module ? \"modulepreload\" : \"preload\"\n\n        sources_tags = sources.uniq.map { |source|\n          href = path_to_javascript(source, path_options)\n          if use_preload_links_header && !options[\"defer\"] && href.present? && !href.start_with?(\"data:\")\n            preload_link = \"<#{href}>; rel=#{rel}; as=script\"\n            preload_link += \"; crossorigin=#{crossorigin}\" unless crossorigin.nil?\n            preload_link += \"; integrity=#{integrity}\" unless integrity.nil?\n            preload_link += \"; nonce=#{content_security_policy_nonce}\" if options[\"nonce\"] == true\n            preload_link += \"; nopush\" if nopush\n            preload_links << preload_link\n          end",
    "comment": "Returns an HTML script tag for each of the +sources+ provided.  Sources may be paths to JavaScript files. Relative paths are assumed to be relative to <tt>assets/javascripts</tt>, full paths are assumed to be relative to the document root. Relative paths are idiomatic, use absolute paths only when needed.  When passing paths, the \".js\" extension is optional. If you do not want \".js\" appended to the path <tt>extname: false</tt> can be set on the options.  You can modify the HTML attributes of the script tag by passing a hash as the last argument.  When the Asset Pipeline is enabled, you can pass the name of your manifest as source, and include other JavaScript or CoffeeScript files inside the manifest.  If the server supports HTTP Early Hints, and the +defer+ option is not enabled, \\Rails will push a <tt>103 Early Hints</tt> response that links to the assets.  ==== Options  When the last parameter is a hash you can add HTML attributes using that parameter. This includes but is not limited to the following options:  * <tt>:extname</tt>  - Append an extension to the generated URL unless the extension already exists. This only applies for relative URLs. * <tt>:protocol</tt>  - Sets the protocol of the generated URL. This option only applies when a relative URL and +host+ options are provided. * <tt>:host</tt>  - When a relative URL is provided the host is added to the that path. * <tt>:skip_pipeline</tt>  - This option is used to bypass the asset pipeline when it is set to true. * <tt>:nonce</tt>  - When set to true, adds an automatic nonce value if you have Content Security Policy enabled. * <tt>:async</tt>  - When set to +true+, adds the +async+ HTML attribute, allowing the script to be fetched in parallel to be parsed and evaluated as soon as possible. * <tt>:defer</tt>  - When set to +true+, adds the +defer+ HTML attribute, which indicates to the browser that the script is meant to be executed after the document has been parsed. Additionally, prevents sending the Preload Links header. * <tt>:nopush</tt>  - Specify if the use of server push is not desired for the script. Defaults to +true+.  Any other specified options will be treated as HTML attributes for the +script+ tag.  For more information regarding how the <tt>:async</tt> and <tt>:defer</tt> options affect the <tt><script></tt> tag, please refer to the {MDN docs}[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script].  ==== Examples  javascript_include_tag \"xmlhr\" # => <script src=\"/assets/xmlhr.debug-1284139606.js\"></script>  javascript_include_tag \"xmlhr\", host: \"localhost\", protocol: \"https\" # => <script src=\"https://localhost/assets/xmlhr.debug-1284139606.js\"></script>  javascript_include_tag \"template.jst\", extname: false # => <script src=\"/assets/template.debug-1284139606.jst\"></script>  javascript_include_tag \"xmlhr.js\" # => <script src=\"/assets/xmlhr.debug-1284139606.js\"></script>  javascript_include_tag \"common.javascript\", \"/elsewhere/cools\" # => <script src=\"/assets/common.javascript.debug-1284139606.js\"></script> #    <script src=\"/elsewhere/cools.debug-1284139606.js\"></script>  javascript_include_tag \"http://www.example.com/xmlhr\" # => <script src=\"http://www.example.com/xmlhr\"></script>  javascript_include_tag \"http://www.example.com/xmlhr.js\" # => <script src=\"http://www.example.com/xmlhr.js\"></script>  javascript_include_tag \"http://www.example.com/xmlhr.js\", nonce: true # => <script src=\"http://www.example.com/xmlhr.js\" nonce=\"...\"></script>  javascript_include_tag \"http://www.example.com/xmlhr.js\", async: true # => <script src=\"http://www.example.com/xmlhr.js\" async=\"async\"></script>  javascript_include_tag \"http://www.example.com/xmlhr.js\", defer: true # => <script src=\"http://www.example.com/xmlhr.js\" defer=\"defer\"></script>",
    "label": "",
    "id": "756"
  },
  {
    "raw_code": "def stylesheet_link_tag(*sources)\n        options = sources.extract_options!.stringify_keys\n        path_options = options.extract!(\"protocol\", \"extname\", \"host\", \"skip_pipeline\").symbolize_keys\n        use_preload_links_header = options[\"preload_links_header\"].nil? ? preload_links_header : options.delete(\"preload_links_header\")\n        preload_links = []\n        crossorigin = options.delete(\"crossorigin\")\n        crossorigin = \"anonymous\" if crossorigin == true\n        nopush = options[\"nopush\"].nil? || options.delete(\"nopush\")\n        integrity = options[\"integrity\"]\n\n        sources_tags = sources.uniq.map { |source|\n          href = path_to_stylesheet(source, path_options)\n          if use_preload_links_header && href.present? && !href.start_with?(\"data:\")\n            preload_link = \"<#{href}>; rel=preload; as=style\"\n            preload_link += \"; crossorigin=#{crossorigin}\" unless crossorigin.nil?\n            preload_link += \"; integrity=#{integrity}\" unless integrity.nil?\n            preload_link += \"; nonce=#{content_security_policy_nonce}\" if options[\"nonce\"] == true\n            preload_link += \"; nopush\" if nopush\n            preload_links << preload_link\n          end",
    "comment": "Returns a stylesheet link tag for the sources specified as arguments.  When passing paths, the <tt>.css</tt> extension is optional. If you don't specify an extension, <tt>.css</tt> will be appended automatically. If you do not want <tt>.css</tt> appended to the path, set <tt>extname: false</tt> in the options. You can modify the link attributes by passing a hash as the last argument.  If the server supports HTTP Early Hints, \\Rails will push a <tt>103 Early Hints</tt> response that links to the assets.  ==== Options  * <tt>:extname</tt>  - Append an extension to the generated URL unless the extension already exists. This only applies for relative URLs. * <tt>:protocol</tt>  - Sets the protocol of the generated URL. This option only applies when a relative URL and +host+ options are provided. * <tt>:host</tt>  - When a relative URL is provided the host is added to the that path. * <tt>:skip_pipeline</tt>  - This option is used to bypass the asset pipeline when it is set to true. * <tt>:nonce</tt>  - When set to true, adds an automatic nonce value if you have Content Security Policy enabled. * <tt>:nopush</tt>  - Specify if the use of server push is not desired for the stylesheet. Defaults to +true+.  ==== Examples  stylesheet_link_tag \"style\" # => <link href=\"/assets/style.css\" rel=\"stylesheet\" />  stylesheet_link_tag \"style.css\" # => <link href=\"/assets/style.css\" rel=\"stylesheet\" />  stylesheet_link_tag \"http://www.example.com/style.css\" # => <link href=\"http://www.example.com/style.css\" rel=\"stylesheet\" />  stylesheet_link_tag \"style.less\", extname: false, skip_pipeline: true, rel: \"stylesheet/less\" # => <link href=\"/stylesheets/style.less\" rel=\"stylesheet/less\">  stylesheet_link_tag \"style\", media: \"all\" # => <link href=\"/assets/style.css\" media=\"all\" rel=\"stylesheet\" />  stylesheet_link_tag \"style\", media: \"print\" # => <link href=\"/assets/style.css\" media=\"print\" rel=\"stylesheet\" />  stylesheet_link_tag \"random.styles\", \"/css/stylish\" # => <link href=\"/assets/random.styles\" rel=\"stylesheet\" /> #    <link href=\"/css/stylish.css\" rel=\"stylesheet\" />  stylesheet_link_tag \"style\", nonce: true # => <link href=\"/assets/style.css\" rel=\"stylesheet\" nonce=\"...\" />",
    "label": "",
    "id": "757"
  },
  {
    "raw_code": "def auto_discovery_link_tag(type = :rss, url_options = {}, tag_options = {})\n        if !(type == :rss || type == :atom || type == :json) && tag_options[:type].blank?\n          raise ArgumentError.new(\"You should pass :type tag_option key explicitly, because you have passed #{type} type other than :rss, :atom, or :json.\")\n        end",
    "comment": "Returns a link tag that browsers and feed readers can use to auto-detect an RSS, Atom, or JSON feed. The +type+ can be <tt>:rss</tt> (default), <tt>:atom</tt>, or <tt>:json</tt>. Control the link options in url_for format using the +url_options+. You can modify the LINK tag itself in +tag_options+.  ==== Options  * <tt>:rel</tt>  - Specify the relation of this link, defaults to \"alternate\" * <tt>:type</tt>  - Override the auto-generated mime type * <tt>:title</tt>  - Specify the title of the link, defaults to the +type+  ==== Examples  auto_discovery_link_tag # => <link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"http://www.currenthost.com/controller/action\" /> auto_discovery_link_tag(:atom) # => <link rel=\"alternate\" type=\"application/atom+xml\" title=\"ATOM\" href=\"http://www.currenthost.com/controller/action\" /> auto_discovery_link_tag(:json) # => <link rel=\"alternate\" type=\"application/json\" title=\"JSON\" href=\"http://www.currenthost.com/controller/action\" /> auto_discovery_link_tag(:rss, {action: \"feed\"}) # => <link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"http://www.currenthost.com/controller/feed\" /> auto_discovery_link_tag(:rss, {action: \"feed\"}, {title: \"My RSS\"}) # => <link rel=\"alternate\" type=\"application/rss+xml\" title=\"My RSS\" href=\"http://www.currenthost.com/controller/feed\" /> auto_discovery_link_tag(:rss, {controller: \"news\", action: \"feed\"}) # => <link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"http://www.currenthost.com/news/feed\" /> auto_discovery_link_tag(:rss, \"http://www.example.com/feed.rss\", {title: \"Example RSS\"}) # => <link rel=\"alternate\" type=\"application/rss+xml\" title=\"Example RSS\" href=\"http://www.example.com/feed.rss\" />",
    "label": "",
    "id": "758"
  },
  {
    "raw_code": "def favicon_link_tag(source = \"favicon.ico\", options = {})\n        tag(\"link\", {\n          rel: \"icon\",\n          type: \"image/x-icon\",\n          href: path_to_image(source, skip_pipeline: options.delete(:skip_pipeline))\n        }.merge!(options.symbolize_keys))\n      end",
    "comment": "Returns a link tag for a favicon managed by the asset pipeline.  If a page has no link like the one generated by this helper, browsers ask for <tt>/favicon.ico</tt> automatically, and cache the file if the request succeeds. If the favicon changes it is hard to get it updated.  To have better control applications may let the asset pipeline manage their favicon storing the file under <tt>app/assets/images</tt>, and using this helper to generate its corresponding link tag.  The helper gets the name of the favicon file as first argument, which defaults to \"favicon.ico\", and also supports +:rel+ and +:type+ options to override their defaults, \"icon\" and \"image/x-icon\" respectively:  favicon_link_tag # => <link href=\"/assets/favicon.ico\" rel=\"icon\" type=\"image/x-icon\" />  favicon_link_tag 'myicon.ico' # => <link href=\"/assets/myicon.ico\" rel=\"icon\" type=\"image/x-icon\" />  Mobile Safari looks for a different link tag, pointing to an image that will be used if you add the page to the home screen of an iOS device. The following call would generate such a tag:  favicon_link_tag 'mb-icon.png', rel: 'apple-touch-icon', type: 'image/png' # => <link href=\"/assets/mb-icon.png\" rel=\"apple-touch-icon\" type=\"image/png\" />",
    "label": "",
    "id": "759"
  },
  {
    "raw_code": "def preload_link_tag(source, options = {})\n        href = path_to_asset(source, skip_pipeline: options.delete(:skip_pipeline))\n        extname = File.extname(source).downcase.delete(\".\")\n        mime_type = options.delete(:type) || Template::Types[extname]&.to_s\n        as_type = options.delete(:as) || resolve_link_as(extname, mime_type)\n        crossorigin = options.delete(:crossorigin)\n        crossorigin = \"anonymous\" if crossorigin == true || (crossorigin.blank? && as_type == \"font\")\n        integrity = options[:integrity]\n        fetchpriority = options.delete(:fetchpriority)\n        nopush = options.delete(:nopush) || false\n        rel = mime_type == \"module\" || mime_type == :module ? \"modulepreload\" : \"preload\"\n        add_nonce = content_security_policy_nonce &&\n          respond_to?(:request) &&\n          request.content_security_policy_nonce_directives&.include?(\"#{as_type}-src\")\n\n        if add_nonce\n          options[:nonce] = content_security_policy_nonce\n        end",
    "comment": "Returns a link tag that browsers can use to preload the +source+. The +source+ can be the path of a resource managed by asset pipeline, a full path, or an URI.  ==== Options  * <tt>:type</tt>  - Override the auto-generated mime type, defaults to the mime type for +source+ extension. * <tt>:as</tt>  - Override the auto-generated value for as attribute, calculated using +source+ extension and mime type. * <tt>:crossorigin</tt>  - Specify the crossorigin attribute, required to load cross-origin resources. * <tt>:nopush</tt>  - Specify if the use of server push is not desired for the resource. Defaults to +false+. * <tt>:integrity</tt> - Specify the integrity attribute.  ==== Examples  preload_link_tag(\"custom_theme.css\") # => <link rel=\"preload\" href=\"/assets/custom_theme.css\" as=\"style\" type=\"text/css\" />  preload_link_tag(\"/videos/video.webm\") # => <link rel=\"preload\" href=\"/videos/video.mp4\" as=\"video\" type=\"video/webm\" />  preload_link_tag(post_path(format: :json), as: \"fetch\") # => <link rel=\"preload\" href=\"/posts.json\" as=\"fetch\" type=\"application/json\" />  preload_link_tag(\"worker.js\", as: \"worker\") # => <link rel=\"preload\" href=\"/assets/worker.js\" as=\"worker\" type=\"text/javascript\" />  preload_link_tag(\"//example.com/font.woff2\") # => <link rel=\"preload\" href=\"//example.com/font.woff2\" as=\"font\" type=\"font/woff2\" crossorigin=\"anonymous\"/>  preload_link_tag(\"//example.com/font.woff2\", crossorigin: \"use-credentials\") # => <link rel=\"preload\" href=\"//example.com/font.woff2\" as=\"font\" type=\"font/woff2\" crossorigin=\"use-credentials\" />  preload_link_tag(\"/media/audio.ogg\", nopush: true) # => <link rel=\"preload\" href=\"/media/audio.ogg\" as=\"audio\" type=\"audio/ogg\" /> ",
    "label": "",
    "id": "760"
  },
  {
    "raw_code": "def image_tag(source, options = {})\n        options = options.symbolize_keys\n        check_for_image_tag_errors(options)\n        skip_pipeline = options.delete(:skip_pipeline)\n\n        options[:src] = resolve_asset_source(\"image\", source, skip_pipeline)\n\n        if options[:srcset] && !options[:srcset].is_a?(String)\n          options[:srcset] = options[:srcset].map do |src_path, size|\n            src_path = path_to_image(src_path, skip_pipeline: skip_pipeline)\n            \"#{src_path} #{size}\"\n          end.join(\", \")\n        end",
    "comment": "Returns an HTML image tag for the +source+. The +source+ can be a full path, a file, or an Active Storage attachment.  ==== Options  You can add HTML attributes using the +options+. The +options+ supports additional keys for convenience and conformance:  * <tt>:size</tt> - Supplied as <tt>\"#{width}x#{height}\"</tt> or <tt>\"#{number}\"</tt>, so <tt>\"30x45\"</tt> becomes <tt>width=\"30\" height=\"45\"</tt>, and <tt>\"50\"</tt> becomes <tt>width=\"50\" height=\"50\"</tt>. <tt>:size</tt> will be ignored if the value is not in the correct format. * <tt>:srcset</tt> - If supplied as a hash or array of <tt>[source, descriptor]</tt> pairs, each image path will be expanded before the list is formatted as a string.  ==== Examples  Assets (images that are part of your app):  image_tag(\"icon\") # => <img src=\"/assets/icon\" /> image_tag(\"icon.png\") # => <img src=\"/assets/icon.png\" /> image_tag(\"icon.png\", size: \"16x10\", alt: \"Edit Entry\") # => <img src=\"/assets/icon.png\" width=\"16\" height=\"10\" alt=\"Edit Entry\" /> image_tag(\"/icons/icon.gif\", size: \"16\") # => <img src=\"/icons/icon.gif\" width=\"16\" height=\"16\" /> image_tag(\"/icons/icon.gif\", height: '32', width: '32') # => <img height=\"32\" src=\"/icons/icon.gif\" width=\"32\" /> image_tag(\"/icons/icon.gif\", class: \"menu_icon\") # => <img class=\"menu_icon\" src=\"/icons/icon.gif\" /> image_tag(\"/icons/icon.gif\", data: { title: 'Rails Application' }) # => <img data-title=\"Rails Application\" src=\"/icons/icon.gif\" /> image_tag(\"icon.png\", srcset: { \"icon_2x.png\" => \"2x\", \"icon_4x.png\" => \"4x\" }) # => <img src=\"/assets/icon.png\" srcset=\"/assets/icon_2x.png 2x, /assets/icon_4x.png 4x\"> image_tag(\"pic.jpg\", srcset: [[\"pic_1024.jpg\", \"1024w\"], [\"pic_1980.jpg\", \"1980w\"]], sizes: \"100vw\") # => <img src=\"/assets/pic.jpg\" srcset=\"/assets/pic_1024.jpg 1024w, /assets/pic_1980.jpg 1980w\" sizes=\"100vw\">  Active Storage blobs (images that are uploaded by the users of your app):  image_tag(user.avatar) # => <img src=\"/rails/active_storage/blobs/.../tiger.jpg\" /> image_tag(user.avatar.variant(resize_to_limit: [100, 100])) # => <img src=\"/rails/active_storage/representations/.../tiger.jpg\" /> image_tag(user.avatar.variant(resize_to_limit: [100, 100]), size: '100') # => <img width=\"100\" height=\"100\" src=\"/rails/active_storage/representations/.../tiger.jpg\" />",
    "label": "",
    "id": "761"
  },
  {
    "raw_code": "def picture_tag(*sources, &block)\n        sources.flatten!\n        options = sources.extract_options!.symbolize_keys\n        image_options = options.delete(:image) || {}\n        skip_pipeline = options.delete(:skip_pipeline)\n\n        content_tag(\"picture\", options) do\n          if block.present?\n            capture(&block).html_safe\n          elsif sources.size <= 1\n            image_tag(sources.last, image_options)\n          else\n            source_tags = sources.map do |source|\n              tag(\"source\",\n               srcset: resolve_asset_source(\"image\", source, skip_pipeline),\n               type: Template::Types[File.extname(source)[1..]]&.to_s)\n            end",
    "comment": "Returns an HTML picture tag for the +sources+. If +sources+ is a string, a single picture tag will be returned. If +sources+ is an array, a picture tag with nested source tags for each source will be returned. The +sources+ can be full paths, files that exist in your public images directory, or Active Storage attachments. Since the picture tag requires an img tag, the last element you provide will be used for the img tag. For complete control over the picture tag, a block can be passed, which will populate the contents of the tag accordingly.  ==== Options  When the last parameter is a hash you can add HTML attributes using that parameter. Apart from all the HTML supported options, the following are supported:  * <tt>:image</tt> - Hash of options that are passed directly to the +image_tag+ helper.  ==== Examples  picture_tag(\"picture.webp\") # => <picture><img src=\"/images/picture.webp\" /></picture> picture_tag(\"gold.png\", :image => { :size => \"20\" }) # => <picture><img height=\"20\" src=\"/images/gold.png\" width=\"20\" /></picture> picture_tag(\"gold.png\", :image => { :size => \"45x70\" }) # => <picture><img height=\"70\" src=\"/images/gold.png\" width=\"45\" /></picture> picture_tag(\"picture.webp\", \"picture.png\") # => <picture><source srcset=\"/images/picture.webp\" /><source srcset=\"/images/picture.png\" /><img src=\"/images/picture.png\" /></picture> picture_tag(\"picture.webp\", \"picture.png\", :image => { alt: \"Image\" }) # => <picture><source srcset=\"/images/picture.webp\" /><source srcset=\"/images/picture.png\" /><img alt=\"Image\" src=\"/images/picture.png\" /></picture> picture_tag([\"picture.webp\", \"picture.png\"], :image => { alt: \"Image\" }) # => <picture><source srcset=\"/images/picture.webp\" /><source srcset=\"/images/picture.png\" /><img alt=\"Image\" src=\"/images/picture.png\" /></picture> picture_tag(:class => \"my-class\") { tag(:source, :srcset => image_path(\"picture.webp\")) + image_tag(\"picture.png\", :alt => \"Image\") } # => <picture class=\"my-class\"><source srcset=\"/images/picture.webp\" /><img alt=\"Image\" src=\"/images/picture.png\" /></picture> picture_tag { tag(:source, :srcset => image_path(\"picture-small.webp\"), :media => \"(min-width: 600px)\") + tag(:source, :srcset => image_path(\"picture-big.webp\")) + image_tag(\"picture.png\", :alt => \"Image\") } # => <picture><source srcset=\"/images/picture-small.webp\" media=\"(min-width: 600px)\" /><source srcset=\"/images/picture-big.webp\" /><img alt=\"Image\" src=\"/images/picture.png\" /></picture>  Active Storage blobs (images that are uploaded by the users of your app):  picture_tag(user.profile_picture) # => <picture><img src=\"/rails/active_storage/blobs/.../profile_picture.webp\" /></picture>",
    "label": "",
    "id": "762"
  },
  {
    "raw_code": "def video_tag(*sources)\n        options = sources.extract_options!.symbolize_keys\n        public_poster_folder = options.delete(:poster_skip_pipeline)\n        sources << options\n        multiple_sources_tag_builder(\"video\", sources) do |tag_options|\n          tag_options[:poster] = path_to_image(tag_options[:poster], skip_pipeline: public_poster_folder) if tag_options[:poster]\n          tag_options[:width], tag_options[:height] = extract_dimensions(tag_options.delete(:size)) if tag_options[:size]\n        end",
    "comment": "Returns an HTML video tag for the +sources+. If +sources+ is a string, a single video tag will be returned. If +sources+ is an array, a video tag with nested source tags for each source will be returned. The +sources+ can be full paths, files that exist in your public videos directory, or Active Storage attachments.  ==== Options  When the last parameter is a hash you can add HTML attributes using that parameter. The following options are supported:  * <tt>:poster</tt> - Set an image (like a screenshot) to be shown before the video loads. The path is calculated like the +src+ of +image_tag+. * <tt>:size</tt> - Supplied as <tt>\"#{width}x#{height}\"</tt> or <tt>\"#{number}\"</tt>, so <tt>\"30x45\"</tt> becomes <tt>width=\"30\" height=\"45\"</tt>, and <tt>\"50\"</tt> becomes <tt>width=\"50\" height=\"50\"</tt>. <tt>:size</tt> will be ignored if the value is not in the correct format. * <tt>:poster_skip_pipeline</tt> will bypass the asset pipeline when using the <tt>:poster</tt> option instead using an asset in the public folder.  ==== Examples  video_tag(\"trailer\") # => <video src=\"/videos/trailer\"></video> video_tag(\"trailer.ogg\") # => <video src=\"/videos/trailer.ogg\"></video> video_tag(\"trailer.ogg\", controls: true, preload: 'none') # => <video preload=\"none\" controls=\"controls\" src=\"/videos/trailer.ogg\"></video> video_tag(\"trailer.m4v\", size: \"16x10\", poster: \"screenshot.png\") # => <video src=\"/videos/trailer.m4v\" width=\"16\" height=\"10\" poster=\"/assets/screenshot.png\"></video> video_tag(\"trailer.m4v\", size: \"16x10\", poster: \"screenshot.png\", poster_skip_pipeline: true) # => <video src=\"/videos/trailer.m4v\" width=\"16\" height=\"10\" poster=\"screenshot.png\"></video> video_tag(\"/trailers/hd.avi\", size: \"16x16\") # => <video src=\"/trailers/hd.avi\" width=\"16\" height=\"16\"></video> video_tag(\"/trailers/hd.avi\", size: \"16\") # => <video height=\"16\" src=\"/trailers/hd.avi\" width=\"16\"></video> video_tag(\"/trailers/hd.avi\", height: '32', width: '32') # => <video height=\"32\" src=\"/trailers/hd.avi\" width=\"32\"></video> video_tag(\"trailer.ogg\", \"trailer.flv\") # => <video><source src=\"/videos/trailer.ogg\" /><source src=\"/videos/trailer.flv\" /></video> video_tag([\"trailer.ogg\", \"trailer.flv\"]) # => <video><source src=\"/videos/trailer.ogg\" /><source src=\"/videos/trailer.flv\" /></video> video_tag([\"trailer.ogg\", \"trailer.flv\"], size: \"160x120\") # => <video height=\"120\" width=\"160\"><source src=\"/videos/trailer.ogg\" /><source src=\"/videos/trailer.flv\" /></video>  Active Storage blobs (videos that are uploaded by the users of your app):  video_tag(user.intro_video) # => <video src=\"/rails/active_storage/blobs/.../intro_video.mp4\"></video>",
    "label": "",
    "id": "763"
  },
  {
    "raw_code": "def audio_tag(*sources)\n        multiple_sources_tag_builder(\"audio\", sources)\n      end",
    "comment": "Returns an HTML audio tag for the +sources+. If +sources+ is a string, a single audio tag will be returned. If +sources+ is an array, an audio tag with nested source tags for each source will be returned. The +sources+ can be full paths, files that exist in your public audios directory, or Active Storage attachments.  When the last parameter is a hash you can add HTML attributes using that parameter.  audio_tag(\"sound\") # => <audio src=\"/audios/sound\"></audio> audio_tag(\"sound.wav\") # => <audio src=\"/audios/sound.wav\"></audio> audio_tag(\"sound.wav\", autoplay: true, controls: true) # => <audio autoplay=\"autoplay\" controls=\"controls\" src=\"/audios/sound.wav\"></audio> audio_tag(\"sound.wav\", \"sound.mid\") # => <audio><source src=\"/audios/sound.wav\" /><source src=\"/audios/sound.mid\" /></audio>  Active Storage blobs (audios that are uploaded by the users of your app):  audio_tag(user.name_pronunciation_audio) # => <audio src=\"/rails/active_storage/blobs/.../name_pronunciation_audio.mp3\"></audio>",
    "label": "",
    "id": "764"
  },
  {
    "raw_code": "def asset_path(source, options = {})\n        raise ArgumentError, \"nil is not a valid asset source\" if source.nil?\n\n        source = source.to_s\n        return \"\" if source.blank?\n        return source if URI_REGEXP.match?(source)\n\n        tail, source = source[/([?#].+)$/], source.sub(/([?#].+)$/, \"\")\n\n        if extname = compute_asset_extname(source, options)\n          source = \"#{source}#{extname}\"\n        end",
    "comment": "This is the entry point for all assets. When using an asset pipeline gem (e.g. propshaft or sprockets-rails), the behavior is \"enhanced\". You can bypass the asset pipeline by passing in <tt>skip_pipeline: true</tt> to the options.  All other asset *_path helpers delegate through this method.  === With the asset pipeline  All options passed to +asset_path+ will be passed to +compute_asset_path+ which is implemented by asset pipeline gems.  asset_path(\"application.js\") # => \"/assets/application-60aa4fdc5cea14baf5400fba1abf4f2a46a5166bad4772b1effe341570f07de9.js\" asset_path('application.js', host: 'example.com') # => \"//example.com/assets/application.js\" asset_path(\"application.js\", host: 'example.com', protocol: 'https') # => \"https://example.com/assets/application.js\"  === Without the asset pipeline (<tt>skip_pipeline: true</tt>)  Accepts a <tt>type</tt> option that can specify the asset's extension. No error checking is done to verify the source passed into +asset_path+ is valid and that the file exists on disk.  asset_path(\"application.js\", skip_pipeline: true)                 # => \"application.js\" asset_path(\"filedoesnotexist.png\", skip_pipeline: true)           # => \"filedoesnotexist.png\" asset_path(\"application\", type: :javascript, skip_pipeline: true) # => \"/javascripts/application.js\" asset_path(\"application\", type: :stylesheet, skip_pipeline: true) # => \"/stylesheets/application.css\"  === Options applying to all assets  Below lists scenarios that apply to +asset_path+ whether or not you're using the asset pipeline.  - All fully qualified URLs are returned immediately. This bypasses the asset pipeline and all other behavior described.  asset_path(\"http://www.example.com/js/xmlhr.js\") # => \"http://www.example.com/js/xmlhr.js\"  - All assets that begin with a forward slash are assumed to be full URLs and will not be expanded. This will bypass the asset pipeline.  asset_path(\"/foo.png\") # => \"/foo.png\"  - All blank strings will be returned immediately. This bypasses the asset pipeline and all other behavior described.  asset_path(\"\") # => \"\"  - If <tt>config.relative_url_root</tt> is specified, all assets will have that root prepended.  Rails.application.config.relative_url_root = \"bar\" asset_path(\"foo.js\", skip_pipeline: true) # => \"bar/foo.js\"  - A different asset host can be specified via <tt>config.action_controller.asset_host</tt> this is commonly used in conjunction with a CDN.  Rails.application.config.action_controller.asset_host = \"assets.example.com\" asset_path(\"foo.js\", skip_pipeline: true) # => \"http://assets.example.com/foo.js\"  - An extension name can be specified manually with <tt>extname</tt>.  asset_path(\"foo\", skip_pipeline: true, extname: \".js\")     # => \"/foo.js\" asset_path(\"foo.css\", skip_pipeline: true, extname: \".js\") # => \"/foo.css.js\"",
    "label": "",
    "id": "765"
  },
  {
    "raw_code": "def asset_url(source, options = {})\n        path_to_asset(source, options.merge(protocol: :request))\n      end",
    "comment": "Computes the full URL to an asset in the public directory. This will use +asset_path+ internally, so most of their behaviors will be the same. If +:host+ options is set, it overwrites global +config.action_controller.asset_host+ setting.  All other options provided are forwarded to +asset_path+ call.  asset_url \"application.js\"                                 # => http://example.com/assets/application.js asset_url \"application.js\", host: \"http://cdn.example.com\" # => http://cdn.example.com/assets/application.js ",
    "label": "",
    "id": "766"
  },
  {
    "raw_code": "def compute_asset_extname(source, options = {})\n        return if options[:extname] == false\n        extname = options[:extname] || ASSET_EXTENSIONS[options[:type]]\n        if extname && File.extname(source) != extname\n          extname\n        else\n          nil\n        end",
    "comment": "Compute extname to append to asset path. Returns +nil+ if nothing should be added.",
    "label": "",
    "id": "767"
  },
  {
    "raw_code": "def compute_asset_path(source, options = {})\n        dir = ASSET_PUBLIC_DIRECTORIES[options[:type]] || \"\"\n        File.join(dir, source)\n      end",
    "comment": "Computes asset path to public directory. Plugins and extensions can override this method to point to custom assets or generate digested paths or query strings.",
    "label": "",
    "id": "768"
  },
  {
    "raw_code": "def compute_asset_host(source = \"\", options = {})\n        request = self.request if respond_to?(:request)\n        host = options[:host]\n        host ||= config.asset_host if defined? config.asset_host\n\n        if host\n          if host.respond_to?(:call)\n            arity = host.respond_to?(:arity) ? host.arity : host.method(:call).arity\n            args = [source]\n            args << request if request && (arity > 1 || arity < 0)\n            host = host.call(*args)\n          elsif host.include?(\"%d\")\n            host = host % (Zlib.crc32(source) % 4)\n          end",
    "comment": "Pick an asset host for this source. Returns +nil+ if no host is set, the host if no wildcard is set, the host interpolated with the numbers 0-3 if it contains <tt>%d</tt> (the number is the source hash mod 4), or the value returned from invoking call on an object responding to call (proc or otherwise).",
    "label": "",
    "id": "769"
  },
  {
    "raw_code": "def javascript_path(source, options = {})\n        path_to_asset(source, { type: :javascript }.merge!(options))\n      end",
    "comment": "Computes the path to a JavaScript asset in the public javascripts directory. If the +source+ filename has no extension, .js will be appended (except for explicit URIs) Full paths from the document root will be passed through. Used internally by +javascript_include_tag+ to build the script path.  javascript_path \"xmlhr\"                              # => /assets/xmlhr.js javascript_path \"dir/xmlhr.js\"                       # => /assets/dir/xmlhr.js javascript_path \"/dir/xmlhr\"                         # => /dir/xmlhr.js javascript_path \"http://www.example.com/js/xmlhr\"    # => http://www.example.com/js/xmlhr javascript_path \"http://www.example.com/js/xmlhr.js\" # => http://www.example.com/js/xmlhr.js",
    "label": "",
    "id": "770"
  },
  {
    "raw_code": "def javascript_url(source, options = {})\n        url_to_asset(source, { type: :javascript }.merge!(options))\n      end",
    "comment": "Computes the full URL to a JavaScript asset in the public javascripts directory. This will use +javascript_path+ internally, so most of their behaviors will be the same. Since +javascript_url+ is based on +asset_url+ method you can set +:host+ options. If +:host+ options is set, it overwrites global +config.action_controller.asset_host+ setting.  javascript_url \"js/xmlhr.js\", host: \"http://stage.example.com\" # => http://stage.example.com/assets/js/xmlhr.js ",
    "label": "",
    "id": "771"
  },
  {
    "raw_code": "def stylesheet_path(source, options = {})\n        path_to_asset(source, { type: :stylesheet }.merge!(options))\n      end",
    "comment": "Computes the path to a stylesheet asset in the public stylesheets directory. If the +source+ filename has no extension, .css will be appended (except for explicit URIs). Full paths from the document root will be passed through. Used internally by +stylesheet_link_tag+ to build the stylesheet path.  stylesheet_path \"style\"                                  # => /assets/style.css stylesheet_path \"dir/style.css\"                          # => /assets/dir/style.css stylesheet_path \"/dir/style.css\"                         # => /dir/style.css stylesheet_path \"http://www.example.com/css/style\"       # => http://www.example.com/css/style stylesheet_path \"http://www.example.com/css/style.css\"   # => http://www.example.com/css/style.css",
    "label": "",
    "id": "772"
  },
  {
    "raw_code": "def stylesheet_url(source, options = {})\n        url_to_asset(source, { type: :stylesheet }.merge!(options))\n      end",
    "comment": "Computes the full URL to a stylesheet asset in the public stylesheets directory. This will use +stylesheet_path+ internally, so most of their behaviors will be the same. Since +stylesheet_url+ is based on +asset_url+ method you can set +:host+ options. If +:host+ options is set, it overwrites global +config.action_controller.asset_host+ setting.  stylesheet_url \"css/style.css\", host: \"http://stage.example.com\" # => http://stage.example.com/assets/css/style.css ",
    "label": "",
    "id": "773"
  },
  {
    "raw_code": "def image_path(source, options = {})\n        path_to_asset(source, { type: :image }.merge!(options))\n      end",
    "comment": "Computes the path to an image asset. Full paths from the document root will be passed through. Used internally by +image_tag+ to build the image path:  image_path(\"edit\")                                         # => \"/assets/edit\" image_path(\"edit.png\")                                     # => \"/assets/edit.png\" image_path(\"icons/edit.png\")                               # => \"/assets/icons/edit.png\" image_path(\"/icons/edit.png\")                              # => \"/icons/edit.png\" image_path(\"http://www.example.com/img/edit.png\")          # => \"http://www.example.com/img/edit.png\"  If you have images as application resources this method may conflict with their named routes. The alias +path_to_image+ is provided to avoid that. \\Rails uses the alias internally, and plugin authors are encouraged to do so.",
    "label": "",
    "id": "774"
  },
  {
    "raw_code": "def image_url(source, options = {})\n        url_to_asset(source, { type: :image }.merge!(options))\n      end",
    "comment": "Computes the full URL to an image asset. This will use +image_path+ internally, so most of their behaviors will be the same. Since +image_url+ is based on +asset_url+ method you can set +:host+ options. If +:host+ options is set, it overwrites global +config.action_controller.asset_host+ setting.  image_url \"edit.png\", host: \"http://stage.example.com\" # => http://stage.example.com/assets/edit.png ",
    "label": "",
    "id": "775"
  },
  {
    "raw_code": "def video_path(source, options = {})\n        path_to_asset(source, { type: :video }.merge!(options))\n      end",
    "comment": "Computes the path to a video asset in the public videos directory. Full paths from the document root will be passed through. Used internally by +video_tag+ to build the video path.  video_path(\"hd\")                                            # => /videos/hd video_path(\"hd.avi\")                                        # => /videos/hd.avi video_path(\"trailers/hd.avi\")                               # => /videos/trailers/hd.avi video_path(\"/trailers/hd.avi\")                              # => /trailers/hd.avi video_path(\"http://www.example.com/vid/hd.avi\")             # => http://www.example.com/vid/hd.avi",
    "label": "",
    "id": "776"
  },
  {
    "raw_code": "def video_url(source, options = {})\n        url_to_asset(source, { type: :video }.merge!(options))\n      end",
    "comment": "Computes the full URL to a video asset in the public videos directory. This will use +video_path+ internally, so most of their behaviors will be the same. Since +video_url+ is based on +asset_url+ method you can set +:host+ options. If +:host+ options is set, it overwrites global +config.action_controller.asset_host+ setting.  video_url \"hd.avi\", host: \"http://stage.example.com\" # => http://stage.example.com/videos/hd.avi ",
    "label": "",
    "id": "777"
  },
  {
    "raw_code": "def audio_path(source, options = {})\n        path_to_asset(source, { type: :audio }.merge!(options))\n      end",
    "comment": "Computes the path to an audio asset in the public audios directory. Full paths from the document root will be passed through. Used internally by +audio_tag+ to build the audio path.  audio_path(\"horse\")                                            # => /audios/horse audio_path(\"horse.wav\")                                        # => /audios/horse.wav audio_path(\"sounds/horse.wav\")                                 # => /audios/sounds/horse.wav audio_path(\"/sounds/horse.wav\")                                # => /sounds/horse.wav audio_path(\"http://www.example.com/sounds/horse.wav\")          # => http://www.example.com/sounds/horse.wav",
    "label": "",
    "id": "778"
  },
  {
    "raw_code": "def audio_url(source, options = {})\n        url_to_asset(source, { type: :audio }.merge!(options))\n      end",
    "comment": "Computes the full URL to an audio asset in the public audios directory. This will use +audio_path+ internally, so most of their behaviors will be the same. Since +audio_url+ is based on +asset_url+ method you can set +:host+ options. If +:host+ options is set, it overwrites global +config.action_controller.asset_host+ setting.  audio_url \"horse.wav\", host: \"http://stage.example.com\" # => http://stage.example.com/audios/horse.wav ",
    "label": "",
    "id": "779"
  },
  {
    "raw_code": "def font_path(source, options = {})\n        path_to_asset(source, { type: :font }.merge!(options))\n      end",
    "comment": "Computes the path to a font asset. Full paths from the document root will be passed through.  font_path(\"font\")                                           # => /fonts/font font_path(\"font.ttf\")                                       # => /fonts/font.ttf font_path(\"dir/font.ttf\")                                   # => /fonts/dir/font.ttf font_path(\"/dir/font.ttf\")                                  # => /dir/font.ttf font_path(\"http://www.example.com/dir/font.ttf\")            # => http://www.example.com/dir/font.ttf",
    "label": "",
    "id": "780"
  },
  {
    "raw_code": "def font_url(source, options = {})\n        url_to_asset(source, { type: :font }.merge!(options))\n      end",
    "comment": "Computes the full URL to a font asset. This will use +font_path+ internally, so most of their behaviors will be the same. Since +font_url+ is based on +asset_url+ method you can set +:host+ options. If +:host+ options is set, it overwrites global +config.action_controller.asset_host+ setting.  font_url \"font.ttf\", host: \"http://stage.example.com\" # => http://stage.example.com/fonts/font.ttf ",
    "label": "",
    "id": "781"
  },
  {
    "raw_code": "def atom_feed(options = {}, &block)\n        if options[:schema_date]\n          options[:schema_date] = options[:schema_date].strftime(\"%Y-%m-%d\") if options[:schema_date].respond_to?(:strftime)\n        else\n          options[:schema_date] = \"2005\" # The Atom spec copyright date\n        end",
    "comment": "Adds easy defaults to writing Atom feeds with the Builder template engine (this does not work on ERB or any other template languages).  Full usage example:  config/routes.rb: Rails.application.routes.draw do resources :posts root to: \"posts#index\" end  app/controllers/posts_controller.rb: class PostsController < ApplicationController # GET /posts.html # GET /posts.atom def index @posts = Post.all  respond_to do |format| format.html format.atom end end end  app/views/posts/index.atom.builder: atom_feed do |feed| feed.title(\"My great blog!\") feed.updated(@posts[0].created_at) if @posts.length > 0  @posts.each do |post| feed.entry(post) do |entry| entry.title(post.title) entry.content(post.body, type: 'html')  entry.author do |author| author.name(\"DHH\") end end end end  The options for atom_feed are:  * <tt>:language</tt>: Defaults to \"en-US\". * <tt>:root_url</tt>: The HTML alternative that this feed is doubling for. Defaults to / on the current host. * <tt>:url</tt>: The URL for this feed. Defaults to the current URL. * <tt>:id</tt>: The id for this feed. Defaults to \"tag:localhost,2005:/posts\", in this case. * <tt>:schema_date</tt>: The date at which the tag scheme for the feed was first used. A good default is the year you created the feed. See http://feedvalidator.org/docs/error/InvalidTAG.html for more information. If not specified, 2005 is used (as an \"I don't care\" value). * <tt>:instruct</tt>: Hash of XML processing instructions in the form {target => {attribute => value, }} or {target => [{attribute => value, }, ]}  Other namespaces can be added to the root element:  app/views/posts/index.atom.builder: atom_feed({'xmlns:app' => 'http://www.w3.org/2007/app', 'xmlns:openSearch' => 'http://a9.com/-/spec/opensearch/1.1/'}) do |feed| feed.title(\"My great blog!\") feed.updated((@posts.first.created_at)) feed.tag!('openSearch:totalResults', 10)  @posts.each do |post| feed.entry(post) do |entry| entry.title(post.title) entry.content(post.body, type: 'html') entry.tag!('app:edited', Time.now)  entry.author do |author| author.name(\"DHH\") end end end end  The Atom spec defines five elements (content rights title subtitle summary) which may directly contain XHTML content if type: 'xhtml' is specified as an attribute. If so, this helper will take care of the enclosing div and XHTML namespace declaration. Example usage:  entry.summary type: 'xhtml' do |xhtml| xhtml.p pluralize(order.line_items.count, \"line item\") xhtml.p \"Shipped to #{order.address}\" xhtml.p \"Paid by #{order.pay_type}\" end   <tt>atom_feed</tt> yields an +AtomFeedBuilder+ instance. Nested elements yield an +AtomBuilder+ instance.",
    "label": "",
    "id": "782"
  },
  {
    "raw_code": "def method_missing(method, *arguments, &block)\n            if xhtml_block?(method, arguments)\n              @xml.__send__(method, *arguments) do\n                @xml.div(xmlns: \"http://www.w3.org/1999/xhtml\") do |xhtml|\n                  block.call(xhtml)\n                end",
    "comment": "Delegate to XML Builder, first wrapping the element in an XHTML namespaced div element if the method and arguments indicate that an xhtml_block? is desired.",
    "label": "",
    "id": "783"
  },
  {
    "raw_code": "def xhtml_block?(method, arguments)\n            if XHTML_TAG_NAMES.include?(method.to_s)\n              last = arguments.last\n              last.is_a?(Hash) && last[:type].to_s == \"xhtml\"\n            end",
    "comment": "True if the method name matches one of the five elements defined in the Atom spec as potentially containing XHTML content and if type: 'xhtml' is, in fact, specified.",
    "label": "",
    "id": "784"
  },
  {
    "raw_code": "def updated(date_or_time = nil)\n          @xml.updated((date_or_time || Time.now.utc).xmlschema)\n        end",
    "comment": "Accepts a Date or Time object and inserts it in the proper format. If +nil+ is passed, current time in UTC is used.",
    "label": "",
    "id": "785"
  },
  {
    "raw_code": "def entry(record, options = {})\n          @xml.entry do\n            @xml.id(options[:id] || \"tag:#{@view.request.host},#{@feed_options[:schema_date]}:#{record.class}/#{record.id}\")\n\n            if options[:published] || (record.respond_to?(:created_at) && record.created_at)\n              @xml.published((options[:published] || record.created_at).xmlschema)\n            end",
    "comment": "Creates an entry tag for a specific record and prefills the id using class and id.  ==== Options  * <tt>:published</tt>: Time first published. Defaults to the created_at attribute on the record if one such exists. * <tt>:updated</tt>: Time of update. Defaults to the updated_at attribute on the record if one such exists. * <tt>:url</tt>: The URL for this entry or +false+ or +nil+ for not having a link tag. Defaults to the +polymorphic_url+ for the record. * <tt>:id</tt>: The ID for this entry. Defaults to \"tag:#{@view.request.host},#{@feed_options[:schema_date]}:#{record.class}/#{record.id}\" * <tt>:type</tt>: The TYPE for this entry. Defaults to \"text/html\".",
    "label": "",
    "id": "786"
  },
  {
    "raw_code": "def cache(name = {}, options = {}, &block)\n        if controller.respond_to?(:perform_caching) && controller.perform_caching\n          CachingRegistry.track_caching do\n            name_options = options.slice(:skip_digest)\n            safe_concat(fragment_for(cache_fragment_name(name, **name_options), options, &block))\n          end",
    "comment": "This helper exposes a method for caching fragments of a view rather than an entire action or page. This technique is useful caching pieces like menus, lists of new topics, static HTML fragments, and so on. This method takes a block that contains the content you wish to cache.  The best way to use this is by doing recyclable key-based cache expiration on top of a cache store like Memcached or Redis that'll automatically kick out old entries.  When using this method, you list the cache dependency as the name of the cache, like so:  <% cache project do %> <b>All the topics on this project</b> <%= render project.topics %> <% end %>  This approach will assume that when a new topic is added, you'll touch the project. The cache key generated from this call will be something like:  views/template/action:7a1156131a6928cb0026877f8b749ac9/projects/123 ^template path  ^template tree digest            ^class   ^id  This cache key is stable, but it's combined with a cache version derived from the project record. When the project updated_at is touched, the #cache_version changes, even if the key stays stable. This means that unlike a traditional key-based cache expiration approach, you won't be generating cache trash, unused keys, simply because the dependent record is updated.  If your template cache depends on multiple sources (try to avoid this to keep things simple), you can name all these dependencies as part of an array:  <% cache [ project, current_user ] do %> <b>All the topics on this project</b> <%= render project.topics %> <% end %>  This will include both records as part of the cache key and updating either of them will expire the cache.  ==== \\Template digest  The template digest that's added to the cache key is computed by taking an MD5 of the contents of the entire template file. This ensures that your caches will automatically expire when you change the template file.  Note that the MD5 is taken of the entire template file, not just what's within the cache do/end call. So it's possible that changing something outside of that call will still expire the cache.  Additionally, the digestor will automatically look through your template file for explicit and implicit dependencies, and include those as part of the digest.  The digestor can be bypassed by passing skip_digest: true as an option to the cache call:  <% cache project, skip_digest: true do %> <b>All the topics on this project</b> <%= render project.topics %> <% end %>  ==== Implicit dependencies  Most template dependencies can be derived from calls to render in the template itself. Here are some examples of render calls that Cache Digests knows how to decode:  render partial: \"comments/comment\", collection: commentable.comments render \"comments/comments\" render 'comments/comments' render('comments/comments')  render \"header\"        # translates to render(\"comments/header\")  render(@topic)         # translates to render(\"topics/topic\") render(topics)         # translates to render(\"topics/topic\") render(message.topics) # translates to render(\"topics/topic\")  It's not possible to derive all render calls like that, though. Here are a few examples of things that can't be derived:  render group_of_attachments render @project.documents.where(published: true).order('created_at')  You will have to rewrite those to the explicit form:  render partial: 'attachments/attachment', collection: group_of_attachments render partial: 'documents/document', collection: @project.documents.where(published: true).order('created_at')  One last type of dependency can be determined implicitly:  render \"maintenance_tasks/runs/info/#{run.status}\"  Because the value passed to render ends in interpolation, Action View will mark all partials within the \"maintenance_tasks/runs/info\" folder as dependencies.  === Explicit dependencies  Sometimes you'll have template dependencies that can't be derived at all. This is typically the case when you have template rendering that happens in helpers. Here's an example:  <%= render_sortable_todolists @project.todolists %>  You'll need to use a special comment format to call those out:  <%# Template Dependency: todolists/todolist %> <%= render_sortable_todolists @project.todolists %>  In some cases, like a single table inheritance setup, you might have a bunch of explicit dependencies. Instead of writing every template out, you can use a wildcard to match any template in a directory:  <%# Template Dependency: events/* %> <%= render_categorizable_events @person.events %>  This marks every template in the directory as a dependency. To find those templates, the wildcard path must be absolutely defined from <tt>app/views</tt> or paths otherwise added with +prepend_view_path+ or +append_view_path+. This way the wildcard for <tt>app/views/recordings/events</tt> would be <tt>recordings/events/*</tt> etc.  The pattern used to match explicit dependencies is <tt>/# Template Dependency: (\\S+)/</tt>, so it's important that you type it out just so. You can only declare one template dependency per line.  === External dependencies  If you use a helper method, for example, inside a cached block and you then update that helper, you'll have to bump the cache as well. It doesn't really matter how you do it, but the MD5 of the template file must change. One recommendation is to simply be explicit in a comment, like:  <%# Helper Dependency Updated: May 6, 2012 at 6pm %> <%= some_helper_method(person) %>  Now all you have to do is change that timestamp when the helper method changes.  === Collection Caching  When rendering a collection of objects that each use the same partial, a <tt>:cached</tt> option can be passed.  For collections rendered such:  <%= render partial: 'projects/project', collection: @projects, cached: true %>  The <tt>cached: true</tt> will make Action View's rendering read several templates from cache at once instead of one call per template.  Templates in the collection not already cached are written to cache.  Works great alongside individual template fragment caching. For instance if the template the collection renders is cached like:  # projects/_project.html.erb <% cache project do %> <%# ... %> <% end %>  Any collection renders will find those cached templates when attempting to read multiple templates at once.  If your collection cache depends on multiple sources (try to avoid this to keep things simple), you can name all these dependencies as part of a block that returns an array:  <%= render partial: 'projects/project', collection: @projects, cached: -> project { [ project, current_user ] } %>  This will include both records as part of the cache key and updating either of them will expire the cache.",
    "label": "",
    "id": "787"
  },
  {
    "raw_code": "def caching?\n        CachingRegistry.caching?\n      end",
    "comment": "Returns whether the current view fragment is within a +cache+ block.  Useful when certain fragments aren't cacheable:  <% cache project do %> <% raise StandardError, \"Caching private data!\" if caching? %> <% end %>",
    "label": "",
    "id": "788"
  },
  {
    "raw_code": "def uncacheable!\n        raise UncacheableFragmentError, \"can't be fragment cached\" if caching?\n      end",
    "comment": "Raises UncacheableFragmentError when called from within a +cache+ block.  Useful to denote helper methods that can't participate in fragment caching:  def project_name_with_time(project) uncacheable! \"#{project.name} - #{Time.now}\" end  # Which will then raise if used within a `cache` block: <% cache project do %> <%= project_name_with_time(project) %> <% end %>",
    "label": "",
    "id": "789"
  },
  {
    "raw_code": "def cache_if(condition, name = {}, options = {}, &block)\n        if condition\n          cache(name, options, &block)\n        else\n          yield\n        end",
    "comment": "Cache fragments of a view if +condition+ is true  <% cache_if admin?, project do %> <b>All the topics on this project</b> <%= render project.topics %> <% end %>",
    "label": "",
    "id": "790"
  },
  {
    "raw_code": "def cache_unless(condition, name = {}, options = {}, &block)\n        cache_if !condition, name, options, &block\n      end",
    "comment": "Cache fragments of a view unless +condition+ is true  <% cache_unless admin?, project do %> <b>All the topics on this project</b> <%= render project.topics %> <% end %>",
    "label": "",
    "id": "791"
  },
  {
    "raw_code": "def cache_fragment_name(name = {}, skip_digest: nil, digest_path: nil)\n        if skip_digest\n          name\n        else\n          fragment_name_with_digest(name, digest_path)\n        end",
    "comment": "This helper returns the name of a cache key for a given fragment cache call. By supplying <tt>skip_digest: true</tt> to cache, the digestion of cache fragments can be manually bypassed. This is useful when cache fragments cannot be manually expired unless you know the exact key which is the case when using memcached.",
    "label": "",
    "id": "792"
  },
  {
    "raw_code": "def capture(*, **, &block)\n        value = nil\n        @output_buffer ||= ActionView::OutputBuffer.new\n        buffer = @output_buffer.capture { value = yield(*, **) }\n\n        string = if @output_buffer.equal?(value)\n          buffer\n        else\n          buffer.presence || value\n        end",
    "comment": "The capture method extracts part of a template as a string object. You can then use this object anywhere in your templates, layout, or helpers.  The capture method can be used in \\ERB templates...  <% @greeting = capture do %> Welcome to my shiny new web page!  The date and time is <%= Time.now %> <% end %>  ...and Builder (RXML) templates.  @timestamp = capture do \"The current timestamp is #{Time.now}.\" end  You can then use that variable anywhere else. For example:  <html> <head><title><%= @greeting %></title></head> <body> <b><%= @greeting %></b> </body> </html>  The return of capture is the string generated by the block. For Example:  @greeting # => \"Welcome to my shiny new web page! The date and time is 2018-09-06 11:09:16 -0500\" ",
    "label": "",
    "id": "793"
  },
  {
    "raw_code": "def content_for(name, content = nil, options = {}, &block)\n        if content || block_given?\n          if block_given?\n            options = content if content\n            content = capture(&block)\n          end",
    "comment": "Calling <tt>content_for</tt> stores a block of markup in an identifier for later use. In order to access this stored content in other templates, helper modules or the layout, you would pass the identifier as an argument to <tt>content_for</tt>.  Note: <tt>yield</tt> can still be used to retrieve the stored content, but calling <tt>yield</tt> doesn't work in helper modules, while <tt>content_for</tt> does.  <% content_for :not_authorized do %> alert('You are not authorized to do that!') <% end %>  You can then use <tt>content_for :not_authorized</tt> anywhere in your templates.  <%= content_for :not_authorized if current_user.nil? %>  This is equivalent to:  <%= yield :not_authorized if current_user.nil? %>  <tt>content_for</tt>, however, can also be used in helper modules.  module StorageHelper def stored_content content_for(:storage) || \"Your storage is empty\" end end  This helper works just like normal helpers.  <%= stored_content %>  You can also use the <tt>yield</tt> syntax alongside an existing call to <tt>yield</tt> in a layout. For example:  <%# This is the layout %> <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\"> <head> <title>My Website</title> <%= yield :script %> </head> <body> <%= yield %> </body> </html>  And now, we'll create a view that has a <tt>content_for</tt> call that creates the <tt>script</tt> identifier.  <%# This is our view %> Please login!  <% content_for :script do %> <script>alert('You are not authorized to view this page!')</script> <% end %>  Then, in another view, you could to do something like this:  <%= link_to 'Logout', action: 'logout', remote: true %>  <% content_for :script do %> <%= javascript_include_tag :defaults %> <% end %>  That will place +script+ tags for your default set of JavaScript files on the page; this technique is useful if you'll only be using these scripts in a few views.  Note that <tt>content_for</tt> concatenates (default) the blocks it is given for a particular identifier in order. For example:  <% content_for :navigation do %> <li><%= link_to 'Home', action: 'index' %></li> <% end %>  And in another place:  <% content_for :navigation do %> <li><%= link_to 'Login', action: 'login' %></li> <% end %>  Then, in another template or layout, this code would render both links in order:  <ul><%= content_for :navigation %></ul>  If the flush parameter is +true+ <tt>content_for</tt> replaces the blocks it is given. For example:  <% content_for :navigation do %> <li><%= link_to 'Home', action: 'index' %></li> <% end %>  <%# Add some other content, or use a different template: %>  <% content_for :navigation, flush: true do %> <li><%= link_to 'Login', action: 'login' %></li> <% end %>  Then, in another template or layout, this code would render only the last link:  <ul><%= content_for :navigation %></ul>  Lastly, simple content can be passed as a parameter:  <% content_for :script, javascript_include_tag(:defaults) %>  WARNING: <tt>content_for</tt> is ignored in caches. So you shouldn't use it for elements that will be fragment cached.",
    "label": "",
    "id": "794"
  },
  {
    "raw_code": "def provide(name, content = nil, &block)\n        content = capture(&block) if block_given?\n        result = @view_flow.append!(name, content) if content\n        result unless content\n      end",
    "comment": "The same as +content_for+ but when used with streaming flushes straight back to the layout. In other words, if you want to concatenate several times to the same buffer when rendering a given template, you should use +content_for+, if not, use +provide+ to tell the layout to stop looking for more contents.  See ActionController::Streaming for more information.",
    "label": "",
    "id": "795"
  },
  {
    "raw_code": "def content_for?(name)\n        @view_flow.get(name).present?\n      end",
    "comment": "<tt>content_for?</tt> checks whether any content has been captured yet using <tt>content_for</tt>.  Useful to render parts of your layout differently based on what is in your views.  <%# This is the layout %> <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\"> <head> <title>My Website</title> <%= yield :script %> </head> <body class=\"<%= content_for?(:right_col) ? 'two-column' : 'one-column' %>\"> <%= yield %> <%= yield :right_col %> </body> </html>",
    "label": "",
    "id": "796"
  },
  {
    "raw_code": "def with_output_buffer(buf = nil) # :nodoc:\n        unless buf\n          buf = ActionView::OutputBuffer.new\n          if output_buffer && output_buffer.respond_to?(:encoding)\n            buf.force_encoding(output_buffer.encoding)\n          end",
    "comment": "Use an alternate output buffer for the duration of the block. Defaults to a new empty string.",
    "label": "",
    "id": "797"
  },
  {
    "raw_code": "def csp_meta_tag(**options)\n        if content_security_policy?\n          options[:name] = \"csp-nonce\"\n          options[:content] = content_security_policy_nonce\n          tag(\"meta\", options)\n        end",
    "comment": "Returns a meta tag \"csp-nonce\" with the per-session nonce value for allowing inline <script> tags.  <head> <%= csp_meta_tag %> </head>  This is used by the \\Rails UJS helper to create dynamically loaded inline <script> elements. ",
    "label": "",
    "id": "798"
  },
  {
    "raw_code": "def csrf_meta_tags\n        if defined?(protect_against_forgery?) && protect_against_forgery?\n          [\n            tag(\"meta\", name: \"csrf-param\", content: request_forgery_protection_token),\n            tag(\"meta\", name: \"csrf-token\", content: form_authenticity_token)\n          ].join(\"\\n\").html_safe\n        end",
    "comment": "Returns meta tags \"csrf-param\" and \"csrf-token\" with the name of the cross-site request forgery protection parameter and token, respectively.  <head> <%= csrf_meta_tags %> </head>  These are used to generate the dynamic forms that implement non-remote links with <tt>:method</tt>.  You don't need to use these tags for regular forms as they generate their own hidden fields.  For Ajax requests other than GETs, extract the \"csrf-token\" from the meta-tag and send as the +X-CSRF-Token+ HTTP header. ",
    "label": "",
    "id": "799"
  },
  {
    "raw_code": "def distance_of_time_in_words(from_time, to_time = 0, options = {})\n        options = {\n          scope: :'datetime.distance_in_words'\n        }.merge!(options)\n\n        from_time = normalize_distance_of_time_argument_to_time(from_time)\n        to_time = normalize_distance_of_time_argument_to_time(to_time)\n        from_time, to_time = to_time, from_time if from_time > to_time\n        distance_in_minutes = ((to_time - from_time) / 60.0).round\n        distance_in_seconds = (to_time - from_time).round\n\n        I18n.with_options locale: options[:locale], scope: options[:scope] do |locale|\n          case distance_in_minutes\n          when 0..1\n            return distance_in_minutes == 0 ?\n                   locale.t(:less_than_x_minutes, count: 1) :\n                   locale.t(:x_minutes, count: distance_in_minutes) unless options[:include_seconds]\n\n            case distance_in_seconds\n            when 0..4   then locale.t :less_than_x_seconds, count: 5\n            when 5..9   then locale.t :less_than_x_seconds, count: 10\n            when 10..19 then locale.t :less_than_x_seconds, count: 20\n            when 20..39 then locale.t :half_a_minute\n            when 40..59 then locale.t :less_than_x_minutes, count: 1\n            else             locale.t :x_minutes,           count: 1\n            end",
    "comment": "Reports the approximate distance in time between two Time, Date, or DateTime objects or integers as seconds. Pass <tt>include_seconds: true</tt> if you want more detailed approximations when distance < 1 min, 29 secs. Distances are reported based on the following table:  0 <-> 29 secs                                                             # => less than a minute 30 secs <-> 1 min, 29 secs                                                # => 1 minute 1 min, 30 secs <-> 44 mins, 29 secs                                       # => [2..44] minutes 44 mins, 30 secs <-> 89 mins, 29 secs                                     # => about 1 hour 89 mins, 30 secs <-> 23 hrs, 59 mins, 29 secs                             # => about [2..24] hours 23 hrs, 59 mins, 30 secs <-> 41 hrs, 59 mins, 29 secs                     # => 1 day 41 hrs, 59 mins, 30 secs  <-> 29 days, 23 hrs, 59 mins, 29 secs           # => [2..29] days 29 days, 23 hrs, 59 mins, 30 secs <-> 44 days, 23 hrs, 59 mins, 29 secs   # => about 1 month 44 days, 23 hrs, 59 mins, 30 secs <-> 59 days, 23 hrs, 59 mins, 29 secs   # => about 2 months 59 days, 23 hrs, 59 mins, 30 secs <-> 1 yr minus 1 sec                    # => [2..12] months 1 yr <-> 1 yr, 3 months                                                   # => about 1 year 1 yr, 3 months <-> 1 yr, 9 months                                         # => over 1 year 1 yr, 9 months <-> 2 yr minus 1 sec                                       # => almost 2 years 2 yrs <-> max time or date                                                # => (same rules as 1 yr)  With <tt>include_seconds: true</tt> and the difference < 1 minute 29 seconds: 0-4   secs      # => less than 5 seconds 5-9   secs      # => less than 10 seconds 10-19 secs      # => less than 20 seconds 20-39 secs      # => half a minute 40-59 secs      # => less than a minute 60-89 secs      # => 1 minute  from_time = Time.now distance_of_time_in_words(from_time, from_time + 50.minutes)                                # => about 1 hour distance_of_time_in_words(from_time, 50.minutes.from_now)                                   # => about 1 hour distance_of_time_in_words(from_time, from_time + 15.seconds)                                # => less than a minute distance_of_time_in_words(from_time, from_time + 15.seconds, include_seconds: true)         # => less than 20 seconds distance_of_time_in_words(from_time, 3.years.from_now)                                      # => about 3 years distance_of_time_in_words(from_time, from_time + 60.hours)                                  # => 3 days distance_of_time_in_words(from_time, from_time + 45.seconds, include_seconds: true)         # => less than a minute distance_of_time_in_words(from_time, from_time - 45.seconds, include_seconds: true)         # => less than a minute distance_of_time_in_words(from_time, 76.seconds.from_now)                                   # => 1 minute distance_of_time_in_words(from_time, from_time + 1.year + 3.days)                           # => about 1 year distance_of_time_in_words(from_time, from_time + 3.years + 6.months)                        # => over 3 years distance_of_time_in_words(from_time, from_time + 4.years + 9.days + 30.minutes + 5.seconds) # => about 4 years  to_time = Time.now + 6.years + 19.days distance_of_time_in_words(from_time, to_time, include_seconds: true)                        # => about 6 years distance_of_time_in_words(to_time, from_time, include_seconds: true)                        # => about 6 years distance_of_time_in_words(Time.now, Time.now)                                               # => less than a minute  With the <tt>scope</tt> option, you can define a custom scope for \\Rails to look up the translation.  For example you can define the following in your locale (e.g. en.yml).  datetime: distance_in_words: short: about_x_hours: one: 'an hour' other: '%{count} hours'  See https://github.com/svenfuchs/rails-i18n/blob/master/rails/locale/en.yml for more examples.  Which will then result in the following:  from_time = Time.now distance_of_time_in_words(from_time, from_time + 50.minutes, scope: 'datetime.distance_in_words.short') # => \"an hour\" distance_of_time_in_words(from_time, from_time + 3.hours, scope: 'datetime.distance_in_words.short')    # => \"3 hours\"",
    "label": "",
    "id": "800"
  },
  {
    "raw_code": "def time_ago_in_words(from_time, options = {})\n        distance_of_time_in_words(from_time, Time.now, options)\n      end",
    "comment": "Like <tt>distance_of_time_in_words</tt>, but where <tt>to_time</tt> is fixed to <tt>Time.now</tt>.  time_ago_in_words(3.minutes.from_now)                 # => 3 minutes time_ago_in_words(3.minutes.ago)                      # => 3 minutes time_ago_in_words(Time.now - 15.hours)                # => about 15 hours time_ago_in_words(Time.now)                           # => less than a minute time_ago_in_words(Time.now, include_seconds: true) # => less than 5 seconds  from_time = Time.now - 3.days - 14.minutes - 25.seconds time_ago_in_words(from_time)      # => 3 days  from_time = (3.days + 14.minutes + 25.seconds).ago time_ago_in_words(from_time)      # => 3 days  Note that you cannot pass a <tt>Numeric</tt> value to <tt>time_ago_in_words</tt>. ",
    "label": "",
    "id": "801"
  },
  {
    "raw_code": "def relative_time_in_words(from_time, options = {})\n        now = Time.now\n        time = distance_of_time_in_words(from_time, now, options.except(:scope))\n        key = from_time > now ? :future : :past\n\n        I18n.t(key, time: time, scope: options.fetch(:scope, :'datetime.relative'), locale: options[:locale])\n      end",
    "comment": "Like <tt>time_ago_in_words</tt>, but adds a prefix/suffix depending on whether the time is in the past or future. You can use the <tt>scope</tt> option to customize the translation scope. All other options are forwarded to <tt>time_ago_in_words</tt>.  relative_time_in_words(3.minutes.from_now) # => \"in 3 minutes\" relative_time_in_words(3.minutes.ago) # => \"3 minutes ago\" relative_time_in_words(10.seconds.ago, include_seconds: true) # => \"less than 10 seconds ago\"  See also #time_ago_in_words",
    "label": "",
    "id": "802"
  },
  {
    "raw_code": "def date_select(object_name, method, options = {}, html_options = {})\n        Tags::DateSelect.new(object_name, method, self, options, html_options).render\n      end",
    "comment": "Returns a set of select tags (one for year, month, and day) pre-selected for accessing a specified date-based attribute (identified by +method+) on an object assigned to the template (identified by +object+).  ==== Options * <tt>:use_month_numbers</tt> - Set to true if you want to use month numbers rather than month names (e.g. \"2\" instead of \"February\"). * <tt>:use_two_digit_numbers</tt> - Set to true if you want to display two digit month and day numbers (e.g. \"02\" instead of \"February\" and \"08\" instead of \"8\"). * <tt>:use_short_month</tt>   - Set to true if you want to use abbreviated month names instead of full month names (e.g. \"Feb\" instead of \"February\"). * <tt>:add_month_numbers</tt>  - Set to true if you want to use both month numbers and month names (e.g. \"2 - February\" instead of \"February\"). * <tt>:use_month_names</tt>   - Set to an array with 12 month names if you want to customize month names. Note: You can also use Rails' i18n functionality for this. * <tt>:month_format_string</tt> - Set to a format string. The string gets passed keys +:number+ (integer) and +:name+ (string). A format string would be something like \"%{name} (%<number>02d)\" for example. See <tt>Kernel.sprintf</tt> for documentation on format sequences. * <tt>:date_separator</tt>    - Specifies a string to separate the date fields. Default is \"\" (i.e. nothing). * <tt>:time_separator</tt>    - Specifies a string to separate the time fields. Default is \" : \". * <tt>:datetime_separator</tt>- Specifies a string to separate the date and time fields. Default is \" &mdash; \". * <tt>:start_year</tt>        - Set the start year for the year select. Default is <tt>Date.today.year - 5</tt> if you are creating new record. While editing existing record, <tt>:start_year</tt> defaults to the current selected year minus 5. * <tt>:end_year</tt>          - Set the end year for the year select. Default is <tt>Date.today.year + 5</tt> if you are creating new record. While editing existing record, <tt>:end_year</tt> defaults to the current selected year plus 5. * <tt>:year_format</tt>       - Set format of years for year select. Lambda should be passed. * <tt>:day_format</tt>        - Set format of days for day select. Lambda should be passed. * <tt>:discard_day</tt>       - Set to true if you don't want to show a day select. This includes the day as a hidden field instead of showing a select field. Also note that this implicitly sets the day to be the first of the given month in order to not create invalid dates like 31 February. * <tt>:discard_month</tt>     - Set to true if you don't want to show a month select. This includes the month as a hidden field instead of showing a select field. Also note that this implicitly sets :discard_day to true. * <tt>:discard_year</tt>      - Set to true if you don't want to show a year select. This includes the year as a hidden field instead of showing a select field. * <tt>:order</tt>             - Set to an array containing <tt>:day</tt>, <tt>:month</tt> and <tt>:year</tt> to customize the order in which the select fields are shown. If you leave out any of the symbols, the respective select will not be shown (like when you set <tt>discard_xxx: true</tt>. Defaults to the order defined in the respective locale (e.g. [:year, :month, :day] in the en locale that ships with \\Rails). * <tt>:include_blank</tt>     - Include a blank option in every select field so it's possible to set empty dates. * <tt>:default</tt>           - Set a default date if the affected date isn't set or is +nil+. * <tt>:selected</tt>          - Set a date that overrides the actual value. * <tt>:disabled</tt>          - Set to true if you want show the select fields as disabled. * <tt>:prompt</tt>            - Set to true (for a generic prompt), a prompt string or a hash of prompt strings for <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>, <tt>:hour</tt>, <tt>:minute</tt> and <tt>:second</tt>. Setting this option prepends a select option with a generic prompt  (Day, Month, Year, Hour, Minute, Seconds) or the given prompt string. * <tt>:with_css_classes</tt>  - Set to true or a hash of strings. Use true if you want to assign generic styles for select tags. This automatically set classes 'year', 'month', 'day', 'hour', 'minute' and 'second'. A hash of strings for <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>, <tt>:hour</tt>, <tt>:minute</tt>, <tt>:second</tt> will extend the select type with the given value. Use +html_options+ to modify every select tag in the set. * <tt>:use_hidden</tt>         - Set to true if you only want to generate hidden input tags.  If anything is passed in the +html_options+ hash it will be applied to every select tag in the set.  NOTE: Discarded selects will default to 1. So if no month select is available, January will be assumed.  # Generates a date select that when POSTed is stored in the article variable, in the written_on attribute. date_select(\"article\", \"written_on\")  # Generates a date select that when POSTed is stored in the article variable, in the written_on attribute, # with the year in the year drop down box starting at 1995. date_select(\"article\", \"written_on\", start_year: 1995)  # Generates a date select that when POSTed is stored in the article variable, in the written_on attribute, # with the year in the year drop down box starting at 1995, numbers used for months instead of words, # and without a day select box. date_select(\"article\", \"written_on\", start_year: 1995, use_month_numbers: true, discard_day: true, include_blank: true)  # Generates a date select that when POSTed is stored in the article variable, in the written_on attribute, # with two digit numbers used for months and days. date_select(\"article\", \"written_on\", use_two_digit_numbers: true)  # Generates a date select that when POSTed is stored in the article variable, in the written_on attribute # with the fields ordered as day, month, year rather than month, day, year. date_select(\"article\", \"written_on\", order: [:day, :month, :year])  # Generates a date select that when POSTed is stored in the user variable, in the birthday attribute # lacking a year field. date_select(\"user\", \"birthday\", order: [:month, :day])  # Generates a date select that when POSTed is stored in the article variable, in the written_on attribute # which is initially set to the date 3 days from the current date date_select(\"article\", \"written_on\", default: 3.days.from_now)  # Generates a date select that when POSTed is stored in the article variable, in the written_on attribute # which is set in the form with today's date, regardless of the value in the Active Record object. date_select(\"article\", \"written_on\", selected: Date.today)  # Generates a date select that when POSTed is stored in the credit_card variable, in the bill_due attribute # that will have a default day of 20. date_select(\"credit_card\", \"bill_due\", default: { day: 20 })  # Generates a date select with custom prompts. date_select(\"article\", \"written_on\", prompt: { day: 'Select day', month: 'Select month', year: 'Select year' })  # Generates a date select with custom year format. date_select(\"article\", \"written_on\", year_format: ->(year) { \"Heisei #{year - 1988}\" })  # Generates a date select with custom day format. date_select(\"article\", \"written_on\", day_format: ->(day) { day.ordinalize })  The selects are prepared for multi-parameter assignment to an Active Record object.  Note: If the day is not included as an option but the month is, the day will be set to the 1st to ensure that all month choices are valid.",
    "label": "",
    "id": "803"
  },
  {
    "raw_code": "def time_select(object_name, method, options = {}, html_options = {})\n        Tags::TimeSelect.new(object_name, method, self, options, html_options).render\n      end",
    "comment": "Returns a set of select tags (one for hour, minute, and optionally second) pre-selected for accessing a specified time-based attribute (identified by +method+) on an object assigned to the template (identified by +object+). You can include the seconds with <tt>:include_seconds</tt>. You can get hours in the AM/PM format with <tt>:ampm</tt> option.  This method will also generate 3 input hidden tags, for the actual year, month, and day unless the option <tt>:ignore_date</tt> is set to +true+. If you set the <tt>:ignore_date</tt> to +true+, you must have a +date_select+ on the same method within the form otherwise an exception will be raised.  If anything is passed in the html_options hash it will be applied to every select tag in the set.  # Creates a time select tag that, when POSTed, will be stored in the article variable in the sunrise attribute. time_select(\"article\", \"sunrise\")  # Creates a time select tag with a seconds field that, when POSTed, will be stored in the article variables in # the sunrise attribute. time_select(\"article\", \"start_time\", include_seconds: true)  # You can set the <tt>:minute_step</tt> to 15 which will give you: 00, 15, 30, and 45. time_select 'game', 'game_time', { minute_step: 15 }  # Creates a time select tag with a custom prompt. Use <tt>prompt: true</tt> for generic prompts. time_select(\"article\", \"written_on\", prompt: { hour: 'Choose hour', minute: 'Choose minute', second: 'Choose seconds' }) time_select(\"article\", \"written_on\", prompt: { hour: true }) # generic prompt for hours time_select(\"article\", \"written_on\", prompt: true) # generic prompts for all  # You can set :ampm option to true which will show the hours as: 12 PM, 01 AM .. 11 PM. time_select 'game', 'game_time', { ampm: true }  # You can set :ignore_date option to true which will remove the hidden inputs for day, # month, and year that are set by default on this helper when you only want the time inputs time_select 'game', 'game_time', { ignore_date: true }  The selects are prepared for multi-parameter assignment to an Active Record object.  Note: If the day is not included as an option but the month is, the day will be set to the 1st to ensure that all month choices are valid.",
    "label": "",
    "id": "804"
  },
  {
    "raw_code": "def datetime_select(object_name, method, options = {}, html_options = {})\n        Tags::DatetimeSelect.new(object_name, method, self, options, html_options).render\n      end",
    "comment": "Returns a set of select tags (one for year, month, day, hour, and minute) pre-selected for accessing a specified datetime-based attribute (identified by +method+) on an object assigned to the template (identified by +object+).  If anything is passed in the html_options hash it will be applied to every select tag in the set.  # Generates a datetime select that, when POSTed, will be stored in the article variable in the written_on # attribute. datetime_select(\"article\", \"written_on\")  # Generates a datetime select with a year select that starts at 1995 that, when POSTed, will be stored in the # article variable in the written_on attribute. datetime_select(\"article\", \"written_on\", start_year: 1995)  # Generates a datetime select with a default value of 3 days from the current time that, when POSTed, will # be stored in the trip variable in the departing attribute. datetime_select(\"trip\", \"departing\", default: 3.days.from_now)  # Generate a datetime select with hours in the AM/PM format datetime_select(\"article\", \"written_on\", ampm: true)  # Generates a datetime select that discards the type that, when POSTed, will be stored in the article variable # as the written_on attribute. datetime_select(\"article\", \"written_on\", discard_type: true)  # Generates a datetime select with a custom prompt. Use <tt>prompt: true</tt> for generic prompts. datetime_select(\"article\", \"written_on\", prompt: { day: 'Choose day', month: 'Choose month', year: 'Choose year' }) datetime_select(\"article\", \"written_on\", prompt: { hour: true }) # generic prompt for hours datetime_select(\"article\", \"written_on\", prompt: true) # generic prompts for all  The selects are prepared for multi-parameter assignment to an Active Record object.",
    "label": "",
    "id": "805"
  },
  {
    "raw_code": "def select_datetime(datetime = Time.current, options = {}, html_options = {})\n        DateTimeSelector.new(datetime, options, html_options).select_datetime\n      end",
    "comment": "Returns a set of HTML select-tags (one for year, month, day, hour, minute, and second) pre-selected with the +datetime+. It's also possible to explicitly set the order of the tags using the <tt>:order</tt> option with an array of symbols <tt>:year</tt>, <tt>:month</tt> and <tt>:day</tt> in the desired order. If you do not supply a Symbol, it will be appended onto the <tt>:order</tt> passed in. You can also add <tt>:date_separator</tt>, <tt>:datetime_separator</tt> and <tt>:time_separator</tt> keys to the +options+ to control visual display of the elements.  If anything is passed in the html_options hash it will be applied to every select tag in the set.  my_date_time = Time.now + 4.days  # Generates a datetime select that defaults to the datetime in my_date_time (four days after today). select_datetime(my_date_time)  # Generates a datetime select that defaults to today (no specified datetime) select_datetime()  # Generates a datetime select that defaults to the datetime in my_date_time (four days after today) # with the fields ordered year, month, day rather than month, day, year. select_datetime(my_date_time, order: [:year, :month, :day])  # Generates a datetime select that defaults to the datetime in my_date_time (four days after today) # with a '/' between each date field. select_datetime(my_date_time, date_separator: '/')  # Generates a datetime select that defaults to the datetime in my_date_time (four days after today) # with a date fields separated by '/', time fields separated by '' and the date and time fields # separated by a comma (','). select_datetime(my_date_time, date_separator: '/', time_separator: '', datetime_separator: ',')  # Generates a datetime select that discards the type of the field and defaults to the datetime in # my_date_time (four days after today) select_datetime(my_date_time, discard_type: true)  # Generate a datetime field with hours in the AM/PM format select_datetime(my_date_time, ampm: true)  # Generates a datetime select that defaults to the datetime in my_date_time (four days after today) # prefixed with 'payday' rather than 'date' select_datetime(my_date_time, prefix: 'payday')  # Generates a datetime select with a custom prompt. Use <tt>prompt: true</tt> for generic prompts. select_datetime(my_date_time, prompt: { day: 'Choose day', month: 'Choose month', year: 'Choose year' }) select_datetime(my_date_time, prompt: { hour: true }) # generic prompt for hours select_datetime(my_date_time, prompt: true) # generic prompts for all",
    "label": "",
    "id": "806"
  },
  {
    "raw_code": "def select_date(date = Date.current, options = {}, html_options = {})\n        DateTimeSelector.new(date, options, html_options).select_date\n      end",
    "comment": "Returns a set of HTML select-tags (one for year, month, and day) pre-selected with the +date+. It's possible to explicitly set the order of the tags using the <tt>:order</tt> option with an array of symbols <tt>:year</tt>, <tt>:month</tt> and <tt>:day</tt> in the desired order. If the array passed to the <tt>:order</tt> option does not contain all the three symbols, all tags will be hidden.  If anything is passed in the html_options hash it will be applied to every select tag in the set.  my_date = Time.now + 6.days  # Generates a date select that defaults to the date in my_date (six days after today). select_date(my_date)  # Generates a date select that defaults to today (no specified date). select_date()  # Generates a date select that defaults to the date in my_date (six days after today) # with the fields ordered year, month, day rather than month, day, year. select_date(my_date, order: [:year, :month, :day])  # Generates a date select that discards the type of the field and defaults to the date in # my_date (six days after today). select_date(my_date, discard_type: true)  # Generates a date select that defaults to the date in my_date, # which has fields separated by '/'. select_date(my_date, date_separator: '/')  # Generates a date select that defaults to the datetime in my_date (six days after today) # prefixed with 'payday' rather than 'date'. select_date(my_date, prefix: 'payday')  # Generates a date select with a custom prompt. Use <tt>prompt: true</tt> for generic prompts. select_date(my_date, prompt: { day: 'Choose day', month: 'Choose month', year: 'Choose year' }) select_date(my_date, prompt: { hour: true }) # generic prompt for hours select_date(my_date, prompt: true) # generic prompts for all",
    "label": "",
    "id": "807"
  },
  {
    "raw_code": "def select_time(datetime = Time.current, options = {}, html_options = {})\n        DateTimeSelector.new(datetime, options, html_options).select_time\n      end",
    "comment": "Returns a set of HTML select-tags (one for hour and minute). You can set <tt>:time_separator</tt> key to format the output, and the <tt>:include_seconds</tt> option to include an input for seconds.  If anything is passed in the html_options hash it will be applied to every select tag in the set.  my_time = Time.now + 5.days + 7.hours + 3.minutes + 14.seconds  # Generates a time select that defaults to the time in my_time. select_time(my_time)  # Generates a time select that defaults to the current time (no specified time). select_time()  # Generates a time select that defaults to the time in my_time, # which has fields separated by ':'. select_time(my_time, time_separator: ':')  # Generates a time select that defaults to the time in my_time, # that also includes an input for seconds. select_time(my_time, include_seconds: true)  # Generates a time select that defaults to the time in my_time, that has fields # separated by ':' and includes an input for seconds. select_time(my_time, time_separator: ':', include_seconds: true)  # Generate a time select field with hours in the AM/PM format select_time(my_time, ampm: true)  # Generates a time select field with hours that range from 2 to 14 select_time(my_time, start_hour: 2, end_hour: 14)  # Generates a time select with a custom prompt. Use <tt>:prompt</tt> to true for generic prompts. select_time(my_time, prompt: { day: 'Choose day', month: 'Choose month', year: 'Choose year' }) select_time(my_time, prompt: { hour: true }) # generic prompt for hours select_time(my_time, prompt: true) # generic prompts for all",
    "label": "",
    "id": "808"
  },
  {
    "raw_code": "def select_second(datetime, options = {}, html_options = {})\n        DateTimeSelector.new(datetime, options, html_options).select_second\n      end",
    "comment": "Returns a select tag with options for each of the seconds 0 through 59 with the current second selected. The <tt>datetime</tt> can be either a +Time+ or +DateTime+ object or an integer. Override the field name using the <tt>:field_name</tt> option, 'second' by default.  my_time = Time.now + 16.seconds  # Generates a select field for seconds that defaults to the seconds for the time in my_time. select_second(my_time)  # Generates a select field for seconds that defaults to the number given. select_second(33)  # Generates a select field for seconds that defaults to the seconds for the time in my_time # that is named 'interval' rather than 'second'. select_second(my_time, field_name: 'interval')  # Generates a select field for seconds with a custom prompt. Use <tt>prompt: true</tt> for a # generic prompt. select_second(14, prompt: 'Choose seconds')",
    "label": "",
    "id": "809"
  },
  {
    "raw_code": "def select_minute(datetime, options = {}, html_options = {})\n        DateTimeSelector.new(datetime, options, html_options).select_minute\n      end",
    "comment": "Returns a select tag with options for each of the minutes 0 through 59 with the current minute selected. Also can return a select tag with options by <tt>minute_step</tt> from 0 through 59 with the 00 minute selected. The <tt>datetime</tt> can be either a +Time+ or +DateTime+ object or an integer. Override the field name using the <tt>:field_name</tt> option, 'minute' by default.  my_time = Time.now + 10.minutes  # Generates a select field for minutes that defaults to the minutes for the time in my_time. select_minute(my_time)  # Generates a select field for minutes that defaults to the number given. select_minute(14)  # Generates a select field for minutes that defaults to the minutes for the time in my_time # that is named 'moment' rather than 'minute'. select_minute(my_time, field_name: 'moment')  # Generates a select field for minutes with a custom prompt. Use <tt>prompt: true</tt> for a # generic prompt. select_minute(14, prompt: 'Choose minutes')",
    "label": "",
    "id": "810"
  },
  {
    "raw_code": "def select_hour(datetime, options = {}, html_options = {})\n        DateTimeSelector.new(datetime, options, html_options).select_hour\n      end",
    "comment": "Returns a select tag with options for each of the hours 0 through 23 with the current hour selected. The <tt>datetime</tt> can be either a +Time+ or +DateTime+ object or an integer. Override the field name using the <tt>:field_name</tt> option, 'hour' by default.  my_time = Time.now + 6.hours  # Generates a select field for hours that defaults to the hour for the time in my_time. select_hour(my_time)  # Generates a select field for hours that defaults to the number given. select_hour(13)  # Generates a select field for hours that defaults to the hour for the time in my_time # that is named 'stride' rather than 'hour'. select_hour(my_time, field_name: 'stride')  # Generates a select field for hours with a custom prompt. Use <tt>prompt: true</tt> for a # generic prompt. select_hour(13, prompt: 'Choose hour')  # Generate a select field for hours in the AM/PM format select_hour(my_time, ampm: true)  # Generates a select field that includes options for hours from 2 to 14. select_hour(my_time, start_hour: 2, end_hour: 14)",
    "label": "",
    "id": "811"
  },
  {
    "raw_code": "def select_day(date, options = {}, html_options = {})\n        DateTimeSelector.new(date, options, html_options).select_day\n      end",
    "comment": "Returns a select tag with options for each of the days 1 through 31 with the current day selected. The <tt>date</tt> can also be substituted for a day number. If you want to display days with a leading zero set the <tt>:use_two_digit_numbers</tt> key in +options+ to true. Override the field name using the <tt>:field_name</tt> option, 'day' by default.  my_date = Time.now + 2.days  # Generates a select field for days that defaults to the day for the date in my_date. select_day(my_date)  # Generates a select field for days that defaults to the number given. select_day(5)  # Generates a select field for days that defaults to the number given, but displays it with two digits. select_day(5, use_two_digit_numbers: true)  # Generates a select field for days that defaults to the day for the date in my_date # that is named 'due' rather than 'day'. select_day(my_date, field_name: 'due')  # Generates a select field for days with a custom prompt. Use <tt>prompt: true</tt> for a # generic prompt. select_day(5, prompt: 'Choose day')",
    "label": "",
    "id": "812"
  },
  {
    "raw_code": "def select_month(date, options = {}, html_options = {})\n        DateTimeSelector.new(date, options, html_options).select_month\n      end",
    "comment": "Returns a select tag with options for each of the months January through December with the current month selected. The month names are presented as keys (what's shown to the user) and the month numbers (1-12) are used as values (what's submitted to the server). It's also possible to use month numbers for the presentation instead of names -- set the <tt>:use_month_numbers</tt> key in +options+ to true for this to happen. If you want both numbers and names, set the <tt>:add_month_numbers</tt> key in +options+ to true. If you would prefer to show month names as abbreviations, set the <tt>:use_short_month</tt> key in +options+ to true. If you want to use your own month names, set the <tt>:use_month_names</tt> key in +options+ to an array of 12 month names. If you want to display months with a leading zero set the <tt>:use_two_digit_numbers</tt> key in +options+ to true. Override the field name using the <tt>:field_name</tt> option, 'month' by default.  # Generates a select field for months that defaults to the current month that # will use keys like \"January\", \"March\". select_month(Date.today)  # Generates a select field for months that defaults to the current month that # is named \"start\" rather than \"month\". select_month(Date.today, field_name: 'start')  # Generates a select field for months that defaults to the current month that # will use keys like \"1\", \"3\". select_month(Date.today, use_month_numbers: true)  # Generates a select field for months that defaults to the current month that # will use keys like \"1 - January\", \"3 - March\". select_month(Date.today, add_month_numbers: true)  # Generates a select field for months that defaults to the current month that # will use keys like \"Jan\", \"Mar\". select_month(Date.today, use_short_month: true)  # Generates a select field for months that defaults to the current month that # will use keys like \"Januar\", \"Marts.\" select_month(Date.today, use_month_names: %w(Januar Februar Marts ...))  # Generates a select field for months that defaults to the current month that # will use keys with two digit numbers like \"01\", \"03\". select_month(Date.today, use_two_digit_numbers: true)  # Generates a select field for months with a custom prompt. Use <tt>prompt: true</tt> for a # generic prompt. select_month(14, prompt: 'Choose month')",
    "label": "",
    "id": "813"
  },
  {
    "raw_code": "def select_year(date, options = {}, html_options = {})\n        DateTimeSelector.new(date, options, html_options).select_year\n      end",
    "comment": "Returns a select tag with options for each of the five years on each side of the current, which is selected. The five year radius can be changed using the <tt>:start_year</tt> and <tt>:end_year</tt> keys in the +options+. Both ascending and descending year lists are supported by making <tt>:start_year</tt> less than or greater than <tt>:end_year</tt>. The <tt>date</tt> can also be substituted for a year given as a number. Override the field name using the <tt>:field_name</tt> option, 'year' by default.  # Generates a select field for years that defaults to the current year that # has ascending year values. select_year(Date.today, start_year: 1992, end_year: 2007)  # Generates a select field for years that defaults to the current year that # is named 'birth' rather than 'year'. select_year(Date.today, field_name: 'birth')  # Generates a select field for years that defaults to the current year that # has descending year values. select_year(Date.today, start_year: 2005, end_year: 1900)  # Generates a select field for years that defaults to the year 2006 that # has ascending year values. select_year(2006, start_year: 2000, end_year: 2010)  # Generates a select field for years with a custom prompt. Use <tt>prompt: true</tt> for a # generic prompt. select_year(14, prompt: 'Choose year')",
    "label": "",
    "id": "814"
  },
  {
    "raw_code": "def time_tag(date_or_time, *args, &block)\n        options  = args.extract_options!\n        format   = options.delete(:format) || :long\n        content  = args.first || I18n.l(date_or_time, format: format)\n\n        content_tag(\"time\", content, options.reverse_merge(datetime: date_or_time.iso8601), &block)\n      end",
    "comment": "Returns an HTML time tag for the given date or time.  time_tag Date.today  # => <time datetime=\"2010-11-04\">November 04, 2010</time> time_tag Time.now  # => <time datetime=\"2010-11-04T17:55:45+01:00\">November 04, 2010 17:55</time> time_tag Date.yesterday, 'Yesterday'  # => <time datetime=\"2010-11-03\">Yesterday</time> time_tag Date.today, datetime: Date.today.strftime('%G-W%V') # => <time datetime=\"2010-W44\">November 04, 2010</time>  <%= time_tag Time.now do %> <span>Right now</span> <% end %> # => <time datetime=\"2010-11-04T17:55:45+01:00\"><span>Right now</span></time>",
    "label": "",
    "id": "815"
  },
  {
    "raw_code": "def set_day_if_discarded\n          if @datetime && @options[:discard_day]\n            @datetime = @datetime.change(day: 1)\n          end",
    "comment": "If the day is hidden, the day should be set to the 1st so all month and year choices are valid. Otherwise, February 31st or February 29th, 2011 can be selected, which are invalid.",
    "label": "",
    "id": "816"
  },
  {
    "raw_code": "def month_names\n          @month_names ||= begin\n            month_names = @options[:use_month_names] || translated_month_names\n            month_names = [nil, *month_names] if month_names.size < 13\n            month_names\n          end",
    "comment": "Returns translated month names, but also ensures that a custom month name array has a leading +nil+ element.",
    "label": "",
    "id": "817"
  },
  {
    "raw_code": "def translated_month_names\n          key = @options[:use_short_month] ? :'date.abbr_month_names' : :'date.month_names'\n          I18n.translate(key, locale: @options[:locale])\n        end",
    "comment": "Returns translated month names. => [nil, \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]  If <tt>:use_short_month</tt> option is set => [nil, \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]",
    "label": "",
    "id": "818"
  },
  {
    "raw_code": "def day_name(number)\n          if day_format_lambda = @options[:day_format]\n            day_format_lambda.call(number)\n          elsif @options[:use_two_digit_numbers]\n            \"%02d\" % number\n          else\n            number\n          end",
    "comment": "Looks up day names by number.  day_name(1) # => 1  If the <tt>use_two_digit_numbers: true</tt> option is passed to DateTimeSelector:  day_name(1) # => \"01\"  If the <tt>day_format: ->(day) { day.ordinalize }</tt> option is passed to DateTimeSelector:  day_name(1) # => \"1st\"",
    "label": "",
    "id": "819"
  },
  {
    "raw_code": "def month_name(number)\n          if @options[:use_month_numbers]\n            number\n          elsif @options[:use_two_digit_numbers]\n            \"%02d\" % number\n          elsif @options[:add_month_numbers]\n            \"#{number} - #{month_names[number]}\"\n          elsif format_string = @options[:month_format_string]\n            format_string % { number: number, name: month_names[number] }\n          else\n            month_names[number]\n          end",
    "comment": "Looks up month names by number (1-based):  month_name(1) # => \"January\"  If the <tt>:use_month_numbers</tt> option is passed:  month_name(1) # => 1  If the <tt>:use_two_digit_numbers</tt> option is passed:  month_name(1) # => '01'  If the <tt>:add_month_numbers</tt> option is passed:  month_name(1) # => \"1 - January\"  If the <tt>:month_format_string</tt> option is passed:  month_name(1) # => \"January (01)\"  depending on the format string.",
    "label": "",
    "id": "820"
  },
  {
    "raw_code": "def year_name(number)\n          if year_format_lambda = @options[:year_format]\n            year_format_lambda.call(number)\n          else\n            number\n          end",
    "comment": "Looks up year names by number.  year_name(1998) # => 1998  If the <tt>:year_format</tt> option is passed:  year_name(1998) # => \"Heisei 10\"",
    "label": "",
    "id": "821"
  },
  {
    "raw_code": "def build_options_and_select(type, selected, options = {})\n          build_select(type, build_options(selected, options))\n        end",
    "comment": "Build full select tag from date type and options.",
    "label": "",
    "id": "822"
  },
  {
    "raw_code": "def build_options(selected, options = {})\n          options = {\n            leading_zeros: true, ampm: false, use_two_digit_numbers: false\n          }.merge!(options)\n\n          start         = options.delete(:start) || 0\n          stop          = options.delete(:end) || 59\n          step          = options.delete(:step) || 1\n          leading_zeros = options.delete(:leading_zeros)\n\n          select_options = []\n          start.step(stop, step) do |i|\n            value = leading_zeros ? sprintf(\"%02d\", i) : i\n            tag_options = { value: value }\n            tag_options[:selected] = \"selected\" if selected == i\n            text = options[:use_two_digit_numbers] ? sprintf(\"%02d\", i) : value\n            text = options[:ampm] ? AMPM_TRANSLATION[i] : text\n            select_options << content_tag(\"option\", text, tag_options)\n          end",
    "comment": "Build select option HTML from date value and options.  build_options(15, start: 1, end: 31) => \"<option value=\"1\">1</option> <option value=\"2\">2</option> <option value=\"3\">3</option>...\"  If <tt>use_two_digit_numbers: true</tt> option is passed:  build_options(15, start: 1, end: 31, use_two_digit_numbers: true) => \"<option value=\"1\">01</option> <option value=\"2\">02</option> <option value=\"3\">03</option>...\"  If <tt>:step</tt> options is passed:  build_options(15, start: 1, end: 31, step: 2) => \"<option value=\"1\">1</option> <option value=\"3\">3</option> <option value=\"5\">5</option>...\"",
    "label": "",
    "id": "823"
  },
  {
    "raw_code": "def build_day_options(selected)\n          select_options = []\n          (1..31).each do |value|\n            tag_options = { value: value }\n            tag_options[:selected] = \"selected\" if selected == value\n            text = day_name(value)\n            select_options << content_tag(\"option\", text, tag_options)\n          end",
    "comment": "Build select option HTML for day.  build_day_options(2) => \"<option value=\"1\">1</option> <option value=\"2\" selected=\"selected\">2</option> <option value=\"3\">3</option>...\"  If <tt>day_format: ->(day) { day.ordinalize }</tt> option is passed to DateTimeSelector  build_day_options(2) => \"<option value=\"1\">1st</option> <option value=\"2\" selected=\"selected\">2nd</option> <option value=\"3\">3rd</option>...\"  If <tt>use_two_digit_numbers: true</tt> option is passed to DateTimeSelector  build_day_options(2) => \"<option value=\"1\">01</option> <option value=\"2\" selected=\"selected\">02</option> <option value=\"3\">03</option>...\"",
    "label": "",
    "id": "824"
  },
  {
    "raw_code": "def build_year_options(selected, options = {})\n          start = options.delete(:start)\n          stop = options.delete(:end)\n          step = options.delete(:step)\n\n          select_options = []\n          start.step(stop, step) do |value|\n            tag_options = { value: value }\n            tag_options[:selected] = \"selected\" if selected == value\n            text = year_name(value)\n            select_options << content_tag(\"option\", text, tag_options)\n          end",
    "comment": "Build select option HTML for year.  build_year_options(1998, start: 1998, end: 2000) => \"<option value=\"1998\" selected=\"selected\">1998</option> <option value=\"1999\">1999</option> <option value=\"2000\">2000</option>\"",
    "label": "",
    "id": "825"
  },
  {
    "raw_code": "def build_select(type, select_options_as_html)\n          select_options = {\n            id: input_id_from_type(type),\n            name: input_name_from_type(type)\n          }.merge!(@html_options)\n          select_options[:disabled] = \"disabled\" if @options[:disabled]\n          select_options[:class] = css_class_attribute(type, select_options[:class], @options[:with_css_classes]) if @options[:with_css_classes]\n\n          select_html = +\"\\n\"\n          select_html << content_tag(\"option\", \"\", value: \"\", label: \" \") + \"\\n\" if @options[:include_blank]\n          select_html << prompt_option_tag(type, @options[:prompt]) + \"\\n\" if @options[:prompt]\n          select_html << select_options_as_html\n\n          (content_tag(\"select\", select_html.html_safe, select_options) + \"\\n\").html_safe\n        end",
    "comment": "Builds select tag from date type and HTML select options.  build_select(:month, \"<option value=\"1\">January</option>...\") => \"<select id=\"post_written_on_2i\" name=\"post[written_on(2i)]\"> <option value=\"1\">January</option>... </select>\"",
    "label": "",
    "id": "826"
  },
  {
    "raw_code": "def css_class_attribute(type, html_options_class, options) # :nodoc:\n          css_class = \\\n            case options\n            when Hash\n              options[type.to_sym]\n            else\n              type\n            end",
    "comment": "Builds the CSS class value for the select element.  css_class_attribute(:year, 'date optional', { year: 'my-year' }) => \"date optional my-year\"",
    "label": "",
    "id": "827"
  },
  {
    "raw_code": "def prompt_option_tag(type, options)\n          prompt = \\\n            case options\n            when Hash\n              default_options = { year: false, month: false, day: false, hour: false, minute: false, second: false }\n              default_options.merge!(options)[type.to_sym]\n            when String\n              options\n            else\n              I18n.translate(:\"datetime.prompts.#{type}\", locale: @options[:locale])\n            end",
    "comment": "Builds a prompt option tag with supplied options or from default options.  prompt_option_tag(:month, prompt: 'Select month') => \"<option value=\"\">Select month</option>\"",
    "label": "",
    "id": "828"
  },
  {
    "raw_code": "def build_hidden(type, value)\n          select_options = {\n            type: \"hidden\",\n            id: input_id_from_type(type),\n            name: input_name_from_type(type),\n            value: value,\n            autocomplete: \"off\"\n          }.merge!(@html_options.slice(:disabled))\n          select_options[:disabled] = \"disabled\" if @options[:disabled]\n\n          tag(:input, select_options) + \"\\n\".html_safe\n        end",
    "comment": "Builds hidden input tag for date part and value.  build_hidden(:year, 2008) => \"<input type=\"hidden\" id=\"date_year\" name=\"date[year]\" value=\"2008\" autocomplete=\"off\" />\"",
    "label": "",
    "id": "829"
  },
  {
    "raw_code": "def input_name_from_type(type)\n          prefix = @options[:prefix] || ActionView::Helpers::DateTimeSelector::DEFAULT_PREFIX\n          prefix += \"[#{@options[:index]}]\" if @options.has_key?(:index)\n\n          field_name = @options[:field_name] || type.to_s\n          if @options[:include_position]\n            field_name += \"(#{ActionView::Helpers::DateTimeSelector::POSITION[type]}i)\"\n          end",
    "comment": "Returns the name attribute for the input tag. => post[written_on(1i)]",
    "label": "",
    "id": "830"
  },
  {
    "raw_code": "def input_id_from_type(type)\n          id = input_name_from_type(type).gsub(/([\\[(])|(\\]\\[)/, \"_\").gsub(/[\\])]/, \"\")\n          id = @options[:namespace] + \"_\" + id if @options[:namespace]\n\n          id\n        end",
    "comment": "Returns the id attribute for the input tag. => \"post_written_on_1i\"",
    "label": "",
    "id": "831"
  },
  {
    "raw_code": "def build_selects_from_types(order)\n          select = +\"\"\n          first_visible = order.find { |type| !@options[:\"discard_#{type}\"] }\n          order.reverse_each do |type|\n            separator = separator(type) unless type == first_visible # don't add before first visible field\n            select.insert(0, separator.to_s + public_send(\"select_#{type}\").to_s)\n          end",
    "comment": "Given an ordering of datetime components, create the selection HTML and join them with their appropriate separators.",
    "label": "",
    "id": "832"
  },
  {
    "raw_code": "def separator(type)\n          return \"\" if @options[:use_hidden]\n\n          case type\n          when :year, :month, :day\n            @options[:\"discard_#{type}\"] ? \"\" : @options[:date_separator]\n          when :hour\n            (@options[:discard_year] && @options[:discard_day]) ? \"\" : @options[:datetime_separator]\n          when :minute, :second\n            @options[:\"discard_#{type}\"] ? \"\" : @options[:time_separator]\n          end",
    "comment": "Returns the separator for a given datetime component.",
    "label": "",
    "id": "833"
  },
  {
    "raw_code": "def date_select(method, options = {}, html_options = {})\n        @template.date_select(@object_name, method, objectify_options(options), html_options)\n      end",
    "comment": "Wraps ActionView::Helpers::DateHelper#date_select for form builders:  <%= form_with model: @person do |f| %> <%= f.date_select :birth_date %> <%= f.submit %> <% end %>  Please refer to the documentation of the base helper for details.",
    "label": "",
    "id": "834"
  },
  {
    "raw_code": "def time_select(method, options = {}, html_options = {})\n        @template.time_select(@object_name, method, objectify_options(options), html_options)\n      end",
    "comment": "Wraps ActionView::Helpers::DateHelper#time_select for form builders:  <%= form_with model: @race do |f| %> <%= f.time_select :average_lap %> <%= f.submit %> <% end %>  Please refer to the documentation of the base helper for details.",
    "label": "",
    "id": "835"
  },
  {
    "raw_code": "def datetime_select(method, options = {}, html_options = {})\n        @template.datetime_select(@object_name, method, objectify_options(options), html_options)\n      end",
    "comment": "Wraps ActionView::Helpers::DateHelper#datetime_select for form builders:  <%= form_with model: @person do |f| %> <%= f.datetime_select :last_request_at %> <%= f.submit %> <% end %>  Please refer to the documentation of the base helper for details.",
    "label": "",
    "id": "836"
  },
  {
    "raw_code": "def debug(object)\n        Marshal.dump(object)\n        object = ERB::Util.html_escape(object.to_yaml)\n        content_tag(:pre, object, class: \"debug_dump\")\n      rescue # errors from Marshal or YAML\n        # Object couldn't be dumped, perhaps because of singleton methods -- this is the fallback\n        content_tag(:code, object.inspect, class: \"debug_dump\")\n      end",
    "comment": "Returns a YAML representation of +object+ wrapped with <pre> and </pre>. If the object cannot be converted to YAML using +to_yaml+, +inspect+ will be called instead. Useful for inspecting an object at the time of rendering.  @user = User.new({ username: 'testing', password: 'xyz', age: 42}) debug(@user) # => <pre class='debug_dump'>--- !ruby/object:User attributes: updated_at: username: testing age: 42 password: xyz created_at: </pre>",
    "label": "",
    "id": "837"
  },
  {
    "raw_code": "def form_for(record, options = {}, &block)\n        raise ArgumentError, \"Missing block\" unless block_given?\n\n        case record\n        when String, Symbol\n          model       = false\n          object_name = record\n        else\n          model       = record\n          object      = _object_for_form_builder(record)\n          raise ArgumentError, \"First argument in form cannot contain nil or be empty\" unless object\n          object_name = options[:as] || model_name_from_record_or_class(object).param_key\n          apply_form_for_options!(object, options)\n        end",
    "comment": "Creates a form that allows the user to create or update the attributes of a specific model object.  The method can be used in several slightly different ways, depending on how much you wish to rely on \\Rails to infer automatically from the model how the form should be constructed. For a generic model object, a form can be created by passing +form_for+ a string or symbol representing the object we are concerned with:  <%= form_for :person do |f| %> First name: <%= f.text_field :first_name %><br /> Last name : <%= f.text_field :last_name %><br /> Biography : <%= f.textarea :biography %><br /> Admin?    : <%= f.checkbox :admin %><br /> <%= f.submit %> <% end %>  The variable +f+ yielded to the block is a FormBuilder object that incorporates the knowledge about the model object represented by <tt>:person</tt> passed to +form_for+. Methods defined on the FormBuilder are used to generate fields bound to this model. Thus, for example,  <%= f.text_field :first_name %>  will get expanded to  <%= text_field :person, :first_name %>  which results in an HTML <tt><input></tt> tag whose +name+ attribute is <tt>person[first_name]</tt>. This means that when the form is submitted, the value entered by the user will be available in the controller as <tt>params[:person][:first_name]</tt>.  For fields generated in this way using the FormBuilder, if <tt>:person</tt> also happens to be the name of an instance variable <tt>@person</tt>, the default value of the field shown when the form is initially displayed (e.g. in the situation where you are editing an existing record) will be the value of the corresponding attribute of <tt>@person</tt>.  The rightmost argument to +form_for+ is an optional hash of options -  * <tt>:url</tt> - The URL the form is to be submitted to. This may be represented in the same way as values passed to +url_for+ or +link_to+. So for example you may use a named route directly. When the model is represented by a string or symbol, as in the example above, if the <tt>:url</tt> option is not specified, by default the form will be sent back to the current URL (We will describe below an alternative resource-oriented usage of +form_for+ in which the URL does not need to be specified explicitly). * <tt>:namespace</tt> - A namespace for your form to ensure uniqueness of id attributes on form elements. The namespace attribute will be prefixed with underscore on the generated HTML id. * <tt>:method</tt> - The method to use when submitting the form, usually either \"get\" or \"post\". If \"patch\", \"put\", \"delete\", or another verb is used, a hidden input with name <tt>_method</tt> is added to simulate the verb over post. * <tt>:authenticity_token</tt> - Authenticity token to use in the form. Use only if you need to pass custom authenticity token string, or to not add authenticity_token field at all (by passing <tt>false</tt>). Remote forms may omit the embedded authenticity token by setting <tt>config.action_view.embed_authenticity_token_in_remote_forms = false</tt>. This is helpful when you're fragment-caching the form. Remote forms get the authenticity token from the <tt>meta</tt> tag, so embedding is unnecessary unless you support browsers without JavaScript. * <tt>:remote</tt> - If set to true, will allow the Unobtrusive JavaScript drivers to control the submit behavior. * <tt>:enforce_utf8</tt> - If set to false, a hidden input with name utf8 is not output. * <tt>:html</tt> - Optional HTML attributes for the form tag.  Also note that +form_for+ doesn't create an exclusive scope. It's still possible to use both the stand-alone FormHelper methods and methods from FormTagHelper. For example:  <%= form_for :person do |f| %> First name: <%= f.text_field :first_name %> Last name : <%= f.text_field :last_name %> Biography : <%= textarea :person, :biography %> Admin?    : <%= checkbox_tag \"person[admin]\", \"1\", @person.company.admin? %> <%= f.submit %> <% end %>  This also works for the methods in FormOptionsHelper and DateHelper that are designed to work with an object as base, like FormOptionsHelper#collection_select and DateHelper#datetime_select.  === +form_for+ with a model object  In the examples above, the object to be created or edited was represented by a symbol passed to +form_for+, and we noted that a string can also be used equivalently. It is also possible, however, to pass a model object itself to +form_for+. For example, if <tt>@article</tt> is an existing record you wish to edit, you can create the form using  <%= form_for @article do |f| %> ... <% end %>  This behaves in almost the same way as outlined previously, with a couple of small exceptions. First, the prefix used to name the input elements within the form (hence the key that denotes them in the +params+ hash) is actually derived from the object's _class_, e.g. <tt>params[:article]</tt> if the object's class is +Article+. However, this can be overwritten using the <tt>:as</tt> option, e.g. -  <%= form_for(@person, as: :client) do |f| %> ... <% end %>  would result in <tt>params[:client]</tt>.  Secondly, the field values shown when the form is initially displayed are taken from the attributes of the object passed to +form_for+, regardless of whether the object is an instance variable. So, for example, if we had a _local_ variable +article+ representing an existing record,  <%= form_for article do |f| %> ... <% end %>  would produce a form with fields whose initial state reflect the current values of the attributes of +article+.  === Resource-oriented style  In the examples just shown, although not indicated explicitly, we still need to use the <tt>:url</tt> option in order to specify where the form is going to be sent. However, further simplification is possible if the record passed to +form_for+ is a _resource_, i.e. it corresponds to a set of RESTful routes, e.g. defined using the +resources+ method in <tt>config/routes.rb</tt>. In this case \\Rails will simply infer the appropriate URL from the record itself. For example,  <%= form_for @article do |f| %> ... <% end %>  is then equivalent to something like:  <%= form_for @article, as: :article, url: article_path(@article), method: :patch, html: { class: \"edit_article\", id: \"edit_article_45\" } do |f| %> ... <% end %>  And for a new record  <%= form_for(Article.new) do |f| %> ... <% end %>  is equivalent to something like:  <%= form_for @article, as: :article, url: articles_path, html: { class: \"new_article\", id: \"new_article\" } do |f| %> ... <% end %>  However you can still overwrite individual conventions, such as:  <%= form_for(@article, url: super_articles_path) do |f| %> ... <% end %>  You can omit the <tt>action</tt> attribute by passing <tt>url: false</tt>:  <%= form_for(@article, url: false) do |f| %> ... <% end %>  You can also set the answer format, like this:  <%= form_for(@article, format: :json) do |f| %> ... <% end %>  For namespaced routes, like +admin_article_url+:  <%= form_for([:admin, @article]) do |f| %> ... <% end %>  If your resource has associations defined, for example, you want to add comments to the document given that the routes are set correctly:  <%= form_for([@document, @comment]) do |f| %> ... <% end %>  Where <tt>@document = Document.find(params[:id])</tt> and <tt>@comment = Comment.new</tt>.  === Setting the method  You can force the form to use the full array of HTTP verbs by setting  method: (:get|:post|:patch|:put|:delete)  in the options hash. If the verb is not GET or POST, which are natively supported by HTML forms, the form will be set to POST and a hidden input called _method will carry the intended verb for the server to interpret.  === Unobtrusive JavaScript  Specifying:  remote: true  in the options hash creates a form that will allow the unobtrusive JavaScript drivers to modify its behavior. The form submission will work just like a regular submission as viewed by the receiving side (all elements available in <tt>params</tt>).  Example:  <%= form_for(@article, remote: true) do |f| %> ... <% end %>  The HTML generated for this would be:  <form action='http://www.example.com' method='post' data-remote='true'> <input name='_method' type='hidden' value='patch' /> ... </form>  === Setting HTML options  You can set data attributes directly by passing in a data hash, but all other HTML options must be wrapped in the HTML key. Example:  <%= form_for(@article, data: { behavior: \"autosave\" }, html: { name: \"go\" }) do |f| %> ... <% end %>  The HTML generated for this would be:  <form action='http://www.example.com' method='post' data-behavior='autosave' name='go'> <input name='_method' type='hidden' value='patch' /> ... </form>  === Removing hidden model id's  The +form_for+ method automatically includes the model id as a hidden field in the form. This is used to maintain the correlation between the form data and its associated model. Some ORM systems do not use IDs on nested models so in this case you want to be able to disable the hidden id.  In the following example the Article model has many Comments stored within it in a NoSQL database, thus there is no primary key for comments.  Example:  <%= form_for(@article) do |f| %> <%= f.fields_for(:comments, include_id: false) do |cf| %> ... <% end %> <% end %>  === Customized form builders  You can also build forms using a customized FormBuilder class. Subclass FormBuilder and override or define some more helpers, then use your custom builder. For example, let's say you made a helper to automatically add labels to form inputs.  <%= form_for @person, url: { action: \"create\" }, builder: LabellingFormBuilder do |f| %> <%= f.text_field :first_name %> <%= f.text_field :last_name %> <%= f.textarea :biography %> <%= f.checkbox :admin %> <%= f.submit %> <% end %>  In this case, if you use this:  <%= render f %>  The rendered template is <tt>people/_labelling_form</tt> and the local variable referencing the form builder is called <tt>labelling_form</tt>.  The custom FormBuilder class is automatically merged with the options of a nested fields_for call, unless it's explicitly set.  In many cases you will want to wrap the above in another helper, so you could do something like the following:  def labelled_form_for(record_or_name_or_array, *args, &block) options = args.extract_options! form_for(record_or_name_or_array, *(args << options.merge(builder: LabellingFormBuilder)), &block) end  If you don't need to attach a form to a model instance, then check out FormTagHelper#form_tag.  === Form to external resources  When you build forms to external resources sometimes you need to set an authenticity token or just render a form without it, for example when you submit data to a payment gateway number and types of fields could be limited.  To set an authenticity token you need to pass an <tt>:authenticity_token</tt> parameter  <%= form_for @invoice, url: external_url, authenticity_token: 'external_token' do |f| %> ... <% end %>  If you don't want to an authenticity token field be rendered at all just pass <tt>false</tt>:  <%= form_for @invoice, url: external_url, authenticity_token: false do |f| %> ... <% end %>",
    "label": "",
    "id": "838"
  },
  {
    "raw_code": "def form_with(model: false, scope: nil, url: nil, format: nil, **options, &block)\n        raise ArgumentError, \"Passed nil to the :model argument, expect an object or false\" if model.nil?\n\n        options = { allow_method_names_outside_object: true, skip_default_ids: !form_with_generates_ids }.merge!(options)\n\n        if model\n          if url != false\n            url ||= if format.nil?\n              polymorphic_path(model, {})\n            else\n              polymorphic_path(model, format: format)\n            end",
    "comment": "Creates a form tag based on mixing URLs, scopes, or models.  # Using just a URL: <%= form_with url: articles_path do |form| %> <%= form.text_field :title %> <% end %> # => <form action=\"/articles\" method=\"post\"> <input type=\"text\" name=\"title\" /> </form>  # With an intentionally empty URL: <%= form_with url: false do |form| %> <%= form.text_field :title %> <% end %> # => <form method=\"post\"> <input type=\"text\" name=\"title\" /> </form>  # Adding a scope prefixes the input field names: <%= form_with scope: :article, url: articles_path do |form| %> <%= form.text_field :title %> <% end %> # => <form action=\"/articles\" method=\"post\"> <input type=\"text\" name=\"article[title]\" /> </form>  # Using a model infers both the URL and scope: <%= form_with model: Article.new do |form| %> <%= form.text_field :title %> <% end %> # => <form action=\"/articles\" method=\"post\"> <input type=\"text\" name=\"article[title]\" /> </form>  # An existing model makes an update form and fills out field values: <%= form_with model: Article.first do |form| %> <%= form.text_field :title %> <% end %> # => <form action=\"/articles/1\" method=\"post\"> <input type=\"hidden\" name=\"_method\" value=\"patch\" /> <input type=\"text\" name=\"article[title]\" value=\"<the title of the article>\" /> </form> # Though the fields don't have to correspond to model attributes: <%= form_with model: Cat.new do |form| %> <%= form.text_field :cats_dont_have_gills %> <%= form.text_field :but_in_forms_they_can %> <% end %> # => <form action=\"/cats\" method=\"post\"> <input type=\"text\" name=\"cat[cats_dont_have_gills]\" /> <input type=\"text\" name=\"cat[but_in_forms_they_can]\" /> </form>  The parameters in the forms are accessible in controllers according to their name nesting. So inputs named +title+ and <tt>article[title]</tt> are accessible as <tt>params[:title]</tt> and <tt>params[:article][:title]</tt> respectively.  For ease of comparison the examples above left out the submit button, as well as the auto generated hidden fields that enable UTF-8 support and adds an authenticity token needed for cross site request forgery protection.  === Resource-oriented style  In many of the examples just shown, the +:model+ passed to +form_with+ is a _resource_. It corresponds to a set of RESTful routes, most likely defined via +resources+ in <tt>config/routes.rb</tt>.  So when passing such a model record, \\Rails infers the URL and method.  <%= form_with model: @article do |form| %> ... <% end %>  is then equivalent to something like:  <%= form_with scope: :article, url: article_path(@article), method: :patch do |form| %> ... <% end %>  And for a new record  <%= form_with model: Article.new do |form| %> ... <% end %>  is equivalent to something like:  <%= form_with scope: :article, url: articles_path do |form| %> ... <% end %>  ==== +form_with+ options  * <tt>:url</tt> - The URL the form submits to. Akin to values passed to +url_for+ or +link_to+. For example, you may use a named route directly. When a <tt>:scope</tt> is passed without a <tt>:url</tt> the form just submits to the current URL. * <tt>:method</tt> - The method to use when submitting the form, usually either \"get\" or \"post\". If \"patch\", \"put\", \"delete\", or another verb is used, a hidden input named <tt>_method</tt> is added to simulate the verb over post. * <tt>:format</tt> - The format of the route the form submits to. Useful when submitting to another resource type, like <tt>:json</tt>. Skipped if a <tt>:url</tt> is passed. * <tt>:scope</tt> - The scope to prefix input field names with and thereby how the submitted parameters are grouped in controllers. * <tt>:namespace</tt> - A namespace for your form to ensure uniqueness of id attributes on form elements. The namespace attribute will be prefixed with underscore on the generated HTML id. * <tt>:model</tt> - A model object to infer the <tt>:url</tt> and <tt>:scope</tt> by, plus fill out input field values. So if a +title+ attribute is set to \"Ahoy!\" then a +title+ input field's value would be \"Ahoy!\". If the model is a new record a create form is generated, if an existing record, however, an update form is generated. Pass <tt>:scope</tt> or <tt>:url</tt> to override the defaults. E.g. turn <tt>params[:article]</tt> into <tt>params[:blog]</tt>. * <tt>:authenticity_token</tt> - Authenticity token to use in the form. Override with a custom authenticity token or pass <tt>false</tt> to skip the authenticity token field altogether. Useful when submitting to an external resource like a payment gateway that might limit the valid fields. Remote forms may omit the embedded authenticity token by setting <tt>config.action_view.embed_authenticity_token_in_remote_forms = false</tt>. This is helpful when fragment-caching the form. Remote forms get the authenticity token from the <tt>meta</tt> tag, so embedding is unnecessary unless you support browsers without JavaScript. * <tt>:local</tt> - Whether to use standard HTTP form submission. When set to <tt>true</tt>, the form is submitted via standard HTTP. When set to <tt>false</tt>, the form is submitted as a \"remote form\", which is handled by \\Rails UJS as an XHR. When unspecified, the behavior is derived from <tt>config.action_view.form_with_generates_remote_forms</tt> where the config's value is actually the inverse of what <tt>local</tt>'s value would be. As of \\Rails 6.1, that configuration option defaults to <tt>false</tt> (which has the equivalent effect of passing <tt>local: true</tt>). In previous versions of \\Rails, that configuration option defaults to <tt>true</tt> (the equivalent of passing <tt>local: false</tt>). * <tt>:skip_enforcing_utf8</tt> - If set to true, a hidden input with name utf8 is not output. * <tt>:builder</tt> - Override the object used to build the form. * <tt>:id</tt> - Optional HTML id attribute. * <tt>:class</tt> - Optional HTML class attribute. * <tt>:data</tt> - Optional HTML data attributes. * <tt>:html</tt> - Other optional HTML attributes for the form tag.  === Examples  When not passing a block, +form_with+ just generates an opening form tag.  <%= form_with(model: @article, url: super_articles_path) %> <%= form_with(model: @article, scope: :blog) %> <%= form_with(model: @article, format: :json) %> <%= form_with(model: @article, authenticity_token: false) %> # Disables the token.  For namespaced routes, like +admin_article_url+:  <%= form_with(model: [ :admin, @article ]) do |form| %> ... <% end %>  If your resource has associations defined, for example, you want to add comments to the document given that the routes are set correctly:  <%= form_with(model: [ @document, Comment.new ]) do |form| %> ... <% end %>  Where <tt>@document = Document.find(params[:id])</tt>.  === Mixing with other form helpers  While +form_with+ uses a FormBuilder object it's possible to mix and match the stand-alone FormHelper methods and methods from FormTagHelper:  <%= form_with scope: :person do |form| %> <%= form.text_field :first_name %> <%= form.text_field :last_name %>  <%= textarea :person, :biography %> <%= checkbox_tag \"person[admin]\", \"1\", @person.company.admin? %>  <%= form.submit %> <% end %>  Same goes for the methods in FormOptionsHelper and DateHelper designed to work with an object as a base, like FormOptionsHelper#collection_select and DateHelper#datetime_select.  === Setting the method  You can force the form to use the full array of HTTP verbs by setting  method: (:get|:post|:patch|:put|:delete)  in the options hash. If the verb is not GET or POST, which are natively supported by HTML forms, the form will be set to POST and a hidden input called _method will carry the intended verb for the server to interpret.  === Setting HTML options  You can set data attributes directly in a data hash, but HTML options besides id and class must be wrapped in an HTML key:  <%= form_with(model: @article, data: { behavior: \"autosave\" }, html: { name: \"go\" }) do |form| %> ... <% end %>  generates  <form action=\"/articles/123\" method=\"post\" data-behavior=\"autosave\" name=\"go\"> <input name=\"_method\" type=\"hidden\" value=\"patch\" /> ... </form>  === Removing hidden model id's  The +form_with+ method automatically includes the model id as a hidden field in the form. This is used to maintain the correlation between the form data and its associated model. Some ORM systems do not use IDs on nested models so in this case you want to be able to disable the hidden id.  In the following example the Article model has many Comments stored within it in a NoSQL database, thus there is no primary key for comments.  <%= form_with(model: @article) do |form| %> <%= form.fields(:comments, skip_id: true) do |fields| %> ... <% end %> <% end %>  === Customized form builders  You can also build forms using a customized FormBuilder class. Subclass FormBuilder and override or define some more helpers, then use your custom builder. For example, let's say you made a helper to automatically add labels to form inputs.  <%= form_with model: @person, url: { action: \"create\" }, builder: LabellingFormBuilder do |form| %> <%= form.text_field :first_name %> <%= form.text_field :last_name %> <%= form.textarea :biography %> <%= form.checkbox :admin %> <%= form.submit %> <% end %>  In this case, if you use:  <%= render form %>  The rendered template is <tt>people/_labelling_form</tt> and the local variable referencing the form builder is called <tt>labelling_form</tt>.  The custom FormBuilder class is automatically merged with the options of a nested +fields+ call, unless it's explicitly set.  In many cases you will want to wrap the above in another helper, so you could do something like the following:  def labelled_form_with(**options, &block) form_with(**options.merge(builder: LabellingFormBuilder), &block) end",
    "label": "",
    "id": "839"
  },
  {
    "raw_code": "def fields_for(record_name, record_object = nil, options = {}, &block)\n        options = { model: record_object, allow_method_names_outside_object: false, skip_default_ids: false }.merge!(options)\n\n        fields(record_name, **options, &block)\n      end",
    "comment": "Creates a scope around a specific model object like #form_with, but doesn't create the form tags themselves. This makes +fields_for+ suitable for specifying additional model objects in the same form.  Although the usage and purpose of +fields_for+ is similar to #form_with's, its method signature is slightly different. Like #form_with, it yields a FormBuilder object associated with a particular model object to a block, and within the block allows methods to be called on the builder to generate fields associated with the model object. Fields may reflect a model object in two ways - how they are named (hence how submitted values appear within the +params+ hash in the controller) and what default values are shown when the form fields are first displayed. In order for both of these features to be specified independently, both an object name (represented by either a symbol or string) and the object itself can be passed to the method separately -  <%= form_with model: @person do |person_form| %> First name: <%= person_form.text_field :first_name %> Last name : <%= person_form.text_field :last_name %>  <%= fields_for :permission, @person.permission do |permission_fields| %> Admin?  : <%= permission_fields.checkbox :admin %> <% end %>  <%= person_form.submit %> <% end %>  In this case, the checkbox field will be represented by an HTML +input+ tag with the +name+ attribute <tt>permission[admin]</tt>, and the submitted value will appear in the controller as <tt>params[:permission][:admin]</tt>. If <tt>@person.permission</tt> is an existing record with an attribute +admin+, the initial state of the checkbox when first displayed will reflect the value of <tt>@person.permission.admin</tt>.  Often this can be simplified by passing just the name of the model object to +fields_for+ -  <%= fields_for :permission do |permission_fields| %> Admin?: <%= permission_fields.checkbox :admin %> <% end %>  ...in which case, if <tt>:permission</tt> also happens to be the name of an instance variable <tt>@permission</tt>, the initial state of the input field will reflect the value of that variable's attribute <tt>@permission.admin</tt>.  Alternatively, you can pass just the model object itself (if the first argument isn't a string or symbol +fields_for+ will realize that the name has been omitted) -  <%= fields_for @person.permission do |permission_fields| %> Admin?: <%= permission_fields.checkbox :admin %> <% end %>  and +fields_for+ will derive the required name of the field from the _class_ of the model object, e.g. if <tt>@person.permission</tt>, is of class +Permission+, the field will still be named <tt>permission[admin]</tt>.  Note: This also works for the methods in FormOptionsHelper and DateHelper that are designed to work with an object as base, like FormOptionsHelper#collection_select and DateHelper#datetime_select.  === Nested Attributes Examples  When the object belonging to the current scope has a nested attribute writer for a certain attribute, +fields_for+ will yield a new scope for that attribute. This allows you to create forms that set or change the attributes of a parent object and its associations in one go.  Nested attribute writers are normal setter methods named after an association. The most common way of defining these writers is either with +accepts_nested_attributes_for+ in a model definition or by defining a method with the proper name. For example: the attribute writer for the association <tt>:address</tt> is called <tt>address_attributes=</tt>.  Whether a one-to-one or one-to-many style form builder will be yielded depends on whether the normal reader method returns a _single_ object or an _array_ of objects.  ==== One-to-one  Consider a Person class which returns a _single_ Address from the <tt>address</tt> reader method and responds to the <tt>address_attributes=</tt> writer method:  class Person def address @address end  def address_attributes=(attributes) # Process the attributes hash end end  This model can now be used with a nested fields_for, like so:  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :address do |address_fields| %> Street  : <%= address_fields.text_field :street %> Zip code: <%= address_fields.text_field :zip_code %> <% end %> ... <% end %>  When address is already an association on a Person you can use +accepts_nested_attributes_for+ to define the writer method for you:  class Person < ActiveRecord::Base has_one :address accepts_nested_attributes_for :address end  If you want to destroy the associated model through the form, you have to enable it first using the <tt>:allow_destroy</tt> option for +accepts_nested_attributes_for+:  class Person < ActiveRecord::Base has_one :address accepts_nested_attributes_for :address, allow_destroy: true end  Now, when you use a form element with the <tt>_destroy</tt> parameter, with a value that evaluates to +true+, you will destroy the associated model (e.g. 1, '1', true, or 'true'):  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :address do |address_fields| %> ... Delete: <%= address_fields.checkbox :_destroy %> <% end %> ... <% end %>  ==== One-to-many  Consider a Person class which returns an _array_ of Project instances from the <tt>projects</tt> reader method and responds to the <tt>projects_attributes=</tt> writer method:  class Person def projects [@project1, @project2] end  def projects_attributes=(attributes) # Process the attributes hash end end  Note that the <tt>projects_attributes=</tt> writer method is in fact required for +fields_for+ to correctly identify <tt>:projects</tt> as a collection, and the correct indices to be set in the form markup.  When projects is already an association on Person you can use +accepts_nested_attributes_for+ to define the writer method for you:  class Person < ActiveRecord::Base has_many :projects accepts_nested_attributes_for :projects end  This model can now be used with a nested fields_for. The block given to the nested +fields_for+ call will be repeated for each instance in the collection:  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects do |project_fields| %> <% if project_fields.object.active? %> Name: <%= project_fields.text_field :name %> <% end %> <% end %> ... <% end %>  It's also possible to specify the instance to be used:  <%= form_with model: @person do |person_form| %> ... <% @person.projects.each do |project| %> <% if project.active? %> <%= person_form.fields_for :projects, project do |project_fields| %> Name: <%= project_fields.text_field :name %> <% end %> <% end %> <% end %> ... <% end %>  Or a collection to be used:  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects, @active_projects do |project_fields| %> Name: <%= project_fields.text_field :name %> <% end %> ... <% end %>  If you want to destroy any of the associated models through the form, you have to enable it first using the <tt>:allow_destroy</tt> option for +accepts_nested_attributes_for+:  class Person < ActiveRecord::Base has_many :projects accepts_nested_attributes_for :projects, allow_destroy: true end  This will allow you to specify which models to destroy in the attributes hash by adding a form element for the <tt>_destroy</tt> parameter with a value that evaluates to +true+ (e.g. 1, '1', true, or 'true'):  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects do |project_fields| %> Delete: <%= project_fields.checkbox :_destroy %> <% end %> ... <% end %>  When a collection is used you might want to know the index of each object in the array. For this purpose, the <tt>index</tt> method is available in the FormBuilder object.  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects do |project_fields| %> Project #<%= project_fields.index %> ... <% end %> ... <% end %>  Note that +fields_for+ will automatically generate a hidden field to store the ID of the record if it responds to <tt>persisted?</tt>. There are circumstances where this hidden field is not needed and you can pass <tt>include_id: false</tt> to prevent +fields_for+ from rendering it automatically.",
    "label": "",
    "id": "840"
  },
  {
    "raw_code": "def fields(scope = nil, model: nil, **options, &block)\n        options = { allow_method_names_outside_object: true, skip_default_ids: !form_with_generates_ids }.merge!(options)\n\n        if model\n          model   = _object_for_form_builder(model)\n          scope ||= model_name_from_record_or_class(model).param_key\n        end",
    "comment": "Scopes input fields with either an explicit scope or model. Like #form_with does with <tt>:scope</tt> or <tt>:model</tt>, except it doesn't output the form tags.  # Using a scope prefixes the input field names: <%= fields :comment do |fields| %> <%= fields.text_field :body %> <% end %> # => <input type=\"text\" name=\"comment[body]\">  # Using a model infers the scope and assigns field values: <%= fields model: Comment.new(body: \"full bodied\") do |fields| %> <%= fields.text_field :body %> <% end %> # => <input type=\"text\" name=\"comment[body]\" value=\"full bodied\">  # Using `fields` with `form_with`: <%= form_with model: @article do |form| %> <%= form.text_field :title %>  <%= form.fields :comment do |fields| %> <%= fields.text_field :body %> <% end %> <% end %>  Much like #form_with a FormBuilder instance associated with the scope or model is yielded, so any generated field names are prefixed with either the passed scope or the scope inferred from the <tt>:model</tt>.  === Mixing with other form helpers  While #form_with uses a FormBuilder object it's possible to mix and match the stand-alone FormHelper methods and methods from FormTagHelper:  <%= fields model: @comment do |fields| %> <%= fields.text_field :body %>  <%= textarea :commenter, :biography %> <%= checkbox_tag \"comment[all_caps]\", \"1\", @comment.commenter.hulk_mode? %> <% end %>  Same goes for the methods in FormOptionsHelper and DateHelper designed to work with an object as a base, like FormOptionsHelper#collection_select and DateHelper#datetime_select.",
    "label": "",
    "id": "841"
  },
  {
    "raw_code": "def label(object_name, method, content_or_options = nil, options = nil, &block)\n        Tags::Label.new(object_name, method, self, content_or_options, options).render(&block)\n      end",
    "comment": "Returns a label tag tailored for labelling an input field for a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). The text of label will default to the attribute name unless a translation is found in the current I18n locale (through <tt>helpers.label.<modelname>.<attribute></tt>) or you specify it explicitly. Additional options on the label tag can be passed as a hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example shown, except for the <tt>:value</tt> option, which is designed to target labels for radio_button tags (where the value is used in the ID of the input tag).  ==== Examples label(:article, :title) # => <label for=\"article_title\">Title</label>  You can localize your labels based on model and attribute names. For example you can define the following in your locale (e.g. en.yml)  helpers: label: article: body: \"Write your entire text here\"  Which then will result in  label(:article, :body) # => <label for=\"article_body\">Write your entire text here</label>  Localization can also be based purely on the translation of the attribute-name (if you are using ActiveRecord):  activerecord: attributes: article: cost: \"Total cost\"  <code></code>  label(:article, :cost) # => <label for=\"article_cost\">Total cost</label>  label(:article, :title, \"A short title\") # => <label for=\"article_title\">A short title</label>  label(:article, :title, \"A short title\", class: \"title_label\") # => <label for=\"article_title\" class=\"title_label\">A short title</label>  label(:article, :privacy, \"Public Article\", value: \"public\") # => <label for=\"article_privacy_public\">Public Article</label>  label(:article, :cost) do |translation| content_tag(:span, translation, class: \"cost_label\") end # => <label for=\"article_cost\"><span class=\"cost_label\">Total cost</span></label>  label(:article, :cost) do |builder| content_tag(:span, builder.translation, class: \"cost_label\") end # => <label for=\"article_cost\"><span class=\"cost_label\">Total cost</span></label>  label(:article, :terms) do raw('Accept <a href=\"/terms\">Terms</a>.') end # => <label for=\"article_terms\">Accept <a href=\"/terms\">Terms</a>.</label>",
    "label": "",
    "id": "842"
  },
  {
    "raw_code": "def text_field(object_name, method, options = {})\n        Tags::TextField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns an input tag of the \"text\" type tailored for accessing a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). Additional options on the input tag can be passed as a hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example shown.  ==== Examples text_field(:article, :title, size: 20) # => <input type=\"text\" id=\"article_title\" name=\"article[title]\" size=\"20\" value=\"#{@article.title}\" />  text_field(:article, :title, class: \"create_input\") # => <input type=\"text\" id=\"article_title\" name=\"article[title]\" value=\"#{@article.title}\" class=\"create_input\" />  text_field(:article, :title,  maxlength: 30, class: \"title_input\") # => <input type=\"text\" id=\"article_title\" name=\"article[title]\" maxlength=\"30\" size=\"30\" value=\"#{@article.title}\" class=\"title_input\" />  text_field(:session, :user, onchange: \"if ($('#session_user').val() === 'admin') { alert('Your login cannot be admin!'); }\") # => <input type=\"text\" id=\"session_user\" name=\"session[user]\" value=\"#{@session.user}\" onchange=\"if ($('#session_user').val() === 'admin') { alert('Your login cannot be admin!'); }\"/>  text_field(:snippet, :code, size: 20, class: 'code_input') # => <input type=\"text\" id=\"snippet_code\" name=\"snippet[code]\" size=\"20\" value=\"#{@snippet.code}\" class=\"code_input\" />",
    "label": "",
    "id": "843"
  },
  {
    "raw_code": "def password_field(object_name, method, options = {})\n        Tags::PasswordField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns an input tag of the \"password\" type tailored for accessing a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). Additional options on the input tag can be passed as a hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example shown. For security reasons this field is blank by default; pass in a value via +options+ if this is not desired.  ==== Examples password_field(:login, :pass, size: 20) # => <input type=\"password\" id=\"login_pass\" name=\"login[pass]\" size=\"20\" />  password_field(:account, :secret, class: \"form_input\", value: @account.secret) # => <input type=\"password\" id=\"account_secret\" name=\"account[secret]\" value=\"#{@account.secret}\" class=\"form_input\" />  password_field(:user, :password, onchange: \"if ($('#user_password').val().length > 30) { alert('Your password needs to be shorter!'); }\") # => <input type=\"password\" id=\"user_password\" name=\"user[password]\" onchange=\"if ($('#user_password').val().length > 30) { alert('Your password needs to be shorter!'); }\"/>  password_field(:account, :pin, size: 20, class: 'form_input') # => <input type=\"password\" id=\"account_pin\" name=\"account[pin]\" size=\"20\" class=\"form_input\" />",
    "label": "",
    "id": "844"
  },
  {
    "raw_code": "def hidden_field(object_name, method, options = {})\n        Tags::HiddenField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns a hidden input tag tailored for accessing a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). Additional options on the input tag can be passed as a hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example shown.  ==== Examples hidden_field(:signup, :pass_confirm) # => <input type=\"hidden\" id=\"signup_pass_confirm\" name=\"signup[pass_confirm]\" value=\"#{@signup.pass_confirm}\" />  hidden_field(:article, :tag_list) # => <input type=\"hidden\" id=\"article_tag_list\" name=\"article[tag_list]\" value=\"#{@article.tag_list}\" />  hidden_field(:user, :token) # => <input type=\"hidden\" id=\"user_token\" name=\"user[token]\" value=\"#{@user.token}\" />",
    "label": "",
    "id": "845"
  },
  {
    "raw_code": "def file_field(object_name, method, options = {})\n        options = { include_hidden: multiple_file_field_include_hidden }.merge!(options)\n\n        Tags::FileField.new(object_name, method, self, convert_direct_upload_option_to_url(options.dup)).render\n      end",
    "comment": "Returns a file upload input tag tailored for accessing a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). Additional options on the input tag can be passed as a hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example shown.  Using this method inside a #form_with block will set the enclosing form's encoding to <tt>multipart/form-data</tt>.  ==== Options * Creates standard HTML attributes for the tag. * <tt>:disabled</tt> - If set to true, the user will not be able to use this input. * <tt>:multiple</tt> - If set to true, *in most updated browsers* the user will be allowed to select multiple files. * <tt>:include_hidden</tt> - When <tt>multiple: true</tt> and <tt>include_hidden: true</tt>, the field will be prefixed with an <tt><input type=\"hidden\"></tt> field with an empty value to support submitting an empty collection of files. * <tt>:accept</tt> - If set to one or multiple mime-types, the user will be suggested a filter when choosing a file. You still need to set up model validations.  ==== Examples file_field(:user, :avatar) # => <input type=\"file\" id=\"user_avatar\" name=\"user[avatar]\" />  file_field(:article, :image, multiple: true) # => <input type=\"file\" id=\"article_image\" name=\"article[image][]\" multiple=\"multiple\" />  file_field(:article, :attached, accept: 'text/html') # => <input accept=\"text/html\" type=\"file\" id=\"article_attached\" name=\"article[attached]\" />  file_field(:article, :image, accept: 'image/png,image/gif,image/jpeg') # => <input type=\"file\" id=\"article_image\" name=\"article[image]\" accept=\"image/png,image/gif,image/jpeg\" />  file_field(:attachment, :file, class: 'file_input') # => <input type=\"file\" id=\"attachment_file\" name=\"attachment[file]\" class=\"file_input\" />",
    "label": "",
    "id": "846"
  },
  {
    "raw_code": "def textarea(object_name, method, options = {})\n        Tags::TextArea.new(object_name, method, self, options).render\n      end",
    "comment": "Returns a textarea opening and closing tag set tailored for accessing a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). Additional options on the input tag can be passed as a hash with +options+.  ==== Examples textarea(:article, :body, cols: 20, rows: 40) # => <textarea cols=\"20\" rows=\"40\" id=\"article_body\" name=\"article[body]\"> #      #{@article.body} #    </textarea>  textarea(:comment, :text, size: \"20x30\") # => <textarea cols=\"20\" rows=\"30\" id=\"comment_text\" name=\"comment[text]\"> #      #{@comment.text} #    </textarea>  textarea(:application, :notes, cols: 40, rows: 15, class: 'app_input') # => <textarea cols=\"40\" rows=\"15\" id=\"application_notes\" name=\"application[notes]\" class=\"app_input\"> #      #{@application.notes} #    </textarea>  textarea(:entry, :body, size: \"20x20\", disabled: 'disabled') # => <textarea cols=\"20\" rows=\"20\" id=\"entry_body\" name=\"entry[body]\" disabled=\"disabled\"> #      #{@entry.body} #    </textarea>",
    "label": "",
    "id": "847"
  },
  {
    "raw_code": "def checkbox(object_name, method, options = {}, checked_value = \"1\", unchecked_value = \"0\")\n        Tags::CheckBox.new(object_name, method, self, checked_value, unchecked_value, options).render\n      end",
    "comment": "Returns a checkbox tag tailored for accessing a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). This object must be an instance object (@object) and not a local object. It's intended that +method+ returns an integer and if that integer is above zero, then the checkbox is checked. Additional options on the input tag can be passed as a hash with +options+. The +checked_value+ defaults to 1 while the default +unchecked_value+ is set to 0 which is convenient for boolean values.  ==== Options  * Any standard HTML attributes for the tag can be passed in, for example +:class+. * <tt>:checked</tt> - +true+ or +false+ forces the state of the checkbox to be checked or not. * <tt>:include_hidden</tt> - If set to false, the auxiliary hidden field described below will not be generated.  ==== Gotcha  The HTML specification says unchecked check boxes are not successful, and thus web browsers do not send them. Unfortunately this introduces a gotcha: if an +Invoice+ model has a +paid+ flag, and in the form that edits a paid invoice the user unchecks its check box, no +paid+ parameter is sent. So, any mass-assignment idiom like  @invoice.update(params[:invoice])  wouldn't update the flag.  To prevent this the helper generates an auxiliary hidden field before every check box. The hidden field has the same name and its attributes mimic an unchecked check box.  This way, the client either sends only the hidden field (representing the check box is unchecked), or both fields. Since the HTML specification says key/value pairs have to be sent in the same order they appear in the form, and parameters extraction gets the last occurrence of any repeated key in the query string, that works for ordinary forms.  Unfortunately that workaround does not work when the check box goes within an array-like parameter, as in  <%= fields_for \"project[invoice_attributes][]\", invoice, index: nil do |form| %> <%= form.checkbox :paid %> ... <% end %>  because parameter name repetition is precisely what \\Rails seeks to distinguish the elements of the array. For each item with a checked check box you get an extra ghost item with only that attribute, assigned to \"0\".  In that case it is preferable to either use FormTagHelper#checkbox_tag or to use hashes instead of arrays.  ==== Examples  # Let's say that @article.validated? is 1: checkbox(\"article\", \"validated\") # => <input name=\"article[validated]\" type=\"hidden\" value=\"0\" /> #    <input checked=\"checked\" type=\"checkbox\" id=\"article_validated\" name=\"article[validated]\" value=\"1\" />  # Let's say that @puppy.gooddog is \"no\": checkbox(\"puppy\", \"gooddog\", {}, \"yes\", \"no\") # => <input name=\"puppy[gooddog]\" type=\"hidden\" value=\"no\" /> #    <input type=\"checkbox\" id=\"puppy_gooddog\" name=\"puppy[gooddog]\" value=\"yes\" />  checkbox(\"eula\", \"accepted\", { class: 'eula_check' }, \"yes\", \"no\") # => <input name=\"eula[accepted]\" type=\"hidden\" value=\"no\" /> #    <input type=\"checkbox\" class=\"eula_check\" id=\"eula_accepted\" name=\"eula[accepted]\" value=\"yes\" />",
    "label": "",
    "id": "848"
  },
  {
    "raw_code": "def radio_button(object_name, method, tag_value, options = {})\n        Tags::RadioButton.new(object_name, method, self, tag_value, options).render\n      end",
    "comment": "Returns a radio button tag for accessing a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). If the current value of +method+ is +tag_value+ the radio button will be checked.  To force the radio button to be checked pass <tt>checked: true</tt> in the +options+ hash. You may pass HTML options there as well.  # Let's say that @article.category returns \"rails\": radio_button(\"article\", \"category\", \"rails\") radio_button(\"article\", \"category\", \"java\") # => <input type=\"radio\" id=\"article_category_rails\" name=\"article[category]\" value=\"rails\" checked=\"checked\" /> #    <input type=\"radio\" id=\"article_category_java\" name=\"article[category]\" value=\"java\" />  # Let's say that @user.receive_newsletter returns \"no\": radio_button(\"user\", \"receive_newsletter\", \"yes\") radio_button(\"user\", \"receive_newsletter\", \"no\") # => <input type=\"radio\" id=\"user_receive_newsletter_yes\" name=\"user[receive_newsletter]\" value=\"yes\" /> #    <input type=\"radio\" id=\"user_receive_newsletter_no\" name=\"user[receive_newsletter]\" value=\"no\" checked=\"checked\" />",
    "label": "",
    "id": "849"
  },
  {
    "raw_code": "def color_field(object_name, method, options = {})\n        Tags::ColorField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns a text_field of type \"color\".  color_field(\"car\", \"color\") # => <input id=\"car_color\" name=\"car[color]\" type=\"color\" value=\"#000000\" />",
    "label": "",
    "id": "850"
  },
  {
    "raw_code": "def search_field(object_name, method, options = {})\n        Tags::SearchField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns an input of type \"search\" for accessing a specified attribute (identified by +method+) on an object assigned to the template (identified by +object_name+). Inputs of type \"search\" may be styled differently by some browsers.  search_field(:user, :name) # => <input id=\"user_name\" name=\"user[name]\" type=\"search\" /> search_field(:user, :name, autosave: false) # => <input autosave=\"false\" id=\"user_name\" name=\"user[name]\" type=\"search\" /> search_field(:user, :name, results: 3) # => <input id=\"user_name\" name=\"user[name]\" results=\"3\" type=\"search\" /> #  Assume request.host returns \"www.example.com\" search_field(:user, :name, autosave: true) # => <input autosave=\"com.example.www\" id=\"user_name\" name=\"user[name]\" results=\"10\" type=\"search\" /> search_field(:user, :name, onsearch: true) # => <input id=\"user_name\" incremental=\"true\" name=\"user[name]\" onsearch=\"true\" type=\"search\" /> search_field(:user, :name, autosave: false, onsearch: true) # => <input autosave=\"false\" id=\"user_name\" incremental=\"true\" name=\"user[name]\" onsearch=\"true\" type=\"search\" /> search_field(:user, :name, autosave: true, onsearch: true) # => <input autosave=\"com.example.www\" id=\"user_name\" incremental=\"true\" name=\"user[name]\" onsearch=\"true\" results=\"10\" type=\"search\" />",
    "label": "",
    "id": "851"
  },
  {
    "raw_code": "def telephone_field(object_name, method, options = {})\n        Tags::TelField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns a text_field of type \"tel\".  telephone_field(\"user\", \"phone\") # => <input id=\"user_phone\" name=\"user[phone]\" type=\"tel\" /> ",
    "label": "",
    "id": "852"
  },
  {
    "raw_code": "def date_field(object_name, method, options = {})\n        Tags::DateField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns a text_field of type \"date\".  date_field(\"user\", \"born_on\") # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"date\" />  The default value is generated by trying to call +strftime+ with \"%Y-%m-%d\" on the object's value, which makes it behave as expected for instances of DateTime and ActiveSupport::TimeWithZone. You can still override that by passing the \"value\" option explicitly, e.g.  @user.born_on = Date.new(1984, 1, 27) date_field(\"user\", \"born_on\", value: \"1984-05-12\") # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"date\" value=\"1984-05-12\" />  You can create values for the \"min\" and \"max\" attributes by passing instances of Date or Time to the options hash.  date_field(\"user\", \"born_on\", min: Date.today) # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"date\" min=\"2014-05-20\" />  Alternatively, you can pass a String formatted as an ISO8601 date as the values for \"min\" and \"max.\"  date_field(\"user\", \"born_on\", min: \"2014-05-20\") # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"date\" min=\"2014-05-20\" /> ",
    "label": "",
    "id": "853"
  },
  {
    "raw_code": "def time_field(object_name, method, options = {})\n        Tags::TimeField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns a text_field of type \"time\".  The default value is generated by trying to call +strftime+ with \"%T.%L\" on the object's value. If you pass <tt>include_seconds: false</tt>, it will be formatted by trying to call +strftime+ with \"%H:%M\" on the object's value. It is also possible to override this by passing the \"value\" option.  ==== Options  Supports the same options as FormTagHelper#time_field_tag.  ==== Examples  time_field(\"task\", \"started_at\") # => <input id=\"task_started_at\" name=\"task[started_at]\" type=\"time\" />  You can create values for the \"min\" and \"max\" attributes by passing instances of Date or Time to the options hash.  time_field(\"task\", \"started_at\", min: Time.now) # => <input id=\"task_started_at\" name=\"task[started_at]\" type=\"time\" min=\"01:00:00.000\" />  Alternatively, you can pass a String formatted as an ISO8601 time as the values for \"min\" and \"max.\"  time_field(\"task\", \"started_at\", min: \"01:00:00\") # => <input id=\"task_started_at\" name=\"task[started_at]\" type=\"time\" min=\"01:00:00.000\" />  By default, provided times will be formatted including seconds. You can render just the hour and minute by passing <tt>include_seconds: false</tt>. Some browsers will render a simpler UI if you exclude seconds in the timestamp format.  time_field(\"task\", \"started_at\", value: Time.now, include_seconds: false) # => <input id=\"task_started_at\" name=\"task[started_at]\" type=\"time\" value=\"01:00\" />",
    "label": "",
    "id": "854"
  },
  {
    "raw_code": "def datetime_field(object_name, method, options = {})\n        Tags::DatetimeLocalField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns a text_field of type \"datetime-local\".  datetime_field(\"user\", \"born_on\") # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"datetime-local\" />  The default value is generated by trying to call +strftime+ with \"%Y-%m-%dT%T\" on the object's value, which makes it behave as expected for instances of DateTime and ActiveSupport::TimeWithZone.  @user.born_on = Date.new(1984, 1, 12) datetime_field(\"user\", \"born_on\") # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"datetime-local\" value=\"1984-01-12T00:00:00\" />  You can create values for the \"min\" and \"max\" attributes by passing instances of Date or Time to the options hash.  datetime_field(\"user\", \"born_on\", min: Date.today) # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"datetime-local\" min=\"2014-05-20T00:00:00.000\" />  Alternatively, you can pass a String formatted as an ISO8601 datetime as the values for \"min\" and \"max.\"  datetime_field(\"user\", \"born_on\", min: \"2014-05-20T00:00:00\") # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"datetime-local\" min=\"2014-05-20T00:00:00.000\" />  By default, provided datetimes will be formatted including seconds. You can render just the date, hour, and minute by passing <tt>include_seconds: false</tt>.  @user.born_on = Time.current datetime_field(\"user\", \"born_on\", include_seconds: false) # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"datetime-local\" value=\"2014-05-20T14:35\" />",
    "label": "",
    "id": "855"
  },
  {
    "raw_code": "def month_field(object_name, method, options = {})\n        Tags::MonthField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns a text_field of type \"month\".  month_field(\"user\", \"born_on\") # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"month\" />  The default value is generated by trying to call +strftime+ with \"%Y-%m\" on the object's value, which makes it behave as expected for instances of DateTime and ActiveSupport::TimeWithZone.  @user.born_on = Date.new(1984, 1, 27) month_field(\"user\", \"born_on\") # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"date\" value=\"1984-01\" /> ",
    "label": "",
    "id": "856"
  },
  {
    "raw_code": "def week_field(object_name, method, options = {})\n        Tags::WeekField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns a text_field of type \"week\".  week_field(\"user\", \"born_on\") # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"week\" />  The default value is generated by trying to call +strftime+ with \"%Y-W%W\" on the object's value, which makes it behave as expected for instances of DateTime and ActiveSupport::TimeWithZone.  @user.born_on = Date.new(1984, 5, 12) week_field(\"user\", \"born_on\") # => <input id=\"user_born_on\" name=\"user[born_on]\" type=\"date\" value=\"1984-W19\" /> ",
    "label": "",
    "id": "857"
  },
  {
    "raw_code": "def url_field(object_name, method, options = {})\n        Tags::UrlField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns a text_field of type \"url\".  url_field(\"user\", \"homepage\") # => <input id=\"user_homepage\" name=\"user[homepage]\" type=\"url\" /> ",
    "label": "",
    "id": "858"
  },
  {
    "raw_code": "def email_field(object_name, method, options = {})\n        Tags::EmailField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns a text_field of type \"email\".  email_field(\"user\", \"address\") # => <input id=\"user_address\" name=\"user[address]\" type=\"email\" /> ",
    "label": "",
    "id": "859"
  },
  {
    "raw_code": "def number_field(object_name, method, options = {})\n        Tags::NumberField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns an input tag of type \"number\".  ==== Options  Supports the same options as FormTagHelper#number_field_tag.",
    "label": "",
    "id": "860"
  },
  {
    "raw_code": "def range_field(object_name, method, options = {})\n        Tags::RangeField.new(object_name, method, self, options).render\n      end",
    "comment": "Returns an input tag of type \"range\".  ==== Options  Supports the same options as FormTagHelper#range_field_tag.",
    "label": "",
    "id": "861"
  },
  {
    "raw_code": "def id\n        options.dig(:html, :id) || options[:id]\n      end",
    "comment": "Generate an HTML <tt>id</tt> attribute value.  return the <tt><form></tt> element's <tt>id</tt> attribute.  <%= form_with model: @article do |f| %> <%# ... %>  <% content_for :sticky_footer do %> <%= form.button(form: f.id) %> <% end %> <% end %>  In the example above, the <tt>:sticky_footer</tt> content area will exist outside of the <tt><form></tt> element. By declaring the <tt>form</tt> HTML attribute, we hint to the browser that the generated <tt><button></tt> element should be treated as the <tt><form></tt> element's submit button, regardless of where it exists in the DOM.",
    "label": "",
    "id": "862"
  },
  {
    "raw_code": "def field_id(method, *suffixes, namespace: @options[:namespace], index: @options[:index])\n        @template.field_id(@object_name, method, *suffixes, namespace: namespace, index: index)\n      end",
    "comment": "Generate an HTML <tt>id</tt> attribute value for the given field  Return the value generated by the <tt>FormBuilder</tt> for the given attribute name.  <%= form_with model: @article do |f| %> <%= f.label :title %> <%= f.text_field :title, aria: { describedby: f.field_id(:title, :error) } %> <%= tag.span(\"is blank\", id: f.field_id(:title, :error) %> <% end %>  In the example above, the <tt><input type=\"text\"></tt> element built by the call to #text_field declares an <tt>aria-describedby</tt> attribute referencing the <tt><span></tt> element, sharing a common <tt>id</tt> root (<tt>article_title</tt>, in this case).",
    "label": "",
    "id": "863"
  },
  {
    "raw_code": "def field_name(method, *methods, multiple: false, index: @options[:index])\n        object_name = @options.fetch(:as) { @object_name }\n\n        @template.field_name(object_name, method, *methods, index: index, multiple: multiple)\n      end",
    "comment": "Generate an HTML <tt>name</tt> attribute value for the given name and field combination  Return the value generated by the <tt>FormBuilder</tt> for the given attribute name.  <%= form_with model: @article do |f| %> <%= f.text_field :title, name: f.field_name(:title, :subtitle) %> <%# => <input type=\"text\" name=\"article[title][subtitle]\"> %> <% end %>  <%= form_with model: @article do |f| %> <%= f.text_field :tag, name: f.field_name(:tag, multiple: true) %> <%# => <input type=\"text\" name=\"article[tag][]\"> %> <% end %> ",
    "label": "",
    "id": "864"
  },
  {
    "raw_code": "def fields_for(record_name, record_object = nil, fields_options = nil, &block)\n        fields_options, record_object = record_object, nil if fields_options.nil? && record_object.is_a?(Hash) && record_object.extractable_options?\n        fields_options ||= {}\n        fields_options[:builder] ||= options[:builder]\n        fields_options[:namespace] = options[:namespace]\n        fields_options[:parent_builder] = self\n\n        case record_name\n        when String, Symbol\n          if nested_attributes_association?(record_name)\n            return fields_for_with_nested_attributes(record_name, record_object, fields_options, block)\n          end",
    "comment": "Creates a scope around a specific model object like #form_with, but doesn't create the form tags themselves. This makes +fields_for+ suitable for specifying additional model objects in the same form.  Although the usage and purpose of +fields_for+ is similar to #form_with's, its method signature is slightly different. Like #form_with, it yields a FormBuilder object associated with a particular model object to a block, and within the block allows methods to be called on the builder to generate fields associated with the model object. Fields may reflect a model object in two ways - how they are named (hence how submitted values appear within the +params+ hash in the controller) and what default values are shown when the form fields are first displayed. In order for both of these features to be specified independently, both an object name (represented by either a symbol or string) and the object itself can be passed to the method separately -  <%= form_with model: @person do |person_form| %> First name: <%= person_form.text_field :first_name %> Last name : <%= person_form.text_field :last_name %>  <%= fields_for :permission, @person.permission do |permission_fields| %> Admin?  : <%= permission_fields.checkbox :admin %> <% end %>  <%= person_form.submit %> <% end %>  In this case, the checkbox field will be represented by an HTML +input+ tag with the +name+ attribute <tt>permission[admin]</tt>, and the submitted value will appear in the controller as <tt>params[:permission][:admin]</tt>. If <tt>@person.permission</tt> is an existing record with an attribute +admin+, the initial state of the checkbox when first displayed will reflect the value of <tt>@person.permission.admin</tt>.  Often this can be simplified by passing just the name of the model object to +fields_for+ -  <%= fields_for :permission do |permission_fields| %> Admin?: <%= permission_fields.checkbox :admin %> <% end %>  ...in which case, if <tt>:permission</tt> also happens to be the name of an instance variable <tt>@permission</tt>, the initial state of the input field will reflect the value of that variable's attribute <tt>@permission.admin</tt>.  Alternatively, you can pass just the model object itself (if the first argument isn't a string or symbol +fields_for+ will realize that the name has been omitted) -  <%= fields_for @person.permission do |permission_fields| %> Admin?: <%= permission_fields.checkbox :admin %> <% end %>  and +fields_for+ will derive the required name of the field from the _class_ of the model object, e.g. if <tt>@person.permission</tt>, is of class +Permission+, the field will still be named <tt>permission[admin]</tt>.  Note: This also works for the methods in FormOptionsHelper and DateHelper that are designed to work with an object as base, like FormOptionsHelper#collection_select and DateHelper#datetime_select.  +fields_for+ tries to be smart about parameters, but it can be confused if both name and value parameters are provided and the provided value has the shape of an option Hash. To remove the ambiguity, explicitly pass an option Hash, even if empty.  <%= form_with model: @person do |person_form| %> ... <%= fields_for :permission, @person.permission, {} do |permission_fields| %> Admin?: <%= checkbox_tag permission_fields.field_name(:admin), @person.permission[:admin] %> <% end %> ... <% end %>  === Nested Attributes Examples  When the object belonging to the current scope has a nested attribute writer for a certain attribute, +fields_for+ will yield a new scope for that attribute. This allows you to create forms that set or change the attributes of a parent object and its associations in one go.  Nested attribute writers are normal setter methods named after an association. The most common way of defining these writers is either with +accepts_nested_attributes_for+ in a model definition or by defining a method with the proper name. For example: the attribute writer for the association <tt>:address</tt> is called <tt>address_attributes=</tt>.  Whether a one-to-one or one-to-many style form builder will be yielded depends on whether the normal reader method returns a _single_ object or an _array_ of objects.  ==== One-to-one  Consider a Person class which returns a _single_ Address from the <tt>address</tt> reader method and responds to the <tt>address_attributes=</tt> writer method:  class Person def address @address end  def address_attributes=(attributes) # Process the attributes hash end end  This model can now be used with a nested +fields_for+, like so:  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :address do |address_fields| %> Street  : <%= address_fields.text_field :street %> Zip code: <%= address_fields.text_field :zip_code %> <% end %> ... <% end %>  When address is already an association on a Person you can use +accepts_nested_attributes_for+ to define the writer method for you:  class Person < ActiveRecord::Base has_one :address accepts_nested_attributes_for :address end  If you want to destroy the associated model through the form, you have to enable it first using the <tt>:allow_destroy</tt> option for +accepts_nested_attributes_for+:  class Person < ActiveRecord::Base has_one :address accepts_nested_attributes_for :address, allow_destroy: true end  Now, when you use a form element with the <tt>_destroy</tt> parameter, with a value that evaluates to +true+, you will destroy the associated model (e.g. 1, '1', true, or 'true'):  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :address do |address_fields| %> ... Delete: <%= address_fields.checkbox :_destroy %> <% end %> ... <% end %>  ==== One-to-many  Consider a Person class which returns an _array_ of Project instances from the <tt>projects</tt> reader method and responds to the <tt>projects_attributes=</tt> writer method:  class Person def projects [@project1, @project2] end  def projects_attributes=(attributes) # Process the attributes hash end end  Note that the <tt>projects_attributes=</tt> writer method is in fact required for +fields_for+ to correctly identify <tt>:projects</tt> as a collection, and the correct indices to be set in the form markup.  When projects is already an association on Person you can use +accepts_nested_attributes_for+ to define the writer method for you:  class Person < ActiveRecord::Base has_many :projects accepts_nested_attributes_for :projects end  This model can now be used with a nested +fields_for+. The block given to the nested +fields_for+ call will be repeated for each instance in the collection:  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects do |project_fields| %> <% if project_fields.object.active? %> Name: <%= project_fields.text_field :name %> <% end %> <% end %> ... <% end %>  It's also possible to specify the instance to be used:  <%= form_with model: @person do |person_form| %> ... <% @person.projects.each do |project| %> <% if project.active? %> <%= person_form.fields_for :projects, project do |project_fields| %> Name: <%= project_fields.text_field :name %> <% end %> <% end %> <% end %> ... <% end %>  Or a collection to be used:  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects, @active_projects do |project_fields| %> Name: <%= project_fields.text_field :name %> <% end %> ... <% end %>  If you want to destroy any of the associated models through the form, you have to enable it first using the <tt>:allow_destroy</tt> option for +accepts_nested_attributes_for+:  class Person < ActiveRecord::Base has_many :projects accepts_nested_attributes_for :projects, allow_destroy: true end  This will allow you to specify which models to destroy in the attributes hash by adding a form element for the <tt>_destroy</tt> parameter with a value that evaluates to +true+ (e.g. 1, '1', true, or 'true'):  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects do |project_fields| %> Delete: <%= project_fields.checkbox :_destroy %> <% end %> ... <% end %>  When a collection is used you might want to know the index of each object in the array. For this purpose, the <tt>index</tt> method is available in the FormBuilder object.  <%= form_with model: @person do |person_form| %> ... <%= person_form.fields_for :projects do |project_fields| %> Project #<%= project_fields.index %> ... <% end %> ... <% end %>  Note that +fields_for+ will automatically generate a hidden field to store the ID of the record. There are circumstances where this hidden field is not needed and you can pass <tt>include_id: false</tt> to prevent +fields_for+ from rendering it automatically.",
    "label": "",
    "id": "865"
  },
  {
    "raw_code": "def fields(scope = nil, model: nil, **options, &block)\n        options[:allow_method_names_outside_object] = true\n        options[:skip_default_ids] = !FormHelper.form_with_generates_ids\n\n        convert_to_legacy_options(options)\n\n        fields_for(scope || model, model, options, &block)\n      end",
    "comment": "See the docs for the ActionView::Helpers::FormHelper#fields helper method.",
    "label": "",
    "id": "866"
  },
  {
    "raw_code": "def label(method, text = nil, options = {}, &block)\n        @template.label(@object_name, method, text, objectify_options(options), &block)\n      end",
    "comment": "Returns a label tag tailored for labelling an input field for a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). The text of label will default to the attribute name unless a translation is found in the current I18n locale (through <tt>helpers.label.<modelname>.<attribute></tt>) or you specify it explicitly. Additional options on the label tag can be passed as a hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example shown, except for the <tt>:value</tt> option, which is designed to target labels for radio_button tags (where the value is used in the ID of the input tag).  ==== Examples label(:title) # => <label for=\"article_title\">Title</label>  You can localize your labels based on model and attribute names. For example you can define the following in your locale (e.g. en.yml)  helpers: label: article: body: \"Write your entire text here\"  Which then will result in  label(:body) # => <label for=\"article_body\">Write your entire text here</label>  Localization can also be based purely on the translation of the attribute-name (if you are using ActiveRecord):  activerecord: attributes: article: cost: \"Total cost\"  <code></code>  label(:cost) # => <label for=\"article_cost\">Total cost</label>  label(:title, \"A short title\") # => <label for=\"article_title\">A short title</label>  label(:title, \"A short title\", class: \"title_label\") # => <label for=\"article_title\" class=\"title_label\">A short title</label>  label(:privacy, \"Public Article\", value: \"public\") # => <label for=\"article_privacy_public\">Public Article</label>  label(:cost) do |translation| content_tag(:span, translation, class: \"cost_label\") end # => <label for=\"article_cost\"><span class=\"cost_label\">Total cost</span></label>  label(:cost) do |builder| content_tag(:span, builder.translation, class: \"cost_label\") end # => <label for=\"article_cost\"><span class=\"cost_label\">Total cost</span></label>  label(:cost) do |builder| content_tag(:span, builder.translation, class: [ \"cost_label\", (\"error_label\" if builder.object.errors.include?(:cost)) ]) end # => <label for=\"article_cost\"><span class=\"cost_label error_label\">Total cost</span></label>  label(:terms) do raw('Accept <a href=\"/terms\">Terms</a>.') end # => <label for=\"article_terms\">Accept <a href=\"/terms\">Terms</a>.</label>",
    "label": "",
    "id": "867"
  },
  {
    "raw_code": "def checkbox(method, options = {}, checked_value = \"1\", unchecked_value = \"0\")\n        @template.checkbox(@object_name, method, objectify_options(options), checked_value, unchecked_value)\n      end",
    "comment": "Returns a checkbox tag tailored for accessing a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). This object must be an instance object (@object) and not a local object. It's intended that +method+ returns an integer and if that integer is above zero, then the checkbox is checked. Additional options on the input tag can be passed as a hash with +options+. The +checked_value+ defaults to 1 while the default +unchecked_value+ is set to 0 which is convenient for boolean values.  ==== Options  * Any standard HTML attributes for the tag can be passed in, for example +:class+. * <tt>:checked</tt> - +true+ or +false+ forces the state of the checkbox to be checked or not. * <tt>:include_hidden</tt> - If set to false, the auxiliary hidden field described below will not be generated.  ==== Gotcha  The HTML specification says unchecked check boxes are not successful, and thus web browsers do not send them. Unfortunately this introduces a gotcha: if an +Invoice+ model has a +paid+ flag, and in the form that edits a paid invoice the user unchecks its check box, no +paid+ parameter is sent. So, any mass-assignment idiom like  @invoice.update(params[:invoice])  wouldn't update the flag.  To prevent this the helper generates an auxiliary hidden field before every check box. The hidden field has the same name and its attributes mimic an unchecked check box.  This way, the client either sends only the hidden field (representing the check box is unchecked), or both fields. Since the HTML specification says key/value pairs have to be sent in the same order they appear in the form, and parameters extraction gets the last occurrence of any repeated key in the query string, that works for ordinary forms.  Unfortunately that workaround does not work when the check box goes within an array-like parameter, as in  <%= fields_for \"project[invoice_attributes][]\", invoice, index: nil do |form| %> <%= form.checkbox :paid %> ... <% end %>  because parameter name repetition is precisely what \\Rails seeks to distinguish the elements of the array. For each item with a checked check box you get an extra ghost item with only that attribute, assigned to \"0\".  In that case it is preferable to either use FormTagHelper#checkbox_tag or to use hashes instead of arrays.  ==== Examples  # Let's say that @article.validated? is 1: checkbox(\"validated\") # => <input name=\"article[validated]\" type=\"hidden\" value=\"0\" /> #    <input checked=\"checked\" type=\"checkbox\" id=\"article_validated\" name=\"article[validated]\" value=\"1\" />  # Let's say that @puppy.gooddog is \"no\": checkbox(\"gooddog\", {}, \"yes\", \"no\") # => <input name=\"puppy[gooddog]\" type=\"hidden\" value=\"no\" /> #    <input type=\"checkbox\" id=\"puppy_gooddog\" name=\"puppy[gooddog]\" value=\"yes\" />  # Let's say that @eula.accepted is \"no\": checkbox(\"accepted\", { class: 'eula_check' }, \"yes\", \"no\") # => <input name=\"eula[accepted]\" type=\"hidden\" value=\"no\" /> #    <input type=\"checkbox\" class=\"eula_check\" id=\"eula_accepted\" name=\"eula[accepted]\" value=\"yes\" />",
    "label": "",
    "id": "868"
  },
  {
    "raw_code": "def radio_button(method, tag_value, options = {})\n        @template.radio_button(@object_name, method, tag_value, objectify_options(options))\n      end",
    "comment": "Returns a radio button tag for accessing a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). If the current value of +method+ is +tag_value+ the radio button will be checked.  To force the radio button to be checked pass <tt>checked: true</tt> in the +options+ hash. You may pass HTML options there as well.  # Let's say that @article.category returns \"rails\": radio_button(\"category\", \"rails\") radio_button(\"category\", \"java\") # => <input type=\"radio\" id=\"article_category_rails\" name=\"article[category]\" value=\"rails\" checked=\"checked\" /> #    <input type=\"radio\" id=\"article_category_java\" name=\"article[category]\" value=\"java\" />  # Let's say that @user.receive_newsletter returns \"no\": radio_button(\"receive_newsletter\", \"yes\") radio_button(\"receive_newsletter\", \"no\") # => <input type=\"radio\" id=\"user_receive_newsletter_yes\" name=\"user[receive_newsletter]\" value=\"yes\" /> #    <input type=\"radio\" id=\"user_receive_newsletter_no\" name=\"user[receive_newsletter]\" value=\"no\" checked=\"checked\" />",
    "label": "",
    "id": "869"
  },
  {
    "raw_code": "def hidden_field(method, options = {})\n        @emitted_hidden_id = true if method == :id\n        @template.hidden_field(@object_name, method, objectify_options(options))\n      end",
    "comment": "Returns a hidden input tag tailored for accessing a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). Additional options on the input tag can be passed as a hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example shown.  ==== Examples # Let's say that @signup.pass_confirm returns true: hidden_field(:pass_confirm) # => <input type=\"hidden\" id=\"signup_pass_confirm\" name=\"signup[pass_confirm]\" value=\"true\" />  # Let's say that @article.tag_list returns \"blog, ruby\": hidden_field(:tag_list) # => <input type=\"hidden\" id=\"article_tag_list\" name=\"article[tag_list]\" value=\"blog, ruby\" />  # Let's say that @user.token returns \"abcde\": hidden_field(:token) # => <input type=\"hidden\" id=\"user_token\" name=\"user[token]\" value=\"abcde\" /> ",
    "label": "",
    "id": "870"
  },
  {
    "raw_code": "def file_field(method, options = {})\n        self.multipart = true\n        @template.file_field(@object_name, method, objectify_options(options))\n      end",
    "comment": "Returns a file upload input tag tailored for accessing a specified attribute (identified by +method+) on an object assigned to the template (identified by +object+). Additional options on the input tag can be passed as a hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example shown.  Using this method inside a #form_with block will set the enclosing form's encoding to <tt>multipart/form-data</tt>.  ==== Options * Creates standard HTML attributes for the tag. * <tt>:disabled</tt> - If set to true, the user will not be able to use this input. * <tt>:multiple</tt> - If set to true, *in most updated browsers* the user will be allowed to select multiple files. * <tt>:include_hidden</tt> - When <tt>multiple: true</tt> and <tt>include_hidden: true</tt>, the field will be prefixed with an <tt><input type=\"hidden\"></tt> field with an empty value to support submitting an empty collection of files. Since <tt>include_hidden</tt> will default to <tt>config.active_storage.multiple_file_field_include_hidden</tt> if you don't specify <tt>include_hidden</tt>, you will need to pass <tt>include_hidden: false</tt> to prevent submitting an empty collection of files when passing <tt>multiple: true</tt>. * <tt>:accept</tt> - If set to one or multiple mime-types, the user will be suggested a filter when choosing a file. You still need to set up model validations.  ==== Examples # Let's say that @user has avatar: file_field(:avatar) # => <input type=\"file\" id=\"user_avatar\" name=\"user[avatar]\" />  # Let's say that @article has image: file_field(:image, :multiple => true) # => <input type=\"file\" id=\"article_image\" name=\"article[image][]\" multiple=\"multiple\" />  # Let's say that @article has attached: file_field(:attached, accept: 'text/html') # => <input accept=\"text/html\" type=\"file\" id=\"article_attached\" name=\"article[attached]\" />  # Let's say that @article has image: file_field(:image, accept: 'image/png,image/gif,image/jpeg') # => <input type=\"file\" id=\"article_image\" name=\"article[image]\" accept=\"image/png,image/gif,image/jpeg\" />  # Let's say that @attachment has file: file_field(:file, class: 'file_input') # => <input type=\"file\" id=\"attachment_file\" name=\"attachment[file]\" class=\"file_input\" />",
    "label": "",
    "id": "871"
  },
  {
    "raw_code": "def submit(value = nil, options = {})\n        value, options = nil, value if value.is_a?(Hash)\n        value ||= submit_default_value\n        @template.submit_tag(value, options)\n      end",
    "comment": "Add the submit button for the given form. When no value is given, it checks if the object is a new resource or not to create the proper label:  <%= form_with model: @article do |f| %> <%= f.submit %> <% end %>  In the example above, if <tt>@article</tt> is a new record, it will use \"Create Article\" as submit button label; otherwise, it uses \"Update Article\".  Those labels can be customized using I18n under the +helpers.submit+ key and using <tt>%{model}</tt> for translation interpolation:  en: helpers: submit: create: \"Create a %{model}\" update: \"Confirm changes to %{model}\"  It also searches for a key specific to the given object:  en: helpers: submit: article: create: \"Add %{model}\" ",
    "label": "",
    "id": "872"
  },
  {
    "raw_code": "def button(value = nil, options = {}, &block)\n        case value\n        when Hash\n          value, options = nil, value\n        when Symbol\n          value, options = nil, { name: field_name(value), id: field_id(value) }.merge!(options.to_h)\n        end",
    "comment": "Add the submit button for the given form. When no value is given, it checks if the object is a new resource or not to create the proper label:  <%= form_with model: @article do |f| %> <%= f.button %> <% end %> In the example above, if <tt>@article</tt> is a new record, it will use \"Create Article\" as button label; otherwise, it uses \"Update Article\".  Those labels can be customized using I18n under the +helpers.submit+ key (the same as submit helper) and using <tt>%{model}</tt> for translation interpolation:  en: helpers: submit: create: \"Create a %{model}\" update: \"Confirm changes to %{model}\"  It also searches for a key specific to the given object:  en: helpers: submit: article: create: \"Add %{model}\"  ==== Examples button(\"Create article\") # => <button name='button' type='submit'>Create article</button>  button(:draft, value: true) # => <button id=\"article_draft\" name=\"article[draft]\" value=\"true\" type=\"submit\">Create article</button>  button do content_tag(:strong, 'Ask me!') end # => <button name='button' type='submit'> #      <strong>Ask me!</strong> #    </button>  button do |text| content_tag(:strong, text) end # => <button name='button' type='submit'> #      <strong>Create article</strong> #    </button>  button(:draft, value: true) do content_tag(:strong, \"Save as draft\") end # =>  <button id=\"article_draft\" name=\"article[draft]\" value=\"true\" type=\"submit\"> #       <strong>Save as draft</strong> #     </button> ",
    "label": "",
    "id": "873"
  },
  {
    "raw_code": "def select(object, method, choices = nil, options = {}, html_options = {}, &block)\n        Tags::Select.new(object, method, self, choices, options, html_options, &block).render\n      end",
    "comment": "Create a select tag and a series of contained option tags for the provided object and method. The option currently held by the object will be selected, provided that the object is available.  There are two possible formats for the +choices+ parameter, corresponding to other helpers' output:  * A flat collection (see <tt>options_for_select</tt>). * A nested collection (see <tt>grouped_options_for_select</tt>).  Example with <tt>@post.person_id => 2</tt>:  select :post, :person_id, Person.all.collect { |p| [ p.name, p.id ] }, { include_blank: true }  would become:  <select name=\"post[person_id]\" id=\"post_person_id\"> <option value=\"\" label=\" \"></option> <option value=\"1\">David</option> <option value=\"2\" selected=\"selected\">Eileen</option> <option value=\"3\">Rafael</option> </select>  This can be used to provide a default set of options in the standard way: before rendering the create form, a new model instance is assigned the default options and bound to @model_name. Usually this model is not saved to the database. Instead, a second model object is created when the create request is received. This allows the user to submit a form page more than once with the expected results of creating multiple records. In addition, this allows a single partial to be used to generate form inputs for both edit and create forms.  By default, <tt>post.person_id</tt> is the selected option. Specify <tt>selected: value</tt> to use a different selection or <tt>selected: nil</tt> to leave all options unselected. Similarly, you can specify values to be disabled in the option tags by specifying the <tt>:disabled</tt> option. This can either be a single value or an array of values to be disabled.  A block can be passed to #select to customize how the options tags will be rendered. This is useful when the options tag has complex attributes.  select(report, :campaign_ids) do available_campaigns.each do |c| tag.option(c.name, value: c.id, data: { tags: c.tags.to_json }) end end  ==== Gotcha  The HTML specification says when +multiple+ parameter passed to select and all options got deselected web browsers do not send any value to server. Unfortunately this introduces a gotcha: if a +User+ model has many +roles+ and have +role_ids+ accessor, and in the form that edits roles of the user the user deselects all roles from +role_ids+ multiple select box, no +role_ids+ parameter is sent. So, any mass-assignment idiom like  @user.update(params[:user])  wouldn't update roles.  To prevent this the helper generates an auxiliary hidden field before every multiple select. The hidden field has the same name as multiple select and blank value.  <b>Note:</b> The client either sends only the hidden field (representing the deselected multiple select box), or both fields. This means that the resulting array always contains a blank string.  In case if you don't want the helper to generate this hidden field you can specify <tt>include_hidden: false</tt> option.",
    "label": "",
    "id": "874"
  },
  {
    "raw_code": "def collection_select(object, method, collection, value_method, text_method, options = {}, html_options = {})\n        Tags::CollectionSelect.new(object, method, self, collection, value_method, text_method, options, html_options).render\n      end",
    "comment": "Returns <tt><select></tt> and <tt><option></tt> tags for the collection of existing return values of +method+ for +object+'s class. The value returned from calling +method+ on the instance +object+ will be selected. If calling +method+ returns +nil+, no selection is made without including <tt>:prompt</tt> or <tt>:include_blank</tt> in the +options+ hash.  The <tt>:value_method</tt> and <tt>:text_method</tt> parameters are methods to be called on each member of +collection+. The return values are used as the +value+ attribute and contents of each <tt><option></tt> tag, respectively. They can also be any object that responds to +call+, such as a +proc+, that will be called for each member of the +collection+ to retrieve the value/text.  Example object structure for use with this method:  class Post < ActiveRecord::Base belongs_to :author end  class Author < ActiveRecord::Base has_many :posts  def name_with_initial \"#{first_name.first}. #{last_name}\" end end  Sample usage (selecting the associated Author for an instance of Post, <tt>@post</tt>):  collection_select(:post, :author_id, Author.all, :id, :name_with_initial, prompt: true)  If <tt>@post.author_id</tt> is already <tt>1</tt>, this would return: <select name=\"post[author_id]\" id=\"post_author_id\"> <option value=\"\">Please select</option> <option value=\"1\" selected=\"selected\">D. Heinemeier Hansson</option> <option value=\"2\">D. Thomas</option> <option value=\"3\">M. Clark</option> </select>",
    "label": "",
    "id": "875"
  },
  {
    "raw_code": "def grouped_collection_select(object, method, collection, group_method, group_label_method, option_key_method, option_value_method, options = {}, html_options = {})\n        Tags::GroupedCollectionSelect.new(object, method, self, collection, group_method, group_label_method, option_key_method, option_value_method, options, html_options).render\n      end",
    "comment": "Returns <tt><select></tt>, <tt><optgroup></tt> and <tt><option></tt> tags for the collection of existing return values of +method+ for +object+'s class. The value returned from calling +method+ on the instance +object+ will be selected. If calling +method+ returns +nil+, no selection is made without including <tt>:prompt</tt> or <tt>:include_blank</tt> in the +options+ hash.  Parameters: * +object+ - The instance of the class to be used for the select tag * +method+ - The attribute of +object+ corresponding to the select tag * +collection+ - An array of objects representing the <tt><optgroup></tt> tags. * +group_method+ - The name of a method which, when called on a member of +collection+, returns an array of child objects representing the <tt><option></tt> tags. It can also be any object that responds to +call+, such as a +proc+, that will be called for each member of the +collection+ to retrieve the value. * +group_label_method+ - The name of a method which, when called on a member of +collection+, returns a string to be used as the +label+ attribute for its <tt><optgroup></tt> tag. It can also be any object that responds to +call+, such as a +proc+, that will be called for each member of the +collection+ to retrieve the label. * +option_key_method+ - The name of a method which, when called on a child object of a member of +collection+, returns a value to be used as the +value+ attribute for its <tt><option></tt> tag. * +option_value_method+ - The name of a method which, when called on a child object of a member of +collection+, returns a value to be used as the contents of its <tt><option></tt> tag.  Example object structure for use with this method:  # attributes: id, name class Continent < ActiveRecord::Base has_many :countries end  # attributes: id, name, continent_id class Country < ActiveRecord::Base belongs_to :continent end  # attributes: id, name, country_id class City < ActiveRecord::Base belongs_to :country end  Sample usage:  grouped_collection_select(:city, :country_id, @continents, :countries, :name, :id, :name)  Possible output:  <select name=\"city[country_id]\" id=\"city_country_id\"> <optgroup label=\"Africa\"> <option value=\"1\">South Africa</option> <option value=\"3\">Somalia</option> </optgroup> <optgroup label=\"Europe\"> <option value=\"7\" selected=\"selected\">Denmark</option> <option value=\"2\">Ireland</option> </optgroup> </select>",
    "label": "",
    "id": "876"
  },
  {
    "raw_code": "def time_zone_select(object, method, priority_zones = nil, options = {}, html_options = {})\n        Tags::TimeZoneSelect.new(object, method, self, priority_zones, options, html_options).render\n      end",
    "comment": "Returns select and option tags for the given object and method, using #time_zone_options_for_select to generate the list of option tags.  In addition to the <tt>:include_blank</tt> option documented above, this method also supports a <tt>:model</tt> option, which defaults to ActiveSupport::TimeZone. This may be used by users to specify a different time zone model object. (See #time_zone_options_for_select for more information.)  You can also supply an array of ActiveSupport::TimeZone objects as +priority_zones+ so that they will be listed above the rest of the (long) list. You can use ActiveSupport::TimeZone.us_zones for a list of US time zones, ActiveSupport::TimeZone.country_zones(country_code) for another country's time zones, or a Regexp to select the zones of your choice.  Finally, this method supports a <tt>:default</tt> option, which selects a default ActiveSupport::TimeZone if the object's time zone is +nil+.  time_zone_select(:user, :time_zone, nil, include_blank: true)  time_zone_select(:user, :time_zone, nil, default: \"Pacific Time (US & Canada)\")  time_zone_select(:user, :time_zone, ActiveSupport::TimeZone.us_zones, default: \"Pacific Time (US & Canada)\")  time_zone_select(:user, :time_zone, [ ActiveSupport::TimeZone[\"Alaska\"], ActiveSupport::TimeZone[\"Hawaii\"] ])  time_zone_select(:user, :time_zone, /Australia/)  time_zone_select(:user, :time_zone, ActiveSupport::TimeZone.all.sort, model: ActiveSupport::TimeZone)",
    "label": "",
    "id": "877"
  },
  {
    "raw_code": "def weekday_select(object, method, options = {}, html_options = {}, &block)\n        Tags::WeekdaySelect.new(object, method, self, options, html_options, &block).render\n      end",
    "comment": "Returns select and option tags for the given object and method, using #weekday_options_for_select to generate the list of option tags.",
    "label": "",
    "id": "878"
  },
  {
    "raw_code": "def options_for_select(container, selected = nil)\n        return container if String === container\n\n        selected, disabled = extract_selected_and_disabled(selected).map do |r|\n          Array(r).map(&:to_s)\n        end",
    "comment": "Accepts a container (hash, array, enumerable, your type) and returns a string of option tags. Given a container where the elements respond to first and last (such as a two-element array), the \"lasts\" serve as option values and the \"firsts\" as option text. Hashes are turned into this form automatically, so the keys become \"firsts\" and values become lasts. If +selected+ is specified, the matching \"last\" or element will get the selected option-tag. +selected+ may also be an array of values to be selected when using a multiple select.  options_for_select([[\"Dollar\", \"$\"], [\"Kroner\", \"DKK\"]]) # => <option value=\"$\">Dollar</option> # => <option value=\"DKK\">Kroner</option>  options_for_select([ \"VISA\", \"MasterCard\" ], \"MasterCard\") # => <option value=\"VISA\">VISA</option> # => <option selected=\"selected\" value=\"MasterCard\">MasterCard</option>  options_for_select({ \"Basic\" => \"$20\", \"Plus\" => \"$40\" }, \"$40\") # => <option value=\"$20\">Basic</option> # => <option value=\"$40\" selected=\"selected\">Plus</option>  options_for_select([ \"VISA\", \"MasterCard\", \"Discover\" ], [\"VISA\", \"Discover\"]) # => <option selected=\"selected\" value=\"VISA\">VISA</option> # => <option value=\"MasterCard\">MasterCard</option> # => <option selected=\"selected\" value=\"Discover\">Discover</option>  You can optionally provide HTML attributes as the last element of the array.  options_for_select([ \"Denmark\", [\"USA\", { class: 'bold' }], \"Sweden\" ], [\"USA\", \"Sweden\"]) # => <option value=\"Denmark\">Denmark</option> # => <option value=\"USA\" class=\"bold\" selected=\"selected\">USA</option> # => <option value=\"Sweden\" selected=\"selected\">Sweden</option>  options_for_select([[\"Dollar\", \"$\", { class: \"bold\" }], [\"Kroner\", \"DKK\", { onclick: \"alert('HI');\" }]]) # => <option value=\"$\" class=\"bold\">Dollar</option> # => <option value=\"DKK\" onclick=\"alert('HI');\">Kroner</option>  If you wish to specify disabled option tags, set +selected+ to be a hash, with <tt>:disabled</tt> being either a value or array of values to be disabled. In this case, you can use <tt>:selected</tt> to specify selected option tags.  options_for_select([\"Free\", \"Basic\", \"Advanced\", \"Super Platinum\"], disabled: \"Super Platinum\") # => <option value=\"Free\">Free</option> # => <option value=\"Basic\">Basic</option> # => <option value=\"Advanced\">Advanced</option> # => <option value=\"Super Platinum\" disabled=\"disabled\">Super Platinum</option>  options_for_select([\"Free\", \"Basic\", \"Advanced\", \"Super Platinum\"], disabled: [\"Advanced\", \"Super Platinum\"]) # => <option value=\"Free\">Free</option> # => <option value=\"Basic\">Basic</option> # => <option value=\"Advanced\" disabled=\"disabled\">Advanced</option> # => <option value=\"Super Platinum\" disabled=\"disabled\">Super Platinum</option>  options_for_select([\"Free\", \"Basic\", \"Advanced\", \"Super Platinum\"], selected: \"Free\", disabled: \"Super Platinum\") # => <option value=\"Free\" selected=\"selected\">Free</option> # => <option value=\"Basic\">Basic</option> # => <option value=\"Advanced\">Advanced</option> # => <option value=\"Super Platinum\" disabled=\"disabled\">Super Platinum</option>  NOTE: Only the option tags are returned, you have to wrap this call in a regular HTML select tag.",
    "label": "",
    "id": "879"
  },
  {
    "raw_code": "def options_from_collection_for_select(collection, value_method, text_method, selected = nil)\n        options = collection.map do |element|\n          [value_for_collection(element, text_method), value_for_collection(element, value_method), option_html_attributes(element)]\n        end",
    "comment": "Returns a string of option tags that have been compiled by iterating over the +collection+ and assigning the result of a call to the +value_method+ as the option value and the +text_method+ as the option text.  options_from_collection_for_select(@people, 'id', 'name') # => <option value=\"#{person.id}\">#{person.name}</option>  This is more often than not used inside a #select_tag like this example:  select_tag 'person', options_from_collection_for_select(@people, 'id', 'name')  If +selected+ is specified as a value or array of values, the element(s) returning a match on +value_method+ will be selected option tag(s).  If +selected+ is specified as a Proc, those members of the collection that return true for the anonymous function are the selected values.  +selected+ can also be a hash, specifying both <tt>:selected</tt> and/or <tt>:disabled</tt> values as required.  Be sure to specify the same class as the +value_method+ when specifying selected or disabled options. Failure to do this will produce undesired results. Example: options_from_collection_for_select(@people, 'id', 'name', '1') Will not select a person with the id of 1 because 1 (an Integer) is not the same as '1' (a string) options_from_collection_for_select(@people, 'id', 'name', 1) should produce the desired results.",
    "label": "",
    "id": "880"
  },
  {
    "raw_code": "def option_groups_from_collection_for_select(collection, group_method, group_label_method, option_key_method, option_value_method, selected_key = nil)\n        collection.map do |group|\n          option_tags = options_from_collection_for_select(\n            value_for_collection(group, group_method), option_key_method, option_value_method, selected_key)\n\n          content_tag(\"optgroup\", option_tags, label: value_for_collection(group, group_label_method))\n        end.join.html_safe\n      end",
    "comment": "Returns a string of <tt><option></tt> tags, like #options_from_collection_for_select, but groups them by <tt><optgroup></tt> tags based on the object relationships of the arguments.  Parameters: * +collection+ - An array of objects representing the <tt><optgroup></tt> tags. * +group_method+ - The name of a method which, when called on a member of +collection+, returns an array of child objects representing the <tt><option></tt> tags. * +group_label_method+ - The name of a method which, when called on a member of +collection+, returns a string to be used as the +label+ attribute for its <tt><optgroup></tt> tag. * +option_key_method+ - The name of a method which, when called on a child object of a member of +collection+, returns a value to be used as the +value+ attribute for its <tt><option></tt> tag. * +option_value_method+ - The name of a method which, when called on a child object of a member of +collection+, returns a value to be used as the contents of its <tt><option></tt> tag. * +selected_key+ - A value equal to the +value+ attribute for one of the <tt><option></tt> tags, which will have the +selected+ attribute set. Corresponds to the return value of one of the calls to +option_key_method+. If +nil+, no selection is made. Can also be a hash if disabled values are to be specified.  Example object structure for use with this method:  class Continent < ActiveRecord::Base has_many :countries # attribs: id, name end  class Country < ActiveRecord::Base belongs_to :continent # attribs: id, name, continent_id end  Sample usage: option_groups_from_collection_for_select(@continents, :countries, :name, :id, :name, 3)  Possible output: <optgroup label=\"Africa\"> <option value=\"1\">Egypt</option> <option value=\"4\">Rwanda</option> ... </optgroup> <optgroup label=\"Asia\"> <option value=\"3\" selected=\"selected\">China</option> <option value=\"12\">India</option> <option value=\"5\">Japan</option> ... </optgroup>  <b>Note:</b> Only the <tt><optgroup></tt> and <tt><option></tt> tags are returned, so you still have to wrap the output in an appropriate <tt><select></tt> tag.",
    "label": "",
    "id": "881"
  },
  {
    "raw_code": "def grouped_options_for_select(grouped_options, selected_key = nil, options = {})\n        prompt  = options[:prompt]\n        divider = options[:divider]\n\n        body = \"\".html_safe\n\n        if prompt\n          body.safe_concat content_tag(\"option\", prompt_text(prompt), value: \"\")\n        end",
    "comment": "Returns a string of <tt><option></tt> tags, like #options_for_select, but wraps them with <tt><optgroup></tt> tags:  grouped_options = [ ['North America', [['United States','US'],'Canada']], ['Europe', ['Denmark','Germany','France']] ] grouped_options_for_select(grouped_options)  grouped_options = { 'North America' => [['United States','US'], 'Canada'], 'Europe' => ['Denmark','Germany','France'] } grouped_options_for_select(grouped_options)  Possible output: <optgroup label=\"North America\"> <option value=\"US\">United States</option> <option value=\"Canada\">Canada</option> </optgroup> <optgroup label=\"Europe\"> <option value=\"Denmark\">Denmark</option> <option value=\"Germany\">Germany</option> <option value=\"France\">France</option> </optgroup>  ==== Parameters  * +grouped_options+ - Accepts a nested array or hash of strings. The first value serves as the <tt><optgroup></tt> label while the second value must be an array of options. The second value can be a nested array of text-value pairs. See <tt>options_for_select</tt> for more info. Ex. [\"North America\",[[\"United States\",\"US\"],[\"Canada\",\"CA\"]]] An optional third value can be provided as HTML attributes for the <tt>optgroup</tt>. Ex. [\"North America\",[[\"United States\",\"US\"],[\"Canada\",\"CA\"]], { disabled: \"disabled\" }] * +selected_key+ - A value equal to the +value+ attribute for one of the <tt><option></tt> tags, which will have the +selected+ attribute set. Note: It is possible for this value to match multiple options as you might have the same option in multiple groups. Each will then get <tt>selected=\"selected\"</tt>.  ==== Options  * <tt>:prompt</tt> - set to true or a prompt string. When the select element doesn't have a value yet, this prepends an option with a generic prompt - \"Please select\" - or the given prompt string. * <tt>:divider</tt> - the divider for the options groups.  grouped_options = [ [['United States','US'], 'Canada'], ['Denmark','Germany','France'] ] grouped_options_for_select(grouped_options, nil, divider: '---------')  Possible output: <optgroup label=\"---------\"> <option value=\"US\">United States</option> <option value=\"Canada\">Canada</option> </optgroup> <optgroup label=\"---------\"> <option value=\"Denmark\">Denmark</option> <option value=\"Germany\">Germany</option> <option value=\"France\">France</option> </optgroup>  <b>Note:</b> Only the <tt><optgroup></tt> and <tt><option></tt> tags are returned, so you still have to wrap the output in an appropriate <tt><select></tt> tag.",
    "label": "",
    "id": "882"
  },
  {
    "raw_code": "def time_zone_options_for_select(selected = nil, priority_zones = nil, model = ::ActiveSupport::TimeZone)\n        zone_options = \"\".html_safe\n\n        zones = model.all\n        convert_zones = lambda { |list| list.map { |z| [ z.to_s, z.name ] } }\n\n        if priority_zones\n          if priority_zones.is_a?(Regexp)\n            priority_zones = zones.select { |z| z.match?(priority_zones) }\n          end",
    "comment": "Returns a string of option tags for pretty much any time zone in the world. Supply an ActiveSupport::TimeZone name as +selected+ to have it marked as the selected option tag. You can also supply an array of ActiveSupport::TimeZone objects as +priority_zones+, so that they will be listed above the rest of the (long) list. (You can use ActiveSupport::TimeZone.us_zones as a convenience for obtaining a list of the US time zones, or a Regexp to select the zones of your choice)  The +selected+ parameter must be either +nil+, or a string that names an ActiveSupport::TimeZone.  By default, +model+ is the ActiveSupport::TimeZone constant (which can be obtained in Active Record as a value object). The +model+ parameter must respond to +all+ and return an array of objects that represent time zones; each object must respond to +name+. If a Regexp is given it will attempt to match the zones using <code>match?</code> method.  NOTE: Only the option tags are returned, you have to wrap this call in a regular HTML select tag.",
    "label": "",
    "id": "883"
  },
  {
    "raw_code": "def weekday_options_for_select(selected = nil, index_as_value: false, day_format: :day_names, beginning_of_week: Date.beginning_of_week)\n        day_names = I18n.translate(\"date.#{day_format}\")\n        day_names = day_names.map.with_index.to_a if index_as_value\n        day_names = day_names.rotate(Date::DAYS_INTO_WEEK.fetch(beginning_of_week))\n\n        options_for_select(day_names, selected)\n      end",
    "comment": "Returns a string of option tags for the days of the week.  ====Options  * <tt>:index_as_value</tt> - Defaults to false, set to true to use the indexes from <tt>I18n.translate(\"date.day_names\")</tt> as the values. By default, Sunday is always 0. * <tt>:day_format</tt> - The I18n key of the array to use for the weekday options. Defaults to +:day_names+, set to +:abbr_day_names+ for abbreviations. * <tt>:beginning_of_week</tt> - Defaults to Date.beginning_of_week.  NOTE: Only the option tags are returned, you have to wrap this call in a regular HTML select tag.",
    "label": "",
    "id": "884"
  },
  {
    "raw_code": "def collection_radio_buttons(object, method, collection, value_method, text_method, options = {}, html_options = {}, &block)\n        Tags::CollectionRadioButtons.new(object, method, self, collection, value_method, text_method, options, html_options).render(&block)\n      end",
    "comment": "Returns radio button tags for the collection of existing return values of +method+ for +object+'s class. The value returned from calling +method+ on the instance +object+ will be selected. If calling +method+ returns +nil+, no selection is made.  The <tt>:value_method</tt> and <tt>:text_method</tt> parameters are methods to be called on each member of +collection+. The return values are used as the +value+ attribute and contents of each radio button tag, respectively. They can also be any object that responds to +call+, such as a +proc+, that will be called for each member of the +collection+ to retrieve the value/text.  Example object structure for use with this method:  class Post < ActiveRecord::Base belongs_to :author end  class Author < ActiveRecord::Base has_many :posts  def name_with_initial \"#{first_name.first}. #{last_name}\" end end  Sample usage (selecting the associated Author for an instance of Post, <tt>@post</tt>): collection_radio_buttons(:post, :author_id, Author.all, :id, :name_with_initial)  If <tt>@post.author_id</tt> is already <tt>1</tt>, this would return: <input id=\"post_author_id_1\" name=\"post[author_id]\" type=\"radio\" value=\"1\" checked=\"checked\" /> <label for=\"post_author_id_1\">D. Heinemeier Hansson</label> <input id=\"post_author_id_2\" name=\"post[author_id]\" type=\"radio\" value=\"2\" /> <label for=\"post_author_id_2\">D. Thomas</label> <input id=\"post_author_id_3\" name=\"post[author_id]\" type=\"radio\" value=\"3\" /> <label for=\"post_author_id_3\">M. Clark</label>  It is also possible to customize the way the elements will be shown by giving a block to the method: collection_radio_buttons(:post, :author_id, Author.all, :id, :name_with_initial) do |b| b.label { b.radio_button } end  The argument passed to the block is a special kind of builder for this collection, which has the ability to generate the label and radio button for the current item in the collection, with proper text and value. Using it, you can change the label and radio button display order or even use the label as wrapper, as in the example above.  The builder methods <tt>label</tt> and <tt>radio_button</tt> also accept extra HTML options: collection_radio_buttons(:post, :author_id, Author.all, :id, :name_with_initial) do |b| b.label(class: \"radio_button\") { b.radio_button(class: \"radio_button\") } end  There are also three special methods available: <tt>object</tt>, <tt>text</tt> and <tt>value</tt>, which are the current item being rendered, its text and value methods, respectively. You can use them like this: collection_radio_buttons(:post, :author_id, Author.all, :id, :name_with_initial) do |b| b.label(:\"data-value\" => b.value) { b.radio_button + b.text } end  ==== Gotcha  The HTML specification says when nothing is selected on a collection of radio buttons web browsers do not send any value to server. Unfortunately this introduces a gotcha: if a +User+ model has a +category_id+ field and in the form no category is selected, no +category_id+ parameter is sent. So, any strong parameters idiom like:  params.expect(user: [...])  will raise an error since no <tt>{user: ...}</tt> will be present.  To prevent this the helper generates an auxiliary hidden field before every collection of radio buttons. The hidden field has the same name as collection radio button and blank value.  In case if you don't want the helper to generate this hidden field you can specify <tt>include_hidden: false</tt> option.",
    "label": "",
    "id": "885"
  },
  {
    "raw_code": "def collection_checkboxes(object, method, collection, value_method, text_method, options = {}, html_options = {}, &block)\n        Tags::CollectionCheckBoxes.new(object, method, self, collection, value_method, text_method, options, html_options).render(&block)\n      end",
    "comment": "Returns check box tags for the collection of existing return values of +method+ for +object+'s class. The value returned from calling +method+ on the instance +object+ will be selected. If calling +method+ returns +nil+, no selection is made.  The <tt>:value_method</tt> and <tt>:text_method</tt> parameters are methods to be called on each member of +collection+. The return values are used as the +value+ attribute and contents of each check box tag, respectively. They can also be any object that responds to +call+, such as a +proc+, that will be called for each member of the +collection+ to retrieve the value/text.  Example object structure for use with this method: class Post < ActiveRecord::Base has_and_belongs_to_many :authors end class Author < ActiveRecord::Base has_and_belongs_to_many :posts def name_with_initial \"#{first_name.first}. #{last_name}\" end end  Sample usage (selecting the associated Author for an instance of Post, <tt>@post</tt>): collection_checkboxes(:post, :author_ids, Author.all, :id, :name_with_initial)  If <tt>@post.author_ids</tt> is already <tt>[1]</tt>, this would return: <input id=\"post_author_ids_1\" name=\"post[author_ids][]\" type=\"checkbox\" value=\"1\" checked=\"checked\" /> <label for=\"post_author_ids_1\">D. Heinemeier Hansson</label> <input id=\"post_author_ids_2\" name=\"post[author_ids][]\" type=\"checkbox\" value=\"2\" /> <label for=\"post_author_ids_2\">D. Thomas</label> <input id=\"post_author_ids_3\" name=\"post[author_ids][]\" type=\"checkbox\" value=\"3\" /> <label for=\"post_author_ids_3\">M. Clark</label> <input name=\"post[author_ids][]\" type=\"hidden\" value=\"\" />  It is also possible to customize the way the elements will be shown by giving a block to the method: collection_checkboxes(:post, :author_ids, Author.all, :id, :name_with_initial) do |b| b.label { b.checkbox } end  The argument passed to the block is a special kind of builder for this collection, which has the ability to generate the label and check box for the current item in the collection, with proper text and value. Using it, you can change the label and check box display order or even use the label as wrapper, as in the example above.  The builder methods <tt>label</tt> and <tt>checkbox</tt> also accept extra HTML options: collection_checkboxes(:post, :author_ids, Author.all, :id, :name_with_initial) do |b| b.label(class: \"checkbox\") { b.checkbox(class: \"checkbox\") } end  There are also three special methods available: <tt>object</tt>, <tt>text</tt> and <tt>value</tt>, which are the current item being rendered, its text and value methods, respectively. You can use them like this: collection_checkboxes(:post, :author_ids, Author.all, :id, :name_with_initial) do |b| b.label(:\"data-value\" => b.value) { b.checkbox + b.text } end  ==== Gotcha  When no selection is made for a collection of checkboxes most web browsers will not send any value.  For example, if we have a +User+ model with +category_ids+ field and we have the following code in our update action:  @user.update(params[:user])  If no +category_ids+ are selected then we can safely assume this field will not be updated.  This is possible thanks to a hidden field generated by the helper method for every collection of checkboxes. This hidden field is given the same field name as the checkboxes with a blank value.  In the rare case you don't want this hidden field, you can pass the <tt>include_hidden: false</tt> option to the helper method.",
    "label": "",
    "id": "886"
  },
  {
    "raw_code": "def select(method, choices = nil, options = {}, html_options = {}, &block)\n        @template.select(@object_name, method, choices, objectify_options(options), @default_html_options.merge(html_options), &block)\n      end",
    "comment": "Wraps ActionView::Helpers::FormOptionsHelper#select for form builders:  <%= form_with model: @post do |f| %> <%= f.select :person_id, Person.all.collect { |p| [ p.name, p.id ] }, include_blank: true %> <%= f.submit %> <% end %>  Please refer to the documentation of the base helper for details.",
    "label": "",
    "id": "887"
  },
  {
    "raw_code": "def collection_select(method, collection, value_method, text_method, options = {}, html_options = {})\n        @template.collection_select(@object_name, method, collection, value_method, text_method, objectify_options(options), @default_html_options.merge(html_options))\n      end",
    "comment": "Wraps ActionView::Helpers::FormOptionsHelper#collection_select for form builders:  <%= form_with model: @post do |f| %> <%= f.collection_select :person_id, Author.all, :id, :name_with_initial, prompt: true %> <%= f.submit %> <% end %>  Please refer to the documentation of the base helper for details.",
    "label": "",
    "id": "888"
  },
  {
    "raw_code": "def grouped_collection_select(method, collection, group_method, group_label_method, option_key_method, option_value_method, options = {}, html_options = {})\n        @template.grouped_collection_select(@object_name, method, collection, group_method, group_label_method, option_key_method, option_value_method, objectify_options(options), @default_html_options.merge(html_options))\n      end",
    "comment": "Wraps ActionView::Helpers::FormOptionsHelper#grouped_collection_select for form builders:  <%= form_with model: @city do |f| %> <%= f.grouped_collection_select :country_id, @continents, :countries, :name, :id, :name %> <%= f.submit %> <% end %>  Please refer to the documentation of the base helper for details.",
    "label": "",
    "id": "889"
  },
  {
    "raw_code": "def time_zone_select(method, priority_zones = nil, options = {}, html_options = {})\n        @template.time_zone_select(@object_name, method, priority_zones, objectify_options(options), @default_html_options.merge(html_options))\n      end",
    "comment": "Wraps ActionView::Helpers::FormOptionsHelper#time_zone_select for form builders:  <%= form_with model: @user do |f| %> <%= f.time_zone_select :time_zone, nil, include_blank: true %> <%= f.submit %> <% end %>  Please refer to the documentation of the base helper for details.",
    "label": "",
    "id": "890"
  },
  {
    "raw_code": "def weekday_select(method, options = {}, html_options = {})\n        @template.weekday_select(@object_name, method, objectify_options(options), @default_html_options.merge(html_options))\n      end",
    "comment": "Wraps ActionView::Helpers::FormOptionsHelper#weekday_select for form builders:  <%= form_with model: @user do |f| %> <%= f.weekday_select :weekday, include_blank: true %> <%= f.submit %> <% end %>  Please refer to the documentation of the base helper for details.",
    "label": "",
    "id": "891"
  },
  {
    "raw_code": "def collection_checkboxes(method, collection, value_method, text_method, options = {}, html_options = {}, &block)\n        @template.collection_checkboxes(@object_name, method, collection, value_method, text_method, objectify_options(options), @default_html_options.merge(html_options), &block)\n      end",
    "comment": "Wraps ActionView::Helpers::FormOptionsHelper#collection_checkboxes for form builders:  <%= form_with model: @post do |f| %> <%= f.collection_checkboxes :author_ids, Author.all, :id, :name_with_initial %> <%= f.submit %> <% end %>  Please refer to the documentation of the base helper for details.",
    "label": "",
    "id": "892"
  },
  {
    "raw_code": "def collection_radio_buttons(method, collection, value_method, text_method, options = {}, html_options = {}, &block)\n        @template.collection_radio_buttons(@object_name, method, collection, value_method, text_method, objectify_options(options), @default_html_options.merge(html_options), &block)\n      end",
    "comment": "Wraps ActionView::Helpers::FormOptionsHelper#collection_radio_buttons for form builders:  <%= form_with model: @post do |f| %> <%= f.collection_radio_buttons :author_id, Author.all, :id, :name_with_initial %> <%= f.submit %> <% end %>  Please refer to the documentation of the base helper for details.",
    "label": "",
    "id": "893"
  },
  {
    "raw_code": "def form_tag(url_for_options = {}, options = {}, &block)\n        html_options = html_options_for_form(url_for_options, options)\n        if block_given?\n          form_tag_with_body(html_options, capture(&block))\n        else\n          form_tag_html(html_options)\n        end",
    "comment": "Starts a form tag that points the action to a URL configured with <tt>url_for_options</tt> just like ActionController::Base#url_for. The method for the form defaults to POST.  ==== Options * <tt>:multipart</tt> - If set to true, the enctype is set to \"multipart/form-data\". * <tt>:method</tt> - The method to use when submitting the form, usually either \"get\" or \"post\". If \"patch\", \"put\", \"delete\", or another verb is used, a hidden input with name <tt>_method</tt> is added to simulate the verb over post. * <tt>:authenticity_token</tt> - Authenticity token to use in the form. Use only if you need to pass custom authenticity token string, or to not add authenticity_token field at all (by passing <tt>false</tt>).  Remote forms may omit the embedded authenticity token by setting <tt>config.action_view.embed_authenticity_token_in_remote_forms = false</tt>. This is helpful when you're fragment-caching the form. Remote forms get the authenticity token from the <tt>meta</tt> tag, so embedding is unnecessary unless you support browsers without JavaScript. * <tt>:remote</tt> - If set to true, will allow the Unobtrusive JavaScript drivers to control the submit behavior. By default this behavior is an ajax submit. * <tt>:enforce_utf8</tt> - If set to false, a hidden input with name utf8 is not output. * Any other key creates standard HTML attributes for the tag.  ==== Examples form_tag('/posts') # => <form action=\"/posts\" method=\"post\">  form_tag('/posts/1', method: :put) # => <form action=\"/posts/1\" method=\"post\"> ... <input name=\"_method\" type=\"hidden\" value=\"put\" /> ...  form_tag('/upload', multipart: true) # => <form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">  <%= form_tag('/posts') do -%> <div><%= submit_tag 'Save' %></div> <% end -%> # => <form action=\"/posts\" method=\"post\"><div><input type=\"submit\" name=\"commit\" value=\"Save\" /></div></form>  <%= form_tag('/posts', remote: true) %> # => <form action=\"/posts\" method=\"post\" data-remote=\"true\">  form_tag(false, method: :get) # => <form method=\"get\">  form_tag('http://far.away.com/form', authenticity_token: false) # form without authenticity token  form_tag('http://far.away.com/form', authenticity_token: \"cf50faa3fe97702ca1ae\") # form with custom authenticity token ",
    "label": "",
    "id": "894"
  },
  {
    "raw_code": "def field_id(object_name, method_name, *suffixes, index: nil, namespace: nil)\n        if object_name.respond_to?(:model_name)\n          object_name = object_name.model_name.singular\n        end",
    "comment": "Generate an HTML <tt>id</tt> attribute value for the given name and field combination  Return the value generated by the <tt>FormBuilder</tt> for the given attribute name.  <%= label_tag :post, :title %> <%= text_field :post, :title, aria: { describedby: field_id(:post, :title, :error) } %> <%= tag.span(\"is blank\", id: field_id(:post, :title, :error) %>  In the example above, the <tt><input type=\"text\"></tt> element built by the call to <tt>text_field</tt> declares an <tt>aria-describedby</tt> attribute referencing the <tt><span></tt> element, sharing a common <tt>id</tt> root (<tt>post_title</tt>, in this case).",
    "label": "",
    "id": "895"
  },
  {
    "raw_code": "def field_name(object_name, method_name, *method_names, multiple: false, index: nil)\n        names = method_names.map! { |name| \"[#{name}]\" }.join\n\n        # a little duplication to construct fewer strings\n        case\n        when object_name.blank?\n          \"#{method_name}#{names}#{multiple ? \"[]\" : \"\"}\"\n        when index\n          \"#{object_name}[#{index}][#{method_name}]#{names}#{multiple ? \"[]\" : \"\"}\"\n        else\n          \"#{object_name}[#{method_name}]#{names}#{multiple ? \"[]\" : \"\"}\"\n        end",
    "comment": "Generate an HTML <tt>name</tt> attribute value for the given name and field combination  Return the value generated by the <tt>FormBuilder</tt> for the given attribute name.  <%= text_field :post, :title, name: field_name(:post, :title, :subtitle) %> <%# => <input type=\"text\" name=\"post[title][subtitle]\"> %>  <%= text_field :post, :tag, name: field_name(:post, :tag, multiple: true) %> <%# => <input type=\"text\" name=\"post[tag][]\"> %> ",
    "label": "",
    "id": "896"
  },
  {
    "raw_code": "def select_tag(name, option_tags = nil, options = {})\n        option_tags ||= \"\"\n        html_name = (options[:multiple] == true && !name.end_with?(\"[]\")) ? \"#{name}[]\" : name\n\n        if options.include?(:include_blank)\n          include_blank = options[:include_blank]\n          options = options.except(:include_blank)\n          options_for_blank_options_tag = { value: \"\" }\n\n          if include_blank == true\n            include_blank = \"\"\n            options_for_blank_options_tag[:label] = \" \"\n          end",
    "comment": "Creates a dropdown selection box, or if the <tt>:multiple</tt> option is set to true, a multiple choice selection box.  Helpers::FormOptions can be used to create common select boxes such as countries, time zones, or associated records. <tt>option_tags</tt> is a string containing the option tags for the select box.  ==== Options * <tt>:multiple</tt> - If set to true, the selection will allow multiple choices. * <tt>:disabled</tt> - If set to true, the user will not be able to use this input. * <tt>:include_blank</tt> - If set to true, an empty option will be created. If set to a string, the string will be used as the option's content and the value will be empty. * <tt>:prompt</tt> - Create a prompt option with blank value and the text asking user to select something. * Any other key creates standard HTML attributes for the tag.  ==== Examples select_tag \"people\", options_from_collection_for_select(@people, \"id\", \"name\") # <select id=\"people\" name=\"people\"><option value=\"1\">David</option></select>  select_tag \"people\", options_from_collection_for_select(@people, \"id\", \"name\", \"1\") # <select id=\"people\" name=\"people\"><option value=\"1\" selected=\"selected\">David</option></select>  select_tag \"people\", raw(\"<option>David</option>\") # => <select id=\"people\" name=\"people\"><option>David</option></select>  select_tag \"count\", raw(\"<option>1</option><option>2</option><option>3</option><option>4</option>\") # => <select id=\"count\" name=\"count\"><option>1</option><option>2</option> #    <option>3</option><option>4</option></select>  select_tag \"colors\", raw(\"<option>Red</option><option>Green</option><option>Blue</option>\"), multiple: true # => <select id=\"colors\" multiple=\"multiple\" name=\"colors[]\"><option>Red</option> #    <option>Green</option><option>Blue</option></select>  select_tag \"locations\", raw(\"<option>Home</option><option selected='selected'>Work</option><option>Out</option>\") # => <select id=\"locations\" name=\"locations\"><option>Home</option><option selected='selected'>Work</option> #    <option>Out</option></select>  select_tag \"access\", raw(\"<option>Read</option><option>Write</option>\"), multiple: true, class: 'form_input', id: 'unique_id' # => <select class=\"form_input\" id=\"unique_id\" multiple=\"multiple\" name=\"access[]\"><option>Read</option> #    <option>Write</option></select>  select_tag \"people\", options_from_collection_for_select(@people, \"id\", \"name\"), include_blank: true # => <select id=\"people\" name=\"people\"><option value=\"\" label=\" \"></option><option value=\"1\">David</option></select>  select_tag \"people\", options_from_collection_for_select(@people, \"id\", \"name\"), include_blank: \"All\" # => <select id=\"people\" name=\"people\"><option value=\"\">All</option><option value=\"1\">David</option></select>  select_tag \"people\", options_from_collection_for_select(@people, \"id\", \"name\"), prompt: \"Select something\" # => <select id=\"people\" name=\"people\"><option value=\"\">Select something</option><option value=\"1\">David</option></select>  select_tag \"destination\", raw(\"<option>NYC</option><option>Paris</option><option>Rome</option>\"), disabled: true # => <select disabled=\"disabled\" id=\"destination\" name=\"destination\"><option>NYC</option> #    <option>Paris</option><option>Rome</option></select>  select_tag \"credit_card\", options_for_select([ \"VISA\", \"MasterCard\" ], \"MasterCard\") # => <select id=\"credit_card\" name=\"credit_card\"><option>VISA</option> #    <option selected=\"selected\">MasterCard</option></select>",
    "label": "",
    "id": "897"
  },
  {
    "raw_code": "def text_field_tag(name, value = nil, options = {})\n        tag :input, { \"type\" => \"text\", \"name\" => name, \"id\" => sanitize_to_id(name), \"value\" => value }.update(options.stringify_keys)\n      end",
    "comment": "Creates a standard text field; use these text fields to input smaller chunks of text like a username or a search query.  ==== Options * <tt>:disabled</tt> - If set to true, the user will not be able to use this input. * <tt>:size</tt> - The number of visible characters that will fit in the input. * <tt>:maxlength</tt> - The maximum number of characters that the browser will allow the user to enter. * <tt>:placeholder</tt> - The text contained in the field by default which is removed when the field receives focus. If set to true, use the translation found in the current I18n locale (through helpers.placeholder.<modelname>.<attribute>). * Any other key creates standard HTML attributes for the tag.  ==== Examples text_field_tag 'name' # => <input id=\"name\" name=\"name\" type=\"text\" />  text_field_tag 'query', 'Enter your search query here' # => <input id=\"query\" name=\"query\" type=\"text\" value=\"Enter your search query here\" />  text_field_tag 'search', nil, placeholder: 'Enter search term...' # => <input id=\"search\" name=\"search\" placeholder=\"Enter search term...\" type=\"text\" />  text_field_tag 'request', nil, class: 'special_input' # => <input class=\"special_input\" id=\"request\" name=\"request\" type=\"text\" />  text_field_tag 'address', '', size: 75 # => <input id=\"address\" name=\"address\" size=\"75\" type=\"text\" value=\"\" />  text_field_tag 'zip', nil, maxlength: 5 # => <input id=\"zip\" maxlength=\"5\" name=\"zip\" type=\"text\" />  text_field_tag 'payment_amount', '$0.00', disabled: true # => <input disabled=\"disabled\" id=\"payment_amount\" name=\"payment_amount\" type=\"text\" value=\"$0.00\" />  text_field_tag 'ip', '0.0.0.0', maxlength: 15, size: 20, class: \"ip-input\" # => <input class=\"ip-input\" id=\"ip\" maxlength=\"15\" name=\"ip\" size=\"20\" type=\"text\" value=\"0.0.0.0\" />",
    "label": "",
    "id": "898"
  },
  {
    "raw_code": "def label_tag(name = nil, content_or_options = nil, options = nil, &block)\n        if block_given? && content_or_options.is_a?(Hash)\n          options = content_or_options = content_or_options.stringify_keys\n        else\n          options ||= {}\n          options = options.stringify_keys\n        end",
    "comment": "Creates a label element. Accepts a block.  ==== Options * Creates standard HTML attributes for the tag.  ==== Examples label_tag 'name' # => <label for=\"name\">Name</label>  label_tag 'name', 'Your name' # => <label for=\"name\">Your name</label>  label_tag 'name', nil, class: 'small_label' # => <label for=\"name\" class=\"small_label\">Name</label>",
    "label": "",
    "id": "899"
  },
  {
    "raw_code": "def hidden_field_tag(name, value = nil, options = {})\n        html_options = options.merge(type: :hidden)\n        unless ActionView::Base.remove_hidden_field_autocomplete\n          html_options[:autocomplete] = \"off\" unless html_options.key?(:autocomplete)\n        end",
    "comment": "Creates a hidden form input field used to transmit data that would be lost due to HTTP's statelessness or data that should be hidden from the user.  ==== Options * Creates standard HTML attributes for the tag.  ==== Examples hidden_field_tag 'tags_list' # => <input type=\"hidden\" name=\"tags_list\" id=\"tags_list\" autocomplete=\"off\" />  hidden_field_tag 'token', 'VUBJKB23UIVI1UU1VOBVI@' # => <input type=\"hidden\" name=\"token\" id=\"token\" value=\"VUBJKB23UIVI1UU1VOBVI@\" autocomplete=\"off\" />  hidden_field_tag 'collected_input', '', onchange: \"alert('Input collected!')\" # => <input type=\"hidden\" name=\"collected_input\" id=\"collected_input\" value=\"\" onchange=\"alert(&#39;Input collected!&#39;)\" autocomplete=\"off\" />",
    "label": "",
    "id": "900"
  },
  {
    "raw_code": "def file_field_tag(name, options = {})\n        text_field_tag(name, nil, convert_direct_upload_option_to_url(options.merge(type: :file)))\n      end",
    "comment": "Creates a file upload field. If you are using file uploads then you will also need to set the multipart option for the form tag:  <%= form_tag '/upload', multipart: true do %> <label for=\"file\">File to Upload</label> <%= file_field_tag \"file\" %> <%= submit_tag %> <% end %>  The specified URL will then be passed a File object containing the selected file, or if the field was left blank, a StringIO object.  ==== Options * Creates standard HTML attributes for the tag. * <tt>:disabled</tt> - If set to true, the user will not be able to use this input. * <tt>:multiple</tt> - If set to true, *in most updated browsers* the user will be allowed to select multiple files. * <tt>:accept</tt> - If set to one or multiple mime-types, the user will be suggested a filter when choosing a file. You still need to set up model validations.  ==== Examples file_field_tag 'attachment' # => <input id=\"attachment\" name=\"attachment\" type=\"file\" />  file_field_tag 'avatar', class: 'profile_input' # => <input class=\"profile_input\" id=\"avatar\" name=\"avatar\" type=\"file\" />  file_field_tag 'picture', disabled: true # => <input disabled=\"disabled\" id=\"picture\" name=\"picture\" type=\"file\" />  file_field_tag 'resume', value: '~/resume.doc' # => <input id=\"resume\" name=\"resume\" type=\"file\" value=\"~/resume.doc\" />  file_field_tag 'user_pic', accept: 'image/png,image/gif,image/jpeg' # => <input accept=\"image/png,image/gif,image/jpeg\" id=\"user_pic\" name=\"user_pic\" type=\"file\" />  file_field_tag 'file', accept: 'text/html', class: 'upload', value: 'index.html' # => <input accept=\"text/html\" class=\"upload\" id=\"file\" name=\"file\" type=\"file\" value=\"index.html\" />",
    "label": "",
    "id": "901"
  },
  {
    "raw_code": "def password_field_tag(name = \"password\", value = nil, options = {})\n        text_field_tag(name, value, options.merge(type: :password))\n      end",
    "comment": "Creates a password field, a masked text field that will hide the users input behind a mask character.  ==== Options * <tt>:disabled</tt> - If set to true, the user will not be able to use this input. * <tt>:size</tt> - The number of visible characters that will fit in the input. * <tt>:maxlength</tt> - The maximum number of characters that the browser will allow the user to enter. * Any other key creates standard HTML attributes for the tag.  ==== Examples password_field_tag 'pass' # => <input id=\"pass\" name=\"pass\" type=\"password\" />  password_field_tag 'secret', 'Your secret here' # => <input id=\"secret\" name=\"secret\" type=\"password\" value=\"Your secret here\" />  password_field_tag 'masked', nil, class: 'masked_input_field' # => <input class=\"masked_input_field\" id=\"masked\" name=\"masked\" type=\"password\" />  password_field_tag 'token', '', size: 15 # => <input id=\"token\" name=\"token\" size=\"15\" type=\"password\" value=\"\" />  password_field_tag 'key', nil, maxlength: 16 # => <input id=\"key\" maxlength=\"16\" name=\"key\" type=\"password\" />  password_field_tag 'confirm_pass', nil, disabled: true # => <input disabled=\"disabled\" id=\"confirm_pass\" name=\"confirm_pass\" type=\"password\" />  password_field_tag 'pin', '1234', maxlength: 4, size: 6, class: \"pin_input\" # => <input class=\"pin_input\" id=\"pin\" maxlength=\"4\" name=\"pin\" size=\"6\" type=\"password\" value=\"1234\" />",
    "label": "",
    "id": "902"
  },
  {
    "raw_code": "def textarea_tag(name, content = nil, options = {})\n        options = options.stringify_keys\n\n        if size = options.delete(\"size\")\n          options[\"cols\"], options[\"rows\"] = size.split(\"x\") if size.respond_to?(:split)\n        end",
    "comment": "Creates a text input area; use a textarea for longer text inputs such as blog posts or descriptions.  ==== Options * <tt>:size</tt> - A string specifying the dimensions (columns by rows) of the textarea (e.g., \"25x10\"). * <tt>:rows</tt> - Specify the number of rows in the textarea * <tt>:cols</tt> - Specify the number of columns in the textarea * <tt>:disabled</tt> - If set to true, the user will not be able to use this input. * <tt>:escape</tt> - By default, the contents of the text input are HTML escaped. If you need unescaped contents, set this to false. * Any other key creates standard HTML attributes for the tag.  ==== Examples textarea_tag 'post' # => <textarea id=\"post\" name=\"post\"></textarea>  textarea_tag 'bio', @user.bio # => <textarea id=\"bio\" name=\"bio\">This is my biography.</textarea>  textarea_tag 'body', nil, rows: 10, cols: 25 # => <textarea cols=\"25\" id=\"body\" name=\"body\" rows=\"10\"></textarea>  textarea_tag 'body', nil, size: \"25x10\" # => <textarea name=\"body\" id=\"body\" cols=\"25\" rows=\"10\"></textarea>  textarea_tag 'description', \"Description goes here.\", disabled: true # => <textarea disabled=\"disabled\" id=\"description\" name=\"description\">Description goes here.</textarea>  textarea_tag 'comment', nil, class: 'comment_input' # => <textarea class=\"comment_input\" id=\"comment\" name=\"comment\"></textarea>",
    "label": "",
    "id": "903"
  },
  {
    "raw_code": "def checkbox_tag(name, *args)\n        if args.length >= 4\n          raise ArgumentError, \"wrong number of arguments (given #{args.length + 1}, expected 1..4)\"\n        end",
    "comment": " :call-seq: checkbox_tag(name, options = {}) checkbox_tag(name, value, options = {}) checkbox_tag(name, value, checked, options = {})  Creates a check box form input tag.  ==== Options * <tt>:value</tt> - The value of the input. Defaults to <tt>\"1\"</tt>. * <tt>:checked</tt> - If set to true, the checkbox will be checked by default. * <tt>:disabled</tt> - If set to true, the user will not be able to use this input. * Any other key creates standard HTML options for the tag.  ==== Examples checkbox_tag 'accept' # => <input id=\"accept\" name=\"accept\" type=\"checkbox\" value=\"1\" />  checkbox_tag 'rock', 'rock music' # => <input id=\"rock\" name=\"rock\" type=\"checkbox\" value=\"rock music\" />  checkbox_tag 'receive_email', 'yes', true # => <input checked=\"checked\" id=\"receive_email\" name=\"receive_email\" type=\"checkbox\" value=\"yes\" />  checkbox_tag 'tos', 'yes', false, class: 'accept_tos' # => <input class=\"accept_tos\" id=\"tos\" name=\"tos\" type=\"checkbox\" value=\"yes\" />  checkbox_tag 'eula', 'accepted', false, disabled: true # => <input disabled=\"disabled\" id=\"eula\" name=\"eula\" type=\"checkbox\" value=\"accepted\" />",
    "label": "",
    "id": "904"
  },
  {
    "raw_code": "def radio_button_tag(name, value, *args)\n        if args.length >= 3\n          raise ArgumentError, \"wrong number of arguments (given #{args.length + 2}, expected 2..4)\"\n        end",
    "comment": " :call-seq: radio_button_tag(name, value, options = {}) radio_button_tag(name, value, checked, options = {})  Creates a radio button; use groups of radio buttons named the same to allow users to select from a group of options.  ==== Options * <tt>:checked</tt> - If set to true, the radio button will be selected by default. * <tt>:disabled</tt> - If set to true, the user will not be able to use this input. * Any other key creates standard HTML options for the tag.  ==== Examples radio_button_tag 'favorite_color', 'maroon' # => <input id=\"favorite_color_maroon\" name=\"favorite_color\" type=\"radio\" value=\"maroon\" />  radio_button_tag 'receive_updates', 'no', true # => <input checked=\"checked\" id=\"receive_updates_no\" name=\"receive_updates\" type=\"radio\" value=\"no\" />  radio_button_tag 'time_slot', \"3:00 p.m.\", false, disabled: true # => <input disabled=\"disabled\" id=\"time_slot_3:00_p.m.\" name=\"time_slot\" type=\"radio\" value=\"3:00 p.m.\" />  radio_button_tag 'color', \"green\", true, class: \"color_input\" # => <input checked=\"checked\" class=\"color_input\" id=\"color_green\" name=\"color\" type=\"radio\" value=\"green\" />",
    "label": "",
    "id": "905"
  },
  {
    "raw_code": "def submit_tag(value = \"Save changes\", options = {})\n        options = options.deep_stringify_keys\n        tag_options = { \"type\" => \"submit\", \"name\" => \"commit\", \"value\" => value }.update(options)\n        set_default_disable_with value, tag_options\n        tag :input, tag_options\n      end",
    "comment": "Creates a submit button with the text <tt>value</tt> as the caption.  ==== Options * <tt>:data</tt> - This option can be used to add custom data attributes. * <tt>:disabled</tt> - If true, the user will not be able to use this input. * Any other key creates standard HTML options for the tag.  ==== Examples submit_tag # => <input name=\"commit\" data-disable-with=\"Save changes\" type=\"submit\" value=\"Save changes\" />  submit_tag \"Edit this article\" # => <input name=\"commit\" data-disable-with=\"Edit this article\" type=\"submit\" value=\"Edit this article\" />  submit_tag \"Save edits\", disabled: true # => <input disabled=\"disabled\" name=\"commit\" data-disable-with=\"Save edits\" type=\"submit\" value=\"Save edits\" />  submit_tag nil, class: \"form_submit\" # => <input class=\"form_submit\" name=\"commit\" type=\"submit\" />  submit_tag \"Edit\", class: \"edit_button\" # => <input class=\"edit_button\" data-disable-with=\"Edit\" name=\"commit\" type=\"submit\" value=\"Edit\" /> ",
    "label": "",
    "id": "906"
  },
  {
    "raw_code": "def button_tag(content_or_options = nil, options = nil, &block)\n        if content_or_options.is_a? Hash\n          options = content_or_options\n        else\n          options ||= {}\n        end",
    "comment": "Creates a button element that defines a <tt>submit</tt> button, <tt>reset</tt> button or a generic button which can be used in JavaScript, for example. You can use the button tag as a regular submit tag but it isn't supported in legacy browsers. However, the button tag does allow for richer labels such as images and emphasis, so this helper will also accept a block. By default, it will create a button tag with type <tt>submit</tt>, if type is not given.  ==== Options * <tt>:data</tt> - This option can be used to add custom data attributes. * <tt>:disabled</tt> - If true, the user will not be able to use this input. * Any other key creates standard HTML options for the tag.  ==== Examples button_tag # => <button name=\"button\" type=\"submit\">Button</button>  button_tag 'Reset', type: 'reset' # => <button name=\"button\" type=\"reset\">Reset</button>  button_tag 'Button', type: 'button' # => <button name=\"button\" type=\"button\">Button</button>  button_tag 'Reset', type: 'reset', disabled: true # => <button name=\"button\" type=\"reset\" disabled=\"disabled\">Reset</button>  button_tag(type: 'button') do content_tag(:strong, 'Ask me!') end # => <button name=\"button\" type=\"button\"> #     <strong>Ask me!</strong> #    </button> ",
    "label": "",
    "id": "907"
  },
  {
    "raw_code": "def image_submit_tag(source, options = {})\n        options = options.stringify_keys\n        src = path_to_image(source, skip_pipeline: options.delete(\"skip_pipeline\"))\n        tag :input, { \"type\" => \"image\", \"src\" => src }.update(options)\n      end",
    "comment": "Displays an image which when clicked will submit the form.  <tt>source</tt> is passed to AssetTagHelper#path_to_image  ==== Options * <tt>:data</tt> - This option can be used to add custom data attributes. * <tt>:disabled</tt> - If set to true, the user will not be able to use this input. * Any other key creates standard HTML options for the tag.  ==== Data attributes  * <tt>confirm: 'question?'</tt> - This will add a JavaScript confirm prompt with the question specified. If the user accepts, the form is processed normally, otherwise no action is taken.  ==== Examples image_submit_tag(\"login.png\") # => <input src=\"/assets/login.png\" type=\"image\" />  image_submit_tag(\"purchase.png\", disabled: true) # => <input disabled=\"disabled\" src=\"/assets/purchase.png\" type=\"image\" />  image_submit_tag(\"search.png\", class: 'search_button', alt: 'Find') # => <input class=\"search_button\" src=\"/assets/search.png\" type=\"image\" />  image_submit_tag(\"agree.png\", disabled: true, class: \"agree_disagree_button\") # => <input class=\"agree_disagree_button\" disabled=\"disabled\" src=\"/assets/agree.png\" type=\"image\" />  image_submit_tag(\"save.png\", data: { confirm: \"Are you sure?\" }) # => <input src=\"/assets/save.png\" data-confirm=\"Are you sure?\" type=\"image\" />",
    "label": "",
    "id": "908"
  },
  {
    "raw_code": "def field_set_tag(legend = nil, options = nil, &block)\n        content = []\n        content << content_tag(\"legend\", legend) unless legend.blank?\n        content << capture(&block) if block_given?\n\n        content_tag(:fieldset, safe_join(content), options)\n      end",
    "comment": "Creates a field set for grouping HTML form elements.  <tt>legend</tt> will become the fieldset's title (optional as per W3C). <tt>options</tt> accept the same values as tag.  ==== Examples <%= field_set_tag do %> <p><%= text_field_tag 'name' %></p> <% end %> # => <fieldset><p><input id=\"name\" name=\"name\" type=\"text\" /></p></fieldset>  <%= field_set_tag 'Your details' do %> <p><%= text_field_tag 'name' %></p> <% end %> # => <fieldset><legend>Your details</legend><p><input id=\"name\" name=\"name\" type=\"text\" /></p></fieldset>  <%= field_set_tag nil, class: 'format' do %> <p><%= text_field_tag 'name' %></p> <% end %> # => <fieldset class=\"format\"><p><input id=\"name\" name=\"name\" type=\"text\" /></p></fieldset>",
    "label": "",
    "id": "909"
  },
  {
    "raw_code": "def color_field_tag(name, value = nil, options = {})\n        text_field_tag(name, value, options.merge(type: :color))\n      end",
    "comment": "Creates a text field of type \"color\".  ==== Options  Supports the same options as #text_field_tag.  ==== Examples  color_field_tag 'name' # => <input id=\"name\" name=\"name\" type=\"color\" />  color_field_tag 'color', '#DEF726' # => <input id=\"color\" name=\"color\" type=\"color\" value=\"#DEF726\" />  color_field_tag 'color', nil, class: 'special_input' # => <input class=\"special_input\" id=\"color\" name=\"color\" type=\"color\" />  color_field_tag 'color', '#DEF726', class: 'special_input', disabled: true # => <input disabled=\"disabled\" class=\"special_input\" id=\"color\" name=\"color\" type=\"color\" value=\"#DEF726\" />",
    "label": "",
    "id": "910"
  },
  {
    "raw_code": "def search_field_tag(name, value = nil, options = {})\n        text_field_tag(name, value, options.merge(type: :search))\n      end",
    "comment": "Creates a text field of type \"search\".  ==== Options  Supports the same options as #text_field_tag.  ==== Examples  search_field_tag 'name' # => <input id=\"name\" name=\"name\" type=\"search\" />  search_field_tag 'search', 'Enter your search query here' # => <input id=\"search\" name=\"search\" type=\"search\" value=\"Enter your search query here\" />  search_field_tag 'search', nil, class: 'special_input' # => <input class=\"special_input\" id=\"search\" name=\"search\" type=\"search\" />  search_field_tag 'search', 'Enter your search query here', class: 'special_input', disabled: true # => <input disabled=\"disabled\" class=\"special_input\" id=\"search\" name=\"search\" type=\"search\" value=\"Enter your search query here\" />",
    "label": "",
    "id": "911"
  },
  {
    "raw_code": "def telephone_field_tag(name, value = nil, options = {})\n        text_field_tag(name, value, options.merge(type: :tel))\n      end",
    "comment": "Creates a text field of type \"tel\".  ==== Options  Supports the same options as #text_field_tag.  ==== Examples  telephone_field_tag 'name' # => <input id=\"name\" name=\"name\" type=\"tel\" />  telephone_field_tag 'tel', '0123456789' # => <input id=\"tel\" name=\"tel\" type=\"tel\" value=\"0123456789\" />  telephone_field_tag 'tel', nil, class: 'special_input' # => <input class=\"special_input\" id=\"tel\" name=\"tel\" type=\"tel\" />  telephone_field_tag 'tel', '0123456789', class: 'special_input', disabled: true # => <input disabled=\"disabled\" class=\"special_input\" id=\"tel\" name=\"tel\" type=\"tel\" value=\"0123456789\" />",
    "label": "",
    "id": "912"
  },
  {
    "raw_code": "def date_field_tag(name, value = nil, options = {})\n        text_field_tag(name, value, options.merge(type: :date))\n      end",
    "comment": "Creates a text field of type \"date\".  ==== Options  Supports the same options as #text_field_tag.  ==== Examples  date_field_tag 'name' # => <input id=\"name\" name=\"name\" type=\"date\" />  date_field_tag 'date', '2014-12-31' # => <input id=\"date\" name=\"date\" type=\"date\" value=\"2014-12-31\" />  date_field_tag 'date', nil, class: 'special_input' # => <input class=\"special_input\" id=\"date\" name=\"date\" type=\"date\" />  date_field_tag 'date', '2014-12-31', class: 'special_input', disabled: true # => <input disabled=\"disabled\" class=\"special_input\" id=\"date\" name=\"date\" type=\"date\" value=\"2014-12-31\" />",
    "label": "",
    "id": "913"
  },
  {
    "raw_code": "def time_field_tag(name, value = nil, options = {})\n        text_field_tag(name, value, options.merge(type: :time))\n      end",
    "comment": "Creates a text field of type \"time\".  ==== Options  Supports the same options as #text_field_tag. Additionally, supports:  * <tt>:min</tt> - The minimum acceptable value. * <tt>:max</tt> - The maximum acceptable value. * <tt>:step</tt> - The acceptable value granularity. * <tt>:include_seconds</tt> - Include seconds and ms in the output timestamp format (true by default).  ==== Examples  time_field_tag 'name' # => <input id=\"name\" name=\"name\" type=\"time\" />  time_field_tag 'time', '01:01' # => <input id=\"time\" name=\"time\" type=\"time\" value=\"01:01\" />  time_field_tag 'time', nil, class: 'special_input' # => <input class=\"special_input\" id=\"time\" name=\"time\" type=\"time\" />  time_field_tag 'time', '01:01', include_seconds: true # => <input id=\"time\" name=\"time\" type=\"time\" value=\"01:01:00.000\" />  time_field_tag 'time', '01:01', min: '00:00', max: '23:59', step: 1 # => <input id=\"time\" max=\"23:59\" min=\"00:00\" name=\"time\" step=\"1\" type=\"time\" value=\"01:01\" />",
    "label": "",
    "id": "914"
  },
  {
    "raw_code": "def datetime_field_tag(name, value = nil, options = {})\n        text_field_tag(name, value, options.merge(type: \"datetime-local\"))\n      end",
    "comment": "Creates a text field of type \"datetime-local\".  ==== Options  Supports the same options as #text_field_tag. Additionally, supports:  * <tt>:min</tt> - The minimum acceptable value. * <tt>:max</tt> - The maximum acceptable value. * <tt>:step</tt> - The acceptable value granularity. * <tt>:include_seconds</tt> - Include seconds in the output timestamp format (true by default).  ==== Examples  datetime_field_tag 'name' # => <input id=\"name\" name=\"name\" type=\"datetime-local\" />  datetime_field_tag 'datetime', '2014-01-01T01:01' # => <input id=\"datetime\" name=\"datetime\" type=\"datetime-local\" value=\"2014-01-01T01:01\" />  datetime_field_tag 'datetime', nil, class: 'special_input' # => <input class=\"special_input\" id=\"datetime\" name=\"datetime\" type=\"datetime-local\" />  datetime_field_tag 'datetime', '2014-01-01T01:01', class: 'special_input', disabled: true # => <input disabled=\"disabled\" class=\"special_input\" id=\"datetime\" name=\"datetime\" type=\"datetime-local\" value=\"2014-01-01T01:01\" />",
    "label": "",
    "id": "915"
  },
  {
    "raw_code": "def month_field_tag(name, value = nil, options = {})\n        text_field_tag(name, value, options.merge(type: :month))\n      end",
    "comment": "Creates a text field of type \"month\".  ==== Options  Supports the same options as #text_field_tag. Additionally, supports:  * <tt>:min</tt> - The minimum acceptable value. * <tt>:max</tt> - The maximum acceptable value. * <tt>:step</tt> - The acceptable value granularity.  ==== Examples  month_field_tag 'name' # => <input id=\"name\" name=\"name\" type=\"month\" />  month_field_tag 'month', '2014-01' # => <input id=\"month\" name=\"month\" type=\"month\" value=\"2014-01\" />  month_field_tag 'month', nil, class: 'special_input' # => <input class=\"special_input\" id=\"month\" name=\"month\" type=\"month\" />  month_field_tag 'month', '2014-01', class: 'special_input', disabled: true # => <input disabled=\"disabled\" class=\"special_input\" id=\"month\" name=\"month\" type=\"month\" value=\"2014-01\" />",
    "label": "",
    "id": "916"
  },
  {
    "raw_code": "def week_field_tag(name, value = nil, options = {})\n        text_field_tag(name, value, options.merge(type: :week))\n      end",
    "comment": "Creates a text field of type \"week\".  ==== Options  Supports the same options as #text_field_tag. Additionally, supports:  * <tt>:min</tt> - The minimum acceptable value. * <tt>:max</tt> - The maximum acceptable value. * <tt>:step</tt> - The acceptable value granularity.  ==== Examples  week_field_tag 'name' # => <input id=\"name\" name=\"name\" type=\"week\" />  week_field_tag 'week', '2014-W01' # => <input id=\"week\" name=\"week\" type=\"week\" value=\"2014-W01\" />  week_field_tag 'week', nil, class: 'special_input' # => <input class=\"special_input\" id=\"week\" name=\"week\" type=\"week\" />  week_field_tag 'week', '2014-W01', class: 'special_input', disabled: true # => <input disabled=\"disabled\" class=\"special_input\" id=\"week\" name=\"week\" type=\"week\" value=\"2014-W01\" />",
    "label": "",
    "id": "917"
  },
  {
    "raw_code": "def url_field_tag(name, value = nil, options = {})\n        text_field_tag(name, value, options.merge(type: :url))\n      end",
    "comment": "Creates a text field of type \"url\".  ==== Options  Supports the same options as #text_field_tag.  ==== Examples  url_field_tag 'name' # => <input id=\"name\" name=\"name\" type=\"url\" />  url_field_tag 'url', 'http://rubyonrails.org' # => <input id=\"url\" name=\"url\" type=\"url\" value=\"http://rubyonrails.org\" />  url_field_tag 'url', nil, class: 'special_input' # => <input class=\"special_input\" id=\"url\" name=\"url\" type=\"url\" />  url_field_tag 'url', 'http://rubyonrails.org', class: 'special_input', disabled: true # => <input disabled=\"disabled\" class=\"special_input\" id=\"url\" name=\"url\" type=\"url\" value=\"http://rubyonrails.org\" />",
    "label": "",
    "id": "918"
  },
  {
    "raw_code": "def email_field_tag(name, value = nil, options = {})\n        text_field_tag(name, value, options.merge(type: :email))\n      end",
    "comment": "Creates a text field of type \"email\".  ==== Options  Supports the same options as #text_field_tag.  ==== Examples  email_field_tag 'name' # => <input id=\"name\" name=\"name\" type=\"email\" />  email_field_tag 'email', 'email@example.com' # => <input id=\"email\" name=\"email\" type=\"email\" value=\"email@example.com\" />  email_field_tag 'email', nil, class: 'special_input' # => <input class=\"special_input\" id=\"email\" name=\"email\" type=\"email\" />  email_field_tag 'email', 'email@example.com', class: 'special_input', disabled: true # => <input disabled=\"disabled\" class=\"special_input\" id=\"email\" name=\"email\" type=\"email\" value=\"email@example.com\" />",
    "label": "",
    "id": "919"
  },
  {
    "raw_code": "def number_field_tag(name, value = nil, options = {})\n        options = options.stringify_keys\n        options[\"type\"] ||= \"number\"\n        if range = options.delete(\"in\") || options.delete(\"within\")\n          options.update(\"min\" => range.min, \"max\" => range.max)\n        end",
    "comment": "Creates a number field.  ==== Options  Supports the same options as #text_field_tag. Additionally, supports:  * <tt>:min</tt> - The minimum acceptable value. * <tt>:max</tt> - The maximum acceptable value. * <tt>:in</tt> - A range specifying the <tt>:min</tt> and <tt>:max</tt> values. * <tt>:within</tt> - Same as <tt>:in</tt>. * <tt>:step</tt> - The acceptable value granularity.  ==== Examples  number_field_tag 'quantity' # => <input id=\"quantity\" name=\"quantity\" type=\"number\" />  number_field_tag 'quantity', '1' # => <input id=\"quantity\" name=\"quantity\" type=\"number\" value=\"1\" />  number_field_tag 'quantity', nil, class: 'special_input' # => <input class=\"special_input\" id=\"quantity\" name=\"quantity\" type=\"number\" />  number_field_tag 'quantity', nil, min: 1 # => <input id=\"quantity\" name=\"quantity\" min=\"1\" type=\"number\" />  number_field_tag 'quantity', nil, max: 9 # => <input id=\"quantity\" name=\"quantity\" max=\"9\" type=\"number\" />  number_field_tag 'quantity', nil, in: 1...10 # => <input id=\"quantity\" name=\"quantity\" min=\"1\" max=\"9\" type=\"number\" />  number_field_tag 'quantity', nil, within: 1...10 # => <input id=\"quantity\" name=\"quantity\" min=\"1\" max=\"9\" type=\"number\" />  number_field_tag 'quantity', nil, min: 1, max: 10 # => <input id=\"quantity\" name=\"quantity\" min=\"1\" max=\"10\" type=\"number\" />  number_field_tag 'quantity', nil, min: 1, max: 10, step: 2 # => <input id=\"quantity\" name=\"quantity\" min=\"1\" max=\"10\" step=\"2\" type=\"number\" />  number_field_tag 'quantity', '1', class: 'special_input', disabled: true # => <input disabled=\"disabled\" class=\"special_input\" id=\"quantity\" name=\"quantity\" type=\"number\" value=\"1\" />",
    "label": "",
    "id": "920"
  },
  {
    "raw_code": "def range_field_tag(name, value = nil, options = {})\n        number_field_tag(name, value, options.merge(type: :range))\n      end",
    "comment": "Creates a range form element.  ==== Options  Supports the same options as #number_field_tag.  ==== Examples  range_field_tag 'quantity', '1' # => <input id=\"quantity\" name=\"quantity\" type=\"range\" value=\"1\" />  range_field_tag 'quantity', in: 1...10 # => <input id=\"quantity\" name=\"quantity\" min=\"1\" max=\"9\" type=\"range\" />  range_field_tag 'quantity', min: 1, max: 10, step: 2 # => <input id=\"quantity\" name=\"quantity\" min=\"1\" max=\"10\" step=\"2\" type=\"range\"",
    "label": "",
    "id": "921"
  },
  {
    "raw_code": "def utf8_enforcer_tag\n        options = {\n          type: \"hidden\",\n          name: \"utf8\",\n          value: \"&#x2713;\".html_safe\n        }\n\n        options[:autocomplete] = \"off\" unless ActionView::Base.remove_hidden_field_autocomplete\n\n        tag(:input, options)\n      end",
    "comment": "Creates the hidden UTF-8 enforcer tag. Override this method in a helper to customize the tag.",
    "label": "",
    "id": "922"
  },
  {
    "raw_code": "def sanitize_to_id(name)\n          name.to_s.delete(\"]\").tr(\"^-a-zA-Z0-9:.\", \"_\")\n        end",
    "comment": "see http://www.w3.org/TR/html4/types.html#type-name",
    "label": "",
    "id": "923"
  },
  {
    "raw_code": "def escape_javascript(javascript)\n        javascript = javascript.to_s\n        if javascript.empty?\n          result = \"\"\n        else\n          result = javascript.gsub(/(\\\\|<\\/|\\r\\n|\\342\\200\\250|\\342\\200\\251|[\\n\\r\"']|[`]|[$])/u, JS_ESCAPE_MAP)\n        end",
    "comment": "Escapes carriage returns and single and double quotes for JavaScript segments.  Also available through the alias j(). This is particularly helpful in JavaScript responses, like:  $('some_element').replaceWith('<%= j render 'some/element_template' %>');",
    "label": "",
    "id": "924"
  },
  {
    "raw_code": "def javascript_tag(content_or_options_with_block = nil, html_options = {}, &block)\n        content =\n          if block_given?\n            html_options = content_or_options_with_block if content_or_options_with_block.is_a?(Hash)\n            capture(&block)\n          else\n            content_or_options_with_block\n          end",
    "comment": "Returns a JavaScript tag with the +content+ inside. Example: javascript_tag \"alert('All is good')\"  Returns: <script> //<![CDATA[ alert('All is good') //]]> </script>  +html_options+ may be a hash of attributes for the <tt>\\<script></tt> tag.  javascript_tag \"alert('All is good')\", type: 'application/javascript'  Returns: <script type=\"application/javascript\"> //<![CDATA[ alert('All is good') //]]> </script>  Instead of passing the content as an argument, you can also use a block in which case, you pass your +html_options+ as the first parameter.  <%= javascript_tag type: 'application/javascript' do -%> alert('All is good') <% end -%>  If you have a content security policy enabled then you can add an automatic nonce value by passing <tt>nonce: true</tt> as part of +html_options+. Example:  <%= javascript_tag nonce: true do -%> alert('All is good') <% end -%>",
    "label": "",
    "id": "925"
  },
  {
    "raw_code": "def number_to_phone(number, options = {})\n        return unless number\n        options = options.symbolize_keys\n\n        parse_float(number, true) if options.delete(:raise)\n        ERB::Util.html_escape(ActiveSupport::NumberHelper.number_to_phone(number, options))\n      end",
    "comment": "Delegates to ActiveSupport::NumberHelper#number_to_phone.  number_to_phone(\"1234567890\")         # => \"123-456-7890\"  Additionally, supports a +:raise+ option that will cause InvalidNumberError to be raised if +number+ is not a valid number:  number_to_phone(\"12x34\")              # => \"12x34\" number_to_phone(\"12x34\", raise: true) # => InvalidNumberError ",
    "label": "",
    "id": "926"
  },
  {
    "raw_code": "def number_to_currency(number, options = {})\n        delegate_number_helper_method(:number_to_currency, number, options)\n      end",
    "comment": "Delegates to ActiveSupport::NumberHelper#number_to_currency.  number_to_currency(\"1234\")               # => \"$1234.00\"  Additionally, supports a +:raise+ option that will cause InvalidNumberError to be raised if +number+ is not a valid number:  number_to_currency(\"12x34\")              # => \"$12x34\" number_to_currency(\"12x34\", raise: true) # => InvalidNumberError ",
    "label": "",
    "id": "927"
  },
  {
    "raw_code": "def number_to_percentage(number, options = {})\n        delegate_number_helper_method(:number_to_percentage, number, options)\n      end",
    "comment": "Delegates to ActiveSupport::NumberHelper#number_to_percentage.  number_to_percentage(\"99\")               # => \"99.000%\"  Additionally, supports a +:raise+ option that will cause InvalidNumberError to be raised if +number+ is not a valid number:  number_to_percentage(\"99x\")              # => \"99x%\" number_to_percentage(\"99x\", raise: true) # => InvalidNumberError ",
    "label": "",
    "id": "928"
  },
  {
    "raw_code": "def number_with_delimiter(number, options = {})\n        delegate_number_helper_method(:number_to_delimited, number, options)\n      end",
    "comment": "Delegates to ActiveSupport::NumberHelper#number_to_delimited.  number_with_delimiter(\"1234\")               # => \"1,234\"  Additionally, supports a +:raise+ option that will cause InvalidNumberError to be raised if +number+ is not a valid number:  number_with_delimiter(\"12x34\")              # => \"12x34\" number_with_delimiter(\"12x34\", raise: true) # => InvalidNumberError ",
    "label": "",
    "id": "929"
  },
  {
    "raw_code": "def number_with_precision(number, options = {})\n        delegate_number_helper_method(:number_to_rounded, number, options)\n      end",
    "comment": "Delegates to ActiveSupport::NumberHelper#number_to_rounded.  number_with_precision(\"1234\")               # => \"1234.000\"  Additionally, supports a +:raise+ option that will cause InvalidNumberError to be raised if +number+ is not a valid number:  number_with_precision(\"12x34\")              # => \"12x34\" number_with_precision(\"12x34\", raise: true) # => InvalidNumberError ",
    "label": "",
    "id": "930"
  },
  {
    "raw_code": "def number_to_human_size(number, options = {})\n        delegate_number_helper_method(:number_to_human_size, number, options)\n      end",
    "comment": "Delegates to ActiveSupport::NumberHelper#number_to_human_size.  number_to_human_size(\"1234\")               # => \"1.21 KB\"  Additionally, supports a +:raise+ option that will cause InvalidNumberError to be raised if +number+ is not a valid number:  number_to_human_size(\"12x34\")              # => \"12x34\" number_to_human_size(\"12x34\", raise: true) # => InvalidNumberError ",
    "label": "",
    "id": "931"
  },
  {
    "raw_code": "def number_to_human(number, options = {})\n        delegate_number_helper_method(:number_to_human, number, options)\n      end",
    "comment": "Delegates to ActiveSupport::NumberHelper#number_to_human.  number_to_human(\"1234\")               # => \"1.23 Thousand\"  Additionally, supports a +:raise+ option that will cause InvalidNumberError to be raised if +number+ is not a valid number:  number_to_human(\"12x34\")              # => \"12x34\" number_to_human(\"12x34\", raise: true) # => InvalidNumberError ",
    "label": "",
    "id": "932"
  },
  {
    "raw_code": "def raw(stringish)\n        stringish.to_s.html_safe\n      end",
    "comment": "This method outputs without escaping a string. Since escaping tags is now default, this can be used when you don't want \\Rails to automatically escape tags. This is not recommended if the data is coming from the user's input.  For example:  raw @user.name # => 'Jimmy <alert>Tables</alert>'",
    "label": "",
    "id": "933"
  },
  {
    "raw_code": "def safe_join(array, sep = $,)\n        sep = ERB::Util.unwrapped_html_escape(sep)\n\n        array.flatten.map! { |i| ERB::Util.unwrapped_html_escape(i) }.join(sep).html_safe\n      end",
    "comment": "This method returns an HTML safe string similar to what <tt>Array#join</tt> would return. The array is flattened, and all items, including the supplied separator, are HTML escaped unless they are HTML safe, and the returned string is marked as HTML safe.  safe_join([tag.p(\"foo\"), \"<p>bar</p>\"], \"<br>\") # => \"<p>foo</p>&lt;br&gt;&lt;p&gt;bar&lt;/p&gt;\"  safe_join([tag.p(\"foo\"), tag.p(\"bar\")], tag.br) # => \"<p>foo</p><br><p>bar</p>\" ",
    "label": "",
    "id": "934"
  },
  {
    "raw_code": "def to_sentence(array, options = {})\n        options.assert_valid_keys(:words_connector, :two_words_connector, :last_word_connector, :locale)\n\n        default_connectors = {\n          words_connector: \", \",\n          two_words_connector: \" and \",\n          last_word_connector: \", and \"\n        }\n        if defined?(I18n)\n          i18n_connectors = I18n.translate(:'support.array', locale: options[:locale], default: {})\n          default_connectors.merge!(i18n_connectors)\n        end",
    "comment": "Converts the array to a comma-separated sentence where the last element is joined by the connector word. This is the html_safe-aware version of ActiveSupport's Array#to_sentence.",
    "label": "",
    "id": "935"
  },
  {
    "raw_code": "def render(options = {}, locals = {}, &block)\n        case options\n        when Hash\n          in_rendering_context(options) do |renderer|\n            if block_given?\n              view_renderer.render_partial(self, options.merge(partial: options[:layout]), &block)\n            else\n              view_renderer.render(self, options)\n            end",
    "comment": "Renders a template and returns the result.  Pass the template to render as the first argument. This is shorthand syntax for partial rendering, so the template filename should be prefixed with an underscore. The partial renderer looks for the partial template in the directory of the calling template first.  <% # app/views/posts/new.html.erb %> <%= render \"form\" %> # => renders app/views/posts/_form.html.erb  Use the complete view path to render a partial from another directory.  <% # app/views/posts/show.html.erb %> <%= render \"comments/form\" %> # => renders app/views/comments/_form.html.erb  Without the rendering mode, the second argument can be a Hash of local variable assignments for the template.  <% # app/views/posts/new.html.erb %> <%= render \"form\", post: Post.new %> # => renders app/views/posts/_form.html.erb  If the first argument responds to `render_in`, the template will be rendered by calling `render_in` with the current view context.  class Greeting def render_in(view_context) view_context.render html: \"<h1>Hello, World</h1>\" end  def format :html end end  <%= render Greeting.new %> # => \"<h1>Hello, World</h1>\"  #### Rendering Mode  Pass the rendering mode as first argument to override it.  `:partial` :   See ActionView::PartialRenderer for details.  <%= render partial: \"form\", locals: { post: Post.new } %> # => renders app/views/posts/_form.html.erb  `:file` :   Renders the contents of a file. This option should **not** be used with unsanitized user input.  <%= render file: \"/path/to/some/file\" %> # => renders /path/to/some/file  `:inline` :   Renders an ERB template string.  <% name = \"World\" %> <%= render inline: \"<h1>Hello, <%= name %>!</h1>\" %> # => renders \"<h1>Hello, World!</h1>\"  `:body` :   Renders the provided text, and sets the format as `:text`.  <%= render body: \"Hello, World!\" %> # => renders \"Hello, World!\"  `:plain` :   Renders the provided text, and sets the format as `:text`.  <%= render plain: \"Hello, World!\" %> # => renders \"Hello, World!\"  `:html` :   Renders the provided HTML string, and sets the format as `:html`. If the string is not `html_safe?`, performs HTML escaping on the string before rendering.  <%= render html: \"<h1>Hello, World!</h1>\".html_safe %> # => renders \"<h1>Hello, World!</h1>\"  <%= render html: \"<h1>Hello, World!</h1>\" %> # => renders \"&lt;h1&gt;Hello, World!&lt;/h1&gt;\"  `:renderable` :   Renders the provided object by calling `render_in` with the current view context. The format is determined by calling `format` on the renderable if it responds to `format`, falling back to `:html` by default.  <%= render renderable: Greeting.new %> # => renders \"<h1>Hello, World</h1>\"   #### Options  `:locals` :   Hash of local variable assignments for the template.  <%= render inline: \"<h1>Hello, <%= name %>!</h1>\", locals: { name: \"World\" } %> # => renders \"<h1>Hello, World!</h1>\"  `:formats` :   Override the current format to render a template for a different format.  <% # app/views/posts/show.html.erb %> <%= render template: \"posts/content\", formats: [:text] %> # => renders app/views/posts/content.text.erb  `:variants` :   Render a template for a different variant.  <% # app/views/posts/show.html.erb %> <%= render template: \"posts/content\", variants: [:tablet] %> # => renders app/views/posts/content.html+tablet.erb  `:handlers` :   Render a template for a different handler.  <% # app/views/posts/show.html.erb %> <%= render template: \"posts/content\", handlers: [:builder] %> # => renders app/views/posts/content.html.builder",
    "label": "",
    "id": "936"
  },
  {
    "raw_code": "def _layout_for(*args, &block)\n        name = args.first\n\n        if block && !name.is_a?(Symbol)\n          capture(*args, &block)\n        else\n          super\n        end",
    "comment": "Overrides _layout_for in the context object so it supports the case a block is passed to a partial. Returns the contents that are yielded to a layout, given a name or a block.  You can think of a layout as a method that is called with a block. If the user calls `yield :some_name`, the block, by default, returns `content_for(:some_name)`. If the user calls simply `yield`, the default block returns `content_for(:layout)`.  The user can override this default by passing a block to the layout:  # The template <%= render layout: \"my_layout\" do %> Content <% end %>  # The layout <html> <%= yield %> </html>  In this case, instead of the default block, which would return `content_for(:layout)`, this method returns the block that was passed in to `render :layout`, and the response would be  <html> Content </html>  Finally, the block can take block arguments, which can be passed in by `yield`:  # The template <%= render layout: \"my_layout\" do |customer| %> Hello <%= customer.name %> <% end %>  # The layout <html> <%= yield Struct.new(:name).new(\"David\") %> </html>  In this case, the layout would receive the block passed into `render :layout`, and the struct specified would be passed into the block as an argument. The result would be  <html> Hello David </html> ",
    "label": "",
    "id": "937"
  },
  {
    "raw_code": "def sanitize(html, options = {})\n        self.class.safe_list_sanitizer.sanitize(html, options)&.html_safe\n      end",
    "comment": "Sanitizes HTML input, stripping all but known-safe tags and attributes.  It also strips +href+ / +src+ attributes with unsafe protocols like +javascript:+, while also protecting against attempts to use Unicode, ASCII, and hex character references to work around these protocol filters.  The default sanitizer is +Rails::HTML5::SafeListSanitizer+. See {Rails HTML Sanitizers}[https://github.com/rails/rails-html-sanitizer] for more information.  Custom sanitization rules can also be provided.  <b>Warning</b>: Adding disallowed tags or attributes to the allowlists may introduce vulnerabilities into your application. Please rely on the default allowlists whenever possible, because they are curated to maintain security and safety. If you think that the default allowlists should be expanded, please {open an issue on the rails-html-sanitizer project}[https://github.com/rails/rails-html-sanitizer/issues].  Please note that sanitizing user-provided text does not guarantee that the resulting markup is valid or even well-formed.  ==== Options  [+:tags+] An array of allowed tags.  [+:attributes+] An array of allowed attributes.  [+:scrubber+] A {Rails::HTML scrubber}[https://github.com/rails/rails-html-sanitizer] or {Loofah::Scrubber}[https://github.com/flavorjones/loofah] object that defines custom sanitization rules. A custom scrubber takes precedence over custom tags and attributes.  ==== Examples  ===== Normal use  <%= sanitize @comment.body %>  ===== Providing custom lists of permitted tags and attributes  <%= sanitize @comment.body, tags: %w(strong em a), attributes: %w(href) %>  ===== Providing a custom +Rails::HTML+ scrubber  class CommentScrubber < Rails::HTML::PermitScrubber def initialize super self.tags = %w( form script comment blockquote ) self.attributes = %w( style ) end  def skip_node?(node) node.text? end end  <code></code>  <%= sanitize @comment.body, scrubber: CommentScrubber.new %>  See {Rails HTML Sanitizer}[https://github.com/rails/rails-html-sanitizer] for documentation about +Rails::HTML+ scrubbers.  ===== Providing a custom +Loofah::Scrubber+  scrubber = Loofah::Scrubber.new do |node| node.remove if node.name == 'script' end  <code></code>  <%= sanitize @comment.body, scrubber: scrubber %>  See {Loofah's documentation}[https://github.com/flavorjones/loofah] for more information about defining custom +Loofah::Scrubber+ objects.  ==== Global Configuration  To set the default allowed tags or attributes across your application:  # In config/application.rb config.action_view.sanitized_allowed_tags = ['strong', 'em', 'a'] config.action_view.sanitized_allowed_attributes = ['href', 'title']  The default, starting in \\Rails 7.1, is to use an HTML5 parser for sanitization (if it is available, see NOTE below). If you wish to revert back to the previous HTML4 behavior, you can do so by setting the following in your application configuration:  # In config/application.rb config.action_view.sanitizer_vendor = Rails::HTML4::Sanitizer  Or, if you're upgrading from a previous version of \\Rails and wish to opt into the HTML5 behavior:  # In config/application.rb config.action_view.sanitizer_vendor = Rails::HTML5::Sanitizer  NOTE: +Rails::HTML5::Sanitizer+ is not supported on JRuby, so on JRuby platforms \\Rails will fall back to using +Rails::HTML4::Sanitizer+.",
    "label": "",
    "id": "938"
  },
  {
    "raw_code": "def sanitize_css(style)\n        self.class.safe_list_sanitizer.sanitize_css(style)\n      end",
    "comment": "Sanitizes a block of CSS code. Used by #sanitize when it comes across a style attribute.",
    "label": "",
    "id": "939"
  },
  {
    "raw_code": "def strip_tags(html)\n        self.class.full_sanitizer.sanitize(html)&.html_safe\n      end",
    "comment": "Strips all HTML tags from +html+, including comments and special characters.  strip_tags(\"Strip <i>these</i> tags!\") # => Strip these tags!  strip_tags(\"<b>Bold</b> no more!  <a href='more.html'>See more here</a>...\") # => Bold no more!  See more here...  strip_tags(\"<div id='top-bar'>Welcome to my website!</div>\") # => Welcome to my website!  strip_tags(\"> A quote from Smith & Wesson\") # => &gt; A quote from Smith &amp; Wesson",
    "label": "",
    "id": "940"
  },
  {
    "raw_code": "def strip_links(html)\n        self.class.link_sanitizer.sanitize(html)\n      end",
    "comment": "Strips all link tags from +html+ leaving just the link text.  strip_links('<a href=\"http://www.rubyonrails.org\">Ruby on Rails</a>') # => Ruby on Rails  strip_links('Please e-mail me at <a href=\"mailto:me@email.com\">me@email.com</a>.') # => Please e-mail me at me@email.com.  strip_links('Blog: <a href=\"http://www.myblog.com/\" class=\"nav\" target=\\\"_blank\\\">Visit</a>.') # => Blog: Visit.  strip_links('<<a href=\"https://example.org\">malformed & link</a>') # => &lt;malformed &amp; link",
    "label": "",
    "id": "941"
  },
  {
    "raw_code": "def full_sanitizer\n          @full_sanitizer ||= sanitizer_vendor.full_sanitizer.new\n        end",
    "comment": "Gets the Rails::HTML::FullSanitizer instance used by +strip_tags+. Replace with any object that responds to +sanitize+.  class Application < Rails::Application config.action_view.full_sanitizer = MySpecialSanitizer.new end",
    "label": "",
    "id": "942"
  },
  {
    "raw_code": "def link_sanitizer\n          @link_sanitizer ||= sanitizer_vendor.link_sanitizer.new\n        end",
    "comment": "Gets the Rails::HTML::LinkSanitizer instance used by +strip_links+. Replace with any object that responds to +sanitize+.  class Application < Rails::Application config.action_view.link_sanitizer = MySpecialSanitizer.new end",
    "label": "",
    "id": "943"
  },
  {
    "raw_code": "def safe_list_sanitizer\n          @safe_list_sanitizer ||= sanitizer_vendor.safe_list_sanitizer.new\n        end",
    "comment": "Gets the Rails::HTML::SafeListSanitizer instance used by sanitize and +sanitize_css+. Replace with any object that responds to +sanitize+.  class Application < Rails::Application config.action_view.safe_list_sanitizer = MySpecialSanitizer.new end",
    "label": "",
    "id": "944"
  },
  {
    "raw_code": "def attributes(attributes)\n          tag_options(attributes.to_h).to_s.strip.html_safe\n        end",
    "comment": "Transforms a Hash into HTML Attributes, ready to be interpolated into ERB.  <input <%= tag.attributes(type: :text, aria: { label: \"Search\" }) %> > # => <input type=\"text\" aria-label=\"Search\">",
    "label": "",
    "id": "945"
  },
  {
    "raw_code": "def tag(name = nil, options = nil, open = false, escape = true)\n        if name.nil?\n          tag_builder\n        else\n          ensure_valid_html5_tag_name(name)\n          \"<#{name}#{tag_builder.tag_options(options, escape) if options}#{open ? \">\" : \" />\"}\".html_safe\n        end",
    "comment": "Returns an HTML tag.  === Building HTML tags  Builds HTML5 compliant tags with a tag proxy. Every tag can be built with:  tag.<tag name>(optional content, options)  where tag name can be e.g. br, div, section, article, or any tag really.  ==== Passing content  Tags can pass content to embed within it:  tag.h1 'All titles fit to print' # => <h1>All titles fit to print</h1>  tag.div tag.p('Hello world!')  # => <div><p>Hello world!</p></div>  Content can also be captured with a block, which is useful in templates:  <%= tag.p do %> The next great American novel starts here. <% end %> # => <p>The next great American novel starts here.</p>  ==== Options  Use symbol keyed options to add attributes to the generated tag.  tag.section class: %w( kitties puppies ) # => <section class=\"kitties puppies\"></section>  tag.section id: dom_id(@post) # => <section id=\"<generated dom id>\"></section>  Pass +true+ for any attributes that can render with no values, like +disabled+ and +readonly+.  tag.input type: 'text', disabled: true # => <input type=\"text\" disabled=\"disabled\">  HTML5 <tt>data-*</tt> and <tt>aria-*</tt> attributes can be set with a single +data+ or +aria+ key pointing to a hash of sub-attributes.  To play nicely with JavaScript conventions, sub-attributes are dasherized.  tag.article data: { user_id: 123 } # => <article data-user-id=\"123\"></article>  Thus <tt>data-user-id</tt> can be accessed as <tt>dataset.userId</tt>.  Data attribute values are encoded to JSON, with the exception of strings, symbols, and BigDecimals. This may come in handy when using jQuery's HTML5-aware <tt>.data()</tt> from 1.4.3.  tag.div data: { city_state: %w( Chicago IL ) } # => <div data-city-state=\"[&quot;Chicago&quot;,&quot;IL&quot;]\"></div>  The generated tag names and attributes are escaped by default. This can be disabled using +escape+.  tag.img src: 'open & shut.png' # => <img src=\"open &amp; shut.png\">  tag.img src: 'open & shut.png', escape: false # => <img src=\"open & shut.png\">  The tag builder respects {HTML5 void elements}[https://www.w3.org/TR/html5/syntax.html#void-elements] if no content is passed, and omits closing tags for those elements.  # A standard element: tag.div # => <div></div>  # A void element: tag.br  # => <br>  Note that when using the block form options should be wrapped in parenthesis.  <%= tag.a(href: \"/about\", class: \"font-bold\") do %> About the author <% end %> # => <a href=\"/about\" class=\"font-bold\">About the author</a>  === Building HTML attributes  Transforms a Hash into HTML attributes, ready to be interpolated into ERB. Includes or omits boolean attributes based on their truthiness. Transforms keys nested within <tt>aria:</tt> or <tt>data:</tt> objects into <tt>aria-</tt> and <tt>data-</tt> prefixed attributes:  <input <%= tag.attributes(type: :text, aria: { label: \"Search\" }) %>> # => <input type=\"text\" aria-label=\"Search\">  <button <%= tag.attributes id: \"call-to-action\", disabled: false, aria: { expanded: false } %> class=\"primary\">Get Started!</button> # => <button id=\"call-to-action\" aria-expanded=\"false\" class=\"primary\">Get Started!</button>  === Legacy syntax  The following format is for legacy syntax support. It will be deprecated in future versions of \\Rails.  tag(name, options = nil, open = false, escape = true)  It returns an empty HTML tag of type +name+ which by default is XHTML compliant. Set +open+ to true to create an open tag compatible with HTML 4.0 and below. Add HTML attributes by passing an attributes hash to +options+. Set +escape+ to false to disable attribute value escaping.  ==== Options  You can use symbols or strings for the attribute names.  Use +true+ with boolean attributes that can render with no value, like +disabled+ and +readonly+.  HTML5 <tt>data-*</tt> attributes can be set with a single +data+ key pointing to a hash of sub-attributes.  ==== Examples  tag(\"br\") # => <br />  tag(\"br\", nil, true) # => <br>  tag(\"input\", type: 'text', disabled: true) # => <input type=\"text\" disabled=\"disabled\" />  tag(\"input\", type: 'text', class: [\"strong\", \"highlight\"]) # => <input class=\"strong highlight\" type=\"text\" />  tag(\"img\", src: \"open & shut.png\") # => <img src=\"open &amp; shut.png\" />  tag(\"img\", { src: \"open &amp; shut.png\" }, false, false) # => <img src=\"open &amp; shut.png\" />  tag(\"div\", data: { name: 'Stephen', city_state: %w(Chicago IL) }) # => <div data-name=\"Stephen\" data-city-state=\"[&quot;Chicago&quot;,&quot;IL&quot;]\" />  tag(\"div\", class: { highlight: current_user.admin? }) # => <div class=\"highlight\" />",
    "label": "",
    "id": "946"
  },
  {
    "raw_code": "def content_tag(name, content_or_options_with_block = nil, options = nil, escape = true, &block)\n        ensure_valid_html5_tag_name(name)\n\n        if block_given?\n          options = content_or_options_with_block if content_or_options_with_block.is_a?(Hash)\n          tag_builder.content_tag_string(name, capture(&block), options, escape)\n        else\n          tag_builder.content_tag_string(name, content_or_options_with_block, options, escape)\n        end",
    "comment": "Returns an HTML block tag of type +name+ surrounding the +content+. Add HTML attributes by passing an attributes hash to +options+. Instead of passing the content as an argument, you can also use a block in which case, you pass your +options+ as the second parameter. Set escape to false to disable escaping. Note: this is legacy syntax, see +tag+ method description for details.  ==== Options The +options+ hash can be used with attributes with no value like (<tt>disabled</tt> and <tt>readonly</tt>), which you can give a value of true in the +options+ hash. You can use symbols or strings for the attribute names.  ==== Examples content_tag(:p, \"Hello world!\") # => <p>Hello world!</p> content_tag(:div, content_tag(:p, \"Hello world!\"), class: \"strong\") # => <div class=\"strong\"><p>Hello world!</p></div> content_tag(:div, \"Hello world!\", class: [\"strong\", \"highlight\"]) # => <div class=\"strong highlight\">Hello world!</div> content_tag(:div, \"Hello world!\", class: [\"strong\", { highlight: current_user.admin? }]) # => <div class=\"strong highlight\">Hello world!</div> content_tag(\"select\", options, multiple: true) # => <select multiple=\"multiple\">...options...</select>  <%= content_tag :div, class: \"strong\" do -%> Hello world! <% end -%> # => <div class=\"strong\">Hello world!</div>",
    "label": "",
    "id": "947"
  },
  {
    "raw_code": "def token_list(*args)\n        tokens = build_tag_values(*args).flat_map { |value| CGI.unescape_html(value.to_s).split(/\\s+/) }.uniq\n\n        safe_join(tokens, \" \")\n      end",
    "comment": "Returns a string of tokens built from +args+.  ==== Examples token_list(\"foo\", \"bar\") # => \"foo bar\" token_list(\"foo\", \"foo bar\") # => \"foo bar\" token_list({ foo: true, bar: false }) # => \"foo\" token_list(nil, false, 123, \"\", \"foo\", { bar: true }) # => \"123 foo bar\"",
    "label": "",
    "id": "948"
  },
  {
    "raw_code": "def cdata_section(content)\n        splitted = content.to_s.gsub(/\\]\\]>/, \"]]]]><![CDATA[>\")\n        \"<![CDATA[#{splitted}]]>\".html_safe\n      end",
    "comment": "Returns a CDATA section with the given +content+. CDATA sections are used to escape blocks of text containing characters which would otherwise be recognized as markup. CDATA sections begin with the string <tt><![CDATA[</tt> and end with (and may not contain) the string <tt>]]></tt>.  cdata_section(\"<hello world>\") # => <![CDATA[<hello world>]]>  cdata_section(File.read(\"hello_world.txt\")) # => <![CDATA[<hello from a text file]]>  cdata_section(\"hello]]>world\") # => <![CDATA[hello]]]]><![CDATA[>world]]>",
    "label": "",
    "id": "949"
  },
  {
    "raw_code": "def escape_once(html)\n        ERB::Util.html_escape_once(html)\n      end",
    "comment": "Returns an escaped version of +html+ without affecting existing escaped entities.  escape_once(\"1 < 2 &amp; 3\") # => \"1 &lt; 2 &amp; 3\"  escape_once(\"&lt;&lt; Accept & Checkout\") # => \"&lt;&lt; Accept &amp; Checkout\"",
    "label": "",
    "id": "950"
  },
  {
    "raw_code": "def concat(string)\n        output_buffer << string\n      end",
    "comment": "The preferred method of outputting text in your views is to use the <tt><%= \"text\" %></tt> eRuby syntax. The regular +puts+ and +print+ methods do not operate as expected in an eRuby code block. If you absolutely must output text within a non-output code block (i.e., <tt><% %></tt>), you can use the +concat+ method.  <% concat \"hello\" %> is equivalent to <%= \"hello\" %>  <% unless signed_in? concat link_to(\"Sign In\", action: :sign_in) end %>  is equivalent to  <% unless signed_in? %> <%= link_to \"Sign In\", action: :sign_in %> <% end %> ",
    "label": "",
    "id": "951"
  },
  {
    "raw_code": "def truncate(text, options = {}, &block)\n        if text\n          length  = options.fetch(:length, 30)\n\n          content = text.truncate(length, options)\n          content = options[:escape] == false ? content.html_safe : ERB::Util.html_escape(content)\n          content << capture(&block) if block_given? && text.length > length\n          content\n        end",
    "comment": "Truncates +text+ if it is longer than a specified +:length+. If +text+ is truncated, an omission marker will be appended to the result for a total length not exceeding +:length+.  You can also pass a block to render and append extra content after the omission marker when +text+ is truncated. However, this content _can_ cause the total length to exceed +:length+ characters.  The result will be escaped unless <tt>escape: false</tt> is specified. In any case, the result will be marked HTML-safe. Care should be taken if +text+ might contain HTML tags or entities, because truncation could produce invalid HTML, such as unbalanced or incomplete tags.  ==== Options  [+:length+] The maximum number of characters that should be returned, excluding any extra content from the block. Defaults to 30.  [+:omission+] The string to append after truncating. Defaults to  <tt>\"...\"</tt>.  [+:separator+] A string or regexp used to find a breaking point at which to truncate. By default, truncation can occur at any character in +text+.  [+:escape+] Whether to escape the result. Defaults to true.  ==== Examples  truncate(\"Once upon a time in a world far far away\") # => \"Once upon a time in a world...\"  truncate(\"Once upon a time in a world far far away\", length: 17) # => \"Once upon a ti...\"  truncate(\"Once upon a time in a world far far away\", length: 17, separator: ' ') # => \"Once upon a...\"  truncate(\"And they found that many people were sleeping better.\", length: 25, omission: '... (continued)') # => \"And they f... (continued)\"  truncate(\"<p>Once upon a time in a world far far away</p>\") # => \"&lt;p&gt;Once upon a time in a wo...\"  truncate(\"<p>Once upon a time in a world far far away</p>\", escape: false) # => \"<p>Once upon a time in a wo...\"  truncate(\"Once upon a time in a world far far away\") { link_to \"Continue\", \"#\" } # => \"Once upon a time in a world...<a href=\\\"#\\\">Continue</a>\"",
    "label": "",
    "id": "952"
  },
  {
    "raw_code": "def highlight(text, phrases, options = {}, &block)\n        text = sanitize(text) if options.fetch(:sanitize, true)\n\n        if text.blank? || phrases.blank?\n          text || \"\"\n        else\n          patterns = Array(phrases).map { |phrase| Regexp === phrase ? phrase : Regexp.escape(phrase) }\n          pattern = /(#{patterns.join(\"|\")})/i\n          highlighter = options.fetch(:highlighter, '<mark>\\1</mark>') unless block\n\n          text.scan(/<[^>]*|[^<]+/).each do |segment|\n            if !segment.start_with?(\"<\")\n              if block\n                segment.gsub!(pattern, &block)\n              else\n                segment.gsub!(pattern, highlighter)\n              end",
    "comment": "Highlights occurrences of +phrases+ in +text+ by formatting them with a highlighter string. +phrases+ can be one or more strings or regular expressions. The result will be marked HTML safe. By default, +text+ is sanitized before highlighting to prevent possible XSS attacks.  If a block is specified, it will be used instead of the highlighter string. Each occurrence of a phrase will be passed to the block, and its return value will be inserted into the final result.  ==== Options  [+:highlighter+] The highlighter string. Uses <tt>\\1</tt> as the placeholder for a phrase, similar to +String#sub+. Defaults to <tt>\"<mark>\\1</mark>\"</tt>. This option is ignored if a block is specified.  [+:sanitize+] Whether to sanitize +text+ before highlighting. Defaults to true.  ==== Examples  highlight('You searched for: rails', 'rails') # => \"You searched for: <mark>rails</mark>\"  highlight('You searched for: rails', /for|rails/) # => \"You searched <mark>for</mark>: <mark>rails</mark>\"  highlight('You searched for: ruby, rails, dhh', 'actionpack') # => \"You searched for: ruby, rails, dhh\"  highlight('You searched for: rails', ['for', 'rails'], highlighter: '<em>\\1</em>') # => \"You searched <em>for</em>: <em>rails</em>\"  highlight('You searched for: rails', 'rails', highlighter: '<a href=\"search?q=\\1\">\\1</a>') # => \"You searched for: <a href=\\\"search?q=rails\\\">rails</a>\"  highlight('You searched for: rails', 'rails') { |match| link_to(search_path(q: match)) } # => \"You searched for: <a href=\\\"search?q=rails\\\">rails</a>\"  highlight('<a href=\"javascript:alert(\\'no!\\')\">ruby</a> on rails', 'rails', sanitize: false) # => \"<a href=\\\"javascript:alert('no!')\\\">ruby</a> on <mark>rails</mark>\"",
    "label": "",
    "id": "953"
  },
  {
    "raw_code": "def excerpt(text, phrase, options = {})\n        return unless text && phrase\n\n        separator = options.fetch(:separator, nil) || \"\"\n        case phrase\n        when Regexp\n          regex = phrase\n        else\n          regex = /#{Regexp.escape(phrase)}/i\n        end",
    "comment": "Extracts the first occurrence of +phrase+ plus surrounding text from +text+. An omission marker is prepended / appended if the start / end of the result does not coincide with the start / end of +text+. The result is always stripped in any case. Returns +nil+ if +phrase+ isn't found.  ==== Options  [+:radius+] The number of characters (or tokens — see +:separator+ option) around +phrase+ to include in the result. Defaults to 100.  [+:omission+] The marker to prepend / append when the start / end of the excerpt does not coincide with the start / end of +text+. Defaults to <tt>\"...\"</tt>.  [+:separator+] The separator between tokens to count for +:radius+. Defaults to <tt>\"\"</tt>, which treats each character as a token.  ==== Examples  excerpt('This is an example', 'an', radius: 5) # => \"...s is an exam...\"  excerpt('This is an example', 'is', radius: 5) # => \"This is a...\"  excerpt('This is an example', 'is') # => \"This is an example\"  excerpt('This next thing is an example', 'ex', radius: 2) # => \"...next...\"  excerpt('This is also an example', 'an', radius: 8, omission: '<chop> ') # => \"<chop> is also an example\"  excerpt('This is a very beautiful morning', 'very', separator: ' ', radius: 1) # => \"...a very beautiful...\"",
    "label": "",
    "id": "954"
  },
  {
    "raw_code": "def pluralize(count, singular, plural_arg = nil, plural: plural_arg, locale: I18n.locale)\n        word = if count == 1 || count.to_s.match?(/^1(\\.0+)?$/)\n          singular\n        else\n          plural || singular.pluralize(locale)\n        end",
    "comment": "Attempts to pluralize the +singular+ word unless +count+ is 1. If +plural+ is supplied, it will use that when count is > 1, otherwise it will use the Inflector to determine the plural form for the given locale, which defaults to +I18n.locale+.  The word will be pluralized using rules defined for the locale (you must define your own inflection rules for languages other than English). See ActiveSupport::Inflector.pluralize.  pluralize(1, 'person') # => \"1 person\"  pluralize(2, 'person') # => \"2 people\"  pluralize(3, 'person', plural: 'users') # => \"3 users\"  pluralize(0, 'person') # => \"0 people\"  pluralize(2, 'Person', locale: :de) # => \"2 Personen\"",
    "label": "",
    "id": "955"
  },
  {
    "raw_code": "def word_wrap(text, line_width: 80, break_sequence: \"\\n\")\n        return +\"\" if text.empty?\n\n        # Match up to `line_width` characters, followed by one of\n        #   (1) non-newline whitespace plus an optional newline\n        #   (2) the end of the string, ignoring any trailing newlines\n        #   (3) a newline\n        #\n        # -OR-\n        #\n        # Match an empty line\n        pattern = /(.{1,#{line_width}})(?:[^\\S\\n]+\\n?|\\n*\\Z|\\n)|\\n/\n\n        text.gsub(pattern, \"\\\\1#{break_sequence}\").chomp!(break_sequence)\n      end",
    "comment": "Wraps the +text+ into lines no longer than +line_width+ width. This method breaks on the first whitespace character that does not exceed +line_width+ (which is 80 by default).  word_wrap('Once upon a time') # => \"Once upon a time\"  word_wrap('Once upon a time, in a kingdom called Far Far Away, a king fell ill, and finding a successor to the throne turned out to be more trouble than anyone could have imagined...') # => \"Once upon a time, in a kingdom called Far Far Away, a king fell ill, and finding\\na successor to the throne turned out to be more trouble than anyone could have\\nimagined...\"  word_wrap('Once upon a time', line_width: 8) # => \"Once\\nupon a\\ntime\"  word_wrap('Once upon a time', line_width: 1) # => \"Once\\nupon\\na\\ntime\"  You can also specify a custom +break_sequence+ (\"\\n\" by default):  word_wrap('Once upon a time', line_width: 1, break_sequence: \"\\r\\n\") # => \"Once\\r\\nupon\\r\\na\\r\\ntime\"",
    "label": "",
    "id": "956"
  },
  {
    "raw_code": "def simple_format(text, html_options = {}, options = {})\n        wrapper_tag = options[:wrapper_tag] || \"p\"\n\n        text = sanitize(text, options.fetch(:sanitize_options, {})) if options.fetch(:sanitize, true)\n        paragraphs = split_paragraphs(text)\n\n        if paragraphs.empty?\n          content_tag(wrapper_tag, nil, html_options)\n        else\n          paragraphs.map! { |paragraph|\n            content_tag(wrapper_tag, raw(paragraph), html_options)\n          }.join(\"\\n\\n\").html_safe\n        end",
    "comment": "Returns +text+ transformed into HTML using simple formatting rules. Two or more consecutive newlines (<tt>\\n\\n</tt> or <tt>\\r\\n\\r\\n</tt>) are considered a paragraph and wrapped in <tt><p></tt> tags. One newline (<tt>\\n</tt> or <tt>\\r\\n</tt>) is considered a linebreak and a <tt><br /></tt> tag is appended. This method does not remove the newlines from the +text+.  You can pass any HTML attributes into <tt>html_options</tt>. These will be added to all created paragraphs.  ==== Options * <tt>:sanitize</tt> - If +false+, does not sanitize +text+. * <tt>:sanitize_options</tt> - Any extra options you want appended to the sanitize. * <tt>:wrapper_tag</tt> - String representing the wrapper tag, defaults to <tt>\"p\"</tt>.  ==== Examples my_text = \"Here is some basic text...\\n...with a line break.\"  simple_format(my_text) # => \"<p>Here is some basic text...\\n<br />...with a line break.</p>\"  simple_format(my_text, {}, wrapper_tag: \"div\") # => \"<div>Here is some basic text...\\n<br />...with a line break.</div>\"  more_text = \"We want to put a paragraph...\\n\\n...right there.\"  simple_format(more_text) # => \"<p>We want to put a paragraph...</p>\\n\\n<p>...right there.</p>\"  simple_format(\"Look ma! A class!\", class: 'description') # => \"<p class='description'>Look ma! A class!</p>\"  simple_format(\"<blink>Unblinkable.</blink>\") # => \"<p>Unblinkable.</p>\"  simple_format(\"<blink>Blinkable!</blink> It's true.\", {}, sanitize: false) # => \"<p><blink>Blinkable!</blink> It's true.</p>\"  simple_format(\"<a target=\\\"_blank\\\" href=\\\"http://example.com\\\">Continue</a>\", {}, { sanitize_options: { attributes: %w[target href] } }) # => \"<p><a target=\\\"_blank\\\" href=\\\"http://example.com\\\">Continue</a></p>\"",
    "label": "",
    "id": "957"
  },
  {
    "raw_code": "def cycle(first_value, *values)\n        options = values.extract_options!\n        name = options.fetch(:name, \"default\")\n\n        values.unshift(*first_value)\n\n        cycle = get_cycle(name)\n        unless cycle && cycle.values == values\n          cycle = set_cycle(name, Cycle.new(*values))\n        end",
    "comment": "Creates a Cycle object whose +to_s+ method cycles through elements of an array every time it is called. This can be used for example, to alternate classes for table rows. You can use named cycles to allow nesting in loops. Passing a Hash as the last parameter with a <tt>:name</tt> key will create a named cycle. The default name for a cycle without a +:name+ key is <tt>\"default\"</tt>. You can manually reset a cycle by calling reset_cycle and passing the name of the cycle. The current cycle string can be obtained anytime using the current_cycle method.  <%# Alternate CSS classes for even and odd numbers... %> <% @items = [1,2,3,4] %> <table> <% @items.each do |item| %> <tr class=\"<%= cycle(\"odd\", \"even\") -%>\"> <td><%= item %></td> </tr> <% end %> </table>   <%# Cycle CSS classes for rows, and text colors for values within each row %> <% @items = [ { first: \"Robert\", middle: \"Daniel\", last: \"James\" }, { first: \"Emily\", middle: \"Shannon\", maiden: \"Pike\", last: \"Hicks\" }, { first: \"June\", middle: \"Dae\", last: \"Jones\" }, ] %> <% @items.each do |item| %> <tr class=\"<%= cycle(\"odd\", \"even\", name: \"row_class\") -%>\"> <td> <% item.values.each do |value| %> <%# Create a named cycle \"colors\" %> <span style=\"color:<%= cycle(\"red\", \"green\", \"blue\", name: \"colors\") -%>\"> <%= value %> </span> <% end %> <% reset_cycle(\"colors\") %> </td> </tr> <% end %>",
    "label": "",
    "id": "958"
  },
  {
    "raw_code": "def current_cycle(name = \"default\")\n        cycle = get_cycle(name)\n        cycle.current_value if cycle\n      end",
    "comment": "Returns the current cycle string after a cycle has been started. Useful for complex table highlighting or any other design need which requires the current cycle string in more than one place.  <%# Alternate background colors %> <% @items = [1,2,3,4] %> <% @items.each do |item| %> <div style=\"background-color:<%= cycle(\"red\",\"white\",\"blue\") %>\"> <span style=\"background-color:<%= current_cycle %>\"><%= item %></span> </div> <% end %>",
    "label": "",
    "id": "959"
  },
  {
    "raw_code": "def reset_cycle(name = \"default\")\n        cycle = get_cycle(name)\n        cycle.reset if cycle\n      end",
    "comment": "Resets a cycle so that it starts from the first element the next time it is called. Pass in +name+ to reset a named cycle.  <%# Alternate CSS classes for even and odd numbers... %> <% @items = [[1,2,3,4], [5,6,3], [3,4,5,6,7,4]] %> <table> <% @items.each do |item| %> <tr class=\"<%= cycle(\"even\", \"odd\") -%>\"> <% item.each do |value| %> <span style=\"color:<%= cycle(\"#333\", \"#666\", \"#999\", name: \"colors\") -%>\"> <%= value %> </span> <% end %>  <% reset_cycle(\"colors\") %> </tr> <% end %> </table>",
    "label": "",
    "id": "960"
  },
  {
    "raw_code": "def get_cycle(name)\n          @_cycles = Hash.new unless defined?(@_cycles)\n          @_cycles[name]\n        end",
    "comment": "The cycle helpers need to store the cycles in a place that is guaranteed to be reset every time a page is rendered, so it uses an instance variable of ActionView::Base.",
    "label": "",
    "id": "961"
  },
  {
    "raw_code": "def translate(key, **options)\n        return key.map { |k| translate(k, **options) } if key.is_a?(Array)\n        key = key&.to_s unless key.is_a?(Symbol)\n\n        alternatives = if options.key?(:default)\n          options[:default].is_a?(Array) ? options.delete(:default).compact : [options.delete(:default)]\n        end",
    "comment": "Delegates to <tt>I18n#translate</tt> but also performs three additional functions.  First, it will ensure that any thrown +MissingTranslation+ messages will be rendered as inline spans that:  * Have a <tt>translation-missing</tt> class applied * Contain the missing key as the value of the +title+ attribute * Have a titleized version of the last key segment as text  For example, the value returned for the missing translation key <tt>\"blog.post.title\"</tt> will be:  <span class=\"translation_missing\" title=\"translation missing: en.blog.post.title\">Title</span>  This allows for views to display rather reasonable strings while still giving developers a way to find missing translations.  If you would prefer missing translations to raise an error, you can opt out of span-wrapping behavior globally by setting <tt>config.i18n.raise_on_missing_translations = true</tt> or individually by passing <tt>raise: true</tt> as an option to <tt>translate</tt>.  Second, if the key starts with a period <tt>translate</tt> will scope the key by the current partial. Calling <tt>translate(\".foo\")</tt> from the <tt>people/index.html.erb</tt> template is equivalent to calling <tt>translate(\"people.index.foo\")</tt>. This makes it less repetitive to translate many keys within the same partial and provides a convention to scope keys consistently.  Third, the translation will be marked as <tt>html_safe</tt> if the key has the suffix \"_html\" or the last element of the key is \"html\". Calling <tt>translate(\"footer_html\")</tt> or <tt>translate(\"footer.html\")</tt> will return an HTML safe string that won't be escaped by other HTML helper methods. This naming convention helps to identify translations that include HTML tags so that you know what kind of output to expect when you call translate in a template and translators know which keys they can provide HTML values for.  To access the translated text along with the fully resolved translation key, <tt>translate</tt> accepts a block:  <%= translate(\".relative_key\") do |translation, resolved_key| %> <span title=\"<%= resolved_key %>\"><%= translation %></span> <% end %>  This enables annotate translated text to be aware of the scope it was resolved against. ",
    "label": "",
    "id": "962"
  },
  {
    "raw_code": "def localize(object, **options)\n        I18n.localize(object, **options)\n      end",
    "comment": "Delegates to <tt>I18n.localize</tt> with no additional functionality.  See https://www.rubydoc.info/gems/i18n/I18n/Backend/Base:localize for more information.",
    "label": "",
    "id": "963"
  },
  {
    "raw_code": "def url_for(options = nil) # :nodoc:\n        case options\n        when String\n          options\n        when :back\n          _back_url\n        else\n          raise ArgumentError, \"arguments passed to url_for can't be handled. Please require \" \\\n                               \"routes or provide your own implementation\"\n        end",
    "comment": "Basic implementation of url_for to allow use helpers without routes existence",
    "label": "",
    "id": "964"
  },
  {
    "raw_code": "def link_to(name = nil, options = nil, html_options = nil, &block)\n        html_options, options, name = options, name, block if block_given?\n        options ||= {}\n\n        html_options = convert_options_to_data_attributes(options, html_options)\n\n        url = url_target(name, options)\n        html_options[\"href\"] ||= url\n\n        content_tag(\"a\", name || url, html_options, &block)\n      end",
    "comment": "Creates an anchor element of the given +name+ using a URL created by the set of +options+. See the valid options in the documentation for +url_for+. It's also possible to pass a \\String instead of an options hash, which generates an anchor element that uses the value of the \\String as the href for the link. Using a <tt>:back</tt> \\Symbol instead of an options hash will generate a link to the referrer (a JavaScript back link will be used in place of a referrer if none exists). If +nil+ is passed as the name the value of the link itself will become the name.  ==== Signatures  link_to(body, url, html_options = {}) # url is a String; you can use URL helpers like # posts_path  link_to(body, url_options = {}, html_options = {}) # url_options, except :method, is passed to url_for  link_to(options = {}, html_options = {}) do # name end  link_to(url, html_options = {}) do # name end  link_to(active_record_model)  ==== Options * <tt>:data</tt> - This option can be used to add custom data attributes.  ==== Examples  Because it relies on +url_for+, +link_to+ supports both older-style controller/action/id arguments and newer RESTful routes. Current \\Rails style favors RESTful routes whenever possible, so base your application on resources and use  link_to \"Profile\", profile_path(@profile) # => <a href=\"/profiles/1\">Profile</a>  or the even pithier  link_to \"Profile\", @profile # => <a href=\"/profiles/1\">Profile</a>  in place of the older more verbose, non-resource-oriented  link_to \"Profile\", controller: \"profiles\", action: \"show\", id: @profile # => <a href=\"/profiles/show/1\">Profile</a>  Similarly,  link_to \"Profiles\", profiles_path # => <a href=\"/profiles\">Profiles</a>  is better than  link_to \"Profiles\", controller: \"profiles\" # => <a href=\"/profiles\">Profiles</a>  When name is +nil+ the href is presented instead  link_to nil, \"http://example.com\" # => <a href=\"http://www.example.com\">http://www.example.com</a>  More concise yet, when +name+ is an Active Record model that defines a +to_s+ method returning a default value or a model instance attribute  link_to @profile # => <a href=\"http://www.example.com/profiles/1\">Eileen</a>  You can use a block as well if your link target is hard to fit into the name parameter. ERB example:  <%= link_to(@profile) do %> <strong><%= @profile.name %></strong> -- <span>Check it out!</span> <% end %> # => <a href=\"/profiles/1\"> <strong>David</strong> -- <span>Check it out!</span> </a>  Classes and ids for CSS are easy to produce:  link_to \"Articles\", articles_path, id: \"news\", class: \"article\" # => <a href=\"/articles\" class=\"article\" id=\"news\">Articles</a>  Be careful when using the older argument style, as an extra literal hash is needed:  link_to \"Articles\", { controller: \"articles\" }, id: \"news\", class: \"article\" # => <a href=\"/articles\" class=\"article\" id=\"news\">Articles</a>  Leaving the hash off gives the wrong link:  link_to \"WRONG!\", controller: \"articles\", id: \"news\", class: \"article\" # => <a href=\"/articles/index/news?class=article\">WRONG!</a>  +link_to+ can also produce links with anchors or query strings:  link_to \"Comment wall\", profile_path(@profile, anchor: \"wall\") # => <a href=\"/profiles/1#wall\">Comment wall</a>  link_to \"Ruby on Rails search\", controller: \"searches\", query: \"ruby on rails\" # => <a href=\"/searches?query=ruby+on+rails\">Ruby on Rails search</a>  link_to \"Nonsense search\", searches_path(foo: \"bar\", baz: \"quux\") # => <a href=\"/searches?foo=bar&baz=quux\">Nonsense search</a>  You can set any link attributes such as <tt>target</tt>, <tt>rel</tt>, <tt>type</tt>:  link_to \"External link\", \"http://www.rubyonrails.org/\", target: \"_blank\", rel: \"nofollow\" # => <a href=\"http://www.rubyonrails.org/\" target=\"_blank\" rel=\"nofollow\">External link</a>  ==== Turbo  Rails 7 ships with Turbo enabled by default. Turbo provides the following +:data+ options:  * <tt>turbo_method: symbol of HTTP verb</tt> - Performs a Turbo link visit with the given HTTP verb. Forms are recommended when performing non-+GET+ requests. Only use <tt>data-turbo-method</tt> where a form is not possible.  * <tt>turbo_confirm: \"question?\"</tt> - Adds a confirmation dialog to the link with the given value.  {Consult the Turbo Handbook for more information on the options above.}[https://turbo.hotwired.dev/handbook/drive#performing-visits-with-a-different-method]  ===== \\Examples  link_to \"Delete profile\", @profile, data: { turbo_method: :delete } # => <a href=\"/profiles/1\" data-turbo-method=\"delete\">Delete profile</a>  link_to \"Visit Other Site\", \"https://rubyonrails.org/\", data: { turbo_confirm: \"Are you sure?\" } # => <a href=\"https://rubyonrails.org/\" data-turbo-confirm=\"Are you sure?\">Visit Other Site</a> ",
    "label": "",
    "id": "965"
  },
  {
    "raw_code": "def button_to(name = nil, options = nil, html_options = nil, &block)\n        html_options, options = options, name if block_given?\n        html_options ||= {}\n        html_options = html_options.stringify_keys\n\n        url =\n          case options\n          when FalseClass then nil\n          else url_for(options)\n          end",
    "comment": "Generates a form containing a single button that submits to the URL created by the set of +options+. This is the safest method to ensure links that cause changes to your data are not triggered by search bots or accelerators.  You can control the form and button behavior with +html_options+. Most values in +html_options+ are passed through to the button element. For example, passing a +:class+ option within +html_options+ will set the class attribute of the button element.  The class attribute of the form element can be set by passing a +:form_class+ option within +html_options+. It defaults to <tt>\"button_to\"</tt> to allow styling of the form and its children.  The form submits a POST request by default if the object is not persisted; conversely, if the object is persisted, it will submit a PATCH request. To specify a different HTTP verb use the +:method+ option within +html_options+.  If the HTML button generated from +button_to+ does not work with your layout, you can consider using the +link_to+ method with the +data-turbo-method+ attribute as described in the +link_to+ documentation.  ==== Options The +options+ hash accepts the same options as +url_for+. To generate a <tt><form></tt> element without an <tt>[action]</tt> attribute, pass <tt>false</tt>:  <%= button_to \"New\", false %> # => \"<form method=\"post\" class=\"button_to\"> #      <button type=\"submit\">New</button> #      <input name=\"authenticity_token\" type=\"hidden\" value=\"10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6\"/> #    </form>\"  Most values in +html_options+ are passed through to the button element, but there are a few special options:  * <tt>:method</tt> - \\Symbol of HTTP verb. Supported verbs are <tt>:post</tt>, <tt>:get</tt>, <tt>:delete</tt>, <tt>:patch</tt>, and <tt>:put</tt>. By default it will be <tt>:post</tt>. * <tt>:disabled</tt> - If set to true, it will generate a disabled button. * <tt>:data</tt> - This option can be used to add custom data attributes. * <tt>:form</tt> - This hash will be form attributes * <tt>:form_class</tt> - This controls the class of the form within which the submit button will be placed * <tt>:params</tt> - \\Hash of parameters to be rendered as hidden fields within the form.  ==== Examples <%= button_to \"New\", action: \"new\" %> # => \"<form method=\"post\" action=\"/controller/new\" class=\"button_to\"> #      <button type=\"submit\">New</button> #      <input name=\"authenticity_token\" type=\"hidden\" value=\"10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6\" autocomplete=\"off\"/> #    </form>\"  <%= button_to \"New\", new_article_path %> # => \"<form method=\"post\" action=\"/articles/new\" class=\"button_to\"> #      <button type=\"submit\">New</button> #      <input name=\"authenticity_token\" type=\"hidden\" value=\"10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6\" autocomplete=\"off\"/> #    </form>\"  <%= button_to \"New\", new_article_path, params: { time: Time.now  } %> # => \"<form method=\"post\" action=\"/articles/new\" class=\"button_to\"> #      <button type=\"submit\">New</button> #      <input name=\"authenticity_token\" type=\"hidden\" value=\"10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6\"/> #      <input type=\"hidden\" name=\"time\" value=\"2021-04-08 14:06:09 -0500\" autocomplete=\"off\"> #    </form>\"  <%= button_to [:make_happy, @user] do %> Make happy <strong><%= @user.name %></strong> <% end %> # => \"<form method=\"post\" action=\"/users/1/make_happy\" class=\"button_to\"> #      <button type=\"submit\"> #        Make happy <strong><%= @user.name %></strong> #      </button> #      <input name=\"authenticity_token\" type=\"hidden\" value=\"10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6\"  autocomplete=\"off\"/> #    </form>\"  <%= button_to \"New\", { action: \"new\" }, form_class: \"new-thing\" %> # => \"<form method=\"post\" action=\"/controller/new\" class=\"new-thing\"> #      <button type=\"submit\">New</button> #      <input name=\"authenticity_token\" type=\"hidden\" value=\"10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6\"  autocomplete=\"off\"/> #    </form>\"  <%= button_to \"Create\", { action: \"create\" }, form: { \"data-type\" => \"json\" } %> # => \"<form method=\"post\" action=\"/images/create\" class=\"button_to\" data-type=\"json\"> #      <button type=\"submit\">Create</button> #      <input name=\"authenticity_token\" type=\"hidden\" value=\"10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6\"  autocomplete=\"off\"/> #    </form>\" ",
    "label": "",
    "id": "966"
  },
  {
    "raw_code": "def link_to_unless_current(name, options = {}, html_options = {}, &block)\n        link_to_unless current_page?(options), name, options, html_options, &block\n      end",
    "comment": "Creates a link tag of the given +name+ using a URL created by the set of +options+ unless the current request URI is the same as the links, in which case only the name is returned (or the given block is yielded, if one exists). You can give +link_to_unless_current+ a block which will specialize the default behavior (e.g., show a \"Start Here\" link rather than the link's text).  ==== Examples Let's say you have a navigation menu...  <ul id=\"navbar\"> <li><%= link_to_unless_current(\"Home\", { action: \"index\" }) %></li> <li><%= link_to_unless_current(\"About Us\", { action: \"about\" }) %></li> </ul>  If in the \"about\" action, it will render...  <ul id=\"navbar\"> <li><a href=\"/controller/index\">Home</a></li> <li>About Us</li> </ul>  ...but if in the \"index\" action, it will render:  <ul id=\"navbar\"> <li>Home</li> <li><a href=\"/controller/about\">About Us</a></li> </ul>  The implicit block given to +link_to_unless_current+ is evaluated if the current action is the action given. So, if we had a comments page and wanted to render a \"Go Back\" link instead of a link to the comments page, we could do something like this...  <%= link_to_unless_current(\"Comment\", { controller: \"comments\", action: \"new\" }) do link_to(\"Go back\", { controller: \"posts\", action: \"index\" }) end %>",
    "label": "",
    "id": "967"
  },
  {
    "raw_code": "def link_to_unless(condition, name, options = {}, html_options = {}, &block)\n        link_to_if !condition, name, options, html_options, &block\n      end",
    "comment": "Creates a link tag of the given +name+ using a URL created by the set of +options+ unless +condition+ is true, in which case only the name is returned. To specialize the default behavior (i.e., show a login link rather than just the plaintext link text), you can pass a block that accepts the name or the full argument list for +link_to_unless+.  ==== Examples <%= link_to_unless(@current_user.nil?, \"Reply\", { action: \"reply\" }) %> # If the user is logged in... # => <a href=\"/controller/reply/\">Reply</a>  <%= link_to_unless(@current_user.nil?, \"Reply\", { action: \"reply\" }) do |name| link_to(name, { controller: \"accounts\", action: \"signup\" }) end %> # If the user is logged in... # => <a href=\"/controller/reply/\">Reply</a> # If not... # => <a href=\"/accounts/signup\">Reply</a>",
    "label": "",
    "id": "968"
  },
  {
    "raw_code": "def link_to_if(condition, name, options = {}, html_options = {}, &block)\n        if condition\n          link_to(name, options, html_options)\n        else\n          if block_given?\n            block.arity <= 1 ? capture(name, &block) : capture(name, options, html_options, &block)\n          else\n            ERB::Util.html_escape(name)\n          end",
    "comment": "Creates a link tag of the given +name+ using a URL created by the set of +options+ if +condition+ is true, otherwise only the name is returned. To specialize the default behavior, you can pass a block that accepts the name or the full argument list for +link_to_if+.  ==== Examples <%= link_to_if(@current_user.nil?, \"Login\", { controller: \"sessions\", action: \"new\" }) %> # If the user isn't logged in... # => <a href=\"/sessions/new/\">Login</a>  <%= link_to_if(@current_user.nil?, \"Login\", { controller: \"sessions\", action: \"new\" }) do link_to(@current_user.login, { controller: \"accounts\", action: \"show\", id: @current_user }) end %> # If the user isn't logged in... # => <a href=\"/sessions/new/\">Login</a> # If they are logged in... # => <a href=\"/accounts/show/3\">my_username</a>",
    "label": "",
    "id": "969"
  },
  {
    "raw_code": "def mail_to(email_address, name = nil, html_options = {}, &block)\n        html_options, name = name, nil if name.is_a?(Hash)\n        html_options = (html_options || {}).stringify_keys\n\n        extras = %w{ cc bcc body subject reply_to }.map! { |item|\n          option = html_options.delete(item).presence || next\n          \"#{item.dasherize}=#{ERB::Util.url_encode(option)}\"\n        }.compact\n        extras = extras.empty? ? \"\" : \"?\" + extras.join(\"&\")\n\n        encoded_email_address = ERB::Util.url_encode(email_address).gsub(\"%40\", \"@\")\n        html_options[\"href\"] = \"mailto:#{encoded_email_address}#{extras}\"\n\n        content_tag(\"a\", name || email_address, html_options, &block)\n      end",
    "comment": "Creates a mailto link tag to the specified +email_address+, which is also used as the name of the link unless +name+ is specified. Additional HTML attributes for the link can be passed in +html_options+.  +mail_to+ has several methods for customizing the email itself by passing special keys to +html_options+.  ==== Options * <tt>:subject</tt> - Preset the subject line of the email. * <tt>:body</tt> - Preset the body of the email. * <tt>:cc</tt> - Carbon Copy additional recipients on the email. * <tt>:bcc</tt> - Blind Carbon Copy additional recipients on the email. * <tt>:reply_to</tt> - Preset the +Reply-To+ field of the email.  ==== Obfuscation Prior to \\Rails 4.0, +mail_to+ provided options for encoding the address in order to hinder email harvesters.  To take advantage of these options, install the +actionview-encoded_mail_to+ gem.  ==== Examples mail_to \"me@domain.com\" # => <a href=\"mailto:me@domain.com\">me@domain.com</a>  mail_to \"me@domain.com\", \"My email\" # => <a href=\"mailto:me@domain.com\">My email</a>  mail_to \"me@domain.com\", cc: \"ccaddress@domain.com\", subject: \"This is an example email\" # => <a href=\"mailto:me@domain.com?cc=ccaddress@domain.com&subject=This%20is%20an%20example%20email\">me@domain.com</a>  You can use a block as well if your link target is hard to fit into the name parameter. ERB example:  <%= mail_to \"me@domain.com\" do %> <strong>Email me:</strong> <span>me@domain.com</span> <% end %> # => <a href=\"mailto:me@domain.com\"> <strong>Email me:</strong> <span>me@domain.com</span> </a>",
    "label": "",
    "id": "970"
  },
  {
    "raw_code": "def current_page?(options = nil, check_parameters: false, method: :get, **options_as_kwargs)\n        unless request\n          raise \"You cannot use helpers that need to determine the current \" \\\n                \"page unless your view context provides a Request object \" \\\n                \"in a #request method\"\n        end",
    "comment": "True if the current request URI was generated by the given +options+.  ==== Examples Let's say we're in the <tt>http://www.example.com/shop/checkout?order=desc&page=1</tt> action.  current_page?(action: 'process') # => false  current_page?(action: 'checkout') # => true  current_page?(controller: 'library', action: 'checkout') # => false  current_page?(controller: 'shop', action: 'checkout') # => true  current_page?(controller: 'shop', action: 'checkout', order: 'asc') # => false  current_page?(controller: 'shop', action: 'checkout', order: 'desc', page: '1') # => true  current_page?(controller: 'shop', action: 'checkout', order: 'desc', page: '2') # => false  current_page?('http://www.example.com/shop/checkout') # => true  current_page?('http://www.example.com/shop/checkout', check_parameters: true) # => false  current_page?('/shop/checkout') # => true  current_page?('http://www.example.com/shop/checkout?order=desc&page=1') # => true  Different actions may share the same URL path but have a different HTTP method. Let's say we sent a POST to <tt>http://www.example.com/products</tt> and rendered a validation error.  current_page?(controller: 'product', action: 'index') # => false  current_page?(controller: 'product', action: 'create') # => false  current_page?(controller: 'product', action: 'create', method: :post) # => true  current_page?(controller: 'product', action: 'index', method: [:get, :post]) # => true  We can also pass in the symbol arguments instead of strings. ",
    "label": "",
    "id": "971"
  },
  {
    "raw_code": "def sms_to(phone_number, name = nil, html_options = {}, &block)\n        html_options, name = name, nil if name.is_a?(Hash)\n        html_options = (html_options || {}).stringify_keys\n\n        country_code = html_options.delete(\"country_code\").presence\n        country_code = country_code ? \"+#{ERB::Util.url_encode(country_code)}\" : \"\"\n\n        body = html_options.delete(\"body\").presence\n        body = body ? \"?&body=#{ERB::Util.url_encode(body)}\" : \"\"\n\n        encoded_phone_number = ERB::Util.url_encode(phone_number)\n        html_options[\"href\"] = \"sms:#{country_code}#{encoded_phone_number};#{body}\"\n\n        content_tag(\"a\", name || phone_number, html_options, &block)\n      end",
    "comment": "Creates an SMS anchor link tag to the specified +phone_number+. When the link is clicked, the default SMS messaging app is opened ready to send a message to the linked phone number. If the +body+ option is specified, the contents of the message will be preset to +body+.  If +name+ is not specified, +phone_number+ will be used as the name of the link.  A +country_code+ option is supported, which prepends a plus sign and the given country code to the linked phone number. For example, <tt>country_code: \"01\"</tt> will prepend <tt>+01</tt> to the linked phone number.  Additional HTML attributes for the link can be passed via +html_options+.  ==== Options * <tt>:country_code</tt> - Prepend the country code to the phone number. * <tt>:body</tt> - Preset the body of the message.  ==== Examples sms_to \"5155555785\" # => <a href=\"sms:5155555785;\">5155555785</a>  sms_to \"5155555785\", country_code: \"01\" # => <a href=\"sms:+015155555785;\">5155555785</a>  sms_to \"5155555785\", \"Text me\" # => <a href=\"sms:5155555785;\">Text me</a>  sms_to \"5155555785\", body: \"I have a question about your product.\" # => <a href=\"sms:5155555785;?body=I%20have%20a%20question%20about%20your%20product\">5155555785</a>  You can use a block as well if your link target is hard to fit into the name parameter. \\ERB example:  <%= sms_to \"5155555785\" do %> <strong>Text me:</strong> <% end %> # => <a href=\"sms:5155555785;\"> <strong>Text me:</strong> </a>",
    "label": "",
    "id": "972"
  },
  {
    "raw_code": "def phone_to(phone_number, name = nil, html_options = {}, &block)\n        html_options, name = name, nil if name.is_a?(Hash)\n        html_options = (html_options || {}).stringify_keys\n\n        country_code = html_options.delete(\"country_code\").presence\n        country_code = country_code.nil? ? \"\" : \"+#{ERB::Util.url_encode(country_code)}\"\n\n        encoded_phone_number = ERB::Util.url_encode(phone_number)\n        html_options[\"href\"] = \"tel:#{country_code}#{encoded_phone_number}\"\n\n        content_tag(\"a\", name || phone_number, html_options, &block)\n      end",
    "comment": "Creates a TEL anchor link tag to the specified +phone_number+. When the link is clicked, the default app to make phone calls is opened and prepopulated with the phone number.  If +name+ is not specified, +phone_number+ will be used as the name of the link.  A +country_code+ option is supported, which prepends a plus sign and the given country code to the linked phone number. For example, <tt>country_code: \"01\"</tt> will prepend <tt>+01</tt> to the linked phone number.  Additional HTML attributes for the link can be passed via +html_options+.  ==== Options * <tt>:country_code</tt> - Prepends the country code to the phone number  ==== Examples phone_to \"1234567890\" # => <a href=\"tel:1234567890\">1234567890</a>  phone_to \"1234567890\", \"Phone me\" # => <a href=\"tel:1234567890\">Phone me</a>  phone_to \"1234567890\", country_code: \"01\" # => <a href=\"tel:+011234567890\">1234567890</a>  You can use a block as well if your link target is hard to fit into the name parameter. \\ERB example:  <%= phone_to \"1234567890\" do %> <strong>Phone me:</strong> <% end %> # => <a href=\"tel:1234567890\"> <strong>Phone me:</strong> </a>",
    "label": "",
    "id": "973"
  },
  {
    "raw_code": "def to_form_params(attribute, namespace = nil)\n          attribute = if attribute.respond_to?(:permitted?)\n            attribute.to_h\n          else\n            attribute\n          end",
    "comment": "Returns an array of hashes each containing :name and :value keys suitable for use as the names and values of form input fields:  to_form_params(name: 'David', nationality: 'Danish') # => [{name: 'name', value: 'David'}, {name: 'nationality', value: 'Danish'}]  to_form_params(country: { name: 'Denmark' }) # => [{name: 'country[name]', value: 'Denmark'}]  to_form_params(countries: ['Denmark', 'Sweden']}) # => [{name: 'countries[]', value: 'Denmark'}, {name: 'countries[]', value: 'Sweden'}]  An optional namespace can be passed to enclose key names:  to_form_params({ name: 'Denmark' }, 'country') # => [{name: 'country[name]', value: 'Denmark'}]",
    "label": "",
    "id": "974"
  },
  {
    "raw_code": "def render\n          raise NotImplementedError, \"Subclasses must implement a render method\"\n        end",
    "comment": "This is what child classes implement.",
    "label": "",
    "id": "975"
  },
  {
    "raw_code": "def default_html_options_for_collection(item, value)\n            html_options = @html_options.dup\n\n            [:checked, :selected, :disabled, :readonly].each do |option|\n              current_value = @options[option]\n              next if current_value.nil?\n\n              accept = if current_value.respond_to?(:call)\n                current_value.call(item)\n              else\n                Array(current_value).map(&:to_s).include?(value.to_s)\n              end",
    "comment": "Generate default options for collection helpers, such as :checked and :disabled.",
    "label": "",
    "id": "976"
  },
  {
    "raw_code": "def grouped_choices?\n            return false if @choices.blank?\n\n            first_choice = @choices.first\n            return false unless first_choice.is_a?(Enumerable)\n\n            first_choice.second.is_a?(Array)\n          end",
    "comment": "Grouped choices look like this:  [nil, []] { nil => [] }",
    "label": "",
    "id": "977"
  },
  {
    "raw_code": "def partial_path(object, view)\n          object = object.to_model if object.respond_to?(:to_model)\n\n          path = if object.respond_to?(:to_partial_path)\n            object.to_partial_path\n          else\n            raise ArgumentError.new(\"'#{object.inspect}' is not an ActiveModel-compatible object. It must implement #to_partial_path.\")\n          end",
    "comment": "Obtains the path to where the object's partial is located. If the object responds to +to_partial_path+, then +to_partial_path+ will be called and will provide the path. If the object does not respond to +to_partial_path+, then an +ArgumentError+ is raised.  If +prefix_partial_path_with_controller_namespace+ is true, then this method will prefix the partial paths with a namespace.",
    "label": "",
    "id": "978"
  },
  {
    "raw_code": "def first?\n      index == 0\n    end",
    "comment": "Check if this is the first iteration of the partial.",
    "label": "",
    "id": "979"
  },
  {
    "raw_code": "def last?\n      index == size - 1\n    end",
    "comment": "Check if this is the last iteration of the partial.",
    "label": "",
    "id": "980"
  },
  {
    "raw_code": "def render(context, options)\n      render_to_object(context, options).body\n    end",
    "comment": "Main render entry point shared by Action View and Action Controller.",
    "label": "",
    "id": "981"
  },
  {
    "raw_code": "def render_body(context, options)\n      if options.key?(:partial)\n        [render_partial(context, options)]\n      else\n        StreamingTemplateRenderer.new(@lookup_context).render(context, options)\n      end",
    "comment": "Render but returns a valid Rack body. If fibers are defined, we return a streaming body that renders the template piece by piece.  Note that partials are not supported to be rendered with streaming, so in such cases, we just wrap them in an array.",
    "label": "",
    "id": "982"
  },
  {
    "raw_code": "def body\n        buffer = String.new\n        each { |part| buffer << part }\n        buffer\n      end",
    "comment": "Returns the complete body as a string.",
    "label": "",
    "id": "983"
  },
  {
    "raw_code": "def log_error(exception)\n          logger = ActionView::Base.logger\n          return unless logger\n\n          message = +\"\\n#{exception.class} (#{exception.message}):\\n\"\n          message << exception.annotated_source_code.to_s if exception.respond_to?(:annotated_source_code)\n          message << \"  \" << exception.backtrace.join(\"\\n  \")\n          logger.fatal(\"#{message}\\n\\n\")\n        end",
    "comment": "This is the same logging logic as in ShowExceptions middleware.",
    "label": "",
    "id": "984"
  },
  {
    "raw_code": "def render_template(view, template, layout_name = nil, locals = {}) # :nodoc:\n      return [super.body] unless template.supports_streaming?\n\n      locals ||= {}\n      layout   = find_layout(layout_name, locals.keys, [formats.first])\n\n      Body.new do |buffer|\n        delayed_render(buffer, template, layout, view, locals)\n      end",
    "comment": "For streaming, instead of rendering a given a template, we return a Body object that responds to each. This object is initialized with a block that knows how to render the template.",
    "label": "",
    "id": "985"
  },
  {
    "raw_code": "def determine_template(options)\n        keys = options.has_key?(:locals) ? options[:locals].keys : []\n\n        if options.key?(:body)\n          Template::Text.new(options[:body])\n        elsif options.key?(:plain)\n          Template::Text.new(options[:plain])\n        elsif options.key?(:html)\n          Template::HTML.new(options[:html], formats.first)\n        elsif options.key?(:file)\n          if File.exist?(options[:file])\n            Template::RawFile.new(options[:file])\n          else\n            if Pathname.new(options[:file]).absolute?\n              raise ArgumentError, \"File #{options[:file]} does not exist\"\n            else\n              raise ArgumentError, \"`render file:` should be given the absolute path to a file. '#{options[:file]}' was given instead\"\n            end",
    "comment": "Determine the template to be rendered using the given options.",
    "label": "",
    "id": "986"
  },
  {
    "raw_code": "def render_template(view, template, layout_name, locals)\n        render_with_layout(view, template, layout_name, locals) do |layout|\n          ActiveSupport::Notifications.instrument(\n            \"render_template.action_view\",\n            identifier: template.identifier,\n            layout: layout && layout.virtual_path,\n            locals: locals\n          ) do\n            template.render(view, locals) { |*name| view._layout_for(*name) }\n          end",
    "comment": "Renders the given template. A string representing the layout can be supplied as well.",
    "label": "",
    "id": "987"
  },
  {
    "raw_code": "def find_layout(layout, keys, formats)\n        resolve_layout(layout, keys, formats)\n      end",
    "comment": "This is the method which actually finds the layout using details in the lookup context object. If no layout is found, it checks if at least a layout with the given name exists across all details before raising the error.",
    "label": "",
    "id": "988"
  },
  {
    "raw_code": "def fetch_or_cache_partial(cached_partials, template, order_by:)\n        entries_to_write = {}\n\n        keyed_partials = order_by.index_with do |cache_key|\n          if content = cached_partials[cache_key]\n            build_rendered_template(content, template)\n          else\n            rendered_partial = yield\n            body = rendered_partial.body\n\n            # We want to cache buffers as raw strings. This both improve performance and\n            # avoid creating forward compatibility issues with the internal representation\n            # of these two types.\n            if body.is_a?(ActionView::OutputBuffer) || body.is_a?(ActiveSupport::SafeBuffer)\n              body = body.to_str\n            end",
    "comment": "`order_by` is an enumerable object containing keys of the cache, all keys are  passed in whether found already or not.  `cached_partials` is a hash. If the value exists it represents the rendered partial from the cache otherwise `Hash#fetch` will take the value of its block.  This method expects a block that will return the rendered partial. An example is to render all results for each element that was not found in the cache and store it as an array. Order it so that the first empty cache element in `cached_partials` corresponds to the first element in `rendered_partials`.  If the partial is not already cached it will also be written back to the underlying cache store.",
    "label": "",
    "id": "989"
  },
  {
    "raw_code": "def render_call_options(node)\n          # We are only looking for calls to render or render_to_string.\n          name = node.name.to_sym\n          return if name != :render && name != :render_to_string\n\n          # We are only looking for calls with arguments.\n          arguments = node.arguments\n          return unless arguments\n\n          arguments = arguments.arguments\n          length = arguments.length\n\n          # Get rid of any parentheses to get directly to the contents.\n          arguments.map! do |argument|\n            current = argument\n\n            while current.is_a?(Prism::ParenthesesNode) &&\n                  current.body.is_a?(Prism::StatementsNode) &&\n                  current.body.body.length == 1\n              current = current.body.body.first\n            end",
    "comment": "Accept a call node and return a hash of options for the render call. If it doesn't match the expected format, return nil.",
    "label": "",
    "id": "990"
  },
  {
    "raw_code": "def render_call_template(node)\n          object_template = false\n          template =\n            case node.type\n            when :string_node\n              path = node.unescaped\n              path.include?(\"/\") ? path : \"#{directory}/#{path}\"\n            when :interpolated_string_node\n              node.parts.map do |node|\n                case node.type\n                when :string_node\n                  node.unescaped\n                when :embedded_statements_node\n                  \"*\"\n                else\n                  return\n                end",
    "comment": "Accept the node that is being passed in the position of the template and return the template name and whether or not it is an object template.",
    "label": "",
    "id": "991"
  },
  {
    "raw_code": "def normalize_args(string, options_hash)\n          if options_hash\n            { partial: string, locals: options_hash }\n          else\n            { partial: string }\n          end",
    "comment": "Convert render(\"foo\", ...) into either render(template: \"foo\", ...) or render(partial: \"foo\", ...)",
    "label": "",
    "id": "992"
  },
  {
    "raw_code": "def corrections\n        candidates = paths.flat_map(&:all_template_paths).uniq\n\n        if partial\n          candidates.select!(&:partial?)\n        else\n          candidates.reject!(&:partial?)\n        end",
    "comment": "Apps may have thousands of candidate templates so we attempt to generate the suggestions as efficiently as possible. First we split templates into prefixes and basenames, so that those can be matched separately.",
    "label": "",
    "id": "993"
  },
  {
    "raw_code": "def register_template_handler(*extensions, handler)\n        raise(ArgumentError, \"Extension is required\") if extensions.empty?\n        extensions.each do |extension|\n          @@template_handlers[extension.to_sym] = handler\n        end",
    "comment": "Register an object that knows how to handle template files with the given extensions. This can be used to implement new template types. The handler must respond to +:call+, which will be passed the template and should return the rendered template as a String.",
    "label": "",
    "id": "994"
  },
  {
    "raw_code": "def unregister_template_handler(*extensions)\n        extensions.each do |extension|\n          handler = @@template_handlers.delete extension.to_sym\n          @@default_template_handlers = nil if @@default_template_handlers == handler\n        end",
    "comment": "Opposite to register_template_handler.",
    "label": "",
    "id": "995"
  },
  {
    "raw_code": "def find_all(name, prefix = nil, partial = false, details = {}, key = nil, locals = [])\n      _find_all(name, prefix, partial, details, key, locals)\n    end",
    "comment": "Normalizes the arguments and passes it on to find_templates.",
    "label": "",
    "id": "996"
  },
  {
    "raw_code": "def find_templates(name, prefix, partial, details, locals = [])\n      raise NotImplementedError, \"Subclasses must implement a find_templates(name, prefix, partial, details, locals = []) method\"\n    end",
    "comment": "This is what child classes implement. No defaults are needed because Resolver guarantees that the arguments are present and normalized.",
    "label": "",
    "id": "997"
  },
  {
    "raw_code": "def template_glob(glob)\n        query = File.join(escape_entry(@path), glob)\n        path_with_slash = File.join(@path, \"\")\n\n        Dir.glob(query).filter_map do |filename|\n          filename = File.expand_path(filename)\n          next if File.directory?(filename)\n          next unless filename.start_with?(path_with_slash)\n\n          filename\n        end",
    "comment": "Safe glob within @path",
    "label": "",
    "id": "998"
  },
  {
    "raw_code": "def translate_location(spot, _backtrace_location, source)\n          compiled = spot[:script_lines]\n          highlight = compiled[spot[:first_lineno] - 1]&.byteslice((spot[:first_column] - 1)...spot[:last_column])\n          return nil if highlight.blank?\n\n          source_lines = source.lines\n          lineno_delta = find_lineno_offset(compiled, source_lines, highlight, spot[:first_lineno])\n\n          tokens = ::ERB::Util.tokenize(source_lines[spot[:first_lineno] - lineno_delta - 1])\n          column_delta = find_offset(spot[:snippet], tokens, spot[:first_column])\n\n          spot[:first_lineno] -= lineno_delta\n          spot[:last_lineno] -= lineno_delta\n          spot[:first_column] -= column_delta\n          spot[:last_column] -= column_delta\n          spot[:script_lines] = source_lines\n\n          spot\n        rescue NotImplementedError, LocationParsingError\n          nil\n        end",
    "comment": "Translate an error location returned by ErrorHighlight to the correct source location inside the template.",
    "label": "",
    "id": "999"
  },
  {
    "raw_code": "def find_lineno_offset(compiled, source_lines, highlight, error_lineno)\n          first_index = error_lineno - 1 - compiled.size + source_lines.size\n          first_index = 0 if first_index < 0\n\n          last_index = error_lineno - 1\n          last_index = source_lines.size - 1 if last_index >= source_lines.size\n\n          last_index.downto(first_index) do |line_index|\n            next unless source_lines[line_index].include?(highlight)\n            return error_lineno - 1 - line_index\n          end",
    "comment": "Return the offset between the error lineno and the source lineno. Searches in reverse from the backtrace lineno so we have a better chance of finding the correct line  The compiled template is likely to be longer than the source. Use the difference between the compiled and source sizes to determine the earliest line that could contain the highlight.",
    "label": "",
    "id": "1000"
  },
  {
    "raw_code": "def find_offset(compiled, source_tokens, error_column)\n          compiled = StringScanner.new(compiled)\n          offset_source_tokens(source_tokens).each_cons(2) do |(name, str, offset), (_, next_str, _)|\n            matched_str = false\n\n            until compiled.eos?\n              if matched_str && next_str && compiled.match?(next_str)\n                break\n              elsif compiled.match?(str)\n                matched_str = true\n\n                if name == :CODE && compiled.pos <= error_column && compiled.pos + str.bytesize >= error_column\n                  return compiled.pos - offset\n                end",
    "comment": "Find which token in the source template spans the byte range that contains the error_column, then return the offset compared to the original source template.  Iterate consecutive pairs of CODE or TEXT tokens, requiring a match of the first token before matching either token.  For example, if we want to find tokens A, B, C, we do the following: 1. Find a match for A: test error_column or advance scanner. 2. Find a match for B or A: a. If B: start over with next token set (B, C). b. If A: test error_column or advance scanner. c. Otherwise: Advance 1 byte  Prioritize matching the next token over the current token once a match for the current token has been found. This is to prevent the current token from looping past the next token if they both match (i.e. if the current token is a single space character).",
    "label": "",
    "id": "1001"
  },
  {
    "raw_code": "def initialize(input, properties = {})\n            @newline_pending = 0\n\n            # Dup properties so that we don't modify argument\n            properties = Hash[properties]\n\n            properties[:bufvar]     ||= \"@output_buffer\"\n            properties[:preamble]   ||= \"\"\n            properties[:postamble]  ||= \"#{properties[:bufvar]}\"\n\n            # Tell Erubi whether the template will be compiled with `frozen_string_literal: true`\n            properties[:freeze_template_literals] = !Template.frozen_string_literal\n\n            properties[:escapefunc] = \"\"\n\n            super\n          end",
    "comment": ":nodoc: all",
    "label": "",
    "id": "1002"
  },
  {
    "raw_code": "def stderr_logger\n        nil\n      end",
    "comment": "Silence logger",
    "label": "",
    "id": "1003"
  },
  {
    "raw_code": "def load_schema\n        File.read(File.expand_path(\"fixtures/db_definitions/sqlite.sql\", __dir__)).split(\";\").each do |sql|\n          ActiveRecord::Base.lease_connection.execute(sql) unless sql.blank?\n        end",
    "comment": "Load actionpack sqlite3 tables",
    "label": "",
    "id": "1004"
  },
  {
    "raw_code": "def render_hello_world\n    render \"test/hello_world\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1005"
  },
  {
    "raw_code": "def render_hello_world_with_forward_slash\n    render \"/test/hello_world\"\n  end",
    "comment": ":ported: compatibility",
    "label": "",
    "id": "1006"
  },
  {
    "raw_code": "def render_template_in_top_directory\n    render template: \"shared\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1007"
  },
  {
    "raw_code": "def render_template_in_top_directory_with_slash\n    render \"/shared\"\n  end",
    "comment": ":deprecated:",
    "label": "",
    "id": "1008"
  },
  {
    "raw_code": "def render_hello_world_from_variable\n    @person = \"david\"\n    render plain: \"hello #{@person}\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1009"
  },
  {
    "raw_code": "def render_action_hello_world\n    render action: \"hello_world\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1010"
  },
  {
    "raw_code": "def render_text_hello_world\n    render plain: \"hello world\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1011"
  },
  {
    "raw_code": "def render_text_hello_world_with_layout\n    @variable_for_layout = \", I am here!\"\n    render plain: \"hello world\", layout: true\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1012"
  },
  {
    "raw_code": "def render_template_with_instance_variables\n    @secret = \"in the sauce\"\n    render template: \"test/render_template_with_ivar\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1013"
  },
  {
    "raw_code": "def render_file_not_using_full_path\n    render file: \"test/render_template_with_ivar\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1014"
  },
  {
    "raw_code": "def render_custom_code\n    render plain: \"hello world\", status: 404\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1015"
  },
  {
    "raw_code": "def render_text_with_nil\n    render plain: nil\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1016"
  },
  {
    "raw_code": "def render_text_with_false\n    render plain: false\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1017"
  },
  {
    "raw_code": "def render_nothing_with_appendix\n    render plain: \"appended\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1018"
  },
  {
    "raw_code": "def render_xml_hello\n    @name = \"David\"\n    render template: \"test/hello\"\n  end",
    "comment": "This test is testing 3 things: render :file in AV      :ported: render :template in AC  :ported: setting content type",
    "label": "",
    "id": "1019"
  },
  {
    "raw_code": "def blank_response\n    render plain: \" \"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1020"
  },
  {
    "raw_code": "def layout_test\n    render action: \"hello_world\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1021"
  },
  {
    "raw_code": "def builder_layout_test\n    @name = nil\n    render action: \"hello\", layout: \"layouts/builder\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1022"
  },
  {
    "raw_code": "def builder_partial_test\n    render action: \"hello_world_container\"\n  end",
    "comment": ":move: test this in Action View",
    "label": "",
    "id": "1023"
  },
  {
    "raw_code": "def partials_list\n    @test_unchanged = \"hello\"\n    @customers = [ Customer.new(\"david\"), Customer.new(\"mary\") ]\n    render action: \"list\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1024"
  },
  {
    "raw_code": "def render_with_explicit_template\n    render template: \"test/hello_world\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1025"
  },
  {
    "raw_code": "def render_with_explicit_template_with_locals\n    render template: \"test/render_template_with_locals\", locals: { secret: \"area51\" }\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1026"
  },
  {
    "raw_code": "def double_render\n    render plain: \"hello\"\n    render plain: \"world\"\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1027"
  },
  {
    "raw_code": "def hello_world_from_rxml_using_template\n    render template: \"test/hello_world_from_rxml\", handlers: [:builder]\n  end",
    "comment": ":deprecated:",
    "label": "",
    "id": "1028"
  },
  {
    "raw_code": "def render_text_with_assigns\n    @hello = \"world\"\n    render plain: \"foo\"\n  end",
    "comment": ":addressed:",
    "label": "",
    "id": "1029"
  },
  {
    "raw_code": "def render_with_filters\n    render action: :formatted_xml_erb\n  end",
    "comment": "Ensure that the before filter is executed *before* self.formats is set.",
    "label": "",
    "id": "1030"
  },
  {
    "raw_code": "def test_simple_show\n    get :hello_world\n    assert_response 200\n    assert_response :success\n    assert_equal \"<html>Hello world!</html>\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1031"
  },
  {
    "raw_code": "def test_renders_default_template_for_missing_action\n    get :'hyphen-ated'\n    assert_equal \"hyphen-ated.erb\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1032"
  },
  {
    "raw_code": "def test_render\n    get :render_hello_world\n    assert_equal \"Hello world!\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1033"
  },
  {
    "raw_code": "def test_render_with_forward_slash\n    get :render_hello_world_with_forward_slash\n    assert_equal \"Hello world!\", @response.body\n  end",
    "comment": ":ported: compatibility",
    "label": "",
    "id": "1034"
  },
  {
    "raw_code": "def test_render_in_top_directory\n    get :render_template_in_top_directory\n    assert_equal \"Elastica\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1035"
  },
  {
    "raw_code": "def test_render_in_top_directory_with_slash\n    get :render_template_in_top_directory_with_slash\n    assert_equal \"Elastica\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1036"
  },
  {
    "raw_code": "def test_render_from_variable\n    get :render_hello_world_from_variable\n    assert_equal \"hello david\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1037"
  },
  {
    "raw_code": "def test_render_action\n    get :render_action_hello_world\n    assert_equal \"Hello world!\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1038"
  },
  {
    "raw_code": "def test_render_action_hello_world_as_string\n    get :render_action_hello_world_as_string\n    assert_equal \"Hello world!\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1039"
  },
  {
    "raw_code": "def test_render_action_with_symbol\n    get :render_action_hello_world_with_symbol\n    assert_equal \"Hello world!\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1040"
  },
  {
    "raw_code": "def test_render_text\n    get :render_text_hello_world\n    assert_equal \"hello world\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1041"
  },
  {
    "raw_code": "def test_do_with_render_text_and_layout\n    get :render_text_hello_world_with_layout\n    assert_equal \"{{hello world, I am here!}}\\n\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1042"
  },
  {
    "raw_code": "def test_do_with_render_action_and_layout_false\n    get :hello_world_with_layout_false\n    assert_equal \"Hello world!\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1043"
  },
  {
    "raw_code": "def test_render_template_with_instance_variables\n    get :render_template_with_instance_variables\n    assert_equal \"The secret is in the sauce\\n\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1044"
  },
  {
    "raw_code": "def test_render_file_not_using_full_path\n    assert_raise(ArgumentError) do\n      get :render_file_not_using_full_path\n    end",
    "comment": ":ported:",
    "label": "",
    "id": "1045"
  },
  {
    "raw_code": "def test_render_template_with_dot_in_path\n    get :render_template_with_dot_in_path\n    assert_equal \"The secret is in the sauce\\n\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1046"
  },
  {
    "raw_code": "def test_render_file_using_pathname\n    get :render_file_using_pathname\n    assert_equal \"The secret is <%= @secret %>\\n\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1047"
  },
  {
    "raw_code": "def test_render_template_with_locals\n    get :render_template_with_locals\n    assert_equal \"The secret is in the sauce\\n\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1048"
  },
  {
    "raw_code": "def test_render_file_from_template\n    get :render_file_from_template\n    assert_equal \"The secret is &lt;%= @secret %&gt;\\n\", @response.body\n  end",
    "comment": ":assessed:",
    "label": "",
    "id": "1049"
  },
  {
    "raw_code": "def test_render_custom_code\n    get :render_custom_code\n    assert_response 404\n    assert_response :missing\n    assert_equal \"hello world\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1050"
  },
  {
    "raw_code": "def test_render_text_with_nil\n    get :render_text_with_nil\n    assert_response 200\n    assert_equal \"\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1051"
  },
  {
    "raw_code": "def test_render_text_with_false\n    get :render_text_with_false\n    assert_equal \"false\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1052"
  },
  {
    "raw_code": "def test_render_nothing_with_appendix\n    get :render_nothing_with_appendix\n    assert_response 200\n    assert_equal \"appended\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1053"
  },
  {
    "raw_code": "def test_attempt_to_access_object_method\n    assert_raise(AbstractController::ActionNotFound) { get :clone }\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1054"
  },
  {
    "raw_code": "def test_private_methods\n    assert_raise(AbstractController::ActionNotFound) { get :determine_layout }\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1055"
  },
  {
    "raw_code": "def test_access_to_request_in_view\n    get :accessing_request_in_template\n    assert_equal \"Hello: www.nextangle.com\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1056"
  },
  {
    "raw_code": "def test_access_to_action_name_in_view\n    get :accessing_action_name_in_template\n    assert_equal \"accessing_action_name_in_template\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1057"
  },
  {
    "raw_code": "def test_access_to_controller_name_in_view\n    get :accessing_controller_name_in_template\n    assert_equal \"test\", @response.body # name is explicitly set in the controller.\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1058"
  },
  {
    "raw_code": "def test_render_xml\n    get :render_xml_hello\n    assert_equal \"<html>\\n  <p>Hello David</p>\\n<p>This is grand!</p>\\n</html>\\n\", @response.body\n    assert_equal \"application/xml\", @response.media_type\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1059"
  },
  {
    "raw_code": "def test_render_xml_as_string_template\n    get :render_xml_hello_as_string_template\n    assert_equal \"<html>\\n  <p>Hello David</p>\\n<p>This is grand!</p>\\n</html>\\n\", @response.body\n    assert_equal \"application/xml\", @response.media_type\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1060"
  },
  {
    "raw_code": "def test_render_xml_with_default\n    get :greeting\n    assert_equal \"<p>This is grand!</p>\\n\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1061"
  },
  {
    "raw_code": "def test_render_xml_with_partial\n    get :builder_partial_test\n    assert_equal \"<test>\\n  <hello/>\\n</test>\\n\", @response.body\n  end",
    "comment": ":move: test in AV",
    "label": "",
    "id": "1062"
  },
  {
    "raw_code": "def test_layout_rendering\n    get :layout_test\n    assert_equal \"<html>Hello world!</html>\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1063"
  },
  {
    "raw_code": "def test_nested_rendering\n    @controller = Fun::GamesController.new\n    get :hello_world\n    assert_equal \"Living in a nested world\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1064"
  },
  {
    "raw_code": "def test_double_render\n    assert_raise(AbstractController::DoubleRenderError) { get :double_render }\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1065"
  },
  {
    "raw_code": "def test_render_to_string_and_render\n    get :render_to_string_and_render\n    assert_equal(\"Hi web users! here is some cached stuff\", @response.body)\n  end",
    "comment": "specify the one exception to double render rule - render_to_string followed by render",
    "label": "",
    "id": "1066"
  },
  {
    "raw_code": "def test_render_text_with_assigns\n    get :render_text_with_assigns\n    assert_equal \"world\", @controller.instance_variable_get(:@hello)\n  end",
    "comment": ":addressed:",
    "label": "",
    "id": "1067"
  },
  {
    "raw_code": "def test_template_with_locals\n    get :render_with_explicit_template_with_locals\n    assert_equal \"The secret is area51\\n\", @response.body\n  end",
    "comment": ":ported:",
    "label": "",
    "id": "1068"
  },
  {
    "raw_code": "def test_with_irregular_plural_record\n    with_test_routes do\n      @tax.save\n      assert_url \"http://example.com/taxes/#{@tax.id}\", @tax\n    end",
    "comment": "Tests for names where .plural.singular doesn't round-trip",
    "label": "",
    "id": "1069"
  },
  {
    "raw_code": "def test_uncountable_resource\n    with_test_routes do\n      @series.save\n      assert_url \"http://example.com/series/#{@series.id}\", @series\n      assert_url \"http://example.com/series\", Series.new\n    end",
    "comment": "Tests for uncountable names",
    "label": "",
    "id": "1070"
  },
  {
    "raw_code": "def test_distance_of_time_in_words_calls_i18n\n    { # with include_seconds\n      [2.seconds,  { include_seconds: true }]  => [:'less_than_x_seconds', 5],\n      [9.seconds,  { include_seconds: true }]  => [:'less_than_x_seconds', 10],\n      [19.seconds, { include_seconds: true }]  => [:'less_than_x_seconds', 20],\n      [30.seconds, { include_seconds: true }]  => [:'half_a_minute',       nil],\n      [59.seconds, { include_seconds: true }]  => [:'less_than_x_minutes', 1],\n      [60.seconds, { include_seconds: true }]  => [:'x_minutes',           1],\n\n      # without include_seconds\n      [29.seconds,          { include_seconds: false }] => [:'less_than_x_minutes', 1],\n      [60.seconds,          { include_seconds: false }] => [:'x_minutes',           1],\n      [44.minutes,          { include_seconds: false }] => [:'x_minutes',           44],\n      [61.minutes,          { include_seconds: false }] => [:'about_x_hours',       1],\n      [24.hours,            { include_seconds: false }] => [:'x_days',              1],\n      [30.days,             { include_seconds: false }] => [:'about_x_months',      1],\n      [60.days,             { include_seconds: false }] => [:'x_months',            2],\n      [1.year,              { include_seconds: false }] => [:'about_x_years',       1],\n      [3.years + 6.months,  { include_seconds: false }] => [:'over_x_years',        3],\n      [3.years + 10.months, { include_seconds: false }] => [:'almost_x_years',      4]\n\n      }.each do |passed, expected|\n      assert_distance_of_time_in_words_translates_key passed, expected\n    end",
    "comment": "distance_of_time_in_words",
    "label": "",
    "id": "1071"
  },
  {
    "raw_code": "def test_select_month_given_use_month_names_option_does_not_translate_monthnames\n    assert_not_called(I18n, :translate) do\n      select_month(8, locale: \"en\", use_month_names: Date::MONTHNAMES)\n    end",
    "comment": "select_month",
    "label": "",
    "id": "1072"
  },
  {
    "raw_code": "def test_date_or_time_select_translates_prompts\n    prompt_defaults = { year: \"Year\", month: \"Month\", day: \"Day\", hour: \"Hour\", minute: \"Minute\", second: \"Seconds\" }\n    defaults = { [:'date.order', locale: \"en\", default: []] => %w(year month day) }\n\n    prompt_defaults.each do |key, prompt|\n      defaults[[(\"datetime.prompts.\" + key.to_s).to_sym, locale: \"en\"]] = prompt\n    end",
    "comment": "date_or_time_select",
    "label": "",
    "id": "1073"
  },
  {
    "raw_code": "def test_javascript_include_tag\n    assert_dom_equal \"<script src='/foo.js'></script>\",  javascript_include_tag(\"/foo\")\n    assert_dom_equal \"<script src='/foo'></script>\",     javascript_include_tag(\"/foo\", extname: false)\n    assert_dom_equal \"<script src='/foo.bar'></script>\", javascript_include_tag(\"/foo\", extname: \".bar\")\n  end",
    "comment": "Setting the :extname option will control what extension (if any) is appended to the URL for assets",
    "label": "",
    "id": "1074"
  },
  {
    "raw_code": "def setup\n    ActionView::LookupContext::DetailsKey.clear\n    view_paths = ActionController::Base.view_paths\n    assert_equal ActionView::FileSystemResolver, view_paths.first.class\n    setup_view(view_paths)\n  end",
    "comment": "Ensure view path cache is primed",
    "label": "",
    "id": "1075"
  },
  {
    "raw_code": "def setup\n    ActionView::LookupContext::DetailsKey.clear\n    path = ActionView::FileSystemResolver.new(FIXTURE_LOAD_PATH)\n    view_paths = ActionView::PathSet.new([path])\n    assert_equal ActionView::FileSystemResolver.new(FIXTURE_LOAD_PATH), view_paths.first\n    setup_view(view_paths)\n  end",
    "comment": "Test the same thing as above, but make sure the view path is not eager loaded",
    "label": "",
    "id": "1076"
  },
  {
    "raw_code": "def test_default_external_works\n    with_external_encoding \"ISO-8859-1\" do\n      @template = new_template(\"hello \\xFCmlat\")\n      assert_equal Encoding::UTF_8, render.encoding\n      assert_equal \"hello \\u{fc}mlat\", render\n    end",
    "comment": "This test ensures that if the default_external is set to something other than UTF-8, we don't get any errors and get back a UTF-8 String.",
    "label": "",
    "id": "1077"
  },
  {
    "raw_code": "def test_lying_with_magic_comment\n    assert_raises(ActionView::Template::Error) do\n      @template = new_template(\"# encoding: UTF-8\\nhello \\xFCmlat\", virtual_path: nil)\n      render\n    end",
    "comment": "TODO: This is currently handled inside ERB. The case of explicitly lying about encodings via the normal Rails API should be handled inside Rails.",
    "label": "",
    "id": "1078"
  },
  {
    "raw_code": "def serialize(arguments)\n      arguments.map { |argument| serialize_argument(argument) }\n    end",
    "comment": "Serializes a set of arguments. Intrinsic types that can safely be serialized without mutation are returned as-is. Arrays/Hashes are serialized element by element. All other types are serialized using GlobalID.",
    "label": "",
    "id": "1079"
  },
  {
    "raw_code": "def deserialize(arguments)\n      arguments.map { |argument| deserialize_argument(argument) }\n    rescue\n      raise DeserializationError\n    end",
    "comment": "Deserializes a set of arguments. Intrinsic types that can safely be deserialized without mutation are returned as-is. Arrays/Hashes are deserialized element by element. All other types are deserialized using GlobalID.",
    "label": "",
    "id": "1080"
  },
  {
    "raw_code": "def before_perform(*filters, &blk)\n        set_callback(:perform, :before, *filters, &blk)\n      end",
    "comment": "Defines a callback that will get called right before the job's perform method is executed.  class VideoProcessJob < ActiveJob::Base queue_as :default  before_perform do |job| UserMailer.notify_video_started_processing(job.arguments.first) end  def perform(video_id) Video.find(video_id).process end end ",
    "label": "",
    "id": "1081"
  },
  {
    "raw_code": "def after_perform(*filters, &blk)\n        set_callback(:perform, :after, *filters, &blk)\n      end",
    "comment": "Defines a callback that will get called right after the job's perform method has finished.  class VideoProcessJob < ActiveJob::Base queue_as :default  after_perform do |job| UserMailer.notify_video_processed(job.arguments.first) end  def perform(video_id) Video.find(video_id).process end end ",
    "label": "",
    "id": "1082"
  },
  {
    "raw_code": "def around_perform(*filters, &blk)\n        set_callback(:perform, :around, *filters, &blk)\n      end",
    "comment": "Defines a callback that will get called around the job's perform method.  class VideoProcessJob < ActiveJob::Base queue_as :default  around_perform do |job, block| UserMailer.notify_video_started_processing(job.arguments.first) block.call UserMailer.notify_video_processed(job.arguments.first) end  def perform(video_id) Video.find(video_id).process end end  You can access the return value of the job only if the execution wasn't halted.  class VideoProcessJob < ActiveJob::Base around_perform do |job, block| value = block.call puts value # => \"Hello World!\" end  def perform \"Hello World!\" end end ",
    "label": "",
    "id": "1083"
  },
  {
    "raw_code": "def before_enqueue(*filters, &blk)\n        set_callback(:enqueue, :before, *filters, &blk)\n      end",
    "comment": "Defines a callback that will get called right before the job is enqueued.  class VideoProcessJob < ActiveJob::Base queue_as :default  before_enqueue do |job| $statsd.increment \"enqueue-video-job.try\" end  def perform(video_id) Video.find(video_id).process end end ",
    "label": "",
    "id": "1084"
  },
  {
    "raw_code": "def after_enqueue(*filters, &blk)\n        set_callback(:enqueue, :after, *filters, &blk)\n      end",
    "comment": "Defines a callback that will get called right after the job is enqueued.  class VideoProcessJob < ActiveJob::Base queue_as :default  after_enqueue do |job| result = job.successfully_enqueued? ? \"success\" : \"failure\" $statsd.increment \"enqueue-video-job.#{result}\" end  def perform(video_id) Video.find(video_id).process end end ",
    "label": "",
    "id": "1085"
  },
  {
    "raw_code": "def around_enqueue(*filters, &blk)\n        set_callback(:enqueue, :around, *filters, &blk)\n      end",
    "comment": "Defines a callback that will get called around the enqueuing of the job.  class VideoProcessJob < ActiveJob::Base queue_as :default  around_enqueue do |job, block| $statsd.time \"video-job.process\" do block.call end end  def perform(video_id) Video.find(video_id).process end end ",
    "label": "",
    "id": "1086"
  },
  {
    "raw_code": "def step(step_name, start: nil, isolated: false, &block)\n      unless block_given?\n        step_method = method(step_name)\n\n        raise ArgumentError, \"Step method '#{step_name}' must accept 0 or 1 arguments\" if step_method.arity > 1\n\n        if step_method.parameters.any? { |type, name| type == :key || type == :keyreq }\n          raise ArgumentError, \"Step method '#{step_name}' must not accept keyword arguments\"\n        end",
    "comment": "Start a new continuation step",
    "label": "",
    "id": "1087"
  },
  {
    "raw_code": "def deserialize(job_data)\n        job_class = job_data[\"job_class\"].safe_constantize\n        raise UnknownJobClassError, job_data[\"job_class\"] unless job_class\n\n        job = job_class.new\n        job.deserialize(job_data)\n        job\n      end",
    "comment": "Creates a new job instance from a hash created with +serialize+",
    "label": "",
    "id": "1088"
  },
  {
    "raw_code": "def set(options = {})\n        ConfiguredJob.new(self, options)\n      end",
    "comment": "Creates a job preconfigured with the given options. You can call perform_later with the job arguments to enqueue the job with the preconfigured options  ==== Options * <tt>:wait</tt> - Enqueues the job with the specified delay * <tt>:wait_until</tt> - Enqueues the job at the time specified * <tt>:queue</tt> - Enqueues the job on the specified queue * <tt>:priority</tt> - Enqueues the job with the specified priority  ==== Examples  VideoJob.set(queue: :some_queue).perform_later(Video.last) VideoJob.set(wait: 5.minutes).perform_later(Video.last) VideoJob.set(wait_until: Time.now.tomorrow).perform_later(Video.last) VideoJob.set(queue: :some_queue, wait: 5.minutes).perform_later(Video.last) VideoJob.set(queue: :some_queue, wait_until: Time.now.tomorrow).perform_later(Video.last) VideoJob.set(queue: :some_queue, wait: 5.minutes, priority: 10).perform_later(Video.last)",
    "label": "",
    "id": "1089"
  },
  {
    "raw_code": "def initialize(*arguments)\n      @arguments  = arguments\n      @job_id     = SecureRandom.uuid\n      @queue_name = self.class.queue_name\n      @scheduled_at = nil\n      @priority   = self.class.priority\n      @executions = 0\n      @exception_executions = {}\n      @timezone   = Time.zone&.name\n    end",
    "comment": "Creates a new job instance. Takes the arguments that will be passed to the perform method.",
    "label": "",
    "id": "1090"
  },
  {
    "raw_code": "def serialize\n      {\n        \"job_class\"  => self.class.name,\n        \"job_id\"     => job_id,\n        \"provider_job_id\" => provider_job_id,\n        \"queue_name\" => queue_name,\n        \"priority\"   => priority,\n        \"arguments\"  => serialize_arguments_if_needed(arguments),\n        \"executions\" => executions,\n        \"exception_executions\" => exception_executions,\n        \"locale\"     => locale || I18n.locale.to_s,\n        \"timezone\"   => timezone,\n        \"enqueued_at\" => Time.now.utc.iso8601(9),\n        \"scheduled_at\" => scheduled_at ? scheduled_at.utc.iso8601(9) : nil,\n      }\n    end",
    "comment": "Returns a hash with the job data that can safely be passed to the queuing adapter.",
    "label": "",
    "id": "1091"
  },
  {
    "raw_code": "def deserialize(job_data)\n      self.job_id               = job_data[\"job_id\"]\n      self.provider_job_id      = job_data[\"provider_job_id\"]\n      self.queue_name           = job_data[\"queue_name\"]\n      self.priority             = job_data[\"priority\"]\n      self.serialized_arguments = job_data[\"arguments\"]\n      self.executions           = job_data[\"executions\"]\n      self.exception_executions = job_data[\"exception_executions\"]\n      self.locale               = job_data[\"locale\"] || I18n.locale.to_s\n      self.timezone             = job_data[\"timezone\"] || Time.zone&.name\n      self.enqueued_at          = deserialize_time(job_data[\"enqueued_at\"]) if job_data[\"enqueued_at\"]\n      self.scheduled_at         = deserialize_time(job_data[\"scheduled_at\"]) if job_data[\"scheduled_at\"]\n    end",
    "comment": "Attaches the stored job data to the current instance. Receives a hash returned from +serialize+  ==== Examples  class DeliverWebhookJob < ActiveJob::Base attr_writer :attempt_number  def attempt_number @attempt_number ||= 0 end  def serialize super.merge('attempt_number' => attempt_number + 1) end  def deserialize(job_data) super self.attempt_number = job_data['attempt_number'] end  rescue_from(Timeout::Error) do |exception| raise exception if attempt_number > 5 retry_job(wait: 10) end end",
    "label": "",
    "id": "1092"
  },
  {
    "raw_code": "def set(options = {}) # :nodoc:\n      self.scheduled_at = options[:wait].seconds.from_now if options[:wait]\n      self.scheduled_at = options[:wait_until] if options[:wait_until]\n      self.queue_name   = self.class.queue_name_from_part(options[:queue]) if options[:queue]\n      self.priority     = options[:priority].to_i if options[:priority]\n\n      self\n    end",
    "comment": "Configures the job with the given options.",
    "label": "",
    "id": "1093"
  },
  {
    "raw_code": "def perform_all_later(*jobs)\n      jobs.flatten!\n      jobs.group_by(&:queue_adapter).each do |queue_adapter, adapter_jobs|\n        instrument_enqueue_all(queue_adapter, adapter_jobs) do\n          if queue_adapter.respond_to?(:enqueue_all)\n            queue_adapter.enqueue_all(adapter_jobs)\n          else\n            adapter_jobs.each do |job|\n              job.successfully_enqueued = false\n              if job.scheduled_at\n                queue_adapter.enqueue_at(job, job.scheduled_at.to_f)\n              else\n                queue_adapter.enqueue(job)\n              end",
    "comment": "Push many jobs onto the queue at once without running enqueue callbacks. Queue adapters may communicate the enqueue status of each job by setting successfully_enqueued and/or enqueue_error on the passed-in job instances.",
    "label": "",
    "id": "1094"
  },
  {
    "raw_code": "def perform_later(...)\n        job = job_or_instantiate(...)\n        enqueue_result = job.enqueue\n\n        yield job if block_given?\n\n        enqueue_result\n      end",
    "comment": "Push a job onto the queue. By default the arguments must be either String, Integer, Float, NilClass, TrueClass, FalseClass, BigDecimal, Symbol, Date, Time, DateTime, ActiveSupport::TimeWithZone, ActiveSupport::Duration, Hash, ActiveSupport::HashWithIndifferentAccess, Array, Range, or GlobalID::Identification instances, although this can be extended by adding custom serializers.  Returns an instance of the job class queued with arguments available in Job#arguments or +false+ if the enqueue did not succeed.  After the attempted enqueue, the job will be yielded to an optional block.  If Active Job is used conjointly with Active Record, and #perform_later is called inside an Active Record transaction, then the enqueue is implicitly deferred to after the transaction is committed, or dropped if it's rolled back. In such case #perform_later will return the job instance like if it was successfully enqueued, but will still return +false+ if a callback prevented the job from being enqueued.  This behavior can be changed on a per job basis:  class NotificationJob < ApplicationJob self.enqueue_after_transaction_commit = false end",
    "label": "",
    "id": "1095"
  },
  {
    "raw_code": "def enqueue(options = {})\n      set(options)\n      self.successfully_enqueued = false\n\n      raw_enqueue\n\n      if successfully_enqueued?\n        self\n      else\n        false\n      end",
    "comment": "Enqueues the job to be performed by the queue adapter.  ==== Options * <tt>:wait</tt> - Enqueues the job with the specified delay * <tt>:wait_until</tt> - Enqueues the job at the time specified * <tt>:queue</tt> - Enqueues the job on the specified queue * <tt>:priority</tt> - Enqueues the job with the specified priority  ==== Examples  my_job_instance.enqueue my_job_instance.enqueue wait: 5.minutes my_job_instance.enqueue queue: :important my_job_instance.enqueue wait_until: Date.tomorrow.midnight my_job_instance.enqueue priority: 10",
    "label": "",
    "id": "1096"
  },
  {
    "raw_code": "def retry_on(*exceptions, wait: 3.seconds, attempts: 5, queue: nil, priority: nil, jitter: JITTER_DEFAULT, report: false)\n        rescue_from(*exceptions) do |error|\n          executions = executions_for(exceptions)\n          if attempts == :unlimited || executions < attempts\n            ActiveSupport.error_reporter.report(error, source: \"application.active_job\") if report\n            retry_job wait: determine_delay(seconds_or_duration_or_algorithm: wait, executions: executions, jitter: jitter), queue: queue, priority: priority, error: error\n          else\n            if block_given?\n              instrument :retry_stopped, error: error do\n                yield self, error\n              end",
    "comment": "Catch the exception and reschedule job for re-execution after so many seconds, for a specific number of attempts. If the exception keeps getting raised beyond the specified number of attempts, the exception is allowed to bubble up to the underlying queuing system, which may have its own retry mechanism or place it in a holding queue for inspection.  You can also pass a block that'll be invoked if the retry attempts fail for custom logic rather than letting the exception bubble up. This block is yielded with the job instance as the first and the error instance as the second parameter.  +retry_on+ and +discard_on+ handlers are searched from bottom to top, and up the class hierarchy. The handler of the first class for which <tt>exception.is_a?(klass)</tt> holds true is the one invoked, if any.  ==== Options * <tt>:wait</tt> - Re-enqueues the job with a delay specified either in seconds (default: 3 seconds), as a computing proc that takes the number of executions so far as an argument, or as a symbol reference of <tt>:polynomially_longer</tt>, which applies the wait algorithm of <tt>((executions**4) + (Kernel.rand * (executions**4) * jitter)) + 2</tt> (first wait ~3s, then ~18s, then ~83s, etc) * <tt>:attempts</tt> - Enqueues the job the specified number of times (default: 5 attempts) or a symbol reference of <tt>:unlimited</tt> to retry the job until it succeeds. The number of attempts includes the original job execution. * <tt>:queue</tt> - Re-enqueues the job on a different queue * <tt>:priority</tt> - Re-enqueues the job with a different priority * <tt>:jitter</tt> - A random delay of wait time used when calculating backoff. The default is 15% (0.15) which represents the upper bound of possible wait time (expressed as a percentage) * <tt>:report</tt> - Errors will be reported to the Rails.error reporter before being retried  ==== Examples  class RemoteServiceJob < ActiveJob::Base retry_on CustomAppException # defaults to ~3s wait, 5 attempts retry_on AnotherCustomAppException, wait: ->(executions) { executions * 2 } retry_on CustomInfrastructureException, wait: 5.minutes, attempts: :unlimited  retry_on ActiveRecord::Deadlocked, wait: 5.seconds, attempts: 3 retry_on Net::OpenTimeout, Timeout::Error, wait: :polynomially_longer, attempts: 10 # retries at most 10 times for Net::OpenTimeout and Timeout::Error combined # To retry at most 10 times for each individual exception: # retry_on Net::OpenTimeout, wait: :polynomially_longer, attempts: 10 # retry_on Net::ReadTimeout, wait: 5.seconds, jitter: 0.30, attempts: 10 # retry_on Timeout::Error, wait: :polynomially_longer, attempts: 10  retry_on YetAnotherCustomAppException, report: true retry_on EvenWorseCustomAppException do |job, error| CustomErrorHandlingCode.handle(job, error) end  def perform(*args) # Might raise CustomAppException, AnotherCustomAppException, or YetAnotherCustomAppException for something domain specific # Might raise ActiveRecord::Deadlocked when a local db deadlock is detected # Might raise Net::OpenTimeout or Timeout::Error when the remote service is down end end",
    "label": "",
    "id": "1097"
  },
  {
    "raw_code": "def discard_on(*exceptions, report: false)\n        rescue_from(*exceptions) do |error|\n          instrument :discard, error: error do\n            ActiveSupport.error_reporter.report(error, source: \"application.active_job\") if report\n            yield self, error if block_given?\n            run_after_discard_procs(error)\n          end",
    "comment": "Discard the job with no attempts to retry, if the exception is raised. This is useful when the subject of the job, like an Active Record, is no longer available, and the job is thus no longer relevant.  Passing the <tt>:report</tt> option reports the error through the error reporter before discarding the job.  You can also pass a block that'll be invoked. This block is yielded with the job instance as the first and the error instance as the second parameter.  +retry_on+ and +discard_on+ handlers are searched from bottom to top, and up the class hierarchy. The handler of the first class for which <tt>exception.is_a?(klass)</tt> holds true is the one invoked, if any.  ==== Example  class SearchIndexingJob < ActiveJob::Base discard_on ActiveJob::DeserializationError discard_on CustomAppException, report: true discard_on(AnotherCustomAppException) do |job, error| CustomErrorHandlingCode.handle(job, error) end  def perform(record) # Will raise ActiveJob::DeserializationError if the record can't be deserialized # Might raise CustomAppException for something domain specific end end",
    "label": "",
    "id": "1098"
  },
  {
    "raw_code": "def after_discard(&blk)\n        self.after_discard_procs += [blk]\n      end",
    "comment": "A block to run when a job is about to be discarded for any reason.  ==== Example  class WorkJob < ActiveJob::Base after_discard do |job, exception| ExceptionNotifier.report(exception) end  ...  end",
    "label": "",
    "id": "1099"
  },
  {
    "raw_code": "def retry_job(options = {})\n      instrument :enqueue_retry, options.slice(:error, :wait) do\n        scheduled_at, queue_name, priority = self.scheduled_at, self.queue_name, self.priority\n        enqueue options\n      ensure\n        self.scheduled_at, self.queue_name, self.priority = scheduled_at, queue_name, priority\n      end",
    "comment": "Reschedules the job to be re-executed. This is useful in combination with {rescue_from}[rdoc-ref:ActiveSupport::Rescuable::ClassMethods#rescue_from]. When you rescue an exception from your job you can ask Active Job to retry performing your job.  ==== Options * <tt>:wait</tt> - Enqueues the job with the specified delay in seconds * <tt>:wait_until</tt> - Enqueues the job at the time specified * <tt>:queue</tt> - Enqueues the job on the specified queue * <tt>:priority</tt> - Enqueues the job with the specified priority  ==== Examples  class SiteScraperJob < ActiveJob::Base rescue_from(ErrorLoadingSite) do retry_job queue: :low_priority end  def perform(*args) # raise ErrorLoadingSite if cannot scrape end end",
    "label": "",
    "id": "1100"
  },
  {
    "raw_code": "def perform_now(...)\n        job_or_instantiate(...).perform_now\n      end",
    "comment": "Performs the job immediately.  MyJob.perform_now(\"mike\") ",
    "label": "",
    "id": "1101"
  },
  {
    "raw_code": "def perform_now\n      # Guard against jobs that were persisted before we started counting executions by zeroing out nil counters\n      self.executions = (executions || 0) + 1\n\n      deserialize_arguments_if_needed\n\n      _perform_job\n    rescue Exception => exception\n      handled = rescue_with_handler(exception)\n      return handled if handled\n\n      run_after_discard_procs(exception)\n      raise\n    end",
    "comment": "Performs the job immediately. The job is not sent to the queuing adapter but directly executed by blocking the execution of others until it's finished. +perform_now+ returns the value of your job's +perform+ method.  class MyJob < ActiveJob::Base def perform \"Hello World!\" end end  puts MyJob.new(*args).perform_now # => \"Hello World!\"",
    "label": "",
    "id": "1102"
  },
  {
    "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of Active Job as a +Gem::Version+.",
    "label": "",
    "id": "1103"
  },
  {
    "raw_code": "def queue_adapter\n        self.queue_adapter = :async if _queue_adapter.nil?\n        _queue_adapter\n      end",
    "comment": "Returns the backend queue provider. The default queue adapter is +:async+. See QueueAdapters for more information.",
    "label": "",
    "id": "1104"
  },
  {
    "raw_code": "def queue_adapter_name\n        self.queue_adapter = :async if _queue_adapter_name.nil?\n        _queue_adapter_name\n      end",
    "comment": "Returns string denoting the name of the configured queue adapter. By default returns <tt>\"async\"</tt>.",
    "label": "",
    "id": "1105"
  },
  {
    "raw_code": "def queue_adapter=(name_or_adapter)\n        case name_or_adapter\n        when Symbol, String\n          queue_adapter = ActiveJob::QueueAdapters.lookup(name_or_adapter).new\n          queue_adapter.try(:check_adapter)\n          assign_adapter(name_or_adapter.to_s, queue_adapter)\n        else\n          if queue_adapter?(name_or_adapter)\n            adapter_name = ActiveJob.adapter_name(name_or_adapter).underscore\n            assign_adapter(adapter_name, name_or_adapter)\n          else\n            raise ArgumentError\n          end",
    "comment": "Specify the backend queue provider. The default queue adapter is the +:async+ queue. See QueueAdapters for more information.",
    "label": "",
    "id": "1106"
  },
  {
    "raw_code": "def lookup(name)\n        const_get(name.to_s.camelize << ADAPTER)\n      end",
    "comment": "Returns adapter for specified name.  ActiveJob::QueueAdapters.lookup(:sidekiq) # => ActiveJob::QueueAdapters::SidekiqAdapter",
    "label": "",
    "id": "1107"
  },
  {
    "raw_code": "def queue_as(part_name = nil, &block)\n        if block_given?\n          self.queue_name = block\n        else\n          self.queue_name = queue_name_from_part(part_name)\n        end",
    "comment": "Specifies the name of the queue to process the job on.  class PublishToFeedJob < ActiveJob::Base queue_as :feeds  def perform(post) post.to_feed! end end  Can be given a block that will evaluate in the context of the job so that a dynamic queue name can be applied:  class PublishToFeedJob < ApplicationJob queue_as do post = self.arguments.first  if post.paid? :paid_feeds else :feeds end end  def perform(post) post.to_feed! end end",
    "label": "",
    "id": "1108"
  },
  {
    "raw_code": "def queue_name\n      if @queue_name.is_a?(Proc)\n        @queue_name = self.class.queue_name_from_part(instance_exec(&@queue_name))\n      end",
    "comment": "Returns the name of the queue the job will be run on.",
    "label": "",
    "id": "1109"
  },
  {
    "raw_code": "def queue_with_priority(priority = nil, &block)\n        if block_given?\n          self.priority = block\n        else\n          self.priority = priority\n        end",
    "comment": "Specifies the priority of the queue to create the job with.  class PublishToFeedJob < ActiveJob::Base queue_with_priority 50  def perform(post) post.to_feed! end end  Can be given a block that will evaluate in the context of the job so that a dynamic priority can be applied:  class PublishToFeedJob < ApplicationJob queue_with_priority do post = self.arguments.first  if post.paid? 10 else 50 end end  def perform(post) post.to_feed! end end",
    "label": "",
    "id": "1110"
  },
  {
    "raw_code": "def priority\n      if @priority.is_a?(Proc)\n        @priority = instance_exec(&@priority)\n      end",
    "comment": "Returns the priority that the job will be created with",
    "label": "",
    "id": "1111"
  },
  {
    "raw_code": "def serialize(argument)\n        serializer = @serializers_index[argument.class] || serializers.find { |s| s.serialize?(argument) }\n        raise SerializationError.new(\"Unsupported argument type: #{argument.class.name}\") unless serializer\n        serializer.serialize(argument)\n      end",
    "comment": "Returns serialized representative of the passed object. Will look up through all known serializers. Raises ActiveJob::SerializationError if it can't find a proper serializer.",
    "label": "",
    "id": "1112"
  },
  {
    "raw_code": "def deserialize(argument)\n        serializer_name = argument[Arguments::OBJECT_SERIALIZER_KEY]\n        raise ArgumentError, \"Serializer name is not present in the argument: #{argument.inspect}\" unless serializer_name\n\n        serializer = serializer_name.safe_constantize\n        raise ArgumentError, \"Serializer #{serializer_name} is not known\" unless serializer\n\n        serializer.deserialize(argument)\n      end",
    "comment": "Returns deserialized object. Will look up through all known serializers. If no serializer found will raise <tt>ArgumentError</tt>.",
    "label": "",
    "id": "1113"
  },
  {
    "raw_code": "def add_serializers(*new_serializers)\n        new_serializers = new_serializers.flatten\n        new_serializers.map! do |s|\n          if s.is_a?(Class) && s < ObjectSerializer\n            s.instance\n          else\n            s\n          end",
    "comment": "Adds new serializers to a list of known serializers.",
    "label": "",
    "id": "1114"
  },
  {
    "raw_code": "def queue_adapter_for_test\n    end",
    "comment": "Returns a queue adapter instance to use with all Active Job test helpers. By default, returns an instance of ActiveJob::QueueAdapters::TestAdapter. Override this method to specify a different adapter. The adapter must implement the same interface as ActiveJob::QueueAdapters::TestAdapter.",
    "label": "",
    "id": "1115"
  },
  {
    "raw_code": "def assert_enqueued_jobs(number, only: nil, except: nil, queue: nil, &block)\n      require_active_job_test_adapter!(\"assert_enqueued_jobs\")\n\n      if block_given?\n        original_jobs = enqueued_jobs_with(only: only, except: except, queue: queue)\n\n        _assert_nothing_raised_or_warn(\"assert_enqueued_jobs\", &block)\n\n        new_jobs = enqueued_jobs_with(only: only, except: except, queue: queue)\n\n        actual_count = (new_jobs - original_jobs).count\n      else\n        actual_count = enqueued_jobs_with(only: only, except: except, queue: queue).count\n      end",
    "comment": "Asserts that the number of enqueued jobs matches the given number.  def test_jobs assert_enqueued_jobs 0 HelloJob.perform_later('david') assert_enqueued_jobs 1 HelloJob.perform_later('abdelkader') assert_enqueued_jobs 2 end  If a block is passed, asserts that the block will cause the specified number of jobs to be enqueued.  def test_jobs_again assert_enqueued_jobs 1 do HelloJob.perform_later('cristian') end  assert_enqueued_jobs 2 do HelloJob.perform_later('aaron') HelloJob.perform_later('rafael') end end  Asserts the number of times a specific job was enqueued by passing +:only+ option.  def test_logging_job assert_enqueued_jobs 1, only: LoggingJob do LoggingJob.perform_later HelloJob.perform_later('jeremy') end end  Asserts the number of times a job except specific class was enqueued by passing +:except+ option.  def test_logging_job assert_enqueued_jobs 1, except: HelloJob do LoggingJob.perform_later HelloJob.perform_later('jeremy') end end  +:only+ and +:except+ options accept Class, Array of Class, or Proc. When passed a Proc, a hash containing the job's class and it's argument are passed as argument.  Asserts the number of times a job is enqueued to a specific queue by passing +:queue+ option.  def test_logging_job assert_enqueued_jobs 2, queue: 'default' do LoggingJob.perform_later HelloJob.perform_later('elfassy') end end",
    "label": "",
    "id": "1116"
  },
  {
    "raw_code": "def assert_no_enqueued_jobs(only: nil, except: nil, queue: nil, &block)\n      require_active_job_test_adapter!(\"assert_no_enqueued_jobs\")\n\n      assert_enqueued_jobs 0, only: only, except: except, queue: queue, &block\n    end",
    "comment": "Asserts that no jobs have been enqueued.  def test_jobs assert_no_enqueued_jobs HelloJob.perform_later('jeremy') assert_enqueued_jobs 1 end  If a block is passed, asserts that the block will not cause any job to be enqueued.  def test_jobs_again assert_no_enqueued_jobs do # No job should be enqueued from this block end end  Asserts that no jobs of a specific kind are enqueued by passing +:only+ option.  def test_no_logging assert_no_enqueued_jobs only: LoggingJob do HelloJob.perform_later('jeremy') end end  Asserts that no jobs except specific class are enqueued by passing +:except+ option.  def test_no_logging assert_no_enqueued_jobs except: HelloJob do HelloJob.perform_later('jeremy') end end  +:only+ and +:except+ options accept Class, Array of Class, or Proc. When passed a Proc, a hash containing the job's class and it's argument are passed as argument.  Asserts that no jobs are enqueued to a specific queue by passing +:queue+ option  def test_no_logging assert_no_enqueued_jobs queue: 'default' do LoggingJob.set(queue: :some_queue).perform_later end end  Note: This assertion is simply a shortcut for:  assert_enqueued_jobs 0, &block",
    "label": "",
    "id": "1117"
  },
  {
    "raw_code": "def assert_performed_jobs(number, only: nil, except: nil, queue: nil, &block)\n      require_active_job_test_adapter!(\"assert_performed_jobs\")\n\n      if block_given?\n        original_count = performed_jobs.size\n\n        perform_enqueued_jobs(only: only, except: except, queue: queue, &block)\n\n        new_count = performed_jobs.size\n\n        performed_jobs_size = new_count - original_count\n      else\n        performed_jobs_size = performed_jobs_with(only: only, except: except, queue: queue).count\n      end",
    "comment": "Asserts that the number of performed jobs matches the given number. If no block is passed, <tt>perform_enqueued_jobs</tt> must be called around or after the job call.  def test_jobs assert_performed_jobs 0  perform_enqueued_jobs do HelloJob.perform_later('xavier') end assert_performed_jobs 1  HelloJob.perform_later('yves')  perform_enqueued_jobs  assert_performed_jobs 2 end  If a block is passed, asserts that the block will cause the specified number of jobs to be performed.  def test_jobs_again assert_performed_jobs 1 do HelloJob.perform_later('robin') end  assert_performed_jobs 2 do HelloJob.perform_later('carlos') HelloJob.perform_later('sean') end end  This method also supports filtering. If the +:only+ option is specified, then only the listed job(s) will be performed.  def test_hello_job assert_performed_jobs 1, only: HelloJob do HelloJob.perform_later('jeremy') LoggingJob.perform_later end end  Also if the +:except+ option is specified, then the job(s) except specific class will be performed.  def test_hello_job assert_performed_jobs 1, except: LoggingJob do HelloJob.perform_later('jeremy') LoggingJob.perform_later end end  An array may also be specified, to support testing multiple jobs.  def test_hello_and_logging_jobs assert_nothing_raised do assert_performed_jobs 2, only: [HelloJob, LoggingJob] do HelloJob.perform_later('jeremy') LoggingJob.perform_later('stewie') RescueJob.perform_later('david') end end end  A proc may also be specified. When passed a Proc, the job's instance will be passed as argument.  def test_hello_and_logging_jobs assert_nothing_raised do assert_performed_jobs(1, only: ->(job) { job.is_a?(HelloJob) }) do HelloJob.perform_later('jeremy') LoggingJob.perform_later('stewie') RescueJob.perform_later('david') end end end  If the +:queue+ option is specified, then only the job(s) enqueued to a specific queue will be performed.  def test_assert_performed_jobs_with_queue_option assert_performed_jobs 1, queue: :some_queue do HelloJob.set(queue: :some_queue).perform_later(\"jeremy\") HelloJob.set(queue: :other_queue).perform_later(\"bogdan\") end end",
    "label": "",
    "id": "1118"
  },
  {
    "raw_code": "def assert_no_performed_jobs(only: nil, except: nil, queue: nil, &block)\n      require_active_job_test_adapter!(\"assert_no_performed_jobs\")\n\n      assert_performed_jobs 0, only: only, except: except, queue: queue, &block\n    end",
    "comment": "Asserts that no jobs have been performed.  def test_jobs assert_no_performed_jobs  perform_enqueued_jobs do HelloJob.perform_later('matthew') assert_performed_jobs 1 end end  If a block is passed, asserts that the block will not cause any job to be performed.  def test_jobs_again assert_no_performed_jobs do # No job should be performed from this block end end  The block form supports filtering. If the +:only+ option is specified, then only the listed job(s) will not be performed.  def test_no_logging assert_no_performed_jobs only: LoggingJob do HelloJob.perform_later('jeremy') end end  Also if the +:except+ option is specified, then the job(s) except specific class will not be performed.  def test_no_logging assert_no_performed_jobs except: HelloJob do HelloJob.perform_later('jeremy') end end  +:only+ and +:except+ options accept Class, Array of Class, or Proc. When passed a Proc, an instance of the job will be passed as argument.  If the +:queue+ option is specified, then only the job(s) enqueued to a specific queue will not be performed.  def test_assert_no_performed_jobs_with_queue_option assert_no_performed_jobs queue: :some_queue do HelloJob.set(queue: :other_queue).perform_later(\"jeremy\") end end  Note: This assertion is simply a shortcut for:  assert_performed_jobs 0, &block",
    "label": "",
    "id": "1119"
  },
  {
    "raw_code": "def assert_enqueued_with(job: nil, args: nil, at: nil, queue: nil, priority: nil, &block)\n      require_active_job_test_adapter!(\"assert_enqueued_with\")\n\n      expected = { job: job, args: args, at: at, queue: queue, priority: priority }.compact\n      expected_args = prepare_args_for_assertion(expected)\n      potential_matches = []\n\n      if block_given?\n        original_enqueued_jobs = enqueued_jobs.dup\n\n        _assert_nothing_raised_or_warn(\"assert_enqueued_with\", &block)\n\n        jobs = enqueued_jobs - original_enqueued_jobs\n      else\n        jobs = enqueued_jobs\n      end",
    "comment": "Asserts that the job has been enqueued with the given arguments.  def test_assert_enqueued_with MyJob.perform_later(1,2,3) assert_enqueued_with(job: MyJob, args: [1,2,3])  MyJob.set(wait_until: Date.tomorrow.noon, queue: \"my_queue\").perform_later assert_enqueued_with(at: Date.tomorrow.noon, queue: \"my_queue\") end  For keyword arguments, specify them as a hash inside an array:  def test_assert_enqueued_with_keyword_arguments MyJob.perform_later(arg1: 'value1', arg2: 'value2') assert_enqueued_with(job: MyJob, args: [{ arg1: 'value1', arg2: 'value2' }]) end  The given arguments may also be specified as matcher procs that return a boolean value indicating whether a job's attribute meets certain criteria.  For example, a proc can be used to match a range of times:  def test_assert_enqueued_with at_matcher = ->(job_at) { (Date.yesterday..Date.tomorrow).cover?(job_at) }  MyJob.set(wait_until: Date.today.noon).perform_later  assert_enqueued_with(job: MyJob, at: at_matcher) end  A proc can also be used to match a subset of a job's args:  def test_assert_enqueued_with args_matcher = ->(job_args) { job_args[0].key?(:foo) }  MyJob.perform_later(foo: \"bar\", other_arg: \"No need to check in the test\")  assert_enqueued_with(job: MyJob, args: args_matcher) end  If a block is passed, asserts that the block will cause the job to be enqueued with the given arguments.  def test_assert_enqueued_with assert_enqueued_with(job: MyJob, args: [1,2,3]) do MyJob.perform_later(1,2,3) end  assert_enqueued_with(job: MyJob, at: Date.tomorrow.noon) do MyJob.set(wait_until: Date.tomorrow.noon).perform_later end end",
    "label": "",
    "id": "1120"
  },
  {
    "raw_code": "def assert_performed_with(job: nil, args: nil, at: nil, queue: nil, priority: nil, &block)\n      require_active_job_test_adapter!(\"assert_performed_with\")\n\n      expected = { job: job, args: args, at: at, queue: queue, priority: priority }.compact\n      expected_args = prepare_args_for_assertion(expected)\n      potential_matches = []\n\n      if block_given?\n        original_performed_jobs_count = performed_jobs.count\n\n        perform_enqueued_jobs(&block)\n\n        jobs = performed_jobs.drop(original_performed_jobs_count)\n      else\n        jobs = performed_jobs\n      end",
    "comment": "Asserts that the job has been performed with the given arguments.  def test_assert_performed_with MyJob.perform_later(1,2,3)  perform_enqueued_jobs  assert_performed_with(job: MyJob, args: [1,2,3])  MyJob.set(wait_until: Date.tomorrow.noon, queue: \"my_queue\").perform_later  perform_enqueued_jobs  assert_performed_with(at: Date.tomorrow.noon, queue: \"my_queue\") end  The given arguments may also be specified as matcher procs that return a boolean value indicating whether a job's attribute meets certain criteria.  For example, a proc can be used to match a range of times:  def test_assert_performed_with at_matcher = ->(job_at) { (Date.yesterday..Date.tomorrow).cover?(job_at) }  MyJob.set(wait_until: Date.today.noon).perform_later  perform_enqueued_jobs  assert_performed_with(job: MyJob, at: at_matcher) end  A proc can also be used to match a subset of a job's args:  def test_assert_performed_with args_matcher = ->(job_args) { job_args[0].key?(:foo) }  MyJob.perform_later(foo: \"bar\", other_arg: \"No need to check in the test\")  perform_enqueued_jobs  assert_performed_with(job: MyJob, args: args_matcher) end  If a block is passed, that block performs all of the jobs that were enqueued throughout the duration of the block and asserts that the job has been performed with the given arguments in the block.  def test_assert_performed_with assert_performed_with(job: MyJob, args: [1,2,3]) do MyJob.perform_later(1,2,3) end  assert_performed_with(job: MyJob, at: Date.tomorrow.noon) do MyJob.set(wait_until: Date.tomorrow.noon).perform_later end end",
    "label": "",
    "id": "1121"
  },
  {
    "raw_code": "def perform_enqueued_jobs(only: nil, except: nil, queue: nil, at: nil, &block)\n      unless block_given?\n        require_active_job_test_adapter!(\"perform_enqueued_jobs (without a block)\")\n        return flush_enqueued_jobs(only: only, except: except, queue: queue, at: at)\n      end",
    "comment": "Performs all enqueued jobs. If a block is given, performs all of the jobs that were enqueued throughout the duration of the block. If a block is not given, performs all of the enqueued jobs up to this point in the test.  def test_perform_enqueued_jobs perform_enqueued_jobs do MyJob.perform_later(1, 2, 3) end assert_performed_jobs 1 end  def test_perform_enqueued_jobs_without_block MyJob.perform_later(1, 2, 3)  perform_enqueued_jobs  assert_performed_jobs 1 end  This method also supports filtering. If the +:only+ option is specified, then only the listed job(s) will be performed.  def test_perform_enqueued_jobs_with_only perform_enqueued_jobs(only: MyJob) do MyJob.perform_later(1, 2, 3) # will be performed HelloJob.perform_later(1, 2, 3) # will not be performed end assert_performed_jobs 1 end  Also if the +:except+ option is specified, then the job(s) except specific class will be performed.  def test_perform_enqueued_jobs_with_except perform_enqueued_jobs(except: HelloJob) do MyJob.perform_later(1, 2, 3) # will be performed HelloJob.perform_later(1, 2, 3) # will not be performed end assert_performed_jobs 1 end  +:only+ and +:except+ options accept Class, Array of Class, or Proc. When passed a Proc, an instance of the job will be passed as argument.  If the +:queue+ option is specified, then only the job(s) enqueued to a specific queue will be performed.  def test_perform_enqueued_jobs_with_queue perform_enqueued_jobs queue: :some_queue do MyJob.set(queue: :some_queue).perform_later(1, 2, 3) # will be performed HelloJob.set(queue: :other_queue).perform_later(1, 2, 3) # will not be performed end assert_performed_jobs 1 end  If the +:at+ option is specified, then only jobs that have been enqueued to run at or before the given time will be performed. This includes jobs that have been enqueued without a time.  If queue_adapter_for_test is overridden to return a different adapter, +perform_enqueued_jobs+ will merely execute the block.",
    "label": "",
    "id": "1122"
  },
  {
    "raw_code": "def queue_adapter\n      ActiveJob::Base.queue_adapter\n    end",
    "comment": "Accesses the queue_adapter set by ActiveJob::Base.  def test_assert_job_has_custom_queue_adapter_set assert_instance_of CustomQueueAdapter, HelloJob.queue_adapter end",
    "label": "",
    "id": "1123"
  },
  {
    "raw_code": "def self.version\n    gem_version\n  end",
    "comment": "Returns the currently loaded version of Active Job as a +Gem::Version+.",
    "label": "",
    "id": "1124"
  },
  {
    "raw_code": "def checkpoint!\n        job.checkpoint!\n      end",
    "comment": "Check if the job should be interrupted, and if so raise an Interrupt exception. The job will be requeued for retry.",
    "label": "",
    "id": "1125"
  },
  {
    "raw_code": "def set!(cursor)\n        @cursor = cursor\n        checkpoint!\n      end",
    "comment": "Set the cursor and interrupt the job if necessary.",
    "label": "",
    "id": "1126"
  },
  {
    "raw_code": "def advance!(from: nil)\n        from = cursor if from.nil?\n\n        begin\n          to = from.succ\n        rescue NoMethodError\n          raise UnadvanceableCursorError, \"Cursor class '#{from.class}' does not implement 'succ'\"\n        end",
    "comment": "Advance the cursor from the current or supplied value  The cursor will be advanced by calling the +succ+ method on the cursor. An UnadvanceableCursorError error will be raised if the cursor does not implement +succ+.",
    "label": "",
    "id": "1127"
  },
  {
    "raw_code": "def resumed?\n        @resumed\n      end",
    "comment": "Has this step been resumed from a previous job execution?",
    "label": "",
    "id": "1128"
  },
  {
    "raw_code": "def advanced?\n        initial_cursor != cursor\n      end",
    "comment": "Has the cursor been advanced during this job execution?",
    "label": "",
    "id": "1129"
  },
  {
    "raw_code": "def interrupt_job_during_step(job, step, cursor: nil, &block)\n        require_active_job_test_adapter!(\"interrupt_job_during_step\")\n        queue_adapter.with(stopping: ->() { during_step?(job, step, cursor: cursor) }, &block)\n      end",
    "comment": "Interrupt a job during a step.  class MyJob < ApplicationJob include ActiveJob::Continuable  cattr_accessor :items, default: [] def perform step :my_step, start: 1 do |step| (step.cursor..10).each do |i| items << i step.advance! end end end end  test \"interrupt job during step\" do MyJob.perform_later interrupt_job_during_step(MyJob, :my_step, cursor: 6) { perform_enqueued_jobs } assert_equal [1, 2, 3, 4, 5], MyJob.items perform_enqueued_jobs assert_equal [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], MyJob.items end",
    "label": "",
    "id": "1130"
  },
  {
    "raw_code": "def interrupt_job_after_step(job, step, &block)\n        require_active_job_test_adapter!(\"interrupt_job_after_step\")\n        queue_adapter.with(stopping: ->() { after_step?(job, step) }, &block)\n      end",
    "comment": "Interrupt a job after a step.  Note that there's no checkpoint after the final step so it won't be interrupted.  class MyJob < ApplicationJob include ActiveJob::Continuable  cattr_accessor :items, default: []  def perform step :step_one { items << 1 } step :step_two { items << 2 } step :step_three { items << 3 } step :step_four { items << 4 } end end  test \"interrupt job after step\" do MyJob.perform_later interrupt_job_after_step(MyJob, :step_two) { perform_enqueued_jobs } assert_equal [1, 2], MyJob.items perform_enqueued_jobs assert_equal [1, 2, 3, 4], MyJob.items end",
    "label": "",
    "id": "1131"
  },
  {
    "raw_code": "def initialize(**executor_options)\n        @scheduler = Scheduler.new(**executor_options)\n      end",
    "comment": "See {Concurrent::ThreadPoolExecutor}[https://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent/ThreadPoolExecutor.html] for executor options.",
    "label": "",
    "id": "1132"
  },
  {
    "raw_code": "def shutdown(wait: true) # :nodoc:\n        @scheduler.shutdown wait: wait\n      end",
    "comment": "Gracefully stop processing jobs. Finishes in-progress work and handles any new jobs following the executor's fallback policy (`caller_runs`). Waits for termination by default. Pass `wait: false` to continue.",
    "label": "",
    "id": "1133"
  },
  {
    "raw_code": "def immediate=(immediate) # :nodoc:\n        @scheduler.immediate = immediate\n      end",
    "comment": "Used for our test suite.",
    "label": "",
    "id": "1134"
  },
  {
    "raw_code": "def build_queue(queue_name)\n        QC::Queue.new(queue_name)\n      end",
    "comment": "Builds a +QC::Queue+ object to schedule jobs on.  If you have a custom +QC::Queue+ subclass you'll need to subclass +ActiveJob::QueueAdapters::QueueClassicAdapter+ and override the <tt>build_queue</tt> method.",
    "label": "",
    "id": "1135"
  },
  {
    "raw_code": "def enqueued_jobs\n        @enqueued_jobs ||= []\n      end",
    "comment": "Provides a store of all the enqueued jobs with the TestAdapter so you can check them.",
    "label": "",
    "id": "1136"
  },
  {
    "raw_code": "def performed_jobs\n        @performed_jobs ||= []\n      end",
    "comment": "Provides a store of all the performed jobs with the TestAdapter so you can check them.",
    "label": "",
    "id": "1137"
  },
  {
    "raw_code": "def serialize?(argument)\n        argument.is_a?(klass)\n      end",
    "comment": "Determines if an argument should be serialized by a serializer.",
    "label": "",
    "id": "1138"
  },
  {
    "raw_code": "def serialize(hash)\n        @template.merge(hash)\n      end",
    "comment": "Serializes an argument to a JSON primitive type.",
    "label": "",
    "id": "1139"
  },
  {
    "raw_code": "def deserialize(hash)\n        raise NotImplementedError, \"#{self.class.name} should implement a public #deserialize(hash) method\"\n      end",
    "comment": "Deserializes an argument from a JSON primitive type.",
    "label": "",
    "id": "1140"
  },
  {
    "raw_code": "def lock_exclusively!(max_run_time, worker)\n          now = self.class.db_time_now\n          if locked_by != worker\n            # We don't own this job so we will update the locked_by name and the locked_at\n            self.locked_at = now\n            self.locked_by = worker\n          end",
    "comment": "Lock this job for this worker. Returns true if we have the lock, false otherwise.",
    "label": "",
    "id": "1141"
  },
  {
    "raw_code": "def initialize(attributes = {})\n      assign_attributes(attributes) if attributes\n\n      super()\n    end",
    "comment": "Initializes a new model with the given +params+.  class Person include ActiveModel::API attr_accessor :name, :age end  person = Person.new(name: 'bob', age: '18') person.name # => \"bob\" person.age  # => \"18\"",
    "label": "",
    "id": "1142"
  },
  {
    "raw_code": "def persisted?\n      false\n    end",
    "comment": "Indicates if the model is persisted. Default is +false+.  class Person include ActiveModel::API attr_accessor :id, :name end  person = Person.new(id: 1, name: 'bob') person.persisted? # => false",
    "label": "",
    "id": "1143"
  },
  {
    "raw_code": "def initialize(name, value_before_type_cast, type, original_attribute = nil, value = nil)\n      @name = name\n      @value_before_type_cast = value_before_type_cast\n      @type = type\n      @original_attribute = original_attribute\n      @value = value unless value.nil?\n    end",
    "comment": "This method should not be called directly. Use #from_database or #from_user",
    "label": "",
    "id": "1144"
  },
  {
    "raw_code": "def attribute(name, ...)\n        super\n        define_attribute_method(name)\n      end",
    "comment": " :call-seq: attribute(name, cast_type = nil, default: nil, **options)  Defines a model attribute. In addition to the attribute name, a cast type and default value may be specified, as well as any options supported by the given cast type.  class Person include ActiveModel::Attributes  attribute :name, :string attribute :active, :boolean, default: true end  person = Person.new person.name = \"Volmer\"  person.name   # => \"Volmer\" person.active # => true",
    "label": "",
    "id": "1145"
  },
  {
    "raw_code": "def attribute_names\n        attribute_types.keys\n      end",
    "comment": "Returns an array of attribute names as strings.  class Person include ActiveModel::Attributes  attribute :name, :string attribute :age, :integer end  Person.attribute_names # => [\"name\", \"age\"]",
    "label": "",
    "id": "1146"
  },
  {
    "raw_code": "def attributes\n      @attributes.to_hash\n    end",
    "comment": "Returns a hash of all the attributes with their names as keys and the values of the attributes as values.  class Person include ActiveModel::Attributes  attribute :name, :string attribute :age, :integer end  person = Person.new person.name = \"Francesco\" person.age = 22  person.attributes # => { \"name\" => \"Francesco\", \"age\" => 22}",
    "label": "",
    "id": "1147"
  },
  {
    "raw_code": "def attribute_names\n      @attributes.keys\n    end",
    "comment": "Returns an array of attribute names as strings.  class Person include ActiveModel::Attributes  attribute :name, :string attribute :age, :integer end  person = Person.new person.attribute_names # => [\"name\", \"age\"]",
    "label": "",
    "id": "1148"
  },
  {
    "raw_code": "def assign_attributes(new_attributes)\n      unless new_attributes.respond_to?(:each_pair)\n        raise ArgumentError, \"When assigning attributes, you must pass a hash as an argument, #{new_attributes.class} passed.\"\n      end",
    "comment": "Allows you to set all the attributes by passing in a hash of attributes with keys matching the attribute names.  If the passed hash responds to <tt>permitted?</tt> method and the return value of this method is +false+ an ActiveModel::ForbiddenAttributesError exception is raised.  class Cat include ActiveModel::AttributeAssignment attr_accessor :name, :status end  cat = Cat.new cat.assign_attributes(name: \"Gorby\", status: \"yawning\") cat.name # => 'Gorby' cat.status # => 'yawning' cat.assign_attributes(status: \"sleeping\") cat.name # => 'Gorby' cat.status # => 'sleeping'",
    "label": "",
    "id": "1149"
  },
  {
    "raw_code": "def attribute_writer_missing(name, value)\n      raise UnknownAttributeError.new(self, name)\n    end",
    "comment": "Like `BasicObject#method_missing`, `#attribute_writer_missing` is invoked when `#assign_attributes` is passed an unknown attribute name.  By default, `#attribute_writer_missing` raises an UnknownAttributeError.  class Rectangle include ActiveModel::AttributeAssignment  attr_accessor :length, :width  def attribute_writer_missing(name, value) Rails.logger.warn \"Tried to assign to unknown attribute #{name}\" end end  rectangle = Rectangle.new rectangle.assign_attributes(height: 10) # => Logs \"Tried to assign to unknown attribute 'height'\"",
    "label": "",
    "id": "1150"
  },
  {
    "raw_code": "def attribute_method_prefix(*prefixes, parameters: nil)\n        self.attribute_method_patterns += prefixes.map! { |prefix| AttributeMethodPattern.new(prefix: prefix, parameters: parameters) }\n        undefine_attribute_methods\n      end",
    "comment": "Declares a method available for all attributes with the given prefix. Uses +method_missing+ and <tt>respond_to?</tt> to rewrite the method.  #{prefix}#{attr}(*args, &block)  to  #{prefix}attribute(#{attr}, *args, &block)  An instance method <tt>#{prefix}attribute</tt> must exist and accept at least the +attr+ argument.  class Person include ActiveModel::AttributeMethods  attr_accessor :name attribute_method_prefix 'clear_' define_attribute_methods :name  private def clear_attribute(attr) send(\"#{attr}=\", nil) end end  person = Person.new person.name = 'Bob' person.name          # => \"Bob\" person.clear_name person.name          # => nil",
    "label": "",
    "id": "1151"
  },
  {
    "raw_code": "def attribute_method_suffix(*suffixes, parameters: nil)\n        self.attribute_method_patterns += suffixes.map! { |suffix| AttributeMethodPattern.new(suffix: suffix, parameters: parameters) }\n        undefine_attribute_methods\n      end",
    "comment": "Declares a method available for all attributes with the given suffix. Uses +method_missing+ and <tt>respond_to?</tt> to rewrite the method.  #{attr}#{suffix}(*args, &block)  to  attribute#{suffix}(#{attr}, *args, &block)  An <tt>attribute#{suffix}</tt> instance method must exist and accept at least the +attr+ argument.  class Person include ActiveModel::AttributeMethods  attr_accessor :name attribute_method_suffix '_short?' define_attribute_methods :name  private def attribute_short?(attr) send(attr).length < 5 end end  person = Person.new person.name = 'Bob' person.name          # => \"Bob\" person.name_short?   # => true",
    "label": "",
    "id": "1152"
  },
  {
    "raw_code": "def attribute_method_affix(*affixes)\n        self.attribute_method_patterns += affixes.map! { |affix| AttributeMethodPattern.new(**affix) }\n        undefine_attribute_methods\n      end",
    "comment": "Declares a method available for all attributes with the given prefix and suffix. Uses +method_missing+ and <tt>respond_to?</tt> to rewrite the method.  #{prefix}#{attr}#{suffix}(*args, &block)  to  #{prefix}attribute#{suffix}(#{attr}, *args, &block)  An <tt>#{prefix}attribute#{suffix}</tt> instance method must exist and accept at least the +attr+ argument.  class Person include ActiveModel::AttributeMethods  attr_accessor :name attribute_method_affix prefix: 'reset_', suffix: '_to_default!' define_attribute_methods :name  private def reset_attribute_to_default!(attr) send(\"#{attr}=\", 'Default Name') end end  person = Person.new person.name                         # => 'Gem' person.reset_name_to_default! person.name                         # => 'Default Name'",
    "label": "",
    "id": "1153"
  },
  {
    "raw_code": "def alias_attribute(new_name, old_name)\n        old_name = old_name.to_s\n        new_name = new_name.to_s\n        self.attribute_aliases = attribute_aliases.merge(new_name => old_name)\n        aliases_by_attribute_name[old_name] << new_name\n        eagerly_generate_alias_attribute_methods(new_name, old_name)\n      end",
    "comment": "Allows you to make aliases for attributes.  class Person include ActiveModel::AttributeMethods  attr_accessor :name attribute_method_suffix '_short?' define_attribute_methods :name  alias_attribute :nickname, :name  private def attribute_short?(attr) send(attr).length < 5 end end  person = Person.new person.name = 'Bob' person.name            # => \"Bob\" person.nickname        # => \"Bob\" person.name_short?     # => true person.nickname_short? # => true",
    "label": "",
    "id": "1154"
  },
  {
    "raw_code": "def attribute_alias?(new_name)\n        attribute_aliases.key? new_name.to_s\n      end",
    "comment": "Is +new_name+ an alias?",
    "label": "",
    "id": "1155"
  },
  {
    "raw_code": "def attribute_alias(name)\n        attribute_aliases[name.to_s]\n      end",
    "comment": "Returns the original name for the alias +name+",
    "label": "",
    "id": "1156"
  },
  {
    "raw_code": "def define_attribute_methods(*attr_names)\n        ActiveSupport::CodeGenerator.batch(generated_attribute_methods, __FILE__, __LINE__) do |owner|\n          attr_names.flatten.each do |attr_name|\n            define_attribute_method(attr_name, _owner: owner)\n            aliases_by_attribute_name[attr_name.to_s].each do |aliased_name|\n              generate_alias_attribute_methods owner, aliased_name, attr_name\n            end",
    "comment": "Declares the attributes that should be prefixed and suffixed by +ActiveModel::AttributeMethods+.  To use, pass attribute names (as strings or symbols). Be sure to declare +define_attribute_methods+ after you define any prefix, suffix, or affix methods, or they will not hook in.  class Person include ActiveModel::AttributeMethods  attr_accessor :name, :age, :address attribute_method_prefix 'clear_'  # Call to define_attribute_methods must appear after the # attribute_method_prefix, attribute_method_suffix or # attribute_method_affix declarations. define_attribute_methods :name, :age, :address  private def clear_attribute(attr) send(\"#{attr}=\", nil) end end",
    "label": "",
    "id": "1157"
  },
  {
    "raw_code": "def define_attribute_method(attr_name, _owner: generated_attribute_methods, as: attr_name)\n        ActiveSupport::CodeGenerator.batch(_owner, __FILE__, __LINE__) do |owner|\n          attribute_method_patterns.each do |pattern|\n            define_attribute_method_pattern(pattern, attr_name, owner: owner, as: as)\n          end",
    "comment": "Declares an attribute that should be prefixed and suffixed by +ActiveModel::AttributeMethods+.  To use, pass an attribute name (as string or symbol). Be sure to declare +define_attribute_method+ after you define any prefix, suffix or affix method, or they will not hook in.  class Person include ActiveModel::AttributeMethods  attr_accessor :name attribute_method_suffix '_short?'  # Call to define_attribute_method must appear after the # attribute_method_prefix, attribute_method_suffix or # attribute_method_affix declarations. define_attribute_method :name  private def attribute_short?(attr) send(attr).length < 5 end end  person = Person.new person.name = 'Bob' person.name        # => \"Bob\" person.name_short? # => true",
    "label": "",
    "id": "1158"
  },
  {
    "raw_code": "def undefine_attribute_methods\n        @generated_attribute_methods&.module_eval do\n          undef_method(*instance_methods)\n        end",
    "comment": "Removes all the previously dynamically defined methods from the class, including alias attribute methods.  class Person include ActiveModel::AttributeMethods  attr_accessor :name attribute_method_suffix '_short?' define_attribute_method :name alias_attribute :first_name, :name  private def attribute_short?(attr) send(attr).length < 5 end end  person = Person.new person.name = 'Bob' person.first_name  # => \"Bob\" person.name_short? # => true  Person.undefine_attribute_methods  person.name_short? # => NoMethodError person.first_name  # => NoMethodError",
    "label": "",
    "id": "1159"
  },
  {
    "raw_code": "def attribute_method_patterns_cache\n          @attribute_method_patterns_cache ||= Concurrent::Map.new(initial_capacity: 4)\n        end",
    "comment": "The methods +method_missing+ and +respond_to?+ of this module are invoked often in a typical rails, both of which invoke the method +matched_attribute_method+. The latter method iterates through an array doing regular expression matches, which results in a lot of object creations. Most of the time it returns a +nil+ match. As the match result is always the same given a +method_name+, this cache is used to alleviate the GC, which ultimately also speeds up the app significantly (in our case our test suite finishes 10% faster with this cache).",
    "label": "",
    "id": "1160"
  },
  {
    "raw_code": "def define_proxy_call(code_generator, name, proxy_target, parameters, *call_args, namespace:, as: name)\n          mangled_name = build_mangled_name(name)\n\n          call_args.map!(&:inspect)\n          call_args << parameters if parameters\n\n          # We have to use a different namespace for every target method, because\n          # if someone defines an attribute that look like an attribute method we could clash, e.g.\n          #   attribute :title_was\n          #   attribute :title\n          namespace = :\"#{namespace}_#{proxy_target}\"\n\n          define_call(code_generator, name, proxy_target, mangled_name, parameters, call_args, namespace: namespace, as: as)\n        end",
    "comment": "Define a method `name` in `mod` that dispatches to `send` using the given `extra` args. This falls back on `send` if the called name cannot be compiled.",
    "label": "",
    "id": "1161"
  },
  {
    "raw_code": "def method_missing(method, ...)\n      if respond_to_without_attributes?(method, true)\n        super\n      else\n        match = matched_attribute_method(method.name)\n        match ? attribute_missing(match, ...) : super\n      end",
    "comment": "Allows access to the object attributes, which are held in the hash returned by <tt>attributes</tt>, as though they were first-class methods. So a +Person+ class with a +name+ attribute can for example use <tt>Person#name</tt> and <tt>Person#name=</tt> and never directly use the attributes hash -- except for multiple assignments with <tt>ActiveRecord::Base#attributes=</tt>.  It's also possible to instantiate related objects, so a <tt>Client</tt> class belonging to the +clients+ table with a +master_id+ foreign key can instantiate master through <tt>Client#master</tt>.",
    "label": "",
    "id": "1162"
  },
  {
    "raw_code": "def attribute_missing(match, ...)\n      __send__(match.proxy_target, match.attr_name, ...)\n    end",
    "comment": "+attribute_missing+ is like +method_missing+, but for attributes. When +method_missing+ is called we check to see if there is a matching attribute method. If so, we tell +attribute_missing+ to dispatch the attribute. This method can be overloaded to customize the behavior.",
    "label": "",
    "id": "1163"
  },
  {
    "raw_code": "def matched_attribute_method(method_name)\n        matches = self.class.send(:attribute_method_patterns_matching, method_name)\n        matches.detect { |match| attribute_method?(match.attr_name) }\n      end",
    "comment": "Returns a struct representing the matching attribute method. The struct's attributes are prefix, base and suffix.",
    "label": "",
    "id": "1164"
  },
  {
    "raw_code": "def self.define_attribute_accessor_method(owner, attr_name, writer: false)\n          method_name = \"#{attr_name}#{'=' if writer}\"\n          if attr_name.ascii_only? && DEF_SAFE_NAME.match?(attr_name)\n            yield method_name, \"'#{attr_name}'\"\n          else\n            safe_name = attr_name.unpack1(\"h*\")\n            const_name = \"ATTR_#{safe_name}\"\n            const_set(const_name, attr_name) unless const_defined?(const_name)\n            temp_method_name = \"__temp__#{safe_name}#{'=' if writer}\"\n            attr_name_expr = \"::ActiveModel::AttributeMethods::AttrNames::#{const_name}\"\n            yield temp_method_name, attr_name_expr\n          end",
    "comment": "We want to generate the methods via module_eval rather than define_method, because define_method is slower on dispatch.  But sometimes the database might return columns with characters that are not allowed in normal method names (like 'my_column(omg)'. So to work around this we first define with the __temp__ identifier, and then use alias method to rename it to what we want.  We are also defining a constant to hold the frozen string of the attribute name. Using a constant means that we do not have to allocate an object on each call to the attribute method. Making it frozen means that it doesn't get duped when used to key the @attributes in read_attribute.",
    "label": "",
    "id": "1165"
  },
  {
    "raw_code": "def hook_attribute_type(attribute, type)\n          type\n        end",
    "comment": "Hook for other modules to override. The attribute type is passed through this method immediately after it is resolved, before any type decorations are applied.",
    "label": "",
    "id": "1166"
  },
  {
    "raw_code": "def define_model_callbacks(*callbacks)\n      options = callbacks.extract_options!\n      options = {\n        skip_after_callbacks_if_terminated: true,\n        scope: [:kind, :name],\n        only: [:before, :around, :after]\n      }.merge!(options)\n\n      types = Array(options.delete(:only))\n\n      callbacks.each do |callback|\n        define_callbacks(callback, options)\n\n        types.each do |type|\n          send(\"_define_#{type}_model_callback\", self, callback)\n        end",
    "comment": "+define_model_callbacks+ accepts the same options +define_callbacks+ does, in case you want to overwrite a default. Besides that, it also accepts an <tt>:only</tt> option, where you can choose if you want all types (before, around or after) or just some.  define_model_callbacks :initialize, only: :after  Note, the <tt>only: <type></tt> hash will apply to all callbacks defined on that method call. To get around this you can call the +define_model_callbacks+ method as many times as you need.  define_model_callbacks :create,  only: :after define_model_callbacks :update,  only: :before define_model_callbacks :destroy, only: :around  Would create +after_create+, +before_update+, and +around_destroy+ methods only.  You can pass in a class to before_<type>, after_<type> and around_<type>, in which case the callback will call that class's <action>_<type> method passing the object that the callback is being called on.  class MyModel extend ActiveModel::Callbacks define_model_callbacks :create  before_create AnotherClass end  class AnotherClass def self.before_create( obj ) # obj is the MyModel instance that the callback is being called on end end  NOTE: +method_name+ passed to +define_model_callbacks+ must not end with <tt>!</tt>, <tt>?</tt> or <tt>=</tt>.",
    "label": "",
    "id": "1167"
  },
  {
    "raw_code": "def to_model\n      self\n    end",
    "comment": "If your object is already designed to implement all of the \\Active \\Model you can use the default <tt>:to_model</tt> implementation, which simply returns +self+.  class Person include ActiveModel::Conversion end  person = Person.new person.to_model == person # => true  If your model does not act like an \\Active \\Model object, then you should define <tt>:to_model</tt> yourself returning a proxy object that wraps your object with \\Active \\Model compliant methods.",
    "label": "",
    "id": "1168"
  },
  {
    "raw_code": "def to_key\n      key = respond_to?(:id) && id\n      key ? Array(key) : nil\n    end",
    "comment": "Returns an Array of all key attributes if any of the attributes is set, whether or not the object is persisted. Returns +nil+ if there are no key attributes.  class Person include ActiveModel::Conversion attr_accessor :id  def initialize(id) @id = id end end  person = Person.new(1) person.to_key # => [1]",
    "label": "",
    "id": "1169"
  },
  {
    "raw_code": "def to_param\n      (persisted? && (key = to_key) && key.all?) ? key.join(self.class.param_delimiter) : nil\n    end",
    "comment": "Returns a +string+ representing the object's key suitable for use in URLs, or +nil+ if <tt>persisted?</tt> is +false+.  class Person include ActiveModel::Conversion attr_accessor :id  def initialize(id) @id = id end  def persisted? true end end  person = Person.new(1) person.to_param # => \"1\"",
    "label": "",
    "id": "1170"
  },
  {
    "raw_code": "def to_partial_path\n      self.class._to_partial_path\n    end",
    "comment": "Returns a +string+ identifying the path associated with the object. ActionPack uses this to find a suitable partial to represent the object.  class Person include ActiveModel::Conversion end  person = Person.new person.to_partial_path # => \"people/person\"",
    "label": "",
    "id": "1171"
  },
  {
    "raw_code": "def _to_partial_path # :nodoc:\n        @_to_partial_path ||= if respond_to?(:model_name)\n          \"#{model_name.collection}/#{model_name.element}\"\n        else\n          element = ActiveSupport::Inflector.underscore(ActiveSupport::Inflector.demodulize(name))\n          collection = ActiveSupport::Inflector.tableize(name)\n          \"#{collection}/#{element}\"\n        end",
    "comment": "Provide a class level cache for #to_partial_path. This is an internal method and should not be accessed directly.",
    "label": "",
    "id": "1172"
  },
  {
    "raw_code": "def changes_applied\n      unless defined?(@attributes)\n        mutations_from_database.finalize_changes\n      end",
    "comment": "Clears dirty data and moves +changes+ to +previous_changes+ and +mutations_from_database+ to +mutations_before_last_save+ respectively.",
    "label": "",
    "id": "1173"
  },
  {
    "raw_code": "def changed?\n      mutations_from_database.any_changes?\n    end",
    "comment": "Returns +true+ if any of the attributes has unsaved changes, +false+ otherwise.  person.changed? # => false person.name = 'bob' person.changed? # => true",
    "label": "",
    "id": "1174"
  },
  {
    "raw_code": "def changed\n      mutations_from_database.changed_attribute_names\n    end",
    "comment": "Returns an array with the name of the attributes with unsaved changes.  person.changed # => [] person.name = 'bob' person.changed # => [\"name\"]",
    "label": "",
    "id": "1175"
  },
  {
    "raw_code": "def attribute_changed?(attr_name, **options)\n      mutations_from_database.changed?(attr_name.to_s, **options)\n    end",
    "comment": "Dispatch target for {*_changed?}[rdoc-ref:#*_changed?] attribute methods.",
    "label": "",
    "id": "1176"
  },
  {
    "raw_code": "def attribute_was(attr_name)\n      mutations_from_database.original_value(attr_name.to_s)\n    end",
    "comment": "Dispatch target for {*_was}[rdoc-ref:#*_was] attribute methods.",
    "label": "",
    "id": "1177"
  },
  {
    "raw_code": "def attribute_previously_changed?(attr_name, **options)\n      mutations_before_last_save.changed?(attr_name.to_s, **options)\n    end",
    "comment": "Dispatch target for {*_previously_changed?}[rdoc-ref:#*_previously_changed?] attribute methods.",
    "label": "",
    "id": "1178"
  },
  {
    "raw_code": "def attribute_previously_was(attr_name)\n      mutations_before_last_save.original_value(attr_name.to_s)\n    end",
    "comment": "Dispatch target for {*_previously_was}[rdoc-ref:#*_previously_was] attribute methods.",
    "label": "",
    "id": "1179"
  },
  {
    "raw_code": "def restore_attributes(attr_names = changed)\n      attr_names.each { |attr_name| restore_attribute!(attr_name) }\n    end",
    "comment": "Restore all previous data of the provided attributes.",
    "label": "",
    "id": "1180"
  },
  {
    "raw_code": "def clear_changes_information\n      @mutations_before_last_save = nil\n      forget_attribute_assignments\n      @mutations_from_database = nil\n    end",
    "comment": "Clears all dirty data: current changes and previous changes.",
    "label": "",
    "id": "1181"
  },
  {
    "raw_code": "def changed_attributes\n      mutations_from_database.changed_values\n    end",
    "comment": "Returns a hash of the attributes with unsaved changes indicating their original values like <tt>attr => original value</tt>.  person.name # => \"bob\" person.name = 'robert' person.changed_attributes # => {\"name\" => \"bob\"}",
    "label": "",
    "id": "1182"
  },
  {
    "raw_code": "def changes\n      mutations_from_database.changes\n    end",
    "comment": "Returns a hash of changed attributes indicating their original and new values like <tt>attr => [original value, new value]</tt>.  person.changes # => {} person.name = 'bob' person.changes # => { \"name\" => [\"bill\", \"bob\"] }",
    "label": "",
    "id": "1183"
  },
  {
    "raw_code": "def previous_changes\n      mutations_before_last_save.changes\n    end",
    "comment": "Returns a hash of attributes that were changed before the model was saved.  person.name # => \"bob\" person.name = 'robert' person.save person.previous_changes # => {\"name\" => [\"bob\", \"robert\"]}",
    "label": "",
    "id": "1184"
  },
  {
    "raw_code": "def attribute_change(attr_name)\n        mutations_from_database.change_to_attribute(attr_name.to_s)\n      end",
    "comment": "Dispatch target for <tt>*_change</tt> attribute methods.",
    "label": "",
    "id": "1185"
  },
  {
    "raw_code": "def attribute_previous_change(attr_name)\n        mutations_before_last_save.change_to_attribute(attr_name.to_s)\n      end",
    "comment": "Dispatch target for <tt>*_previous_change</tt> attribute methods.",
    "label": "",
    "id": "1186"
  },
  {
    "raw_code": "def attribute_will_change!(attr_name)\n        mutations_from_database.force_change(attr_name.to_s)\n      end",
    "comment": "Dispatch target for <tt>*_will_change!</tt> attribute methods.",
    "label": "",
    "id": "1187"
  },
  {
    "raw_code": "def restore_attribute!(attr_name)\n        attr_name = attr_name.to_s\n        if attribute_changed?(attr_name)\n          __send__(\"#{attr_name}=\", attribute_was(attr_name))\n          clear_attribute_change(attr_name)\n        end",
    "comment": "Dispatch target for <tt>restore_*!</tt> attribute methods.",
    "label": "",
    "id": "1188"
  },
  {
    "raw_code": "def message\n      case raw_type\n      when Symbol\n        self.class.generate_message(attribute, raw_type, @base, options.except(*CALLBACKS_OPTIONS))\n      else\n        raw_type\n      end",
    "comment": "Returns the error message.  error = ActiveModel::Error.new(person, :name, :too_short, count: 5) error.message # => \"is too short (minimum is 5 characters)\"",
    "label": "",
    "id": "1189"
  },
  {
    "raw_code": "def details\n      { error: raw_type }.merge(options.except(*CALLBACKS_OPTIONS + MESSAGE_OPTIONS))\n    end",
    "comment": "Returns the error details.  error = ActiveModel::Error.new(person, :name, :too_short, count: 5) error.details # => { error: :too_short, count: 5 }",
    "label": "",
    "id": "1190"
  },
  {
    "raw_code": "def full_message\n      self.class.full_message(attribute, message, @base)\n    end",
    "comment": "Returns the full error message.  error = ActiveModel::Error.new(person, :name, :too_short, count: 5) error.full_message # => \"Name is too short (minimum is 5 characters)\"",
    "label": "",
    "id": "1191"
  },
  {
    "raw_code": "def match?(attribute, type = nil, **options)\n      if @attribute != attribute || (type && @type != type)\n        return false\n      end",
    "comment": "See if error matches provided +attribute+, +type+, and +options+.  Omitted params are not checked for a match.",
    "label": "",
    "id": "1192"
  },
  {
    "raw_code": "def strict_match?(attribute, type, **options)\n      return false unless match?(attribute, type)\n\n      options == @options.except(*CALLBACKS_OPTIONS + MESSAGE_OPTIONS)\n    end",
    "comment": "See if error matches provided +attribute+, +type+, and +options+ exactly.  All params must be equal to Error's own attributes to be considered a strict match.",
    "label": "",
    "id": "1193"
  },
  {
    "raw_code": "def initialize(base)\n      @base = base\n      @errors = []\n    end",
    "comment": "Pass in the instance of the object that is using the errors object.  class Person def initialize @errors = ActiveModel::Errors.new(self) end end",
    "label": "",
    "id": "1194"
  },
  {
    "raw_code": "def copy!(other) # :nodoc:\n      @errors = other.errors.deep_dup\n      @errors.each { |error|\n        error.instance_variable_set(:@base, @base)\n      }\n    end",
    "comment": "Copies the errors from <tt>other</tt>. For copying errors but keep <tt>@base</tt> as is.  ==== Parameters  * +other+ - The ActiveModel::Errors instance.  ==== Examples  person.errors.copy!(other) ",
    "label": "",
    "id": "1195"
  },
  {
    "raw_code": "def import(error, override_options = {})\n      [:attribute, :type].each do |key|\n        if override_options.key?(key)\n          override_options[key] = override_options[key].to_sym\n        end",
    "comment": "Imports one error. Imported errors are wrapped as a NestedError, providing access to original error object. If attribute or type needs to be overridden, use +override_options+.  ==== Options  * +:attribute+ - Override the attribute the error belongs to. * +:type+ - Override type of the error.",
    "label": "",
    "id": "1196"
  },
  {
    "raw_code": "def merge!(other)\n      return errors if equal?(other)\n\n      other.errors.each { |error|\n        import(error)\n      }\n    end",
    "comment": "Merges the errors from <tt>other</tt>, each Error wrapped as NestedError.  ==== Parameters  * +other+ - The ActiveModel::Errors instance.  ==== Examples  person.errors.merge!(other) ",
    "label": "",
    "id": "1197"
  },
  {
    "raw_code": "def where(attribute, type = nil, **options)\n      attribute, type, options = normalize_arguments(attribute, type, **options)\n      @errors.select { |error|\n        error.match?(attribute, type, **options)\n      }\n    end",
    "comment": "Search for errors matching +attribute+, +type+, or +options+.  Only supplied params will be matched.  person.errors.where(:name) # => all name errors. person.errors.where(:name, :too_short) # => all name errors being too short person.errors.where(:name, :too_short, minimum: 2) # => all name errors being too short and minimum is 2",
    "label": "",
    "id": "1198"
  },
  {
    "raw_code": "def include?(attribute)\n      @errors.any? { |error|\n        error.match?(attribute.to_sym)\n      }\n    end",
    "comment": "Returns +true+ if the error messages include an error for the given key +attribute+, +false+ otherwise.  person.errors.messages        # => {:name=>[\"cannot be nil\"]} person.errors.include?(:name) # => true person.errors.include?(:age)  # => false",
    "label": "",
    "id": "1199"
  },
  {
    "raw_code": "def delete(attribute, type = nil, **options)\n      attribute, type, options = normalize_arguments(attribute, type, **options)\n      matches = where(attribute, type, **options)\n      matches.each do |error|\n        @errors.delete(error)\n      end",
    "comment": "Delete messages for +key+. Returns the deleted messages.  person.errors[:name]        # => [\"cannot be nil\"] person.errors.delete(:name) # => [\"cannot be nil\"] person.errors[:name]        # => []",
    "label": "",
    "id": "1200"
  },
  {
    "raw_code": "def [](attribute)\n      messages_for(attribute)\n    end",
    "comment": "When passed a symbol or a name of a method, returns an array of errors for the method.  person.errors[:name]  # => [\"cannot be nil\"] person.errors['name'] # => [\"cannot be nil\"]",
    "label": "",
    "id": "1201"
  },
  {
    "raw_code": "def attribute_names\n      @errors.map(&:attribute).uniq.freeze\n    end",
    "comment": "Returns all error attribute names  person.errors.messages        # => {:name=>[\"cannot be nil\", \"must be specified\"]} person.errors.attribute_names # => [:name]",
    "label": "",
    "id": "1202"
  },
  {
    "raw_code": "def as_json(options = nil)\n      to_hash(options && options[:full_messages])\n    end",
    "comment": "Returns a Hash that can be used as the JSON representation for this object. You can pass the <tt>:full_messages</tt> option. This determines if the JSON object should contain full messages or not (false by default).  person.errors.as_json                      # => {:name=>[\"cannot be nil\"]} person.errors.as_json(full_messages: true) # => {:name=>[\"name cannot be nil\"]}",
    "label": "",
    "id": "1203"
  },
  {
    "raw_code": "def to_hash(full_messages = false)\n      message_method = full_messages ? :full_message : :message\n      group_by_attribute.transform_values do |errors|\n        errors.map(&message_method)\n      end",
    "comment": "Returns a Hash of attributes with their error messages. If +full_messages+ is +true+, it will contain full messages (see +full_message+).  person.errors.to_hash       # => {:name=>[\"cannot be nil\"]} person.errors.to_hash(true) # => {:name=>[\"name cannot be nil\"]}",
    "label": "",
    "id": "1204"
  },
  {
    "raw_code": "def messages\n      hash = to_hash\n      hash.default = EMPTY_ARRAY\n      hash.freeze\n      hash\n    end",
    "comment": "Returns a Hash of attributes with an array of their error messages.",
    "label": "",
    "id": "1205"
  },
  {
    "raw_code": "def details\n      hash = group_by_attribute.transform_values do |errors|\n        errors.map(&:details)\n      end",
    "comment": "Returns a Hash of attributes with an array of their error details.",
    "label": "",
    "id": "1206"
  },
  {
    "raw_code": "def group_by_attribute\n      @errors.group_by(&:attribute)\n    end",
    "comment": "Returns a Hash of attributes with an array of their Error objects.  person.errors.group_by_attribute # => {:name=>[<#ActiveModel::Error>, <#ActiveModel::Error>]}",
    "label": "",
    "id": "1207"
  },
  {
    "raw_code": "def add(attribute, type = :invalid, **options)\n      attribute, type, options = normalize_arguments(attribute, type, **options)\n      error = Error.new(@base, attribute, type, **options)\n\n      if exception = options[:strict]\n        exception = ActiveModel::StrictValidationFailed if exception == true\n        raise exception, error.full_message\n      end",
    "comment": "Adds a new error of +type+ on +attribute+. More than one error can be added to the same +attribute+. If no +type+ is supplied, <tt>:invalid</tt> is assumed.  person.errors.add(:name) # Adds <#ActiveModel::Error attribute=name, type=invalid> person.errors.add(:name, :not_implemented, message: \"must be implemented\") # Adds <#ActiveModel::Error attribute=name, type=not_implemented, options={:message=>\"must be implemented\"}>  person.errors.messages # => {:name=>[\"is invalid\", \"must be implemented\"]}  If +type+ is a string, it will be used as error message.  If +type+ is a symbol, it will be translated using the appropriate scope (see +generate_message+).  person.errors.add(:name, :blank) person.errors.messages # => {:name=>[\"can't be blank\"]}  person.errors.add(:name, :too_long, count: 25) person.errors.messages # => [\"is too long (maximum is 25 characters)\"]  If +type+ is a proc, it will be called, allowing for things like <tt>Time.now</tt> to be used within an error.  If the <tt>:strict</tt> option is set to +true+, it will raise ActiveModel::StrictValidationFailed instead of adding the error. <tt>:strict</tt> option can also be set to any other exception.  person.errors.add(:name, :invalid, strict: true) # => ActiveModel::StrictValidationFailed: Name is invalid person.errors.add(:name, :invalid, strict: NameIsInvalid) # => NameIsInvalid: Name is invalid  person.errors.messages # => {}  +attribute+ should be set to <tt>:base</tt> if the error is not directly associated with a single attribute.  person.errors.add(:base, :name_or_email_blank, message: \"either name or email must be present\") person.errors.messages # => {:base=>[\"either name or email must be present\"]} person.errors.details # => {:base=>[{error: :name_or_email_blank}]}",
    "label": "",
    "id": "1208"
  },
  {
    "raw_code": "def added?(attribute, type = :invalid, options = {})\n      attribute, type, options = normalize_arguments(attribute, type, **options)\n\n      if type.is_a? Symbol\n        @errors.any? { |error|\n          error.strict_match?(attribute, type, **options)\n        }\n      else\n        messages_for(attribute).include?(type)\n      end",
    "comment": "Returns +true+ if an error matches provided +attribute+ and +type+, or +false+ otherwise. +type+ is treated the same as for +add+.  person.errors.add :name, :blank person.errors.added? :name, :blank           # => true person.errors.added? :name, \"can't be blank\" # => true  If the error requires options, then it returns +true+ with the correct options, or +false+ with incorrect or missing options.  person.errors.add :name, :too_long, count: 25 person.errors.added? :name, :too_long, count: 25                     # => true person.errors.added? :name, \"is too long (maximum is 25 characters)\" # => true person.errors.added? :name, :too_long, count: 24                     # => false person.errors.added? :name, :too_long                                # => false person.errors.added? :name, \"is too long\"                            # => false",
    "label": "",
    "id": "1209"
  },
  {
    "raw_code": "def of_kind?(attribute, type = :invalid)\n      attribute, type = normalize_arguments(attribute, type)\n\n      if type.is_a? Symbol\n        !where(attribute, type).empty?\n      else\n        messages_for(attribute).include?(type)\n      end",
    "comment": "Returns +true+ if an error on the attribute with the given type is present, or +false+ otherwise. +type+ is treated the same as for +add+.  person.errors.add :age person.errors.add :name, :too_long, count: 25 person.errors.of_kind? :age                                            # => true person.errors.of_kind? :name                                           # => false person.errors.of_kind? :name, :too_long                                # => true person.errors.of_kind? :name, \"is too long (maximum is 25 characters)\" # => true person.errors.of_kind? :name, :not_too_long                            # => false person.errors.of_kind? :name, \"is too long\"                            # => false",
    "label": "",
    "id": "1210"
  },
  {
    "raw_code": "def full_messages\n      @errors.map(&:full_message)\n    end",
    "comment": "Returns all the full error messages in an array.  class Person validates_presence_of :name, :address, :email validates_length_of :name, in: 5..30 end  person = Person.create(address: '123 First St.') person.errors.full_messages # => [\"Name is too short (minimum is 5 characters)\", \"Name can't be blank\", \"Email can't be blank\"]",
    "label": "",
    "id": "1211"
  },
  {
    "raw_code": "def full_messages_for(attribute)\n      where(attribute).map(&:full_message).freeze\n    end",
    "comment": "Returns all the full error messages for a given attribute in an array.  class Person validates_presence_of :name, :email validates_length_of :name, in: 5..30 end  person = Person.create() person.errors.full_messages_for(:name) # => [\"Name is too short (minimum is 5 characters)\", \"Name can't be blank\"]",
    "label": "",
    "id": "1212"
  },
  {
    "raw_code": "def messages_for(attribute)\n      where(attribute).map(&:message)\n    end",
    "comment": "Returns all the error messages for a given attribute in an array.  class Person validates_presence_of :name, :email validates_length_of :name, in: 5..30 end  person = Person.create() person.errors.messages_for(:name) # => [\"is too short (minimum is 5 characters)\", \"can't be blank\"]",
    "label": "",
    "id": "1213"
  },
  {
    "raw_code": "def full_message(attribute, message)\n      Error.full_message(attribute, message, @base)\n    end",
    "comment": "Returns a full message for a given attribute.  person.errors.full_message(:name, 'is invalid') # => \"Name is invalid\"",
    "label": "",
    "id": "1214"
  },
  {
    "raw_code": "def generate_message(attribute, type = :invalid, options = {})\n      Error.generate_message(attribute, type, @base, options)\n    end",
    "comment": "Translates an error message in its default scope (<tt>activemodel.errors.messages</tt>).  Error messages are first looked up in <tt>activemodel.errors.models.MODEL.attributes.ATTRIBUTE.MESSAGE</tt>, if it's not there, it's looked up in <tt>activemodel.errors.models.MODEL.MESSAGE</tt> and if that is not there also, it returns the translation of the default message (e.g. <tt>activemodel.errors.messages.MESSAGE</tt>). The translated model name, translated attribute name, and the value are available for interpolation.  When using inheritance in your models, it will check all the inherited models too, but only if the model itself hasn't been found. Say you have <tt>class Admin < User; end</tt> and you wanted the translation for the <tt>:blank</tt> error message for the <tt>title</tt> attribute, it looks for these translations:  * <tt>activemodel.errors.models.admin.attributes.title.blank</tt> * <tt>activemodel.errors.models.admin.blank</tt> * <tt>activemodel.errors.models.user.attributes.title.blank</tt> * <tt>activemodel.errors.models.user.blank</tt> * any default you provided through the +options+ hash (in the <tt>activemodel.errors</tt> scope) * <tt>activemodel.errors.messages.blank</tt> * <tt>errors.attributes.title.blank</tt> * <tt>errors.messages.blank</tt>",
    "label": "",
    "id": "1215"
  },
  {
    "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of \\Active \\Model as a +Gem::Version+.",
    "label": "",
    "id": "1216"
  },
  {
    "raw_code": "def test_to_key\n        assert_respond_to model, :to_key\n        def_method(model, :persisted?) { false }\n        assert model.to_key.nil?, \"to_key should return nil when `persisted?` returns false\"\n      end",
    "comment": "Passes if the object's model responds to <tt>to_key</tt> and if calling this method returns +nil+ when the object is not persisted. Fails otherwise.  <tt>to_key</tt> returns an Enumerable of all (primary) key attributes of the model, and is used to a generate unique DOM id for the object.",
    "label": "",
    "id": "1217"
  },
  {
    "raw_code": "def test_to_param\n        assert_respond_to model, :to_param\n        def_method(model, :to_key) { [1] }\n        def_method(model, :persisted?) { false }\n        assert model.to_param.nil?, \"to_param should return nil when `persisted?` returns false\"\n      end",
    "comment": "Passes if the object's model responds to <tt>to_param</tt> and if calling this method returns +nil+ when the object is not persisted. Fails otherwise.  <tt>to_param</tt> is used to represent the object's key in URLs. Implementers can decide to either raise an exception or provide a default in case the record uses a composite primary key. There are no tests for this behavior in lint because it doesn't make sense to force any of the possible implementation strategies on the implementer.",
    "label": "",
    "id": "1218"
  },
  {
    "raw_code": "def test_to_partial_path\n        assert_respond_to model, :to_partial_path\n        assert_kind_of String, model.to_partial_path\n      end",
    "comment": "Passes if the object's model responds to <tt>to_partial_path</tt> and if calling this method returns a string. Fails otherwise.  <tt>to_partial_path</tt> is used for looking up partials. For example, a BlogPost model might return \"blog_posts/blog_post\".",
    "label": "",
    "id": "1219"
  },
  {
    "raw_code": "def test_persisted?\n        assert_respond_to model, :persisted?\n        assert_boolean model.persisted?, \"persisted?\"\n      end",
    "comment": "Passes if the object's model responds to <tt>persisted?</tt> and if calling this method returns either +true+ or +false+. Fails otherwise.  <tt>persisted?</tt> is used when calculating the URL for an object. If the object is not persisted, a form for that object, for instance, will route to the create action. If it is persisted, a form for the object will route to the update action.",
    "label": "",
    "id": "1220"
  },
  {
    "raw_code": "def test_model_naming\n        assert_respond_to model.class, :model_name\n        model_name = model.class.model_name\n        assert_respond_to model_name, :to_str\n        assert_respond_to model_name.human, :to_str\n        assert_respond_to model_name.singular, :to_str\n        assert_respond_to model_name.plural, :to_str\n\n        assert_respond_to model, :model_name\n        assert_equal model.model_name, model.class.model_name\n      end",
    "comment": "Passes if the object's model responds to <tt>model_name</tt> both as an instance method and as a class method, and if calling this method returns a string with some convenience methods: <tt>:human</tt>, <tt>:singular</tt> and <tt>:plural</tt>.  Check ActiveModel::Naming for more information.",
    "label": "",
    "id": "1221"
  },
  {
    "raw_code": "def test_errors_aref\n        assert_respond_to model, :errors\n        assert_equal [], model.errors[:hello], \"errors#[] should return an empty Array\"\n      end",
    "comment": "Passes if the object's model responds to <tt>errors</tt> and if calling <tt>[](attribute)</tt> on the result of this method returns an array. Fails otherwise.  <tt>errors[attribute]</tt> is used to retrieve the errors of a model for a given attribute. If errors are present, the method should return an array of strings that are the errors for the attribute in question. If localization is used, the strings should be localized for the current locale. If no error is present, the method should return an empty array.",
    "label": "",
    "id": "1222"
  },
  {
    "raw_code": "def initialize(klass, namespace = nil, name = nil, locale = :en)\n      @name = name || klass.name\n\n      raise ArgumentError, \"Class name cannot be blank. You need to supply a name argument when anonymous class given\" if @name.blank?\n\n      @unnamespaced = @name.delete_prefix(\"#{namespace.name}::\") if namespace\n      @klass        = klass\n      @singular     = _singularize(@name)\n      @plural       = ActiveSupport::Inflector.pluralize(@singular, locale)\n      @uncountable  = @plural == @singular\n      @element      = ActiveSupport::Inflector.underscore(ActiveSupport::Inflector.demodulize(@name))\n      @human        = ActiveSupport::Inflector.humanize(@element)\n      @collection   = ActiveSupport::Inflector.tableize(@name)\n      @param_key    = (namespace ? _singularize(@unnamespaced) : @singular)\n      @i18n_key     = @name.underscore.to_sym\n\n      @route_key          = (namespace ? ActiveSupport::Inflector.pluralize(@param_key, locale) : @plural.dup)\n      @singular_route_key = ActiveSupport::Inflector.singularize(@route_key, locale)\n      @route_key << \"_index\" if @uncountable\n    end",
    "comment": "Returns a new ActiveModel::Name instance. By default, the +namespace+ and +name+ option will take the namespace and name of the given class respectively. Use +locale+ argument for singularize and pluralize model name.  module Foo class Bar end end  ActiveModel::Name.new(Foo::Bar).to_s # => \"Foo::Bar\"",
    "label": "",
    "id": "1223"
  },
  {
    "raw_code": "def human(options = {})\n      return @human if i18n_keys.empty? || i18n_scope.empty?\n\n      key, *defaults = i18n_keys\n      defaults << options[:default] if options[:default]\n      defaults << MISSING_TRANSLATION\n\n      translation = I18n.translate(key, scope: i18n_scope, count: 1, **options, default: defaults)\n      translation = @human if translation == MISSING_TRANSLATION\n      translation\n    end",
    "comment": "Transform the model name into a more human format, using I18n. By default, it will underscore then humanize the class name.  class BlogPost extend ActiveModel::Naming end  BlogPost.model_name.human # => \"Blog post\"  Specify +options+ with additional translating options.",
    "label": "",
    "id": "1224"
  },
  {
    "raw_code": "def model_name\n      @_model_name ||= begin\n        namespace = module_parents.detect do |n|\n          n.respond_to?(:use_relative_model_naming?) && n.use_relative_model_naming?\n        end",
    "comment": "Returns an ActiveModel::Name object for module. It can be used to retrieve all kinds of naming-related information (See ActiveModel::Name for more information).  class Person extend ActiveModel::Naming end  Person.model_name.name     # => \"Person\" Person.model_name.class    # => ActiveModel::Name Person.model_name.singular # => \"person\" Person.model_name.plural   # => \"people\"",
    "label": "",
    "id": "1225"
  },
  {
    "raw_code": "def self.plural(record_or_class)\n      model_name_from_record_or_class(record_or_class).plural\n    end",
    "comment": "Returns the plural class name of a record or class.  ActiveModel::Naming.plural(post)             # => \"posts\" ActiveModel::Naming.plural(Highrise::Person) # => \"highrise_people\"",
    "label": "",
    "id": "1226"
  },
  {
    "raw_code": "def self.singular(record_or_class)\n      model_name_from_record_or_class(record_or_class).singular\n    end",
    "comment": "Returns the singular class name of a record or class.  ActiveModel::Naming.singular(post)             # => \"post\" ActiveModel::Naming.singular(Highrise::Person) # => \"highrise_person\"",
    "label": "",
    "id": "1227"
  },
  {
    "raw_code": "def self.uncountable?(record_or_class)\n      model_name_from_record_or_class(record_or_class).uncountable?\n    end",
    "comment": "Identifies whether the class name of a record or class is uncountable.  ActiveModel::Naming.uncountable?(Sheep) # => true ActiveModel::Naming.uncountable?(Post)  # => false",
    "label": "",
    "id": "1228"
  },
  {
    "raw_code": "def self.singular_route_key(record_or_class)\n      model_name_from_record_or_class(record_or_class).singular_route_key\n    end",
    "comment": "Returns string to use while generating route names. It differs for namespaced models regarding whether it's inside isolated engine.  # For isolated engine: ActiveModel::Naming.singular_route_key(Blog::Post) # => \"post\"  # For shared engine: ActiveModel::Naming.singular_route_key(Blog::Post) # => \"blog_post\"",
    "label": "",
    "id": "1229"
  },
  {
    "raw_code": "def self.route_key(record_or_class)\n      model_name_from_record_or_class(record_or_class).route_key\n    end",
    "comment": "Returns string to use while generating route names. It differs for namespaced models regarding whether it's inside isolated engine.  # For isolated engine: ActiveModel::Naming.route_key(Blog::Post) # => \"posts\"  # For shared engine: ActiveModel::Naming.route_key(Blog::Post) # => \"blog_posts\"  The route key also considers if the noun is uncountable and, in such cases, automatically appends _index.",
    "label": "",
    "id": "1230"
  },
  {
    "raw_code": "def self.param_key(record_or_class)\n      model_name_from_record_or_class(record_or_class).param_key\n    end",
    "comment": "Returns string to use for params names. It differs for namespaced models regarding whether it's inside isolated engine.  # For isolated engine: ActiveModel::Naming.param_key(Blog::Post) # => \"post\"  # For shared engine: ActiveModel::Naming.param_key(Blog::Post) # => \"blog_post\"",
    "label": "",
    "id": "1231"
  },
  {
    "raw_code": "def has_secure_password(attribute = :password, validations: true, reset_token: true)\n        # Load bcrypt gem only when has_secure_password is used.\n        # This is to avoid ActiveModel (and by extension the entire framework)\n        # being dependent on a binary library.\n        begin\n          require \"bcrypt\"\n        rescue LoadError\n          warn \"You don't have bcrypt installed in your application. Please add it to your Gemfile and run bundle install.\"\n          raise\n        end",
    "comment": "Adds methods to set and authenticate against a BCrypt password. This mechanism requires you to have a +XXX_digest+ attribute, where +XXX+ is the attribute name of your desired password.  The following validations are added automatically: * Password must be present on creation * Password length should be less than or equal to 72 bytes * Confirmation of password (using a +XXX_confirmation+ attribute)  If confirmation validation is not needed, simply leave out the value for +XXX_confirmation+ (i.e. don't provide a form field for it). When this attribute has a +nil+ value, the validation will not be triggered.  Additionally, a +XXX_challenge+ attribute is created. When set to a value other than +nil+, it will validate against the currently persisted password. This validation relies on dirty tracking, as provided by ActiveModel::Dirty; if dirty tracking methods are not defined, this validation will fail.  All of the above validations can be omitted by passing <tt>validations: false</tt> as an argument. This allows complete customizability of validation behavior.  Finally, a password reset token that's valid for 15 minutes after issue is automatically configured when +reset_token+ is set to true (which it is by default) and the object responds to +generates_token_for+ (which Active Records do).  To use +has_secure_password+, add bcrypt (~> 3.1.7) to your Gemfile:  gem \"bcrypt\", \"~> 3.1.7\"  ==== Examples  ===== Using Active Record (which automatically includes ActiveModel::SecurePassword)  # Schema: User(name:string, password_digest:string, recovery_password_digest:string) class User < ActiveRecord::Base has_secure_password has_secure_password :recovery_password, validations: false end  user = User.new(name: \"david\", password: \"\", password_confirmation: \"nomatch\")  user.save                                                      # => false, password required user.password = \"vr00m\" user.save                                                      # => false, confirmation doesn't match user.password_confirmation = \"vr00m\" user.save                                                      # => true  user.authenticate(\"notright\")                                  # => false user.authenticate(\"vr00m\")                                     # => user User.find_by(name: \"david\")&.authenticate(\"notright\")          # => false User.find_by(name: \"david\")&.authenticate(\"vr00m\")             # => user  user.recovery_password = \"42password\" user.recovery_password_digest                                  # => \"$2a$04$iOfhwahFymCs5weB3BNH/uXkTG65HR.qpW.bNhEjFP3ftli3o5DQC\" user.save                                                      # => true  user.authenticate_recovery_password(\"42password\")              # => user  user.update(password: \"pwn3d\", password_challenge: \"\")         # => false, challenge doesn't authenticate user.update(password: \"nohack4u\", password_challenge: \"vr00m\") # => true  user.authenticate(\"vr00m\")                                     # => false, old password user.authenticate(\"nohack4u\")                                  # => user  ===== Conditionally requiring a password  class Account include ActiveModel::SecurePassword  attr_accessor :is_guest, :password_digest  has_secure_password  def errors super.tap { |errors| errors.delete(:password, :blank) if is_guest } end end  account = Account.new account.valid? # => false, password required  account.is_guest = true account.valid? # => true  ===== Using the password reset token  user = User.create!(name: \"david\", password: \"123\", password_confirmation: \"123\") token = user.password_reset_token User.find_by_password_reset_token(token) # returns user  # 16 minutes later... User.find_by_password_reset_token(token) # returns nil  # raises ActiveSupport::MessageVerifier::InvalidSignature since the token is expired User.find_by_password_reset_token!(token)",
    "label": "",
    "id": "1232"
  },
  {
    "raw_code": "def serializable_hash(options = nil)\n      attribute_names = attribute_names_for_serialization\n\n      return serializable_attributes(attribute_names) if options.blank?\n\n      if only = options[:only]\n        attribute_names = Array(only).map(&:to_s) & attribute_names\n      elsif except = options[:except]\n        attribute_names -= Array(except).map(&:to_s)\n      end",
    "comment": "Returns a serialized hash of your object.  class Person include ActiveModel::Serialization  attr_accessor :name, :age  def attributes {'name' => nil, 'age' => nil} end  def capitalized_name name.capitalize end end  person = Person.new person.name = 'bob' person.age  = 22 person.serializable_hash                # => {\"name\"=>\"bob\", \"age\"=>22} person.serializable_hash(only: :name)   # => {\"name\"=>\"bob\"} person.serializable_hash(except: :name) # => {\"age\"=>22} person.serializable_hash(methods: :capitalized_name) # => {\"name\"=>\"bob\", \"age\"=>22, \"capitalized_name\"=>\"Bob\"}  Example with <tt>:include</tt> option  class User include ActiveModel::Serializers::JSON attr_accessor :name, :notes # Emulate has_many :notes def attributes {'name' => nil} end end  class Note include ActiveModel::Serializers::JSON attr_accessor :title, :text def attributes {'title' => nil, 'text' => nil} end end  note = Note.new note.title = 'Battle of Austerlitz' note.text = 'Some text here'  user = User.new user.name = 'Napoleon' user.notes = [note]  user.serializable_hash # => {\"name\" => \"Napoleon\"} user.serializable_hash(include: { notes: { only: 'title' }}) # => {\"name\" => \"Napoleon\", \"notes\" => [{\"title\"=>\"Battle of Austerlitz\"}]}",
    "label": "",
    "id": "1233"
  },
  {
    "raw_code": "def serializable_add_includes(options = {}) # :nodoc:\n        return unless includes = options[:include]\n\n        unless includes.is_a?(Hash)\n          includes = Hash[Array(includes).flat_map { |n| n.is_a?(Hash) ? n.to_a : [[n, {}]] }]\n        end",
    "comment": "Add associations specified via the <tt>:include</tt> option.  Expects a block that takes as arguments: +association+ - name of the association +records+     - the association record(s) to be serialized +opts+        - options for the association records",
    "label": "",
    "id": "1234"
  },
  {
    "raw_code": "def i18n_scope\n      :activemodel\n    end",
    "comment": "Returns the +i18n_scope+ for the class. Override if you want custom lookup.",
    "label": "",
    "id": "1235"
  },
  {
    "raw_code": "def lookup_ancestors\n      ancestors.select { |x| x.respond_to?(:model_name) }\n    end",
    "comment": "When localizing a string, it goes through the lookup returned by this method, which is used in ActiveModel::Name#human, ActiveModel::Errors#full_messages and ActiveModel::Translation#human_attribute_name.",
    "label": "",
    "id": "1236"
  },
  {
    "raw_code": "def human_attribute_name(attribute, options = {})\n      attribute = attribute.to_s\n\n      if attribute.include?(\".\")\n        namespace, _, attribute = attribute.rpartition(\".\")\n        namespace.tr!(\".\", \"/\")\n\n        if attribute.present?\n          key = \"#{namespace}.#{attribute}\"\n          separator = \"/\"\n        else\n          key = namespace\n          separator = \".\"\n        end",
    "comment": "Transforms attribute names into a more human format, such as \"First name\" instead of \"first_name\".  Person.human_attribute_name(\"first_name\") # => \"First name\"  Specify +options+ with additional translating options.",
    "label": "",
    "id": "1237"
  },
  {
    "raw_code": "def register(type_name, klass = nil, &block)\n        registry.register(type_name, klass, &block)\n      end",
    "comment": "Add a new type to the registry, allowing it to be referenced as a symbol by {attribute}[rdoc-ref:Attributes::ClassMethods#attribute].",
    "label": "",
    "id": "1238"
  },
  {
    "raw_code": "def validates_each(*attr_names, &block)\n        validates_with BlockValidator, _merge_attributes(attr_names), &block\n      end",
    "comment": "Validates each attribute against a block.  class Person include ActiveModel::Validations  attr_accessor :first_name, :last_name  validates_each :first_name, :last_name, allow_blank: true do |record, attr, value| record.errors.add attr, \"starts with z.\" if value.start_with?(\"z\") end end  ==== Options  * <tt>:on</tt> - Specifies the contexts where this validation is active. Runs in all validation contexts by default +nil+. You can pass a symbol or an array of symbols. (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt> or <tt>on: [:create, :custom_validation_context]</tt>) * <tt>:except_on</tt> - Specifies the contexts where this validation is not active. Runs in all validation contexts by default +nil+. You can pass a symbol or an array of symbols. (e.g. <tt>except: :create</tt> or <tt>except_on: :custom_validation_context</tt> or <tt>except_on: [:create, :custom_validation_context]</tt>) * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+. * <tt>:allow_blank</tt> - Skip validation if attribute is blank. * <tt>:if</tt> - Specifies a method, proc, or string to call to determine if the validation should occur (e.g. <tt>if: :allow_validation</tt>, or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method, proc or string should return or evaluate to a +true+ or +false+ value. * <tt>:unless</tt> - Specifies a method, proc, or string to call to determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>, or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The method, proc, or string should return or evaluate to a +true+ or +false+ value.",
    "label": "",
    "id": "1239"
  },
  {
    "raw_code": "def validate(*args, &block)\n        options = args.extract_options!\n\n        if args.all?(Symbol)\n          options.each_key do |k|\n            unless VALID_OPTIONS_FOR_VALIDATE.include?(k)\n              raise ArgumentError.new(\"Unknown key: #{k.inspect}. Valid keys are: #{VALID_OPTIONS_FOR_VALIDATE.map(&:inspect).join(', ')}. Perhaps you meant to call `validates` instead of `validate`?\")\n            end",
    "comment": "Adds a validation method or block to the class. This is useful when overriding the +validate+ instance method becomes too unwieldy and you're looking for more descriptive declaration of your validations.  This can be done with a symbol pointing to a method:  class Comment include ActiveModel::Validations  validate :must_be_friends  def must_be_friends errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee) end end  With a block which is passed with the current record to be validated:  class Comment include ActiveModel::Validations  validate do |comment| comment.must_be_friends end  def must_be_friends errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee) end end  Or with a block where +self+ points to the current record to be validated:  class Comment include ActiveModel::Validations  validate do errors.add(:base, 'Must be friends to leave a comment') unless commenter.friend_of?(commentee) end end  Note that the return value of validation methods is not relevant. It's not possible to halt the validate callback chain.  ==== Options  * <tt>:on</tt> - Specifies the contexts where this validation is active. Runs in all validation contexts by default +nil+. You can pass a symbol or an array of symbols. (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt> or <tt>on: [:create, :custom_validation_context]</tt>) * <tt>:except_on</tt> - Specifies the contexts where this validation is not active. Runs in all validation contexts by default +nil+. You can pass a symbol or an array of symbols. (e.g. <tt>except: :create</tt> or <tt>except_on: :custom_validation_context</tt> or <tt>except_on: [:create, :custom_validation_context]</tt>) * <tt>:if</tt> - Specifies a method or proc to call to determine if the validation should occur (e.g. <tt>if: :allow_validation</tt>, or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method or proc should return or evaluate to a +true+ or +false+ value. * <tt>:unless</tt> - Specifies a method or proc to call to determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>, or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The method or proc should return or evaluate to a +true+ or +false+ value.  NOTE: Calling +validate+ multiple times on the same method will overwrite previous definitions. ",
    "label": "",
    "id": "1240"
  },
  {
    "raw_code": "def validators\n        _validators.values.flatten.uniq\n      end",
    "comment": "List all validators that are being used to validate the model using +validates_with+ method.  class Person include ActiveModel::Validations  validates_with MyValidator validates_with OtherValidator, on: :create validates_with StrictValidator, strict: true end  Person.validators # => [ #      #<MyValidator:0x007fbff403e808 @options={}>, #      #<OtherValidator:0x007fbff403d930 @options={on: :create}>, #      #<StrictValidator:0x007fbff3204a30 @options={strict:true}> #    ]",
    "label": "",
    "id": "1241"
  },
  {
    "raw_code": "def clear_validators!\n        reset_callbacks(:validate)\n        _validators.clear\n      end",
    "comment": "Clears all of the validators and validations.  Note that this will clear anything that is being used to validate the model for both the +validates_with+ and +validate+ methods. It clears the validators that are created with an invocation of +validates_with+ and the callbacks that are set by an invocation of +validate+.  class Person include ActiveModel::Validations  validates_with MyValidator validates_with OtherValidator, on: :create validates_with StrictValidator, strict: true validate :cannot_be_robot  def cannot_be_robot errors.add(:base, 'A person cannot be a robot') if person_is_robot end end  Person.validators # => [ #      #<MyValidator:0x007fbff403e808 @options={}>, #      #<OtherValidator:0x007fbff403d930 @options={on: :create}>, #      #<StrictValidator:0x007fbff3204a30 @options={strict:true}> #    ]  If one runs <tt>Person.clear_validators!</tt> and then checks to see what validators this class has, you would obtain:  Person.validators # => []  Also, the callback set by <tt>validate :cannot_be_robot</tt> will be erased so that:  Person._validate_callbacks.empty?  # => true ",
    "label": "",
    "id": "1242"
  },
  {
    "raw_code": "def validators_on(*attributes)\n        attributes.flat_map do |attribute|\n          _validators[attribute.to_sym]\n        end",
    "comment": "List all validators that are being used to validate a specific attribute.  class Person include ActiveModel::Validations  attr_accessor :name, :age  validates_presence_of :name validates_inclusion_of :age, in: 0..99 end  Person.validators_on(:name) # => [ #       #<ActiveModel::Validations::PresenceValidator:0x007fe604914e60 @attributes=[:name], @options={}>, #    ]",
    "label": "",
    "id": "1243"
  },
  {
    "raw_code": "def attribute_method?(attribute)\n        method_defined?(attribute)\n      end",
    "comment": "Returns +true+ if +attribute+ is an attribute method, +false+ otherwise.  class Person include ActiveModel::Validations  attr_accessor :name end  User.attribute_method?(:name) # => true User.attribute_method?(:age)  # => false",
    "label": "",
    "id": "1244"
  },
  {
    "raw_code": "def inherited(base) # :nodoc:\n        dup = _validators.dup\n        base._validators = dup.each { |k, v| dup[k] = v.dup }\n        super\n      end",
    "comment": "Copy validators on inheritance.",
    "label": "",
    "id": "1245"
  },
  {
    "raw_code": "def initialize_dup(other) # :nodoc:\n      @errors = nil\n      super\n    end",
    "comment": "Clean the +Errors+ object if instance is duped.",
    "label": "",
    "id": "1246"
  },
  {
    "raw_code": "def errors\n      @errors ||= Errors.new(self)\n    end",
    "comment": "Returns the +Errors+ object that holds all information about attribute error messages.  class Person include ActiveModel::Validations  attr_accessor :name validates_presence_of :name end  person = Person.new person.valid? # => false person.errors # => #<ActiveModel::Errors:0x007fe603816640 @messages={name:[\"can't be blank\"]}>",
    "label": "",
    "id": "1247"
  },
  {
    "raw_code": "def valid?(context = nil)\n      current_context = validation_context\n      context_for_validation.context = context\n      errors.clear\n      run_validations!\n    ensure\n      context_for_validation.context = current_context\n    end",
    "comment": "Runs all the specified validations and returns +true+ if no errors were added otherwise +false+.  class Person include ActiveModel::Validations  attr_accessor :name validates_presence_of :name end  person = Person.new person.name = '' person.valid? # => false person.name = 'david' person.valid? # => true  Context can optionally be supplied to define which callbacks to test against (the context is defined on the validations using <tt>:on</tt>).  class Person include ActiveModel::Validations  attr_accessor :name validates_presence_of :name, on: :new end  person = Person.new person.valid?       # => true person.valid?(:new) # => false",
    "label": "",
    "id": "1248"
  },
  {
    "raw_code": "def invalid?(context = nil)\n      !valid?(context)\n    end",
    "comment": "Performs the opposite of <tt>valid?</tt>. Returns +true+ if errors were added, +false+ otherwise.  class Person include ActiveModel::Validations  attr_accessor :name validates_presence_of :name end  person = Person.new person.name = '' person.invalid? # => true person.name = 'david' person.invalid? # => false  Context can optionally be supplied to define which callbacks to test against (the context is defined on the validations using <tt>:on</tt>).  class Person include ActiveModel::Validations  attr_accessor :name validates_presence_of :name, on: :new end  person = Person.new person.invalid?       # => false person.invalid?(:new) # => true",
    "label": "",
    "id": "1249"
  },
  {
    "raw_code": "def validate!(context = nil)\n      valid?(context) || raise_validation_error\n    end",
    "comment": "Runs all the validations within the specified context. Returns +true+ if no errors are found, raises +ValidationError+ otherwise.  Validations with no <tt>:on</tt> option will run no matter the context. Validations with some <tt>:on</tt> option will only run in the specified context.",
    "label": "",
    "id": "1250"
  },
  {
    "raw_code": "def validation_context\n      context_for_validation.context\n    end",
    "comment": "Returns the context when running validations.",
    "label": "",
    "id": "1251"
  },
  {
    "raw_code": "def self.kind\n      @kind ||= name.split(\"::\").last.underscore.chomp(\"_validator\").to_sym unless anonymous?\n    end",
    "comment": "Returns the kind of the validator.  PresenceValidator.kind   # => :presence AcceptanceValidator.kind # => :acceptance",
    "label": "",
    "id": "1252"
  },
  {
    "raw_code": "def initialize(options = {})\n      @options = options.except(:class).freeze\n    end",
    "comment": "Accepts options that will be made available through the +options+ reader.",
    "label": "",
    "id": "1253"
  },
  {
    "raw_code": "def kind\n      self.class.kind\n    end",
    "comment": "Returns the kind for this validator.  PresenceValidator.new(attributes: [:username]).kind # => :presence AcceptanceValidator.new(attributes: [:terms]).kind  # => :acceptance",
    "label": "",
    "id": "1254"
  },
  {
    "raw_code": "def validate(record)\n      raise NotImplementedError, \"Subclasses must implement a validate(record) method.\"\n    end",
    "comment": "Override this method in subclasses with validation logic, adding errors to the records +errors+ array where necessary.",
    "label": "",
    "id": "1255"
  },
  {
    "raw_code": "def initialize(options)\n      @attributes = Array(options.delete(:attributes))\n      raise ArgumentError, \":attributes cannot be blank\" if @attributes.empty?\n      super\n      check_validity!\n    end",
    "comment": "Returns a new validator instance. All options will be available via the +options+ reader, however the <tt>:attributes</tt> option will be removed and instead be made available through the +attributes+ reader.",
    "label": "",
    "id": "1256"
  },
  {
    "raw_code": "def validate(record)\n      attributes.each do |attribute|\n        value = record.read_attribute_for_validation(attribute)\n        next if (value.nil? && options[:allow_nil]) || (value.blank? && options[:allow_blank])\n        value = prepare_value_for_validation(value, record, attribute)\n        validate_each(record, attribute, value)\n      end",
    "comment": "Performs validation on the supplied record. By default this will call +validate_each+ to determine validity therefore subclasses should override +validate_each+ with validation logic.",
    "label": "",
    "id": "1257"
  },
  {
    "raw_code": "def validate_each(record, attribute, value)\n      raise NotImplementedError, \"Subclasses must implement a validate_each(record, attribute, value) method\"\n    end",
    "comment": "Override this method in subclasses with the validation logic, adding errors to the records +errors+ array where necessary.",
    "label": "",
    "id": "1258"
  },
  {
    "raw_code": "def check_validity!\n    end",
    "comment": "Hook method that gets called by the initializer allowing verification that the arguments supplied are valid. You could for example raise an +ArgumentError+ when invalid options are supplied.",
    "label": "",
    "id": "1259"
  },
  {
    "raw_code": "def self.version\n    gem_version\n  end",
    "comment": "Returns the currently loaded version of \\Active \\Model as a +Gem::Version+.",
    "label": "",
    "id": "1260"
  },
  {
    "raw_code": "def normalize_attribute(name)\n        # Treat the value as a new, unnormalized value.\n        send(:\"#{name}=\", send(name))\n      end",
    "comment": "Normalizes a specified attribute using its declared normalizations.  ==== Examples  class User include ActiveModel::Attributes include ActiveModel::Attributes::Normalization  attribute :email, :string  normalizes :email, with: -> email { email.strip.downcase } end  legacy_user = User.load_from_legacy_data(...) legacy_user.email # => \" CRUISE-CONTROL@EXAMPLE.COM\\n\" legacy_user.normalize_attribute(:email) legacy_user.email # => \"cruise-control@example.com\"  ==== Behavior with Active Record  To prevent confusion, normalization will not be applied when the attribute is fetched from the database. This means that if a record was persisted before the normalization was declared, the record's attribute will not be normalized until either it is assigned a new value, or it is explicitly migrated via Normalization#normalize_attribute.  Be aware that if your app was created before Rails 7.1, and your app marshals instances of the targeted model (for example, when caching), then you should set ActiveRecord.marshalling_format_version to +7.1+ or higher via either <tt>config.load_defaults 7.1</tt> or <tt>config.active_record.marshalling_format_version = 7.1</tt>. Otherwise, +Marshal+ may attempt to serialize the normalization +Proc+ and raise +TypeError+.  class User < ActiveRecord::Base normalizes :email, with: -> email { email.strip.downcase } normalizes :phone, with: -> phone { phone.delete(\"^0-9\").delete_prefix(\"1\") } end  user = User.create(email: \" CRUISE-CONTROL@EXAMPLE.COM\\n\") user.email                  # => \"cruise-control@example.com\"  user = User.find_by(email: \"\\tCRUISE-CONTROL@EXAMPLE.COM \") user.email                  # => \"cruise-control@example.com\" user.email_before_type_cast # => \"cruise-control@example.com\"  User.where(email: \"\\tCRUISE-CONTROL@EXAMPLE.COM \").count         # => 1 User.where([\"email = ?\", \"\\tCRUISE-CONTROL@EXAMPLE.COM \"]).count # => 0  User.exists?(email: \"\\tCRUISE-CONTROL@EXAMPLE.COM \")         # => true User.exists?([\"email = ?\", \"\\tCRUISE-CONTROL@EXAMPLE.COM \"]) # => false  User.normalize_value_for(:phone, \"+1 (555) 867-5309\") # => \"5558675309\"",
    "label": "",
    "id": "1261"
  },
  {
    "raw_code": "def normalizes(*names, with:, apply_to_nil: false)\n          decorate_attributes(names) do |name, cast_type|\n            NormalizedValueType.new(cast_type: cast_type, normalizer: with, normalize_nil: apply_to_nil)\n          end",
    "comment": "Declares a normalization for one or more attributes. The normalization is applied when the attribute is assigned or validated.  Because the normalization may be applied multiple times, it should be _idempotent_. In other words, applying the normalization more than once should have the same result as applying it only once.  By default, the normalization will not be applied to +nil+ values. This behavior can be changed with the +:apply_to_nil+ option.  ==== Options  * +:with+ - Any callable object that accepts the attribute's value as its sole argument, and returns it normalized. * +:apply_to_nil+ - Whether to apply the normalization to +nil+ values. Defaults to +false+.  ==== Examples  class User include ActiveModel::Attributes include ActiveModel::Attributes::Normalization  attribute :email, :string attribute :phone, :string  normalizes :email, with: -> email { email.strip.downcase } normalizes :phone, with: -> phone { phone.delete(\"^0-9\").delete_prefix(\"1\") } end  user = User.new user.email =    \" CRUISE-CONTROL@EXAMPLE.COM\\n\" user.email # => \"cruise-control@example.com\"  User.normalize_value_for(:phone, \"+1 (555) 867-5309\") # => \"5558675309\"",
    "label": "",
    "id": "1262"
  },
  {
    "raw_code": "def normalize_value_for(name, value)\n          type_for_attribute(name).cast(value)\n        end",
    "comment": "Normalizes a given +value+ using normalizations declared for +name+.  ==== Examples  class User include ActiveModel::Attributes include ActiveModel::Attributes::Normalization  attribute :email, :string  normalizes :email, with: -> email { email.strip.downcase } end  User.normalize_value_for(:email, \" CRUISE-CONTROL@EXAMPLE.COM\\n\") # => \"cruise-control@example.com\"",
    "label": "",
    "id": "1263"
  },
  {
    "raw_code": "def as_json(options = nil)\n        root = if options && options.key?(:root)\n          options[:root]\n        else\n          include_root_in_json\n        end",
    "comment": "Returns a hash representing the model. Some configuration can be passed through +options+.  The option <tt>include_root_in_json</tt> controls the top-level behavior of +as_json+. If +true+, +as_json+ will emit a single root node named after the object's type. The default value for <tt>include_root_in_json</tt> option is +false+.  user = User.find(1) user.as_json # => { \"id\" => 1, \"name\" => \"Konata Izumi\", \"age\" => 16, #     \"created_at\" => \"2006-08-01T17:27:133.000Z\", \"awesome\" => true}  ActiveRecord::Base.include_root_in_json = true  user.as_json # => { \"user\" => { \"id\" => 1, \"name\" => \"Konata Izumi\", \"age\" => 16, #                  \"created_at\" => \"2006-08-01T17:27:13.000Z\", \"awesome\" => true } }  This behavior can also be achieved by setting the <tt>:root</tt> option to +true+ as in:  user = User.find(1) user.as_json(root: true) # => { \"user\" => { \"id\" => 1, \"name\" => \"Konata Izumi\", \"age\" => 16, #                  \"created_at\" => \"2006-08-01T17:27:13.000Z\", \"awesome\" => true } }  If you prefer, <tt>:root</tt> may also be set to a custom string key instead as in:  user = User.find(1) user.as_json(root: \"author\") # => { \"author\" => { \"id\" => 1, \"name\" => \"Konata Izumi\", \"age\" => 16, #                  \"created_at\" => \"2006-08-01T17:27:13.000Z\", \"awesome\" => true } }  Without any +options+, the returned Hash will include all the model's attributes.  user = User.find(1) user.as_json # => { \"id\" => 1, \"name\" => \"Konata Izumi\", \"age\" => 16, #      \"created_at\" => \"2006-08-01T17:27:13.000Z\", \"awesome\" => true}  The <tt>:only</tt> and <tt>:except</tt> options can be used to limit the attributes included, and work similar to the +attributes+ method.  user.as_json(only: [:id, :name]) # => { \"id\" => 1, \"name\" => \"Konata Izumi\" }  user.as_json(except: [:id, :created_at, :age]) # => { \"name\" => \"Konata Izumi\", \"awesome\" => true }  To include the result of some method calls on the model use <tt>:methods</tt>:  user.as_json(methods: :permalink) # => { \"id\" => 1, \"name\" => \"Konata Izumi\", \"age\" => 16, #      \"created_at\" => \"2006-08-01T17:27:13.000Z\", \"awesome\" => true, #      \"permalink\" => \"1-konata-izumi\" }  To include associations use <tt>:include</tt>:  user.as_json(include: :posts) # => { \"id\" => 1, \"name\" => \"Konata Izumi\", \"age\" => 16, #      \"created_at\" => \"2006-08-01T17:27:13.000Z\", \"awesome\" => true, #      \"posts\" => [ { \"id\" => 1, \"author_id\" => 1, \"title\" => \"Welcome to the weblog\" }, #                   { \"id\" => 2, \"author_id\" => 1, \"title\" => \"So I was thinking\" } ] }  Second level and higher order associations work as well:  user.as_json(include: { posts: { include: { comments: { only: :body } }, only: :title } }) # => { \"id\" => 1, \"name\" => \"Konata Izumi\", \"age\" => 16, #      \"created_at\" => \"2006-08-01T17:27:13.000Z\", \"awesome\" => true, #      \"posts\" => [ { \"comments\" => [ { \"body\" => \"1st post!\" }, { \"body\" => \"Second!\" } ], #                     \"title\" => \"Welcome to the weblog\" }, #                   { \"comments\" => [ { \"body\" => \"Don't think too hard\" } ], #                     \"title\" => \"So I was thinking\" } ] }",
    "label": "",
    "id": "1264"
  },
  {
    "raw_code": "def from_json(json, include_root = include_root_in_json)\n        hash = ActiveSupport::JSON.decode(json)\n        hash = hash.values.first if include_root\n        self.attributes = hash\n        self\n      end",
    "comment": "Sets the model +attributes+ from a JSON string. Returns +self+.  class Person include ActiveModel::Serializers::JSON  attr_accessor :name, :age, :awesome  def attributes=(hash) hash.each do |key, value| send(\"#{key}=\", value) end end  def attributes instance_values end end  json = { name: 'bob', age: 22, awesome:true }.to_json person = Person.new person.from_json(json) # => #<Person:0x007fec5e7a0088 @age=22, @awesome=true, @name=\"bob\"> person.name            # => \"bob\" person.age             # => 22 person.awesome         # => true  The default value for +include_root+ is +false+. You can change it to +true+ if the given JSON string includes a single root node.  json = { person: { name: 'bob', age: 22, awesome:true } }.to_json person = Person.new person.from_json(json, true) # => #<Person:0x007fec5e7a0088 @age=22, @awesome=true, @name=\"bob\"> person.name                  # => \"bob\" person.age                   # => 22 person.awesome               # => true",
    "label": "",
    "id": "1265"
  },
  {
    "raw_code": "def microseconds(time)\n          time[:sec_fraction] ? (time[:sec_fraction] * 1_000_000).to_i : 0\n        end",
    "comment": "'0.123456' -> 123456 '1.123456' -> 123456",
    "label": "",
    "id": "1266"
  },
  {
    "raw_code": "def initialize(precision: nil, limit: nil, scale: nil)\n        super()\n        @precision = precision\n        @scale = scale\n        @limit = limit\n      end",
    "comment": "Initializes a type with three basic configuration settings: precision, limit, and scale. The Value base class does not define behavior for these settings. It uses them for equality comparison and hash key generation only.",
    "label": "",
    "id": "1267"
  },
  {
    "raw_code": "def serializable?(value, &)\n        true\n      end",
    "comment": "Returns true if this type can convert +value+ to a type that is usable by the database.  For example a boolean type can return +true+ if the value parameter is a Ruby boolean, but may return +false+ if the value parameter is some other object.",
    "label": "",
    "id": "1268"
  },
  {
    "raw_code": "def type\n      end",
    "comment": "Returns the unique type name as a Symbol. Subclasses should override this method.",
    "label": "",
    "id": "1269"
  },
  {
    "raw_code": "def deserialize(value)\n        cast(value)\n      end",
    "comment": "Converts a value from database input to the appropriate ruby type. The return value of this method will be returned from ActiveRecord::AttributeMethods::Read#read_attribute. The default implementation just calls Value#cast.  +value+ The raw input, as provided from the database.",
    "label": "",
    "id": "1270"
  },
  {
    "raw_code": "def cast(value)\n        cast_value(value) unless value.nil?\n      end",
    "comment": "Type casts a value from user input (e.g. from a setter). This value may be a string from the form builder, or a ruby object passed to a setter. There is currently no way to differentiate between which source it came from.  The return value of this method will be returned from ActiveRecord::AttributeMethods::Read#read_attribute. See also: Value#cast_value.  +value+ The raw input, as provided to the attribute setter.",
    "label": "",
    "id": "1271"
  },
  {
    "raw_code": "def serialize(value)\n        value\n      end",
    "comment": "Casts a value from the ruby type to a type that the database knows how to understand. The returned value from this method should be a +String+, +Numeric+, +Date+, +Time+, +Symbol+, +true+, +false+, or +nil+.",
    "label": "",
    "id": "1272"
  },
  {
    "raw_code": "def type_cast_for_schema(value) # :nodoc:\n        value.inspect\n      end",
    "comment": "Type casts a value for schema dumping. This method is private, as we are hoping to remove it entirely.",
    "label": "",
    "id": "1273"
  },
  {
    "raw_code": "def binary? # :nodoc:\n        false\n      end",
    "comment": "These predicates are not documented, as I need to look further into their use, and see if they can be removed entirely.",
    "label": "",
    "id": "1274"
  },
  {
    "raw_code": "def changed?(old_value, new_value, _new_value_before_type_cast)\n        old_value != new_value\n      end",
    "comment": "Determines whether a value has changed for dirty checking. +old_value+ and +new_value+ will always be type-cast. Types should not need to override this method.",
    "label": "",
    "id": "1275"
  },
  {
    "raw_code": "def changed_in_place?(raw_old_value, new_value)\n        false\n      end",
    "comment": "Determines whether the mutable value has been modified since it was read. Returns +false+ by default. If your type returns an object which could be mutated, you should override this method. You will need to either:  - pass +new_value+ to Value#serialize and compare it to +raw_old_value+  or  - pass +raw_old_value+ to Value#deserialize and compare it to +new_value+  +raw_old_value+ The original value, before being passed to +deserialize+.  +new_value+ The current value, after type casting.",
    "label": "",
    "id": "1276"
  },
  {
    "raw_code": "def cast_value(value) # :doc:\n          value\n        end",
    "comment": "Convenience method for types which do not need separate type casting behavior for user and database inputs. Called by Value#cast for values except +nil+.",
    "label": "",
    "id": "1277"
  },
  {
    "raw_code": "def changed_in_place?(raw_old_value, new_value)\n          raw_old_value != serialize(new_value)\n        end",
    "comment": "+raw_old_value+ will be the `_before_type_cast` version of the value (likely a string). +new_value+ will be the current, type cast value.",
    "label": "",
    "id": "1278"
  },
  {
    "raw_code": "def fast_string_to_time(string)\n              return unless string.include?(\"-\") #  Time.new(\"1234\") # => 1234-01-01 00:00:00\n\n              if is_utc?\n                ::Time.at(::Time.new(string, in: \"UTC\"))\n              else\n                ::Time.new(string)\n              end",
    "comment": "BUG: Wrapping the Time object with Time.at because Time.new with `in:` in Ruby 3.2.0 used to return an invalid Time object see: https://bugs.ruby-lang.org/issues/19292",
    "label": "",
    "id": "1279"
  },
  {
    "raw_code": "def validates_absence_of(*attr_names)\n        validates_with AbsenceValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates that the specified attributes are blank (as defined by Object#present?).  class Person < ActiveRecord::Base validates_absence_of :first_name end  The first_name attribute must be in the object and it must be blank.  Configuration options: * <tt>:message</tt> - A custom error message (default is: \"must be blank\").  There is also a list of default options supported by every validator: +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+. See ActiveModel::Validations::ClassMethods#validates for more information.",
    "label": "",
    "id": "1280"
  },
  {
    "raw_code": "def validates_acceptance_of(*attr_names)\n        validates_with AcceptanceValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Encapsulates the pattern of wanting to validate the acceptance of a terms of service check box (or similar agreement).  class Person < ActiveRecord::Base validates_acceptance_of :terms_of_service validates_acceptance_of :eula, message: 'must be abided' end  If the database column does not exist, the +terms_of_service+ attribute is entirely virtual. This check is performed only if +terms_of_service+ is not +nil+.  Configuration options: * <tt>:message</tt> - A custom error message (default is: \"must be accepted\"). * <tt>:accept</tt> - Specifies a value that is considered accepted. Also accepts an array of possible values. The default value is an array [\"1\", true], which makes it easy to relate to an HTML checkbox. This should be set to, or include, +true+ if you are validating a database column, since the attribute is typecast from \"1\" to +true+ before validation.  There is also a list of default options supported by every validator: +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+. See ActiveModel::Validations::ClassMethods#validates for more information.",
    "label": "",
    "id": "1281"
  },
  {
    "raw_code": "def before_validation(*args, &block)\n          options = args.extract_options!\n\n          set_options_for_callback(options)\n\n          set_callback(:validation, :before, *args, options, &block)\n        end",
    "comment": "Defines a callback that will get called right before validation.  class Person include ActiveModel::Validations include ActiveModel::Validations::Callbacks  attr_accessor :name  validates_length_of :name, maximum: 6  before_validation :remove_whitespaces  private def remove_whitespaces name.strip! end end  person = Person.new person.name = '  bob  ' person.valid? # => true person.name   # => \"bob\"",
    "label": "",
    "id": "1282"
  },
  {
    "raw_code": "def after_validation(*args, &block)\n          options = args.extract_options!\n          options = options.dup\n          options[:prepend] = true\n\n          set_options_for_callback(options)\n\n          set_callback(:validation, :after, *args, options, &block)\n        end",
    "comment": "Defines a callback that will get called right after validation.  class Person include ActiveModel::Validations include ActiveModel::Validations::Callbacks  attr_accessor :name, :status  validates_presence_of :name  after_validation :set_status  private def set_status self.status = errors.empty? end end  person = Person.new person.name = '' person.valid? # => false person.status # => false person.name = 'bob' person.valid? # => true person.status # => true",
    "label": "",
    "id": "1283"
  },
  {
    "raw_code": "def run_validations!\n        _run_validation_callbacks { super }\n      end",
    "comment": "Override run_validations! to include callbacks.",
    "label": "",
    "id": "1284"
  },
  {
    "raw_code": "def inclusion_method(enumerable)\n        if enumerable.is_a? Range\n          case enumerable.begin || enumerable.end\n          when Numeric, Time, DateTime, Date\n            :cover?\n          else\n            :include?\n          end",
    "comment": "After Ruby 2.2, <tt>Range#include?</tt> on non-number-or-time-ish ranges checks all possible values in the range for equality, which is slower but more accurate. <tt>Range#cover?</tt> uses the previous logic of comparing a value with the range endpoints, which is fast but is only accurate on Numeric, Time, Date, or DateTime ranges.",
    "label": "",
    "id": "1285"
  },
  {
    "raw_code": "def validates_comparison_of(*attr_names)\n        validates_with ComparisonValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates the value of a specified attribute fulfills all defined comparisons with another value, proc, or attribute.  class Person < ActiveRecord::Base validates_comparison_of :value, greater_than: 'the sum of its parts' end  Configuration options: * <tt>:message</tt> - A custom error message (default is: \"failed comparison\"). * <tt>:greater_than</tt> - Specifies the value must be greater than the supplied value. The default error message for this option is _\"must be greater than %{count}\"_. * <tt>:greater_than_or_equal_to</tt> - Specifies the value must be greater than or equal to the supplied value. The default error message for this option is _\"must be greater than or equal to %{count}\"_. * <tt>:equal_to</tt> - Specifies the value must be equal to the supplied value. The default error message for this option is _\"must be equal to %{count}\"_. * <tt>:less_than</tt> - Specifies the value must be less than the supplied value. The default error message for this option is _\"must be less than %{count}\"_. * <tt>:less_than_or_equal_to</tt> - Specifies the value must be less than or equal to the supplied value. The default error message for this option is _\"must be less than or equal to %{count}\"_. * <tt>:other_than</tt> - Specifies the value must not be equal to the supplied value. The default error message for this option is _\"must be other than %{count}\"_.  There is also a list of default options supported by every validator: +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+ . See ActiveModel::Validations::ClassMethods#validates for more information.  The validator requires at least one of the following checks to be supplied. Each will accept a proc, value, or a symbol which corresponds to a method:  * <tt>:greater_than</tt> * <tt>:greater_than_or_equal_to</tt> * <tt>:equal_to</tt> * <tt>:less_than</tt> * <tt>:less_than_or_equal_to</tt> * <tt>:other_than</tt>  For example:  class Person < ActiveRecord::Base validates_comparison_of :birth_date, less_than_or_equal_to: -> { Date.today } validates_comparison_of :preferred_name, other_than: :given_name, allow_nil: true end",
    "label": "",
    "id": "1286"
  },
  {
    "raw_code": "def validates_confirmation_of(*attr_names)\n        validates_with ConfirmationValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Encapsulates the pattern of wanting to validate a password or email address field with a confirmation.  Model: class Person < ActiveRecord::Base validates_confirmation_of :user_name, :password validates_confirmation_of :email_address, message: 'should match confirmation' end  View: <%= password_field \"person\", \"password\" %> <%= password_field \"person\", \"password_confirmation\" %>  The added +password_confirmation+ attribute is virtual; it exists only as an in-memory attribute for validating the password. To achieve this, the validation adds accessors to the model for the confirmation attribute.  NOTE: This check is performed only if +password_confirmation+ is not +nil+. To require confirmation, make sure to add a presence check for the confirmation attribute:  validates_presence_of :password_confirmation, if: :password_changed?  Configuration options: * <tt>:message</tt> - A custom error message (default is: \"doesn't match <tt>%{translated_attribute_name}</tt>\"). * <tt>:case_sensitive</tt> - Looks for an exact match. Ignored by non-text columns (+true+ by default).  There is also a list of default options supported by every validator: +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+. See ActiveModel::Validations::ClassMethods#validates for more information.",
    "label": "",
    "id": "1287"
  },
  {
    "raw_code": "def validates_exclusion_of(*attr_names)\n        validates_with ExclusionValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates that the value of the specified attribute is not in a particular enumerable object.  class Person < ActiveRecord::Base validates_exclusion_of :username, in: %w( admin superuser ), message: \"You don't belong here\" validates_exclusion_of :age, in: 30..60, message: 'This site is only for under 30 and over 60' validates_exclusion_of :format, in: %w( mov avi ), message: \"extension %{value} is not allowed\" validates_exclusion_of :password, in: ->(person) { [person.username, person.first_name] }, message: 'should not be the same as your username or first name' validates_exclusion_of :karma, in: :reserved_karmas end  Configuration options: * <tt>:in</tt> - An enumerable object of items that the value shouldn't be part of. This can be supplied as a proc, lambda, or symbol which returns an enumerable. If the enumerable is a numerical, time, or datetime range the test is performed with <tt>Range#cover?</tt>, otherwise with <tt>include?</tt>. When using a proc or lambda the instance under validation is passed as an argument. * <tt>:within</tt> - A synonym(or alias) for <tt>:in</tt> <tt>Range#cover?</tt>, otherwise with <tt>include?</tt>. * <tt>:message</tt> - Specifies a custom error message (default is: \"is reserved\").  There is also a list of default options supported by every validator: +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+. See ActiveModel::Validations::ClassMethods#validates for more information.",
    "label": "",
    "id": "1288"
  },
  {
    "raw_code": "def validates_format_of(*attr_names)\n        validates_with FormatValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates whether the value of the specified attribute is of the correct form, going by the regular expression provided. You can require that the attribute matches the regular expression:  class Person < ActiveRecord::Base validates_format_of :email, with: /\\A([^@\\s]+)@((?:[-a-z0-9]+\\.)+[a-z]{2,})\\z/i, on: :create end  Alternatively, you can require that the specified attribute does _not_ match the regular expression:  class Person < ActiveRecord::Base validates_format_of :email, without: /NOSPAM/ end  You can also provide a proc or lambda which will determine the regular expression that will be used to validate the attribute.  class Person < ActiveRecord::Base # Admin can have number as a first letter in their screen name validates_format_of :screen_name, with: ->(person) { person.admin? ? /\\A[a-z0-9][a-z0-9_\\-]*\\z/i : /\\A[a-z][a-z0-9_\\-]*\\z/i } end  Note: use <tt>\\A</tt> and <tt>\\z</tt> to match the start and end of the string, <tt>^</tt> and <tt>$</tt> match the start/end of a line.  Due to frequent misuse of <tt>^</tt> and <tt>$</tt>, you need to pass the <tt>multiline: true</tt> option in case you use any of these two anchors in the provided regular expression. In most cases, you should be using <tt>\\A</tt> and <tt>\\z</tt>.  You must pass either <tt>:with</tt> or <tt>:without</tt> as an option. In addition, both must be a regular expression or a proc or lambda, or else an exception will be raised.  Configuration options: * <tt>:message</tt> - A custom error message (default is: \"is invalid\"). * <tt>:with</tt> - Regular expression that if the attribute matches will result in a successful validation. This can be provided as a proc or lambda returning regular expression which will be called at runtime. * <tt>:without</tt> - Regular expression that if the attribute does not match will result in a successful validation. This can be provided as a proc or lambda returning regular expression which will be called at runtime. * <tt>:multiline</tt> - Set to true if your regular expression contains anchors that match the beginning or end of lines as opposed to the beginning or end of the string. These anchors are <tt>^</tt> and <tt>$</tt>.  There is also a list of default options supported by every validator: +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+. See ActiveModel::Validations::ClassMethods#validates for more information.",
    "label": "",
    "id": "1289"
  },
  {
    "raw_code": "def validates_inclusion_of(*attr_names)\n        validates_with InclusionValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates whether the value of the specified attribute is available in a particular enumerable object.  class Person < ActiveRecord::Base validates_inclusion_of :role, in: %w( admin contributor ) validates_inclusion_of :age, in: 0..99 validates_inclusion_of :format, in: %w( jpg gif png ), message: \"extension %{value} is not included in the list\" validates_inclusion_of :states, in: ->(person) { STATES[person.country] } validates_inclusion_of :karma, in: :available_karmas end  Configuration options: * <tt>:in</tt> - An enumerable object of available items. This can be supplied as a proc, lambda, or symbol which returns an enumerable. If the enumerable is a numerical, time, or datetime range the test is performed with <tt>Range#cover?</tt>, otherwise with <tt>include?</tt>. When using a proc or lambda the instance under validation is passed as an argument. * <tt>:within</tt> - A synonym(or alias) for <tt>:in</tt> * <tt>:message</tt> - Specifies a custom error message (default is: \"is not included in the list\").  There is also a list of default options supported by every validator: +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+. See ActiveModel::Validations::ClassMethods#validates for more information.",
    "label": "",
    "id": "1290"
  },
  {
    "raw_code": "def validates_length_of(*attr_names)\n        validates_with LengthValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates that the specified attributes match the length restrictions supplied. Only one constraint option can be used at a time apart from +:minimum+ and +:maximum+ that can be combined together:  class Person < ActiveRecord::Base validates_length_of :first_name, maximum: 30 validates_length_of :last_name, maximum: 30, message: \"less than 30 if you don't mind\" validates_length_of :fax, in: 7..32, allow_nil: true validates_length_of :phone, in: 7..32, allow_blank: true validates_length_of :user_name, within: 6..20, too_long: 'pick a shorter name', too_short: 'pick a longer name' validates_length_of :zip_code, minimum: 5, too_short: 'please enter at least 5 characters' validates_length_of :smurf_leader, is: 4, message: \"papa is spelled with 4 characters... don't play me.\" validates_length_of :words_in_essay, minimum: 100, too_short: 'Your essay must be at least 100 words.'  private def words_in_essay essay.scan(/\\w+/) end end  Constraint options:  * <tt>:minimum</tt> - The minimum size of the attribute. * <tt>:maximum</tt> - The maximum size of the attribute. Allows +nil+ by default if not used with +:minimum+. * <tt>:is</tt> - The exact size of the attribute. * <tt>:within</tt> - A range specifying the minimum and maximum size of the attribute. * <tt>:in</tt> - A synonym (or alias) for <tt>:within</tt>.  Other options:  * <tt>:allow_nil</tt> - Attribute may be +nil+; skip validation. * <tt>:allow_blank</tt> - Attribute may be blank; skip validation. * <tt>:too_long</tt> - The error message if the attribute goes over the maximum (default is: \"is too long (maximum is %{count} characters)\"). * <tt>:too_short</tt> - The error message if the attribute goes under the minimum (default is: \"is too short (minimum is %{count} characters)\"). * <tt>:wrong_length</tt> - The error message if using the <tt>:is</tt> method and the attribute is the wrong size (default is: \"is the wrong length (should be %{count} characters)\"). * <tt>:message</tt> - The error message to use for a <tt>:minimum</tt>, <tt>:maximum</tt>, or <tt>:is</tt> violation. An alias of the appropriate <tt>too_long</tt>/<tt>too_short</tt>/<tt>wrong_length</tt> message.  There is also a list of default options supported by every validator: +:if+, +:unless+, +:on+, and +:strict+. See ActiveModel::Validations::ClassMethods#validates for more information.",
    "label": "",
    "id": "1291"
  },
  {
    "raw_code": "def validates_numericality_of(*attr_names)\n        validates_with NumericalityValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates whether the value of the specified attribute is numeric by trying to convert it to a float with +Kernel.Float+ (if <tt>only_integer</tt> is +false+) or applying it to the regular expression <tt>/\\A[\\+\\-]?\\d+\\z/</tt> (if <tt>only_integer</tt> is set to +true+). Precision of +Kernel.Float+ values are guaranteed up to 15 digits.  class Person < ActiveRecord::Base validates_numericality_of :value, on: :create end  Configuration options: * <tt>:message</tt> - A custom error message (default is: \"is not a number\"). * <tt>:only_integer</tt> - Specifies whether the value has to be an integer (default is +false+). * <tt>:only_numeric</tt> - Specifies whether the value has to be an instance of Numeric (default is +false+). The default behavior is to attempt parsing the value if it is a String. * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+ (default is +false+). Notice that for Integer and Float columns empty strings are converted to +nil+. * <tt>:greater_than</tt> - Specifies the value must be greater than the supplied value. The default error message for this option is _\"must be greater than %{count}\"_. * <tt>:greater_than_or_equal_to</tt> - Specifies the value must be greater than or equal the supplied value. The default error message for this option is _\"must be greater than or equal to %{count}\"_. * <tt>:equal_to</tt> - Specifies the value must be equal to the supplied value. The default error message for this option is _\"must be equal to %{count}\"_. * <tt>:less_than</tt> - Specifies the value must be less than the supplied value. The default error message for this option is _\"must be less than %{count}\"_. * <tt>:less_than_or_equal_to</tt> - Specifies the value must be less than or equal the supplied value. The default error message for this option is _\"must be less than or equal to %{count}\"_. * <tt>:other_than</tt> - Specifies the value must be other than the supplied value. The default error message for this option is _\"must be other than %{count}\"_. * <tt>:odd</tt> - Specifies the value must be an odd number. The default error message for this option is _\"must be odd\"_. * <tt>:even</tt> - Specifies the value must be an even number. The default error message for this option is _\"must be even\"_. * <tt>:in</tt> - Check that the value is within a range. The default error message for this option is _\"must be in %{count}\"_.  There is also a list of default options supported by every validator: +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+ . See ActiveModel::Validations::ClassMethods#validates for more information.  The following checks can also be supplied with a proc or a symbol which corresponds to a method:  * <tt>:greater_than</tt> * <tt>:greater_than_or_equal_to</tt> * <tt>:equal_to</tt> * <tt>:less_than</tt> * <tt>:less_than_or_equal_to</tt> * <tt>:only_integer</tt> * <tt>:other_than</tt>  For example:  class Person < ActiveRecord::Base validates_numericality_of :width, less_than: ->(person) { person.height } validates_numericality_of :width, greater_than: :minimum_weight end",
    "label": "",
    "id": "1292"
  },
  {
    "raw_code": "def validates_presence_of(*attr_names)\n        validates_with PresenceValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates that the specified attributes are not blank (as defined by Object#blank?).  class Person < ActiveRecord::Base validates_presence_of :first_name end  The first_name attribute must be in the object and it cannot be blank.  If you want to validate the presence of a boolean field (where the real values are +true+ and +false+), you will want to use <tt>validates_inclusion_of :field_name, in: [true, false]</tt>.  This is due to the way Object#blank? handles boolean values: <tt>false.blank? # => true</tt>.  Configuration options: * <tt>:message</tt> - A custom error message (default is: \"can't be blank\").  There is also a list of default options supported by every validator: +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+. See ActiveModel::Validations::ClassMethods#validates for more information.",
    "label": "",
    "id": "1293"
  },
  {
    "raw_code": "def validates(*attributes)\n        defaults = attributes.extract_options!.dup\n        validations = defaults.slice!(*_validates_default_keys)\n\n        raise ArgumentError, \"You need to supply at least one attribute\" if attributes.empty?\n        raise ArgumentError, \"You need to supply at least one validation\" if validations.empty?\n\n        defaults[:attributes] = attributes\n\n        validations.each do |key, options|\n          key = \"#{key.to_s.camelize}Validator\"\n\n          begin\n            validator = const_get(key)\n          rescue NameError\n            raise ArgumentError, \"Unknown validator: '#{key}'\"\n          end",
    "comment": "This method is a shortcut to all default validators and any custom validator classes ending in 'Validator'. Note that \\Rails default validators can be overridden inside specific classes by creating custom validator classes in their place such as PresenceValidator.  Examples of using the default Rails validators:  validates :username, absence: true validates :terms, acceptance: true validates :password, confirmation: true validates :username, exclusion: { in: %w(admin superuser) } validates :email, format: { with: /\\A([^@\\s]+)@((?:[-a-z0-9]+\\.)+[a-z]{2,})\\z/i, on: :create } validates :age, inclusion: { in: 0..9 } validates :first_name, length: { maximum: 30 } validates :age, numericality: true validates :username, presence: true  The power of the +validates+ method comes when using custom validators and default validators in one call for a given attribute.  class EmailValidator < ActiveModel::EachValidator def validate_each(record, attribute, value) record.errors.add attribute, (options[:message] || \"is not an email\") unless /\\A([^@\\s]+)@((?:[-a-z0-9]+\\.)+[a-z]{2,})\\z/i.match?(value) end end  class Person include ActiveModel::Validations attr_accessor :name, :email  validates :name, presence: true, length: { maximum: 100 } validates :email, presence: true, email: true end  Validator classes may also exist within the class being validated allowing custom modules of validators to be included as needed.  class Film include ActiveModel::Validations  class TitleValidator < ActiveModel::EachValidator def validate_each(record, attribute, value) record.errors.add attribute, \"must start with 'the'\" unless /\\Athe/i.match?(value) end end  validates :name, title: true end  Additionally validator classes may be in another namespace and still used within any class.  validates :name, :'film/title' => true  The validators hash can also handle regular expressions, ranges, arrays and strings in shortcut form.  validates :email, format: /@/ validates :role, inclusion: %w(admin contributor) validates :password, length: 6..20  When using shortcut form, ranges and arrays are passed to your validator's initializer as <tt>options[:in]</tt> while other types including regular expressions and strings are passed as <tt>options[:with]</tt>.  There is also a list of options that could be used along with validators:  * <tt>:on</tt> - Specifies the contexts where this validation is active. Runs in all validation contexts by default +nil+. You can pass a symbol or an array of symbols. (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt> or <tt>on: [:create, :custom_validation_context]</tt>) * <tt>:except_on</tt> - Specifies the contexts where this validation is not active. Runs in all validation contexts by default +nil+. You can pass a symbol or an array of symbols. (e.g. <tt>except: :create</tt> or <tt>except_on: :custom_validation_context</tt> or <tt>except_on: [:create, :custom_validation_context]</tt>) * <tt>:if</tt> - Specifies a method, proc or string to call to determine if the validation should occur (e.g. <tt>if: :allow_validation</tt>, or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method, proc or string should return or evaluate to a +true+ or +false+ value. * <tt>:unless</tt> - Specifies a method, proc, or string to call to determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>, or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The method, proc, or string should return or evaluate to a +true+ or +false+ value. * <tt>:allow_nil</tt> - Skip validation if the attribute is +nil+. * <tt>:allow_blank</tt> - Skip validation if the attribute is blank. * <tt>:strict</tt> - If the <tt>:strict</tt> option is set to true will raise ActiveModel::StrictValidationFailed instead of adding the error. <tt>:strict</tt> option can also be set to any other exception.  Example:  validates :password, presence: true, confirmation: true, if: :password_required? validates :token, length: { is: 24 }, strict: TokenLengthException   Finally, the options +:if+, +:unless+, +:on+, +:allow_blank+, +:allow_nil+, +:strict+ and +:message+ can be given to one specific validator, as a hash:  validates :password, presence: { if: :password_required?, message: 'is forgotten.' }, confirmation: true",
    "label": "",
    "id": "1294"
  },
  {
    "raw_code": "def validates!(*attributes)\n        options = attributes.extract_options!\n        options[:strict] = true\n        validates(*(attributes << options))\n      end",
    "comment": "This method is used to define validations that cannot be corrected by end users and are considered exceptional. So each validator defined with bang or <tt>:strict</tt> option set to <tt>true</tt> will always raise ActiveModel::StrictValidationFailed instead of adding error when validation fails. See <tt>validates</tt> for more information about the validation itself.  class Person include ActiveModel::Validations  attr_accessor :name validates! :name, presence: true end  person = Person.new person.name = '' person.valid? # => ActiveModel::StrictValidationFailed: Name can't be blank",
    "label": "",
    "id": "1295"
  },
  {
    "raw_code": "def _validates_default_keys\n        [:if, :unless, :on, :allow_blank, :allow_nil, :strict, :except_on]\n      end",
    "comment": "When creating custom validators, it might be useful to be able to specify additional default keys. This can be done by overwriting this method.",
    "label": "",
    "id": "1296"
  },
  {
    "raw_code": "def validates_with(*args, &block)\n        options = args.extract_options!\n        options[:class] = self\n\n        args.each do |klass|\n          validator = klass.new(options.dup, &block)\n\n          if validator.respond_to?(:attributes) && !validator.attributes.empty?\n            validator.attributes.each do |attribute|\n              _validators[attribute.to_sym] << validator\n            end",
    "comment": "Passes the record off to the class or classes specified and allows them to add errors based on more complex conditions.  class Person include ActiveModel::Validations validates_with MyValidator end  class MyValidator < ActiveModel::Validator def validate(record) if some_complex_logic record.errors.add :base, 'This record is invalid' end end  private def some_complex_logic # ... end end  You may also pass it multiple classes, like so:  class Person include ActiveModel::Validations validates_with MyValidator, MyOtherValidator, on: :create end  There is no default error message for +validates_with+. You must manually add errors to the record's errors collection in the validator class.  To implement the validate method, you must have a +record+ parameter defined, which is the record to be validated.  Configuration options: * <tt>:on</tt> - Specifies the contexts where this validation is active. Runs in all validation contexts by default +nil+. You can pass a symbol or an array of symbols. (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt> or <tt>on: [:create, :custom_validation_context]</tt>) * <tt>:if</tt> - Specifies a method, proc, or string to call to determine if the validation should occur (e.g. <tt>if: :allow_validation</tt>, or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method, proc, or string should return or evaluate to a +true+ or +false+ value. * <tt>:unless</tt> - Specifies a method, proc, or string to call to determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>, or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The method, proc, or string should return or evaluate to a +true+ or +false+ value. * <tt>:strict</tt> - Specifies whether validation should be strict. See <tt>ActiveModel::Validations#validates!</tt> for more information.  If you pass any additional configuration options, they will be passed to the class and available as +options+:  class Person include ActiveModel::Validations validates_with MyValidator, my_custom_key: 'my custom value' end  class MyValidator < ActiveModel::Validator def validate(record) options[:my_custom_key] # => \"my custom value\" end end",
    "label": "",
    "id": "1297"
  },
  {
    "raw_code": "def validates_with(*args, &block)\n      options = args.extract_options!\n      options[:class] = self.class\n\n      args.each do |klass|\n        validator = klass.new(options.dup, &block)\n        validator.validate(self)\n      end",
    "comment": "Passes the record off to the class or classes specified and allows them to add errors based on more complex conditions.  class Person include ActiveModel::Validations  validate :instance_validations  def instance_validations validates_with MyValidator end end  Please consult the class method documentation for more information on creating your own validator.  You may also pass it multiple classes, like so:  class Person include ActiveModel::Validations  validate :instance_validations, on: :create  def instance_validations validates_with MyValidator, MyOtherValidator end end  Standard configuration options (<tt>:on</tt>, <tt>:if</tt> and <tt>:unless</tt>), which are available on the class version of +validates_with+, should instead be placed on the +validates+ method as these are applied and tested in the callback.  If you pass any additional configuration options, they will be passed to the class and available as +options+, please refer to the class version of this method for more information.",
    "label": "",
    "id": "1298"
  },
  {
    "raw_code": "def @contact.label; \"Has cheezburger\"; end\n    def @contact.favorite_quote; \"Constraints are liberating\"; end\n\n    # Single method.\n    assert_match %r{\"label\":\"Has cheezburger\"}, @contact.to_json(only: :name, methods: :label)\n\n    # Both methods.\n    methods_json = @contact.to_json(only: :name, methods: [:label, :favorite_quote])\n    assert_match %r{\"label\":\"Has cheezburger\"}, methods_json\n    assert_match %r{\"favorite_quote\":\"Constraints are liberating\"}, methods_json\n  end\n\n  test \"should return Hash for errors\" do\n    contact = Contact.new\n    contact.errors.add :name, \"can't be blank\"\n    contact.errors.add :name, \"is too short (minimum is 2 characters)\"\n    contact.errors.add :age, \"must be 16 or over\"\n\n    hash = {}\n    hash[:name] = [\"can't be blank\", \"is too short (minimum is 2 characters)\"]\n    hash[:age]  = [\"must be 16 or over\"]\n    assert_equal hash.to_json, contact.errors.to_json\n  end",
    "comment": "Define methods on fixture.",
    "label": "",
    "id": "1299"
  },
  {
    "raw_code": "def test_validate_format_numeric\n    Topic.validates_format_of(:title, :content, with: /\\A[1-9][0-9]*\\z/, message: \"is bad data\")\n\n    t = Topic.new(\"title\" => \"72x\", \"content\" => \"6789\")\n    assert_predicate t, :invalid?, \"Shouldn't be valid\"\n\n    assert_equal [\"is bad data\"], t.errors[:title]\n    assert_empty t.errors[:content]\n\n    t.title = \"-11\"\n    assert_predicate t, :invalid?, \"Shouldn't be valid\"\n\n    t.title = \"03\"\n    assert_predicate t, :invalid?, \"Shouldn't be valid\"\n\n    t.title = \"z44\"\n    assert_predicate t, :invalid?, \"Shouldn't be valid\"\n\n    t.title = \"5v7\"\n    assert_predicate t, :invalid?, \"Shouldn't be valid\"\n\n    t.title = \"1\"\n\n    assert_predicate t, :valid?\n    assert_empty t.errors[:title]\n  end",
    "comment": "testing ticket #3142",
    "label": "",
    "id": "1300"
  },
  {
    "raw_code": "def test_generate_message_inclusion_with_default_message\n    assert_equal \"is not included in the list\", @person.errors.generate_message(:title, :inclusion, value: \"title\")\n  end",
    "comment": "validates_inclusion_of: generate_message(attr_name, :inclusion, message: custom_message, value: value)",
    "label": "",
    "id": "1301"
  },
  {
    "raw_code": "def test_generate_message_exclusion_with_default_message\n    assert_equal \"is reserved\", @person.errors.generate_message(:title, :exclusion, value: \"title\")\n  end",
    "comment": "validates_exclusion_of: generate_message(attr_name, :exclusion, message: custom_message, value: value)",
    "label": "",
    "id": "1302"
  },
  {
    "raw_code": "def test_generate_message_invalid_with_default_message\n    assert_equal \"is invalid\", @person.errors.generate_message(:title, :invalid, value: \"title\")\n  end",
    "comment": "validates_format_of:  generate_message(attr_name, :invalid, message: custom_message, value: value)",
    "label": "",
    "id": "1303"
  },
  {
    "raw_code": "def test_generate_message_confirmation_with_default_message\n    assert_equal \"doesn't match Title\", @person.errors.generate_message(:title, :confirmation)\n  end",
    "comment": "validates_confirmation_of: generate_message(attr_name, :confirmation, message: custom_message)",
    "label": "",
    "id": "1304"
  },
  {
    "raw_code": "def test_generate_message_accepted_with_default_message\n    assert_equal \"must be accepted\", @person.errors.generate_message(:title, :accepted)\n  end",
    "comment": "validates_acceptance_of: generate_message(attr_name, :accepted, message: custom_message)",
    "label": "",
    "id": "1305"
  },
  {
    "raw_code": "def test_generate_message_empty_with_default_message\n    assert_equal \"can't be empty\", @person.errors.generate_message(:title, :empty)\n  end",
    "comment": "add_on_empty: generate_message(attr, :empty, message: custom_message)",
    "label": "",
    "id": "1306"
  },
  {
    "raw_code": "def test_generate_message_blank_with_default_message\n    assert_equal \"can't be blank\", @person.errors.generate_message(:title, :blank)\n  end",
    "comment": "validates_presence_of: generate_message(attr, :blank, message: custom_message)",
    "label": "",
    "id": "1307"
  },
  {
    "raw_code": "def test_generate_message_too_long_with_default_message_plural\n    assert_equal \"is too long (maximum is 10 characters)\", @person.errors.generate_message(:title, :too_long, count: 10)\n  end",
    "comment": "validates_length_of: generate_message(attr, :too_long, message: custom_message, count: option_value.end)",
    "label": "",
    "id": "1308"
  },
  {
    "raw_code": "def test_generate_message_too_short_with_default_message_plural\n    assert_equal \"is too short (minimum is 10 characters)\", @person.errors.generate_message(:title, :too_short, count: 10)\n  end",
    "comment": "validates_length_of: generate_message(attr, :too_short, default: custom_message, count: option_value.begin)",
    "label": "",
    "id": "1309"
  },
  {
    "raw_code": "def test_generate_message_wrong_length_with_default_message_plural\n    assert_equal \"is the wrong length (should be 10 characters)\", @person.errors.generate_message(:title, :wrong_length, count: 10)\n  end",
    "comment": "validates_length_of: generate_message(attr, :wrong_length, message: custom_message, count: option_value)",
    "label": "",
    "id": "1310"
  },
  {
    "raw_code": "def test_generate_message_not_a_number_with_default_message\n    assert_equal \"is not a number\", @person.errors.generate_message(:title, :not_a_number, value: \"title\")\n  end",
    "comment": "validates_numericality_of: generate_message(attr_name, :not_a_number, value: raw_value, message: custom_message)",
    "label": "",
    "id": "1311"
  },
  {
    "raw_code": "def test_generate_message_greater_than_with_default_message\n    assert_equal \"must be greater than 10\", @person.errors.generate_message(:title, :greater_than, value: \"title\", count: 10)\n  end",
    "comment": "validates_numericality_of: generate_message(attr_name, option, value: raw_value, default: custom_message)",
    "label": "",
    "id": "1312"
  },
  {
    "raw_code": "def self.set_expectations_for_validation(validation, error_type, &block_that_sets_validation)\n    if error_type == :confirmation\n      attribute = :title_confirmation\n    else\n      attribute = :title\n    end",
    "comment": "To make things DRY this macro is created to define 3 tests for every validation case.",
    "label": "",
    "id": "1313"
  },
  {
    "raw_code": "def self.schema_cache_ignored_table?(table_name)\n    ActiveRecord.schema_cache_ignored_tables.any? do |ignored|\n      ignored === table_name\n    end",
    "comment": "Checks to see if the +table_name+ is ignored by checking against the +schema_cache_ignored_tables+ option.  ActiveRecord.schema_cache_ignored_table?(:developers) ",
    "label": "",
    "id": "1314"
  },
  {
    "raw_code": "def self.default_timezone=(default_timezone)\n    unless %i(local utc).include?(default_timezone)\n      raise ArgumentError, \"default_timezone must be either :utc (default) or :local.\"\n    end",
    "comment": "Determines whether to use Time.utc (using :utc) or Time.local (using :local) when pulling dates and times from the database. This is set to :utc by default.",
    "label": "",
    "id": "1315"
  },
  {
    "raw_code": "def self.global_executor_concurrency=(global_executor_concurrency)\n    if self.async_query_executor.nil? || self.async_query_executor == :multi_thread_pool\n      raise ArgumentError, \"`global_executor_concurrency` cannot be set when the executor is nil or set to `:multi_thread_pool`. For multiple thread pools, please set the concurrency in your database configuration.\"\n    end",
    "comment": "Set the +global_executor_concurrency+. This configuration value can only be used with the global thread pool async query executor.",
    "label": "",
    "id": "1316"
  },
  {
    "raw_code": "def self.permanent_connection_checkout=(value)\n    unless [true, :deprecated, :disallowed].include?(value)\n      raise ArgumentError, \"permanent_connection_checkout must be one of: `true`, `:deprecated` or `:disallowed`\"\n    end",
    "comment": "Defines whether +ActiveRecord::Base.connection+ is allowed, deprecated, or entirely disallowed.",
    "label": "",
    "id": "1317"
  },
  {
    "raw_code": "def self.disconnect_all!\n    ConnectionAdapters::PoolConfig.disconnect_all!\n  end",
    "comment": "Explicitly closes all database connections in all pools.",
    "label": "",
    "id": "1318"
  },
  {
    "raw_code": "def self.after_all_transactions_commit(&block)\n    open_transactions = all_open_transactions\n\n    if open_transactions.empty?\n      yield\n    elsif open_transactions.size == 1\n      open_transactions.first.after_commit(&block)\n    else\n      count = open_transactions.size\n      callback = -> do\n        count -= 1\n        block.call if count.zero?\n      end",
    "comment": "Registers a block to be called after all the current transactions have been committed.  If there is no currently open transaction, the block is called immediately.  If there are multiple nested transactions, the block is called after the outermost one has been committed,  If any of the currently open transactions is rolled back, the block is never called.  If multiple transactions are open across multiple databases, the block will be invoked if and once all of them have been committed. But note that nesting transactions across two distinct databases is a sharding anti-pattern that comes with a world of hurts.",
    "label": "",
    "id": "1319"
  },
  {
    "raw_code": "def self.with_transaction_isolation_level(isolation_level, &block)\n    original_level = self.default_transaction_isolation_level\n    self.default_transaction_isolation_level = isolation_level\n    yield\n  ensure\n    self.default_transaction_isolation_level = original_level\n  end",
    "comment": "Sets a transaction isolation level for all connection pools within the block.",
    "label": "",
    "id": "1320"
  },
  {
    "raw_code": "def self.sql(sql_string, *positional_binds, retryable: false, **named_binds)\n    if Arel::Nodes::SqlLiteral === sql_string\n      sql_string\n    elsif positional_binds.empty? && named_binds.empty?\n      Arel::Nodes::SqlLiteral.new(sql_string, retryable: retryable)\n    else\n      Arel::Nodes::BoundSqlLiteral.new sql_string, positional_binds, named_binds\n    end",
    "comment": "Wrap a known-safe SQL string for passing to query methods, e.g.  Post.order(Arel.sql(\"REPLACE(title, 'misc', 'zzzz') asc\")).pluck(:id)  Great caution should be taken to avoid SQL injection vulnerabilities. This method should not be used with unsafe values such as request parameters or model attributes.  Take a look at the {security guide}[https://guides.rubyonrails.org/security.html#sql-injection] for more information.  To construct a more complex query fragment, including the possible use of user-provided values, the +sql_string+ may contain <tt>?</tt> and +:key+ placeholders, corresponding to the additional arguments. Note that this behavior only applies when bind value parameters are supplied in the call; without them, the placeholder tokens have no special meaning, and will be passed through to the query as-is.  The +:retryable+ option can be used to mark the SQL as safe to retry. Use this option only if the SQL is idempotent, as it could be executed more than once.",
    "label": "",
    "id": "1321"
  },
  {
    "raw_code": "def composed_of(part_id, options = {})\n          options.assert_valid_keys(:class_name, :mapping, :allow_nil, :constructor, :converter)\n\n          unless self < Aggregations\n            include Aggregations\n          end",
    "comment": "Adds reader and writer methods for manipulating a value object: <tt>composed_of :address</tt> adds <tt>address</tt> and <tt>address=(new_address)</tt> methods.  Options are: * <tt>:class_name</tt> - Specifies the class name of the association. Use it only if that name can't be inferred from the part id. So <tt>composed_of :address</tt> will by default be linked to the Address class, but if the real class name is +CompanyAddress+, you'll have to specify it with this option. * <tt>:mapping</tt> - Specifies the mapping of entity attributes to attributes of the value object. Each mapping is represented as a key-value pair where the key is the name of the entity attribute and the value is the name of the attribute in the value object. The order in which mappings are defined determines the order in which attributes are sent to the value class constructor. The mapping can be written as a hash or as an array of pairs. * <tt>:allow_nil</tt> - Specifies that the value object will not be instantiated when all mapped attributes are +nil+. Setting the value object to +nil+ has the effect of writing +nil+ to all mapped attributes. This defaults to +false+. * <tt>:constructor</tt> - A symbol specifying the name of the constructor method or a Proc that is called to initialize the value object. The constructor is passed all of the mapped attributes, in the order that they are defined in the <tt>:mapping option</tt>, as arguments and uses them to instantiate a <tt>:class_name</tt> object. The default is <tt>:new</tt>. * <tt>:converter</tt> - A symbol specifying the name of a class method of <tt>:class_name</tt> or a Proc that is called when a new value is assigned to the value object. The converter is passed the single value that is used in the assignment and is only called if the new value is not an instance of <tt>:class_name</tt>. If <tt>:allow_nil</tt> is set to true, the converter can return +nil+ to skip the assignment.  Option examples: composed_of :temperature, mapping: { reading: :celsius } composed_of :balance, class_name: \"Money\", mapping: { balance: :amount } composed_of :address, mapping: { address_street: :street, address_city: :city } composed_of :address, mapping: [ %w(address_street street), %w(address_city city) ] composed_of :gps_location composed_of :gps_location, allow_nil: true composed_of :ip_address, class_name: 'IPAddr', mapping: { ip: :to_i }, constructor: Proc.new { |ip| IPAddr.new(ip, Socket::AF_INET) }, converter: Proc.new { |ip| ip.is_a?(Integer) ? IPAddr.new(ip, Socket::AF_INET) : IPAddr.new(ip.to_s) } ",
    "label": "",
    "id": "1322"
  },
  {
    "raw_code": "def association(name) # :nodoc:\n      association = association_instance_get(name)\n\n      if association.nil?\n        unless reflection = self.class._reflect_on_association(name)\n          raise AssociationNotFoundError.new(self, name)\n        end",
    "comment": "Returns the association instance for the given name, instantiating it if it doesn't already exist",
    "label": "",
    "id": "1323"
  },
  {
    "raw_code": "def association_instance_get(name)\n        (@association_cache ||= {})[name]\n      end",
    "comment": "Returns the specified association instance if it exists, +nil+ otherwise.",
    "label": "",
    "id": "1324"
  },
  {
    "raw_code": "def association_instance_set(name, association)\n        @association_cache[name] = association\n      end",
    "comment": "Set the specified association instance.",
    "label": "",
    "id": "1325"
  },
  {
    "raw_code": "def has_many(name, scope = nil, **options, &extension)\n          reflection = Builder::HasMany.build(self, name, scope, options, &extension)\n          Reflection.add_reflection(self, name, reflection)\n        end",
    "comment": "Specifies a one-to-many association. The following methods for retrieval and query of collections of associated objects will be added:  +collection+ is a placeholder for the symbol passed as the +name+ argument, so <tt>has_many :clients</tt> would add among others <tt>clients.empty?</tt>.  [<tt>collection</tt>] Returns a Relation of all the associated objects. An empty Relation is returned if none are found. [<tt>collection<<(object, ...)</tt>] Adds one or more objects to the collection by setting their foreign keys to the collection's primary key. Note that this operation instantly fires update SQL without waiting for the save or update call on the parent object, unless the parent object is a new record. This will also run validations and callbacks of associated object(s). [<tt>collection.delete(object, ...)</tt>] Removes one or more objects from the collection by setting their foreign keys to +NULL+. Objects will be in addition destroyed if they're associated with <tt>dependent: :destroy</tt>, and deleted if they're associated with <tt>dependent: :delete_all</tt>.  If the <tt>:through</tt> option is used, then the join records are deleted (rather than nullified) by default, but you can specify <tt>dependent: :destroy</tt> or <tt>dependent: :nullify</tt> to override this. [<tt>collection.destroy(object, ...)</tt>] Removes one or more objects from the collection by running <tt>destroy</tt> on each record, regardless of any dependent option, ensuring callbacks are run.  If the <tt>:through</tt> option is used, then the join records are destroyed instead, not the objects themselves. [<tt>collection=objects</tt>] Replaces the collections content by deleting and adding objects as appropriate. If the <tt>:through</tt> option is true callbacks in the join models are triggered except destroy callbacks, since deletion is direct by default. You can specify <tt>dependent: :destroy</tt> or <tt>dependent: :nullify</tt> to override this. [<tt>collection_singular_ids</tt>] Returns an array of the associated objects' ids [<tt>collection_singular_ids=ids</tt>] Replace the collection with the objects identified by the primary keys in +ids+. This method loads the models and calls <tt>collection=</tt>. See above. [<tt>collection.clear</tt>] Removes every object from the collection. This destroys the associated objects if they are associated with <tt>dependent: :destroy</tt>, deletes them directly from the database if <tt>dependent: :delete_all</tt>, otherwise sets their foreign keys to +NULL+. If the <tt>:through</tt> option is true no destroy callbacks are invoked on the join models. Join models are directly deleted. [<tt>collection.empty?</tt>] Returns +true+ if there are no associated objects. [<tt>collection.size</tt>] Returns the number of associated objects. [<tt>collection.find(...)</tt>] Finds an associated object according to the same rules as ActiveRecord::FinderMethods#find. [<tt>collection.exists?(...)</tt>] Checks whether an associated object with the given conditions exists. Uses the same rules as ActiveRecord::FinderMethods#exists?. [<tt>collection.build(attributes = {}, ...)</tt>] Returns one or more new objects of the collection type that have been instantiated with +attributes+ and linked to this object through a foreign key, but have not yet been saved. [<tt>collection.create(attributes = {})</tt>] Returns a new object of the collection type that has been instantiated with +attributes+, linked to this object through a foreign key, and that has already been saved (if it passed the validation). *Note*: This only works if the base model already exists in the DB, not if it is a new (unsaved) record! [<tt>collection.create!(attributes = {})</tt>] Does the same as <tt>collection.create</tt>, but raises ActiveRecord::RecordInvalid if the record is invalid. [<tt>collection.reload</tt>] Returns a Relation of all of the associated objects, forcing a database read. An empty Relation is returned if none are found.  ==== Example  class Firm < ActiveRecord::Base has_many :clients end  Declaring <tt>has_many :clients</tt> adds the following methods (and more):  firm = Firm.find(2) client = Client.find(6)  firm.clients                       # similar to Client.where(firm_id: 2) firm.clients << client firm.clients.delete(client) firm.clients.destroy(client) firm.clients = [client] firm.client_ids firm.client_ids = [6] firm.clients.clear firm.clients.empty?                # similar to firm.clients.size == 0 firm.clients.size                  # similar to Client.count \"firm_id = 2\" firm.clients.find                  # similar to Client.where(firm_id: 2).find(6) firm.clients.exists?(name: 'ACME') # similar to Client.exists?(name: 'ACME', firm_id: 2) firm.clients.build                 # similar to Client.new(firm_id: 2) firm.clients.create                # similar to Client.create(firm_id: 2) firm.clients.create!               # similar to Client.create!(firm_id: 2) firm.clients.reload  The declaration can also include an +options+ hash to specialize the behavior of the association.  ==== Scopes  You can pass a second argument +scope+ as a callable (i.e. proc or lambda) to retrieve a specific set of records or customize the generated query when you access the associated collection.  Scope examples: has_many :comments, -> { where(author_id: 1) } has_many :employees, -> { joins(:address) } has_many :posts, ->(blog) { where(\"max_post_length > ?\", blog.max_post_length) }  ==== Extensions  The +extension+ argument allows you to pass a block into a has_many association. This is useful for adding new finders, creators, and other factory-type methods to be used as part of the association.  Extension examples: has_many :employees do def find_or_create_by_name(name) first_name, last_name = name.split(\" \", 2) find_or_create_by(first_name: first_name, last_name: last_name) end end  ==== Options [+:class_name+] Specify the class name of the association. Use it only if that name can't be inferred from the association name. So <tt>has_many :products</tt> will by default be linked to the +Product+ class, but if the real class name is +SpecialProduct+, you'll have to specify it with this option. [+:foreign_key+] Specify the foreign key used for the association. By default this is guessed to be the name of this class in lower-case and \"_id\" suffixed. So a Person class that makes a #has_many association will use \"person_id\" as the default <tt>:foreign_key</tt>.  Setting the <tt>:foreign_key</tt> option prevents automatic detection of the association's inverse, so it is generally a good idea to set the <tt>:inverse_of</tt> option as well. [+:foreign_type+] Specify the column used to store the associated object's type, if this is a polymorphic association. By default this is guessed to be the name of the polymorphic association specified on \"as\" option with a \"_type\" suffix. So a class that defines a <tt>has_many :tags, as: :taggable</tt> association will use \"taggable_type\" as the default <tt>:foreign_type</tt>. [+:primary_key+] Specify the name of the column to use as the primary key for the association. By default this is +id+. [+:dependent+] Controls what happens to the associated objects when their owner is destroyed. Note that these are implemented as callbacks, and \\Rails executes callbacks in order. Therefore, other similar callbacks may affect the <tt>:dependent</tt> behavior, and the <tt>:dependent</tt> behavior may affect other callbacks.  * <tt>nil</tt> do nothing (default). * <tt>:destroy</tt> causes all the associated objects to also be destroyed. * <tt>:destroy_async</tt> destroys all the associated objects in a background job. <b>WARNING:</b> Do not use this option if the association is backed by foreign key constraints in your database. The foreign key constraint actions will occur inside the same transaction that deletes its owner. * <tt>:delete_all</tt> causes all the associated objects to be deleted directly from the database (so callbacks will not be executed). * <tt>:nullify</tt> causes the foreign keys to be set to +NULL+. Polymorphic type will also be nullified on polymorphic associations. Callbacks are not executed. * <tt>:restrict_with_exception</tt> causes an ActiveRecord::DeleteRestrictionError exception to be raised if there are any associated records. * <tt>:restrict_with_error</tt> causes an error to be added to the owner if there are any associated objects.  If using with the <tt>:through</tt> option, the association on the join model must be a #belongs_to, and the records which get deleted are the join records, rather than the associated records.  If using <tt>dependent: :destroy</tt> on a scoped association, only the scoped objects are destroyed. For example, if a Post model defines <tt>has_many :comments, -> { where published: true }, dependent: :destroy</tt> and <tt>destroy</tt> is called on a post, only published comments are destroyed. This means that any unpublished comments in the database would still contain a foreign key pointing to the now deleted post. [+:counter_cache+] This option can be used to configure a custom named <tt>:counter_cache.</tt> You only need this option, when you customized the name of your <tt>:counter_cache</tt> on the #belongs_to association. [+:as+] Specifies a polymorphic interface (See #belongs_to). [+:through+] Specifies an association through which to perform the query.  This can be any other type of association, including other <tt>:through</tt> associations, but it cannot be a polymorphic association. Options for <tt>:class_name</tt>, <tt>:primary_key</tt> and <tt>:foreign_key</tt> are ignored, as the association uses the source reflection.  If the association on the join model is a #belongs_to, the collection can be modified and the records on the <tt>:through</tt> model will be automatically created and removed as appropriate. Otherwise, the collection is read-only, so you should manipulate the <tt>:through</tt> association directly.  If you are going to modify the association (rather than just read from it), then it is a good idea to set the <tt>:inverse_of</tt> option on the source association on the join model. This allows associated records to be built which will automatically create the appropriate join model records when they are saved. See {Association Join Models}[rdoc-ref:Associations::ClassMethods@Association+Join+Models] and {Setting Inverses}[rdoc-ref:Associations::ClassMethods@Setting+Inverses] for more detail.  [+:disable_joins+] Specifies whether joins should be skipped for an association. If set to true, two or more queries will be generated. Note that in some cases, if order or limit is applied, it will be done in-memory due to database limitations. This option is only applicable on <tt>has_many :through</tt> associations as +has_many+ alone do not perform a join. [+:source+] Specifies the source association name used by #has_many <tt>:through</tt> queries. Only use it if the name cannot be inferred from the association. <tt>has_many :subscribers, through: :subscriptions</tt> will look for either <tt>:subscribers</tt> or <tt>:subscriber</tt> on Subscription, unless a <tt>:source</tt> is given. [+:source_type+] Specifies type of the source association used by #has_many <tt>:through</tt> queries where the source association is a polymorphic #belongs_to. [+:validate+] When set to +true+, validates new objects added to association when saving the parent object. +true+ by default. If you want to ensure associated objects are revalidated on every update, use +validates_associated+. [+:autosave+] If true, always save the associated objects or destroy them if marked for destruction, when saving the parent object. If false, never save or destroy the associated objects. By default, only save associated objects that are new records. This option is implemented as a +before_save+ callback. Because callbacks are run in the order they are defined, associated objects may need to be explicitly saved in any user-defined +before_save+ callbacks.  Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets <tt>:autosave</tt> to <tt>true</tt>. [+:inverse_of+] Specifies the name of the #belongs_to association on the associated object that is the inverse of this #has_many association. See {Bi-directional associations}[rdoc-ref:Associations::ClassMethods@Bi-directional+associations] for more detail. [+:extend+] Specifies a module or array of modules that will be extended into the association object returned. Useful for defining methods on associations, especially when they should be shared between multiple association objects. [+:strict_loading+] When set to +true+, enforces strict loading every time the associated record is loaded through this association. [+:ensuring_owner_was+] Specifies an instance method to be called on the owner. The method must return true in order for the associated records to be deleted in a background job. [+:query_constraints+] Serves as a composite foreign key. Defines the list of columns to be used to query the associated object. This is an optional option. By default Rails will attempt to derive the value automatically. When the value is set the Array size must match associated model's primary key or +query_constraints+ size. [+:index_errors+] Allows differentiation of multiple validation errors from the association records, by including an index in the error attribute name, e.g. +roles[2].level+. When set to +true+, the index is based on association order, i.e. database order, with yet to be persisted new records placed at the end. When set to +:nested_attributes_order+, the index is based on the record order received by nested attributes setter, when accepts_nested_attributes_for is used. [:before_add] Defines an {association callback}[rdoc-ref:Associations::ClassMethods@Association+callbacks] that gets triggered <b>before an object is added</b> to the association collection. [:after_add] Defines an {association callback}[rdoc-ref:Associations::ClassMethods@Association+callbacks] that gets triggered <b>after an object is added</b> to the association collection. [:before_remove] Defines an {association callback}[rdoc-ref:Associations::ClassMethods@Association+callbacks] that gets triggered <b>before an object is removed</b> from the association collection. [:after_remove] Defines an {association callback}[rdoc-ref:Associations::ClassMethods@Association+callbacks] that gets triggered <b>after an object is removed</b> from the association collection. [+:deprecated+] If true, marks the association as deprecated. Usage of deprecated associations is reported. Please, check the class documentation above for details.  Option examples: has_many :comments, -> { order(\"posted_on\") } has_many :comments, -> { includes(:author) } has_many :people, -> { where(deleted: false).order(\"name\") }, class_name: \"Person\" has_many :tracks, -> { order(\"position\") }, dependent: :destroy has_many :comments, dependent: :nullify has_many :tags, as: :taggable has_many :reports, -> { readonly } has_many :subscribers, through: :subscriptions, source: :user has_many :subscribers, through: :subscriptions, disable_joins: true has_many :comments, strict_loading: true has_many :comments, query_constraints: [:blog_id, :post_id] has_many :comments, index_errors: :nested_attributes_order",
    "label": "",
    "id": "1326"
  },
  {
    "raw_code": "def has_one(name, scope = nil, **options)\n          reflection = Builder::HasOne.build(self, name, scope, options)\n          Reflection.add_reflection(self, name, reflection)\n        end",
    "comment": "Specifies a one-to-one association with another class. This method should only be used if the other class contains the foreign key. If the current class contains the foreign key, then you should use #belongs_to instead. See {Is it a belongs_to or has_one association?}[rdoc-ref:Associations::ClassMethods@Is+it+a+-23belongs_to+or+-23has_one+association-3F] for more detail on when to use #has_one and when to use #belongs_to.  The following methods for retrieval and query of a single associated object will be added:  +association+ is a placeholder for the symbol passed as the +name+ argument, so <tt>has_one :manager</tt> would add among others <tt>manager.nil?</tt>.  [<tt>association</tt>] Returns the associated object. +nil+ is returned if none is found. [<tt>association=(associate)</tt>] Assigns the associate object, extracts the primary key, sets it as the foreign key, and saves the associate object. To avoid database inconsistencies, permanently deletes an existing associated object when assigning a new one, even if the new one isn't saved to database. [<tt>build_association(attributes = {})</tt>] Returns a new object of the associated type that has been instantiated with +attributes+ and linked to this object through a foreign key, but has not yet been saved. [<tt>create_association(attributes = {})</tt>] Returns a new object of the associated type that has been instantiated with +attributes+, linked to this object through a foreign key, and that has already been saved (if it passed the validation). [<tt>create_association!(attributes = {})</tt>] Does the same as <tt>create_association</tt>, but raises ActiveRecord::RecordInvalid if the record is invalid. [<tt>reload_association</tt>] Returns the associated object, forcing a database read. [<tt>reset_association</tt>] Unloads the associated object. The next access will query it from the database.  ==== Example  class Account < ActiveRecord::Base has_one :beneficiary end  Declaring <tt>has_one :beneficiary</tt> adds the following methods (and more):  account = Account.find(5) beneficiary = Beneficiary.find(8)  account.beneficiary               # similar to Beneficiary.find_by(account_id: 5) account.beneficiary = beneficiary # similar to beneficiary.update(account_id: 5) account.build_beneficiary         # similar to Beneficiary.new(account_id: 5) account.create_beneficiary        # similar to Beneficiary.create(account_id: 5) account.create_beneficiary!       # similar to Beneficiary.create!(account_id: 5) account.reload_beneficiary account.reset_beneficiary  ==== Scopes  You can pass a second argument +scope+ as a callable (i.e. proc or lambda) to retrieve a specific record or customize the generated query when you access the associated object.  Scope examples: has_one :author, -> { where(comment_id: 1) } has_one :employer, -> { joins(:company) } has_one :latest_post, ->(blog) { where(\"created_at > ?\", blog.enabled_at) }  ==== Options  The declaration can also include an +options+ hash to specialize the behavior of the association.  Options are: [+:class_name+] Specify the class name of the association. Use it only if that name can't be inferred from the association name. So <tt>has_one :manager</tt> will by default be linked to the Manager class, but if the real class name is Person, you'll have to specify it with this option. [+:dependent+] Controls what happens to the associated object when its owner is destroyed:  * <tt>nil</tt> do nothing (default). * <tt>:destroy</tt> causes the associated object to also be destroyed * <tt>:destroy_async</tt> causes the associated object to be destroyed in a background job. <b>WARNING:</b> Do not use this option if the association is backed by foreign key constraints in your database. The foreign key constraint actions will occur inside the same transaction that deletes its owner. * <tt>:delete</tt> causes the associated object to be deleted directly from the database (so callbacks will not execute) * <tt>:nullify</tt> causes the foreign key to be set to +NULL+. Polymorphic type column is also nullified on polymorphic associations. Callbacks are not executed. * <tt>:restrict_with_exception</tt> causes an ActiveRecord::DeleteRestrictionError exception to be raised if there is an associated record * <tt>:restrict_with_error</tt> causes an error to be added to the owner if there is an associated object  Note that <tt>:dependent</tt> option is ignored when using <tt>:through</tt> option. [+:foreign_key+] Specify the foreign key used for the association. By default this is guessed to be the name of this class in lower-case and \"_id\" suffixed. So a Person class that makes a #has_one association will use \"person_id\" as the default <tt>:foreign_key</tt>.  Setting the <tt>:foreign_key</tt> option prevents automatic detection of the association's inverse, so it is generally a good idea to set the <tt>:inverse_of</tt> option as well. [+:foreign_type+] Specify the column used to store the associated object's type, if this is a polymorphic association. By default this is guessed to be the name of the polymorphic association specified on \"as\" option with a \"_type\" suffix. So a class that defines a <tt>has_one :tag, as: :taggable</tt> association will use \"taggable_type\" as the default <tt>:foreign_type</tt>. [+:primary_key+] Specify the method that returns the primary key used for the association. By default this is +id+. [+:as+] Specifies a polymorphic interface (See #belongs_to). [+:through+] Specifies an association through which to perform the query.  The through association must be a +has_one+, <tt>has_one :through</tt>, or non-polymorphic +belongs_to+. That is, a non-polymorphic singular association. Options for <tt>:class_name</tt>, <tt>:primary_key</tt>, and <tt>:foreign_key</tt> are ignored, as the association uses the source reflection. You can only use a <tt>:through</tt> query through a #has_one or #belongs_to association on the join model.  If the association on the join model is a #belongs_to, the collection can be modified and the records on the <tt>:through</tt> model will be automatically created and removed as appropriate. Otherwise, the collection is read-only, so you should manipulate the <tt>:through</tt> association directly.  If you are going to modify the association (rather than just read from it), then it is a good idea to set the <tt>:inverse_of</tt> option on the source association on the join model. This allows associated records to be built which will automatically create the appropriate join model records when they are saved. See {Association Join Models}[rdoc-ref:Associations::ClassMethods@Association+Join+Models] and {Setting Inverses}[rdoc-ref:Associations::ClassMethods@Setting+Inverses] for more detail. [+:disable_joins+] Specifies whether joins should be skipped for an association. If set to true, two or more queries will be generated. Note that in some cases, if order or limit is applied, it will be done in-memory due to database limitations. This option is only applicable on <tt>has_one :through</tt> associations as +has_one+ alone does not perform a join. [+:source+] Specifies the source association name used by #has_one <tt>:through</tt> queries. Only use it if the name cannot be inferred from the association. <tt>has_one :favorite, through: :favorites</tt> will look for a <tt>:favorite</tt> on Favorite, unless a <tt>:source</tt> is given. [+:source_type+] Specifies type of the source association used by #has_one <tt>:through</tt> queries where the source association is a polymorphic #belongs_to. [+:validate+] When set to +true+, validates new objects added to association when saving the parent object. +false+ by default. If you want to ensure associated objects are revalidated on every update, use +validates_associated+. [+:autosave+] If +true+, always saves the associated object or destroys it if marked for destruction, when saving the parent object. If +false+, never save or destroy the associated object.  By default, only saves the associated object if it's a new record. Setting this option to +true+ also enables validations on the associated object unless explicitly disabled with <tt>validate: false</tt>. This is because saving an object with invalid associated objects would fail, so any associated objects will go through validation checks.  Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets <tt>:autosave</tt> to <tt>true</tt>. [+:touch+] If true, the associated object will be touched (the +updated_at+ / +updated_on+ attributes set to current time) when this record is either saved or destroyed. If you specify a symbol, that attribute will be updated with the current time in addition to the +updated_at+ / +updated_on+ attribute. Please note that no validation will be performed when touching, and only the +after_touch+, +after_commit+, and +after_rollback+ callbacks will be executed. [+:inverse_of+] Specifies the name of the #belongs_to association on the associated object that is the inverse of this #has_one association. See {Bi-directional associations}[rdoc-ref:Associations::ClassMethods@Bi-directional+associations] for more detail. [+:required+] When set to +true+, the association will also have its presence validated. This will validate the association itself, not the id. You can use +:inverse_of+ to avoid an extra query during validation. [+:strict_loading+] Enforces strict loading every time the associated record is loaded through this association. [+:ensuring_owner_was+] Specifies an instance method to be called on the owner. The method must return true in order for the associated records to be deleted in a background job. [+:query_constraints+] Serves as a composite foreign key. Defines the list of columns to be used to query the associated object. This is an optional option. By default Rails will attempt to derive the value automatically. When the value is set the Array size must match associated model's primary key or +query_constraints+ size. [+:deprecated+] If true, marks the association as deprecated. Usage of deprecated associations is reported. Please, check the class documentation above for details.  Option examples: has_one :credit_card, dependent: :destroy  # destroys the associated credit card has_one :credit_card, dependent: :nullify  # updates the associated records foreign # key value to NULL rather than destroying it has_one :last_comment, -> { order('posted_on desc') }, class_name: \"Comment\" has_one :project_manager, -> { where(role: 'project_manager') }, class_name: \"Person\" has_one :attachment, as: :attachable has_one :boss, -> { readonly } has_one :club, through: :membership has_one :club, through: :membership, disable_joins: true has_one :primary_address, -> { where(primary: true) }, through: :addressables, source: :addressable has_one :credit_card, required: true has_one :credit_card, strict_loading: true has_one :employment_record_book, query_constraints: [:organization_id, :employee_id]",
    "label": "",
    "id": "1327"
  },
  {
    "raw_code": "def belongs_to(name, scope = nil, **options)\n          reflection = Builder::BelongsTo.build(self, name, scope, options)\n          Reflection.add_reflection(self, name, reflection)\n        end",
    "comment": "Specifies a one-to-one association with another class. This method should only be used if this class contains the foreign key. If the other class contains the foreign key, then you should use #has_one instead. See {Is it a belongs_to or has_one association?}[rdoc-ref:Associations::ClassMethods@Is+it+a+-23belongs_to+or+-23has_one+association-3F] for more detail on when to use #has_one and when to use #belongs_to.  Methods will be added for retrieval and query for a single associated object, for which this object holds an id:  +association+ is a placeholder for the symbol passed as the +name+ argument, so <tt>belongs_to :author</tt> would add among others <tt>author.nil?</tt>.  [<tt>association</tt>] Returns the associated object. +nil+ is returned if none is found. [<tt>association=(associate)</tt>] Assigns the associate object, extracts the primary key, and sets it as the foreign key. No modification or deletion of existing records takes place. [<tt>build_association(attributes = {})</tt>] Returns a new object of the associated type that has been instantiated with +attributes+ and linked to this object through a foreign key, but has not yet been saved. [<tt>create_association(attributes = {})</tt>] Returns a new object of the associated type that has been instantiated with +attributes+, linked to this object through a foreign key, and that has already been saved (if it passed the validation). [<tt>create_association!(attributes = {})</tt>] Does the same as <tt>create_association</tt>, but raises ActiveRecord::RecordInvalid if the record is invalid. [<tt>reload_association</tt>] Returns the associated object, forcing a database read. [<tt>reset_association</tt>] Unloads the associated object. The next access will query it from the database. [<tt>association_changed?</tt>] Returns true if a new associate object has been assigned and the next save will update the foreign key. [<tt>association_previously_changed?</tt>] Returns true if the previous save updated the association to reference a new associate object.  ==== Example  class Post < ActiveRecord::Base belongs_to :author end  Declaring <tt>belongs_to :author</tt> adds the following methods (and more):  post = Post.find(7) author = Author.find(19)  post.author           # similar to Author.find(post.author_id) post.author = author  # similar to post.author_id = author.id post.build_author     # similar to post.author = Author.new post.create_author    # similar to post.author = Author.new; post.author.save; post.author post.create_author!   # similar to post.author = Author.new; post.author.save!; post.author post.reload_author post.reset_author post.author_changed? post.author_previously_changed?  ==== Scopes  You can pass a second argument +scope+ as a callable (i.e. proc or lambda) to retrieve a specific record or customize the generated query when you access the associated object.  Scope examples: belongs_to :firm, -> { where(id: 2) } belongs_to :user, -> { joins(:friends) } belongs_to :level, ->(game) { where(\"game_level > ?\", game.current_level) }  ==== Options  The declaration can also include an +options+ hash to specialize the behavior of the association.  [+:class_name+] Specify the class name of the association. Use it only if that name can't be inferred from the association name. So <tt>belongs_to :author</tt> will by default be linked to the Author class, but if the real class name is Person, you'll have to specify it with this option. +:class_name+ is not supported in polymorphic associations, since in that case the class name of the associated record is stored in the type column. [+:foreign_key+] Specify the foreign key used for the association. By default this is guessed to be the name of the association with an \"_id\" suffix. So a class that defines a <tt>belongs_to :person</tt> association will use \"person_id\" as the default <tt>:foreign_key</tt>. Similarly, <tt>belongs_to :favorite_person, class_name: \"Person\"</tt> will use a foreign key of \"favorite_person_id\".  Setting the <tt>:foreign_key</tt> option prevents automatic detection of the association's inverse, so it is generally a good idea to set the <tt>:inverse_of</tt> option as well. [+:foreign_type+] Specify the column used to store the associated object's type, if this is a polymorphic association. By default this is guessed to be the name of the association with a \"_type\" suffix. So a class that defines a <tt>belongs_to :taggable, polymorphic: true</tt> association will use \"taggable_type\" as the default <tt>:foreign_type</tt>. [+:primary_key+] Specify the method that returns the primary key of associated object used for the association. By default this is +id+. [+:dependent+] If set to <tt>:destroy</tt>, the associated object is destroyed when this object is. If set to <tt>:delete</tt>, the associated object is deleted *without* calling its destroy method. If set to <tt>:destroy_async</tt>, the associated object is scheduled to be destroyed in a background job. This option should not be specified when #belongs_to is used in conjunction with a #has_many relationship on another class because of the potential to leave orphaned records behind. [+:counter_cache+] Caches the number of belonging objects on the associate class through the use of CounterCache::ClassMethods#increment_counter and CounterCache::ClassMethods#decrement_counter. The counter cache is incremented when an object of this class is created and decremented when it's destroyed. This requires that a column named <tt>#{table_name}_count</tt> (such as +comments_count+ for a belonging Comment class) is used on the associate class (such as a Post class) - that is the migration for <tt>#{table_name}_count</tt> is created on the associate class (such that <tt>Post.comments_count</tt> will return the count cached). You can also specify a custom counter cache column by providing a column name instead of a +true+/+false+ value to this option (e.g., <tt>counter_cache: :my_custom_counter</tt>.)  Starting to use counter caches on existing large tables can be troublesome, because the column values must be backfilled separately of the column addition (to not lock the table for too long) and before the use of +:counter_cache+ (otherwise methods like +size+/+any?+/etc, which use counter caches internally, can produce incorrect results). To safely backfill the values while keeping counter cache columns updated with the child records creation/removal and to avoid the mentioned methods use the possibly incorrect counter cache column values and always get the results from the database, use <tt>counter_cache: { active: false }</tt>. If you also need to specify a custom column name, use <tt>counter_cache: { active: false, column: :my_custom_counter }</tt>.  Note: If you've enabled the counter cache, then you may want to add the counter cache attribute to the +attr_readonly+ list in the associated classes (e.g. <tt>class Post; attr_readonly :comments_count; end</tt>). [+:polymorphic+] Specify this association is a polymorphic association by passing +true+. Note: Since polymorphic associations rely on storing class names in the database, make sure to update the class names in the <tt>*_type</tt> polymorphic type column of the corresponding rows. [+:validate+] When set to +true+, validates new objects added to association when saving the parent object. +false+ by default. If you want to ensure associated objects are revalidated on every update, use +validates_associated+. [+:autosave+] If true, always save the associated object or destroy it if marked for destruction, when saving the parent object. If false, never save or destroy the associated object. By default, only save the associated object if it's a new record.  Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets <tt>:autosave</tt> to <tt>true</tt>. [+:touch+] If true, the associated object will be touched (the +updated_at+ / +updated_on+ attributes set to current time) when this record is either saved or destroyed. If you specify a symbol, that attribute will be updated with the current time in addition to the +updated_at+ / +updated_on+ attribute. Please note that no validation will be performed when touching, and only the +after_touch+, +after_commit+, and +after_rollback+ callbacks will be executed. [+:inverse_of+] Specifies the name of the #has_one or #has_many association on the associated object that is the inverse of this #belongs_to association. See {Bi-directional associations}[rdoc-ref:Associations::ClassMethods@Bi-directional+associations] for more detail. [+:optional+] When set to +true+, the association will not have its presence validated. [+:required+] When set to +true+, the association will also have its presence validated. This will validate the association itself, not the id. You can use +:inverse_of+ to avoid an extra query during validation. NOTE: <tt>required</tt> is set to <tt>true</tt> by default and is deprecated. If you don't want to have association presence validated, use <tt>optional: true</tt>. [+:default+] Provide a callable (i.e. proc or lambda) to specify that the association should be initialized with a particular record before validation. Please note that callable won't be executed if the record exists. [+:strict_loading+] Enforces strict loading every time the associated record is loaded through this association. [+:ensuring_owner_was+] Specifies an instance method to be called on the owner. The method must return true in order for the associated records to be deleted in a background job. [+:query_constraints+] Serves as a composite foreign key. Defines the list of columns to be used to query the associated object. This is an optional option. By default Rails will attempt to derive the value automatically. When the value is set the Array size must match associated model's primary key or +query_constraints+ size. [+:deprecated+] If true, marks the association as deprecated. Usage of deprecated associations is reported. Please, check the class documentation above for details.  Option examples: belongs_to :firm, foreign_key: \"client_of\" belongs_to :person, primary_key: \"name\", foreign_key: \"person_name\" belongs_to :author, class_name: \"Person\", foreign_key: \"author_id\" belongs_to :valid_coupon, ->(o) { where \"discounts > ?\", o.payments_count }, class_name: \"Coupon\", foreign_key: \"coupon_id\" belongs_to :attachable, polymorphic: true belongs_to :project, -> { readonly } belongs_to :post, counter_cache: true belongs_to :comment, touch: true belongs_to :company, touch: :employees_last_updated_at belongs_to :user, optional: true belongs_to :account, default: -> { company.account } belongs_to :account, strict_loading: true belongs_to :note, query_constraints: [:organization_id, :note_id]",
    "label": "",
    "id": "1328"
  },
  {
    "raw_code": "def has_and_belongs_to_many(name, scope = nil, **options, &extension)\n          habtm_reflection = ActiveRecord::Reflection::HasAndBelongsToManyReflection.new(name, scope, options, self)\n\n          builder = Builder::HasAndBelongsToMany.new(name, self, options)\n\n          join_model = builder.through_model\n\n          const_set(join_model.name, join_model)\n          private_constant(join_model.name)\n\n          middle_reflection = builder.middle_reflection(join_model)\n\n          Builder::HasMany.define_callbacks(self, middle_reflection)\n          Reflection.add_reflection(self, middle_reflection.name, middle_reflection)\n          middle_reflection.parent_reflection = habtm_reflection\n\n          include Module.new {\n            class_eval <<-RUBY, __FILE__, __LINE__ + 1\n              def destroy_associations\n                association(:#{middle_reflection.name}).delete_all(:delete_all)\n                association(:#{name}).reset\n                super\n              end\n            RUBY\n          }\n\n          hm_options = {}\n          hm_options[:through] = middle_reflection.name\n          hm_options[:source] = join_model.right_reflection.name\n\n          [:before_add, :after_add, :before_remove, :after_remove, :autosave, :validate, :join_table, :class_name, :extend, :strict_loading, :deprecated].each do |k|\n            hm_options[k] = options[k] if options.key?(k)\n          end",
    "comment": "Specifies a many-to-many relationship with another class. This associates two classes via an intermediate join table. Unless the join table is explicitly specified as an option, it is guessed using the lexical order of the class names. So a join between Developer and Project will give the default join table name of \"developers_projects\" because \"D\" precedes \"P\" alphabetically. Note that this precedence is calculated using the <tt><</tt> operator for String. This means that if the strings are of different lengths, and the strings are equal when compared up to the shortest length, then the longer string is considered of higher lexical precedence than the shorter one. For example, one would expect the tables \"paper_boxes\" and \"papers\" to generate a join table name of \"papers_paper_boxes\" because of the length of the name \"paper_boxes\", but it in fact generates a join table name of \"paper_boxes_papers\". Be aware of this caveat, and use the custom <tt>:join_table</tt> option if you need to. If your tables share a common prefix, it will only appear once at the beginning. For example, the tables \"catalog_categories\" and \"catalog_products\" generate a join table name of \"catalog_categories_products\".  The join table should not have a primary key or a model associated with it. You must manually generate the join table with a migration such as this:  class CreateDevelopersProjectsJoinTable < ActiveRecord::Migration[8.1] def change create_join_table :developers, :projects end end  It's also a good idea to add indexes to each of those columns to speed up the joins process. However, in MySQL it is advised to add a compound index for both of the columns as MySQL only uses one index per table during the lookup.  Adds the following methods for retrieval and query:  +collection+ is a placeholder for the symbol passed as the +name+ argument, so <tt>has_and_belongs_to_many :categories</tt> would add among others <tt>categories.empty?</tt>.  [<tt>collection</tt>] Returns a Relation of all the associated objects. An empty Relation is returned if none are found. [<tt>collection<<(object, ...)</tt>] Adds one or more objects to the collection by creating associations in the join table (<tt>collection.push</tt> and <tt>collection.concat</tt> are aliases to this method). Note that this operation instantly fires update SQL without waiting for the save or update call on the parent object, unless the parent object is a new record. [<tt>collection.delete(object, ...)</tt>] Removes one or more objects from the collection by removing their associations from the join table. This does not destroy the objects. [<tt>collection.destroy(object, ...)</tt>] Removes one or more objects from the collection by running destroy on each association in the join table, overriding any dependent option. This does not destroy the objects. [<tt>collection=objects</tt>] Replaces the collection's content by deleting and adding objects as appropriate. [<tt>collection_singular_ids</tt>] Returns an array of the associated objects' ids. [<tt>collection_singular_ids=ids</tt>] Replace the collection by the objects identified by the primary keys in +ids+. [<tt>collection.clear</tt>] Removes every object from the collection. This does not destroy the objects. [<tt>collection.empty?</tt>] Returns +true+ if there are no associated objects. [<tt>collection.size</tt>] Returns the number of associated objects. [<tt>collection.find(id)</tt>] Finds an associated object responding to the +id+ and that meets the condition that it has to be associated with this object. Uses the same rules as ActiveRecord::FinderMethods#find. [<tt>collection.exists?(...)</tt>] Checks whether an associated object with the given conditions exists. Uses the same rules as ActiveRecord::FinderMethods#exists?. [<tt>collection.build(attributes = {})</tt>] Returns a new object of the collection type that has been instantiated with +attributes+ and linked to this object through the join table, but has not yet been saved. [<tt>collection.create(attributes = {})</tt>] Returns a new object of the collection type that has been instantiated with +attributes+, linked to this object through the join table, and that has already been saved (if it passed the validation). [<tt>collection.reload</tt>] Returns a Relation of all of the associated objects, forcing a database read. An empty Relation is returned if none are found.  ==== Example  class Developer < ActiveRecord::Base has_and_belongs_to_many :projects end  Declaring <tt>has_and_belongs_to_many :projects</tt> adds the following methods (and more):  developer = Developer.find(11) project   = Project.find(9)  developer.projects developer.projects << project developer.projects.delete(project) developer.projects.destroy(project) developer.projects = [project] developer.project_ids developer.project_ids = [9] developer.projects.clear developer.projects.empty? developer.projects.size developer.projects.find(9) developer.projects.exists?(9) developer.projects.build  # similar to Project.new(developer_id: 11) developer.projects.create # similar to Project.create(developer_id: 11) developer.projects.reload  The declaration may include an +options+ hash to specialize the behavior of the association.  ==== Scopes  You can pass a second argument +scope+ as a callable (i.e. proc or lambda) to retrieve a specific set of records or customize the generated query when you access the associated collection.  Scope examples: has_and_belongs_to_many :projects, -> { includes(:milestones, :manager) } has_and_belongs_to_many :categories, ->(post) { where(\"default_category = ?\", post.default_category) }  ==== Extensions  The +extension+ argument allows you to pass a block into a has_and_belongs_to_many association. This is useful for adding new finders, creators, and other factory-type methods to be used as part of the association.  Extension examples: has_and_belongs_to_many :contractors do def find_or_create_by_name(name) first_name, last_name = name.split(\" \", 2) find_or_create_by(first_name: first_name, last_name: last_name) end end  ==== Options  [+:class_name+] Specify the class name of the association. Use it only if that name can't be inferred from the association name. So <tt>has_and_belongs_to_many :projects</tt> will by default be linked to the Project class, but if the real class name is SuperProject, you'll have to specify it with this option. [+:join_table+] Specify the name of the join table if the default based on lexical order isn't what you want. <b>WARNING:</b> If you're overwriting the table name of either class, the +table_name+ method MUST be declared underneath any #has_and_belongs_to_many declaration in order to work. [+:foreign_key+] Specify the foreign key used for the association. By default this is guessed to be the name of this class in lower-case and \"_id\" suffixed. So a Person class that makes a #has_and_belongs_to_many association to Project will use \"person_id\" as the default <tt>:foreign_key</tt>.  Setting the <tt>:foreign_key</tt> option prevents automatic detection of the association's inverse, so it is generally a good idea to set the <tt>:inverse_of</tt> option as well. [+:association_foreign_key+] Specify the foreign key used for the association on the receiving side of the association. By default this is guessed to be the name of the associated class in lower-case and \"_id\" suffixed. So if a Person class makes a #has_and_belongs_to_many association to Project, the association will use \"project_id\" as the default <tt>:association_foreign_key</tt>. [+:validate+] When set to +true+, validates new objects added to association when saving the parent object. +true+ by default. If you want to ensure associated objects are revalidated on every update, use +validates_associated+. [+:autosave+] If true, always save the associated objects or destroy them if marked for destruction, when saving the parent object. If false, never save or destroy the associated objects. By default, only save associated objects that are new records.  Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets <tt>:autosave</tt> to <tt>true</tt>. [+:strict_loading+] Enforces strict loading every time an associated record is loaded through this association. [+:deprecated+] If true, marks the association as deprecated. Usage of deprecated associations is reported. Please, check the class documentation above for details.  Option examples: has_and_belongs_to_many :projects has_and_belongs_to_many :projects, -> { includes(:milestones, :manager) } has_and_belongs_to_many :nations, class_name: \"Country\" has_and_belongs_to_many :categories, join_table: \"prods_cats\" has_and_belongs_to_many :categories, -> { readonly } has_and_belongs_to_many :categories, strict_loading: true",
    "label": "",
    "id": "1329"
  },
  {
    "raw_code": "def define_attribute(\n        name,\n        cast_type,\n        default: NO_DEFAULT_PROVIDED,\n        user_provided_default: true\n      )\n        attribute_types[name] = cast_type\n        define_default_attribute(name, default, cast_type, from_user: user_provided_default)\n      end",
    "comment": ":method: attribute :call-seq: attribute(name, cast_type = nil, **options)  Defines an attribute with a type on this model. It will override the type of existing attributes if needed. This allows control over how values are converted to and from SQL when assigned to a model. It also changes the behavior of values passed to {ActiveRecord::Base.where}[rdoc-ref:QueryMethods#where]. This will let you use your domain objects across much of Active Record, without having to rely on implementation details or monkey patching.  ==== Parameters  [+name+] The name of the methods to define attribute methods for, and the column which this will persist to.  [+cast_type+] A symbol such as +:string+ or +:integer+, or a type object to be used for this attribute. If this parameter is not passed, the previously defined type (if any) will be used. Otherwise, the type will be ActiveModel::Type::Value. See the examples below for more information about providing custom type objects.  ==== Options  [+:default+] The default value to use when no value is provided. If this option is not passed, the previously defined default value (if any) on the superclass or in the schema will be used. Otherwise, the default will be +nil+.  [+:array+] (PostgreSQL only) Specifies that the type should be an array. See the examples below.  [+:range+] (PostgreSQL only) Specifies that the type should be a range. See the examples below.  When using a symbol for +cast_type+, extra options are forwarded to the constructor of the type object.  ==== Examples  The type detected by Active Record can be overridden.  # db/schema.rb create_table :store_listings, force: true do |t| t.decimal :price_in_cents end  # app/models/store_listing.rb class StoreListing < ActiveRecord::Base end  store_listing = StoreListing.new(price_in_cents: '10.1')  # before store_listing.price_in_cents # => BigDecimal(10.1)  class StoreListing < ActiveRecord::Base attribute :price_in_cents, :integer end  # after store_listing.price_in_cents # => 10  A default can also be provided.  # db/schema.rb create_table :store_listings, force: true do |t| t.string :my_string, default: \"original default\" end  StoreListing.new.my_string # => \"original default\"  # app/models/store_listing.rb class StoreListing < ActiveRecord::Base attribute :my_string, :string, default: \"new default\" end  StoreListing.new.my_string # => \"new default\"  class Product < ActiveRecord::Base attribute :my_default_proc, :datetime, default: -> { Time.now } end  Product.new.my_default_proc # => 2015-05-30 11:04:48 -0600 sleep 1 Product.new.my_default_proc # => 2015-05-30 11:04:49 -0600  \\Attributes do not need to be backed by a database column.  # app/models/my_model.rb class MyModel < ActiveRecord::Base attribute :my_string, :string attribute :my_int_array, :integer, array: true attribute :my_float_range, :float, range: true end  model = MyModel.new( my_string: \"string\", my_int_array: [\"1\", \"2\", \"3\"], my_float_range: \"[1,3.5]\", ) model.attributes # => { my_string: \"string\", my_int_array: [1, 2, 3], my_float_range: 1.0..3.5 }  Passing options to the type constructor  # app/models/my_model.rb class MyModel < ActiveRecord::Base attribute :small_int, :integer, limit: 2 end  MyModel.create(small_int: 65537) # => Error: 65537 is out of range for the limit of two bytes  ==== Creating Custom Types  Users may also define their own custom types, as long as they respond to the methods defined on the value type. The method +deserialize+ or +cast+ will be called on your type object, with raw input from the database or from your controllers. See ActiveModel::Type::Value for the expected API. It is recommended that your type objects inherit from an existing type, or from ActiveRecord::Type::Value  class PriceType < ActiveRecord::Type::Integer def cast(value) if !value.kind_of?(Numeric) && value.include?('$') price_in_dollars = value.gsub(/\\$/, '').to_f super(price_in_dollars * 100) else super end end end  # config/initializers/types.rb ActiveRecord::Type.register(:price, PriceType)  # app/models/store_listing.rb class StoreListing < ActiveRecord::Base attribute :price_in_cents, :price end  store_listing = StoreListing.new(price_in_cents: '$10.00') store_listing.price_in_cents # => 1000  For more details on creating custom types, see the documentation for ActiveModel::Type::Value. For more details on registering your types to be referenced by a symbol, see ActiveRecord::Type.register. You can also pass a type object directly, in place of a symbol.  ==== \\Querying  When {ActiveRecord::Base.where}[rdoc-ref:QueryMethods#where] is called, it will use the type defined by the model class to convert the value to SQL, calling +serialize+ on your type object. For example:  class Money < Struct.new(:amount, :currency) end  class PriceType < ActiveRecord::Type::Value def initialize(currency_converter:) @currency_converter = currency_converter end  # value will be the result of #deserialize or # #cast. Assumed to be an instance of Money in # this case. def serialize(value) value_in_bitcoins = @currency_converter.convert_to_bitcoins(value) value_in_bitcoins.amount end end  # config/initializers/types.rb ActiveRecord::Type.register(:price, PriceType)  # app/models/product.rb class Product < ActiveRecord::Base currency_converter = ConversionRatesFromTheInternet.new attribute :price_in_bitcoins, :price, currency_converter: currency_converter end  Product.where(price_in_bitcoins: Money.new(5, \"USD\")) # SELECT * FROM products WHERE price_in_bitcoins = 0.02230  Product.where(price_in_bitcoins: Money.new(5, \"GBP\")) # SELECT * FROM products WHERE price_in_bitcoins = 0.03412  ==== Dirty Tracking  The type of an attribute is given the opportunity to change how dirty tracking is performed. The methods +changed?+ and +changed_in_place?+ will be called from ActiveModel::Dirty. See the documentation for those methods in ActiveModel::Type::Value for more details.  -- Implemented by ActiveModel::AttributeRegistration#attribute. This API only accepts type objects, and will do its work immediately instead of waiting for the schema to load. While this method is provided so it can be used by plugin authors, application code should probably use ClassMethods#attribute.  ==== Parameters  [+name+] The name of the attribute being defined. Expected to be a +String+.  [+cast_type+] The type object to use for this attribute.  [+default+] The default value to use when no value is provided. If this option is not passed, the previous default value (if any) will be used. Otherwise, the default will be +nil+. A proc can also be passed, and will be called once each time a new value is needed.  [+user_provided_default+] Whether the default value should be cast using +cast+ or +deserialize+.",
    "label": "",
    "id": "1330"
  },
  {
    "raw_code": "def assign_nested_parameter_attributes(pairs)\n        pairs.each { |k, v| _assign_attribute(k, v) }\n      end",
    "comment": "Assign any deferred nested attributes after the base attributes have been set.",
    "label": "",
    "id": "1331"
  },
  {
    "raw_code": "def assign_multiparameter_attributes(pairs)\n        execute_callstack_for_multiparameter_attributes(\n          extract_callstack_for_multiparameter_attributes(pairs)\n        )\n      end",
    "comment": "Instantiates objects for all attribute classes that needs more than one constructor parameter. This is done by calling new on the column type or aggregation type (through composed_of) object with these parameters. So having the pairs written_on(1) = \"2004\", written_on(2) = \"6\", written_on(3) = \"24\", will instantiate written_on (a date type) with Date.new(\"2004\", \"6\", \"24\"). You can also specify a typecast character in the parentheses to have the parameters typecasted before they're used in the constructor. Use i for Integer and f for Float. If all the values for a given attribute are empty, the attribute will be set to +nil+.",
    "label": "",
    "id": "1332"
  },
  {
    "raw_code": "def alias_attribute(new_name, old_name)\n        super\n\n        if @alias_attributes_mass_generated\n          ActiveSupport::CodeGenerator.batch(generated_attribute_methods, __FILE__, __LINE__) do |code_generator|\n            generate_alias_attribute_methods(code_generator, new_name, old_name)\n          end",
    "comment": "Allows you to make aliases for attributes.  class Person < ActiveRecord::Base alias_attribute :nickname, :name end  person = Person.create(name: 'Bob') person.name     # => \"Bob\" person.nickname # => \"Bob\"  The alias can also be used for querying:  Person.where(nickname: \"Bob\") # SELECT \"people\".* FROM \"people\" WHERE \"people\".\"name\" = \"Bob\"",
    "label": "",
    "id": "1333"
  },
  {
    "raw_code": "def define_attribute_methods # :nodoc:\n        return false if @attribute_methods_generated\n        # Use a mutex; we don't want two threads simultaneously trying to define\n        # attribute methods.\n        GeneratedAttributeMethods::LOCK.synchronize do\n          return false if @attribute_methods_generated\n\n          superclass.define_attribute_methods unless base_class?\n\n          unless abstract_class?\n            load_schema\n            super(attribute_names)\n            alias_attribute :id_value, :id if _has_attribute?(\"id\") && !_has_attribute?(\"id_value\")\n          end",
    "comment": "Generates all the attribute related methods for columns in the database accessors, mutators and query methods.",
    "label": "",
    "id": "1334"
  },
  {
    "raw_code": "def instance_method_already_implemented?(method_name)\n        if dangerous_attribute_method?(method_name)\n          raise DangerousAttributeError, \"#{method_name} is defined by Active Record. Check to make sure that you don't have an attribute or method with the same name.\"\n        end",
    "comment": "Raises an ActiveRecord::DangerousAttributeError exception when an \\Active \\Record method is defined in the model, otherwise +false+.  class Person < ActiveRecord::Base def save 'already defined by Active Record' end end  Person.instance_method_already_implemented?(:save) # => ActiveRecord::DangerousAttributeError: save is defined by Active Record. Check to make sure that you don't have an attribute or method with the same name.  Person.instance_method_already_implemented?(:name) # => false",
    "label": "",
    "id": "1335"
  },
  {
    "raw_code": "def dangerous_attribute_method?(name) # :nodoc:\n        ::ActiveRecord::AttributeMethods.dangerous_attribute_methods.include?(name.to_s)\n      end",
    "comment": "A method name is 'dangerous' if it is already (re)defined by Active Record, but not by any ancestors. (So 'puts' is not dangerous but 'save' is.)",
    "label": "",
    "id": "1336"
  },
  {
    "raw_code": "def dangerous_class_method?(method_name)\n        return true if RESTRICTED_CLASS_METHODS.include?(method_name.to_s)\n\n        if Base.respond_to?(method_name, true)\n          if Object.respond_to?(method_name, true)\n            Base.method(method_name).owner != Object.method(method_name).owner\n          else\n            true\n          end",
    "comment": "A class method is 'dangerous' if it is already (re)defined by Active Record, but not by any ancestors. (So 'puts' is not dangerous but 'new' is.)",
    "label": "",
    "id": "1337"
  },
  {
    "raw_code": "def attribute_method?(attribute)\n        super || (table_exists? && column_names.include?(attribute.to_s.delete_suffix(\"=\")))\n      end",
    "comment": "Returns +true+ if +attribute+ is an attribute method and table exists, +false+ otherwise.  class Person < ActiveRecord::Base end  Person.attribute_method?('name')   # => true Person.attribute_method?(:age=)    # => true Person.attribute_method?(:nothing) # => false",
    "label": "",
    "id": "1338"
  },
  {
    "raw_code": "def attribute_names\n        @attribute_names ||= if !abstract_class? && table_exists?\n          attribute_types.keys\n        else\n          []\n        end.freeze\n      end",
    "comment": "Returns an array of column names as strings if it's not an abstract class and table exists. Otherwise it returns an empty array.  class Person < ActiveRecord::Base end  Person.attribute_names # => [\"id\", \"created_at\", \"updated_at\", \"name\", \"age\"]",
    "label": "",
    "id": "1339"
  },
  {
    "raw_code": "def has_attribute?(attr_name)\n        attr_name = attr_name.to_s\n        attr_name = attribute_aliases[attr_name] || attr_name\n        attribute_types.key?(attr_name)\n      end",
    "comment": "Returns true if the given attribute exists, otherwise false.  class Person < ActiveRecord::Base alias_attribute :new_name, :name end  Person.has_attribute?('name')     # => true Person.has_attribute?('new_name') # => true Person.has_attribute?(:age)       # => true Person.has_attribute?(:nothing)   # => false",
    "label": "",
    "id": "1340"
  },
  {
    "raw_code": "def respond_to?(name, include_private = false)\n      return false unless super\n\n      # If the result is true then check for the select case.\n      # For queries selecting a subset of columns, return false for unselected columns.\n      if @attributes\n        if name = self.class.symbol_column_to_string(name.to_sym)\n          return _has_attribute?(name)\n        end",
    "comment": "A Person object with a name attribute can ask <tt>person.respond_to?(:name)</tt>, <tt>person.respond_to?(:name=)</tt>, and <tt>person.respond_to?(:name?)</tt> which will all return +true+. It also defines the attribute methods if they have not been generated.  class Person < ActiveRecord::Base end  person = Person.new person.respond_to?(:name)    # => true person.respond_to?(:name=)   # => true person.respond_to?(:name?)   # => true person.respond_to?('age')    # => true person.respond_to?('age=')   # => true person.respond_to?('age?')   # => true person.respond_to?(:nothing) # => false",
    "label": "",
    "id": "1341"
  },
  {
    "raw_code": "def has_attribute?(attr_name)\n      attr_name = attr_name.to_s\n      attr_name = self.class.attribute_aliases[attr_name] || attr_name\n      @attributes.key?(attr_name)\n    end",
    "comment": "Returns +true+ if the given attribute is in the attributes hash, otherwise +false+.  class Person < ActiveRecord::Base alias_attribute :new_name, :name end  person = Person.new person.has_attribute?(:name)     # => true person.has_attribute?(:new_name) # => true person.has_attribute?('age')     # => true person.has_attribute?(:nothing)  # => false",
    "label": "",
    "id": "1342"
  },
  {
    "raw_code": "def attribute_names\n      @attributes.keys\n    end",
    "comment": "Returns an array of names for the attributes available on this object.  class Person < ActiveRecord::Base end  person = Person.new person.attribute_names # => [\"id\", \"created_at\", \"updated_at\", \"name\", \"age\"]",
    "label": "",
    "id": "1343"
  },
  {
    "raw_code": "def attributes\n      @attributes.to_hash\n    end",
    "comment": "Returns a hash of all the attributes with their names as keys and the values of the attributes as values.  class Person < ActiveRecord::Base end  person = Person.create(name: 'Francesco', age: 22) person.attributes # => {\"id\"=>3, \"created_at\"=>Sun, 21 Oct 2012 04:53:04, \"updated_at\"=>Sun, 21 Oct 2012 04:53:04, \"name\"=>\"Francesco\", \"age\"=>22}",
    "label": "",
    "id": "1344"
  },
  {
    "raw_code": "def attribute_for_inspect(attr_name)\n      attr_name = attr_name.to_s\n      attr_name = self.class.attribute_aliases[attr_name] || attr_name\n      value = _read_attribute(attr_name)\n      format_for_inspect(attr_name, value)\n    end",
    "comment": "Returns an <tt>#inspect</tt>-like string for the value of the attribute +attr_name+. String attributes are truncated up to 50 characters. Other attributes return the value of <tt>#inspect</tt> without modification.  person = Person.create!(name: 'David Heinemeier Hansson ' * 3)  person.attribute_for_inspect(:name) # => \"\\\"David Heinemeier Hansson David Heinemeier Hansson ...\\\"\"  person.attribute_for_inspect(:created_at) # => \"\\\"2012-10-22 00:15:07.000000000 +0000\\\"\"  person.attribute_for_inspect(:tag_ids) # => \"[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\"",
    "label": "",
    "id": "1345"
  },
  {
    "raw_code": "def attribute_present?(attr_name)\n      attr_name = attr_name.to_s\n      attr_name = self.class.attribute_aliases[attr_name] || attr_name\n      value = _read_attribute(attr_name)\n      !value.nil? && !(value.respond_to?(:empty?) && value.empty?)\n    end",
    "comment": "Returns +true+ if the specified +attribute+ has been set by the user or by a database load and is neither +nil+ nor <tt>empty?</tt> (the latter only applies to objects that respond to <tt>empty?</tt>, most notably Strings). Otherwise, +false+. Note that it always returns +true+ with boolean attributes.  class Task < ActiveRecord::Base end  task = Task.new(title: '', is_done: false) task.attribute_present?(:title)   # => false task.attribute_present?(:is_done) # => true task.title = 'Buy milk' task.is_done = true task.attribute_present?(:title)   # => true task.attribute_present?(:is_done) # => true",
    "label": "",
    "id": "1346"
  },
  {
    "raw_code": "def [](attr_name)\n      read_attribute(attr_name) { |n| missing_attribute(n, caller) }\n    end",
    "comment": "Returns the value of the attribute identified by +attr_name+ after it has been type cast. (For information about specific type casting behavior, see the types under ActiveModel::Type.)  class Person < ActiveRecord::Base belongs_to :organization end  person = Person.new(name: \"Francesco\", date_of_birth: \"2004-12-12\") person[:name]            # => \"Francesco\" person[:date_of_birth]   # => Date.new(2004, 12, 12) person[:organization_id] # => nil  Raises ActiveModel::MissingAttributeError if the attribute is missing. Note, however, that the +id+ attribute will never be considered missing.  person = Person.select(:name).first person[:name]            # => \"Francesco\" person[:date_of_birth]   # => ActiveModel::MissingAttributeError: missing attribute 'date_of_birth' for Person person[:organization_id] # => ActiveModel::MissingAttributeError: missing attribute 'organization_id' for Person person[:id]              # => nil",
    "label": "",
    "id": "1347"
  },
  {
    "raw_code": "def []=(attr_name, value)\n      write_attribute(attr_name, value)\n    end",
    "comment": "Updates the attribute identified by +attr_name+ using the specified +value+. The attribute value will be type cast upon being read.  class Person < ActiveRecord::Base end  person = Person.new person[:date_of_birth] = \"2004-12-12\" person[:date_of_birth] # => Date.new(2004, 12, 12)",
    "label": "",
    "id": "1348"
  },
  {
    "raw_code": "def accessed_fields\n      @attributes.accessed\n    end",
    "comment": "Returns the name of all database fields which have been read from this model. This can be useful in development mode to determine which fields need to be selected. For performance critical pages, selecting only the required fields can be an easy performance win (assuming you aren't using all of the fields on the model).  For example:  class PostsController < ActionController::Base after_action :print_accessed_fields, only: :index  def index @posts = Post.all end  private def print_accessed_fields p @posts.first.accessed_fields end end  Which allows you to quickly change your code to:  class PostsController < ActionController::Base def index @posts = Post.select(:id, :title, :author_id, :updated_at) end end",
    "label": "",
    "id": "1349"
  },
  {
    "raw_code": "def attributes_for_update(attribute_names)\n        attribute_names &= self.class.column_names\n        attribute_names.delete_if do |name|\n          self.class.readonly_attribute?(name) ||\n            self.class.counter_cache_column?(name) ||\n            column_for_attribute(name).virtual?\n        end",
    "comment": "Filters the primary keys, readonly attributes and virtual columns from the attribute names.",
    "label": "",
    "id": "1350"
  },
  {
    "raw_code": "def attributes_for_create(attribute_names)\n        attribute_names &= self.class.column_names\n        attribute_names.delete_if do |name|\n          (pk_attribute?(name) && id.nil?) ||\n            column_for_attribute(name).virtual?\n        end",
    "comment": "Filters out the virtual columns and also primary keys, from the attribute names, when the primary key is to be generated (e.g. the id attribute has no value).",
    "label": "",
    "id": "1351"
  },
  {
    "raw_code": "def add_autosave_association_callbacks(reflection)\n          save_method = :\"autosave_associated_records_for_#{reflection.name}\"\n\n          if reflection.collection?\n            around_save :around_save_collection_association\n\n            define_non_cyclic_method(save_method) { save_collection_association(reflection) }\n            # Doesn't use after_save as that would save associations added in after_create/after_update twice\n            after_create save_method\n            after_update save_method\n          elsif reflection.has_one?\n            define_non_cyclic_method(save_method) { save_has_one_association(reflection) }\n            # Configures two callbacks instead of a single after_save so that\n            # the model may rely on their execution order relative to its\n            # own callbacks.\n            #\n            # For example, given that after_creates run before after_saves, if\n            # we configured instead an after_save there would be no way to fire\n            # a custom after_create callback after the child association gets\n            # created.\n            after_create save_method\n            after_update save_method\n          else\n            define_non_cyclic_method(save_method) { throw(:abort) if save_belongs_to_association(reflection) == false }\n            before_save save_method\n          end",
    "comment": "Adds validation and save callbacks for the association as specified by the +reflection+.  For performance reasons, we don't check whether to validate at runtime. However the validation and callback methods are lazy and those methods get created when they are invoked for the very first time. However, this can change, for instance, when using nested attributes, which is called _after_ the association has been defined. Since we don't want the callbacks to get defined multiple times, there are guards that check if the save or validation methods have already been defined before actually defining them.",
    "label": "",
    "id": "1352"
  },
  {
    "raw_code": "def reload(options = nil)\n      @marked_for_destruction = false\n      @destroyed_by_association = nil\n      super\n    end",
    "comment": "Reloads the attributes of the object as usual and clears <tt>marked_for_destruction</tt> flag.",
    "label": "",
    "id": "1353"
  },
  {
    "raw_code": "def mark_for_destruction\n      @marked_for_destruction = true\n    end",
    "comment": "Marks this record to be destroyed as part of the parent's save transaction. This does _not_ actually destroy the record instantly, rather child record will be destroyed when <tt>parent.save</tt> is called.  Only useful if the <tt>:autosave</tt> option on the parent is enabled for this associated model.",
    "label": "",
    "id": "1354"
  },
  {
    "raw_code": "def marked_for_destruction?\n      @marked_for_destruction\n    end",
    "comment": "Returns whether or not this record will be destroyed as part of the parent's save transaction.  Only useful if the <tt>:autosave</tt> option on the parent is enabled for this associated model.",
    "label": "",
    "id": "1355"
  },
  {
    "raw_code": "def destroyed_by_association=(reflection)\n      @destroyed_by_association = reflection\n    end",
    "comment": "Records the association that is being destroyed and destroying this record in the process.",
    "label": "",
    "id": "1356"
  },
  {
    "raw_code": "def destroyed_by_association\n      @destroyed_by_association\n    end",
    "comment": "Returns the association for the parent being destroyed.  Used to avoid updating the counter cache unnecessarily.",
    "label": "",
    "id": "1357"
  },
  {
    "raw_code": "def changed_for_autosave?\n      new_record? || has_changes_to_save? || marked_for_destruction? || nested_records_changed_for_autosave?\n    end",
    "comment": "Returns whether or not this record has been changed in any way (including whether any of its nested autosave associations are likewise changed)",
    "label": "",
    "id": "1358"
  },
  {
    "raw_code": "def associated_records_to_validate_or_save(association, new_record, autosave)\n        if new_record || custom_validation_context?\n          association && association.target\n        elsif autosave\n          association.target.find_all(&:changed_for_autosave?)\n        else\n          association.target.find_all(&:new_record?)\n        end",
    "comment": "Returns the record for an association collection that should be validated or saved. If +autosave+ is +false+ only new records will be returned, unless the parent is/was a new record itself.",
    "label": "",
    "id": "1359"
  },
  {
    "raw_code": "def nested_records_changed_for_autosave?\n        @_nested_records_changed_for_autosave_already_called ||= false\n        return false if @_nested_records_changed_for_autosave_already_called\n        begin\n          @_nested_records_changed_for_autosave_already_called = true\n          self.class._reflections.values.any? do |reflection|\n            if reflection.options[:autosave]\n              association = association_instance_get(reflection.name)\n              association && Array.wrap(association.target).any?(&:changed_for_autosave?)\n            end",
    "comment": "Go through nested autosave associations that are loaded in memory (without loading any new ones), and return true if any are changed for autosave. Returns false if already called to prevent an infinite loop.",
    "label": "",
    "id": "1360"
  },
  {
    "raw_code": "def validate_has_one_association(reflection)\n        association = association_instance_get(reflection.name)\n        record      = association && association.reader\n        return unless record && (record.changed_for_autosave? || custom_validation_context?)\n\n        inverse_association = reflection.inverse_of && record.association(reflection.inverse_of.name)\n        return if inverse_association && (record.validating_belongs_to_for?(inverse_association) ||\n          record.autosaving_belongs_to_for?(inverse_association))\n\n        association_valid?(association, record)\n      end",
    "comment": "Validate the association if <tt>:validate</tt> or <tt>:autosave</tt> is turned on for the has_one association.",
    "label": "",
    "id": "1361"
  },
  {
    "raw_code": "def validate_belongs_to_association(reflection)\n        association = association_instance_get(reflection.name)\n        record      = association && association.reader\n        return unless record && (record.changed_for_autosave? || custom_validation_context?)\n\n        begin\n          @validating_belongs_to_for ||= {}\n          @validating_belongs_to_for[association] = true\n          association_valid?(association, record)\n        ensure\n          @validating_belongs_to_for[association] = false\n        end",
    "comment": "Validate the association if <tt>:validate</tt> or <tt>:autosave</tt> is turned on for the belongs_to association.",
    "label": "",
    "id": "1362"
  },
  {
    "raw_code": "def validate_collection_association(reflection)\n        if association = association_instance_get(reflection.name)\n          if records = associated_records_to_validate_or_save(association, new_record?, reflection.options[:autosave])\n            records.each { |record| association_valid?(association, record) }\n          end",
    "comment": "Validate the associated records if <tt>:validate</tt> or <tt>:autosave</tt> is turned on for the association specified by +reflection+.",
    "label": "",
    "id": "1363"
  },
  {
    "raw_code": "def association_valid?(association, record)\n        return true if record.destroyed? || (association.options[:autosave] && record.marked_for_destruction?)\n\n        context = validation_context if custom_validation_context?\n        return true if record.valid?(context)\n\n        if context || record.changed_for_autosave?\n          associated_errors = record.errors.objects\n        else\n          # If there are existing invalid records in the DB, we should still be able to reference them.\n          # Unless a record (no matter where in the association chain) is invalid and is being changed.\n          associated_errors = record.errors.objects.select { |error| error.is_a?(Associations::NestedError) }\n        end",
    "comment": "Returns whether or not the association is valid and applies any errors to the parent, <tt>self</tt>, if it wasn't. Skips any <tt>:autosave</tt> enabled records if they're marked_for_destruction? or destroyed.",
    "label": "",
    "id": "1364"
  },
  {
    "raw_code": "def around_save_collection_association\n        previously_new_record_before_save = (@new_record_before_save ||= false)\n        @new_record_before_save = !previously_new_record_before_save && new_record?\n\n        yield\n      ensure\n        @new_record_before_save = previously_new_record_before_save\n      end",
    "comment": "Is used as an around_save callback to check while saving a collection association whether or not the parent was a new record before saving.",
    "label": "",
    "id": "1365"
  },
  {
    "raw_code": "def save_collection_association(reflection)\n        if association = association_instance_get(reflection.name)\n          autosave = reflection.options[:autosave]\n\n          # By saving the instance variable in a local variable,\n          # we make the whole callback re-entrant.\n          new_record_before_save = @new_record_before_save\n\n          # reconstruct the scope now that we know the owner's id\n          association.reset_scope\n\n          if records = associated_records_to_validate_or_save(association, new_record_before_save, autosave)\n            if autosave\n              records_to_destroy = records.select(&:marked_for_destruction?)\n              records_to_destroy.each { |record| association.destroy(record) }\n              records -= records_to_destroy\n            end",
    "comment": "Saves any new associated records, or all loaded autosave associations if <tt>:autosave</tt> is enabled on the association.  In addition, it destroys all children that were marked for destruction with #mark_for_destruction.  This all happens inside a transaction, _if_ the Transactions module is included into ActiveRecord::Base after the AutosaveAssociation module, which it does by default.",
    "label": "",
    "id": "1366"
  },
  {
    "raw_code": "def save_has_one_association(reflection)\n        association = association_instance_get(reflection.name)\n        return unless association && association.loaded?\n\n        record = association.load_target\n        return unless record && !record.destroyed?\n\n        autosave = reflection.options[:autosave]\n\n        if autosave && record.marked_for_destruction?\n          record.destroy\n        elsif autosave != false\n          primary_key = Array(compute_primary_key(reflection, self)).map(&:to_s)\n          primary_key_value = primary_key.map { |key| _read_attribute(key) }\n          return unless (autosave && record.changed_for_autosave?) || _record_changed?(reflection, record, primary_key_value)\n\n          unless reflection.through_reflection\n            foreign_key = Array(reflection.foreign_key)\n            primary_key_foreign_key_pairs = primary_key.zip(foreign_key)\n\n            primary_key_foreign_key_pairs.each do |primary_key, foreign_key|\n              association_id = _read_attribute(primary_key)\n              record[foreign_key] = association_id unless record[foreign_key] == association_id\n            end",
    "comment": "Saves the associated record if it's new or <tt>:autosave</tt> is enabled on the association.  In addition, it will destroy the association if it was marked for destruction with #mark_for_destruction.  This all happens inside a transaction, _if_ the Transactions module is included into ActiveRecord::Base after the AutosaveAssociation module, which it does by default.",
    "label": "",
    "id": "1367"
  },
  {
    "raw_code": "def _record_changed?(reflection, record, key)\n        record.new_record? ||\n          (association_foreign_key_changed?(reflection, record, key) ||\n          inverse_polymorphic_association_changed?(reflection, record)) ||\n          record.will_save_change_to_attribute?(reflection.foreign_key)\n      end",
    "comment": "If the record is new or it has changed, returns true.",
    "label": "",
    "id": "1368"
  },
  {
    "raw_code": "def save_belongs_to_association(reflection)\n        association = association_instance_get(reflection.name)\n        return unless association && association.loaded? && !association.stale_target?\n\n        record = association.load_target\n        if record && !record.destroyed?\n          autosave = reflection.options[:autosave]\n\n          if autosave && record.marked_for_destruction?\n            foreign_key = Array(reflection.foreign_key)\n            foreign_key.each { |key| self[key] = nil }\n            record.destroy\n          elsif autosave != false\n            saved = if record.new_record? || (autosave && record.changed_for_autosave?)\n              begin\n                @autosaving_belongs_to_for ||= {}\n                @autosaving_belongs_to_for[association] = true\n                record.save(validate: !autosave)\n              ensure\n                @autosaving_belongs_to_for[association] = false\n              end",
    "comment": "Saves the associated record if it's new or <tt>:autosave</tt> is enabled.  In addition, it will destroy the association if it was marked for destruction.",
    "label": "",
    "id": "1369"
  },
  {
    "raw_code": "def register(name, class_name, path = class_name.underscore)\n        @adapters[name.to_s] = [class_name, path]\n      end",
    "comment": "Registers a custom database adapter.  Can also be used to define aliases.  == Example  ActiveRecord::ConnectionAdapters.register(\"megadb\", \"MegaDB::ActiveRecordAdapter\", \"mega_db/active_record_adapter\")  ActiveRecord::ConnectionAdapters.register(\"mysql\", \"ActiveRecord::ConnectionAdapters::TrilogyAdapter\", \"active_record/connection_adapters/trilogy_adapter\") ",
    "label": "",
    "id": "1370"
  },
  {
    "raw_code": "def establish_connection(config_or_env = nil)\n      config_or_env ||= DEFAULT_ENV.call.to_sym\n      db_config = resolve_config_for_connection(config_or_env)\n      connection_handler.establish_connection(db_config, owner_name: self, role: current_role, shard: current_shard)\n    end",
    "comment": "Establishes the connection to the database. Accepts a hash as input where the <tt>:adapter</tt> key must be specified with the name of a database adapter (in lower-case) example for regular databases (MySQL, PostgreSQL, etc):  ActiveRecord::Base.establish_connection( adapter:  \"mysql2\", host:     \"localhost\", username: \"myuser\", password: \"mypass\", database: \"somedatabase\" )  Example for SQLite database:  ActiveRecord::Base.establish_connection( adapter:  \"sqlite3\", database: \"path/to/dbfile\" )  Also accepts keys as strings (for parsing from YAML for example):  ActiveRecord::Base.establish_connection( \"adapter\"  => \"sqlite3\", \"database\" => \"path/to/dbfile\" )  Or a URL:  ActiveRecord::Base.establish_connection( \"postgres://myuser:mypass@localhost/somedatabase\" )  In case {ActiveRecord::Base.configurations}[rdoc-ref:Core.configurations] is set (\\Rails automatically loads the contents of config/database.yml into it), a symbol can also be given as argument, representing a key in the configuration hash:  ActiveRecord::Base.establish_connection(:production)  The exceptions AdapterNotSpecified, AdapterNotFound, and +ArgumentError+ may be returned on an error.",
    "label": "",
    "id": "1371"
  },
  {
    "raw_code": "def connects_to(database: {}, shards: {})\n      raise NotImplementedError, \"`connects_to` can only be called on ActiveRecord::Base or abstract classes\" unless self == Base || abstract_class?\n\n      if database.present? && shards.present?\n        raise ArgumentError, \"`connects_to` can only accept a `database` or `shards` argument, but not both arguments.\"\n      end",
    "comment": "Connects a model to the databases specified. The +database+ keyword takes a hash consisting of a +role+ and a +database_key+.  This will look up the database config using the +database_key+ and establish a connection to that config.  class AnimalsModel < ApplicationRecord self.abstract_class = true  connects_to database: { writing: :primary, reading: :primary_replica } end  +connects_to+ also supports horizontal sharding. The horizontal sharding API supports read replicas as well. You can connect a model to a list of shards like this:  class AnimalsModel < ApplicationRecord self.abstract_class = true  connects_to shards: { default: { writing: :primary, reading: :primary_replica }, shard_two: { writing: :primary_shard_two, reading: :primary_shard_replica_two } } end  Returns an array of database connections.",
    "label": "",
    "id": "1372"
  },
  {
    "raw_code": "def connected_to(role: nil, shard: nil, prevent_writes: false, &blk)\n      if self != Base && !abstract_class\n        raise NotImplementedError, \"calling `connected_to` is only allowed on ActiveRecord::Base or abstract classes.\"\n      end",
    "comment": "Connects to a role (e.g. writing, reading, or a custom role) and/or shard for the duration of the block. At the end of the block the connection will be returned to the original role / shard.  If only a role is passed, Active Record will look up the connection based on the requested role. If a non-established role is requested an +ActiveRecord::ConnectionNotEstablished+ error will be raised:  ActiveRecord::Base.connected_to(role: :writing) do Dog.create! # creates dog using dog writing connection end  ActiveRecord::Base.connected_to(role: :reading) do Dog.create! # throws exception because we're on a replica end  When swapping to a shard, the role must be passed as well. If a non-existent shard is passed, an +ActiveRecord::ConnectionNotEstablished+ error will be raised.  When a shard and role is passed, Active Record will first lookup the role, and then look up the connection by shard key.  ActiveRecord::Base.connected_to(role: :reading, shard: :shard_one_replica) do Dog.first # finds first Dog record stored on the shard one replica end",
    "label": "",
    "id": "1373"
  },
  {
    "raw_code": "def connected_to_many(*classes, role:, shard: nil, prevent_writes: false)\n      classes = classes.flatten\n\n      if self != Base || classes.include?(Base)\n        raise NotImplementedError, \"connected_to_many can only be called on ActiveRecord::Base.\"\n      end",
    "comment": "Connects a role and/or shard to the provided connection names. Optionally +prevent_writes+ can be passed to block writes on a connection. +reading+ will automatically set +prevent_writes+ to true.  +connected_to_many+ is an alternative to deeply nested +connected_to+ blocks.  Usage:  ActiveRecord::Base.connected_to_many(AnimalsRecord, MealsRecord, role: :reading) do Dog.first # Read from animals replica Dinner.first # Read from meals replica Person.first # Read from primary writer end",
    "label": "",
    "id": "1374"
  },
  {
    "raw_code": "def connected_to_all_shards(role: nil, prevent_writes: false, &blk)\n      shard_keys.map do |shard|\n        connected_to(shard: shard, role: role, prevent_writes: prevent_writes, &blk)\n      end",
    "comment": "Passes the block to +connected_to+ for every +shard+ the model is configured to connect to (if any), and returns the results in an array.  Optionally, +role+ and/or +prevent_writes+ can be passed which will be forwarded to each +connected_to+ call.",
    "label": "",
    "id": "1375"
  },
  {
    "raw_code": "def connecting_to(role: default_role, shard: default_shard, prevent_writes: false)\n      prevent_writes = true if role == ActiveRecord.reading_role\n\n      append_to_connected_to_stack(role: role, shard: shard, prevent_writes: prevent_writes, klasses: [self])\n    end",
    "comment": "Use a specified connection.  This method is useful for ensuring that a specific connection is being used. For example, when booting a console in readonly mode.  It is not recommended to use this method in a request since it does not yield to a block like +connected_to+.",
    "label": "",
    "id": "1376"
  },
  {
    "raw_code": "def prohibit_shard_swapping(enabled = true)\n      prev_value = ActiveSupport::IsolatedExecutionState[:active_record_prohibit_shard_swapping]\n      ActiveSupport::IsolatedExecutionState[:active_record_prohibit_shard_swapping] = enabled\n      yield\n    ensure\n      ActiveSupport::IsolatedExecutionState[:active_record_prohibit_shard_swapping] = prev_value\n    end",
    "comment": "Prohibit swapping shards while inside of the passed block.  In some cases you may want to be able to swap shards but not allow a nested call to connected_to or connected_to_many to swap again. This is useful in cases you're using sharding to provide per-request database isolation.",
    "label": "",
    "id": "1377"
  },
  {
    "raw_code": "def shard_swapping_prohibited?\n      ActiveSupport::IsolatedExecutionState[:active_record_prohibit_shard_swapping]\n    end",
    "comment": "Determine whether or not shard swapping is currently prohibited",
    "label": "",
    "id": "1378"
  },
  {
    "raw_code": "def while_preventing_writes(enabled = true, &block)\n      connected_to(role: current_role, prevent_writes: enabled, &block)\n    end",
    "comment": "Prevent writing to the database regardless of role.  In some cases you may want to prevent writes to the database even if you are on a database that can write. +while_preventing_writes+ will prevent writes to the database for the duration of the block.  This method does not provide the same protection as a readonly user and is meant to be a safeguard against accidental writes.  See +READ_QUERY+ for the queries that are blocked by this method.",
    "label": "",
    "id": "1379"
  },
  {
    "raw_code": "def connected_to?(role:, shard: ActiveRecord::Base.default_shard)\n      current_role == role.to_sym && current_shard == shard.to_sym\n    end",
    "comment": "Returns true if role is the current connected role and/or current connected shard. If no shard is passed, the default will be used.  ActiveRecord::Base.connected_to(role: :writing) do ActiveRecord::Base.connected_to?(role: :writing) #=> true ActiveRecord::Base.connected_to?(role: :reading) #=> false end  ActiveRecord::Base.connected_to(role: :reading, shard: :shard_one) do ActiveRecord::Base.connected_to?(role: :reading, shard: :shard_one) #=> true ActiveRecord::Base.connected_to?(role: :reading, shard: :default) #=> false ActiveRecord::Base.connected_to?(role: :writing, shard: :shard_one) #=> true end",
    "label": "",
    "id": "1380"
  },
  {
    "raw_code": "def clear_query_caches_for_current_thread\n      connection_handler.each_connection_pool do |pool|\n        pool.clear_query_cache\n      end",
    "comment": "Clears the query cache for all connections associated with the current thread.",
    "label": "",
    "id": "1381"
  },
  {
    "raw_code": "def lease_connection\n      connection_pool.lease_connection\n    end",
    "comment": "Returns the connection currently associated with the class. This can also be used to \"borrow\" the connection to do database work unrelated to any of the specific Active Records. The connection will remain leased for the entire duration of the request or job, or until +#release_connection+ is called.",
    "label": "",
    "id": "1382"
  },
  {
    "raw_code": "def connection\n      pool = connection_pool\n      if pool.permanent_lease?\n        case ActiveRecord.permanent_connection_checkout\n        when :deprecated\n          ActiveRecord.deprecator.warn <<~MESSAGE\n            Called deprecated `ActiveRecord::Base.connection` method.\n\n            Either use `with_connection` or `lease_connection`.\n          MESSAGE\n        when :disallowed\n          raise ActiveRecordError, <<~MESSAGE\n            Called deprecated `ActiveRecord::Base.connection` method.\n\n            Either use `with_connection` or `lease_connection`.\n          MESSAGE\n        end",
    "comment": "Soft deprecated. Use +#with_connection+ or +#lease_connection+ instead.",
    "label": "",
    "id": "1383"
  },
  {
    "raw_code": "def release_connection\n      connection_pool.release_connection\n    end",
    "comment": "Return the currently leased connection into the pool",
    "label": "",
    "id": "1384"
  },
  {
    "raw_code": "def with_connection(prevent_permanent_checkout: false, &block)\n      connection_pool.with_connection(prevent_permanent_checkout: prevent_permanent_checkout, &block)\n    end",
    "comment": "Checkouts a connection from the pool, yield it and then check it back in. If a connection was already leased via #lease_connection or a parent call to #with_connection, that same connection is yielded. If #lease_connection is called inside the block, the connection won't be checked back in. If #connection is called inside the block, the connection won't be checked back in unless the +prevent_permanent_checkout+ argument is set to +true+.",
    "label": "",
    "id": "1385"
  },
  {
    "raw_code": "def connection_specification_name\n      if @connection_specification_name.nil?\n        return self == Base ? Base.name : superclass.connection_specification_name\n      end",
    "comment": "Returns the connection specification name from the current class or its parent.",
    "label": "",
    "id": "1386"
  },
  {
    "raw_code": "def connection_db_config\n      connection_pool.db_config\n    end",
    "comment": "Returns the db_config object from the associated connection:  ActiveRecord::Base.connection_db_config #<ActiveRecord::DatabaseConfigurations::HashConfig:0x00007fd1acbded10 @env_name=\"development\", @name=\"primary\", @config={pool: 5, timeout: 5000, database: \"storage/development.sqlite3\", adapter: \"sqlite3\"}>  Use only for reading.",
    "label": "",
    "id": "1387"
  },
  {
    "raw_code": "def connected?\n      connection_handler.connected?(connection_specification_name, role: current_role, shard: current_shard)\n    end",
    "comment": "Returns +true+ if Active Record is connected.",
    "label": "",
    "id": "1388"
  },
  {
    "raw_code": "def self.destroy_association_async_job\n        if _destroy_association_async_job.is_a?(String)\n          self._destroy_association_async_job = _destroy_association_async_job.constantize\n        end",
    "comment": "The job class used to destroy associations in the background.",
    "label": "",
    "id": "1389"
  },
  {
    "raw_code": "def self.configurations=(config)\n        @@configurations = ActiveRecord::DatabaseConfigurations.new(config)\n      end",
    "comment": " Contains the database configuration - as is typically stored in config/database.yml - as an ActiveRecord::DatabaseConfigurations object.  For example, the following database.yml...  development: adapter: sqlite3 database: storage/development.sqlite3  production: adapter: sqlite3 database: storage/production.sqlite3  ...would result in ActiveRecord::Base.configurations to look like this:  #<ActiveRecord::DatabaseConfigurations:0x00007fd1acbdf800 @configurations=[ #<ActiveRecord::DatabaseConfigurations::HashConfig:0x00007fd1acbded10 @env_name=\"development\", @name=\"primary\", @config={adapter: \"sqlite3\", database: \"storage/development.sqlite3\"}>, #<ActiveRecord::DatabaseConfigurations::HashConfig:0x00007fd1acbdea90 @env_name=\"production\", @name=\"primary\", @config={adapter: \"sqlite3\", database: \"storage/production.sqlite3\"}> ]>",
    "label": "",
    "id": "1390"
  },
  {
    "raw_code": "def self.configurations\n        @@configurations\n      end",
    "comment": "Returns a fully resolved ActiveRecord::DatabaseConfigurations object.",
    "label": "",
    "id": "1391"
  },
  {
    "raw_code": "def self.current_role\n        connected_to_stack.reverse_each do |hash|\n          return hash[:role] if hash[:role] && hash[:klasses].include?(Base)\n          return hash[:role] if hash[:role] && hash[:klasses].include?(connection_class_for_self)\n        end",
    "comment": "Returns the symbol representing the current connected role.  ActiveRecord::Base.connected_to(role: :writing) do ActiveRecord::Base.current_role #=> :writing end  ActiveRecord::Base.connected_to(role: :reading) do ActiveRecord::Base.current_role #=> :reading end",
    "label": "",
    "id": "1392"
  },
  {
    "raw_code": "def self.current_shard\n        connected_to_stack.reverse_each do |hash|\n          return hash[:shard] if hash[:shard] && hash[:klasses].include?(Base)\n          return hash[:shard] if hash[:shard] && hash[:klasses].include?(connection_class_for_self)\n        end",
    "comment": "Returns the symbol representing the current connected shard.  ActiveRecord::Base.connected_to(role: :reading) do ActiveRecord::Base.current_shard #=> :default end  ActiveRecord::Base.connected_to(role: :writing, shard: :one) do ActiveRecord::Base.current_shard #=> :one end",
    "label": "",
    "id": "1393"
  },
  {
    "raw_code": "def self.current_preventing_writes\n        connected_to_stack.reverse_each do |hash|\n          return hash[:prevent_writes] if !hash[:prevent_writes].nil? && hash[:klasses].include?(Base)\n          return hash[:prevent_writes] if !hash[:prevent_writes].nil? && hash[:klasses].include?(connection_class_for_self)\n        end",
    "comment": "Returns the symbol representing the current setting for preventing writes.  ActiveRecord::Base.connected_to(role: :reading) do ActiveRecord::Base.current_preventing_writes #=> true end  ActiveRecord::Base.connected_to(role: :writing) do ActiveRecord::Base.current_preventing_writes #=> false end",
    "label": "",
    "id": "1394"
  },
  {
    "raw_code": "def self.preventing_writes?(class_name) # :nodoc:\n        connected_to_stack.reverse_each do |hash|\n          return hash[:prevent_writes] if !hash[:prevent_writes].nil? && hash[:klasses].include?(Base)\n          return hash[:prevent_writes] if !hash[:prevent_writes].nil? && hash[:klasses].any? { |klass| klass.name == class_name }\n        end",
    "comment": "Intended to behave like `.current_preventing_writes` given the class name as input. See PoolConfig and ConnectionHandler::ConnectionDescriptor.",
    "label": "",
    "id": "1395"
  },
  {
    "raw_code": "def filter_attributes\n        if @filter_attributes.nil?\n          superclass.filter_attributes\n        else\n          @filter_attributes\n        end",
    "comment": "Returns columns which shouldn't be exposed while calling +#inspect+.",
    "label": "",
    "id": "1396"
  },
  {
    "raw_code": "def filter_attributes=(filter_attributes)\n        @inspection_filter = nil\n        @filter_attributes = filter_attributes\n\n        FilterAttributeHandler.sensitive_attribute_was_declared(self, filter_attributes)\n      end",
    "comment": "Specifies columns which shouldn't be exposed while calling +#inspect+.",
    "label": "",
    "id": "1397"
  },
  {
    "raw_code": "def inspect # :nodoc:\n        if self == Base || singleton_class?\n          super\n        elsif abstract_class?\n          \"#{super}(abstract)\"\n        elsif !schema_loaded? && !connected?\n          \"#{super} (call '#{super}.load_schema' to load schema informations)\"\n        elsif table_exists?\n          attr_list = attribute_types.map { |name, type| \"#{name}: #{type.type}\" } * \", \"\n          \"#{super}(#{attr_list})\"\n        else\n          \"#{super}(Table doesn't exist)\"\n        end",
    "comment": "Returns a string like 'Post(id:integer, title:string, body:text)'",
    "label": "",
    "id": "1398"
  },
  {
    "raw_code": "def arel_table # :nodoc:\n        @arel_table ||= Arel::Table.new(table_name, klass: self)\n      end",
    "comment": "Returns an instance of +Arel::Table+ loaded with the current table name.",
    "label": "",
    "id": "1399"
  },
  {
    "raw_code": "def initialize(attributes = nil)\n      @new_record = true\n      @attributes = self.class._default_attributes.deep_dup\n\n      init_internals\n      initialize_internals_callback\n\n      super\n\n      yield self if block_given?\n      _run_initialize_callbacks\n    end",
    "comment": "New objects can be instantiated as either empty (pass no construction parameter) or pre-set with attributes but not yet saved (pass a hash with key names matching the associated table column names). In both instances, valid attribute keys are determined by the column names of the associated table -- hence you can't have attributes that aren't part of the table columns.  ==== Example # Instantiates a single new object User.new(first_name: 'Jamie')",
    "label": "",
    "id": "1400"
  },
  {
    "raw_code": "def init_with(coder, &block)\n      coder = LegacyYamlAdapter.convert(coder)\n      attributes = self.class.yaml_encoder.decode(coder)\n      init_with_attributes(attributes, coder[\"new_record\"], &block)\n    end",
    "comment": "Initialize an empty model object from +coder+. +coder+ should be the result of previously encoding an Active Record model, using #encode_with.  class Post < ActiveRecord::Base end  old_post = Post.new(title: \"hello world\") coder = {} old_post.encode_with(coder)  post = Post.allocate post.init_with(coder) post.title # => 'hello world'",
    "label": "",
    "id": "1401"
  },
  {
    "raw_code": "def init_with_attributes(attributes, new_record = false) # :nodoc:\n      @new_record = new_record\n      @attributes = attributes\n\n      init_internals\n\n      yield self if block_given?\n\n      _run_find_callbacks\n      _run_initialize_callbacks\n\n      self\n    end",
    "comment": " Initialize an empty model object from +attributes+. +attributes+ should be an attributes object, and unlike the `initialize` method, no assignment calls are made per attribute.",
    "label": "",
    "id": "1402"
  },
  {
    "raw_code": "def initialize_dup(other) # :nodoc:\n      @attributes = init_attributes(other)\n\n      _run_initialize_callbacks\n\n      @new_record               = true\n      @previously_new_record    = false\n      @destroyed                = false\n      @_start_transaction_state = nil\n\n      super\n    end",
    "comment": " :method: clone Identical to Ruby's clone method.  This is a \"shallow\" copy.  Be warned that your attributes are not copied. That means that modifying attributes of the clone will modify the original, since they will both point to the same attributes hash. If you need a copy of your attributes hash, please use the #dup method.  user = User.first new_user = user.clone user.name               # => \"Bob\" new_user.name = \"Joe\" user.name               # => \"Joe\"  user.object_id == new_user.object_id            # => false user.name.object_id == new_user.name.object_id  # => true  user.name.object_id == user.dup.name.object_id  # => false  :method: dup Duped objects have no id assigned and are treated as new records. Note that this is a \"shallow\" copy as it copies the object's attributes only, not its associations. The extent of a \"deep\" copy is application specific and is therefore left to the application to implement according to its need. The dup method does not preserve the timestamps (created|updated)_(at|on) and locking column. ",
    "label": "",
    "id": "1403"
  },
  {
    "raw_code": "def encode_with(coder)\n      self.class.yaml_encoder.encode(@attributes, coder)\n      coder[\"new_record\"] = new_record?\n      coder[\"active_record_yaml_version\"] = 2\n    end",
    "comment": "Populate +coder+ with attributes about this record that should be serialized. The structure of +coder+ defined in this method is guaranteed to match the structure of +coder+ passed to the #init_with method.  Example:  class Post < ActiveRecord::Base end coder = {} Post.new.encode_with(coder) coder # => {\"attributes\" => {\"id\" => nil, ... }}",
    "label": "",
    "id": "1404"
  },
  {
    "raw_code": "def ==(comparison_object)\n      super ||\n        comparison_object.instance_of?(self.class) &&\n        primary_key_values_present? &&\n        comparison_object.id == id\n    end",
    "comment": " :method: slice  :call-seq: slice(*methods)  Returns a hash of the given methods with their names as keys and returned values as values.  topic = Topic.new(title: \"Budget\", author_name: \"Jason\") topic.slice(:title, :author_name) # => { \"title\" => \"Budget\", \"author_name\" => \"Jason\" }  -- Implemented by ActiveModel::Access#slice.  :method: values_at  :call-seq: values_at(*methods)  Returns an array of the values returned by the given methods.  topic = Topic.new(title: \"Budget\", author_name: \"Jason\") topic.values_at(:title, :author_name) # => [\"Budget\", \"Jason\"]  -- Implemented by ActiveModel::Access#values_at. Returns true if +comparison_object+ is the same exact object, or +comparison_object+ is of the same type and +self+ has an ID and it is equal to +comparison_object.id+.  Note that new records are different from any other record by definition, unless the other record is the receiver itself. Besides, if you fetch existing records with +select+ and leave the ID out, you're on your own, this predicate will return false.  Note also that destroying a record preserves its ID in the model instance, so deleted models are still comparable.",
    "label": "",
    "id": "1405"
  },
  {
    "raw_code": "def hash\n      id = self.id\n\n      if self.class.composite_primary_key? ? primary_key_values_present? : id\n        self.class.hash ^ id.hash\n      else\n        super\n      end",
    "comment": "Delegates to id in order to allow two records of the same type and id to work with something like: [ Person.find(1), Person.find(2), Person.find(3) ] & [ Person.find(1), Person.find(4) ] # => [ Person.find(1) ]",
    "label": "",
    "id": "1406"
  },
  {
    "raw_code": "def freeze\n      @attributes = @attributes.clone.freeze\n      self\n    end",
    "comment": "Clone and freeze the attributes hash such that associations are still accessible, even on destroyed records, but cloned models will not be frozen.",
    "label": "",
    "id": "1407"
  },
  {
    "raw_code": "def frozen?\n      @attributes.frozen?\n    end",
    "comment": "Returns +true+ if the attributes hash has been frozen.",
    "label": "",
    "id": "1408"
  },
  {
    "raw_code": "def <=>(other_object)\n      if other_object.is_a?(self.class)\n        to_key <=> other_object.to_key\n      else\n        super\n      end",
    "comment": "Allows sort on objects",
    "label": "",
    "id": "1409"
  },
  {
    "raw_code": "def readonly?\n      @readonly\n    end",
    "comment": "Returns +true+ if the record is read only.",
    "label": "",
    "id": "1410"
  },
  {
    "raw_code": "def strict_loading?\n      @strict_loading\n    end",
    "comment": "Returns +true+ if the record is in strict_loading mode.",
    "label": "",
    "id": "1411"
  },
  {
    "raw_code": "def strict_loading!(value = true, mode: :all)\n      unless [:all, :n_plus_one_only].include?(mode)\n        raise ArgumentError, \"The :mode option must be one of [:all, :n_plus_one_only] but #{mode.inspect} was provided.\"\n      end",
    "comment": "Sets the record to strict_loading mode. This will raise an error if the record tries to lazily load an association.  NOTE: Strict loading is disabled during validation in order to let the record validate its association.  user = User.first user.strict_loading! # => true user.address.city # => ActiveRecord::StrictLoadingViolationError user.comments.to_a # => ActiveRecord::StrictLoadingViolationError  ==== Parameters  * +value+ - Boolean specifying whether to enable or disable strict loading. * <tt>:mode</tt> - Symbol specifying strict loading mode. Defaults to :all. Using :n_plus_one_only mode will only raise an error if an association that will lead to an n plus one query is lazily loaded.  ==== Examples  user = User.first user.strict_loading!(false) # => false user.address.city # => \"Tatooine\" user.comments.to_a # => [#<Comment:0x00...]  user.strict_loading!(mode: :n_plus_one_only) user.address.city # => \"Tatooine\" user.comments.to_a # => [#<Comment:0x00...] user.comments.first.ratings.to_a # => ActiveRecord::StrictLoadingViolationError",
    "label": "",
    "id": "1412"
  },
  {
    "raw_code": "def strict_loading_n_plus_one_only?\n      @strict_loading_mode == :n_plus_one_only\n    end",
    "comment": "Returns +true+ if the record uses strict_loading with +:n_plus_one_only+ mode enabled.",
    "label": "",
    "id": "1413"
  },
  {
    "raw_code": "def strict_loading_all?\n      @strict_loading_mode == :all\n    end",
    "comment": "Returns +true+ if the record uses strict_loading with +:all+ mode enabled.",
    "label": "",
    "id": "1414"
  },
  {
    "raw_code": "def readonly!\n      @readonly = true\n    end",
    "comment": "Prevents records from being written to the database:  customer = Customer.new customer.readonly! customer.save # raises ActiveRecord::ReadOnlyRecord  customer = Customer.first customer.readonly! customer.update(name: 'New Name') # raises ActiveRecord::ReadOnlyRecord  Read-only records cannot be deleted from the database either:  customer = Customer.first customer.readonly! customer.destroy # raises ActiveRecord::ReadOnlyRecord  Please, note that the objects themselves are still mutable in memory:  customer = Customer.new customer.readonly! customer.name = 'New Name' # OK  but you won't be able to persist the changes.",
    "label": "",
    "id": "1415"
  },
  {
    "raw_code": "def inspect\n      inspect_with_attributes(attributes_for_inspect)\n    end",
    "comment": "Returns the attributes of the record as a nicely formatted string.  Post.first.inspect #=> \"#<Post id: 1, title: \"Hello, World!\", published_at: \"2023-10-23 14:28:11 +0000\">\"  The attributes can be limited by setting <tt>.attributes_for_inspect</tt>.  Post.attributes_for_inspect = [:id, :title] Post.first.inspect #=> \"#<Post id: 1, title: \"Hello, World!\">\"",
    "label": "",
    "id": "1416"
  },
  {
    "raw_code": "def full_inspect\n      inspect_with_attributes(all_attributes_for_inspect)\n    end",
    "comment": "Returns all attributes of the record as a nicely formatted string, ignoring <tt>.attributes_for_inspect</tt>.  Post.first.full_inspect #=> \"#<Post id: 1, title: \"Hello, World!\", published_at: \"2023-10-23 14:28:11 +0000\">\" ",
    "label": "",
    "id": "1417"
  },
  {
    "raw_code": "def pretty_print(pp)\n      return super if custom_inspect_method_defined?\n      pp.object_address_group(self) do\n        if @attributes\n          attr_names = attributes_for_inspect.select { |name| _has_attribute?(name.to_s) }\n          pp.seplist(attr_names, proc { pp.text \",\" }) do |attr_name|\n            attr_name = attr_name.to_s\n            pp.breakable \" \"\n            pp.group(1) do\n              pp.text attr_name\n              pp.text \":\"\n              pp.breakable\n              value = attribute_for_inspect(attr_name)\n              pp.text value\n            end",
    "comment": "Takes a PP and prettily prints this record to it, allowing you to get a nice result from <tt>pp record</tt> when pp is required.",
    "label": "",
    "id": "1418"
  },
  {
    "raw_code": "def to_ary\n        nil\n      end",
    "comment": "+Array#flatten+ will call +#to_ary+ (recursively) on each of the elements of the array, and then rescues from the possible +NoMethodError+. If those elements are +ActiveRecord::Base+'s, then this triggers the various +method_missing+'s that we have, which significantly impacts upon performance.  So we can avoid the +method_missing+ hit by explicitly defining +#to_ary+ as +nil+ here.  See also https://tenderlovemaking.com/2011/06/28/til-its-ok-to-return-nil-from-to_ary.html",
    "label": "",
    "id": "1419"
  },
  {
    "raw_code": "def reset_counters(id, *counters, touch: nil)\n        ids = if composite_primary_key?\n          if id.first.is_a?(Array)\n            id\n          else\n            [id]\n          end",
    "comment": "Resets one or more counter caches to their correct value using an SQL count query. This is useful when adding new counter caches, or if the counter has been corrupted or modified directly by SQL.  ==== Parameters  * +id+ - The id of the object you wish to reset a counter on or an array of ids. * +counters+ - One or more association counters to reset. Association name or counter name can be given. * <tt>:touch</tt> - Touch timestamp columns when updating. Pass +true+ to touch +updated_at+ and/or +updated_on+. Pass a symbol to touch that column or an array of symbols to touch just those ones.  ==== Examples  # For the Post with id #1, reset the comments_count Post.reset_counters(1, :comments)  # For posts with ids #1 and #2, reset the comments_count Post.reset_counters([1, 2], :comments)  # Like above, but also touch the updated_at and/or updated_on # attributes. Post.reset_counters(1, :comments, touch: true)",
    "label": "",
    "id": "1420"
  },
  {
    "raw_code": "def update_counters(id, counters)\n        id = [id] if composite_primary_key? && id.is_a?(Array) && !id[0].is_a?(Array)\n        unscoped.where!(primary_key => id).update_counters(counters)\n      end",
    "comment": "A generic \"counter updater\" implementation, intended primarily to be used by #increment_counter and #decrement_counter, but which may also be useful on its own. It simply does a direct SQL update for the record with the given ID, altering the given hash of counters by the amount given by the corresponding value:  ==== Parameters  * +id+ - The id of the object you wish to update a counter on or an array of ids. * +counters+ - A Hash containing the names of the fields to update as keys and the amount to update the field by as values. * <tt>:touch</tt> option - Touch timestamp columns when updating. If attribute names are passed, they are updated along with updated_at/on attributes.  ==== Examples  # For the Post with id of 5, decrement the comments_count by 1, and # increment the actions_count by 1 Post.update_counters 5, comments_count: -1, actions_count: 1 # Executes the following SQL: # UPDATE posts #    SET comments_count = COALESCE(comments_count, 0) - 1, #        actions_count = COALESCE(actions_count, 0) + 1 #  WHERE id = 5  # For the Posts with id of 10 and 15, increment the comments_count by 1 Post.update_counters [10, 15], comments_count: 1 # Executes the following SQL: # UPDATE posts #    SET comments_count = COALESCE(comments_count, 0) + 1 #  WHERE id IN (10, 15)  # For the Posts with id of 10 and 15, increment the comments_count by 1 # and update the updated_at value for each counter. Post.update_counters [10, 15], comments_count: 1, touch: true # Executes the following SQL: # UPDATE posts #    SET comments_count = COALESCE(comments_count, 0) + 1, #    `updated_at` = '2016-10-13T09:59:23-05:00' #  WHERE id IN (10, 15)",
    "label": "",
    "id": "1421"
  },
  {
    "raw_code": "def increment_counter(counter_name, id, by: 1, touch: nil)\n        update_counters(id, counter_name => by, touch: touch)\n      end",
    "comment": "Increment a numeric field by one, via a direct SQL update.  This method is used primarily for maintaining counter_cache columns that are used to store aggregate values. For example, a +DiscussionBoard+ may cache posts_count and comments_count to avoid running an SQL query to calculate the number of posts and comments there are, each time it is displayed.  ==== Parameters  * +counter_name+ - The name of the field that should be incremented. * +id+ - The id of the object that should be incremented or an array of ids. * <tt>:by</tt> - The amount by which to increment the value. Defaults to +1+. * <tt>:touch</tt> - Touch timestamp columns when updating. Pass +true+ to touch +updated_at+ and/or +updated_on+. Pass a symbol to touch that column or an array of symbols to touch just those ones.  ==== Examples  # Increment the posts_count column for the record with an id of 5 DiscussionBoard.increment_counter(:posts_count, 5)  # Increment the posts_count column for the record with an id of 5 # by a specific amount. DiscussionBoard.increment_counter(:posts_count, 5, by: 3)  # Increment the posts_count column for the record with an id of 5 # and update the updated_at value. DiscussionBoard.increment_counter(:posts_count, 5, touch: true)",
    "label": "",
    "id": "1422"
  },
  {
    "raw_code": "def decrement_counter(counter_name, id, by: 1, touch: nil)\n        update_counters(id, counter_name => -by, touch: touch)\n      end",
    "comment": "Decrement a numeric field by one, via a direct SQL update.  This works the same as #increment_counter but reduces the column value by 1 instead of increasing it.  ==== Parameters  * +counter_name+ - The name of the field that should be decremented. * +id+ - The id of the object that should be decremented or an array of ids. * <tt>:by</tt> - The amount by which to decrement the value. Defaults to +1+. * <tt>:touch</tt> - Touch timestamp columns when updating. Pass +true+ to touch +updated_at+ and/or +updated_on+. Pass a symbol to touch that column or an array of symbols to touch just those ones.  ==== Examples  # Decrement the posts_count column for the record with an id of 5 DiscussionBoard.decrement_counter(:posts_count, 5)  # Decrement the posts_count column for the record with an id of 5 by a specific amount. DiscussionBoard.decrement_counter(:posts_count, 5, by: 3)  # Decrement the posts_count column for the record with an id of 5 # and update the updated_at value. DiscussionBoard.decrement_counter(:posts_count, 5, touch: true)",
    "label": "",
    "id": "1423"
  },
  {
    "raw_code": "def self.register_db_config_handler(&block)\n      db_config_handlers << block\n    end",
    "comment": "Allows an application to register a custom handler for database configuration objects. This is useful for creating a custom handler that responds to methods your application needs but Active Record doesn't implement. For example if you are using Vitess, you may want your Vitess configurations to respond to `sharded?`. To implement this define the following in an initializer:  ActiveSupport.on_load(:active_record_database_configurations) do ActiveRecord::DatabaseConfigurations.register_db_config_handler do |env_name, name, url, config| next unless config.key?(:vitess) VitessConfig.new(env_name, name, config) end end  Note: applications must handle the condition in which custom config should be created in your handler registration otherwise all objects will use the custom handler.  Then define your +VitessConfig+ to respond to the methods your application needs. It is recommended that you inherit from one of the existing database config classes to avoid having to reimplement all methods. Custom config handlers should only implement methods Active Record does not.  class VitessConfig < ActiveRecord::DatabaseConfigurations::UrlConfig def sharded? configuration_hash.fetch(\"sharded\", false) end end  For configs that have a +:vitess+ key, a +VitessConfig+ object will be created instead of a +UrlConfig+.",
    "label": "",
    "id": "1424"
  },
  {
    "raw_code": "def configs_for(env_name: nil, name: nil, config_key: nil, include_hidden: false)\n      env_name ||= default_env if name\n      configs = env_with_configs(env_name)\n\n      unless include_hidden\n        configs = configs.select do |db_config|\n          db_config.database_tasks?\n        end",
    "comment": "Collects the configs for the environment and optionally the specification name passed in. To include replica configurations pass <tt>include_hidden: true</tt>.  If a name is provided a single +DatabaseConfig+ object will be returned, otherwise an array of +DatabaseConfig+ objects will be returned that corresponds with the environment and type requested.  ==== Options  * <tt>env_name:</tt> The environment name. Defaults to +nil+ which will collect configs for all environments. * <tt>name:</tt> The db config name (i.e. primary, animals, etc.). Defaults to +nil+. If no +env_name+ is specified the config for the default env and the passed +name+ will be returned. * <tt>config_key:</tt> Selects configs that contain a particular key in the configuration hash. Useful for selecting configs that use a custom db config handler or finding configs with hashes that contain a particular key. * <tt>include_hidden:</tt> Determines whether to include replicas and configurations hidden by <tt>database_tasks: false</tt> in the returned list. Most of the time we're only iterating over the primary connections (i.e. migrations don't need to run for the write and read connection). Defaults to +false+.",
    "label": "",
    "id": "1425"
  },
  {
    "raw_code": "def find_db_config(env)\n      env = env.to_s\n      configurations.find do |db_config|\n        db_config.for_current_env? && (db_config.env_name == env || db_config.name == env)\n      end || configurations.find do |db_config|\n        db_config.env_name == env\n      end",
    "comment": "Returns a single +DatabaseConfig+ object based on the requested environment.  If the application has multiple databases +find_db_config+ will return the first +DatabaseConfig+ for the environment.",
    "label": "",
    "id": "1426"
  },
  {
    "raw_code": "def primary?(name) # :nodoc:\n      return true if name == \"primary\"\n\n      first_config = find_db_config(default_env)\n      first_config && name == first_config.name\n    end",
    "comment": "A primary configuration is one that is named primary or if there is no primary, the first configuration for an environment will be treated as primary. This is used as the \"default\" configuration and is used when the application needs to treat one configuration differently. For example, when Rails dumps the schema, the primary configuration's schema file will be named `schema.rb` instead of `primary_schema.rb`.",
    "label": "",
    "id": "1427"
  },
  {
    "raw_code": "def empty?\n      configurations.empty?\n    end",
    "comment": "Checks if the application's configurations are empty.",
    "label": "",
    "id": "1428"
  },
  {
    "raw_code": "def resolve(config) # :nodoc:\n      return config if DatabaseConfigurations::DatabaseConfig === config\n\n      case config\n      when Symbol\n        resolve_symbol_connection(config)\n      when Hash, String\n        build_db_config_from_raw_config(default_env, \"primary\", config)\n      else\n        raise TypeError, \"Invalid type for configuration. Expected Symbol, String, or Hash. Got #{config.inspect}\"\n      end",
    "comment": "Returns fully resolved connection, accepts hash, string or symbol. Always returns a DatabaseConfiguration::DatabaseConfig  == Examples  Symbol representing current environment.  DatabaseConfigurations.new(\"production\" => {}).resolve(:production) # => DatabaseConfigurations::HashConfig.new(env_name: \"production\", config: {})  One layer deep hash of connection values.  DatabaseConfigurations.new({}).resolve(\"adapter\" => \"sqlite3\") # => DatabaseConfigurations::HashConfig.new(config: {\"adapter\" => \"sqlite3\"})  Connection URL.  DatabaseConfigurations.new({}).resolve(\"postgresql://localhost/foo\") # => DatabaseConfigurations::UrlConfig.new(config: {\"adapter\" => \"postgresql\", \"host\" => \"localhost\", \"database\" => \"foo\"})",
    "label": "",
    "id": "1429"
  },
  {
    "raw_code": "def delegated_type(role, types:, **options)\n      belongs_to role, options.delete(:scope), **options, polymorphic: true\n      define_delegated_type_methods role, types: types, options: options\n    end",
    "comment": "Defines this as a class that'll delegate its type for the passed +role+ to the class references in +types+. That'll create a polymorphic +belongs_to+ relationship to that +role+, and it'll add all the delegated type convenience methods:  class Entry < ApplicationRecord delegated_type :entryable, types: %w[ Message Comment ], dependent: :destroy end  @entry.entryable_class # => Message or Comment @entry.entryable_name  # => \"message\" or \"comment\" Entry.messages         # => Entry.where(entryable_type: \"Message\") @entry.message?        # => true when entryable_type == \"Message\" @entry.message         # => returns the message record, when entryable_type == \"Message\", otherwise nil @entry.message_id      # => returns entryable_id, when entryable_type == \"Message\", otherwise nil Entry.comments         # => Entry.where(entryable_type: \"Comment\") @entry.comment?        # => true when entryable_type == \"Comment\" @entry.comment         # => returns the comment record, when entryable_type == \"Comment\", otherwise nil @entry.comment_id      # => returns entryable_id, when entryable_type == \"Comment\", otherwise nil  You can also declare namespaced types:  class Entry < ApplicationRecord delegated_type :entryable, types: %w[ Message Comment Access::NoticeMessage ], dependent: :destroy end  Entry.access_notice_messages @entry.access_notice_message @entry.access_notice_message?  ==== Options  The +options+ are passed directly to the +belongs_to+ call, so this is where you declare +dependent+ etc. The following options can be included to specialize the behavior of the delegated type convenience methods.  [+:foreign_key+] Specify the foreign key used for the convenience methods. By default this is guessed to be the passed +role+ with an \"_id\" suffix. So a class that defines a <tt>delegated_type :entryable, types: %w[ Message Comment ]</tt> association will use \"entryable_id\" as the default <tt>:foreign_key</tt>. [+:foreign_type+] Specify the column used to store the associated object's type. By default this is inferred to be the passed +role+ with a \"_type\" suffix. A class that defines a <tt>delegated_type :entryable, types: %w[ Message Comment ]</tt> association will use \"entryable_type\" as the default <tt>:foreign_type</tt>. [+:primary_key+] Specify the method that returns the primary key of associated object used for the convenience methods. By default this is +id+.  Option examples: class Entry < ApplicationRecord delegated_type :entryable, types: %w[ Message Comment ], primary_key: :uuid, foreign_key: :entryable_uuid end  @entry.message_uuid # => returns entryable_uuid, when entryable_type == \"Message\", otherwise nil @entry.comment_uuid # => returns entryable_uuid, when entryable_type == \"Comment\", otherwise nil",
    "label": "",
    "id": "1430"
  },
  {
    "raw_code": "def signature(model, method_name)\n              attribute_names(model, method_name.to_s).map { |name| \"_#{name}\" }.join(\", \")\n            end",
    "comment": "The parameters in the signature may have reserved Ruby words, in order to prevent errors, we start each param name with `_`.",
    "label": "",
    "id": "1431"
  },
  {
    "raw_code": "def attributes_hash(model, method_name)\n              \"{\" + attribute_names(model, method_name).map { |name| \":#{name} => _#{name}\" }.join(\",\") + \"}\"\n            end",
    "comment": "Given that the parameters starts with `_`, the finder needs to use the same parameter name.",
    "label": "",
    "id": "1432"
  },
  {
    "raw_code": "def collecting_queries_for_explain # :nodoc:\n      ExplainRegistry.start\n      yield\n      ExplainRegistry.queries\n    ensure\n      ExplainRegistry.reset\n    end",
    "comment": "Executes the block with the collect flag enabled. Queries are collected asynchronously by the subscriber and returned.",
    "label": "",
    "id": "1433"
  },
  {
    "raw_code": "def exec_explain(queries, options = []) # :nodoc:\n      str = with_connection do |c|\n        queries.map do |sql, binds|\n          msg = +\"#{build_explain_clause(c, options)} #{sql}\"\n          unless binds.empty?\n            msg << \" \"\n            msg << binds.map { |attr| render_bind(c, attr) }.inspect\n          end",
    "comment": "Makes the adapter execute EXPLAIN for the tuples of queries and bindings. Returns a formatted string ready to be logged.",
    "label": "",
    "id": "1434"
  },
  {
    "raw_code": "def str.inspect\n        self\n      end",
    "comment": "Overriding inspect to be more human readable, especially in the console.",
    "label": "",
    "id": "1435"
  },
  {
    "raw_code": "def identify(label, column_type = :integer)\n        if column_type == :uuid\n          Digest::UUID.uuid_v5(Digest::UUID::OID_NAMESPACE, label.to_s)\n        else\n          Zlib.crc32(label.to_s) % MAX_ID\n        end",
    "comment": "Returns a consistent, platform-independent identifier for +label+.  \\Integer identifiers are values less than 2^30. UUIDs are RFC 4122 version 5 SHA-1 hashes.",
    "label": "",
    "id": "1436"
  },
  {
    "raw_code": "def composite_identify(label, key)\n        key\n          .index_with\n          .with_index { |sub_key, index| (identify(label) << index) % MAX_ID }\n          .with_indifferent_access\n      end",
    "comment": "Returns a consistent, platform-independent hash representing a mapping between the label and the subcomponents of the provided composite key.  Example:  composite_identify(\"label\", [:a, :b, :c]) # => { a: hash_1, b: hash_2, c: hash_3 }",
    "label": "",
    "id": "1437"
  },
  {
    "raw_code": "def context_class\n        @context_class ||= Class.new\n      end",
    "comment": "Superclass for the evaluation contexts used by \\ERB fixtures.",
    "label": "",
    "id": "1438"
  },
  {
    "raw_code": "def table_rows\n      # allow specifying fixtures to be ignored by setting `ignore` in `_fixture` section\n      fixtures.except!(*ignored_fixtures)\n\n      TableRows.new(\n        table_name,\n        model_class: model_class,\n        fixtures: fixtures,\n      ).to_hash\n    end",
    "comment": "Returns a hash of rows to be inserted. The key is the table, the value is a list of rows to insert to that table.",
    "label": "",
    "id": "1439"
  },
  {
    "raw_code": "def read_fixture_files(path)\n        yaml_files = Dir[\"#{path}{.yml,/{**,*}/*.yml}\"].select { |f|\n          ::File.file?(f)\n        }\n\n        raise ArgumentError, \"No fixture files found for #{@name}\" if yaml_files.empty?\n\n        yaml_files.each_with_object({}) do |file, fixtures|\n          FixtureSet::File.open(file) do |fh|\n            self.model_class ||= fh.model_class if fh.model_class\n            self.model_class ||= default_fixture_model_class\n            self.ignored_fixtures ||= fh.ignored_fixtures\n            fh.each do |fixture_name, row|\n              fixtures[fixture_name] = ActiveRecord::Fixture.new(row, model_class)\n            end",
    "comment": "Loads the fixtures from the YAML file at +path+. If the file sets the +model_class+ and current instance value is not set, it uses the file value.",
    "label": "",
    "id": "1440"
  },
  {
    "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of Active Record as a +Gem::Version+.",
    "label": "",
    "id": "1441"
  },
  {
    "raw_code": "def new(attributes = nil, &block)\n        if abstract_class? || self == Base\n          raise NotImplementedError, \"#{self} is an abstract class and cannot be instantiated.\"\n        end",
    "comment": "Determines if one of the attributes passed in is the inheritance column, and if the inheritance column is attr accessible, it initializes an instance of the given subclass instead of the base class.",
    "label": "",
    "id": "1442"
  },
  {
    "raw_code": "def descends_from_active_record?\n        if self == Base\n          false\n        elsif superclass.abstract_class?\n          superclass.descends_from_active_record?\n        else\n          superclass == Base || !columns_hash.include?(inheritance_column)\n        end",
    "comment": "Returns +true+ if this does not need STI type condition. Returns +false+ if STI type condition needs to be applied.",
    "label": "",
    "id": "1443"
  },
  {
    "raw_code": "def base_class?\n        base_class == self\n      end",
    "comment": "Returns whether the class is a base class. See #base_class for more information.",
    "label": "",
    "id": "1444"
  },
  {
    "raw_code": "def abstract_class?\n        @abstract_class == true\n      end",
    "comment": "Returns whether this class is an abstract class or not.",
    "label": "",
    "id": "1445"
  },
  {
    "raw_code": "def primary_abstract_class\n        if ActiveRecord.application_record_class && ActiveRecord.application_record_class.name != name\n          raise ArgumentError, \"The `primary_abstract_class` is already set to #{ActiveRecord.application_record_class.inspect}. There can only be one `primary_abstract_class` in an application.\"\n        end",
    "comment": "Sets the application record class for Active Record  This is useful if your application uses a different class than ApplicationRecord for your primary abstract class. This class will share a database connection with Active Record. It is the class that connects to your primary database.",
    "label": "",
    "id": "1446"
  },
  {
    "raw_code": "def sti_name\n        store_full_sti_class && store_full_class_name ? name : name.demodulize\n      end",
    "comment": "Returns the value to be stored in the inheritance column for STI.",
    "label": "",
    "id": "1447"
  },
  {
    "raw_code": "def sti_class_for(type_name)\n        if store_full_sti_class && store_full_class_name\n          type_name.constantize\n        else\n          compute_type(type_name)\n        end",
    "comment": "Returns the class for the provided +type_name+.  It is used to find the class correspondent to the value stored in the inheritance column.",
    "label": "",
    "id": "1448"
  },
  {
    "raw_code": "def polymorphic_name\n        store_full_class_name ? base_class.name : base_class.name.demodulize\n      end",
    "comment": "Returns the value to be stored in the polymorphic type column for Polymorphic Associations.",
    "label": "",
    "id": "1449"
  },
  {
    "raw_code": "def polymorphic_class_for(name)\n        if store_full_class_name\n          name.constantize\n        else\n          compute_type(name)\n        end",
    "comment": "Returns the class for the provided +name+.  It is used to find the class correspondent to the value stored in the polymorphic type column.",
    "label": "",
    "id": "1450"
  },
  {
    "raw_code": "def compute_type(type_name)\n          if type_name.start_with?(\"::\")\n            # If the type is prefixed with a scope operator then we assume that\n            # the type_name is an absolute reference.\n            type_name.constantize\n          else\n            type_candidate = @_type_candidates_cache[type_name]\n            if type_candidate && type_constant = type_candidate.safe_constantize\n              return type_constant\n            end",
    "comment": "Returns the class type of the record using the current module as a prefix. So descendants of MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.",
    "label": "",
    "id": "1451"
  },
  {
    "raw_code": "def discriminate_class_for_record(record)\n          if using_single_table_inheritance?(record)\n            find_sti_class(record[inheritance_column])\n          else\n            super\n          end",
    "comment": "Called by +instantiate+ to decide which class to use for a new record instance. For single-table inheritance, we check the record for a +type+ column and return the corresponding class.",
    "label": "",
    "id": "1452"
  },
  {
    "raw_code": "def subclass_from_attributes(attrs)\n          attrs = attrs.to_h if attrs.respond_to?(:permitted?)\n          if attrs.is_a?(Hash)\n            subclass_name = attrs[inheritance_column] || attrs[inheritance_column.to_sym]\n\n            if subclass_name.present?\n              find_sti_class(subclass_name)\n            end",
    "comment": "Detect the subclass from the inheritance column of attrs. If the inheritance column value is not self or a valid subclass, raises ActiveRecord::SubclassNotFound",
    "label": "",
    "id": "1453"
  },
  {
    "raw_code": "def ensure_proper_type\n        klass = self.class\n        if klass.finder_needs_type_condition?\n          _write_attribute(klass.inheritance_column, klass.sti_name)\n        end",
    "comment": "Sets the attribute used for single table inheritance to this class name if this is not the ActiveRecord::Base descendant. Considering the hierarchy Reply < Message < ActiveRecord::Base, this makes it possible to do Reply.new without having to set <tt>Reply[Reply.inheritance_column] = \"Reply\"</tt> yourself. No such attribute would be set for objects of the Message class in that example.",
    "label": "",
    "id": "1454"
  },
  {
    "raw_code": "def keys_including_timestamps\n      @keys_including_timestamps ||= if record_timestamps?\n        keys + model.all_timestamp_attributes_in_model\n      else\n        keys\n      end",
    "comment": "TODO: Consider renaming this method, as it only conditionally extends keys, not always",
    "label": "",
    "id": "1455"
  },
  {
    "raw_code": "def to_param\n      return unless id\n      Array(id).join(self.class.param_delimiter)\n    end",
    "comment": "Returns a +String+, which Action Pack uses for constructing a URL to this object. The default implementation returns this record's id as a +String+, or +nil+ if this record's unsaved.  For example, suppose that you have a User model, and that you have a <tt>resources :users</tt> route. Normally, +user_path+ will construct a path with the user object's 'id' in it:  user = User.find_by(name: 'Phusion') user_path(user)  # => \"/users/1\"  You can override +to_param+ in your model to make +user_path+ construct a path using the user's name instead of the user's id:  class User < ActiveRecord::Base def to_param  # overridden name end end  user = User.find_by(name: 'Phusion') user_path(user)  # => \"/users/Phusion\"",
    "label": "",
    "id": "1456"
  },
  {
    "raw_code": "def cache_key\n      if new_record?\n        \"#{model_name.cache_key}/new\"\n      else\n        if cache_version\n          \"#{model_name.cache_key}/#{id}\"\n        else\n          timestamp = max_updated_column_timestamp\n\n          if timestamp\n            timestamp = timestamp.utc.to_fs(cache_timestamp_format)\n            \"#{model_name.cache_key}/#{id}-#{timestamp}\"\n          else\n            \"#{model_name.cache_key}/#{id}\"\n          end",
    "comment": "Returns a stable cache key that can be used to identify this record.  Product.new.cache_key     # => \"products/new\" Product.find(5).cache_key # => \"products/5\"  If ActiveRecord::Base.cache_versioning is turned off, as it was in \\Rails 5.1 and earlier, the cache key will also include a version.  Product.cache_versioning = false Product.find(5).cache_key  # => \"products/5-20071224150000\" (updated_at available)",
    "label": "",
    "id": "1457"
  },
  {
    "raw_code": "def cache_version\n      return unless cache_versioning\n\n      if has_attribute?(\"updated_at\")\n        timestamp = updated_at_before_type_cast\n        if can_use_fast_cache_version?(timestamp)\n          raw_timestamp_to_cache_version(timestamp)\n\n        elsif timestamp = updated_at\n          timestamp.utc.to_fs(cache_timestamp_format)\n        end",
    "comment": "Returns a cache version that can be used together with the cache key to form a recyclable caching scheme. By default, the #updated_at column is used for the cache_version, but this method can be overwritten to return something else.  Note, this method will return nil if ActiveRecord::Base.cache_versioning is set to +false+.",
    "label": "",
    "id": "1458"
  },
  {
    "raw_code": "def cache_key_with_version\n      if version = cache_version\n        \"#{cache_key}-#{version}\"\n      else\n        cache_key\n      end",
    "comment": "Returns a cache key along with the version.",
    "label": "",
    "id": "1459"
  },
  {
    "raw_code": "def to_param(method_name = nil)\n        if method_name.nil?\n          super()\n        else\n          define_method :to_param do\n            if (default = super()) &&\n                 (result = send(method_name).to_s).present? &&\n                   (param = result.squish.parameterize.truncate(20, separator: /-/, omission: \"\")).present?\n              \"#{default}-#{param}\"\n            else\n              default\n            end",
    "comment": "Defines your model's +to_param+ method to generate \"pretty\" URLs using +method_name+, which can be any attribute or method that responds to +to_s+.  class User < ActiveRecord::Base to_param :name end  user = User.find_by(name: 'Fancy Pants') user.id         # => 123 user_path(user) # => \"/users/123-fancy-pants\"  Values longer than 20 characters will be truncated. The value is truncated word by word.  user = User.find_by(name: 'David Heinemeier Hansson') user.id         # => 125 user_path(user) # => \"/users/125-david-heinemeier\"  Because the generated param begins with the record's +id+, it is suitable for passing to +find+. In a controller, for example:  params[:id]               # => \"123-fancy-pants\" User.find(params[:id]).id # => 123",
    "label": "",
    "id": "1460"
  },
  {
    "raw_code": "def can_use_fast_cache_version?(timestamp)\n        timestamp.is_a?(String) &&\n          cache_timestamp_format == :usec &&\n          # FIXME: checking out a connection for this is wasteful\n          # we should store/cache this information in the schema cache\n          # or similar.\n          self.class.with_connection(&:default_timezone) == :utc &&\n          !updated_at_came_from_user?\n      end",
    "comment": "Detects if the value before type cast can be used to generate a cache_version.  The fast cache version only works with a string value directly from the database.  We also must check if the timestamp format has been changed or if the timezone is not set to UTC then we cannot apply our transformations correctly.",
    "label": "",
    "id": "1461"
  },
  {
    "raw_code": "def raw_timestamp_to_cache_version(timestamp)\n        key = timestamp.delete(\"- :.\")\n        if key.length < 20\n          key.ljust(20, \"0\")\n        else\n          key\n        end",
    "comment": "Converts a raw database string to `:usec` format.  Example:  timestamp = \"2018-10-15 20:02:15.266505\" raw_timestamp_to_cache_version(timestamp) # => \"20181015200215266505\"  PostgreSQL truncates trailing zeros, https://github.com/postgres/postgres/commit/3e1beda2cde3495f41290e1ece5d544525810214 to account for this we pad the output with zeros",
    "label": "",
    "id": "1462"
  },
  {
    "raw_code": "def create_table\n      return unless enabled?\n\n      @pool.with_connection do |connection|\n        unless connection.table_exists?(table_name)\n          connection.create_table(table_name, id: false) do |t|\n            t.string :key, **connection.internal_string_options_for_primary_key\n            t.string :value\n            t.timestamps\n          end",
    "comment": "Creates an internal metadata table with columns +key+ and +value+",
    "label": "",
    "id": "1463"
  },
  {
    "raw_code": "def check_all_pending!\n        pending_migrations = []\n\n        ActiveRecord::Tasks::DatabaseTasks.with_temporary_pool_for_each(env: env) do |pool|\n          if pending = pool.migration_context.open.pending_migrations\n            pending_migrations << pending\n          end",
    "comment": "Raises ActiveRecord::PendingMigrationError error if any migrations are pending for all database configurations in an environment.",
    "label": "",
    "id": "1464"
  },
  {
    "raw_code": "def disable_ddl_transaction!\n        @disable_ddl_transaction = true\n      end",
    "comment": "Disable the transaction wrapping this migration. You can still create your own transactions even after calling #disable_ddl_transaction!  For more details read the {\"Transactional Migrations\" section above}[rdoc-ref:Migration].",
    "label": "",
    "id": "1465"
  },
  {
    "raw_code": "def revert(*migration_classes, &block)\n      run(*migration_classes.reverse, revert: true) unless migration_classes.empty?\n      if block_given?\n        if connection.respond_to? :revert\n          connection.revert(&block)\n        else\n          recorder = command_recorder\n          @connection = recorder\n          suppress_messages do\n            connection.revert(&block)\n          end",
    "comment": "Reverses the migration commands for the given block and the given migrations.  The following migration will remove the table 'horses' and create the table 'apples' on the way up, and the reverse on the way down.  class FixTLMigration < ActiveRecord::Migration[8.1] def change revert do create_table(:horses) do |t| t.text :content t.datetime :remind_at end end create_table(:apples) do |t| t.string :variety end end end  Or equivalently, if +TenderloveMigration+ is defined as in the documentation for Migration:  require_relative \"20121212123456_tenderlove_migration\"  class FixupTLMigration < ActiveRecord::Migration[8.1] def change revert TenderloveMigration  create_table(:apples) do |t| t.string :variety end end end  This command can be nested.",
    "label": "",
    "id": "1466"
  },
  {
    "raw_code": "def reversible\n      helper = ReversibleBlockHelper.new(reverting?)\n      execute_block { yield helper }\n    end",
    "comment": "Used to specify an operation that can be run in one direction or another. Call the methods +up+ and +down+ of the yielded object to run a block only in one given direction. The whole block will be called in the right order within the migration.  In the following example, the looping on users will always be done when the three columns 'first_name', 'last_name' and 'full_name' exist, even when migrating down:  class SplitNameMigration < ActiveRecord::Migration[8.1] def change add_column :users, :first_name, :string add_column :users, :last_name, :string  reversible do |dir| User.reset_column_information User.all.each do |u| dir.up   { u.first_name, u.last_name = u.full_name.split(' ') } dir.down { u.full_name = \"#{u.first_name} #{u.last_name}\" } u.save end end  revert { add_column :users, :full_name, :string } end end",
    "label": "",
    "id": "1467"
  },
  {
    "raw_code": "def up_only(&block)\n      execute_block(&block) unless reverting?\n    end",
    "comment": "Used to specify an operation that is only run when migrating up (for example, populating a new column with its initial values).  In the following example, the new column +published+ will be given the value +true+ for all existing records.  class AddPublishedToPosts < ActiveRecord::Migration[8.1] def change add_column :posts, :published, :boolean, default: false up_only do execute \"update posts set published = 'true'\" end end end",
    "label": "",
    "id": "1468"
  },
  {
    "raw_code": "def run(*migration_classes)\n      opts = migration_classes.extract_options!\n      dir = opts[:direction] || :up\n      dir = (dir == :down ? :up : :down) if opts[:revert]\n      if reverting?\n        # If in revert and going :up, say, we want to execute :down without reverting, so\n        revert { run(*migration_classes, direction: dir, revert: true) }\n      else\n        migration_classes.each do |migration_class|\n          migration_class.new.exec_migration(connection, dir)\n        end",
    "comment": "Runs the given migration classes. Last argument can specify options:  - +:direction+ - Default is +:up+. - +:revert+ - Default is +false+.",
    "label": "",
    "id": "1469"
  },
  {
    "raw_code": "def migrate(direction)\n      return unless respond_to?(direction)\n\n      case direction\n      when :up   then announce \"migrating\"\n      when :down then announce \"reverting\"\n      end",
    "comment": "Execute this migration in the named direction",
    "label": "",
    "id": "1470"
  },
  {
    "raw_code": "def say(message, subitem = false)\n      write \"#{subitem ? \"   ->\" : \"--\"} #{message}\"\n    end",
    "comment": "Takes a message argument and outputs it as is. A second boolean argument can be passed to specify whether to indent or not.",
    "label": "",
    "id": "1471"
  },
  {
    "raw_code": "def say_with_time(message)\n      say(message)\n      result = nil\n      time_elapsed = ActiveSupport::Benchmark.realtime { result = yield }\n      say \"%.4fs\" % time_elapsed, :subitem\n      say(\"#{result} rows\", :subitem) if result.is_a?(Integer)\n      result\n    end",
    "comment": "Outputs text along with how long it took to run its block. If the block returns an integer it assumes it is the number of rows affected.",
    "label": "",
    "id": "1472"
  },
  {
    "raw_code": "def suppress_messages\n      save, self.verbose = verbose, false\n      yield\n    ensure\n      self.verbose = save\n    end",
    "comment": "Takes a block as an argument and suppresses any output generated by the block.",
    "label": "",
    "id": "1473"
  },
  {
    "raw_code": "def proper_table_name(name, options = {})\n      if name.respond_to? :table_name\n        name.table_name\n      else\n        \"#{options[:table_name_prefix]}#{name}#{options[:table_name_suffix]}\"\n      end",
    "comment": "Finds the correct table name given an Active Record object. Uses the Active Record object's own table_name, or pre/suffix from the options passed in.",
    "label": "",
    "id": "1474"
  },
  {
    "raw_code": "def next_migration_number(number)\n      if ActiveRecord.timestamped_migrations\n        [Time.now.utc.strftime(\"%Y%m%d%H%M%S\"), \"%.14d\" % number].max\n      else\n        \"%.3d\" % number.to_i\n      end",
    "comment": "Determines the version number of the next migration.",
    "label": "",
    "id": "1475"
  },
  {
    "raw_code": "def table_name_options(config = ActiveRecord::Base) # :nodoc:\n      {\n        table_name_prefix: config.table_name_prefix,\n        table_name_suffix: config.table_name_suffix\n      }\n    end",
    "comment": "Builds a hash for use in ActiveRecord::Migration#proper_table_name using the Active Record object's table_name prefix and suffix",
    "label": "",
    "id": "1476"
  },
  {
    "raw_code": "def migrate(target_version = nil, &block)\n      case\n      when target_version.nil?\n        up(target_version, &block)\n      when current_version == 0 && target_version == 0\n        []\n      when current_version > target_version\n        down(target_version, &block)\n      else\n        up(target_version, &block)\n      end",
    "comment": "Runs the migrations in the +migrations_path+.  If +target_version+ is +nil+, +migrate+ will run +up+.  If the +current_version+ and +target_version+ are both 0 then an empty array will be returned and no migrations will be run.  If the +current_version+ in the schema is greater than the +target_version+, then +down+ will be run.  If none of the conditions are met, +up+ will be run with the +target_version+.",
    "label": "",
    "id": "1477"
  },
  {
    "raw_code": "def current_version\n        connection_pool = ActiveRecord::Tasks::DatabaseTasks.migration_connection_pool\n        schema_migration = SchemaMigration.new(connection_pool)\n        internal_metadata = InternalMetadata.new(connection_pool)\n\n        MigrationContext.new(migrations_paths, schema_migration, internal_metadata).current_version\n      end",
    "comment": "For cases where a table doesn't exist like loading from schema cache",
    "label": "",
    "id": "1478"
  },
  {
    "raw_code": "def run_without_lock\n        migration = migrations.detect { |m| m.version == @target_version }\n        raise UnknownMigrationVersionError.new(@target_version) if migration.nil?\n\n        record_environment\n        execute_migration_in_transaction(migration)\n      end",
    "comment": "Used for running a specific migration.",
    "label": "",
    "id": "1479"
  },
  {
    "raw_code": "def migrate_without_lock\n        if invalid_target?\n          raise UnknownMigrationVersionError.new(@target_version)\n        end",
    "comment": "Used for running multiple migrations up to or down to a certain value.",
    "label": "",
    "id": "1480"
  },
  {
    "raw_code": "def record_environment\n        return if down?\n\n        @internal_metadata[:environment] = connection.pool.db_config.env_name\n      end",
    "comment": "Stores the current environment in the database.",
    "label": "",
    "id": "1481"
  },
  {
    "raw_code": "def invalid_target?\n        @target_version && @target_version != 0 && !target\n      end",
    "comment": "Return true if a valid version is not provided.",
    "label": "",
    "id": "1482"
  },
  {
    "raw_code": "def ddl_transaction(migration, &block)\n        if use_transaction?(migration)\n          connection.transaction(&block)\n        else\n          yield\n        end",
    "comment": "Wrap the migration in a transaction only if supported by the adapter.",
    "label": "",
    "id": "1483"
  },
  {
    "raw_code": "def self.derive_join_table_name(first_table, second_table) # :nodoc:\n      [first_table.to_s, second_table.to_s].sort.join(\"\\0\").gsub(/^(.*[_.])(.+)\\0\\1(.+)/, '\\1\\2_\\3').tr(\"\\0\", \"_\")\n    end",
    "comment": "Derives the join table name for +first_table+ and +second_table+. The table names appear in alphabetical order. A common prefix is removed (useful for namespaced models like Music::Artist and Music::Record):  artists, records => artists_records records, artists => artists_records music_artists, music_records => music_artists_records music.artists, music.records => music.artists_records",
    "label": "",
    "id": "1484"
  },
  {
    "raw_code": "def table_name\n        reset_table_name unless defined?(@table_name)\n        @table_name\n      end",
    "comment": "Guesses the table name (in forced lower-case) based on the name of the class in the inheritance hierarchy descending directly from ActiveRecord::Base. So if the hierarchy looks like: Reply < Message < ActiveRecord::Base, then Message is used to guess the table name even when called on Reply. The rules used to do the guess are handled by the Inflector class in Active Support, which knows almost all common English inflections. You can add new inflections in config/initializers/inflections.rb.  Nested classes are given table names prefixed by the singular form of the parent's table name. Enclosing modules are not considered.  ==== Examples  class Invoice < ActiveRecord::Base end  file                  class               table_name invoice.rb            Invoice             invoices  class Invoice < ActiveRecord::Base class Lineitem < ActiveRecord::Base end end  file                  class               table_name invoice.rb            Invoice::Lineitem   invoice_lineitems  module Invoice class Lineitem < ActiveRecord::Base end end  file                  class               table_name invoice/lineitem.rb   Invoice::Lineitem   lineitems  Additionally, the class-level +table_name_prefix+ is prepended and the +table_name_suffix+ is appended. So if you have \"myapp_\" as a prefix, the table name guess for an Invoice class becomes \"myapp_invoices\". Invoice::Lineitem becomes \"myapp_invoice_lineitems\".  Active Model Naming's +model_name+ is the base name used to guess the table name. In case a custom Active Model Name is defined, it will be used for the table name as well:  class PostRecord < ActiveRecord::Base class << self def model_name ActiveModel::Name.new(self, nil, \"Post\") end end end  PostRecord.table_name # => \"posts\"  You can also set your own table name explicitly:  class Mouse < ActiveRecord::Base self.table_name = \"mice\" end",
    "label": "",
    "id": "1485"
  },
  {
    "raw_code": "def table_name=(value)\n        value = value && value.to_s\n\n        if defined?(@table_name)\n          return if value == @table_name\n          reset_column_information if connected?\n        end",
    "comment": "Sets the table name explicitly. Example:  class Project < ActiveRecord::Base self.table_name = \"project\" end",
    "label": "",
    "id": "1486"
  },
  {
    "raw_code": "def quoted_table_name\n        adapter_class.quote_table_name(table_name)\n      end",
    "comment": "Returns a quoted version of the table name.",
    "label": "",
    "id": "1487"
  },
  {
    "raw_code": "def reset_table_name # :nodoc:\n        self.table_name = if self == Base\n          nil\n        elsif abstract_class?\n          superclass.table_name\n        elsif superclass.abstract_class?\n          superclass.table_name || compute_table_name\n        else\n          compute_table_name\n        end",
    "comment": "Computes the table name, (re)sets it internally, and returns it.",
    "label": "",
    "id": "1488"
  },
  {
    "raw_code": "def protected_environments\n        if defined?(@protected_environments)\n          @protected_environments\n        else\n          superclass.protected_environments\n        end",
    "comment": "The array of names of environments where destructive actions should be prohibited. By default, the value is <tt>[\"production\"]</tt>.",
    "label": "",
    "id": "1489"
  },
  {
    "raw_code": "def protected_environments=(environments)\n        @protected_environments = environments.map(&:to_s)\n      end",
    "comment": "Sets an array of names of environments where destructive actions should be prohibited.",
    "label": "",
    "id": "1490"
  },
  {
    "raw_code": "def ignored_columns\n        @ignored_columns || superclass.ignored_columns\n      end",
    "comment": "The list of columns names the model should ignore. Ignored columns won't have attribute accessors defined, and won't be referenced in SQL queries.",
    "label": "",
    "id": "1491"
  },
  {
    "raw_code": "def only_columns\n        @only_columns || superclass.only_columns\n      end",
    "comment": "The list of columns names the model should allow. Only columns are used to define attribute accessors, and are referenced in SQL queries.",
    "label": "",
    "id": "1492"
  },
  {
    "raw_code": "def ignored_columns=(columns)\n        check_model_columns(@only_columns.present?)\n        reload_schema_from_cache\n        @ignored_columns = columns.map(&:to_s).freeze\n      end",
    "comment": "Sets the columns names the model should ignore. Ignored columns won't have attribute accessors defined, and won't be referenced in SQL queries.  A common usage pattern for this method is to ensure all references to an attribute have been removed and deployed, before a migration to drop the column from the database has been deployed and run. Using this two step approach to dropping columns ensures there is no code that raises errors due to having a cached schema in memory at the time the schema migration is run.  For example, given a model where you want to drop the \"category\" attribute, first mark it as ignored:  class Project < ActiveRecord::Base # schema: #   id         :bigint #   name       :string, limit: 255 #   category   :string, limit: 255  self.ignored_columns += [:category] end  The schema still contains \"category\", but now the model omits it, so any meta-driven code or schema caching will not attempt to use the column:  Project.columns_hash[\"category\"] => nil  You will get an error if accessing that attribute directly, so ensure all usages of the column are removed (automated tests can help you find any usages).  user = Project.create!(name: \"First Project\") user.category # => raises NoMethodError",
    "label": "",
    "id": "1493"
  },
  {
    "raw_code": "def sequence_name=(value)\n        @sequence_name          = value.to_s\n        @explicit_sequence_name = true\n      end",
    "comment": "Sets the name of the sequence to use when generating ids to the given value, or (if the value is +nil+ or +false+) to the value returned by the given block. This is required for Oracle and is useful for any database which relies on sequences for primary key generation.  If a sequence name is not explicitly set when using Oracle, it will default to the commonly used pattern of: #{table_name}_seq  If a sequence name is not explicitly set when using PostgreSQL, it will discover the sequence corresponding to your primary key for you.  class Project < ActiveRecord::Base self.sequence_name = \"projectseq\"   # default would have been \"project_seq\" end",
    "label": "",
    "id": "1494"
  },
  {
    "raw_code": "def prefetch_primary_key?\n        with_connection { |c| c.prefetch_primary_key?(table_name) }\n      end",
    "comment": "Determines if the primary key values should be selected from their corresponding sequence before the insert statement.",
    "label": "",
    "id": "1495"
  },
  {
    "raw_code": "def next_sequence_value\n        with_connection { |c| c.next_sequence_value(sequence_name) }\n      end",
    "comment": "Returns the next value that will be used as the primary key on an insert statement.",
    "label": "",
    "id": "1496"
  },
  {
    "raw_code": "def table_exists?\n        schema_cache.data_source_exists?(table_name)\n      end",
    "comment": "Indicates whether the table associated with this class exists",
    "label": "",
    "id": "1497"
  },
  {
    "raw_code": "def column_for_attribute(name)\n        name = name.to_s\n        columns_hash.fetch(name) do\n          ConnectionAdapters::NullColumn.new(name)\n        end",
    "comment": "Returns the column object for the named attribute. Returns an ActiveRecord::ConnectionAdapters::NullColumn if the named attribute does not exist.  class Person < ActiveRecord::Base end  person = Person.new person.column_for_attribute(:name) # the result depends on the ConnectionAdapter # => #<ActiveRecord::ConnectionAdapters::Column:0x007ff4ab083980 @name=\"name\", @sql_type=\"varchar(255)\", @null=true, ...>  person.column_for_attribute(:nothing) # => #<ActiveRecord::ConnectionAdapters::NullColumn:0xXXX @name=nil, @sql_type=nil, @cast_type=#<Type::Value>, ...>",
    "label": "",
    "id": "1498"
  },
  {
    "raw_code": "def column_defaults\n        load_schema\n        @column_defaults ||= _default_attributes.deep_dup.to_hash.freeze\n      end",
    "comment": "Returns a hash where the keys are column names and the values are default values when instantiating the Active Record object for this table.",
    "label": "",
    "id": "1499"
  },
  {
    "raw_code": "def column_names\n        @column_names ||= columns.map(&:name).freeze\n      end",
    "comment": "Returns an array of column names as strings.",
    "label": "",
    "id": "1500"
  },
  {
    "raw_code": "def content_columns\n        @content_columns ||= columns.reject do |c|\n          c.name == primary_key ||\n          c.name == inheritance_column ||\n          c.name.end_with?(\"_id\", \"_count\")\n        end.freeze\n      end",
    "comment": "Returns an array of column objects where the primary id, all columns ending in \"_id\" or \"_count\", and columns used for single table inheritance have been removed.",
    "label": "",
    "id": "1501"
  },
  {
    "raw_code": "def reset_column_information\n        connection_pool.active_connection&.clear_cache!\n        ([self] + descendants).each(&:undefine_attribute_methods)\n        schema_cache.clear_data_source_cache!(table_name)\n\n        reload_schema_from_cache\n        initialize_find_by_cache\n      end",
    "comment": "Resets all the cached information about columns, which will cause them to be reloaded on the next request.  The most common usage pattern for this method is probably in a migration, when just after creating a table you want to populate it with some default values, e.g.:  class CreateJobLevels < ActiveRecord::Migration[8.1] def up create_table :job_levels do |t| t.integer :id t.string :name  t.timestamps end  JobLevel.reset_column_information %w{assistant executive manager director}.each do |type| JobLevel.create(name: type) end end  def down drop_table :job_levels end end",
    "label": "",
    "id": "1502"
  },
  {
    "raw_code": "def load_schema\n        return if schema_loaded?\n        @load_schema_monitor.synchronize do\n          return if schema_loaded?\n\n          load_schema!\n\n          @schema_loaded = true\n        rescue\n          reload_schema_from_cache # If the schema loading failed half way through, we must reset the state.\n          raise\n        end",
    "comment": "Load the model's schema information either from the schema cache or directly from the database.",
    "label": "",
    "id": "1503"
  },
  {
    "raw_code": "def undecorated_table_name(model_name)\n          table_name = model_name.to_s.demodulize.underscore\n          pluralize_table_names ? table_name.pluralize : table_name\n        end",
    "comment": "Guesses the table name, but does not decorate it with prefix and suffix information.",
    "label": "",
    "id": "1504"
  },
  {
    "raw_code": "def compute_table_name\n          if base_class?\n            # Nested classes are prefixed with singular parent table name.\n            if module_parent < Base && !module_parent.abstract_class?\n              contained = module_parent.table_name\n              contained = contained.singularize if module_parent.pluralize_table_names\n              contained += \"_\"\n            end",
    "comment": "Computes and returns a table name according to default conventions.",
    "label": "",
    "id": "1505"
  },
  {
    "raw_code": "def accepts_nested_attributes_for(*attr_names)\n        options = { allow_destroy: false, update_only: false }\n        options.update(attr_names.extract_options!)\n        options.assert_valid_keys(:allow_destroy, :reject_if, :limit, :update_only)\n        options[:reject_if] = REJECT_ALL_BLANK_PROC if options[:reject_if] == :all_blank\n\n        attr_names.each do |association_name|\n          if reflection = _reflect_on_association(association_name)\n            reflection.autosave = true\n            define_autosave_validation_callbacks(reflection)\n\n            nested_attributes_options = self.nested_attributes_options.dup\n            nested_attributes_options[association_name.to_sym] = options\n            self.nested_attributes_options = nested_attributes_options\n\n            type = (reflection.collection? ? :collection : :one_to_one)\n            generate_association_writer(association_name, type)\n          else\n            raise ArgumentError, \"No association found for name `#{association_name}'. Has it been defined yet?\"\n          end",
    "comment": "Defines an attributes writer for the specified association(s).  Supported options: [:allow_destroy] If true, destroys any members from the attributes hash with a <tt>_destroy</tt> key and a value that evaluates to +true+ (e.g. 1, '1', true, or 'true'). This option is false by default. [:reject_if] Allows you to specify a Proc or a Symbol pointing to a method that checks whether a record should be built for a certain attribute hash. The hash is passed to the supplied Proc or the method and it should return either +true+ or +false+. When no +:reject_if+ is specified, a record will be built for all attribute hashes that do not have a <tt>_destroy</tt> value that evaluates to true. Passing <tt>:all_blank</tt> instead of a Proc will create a proc that will reject a record where all the attributes are blank excluding any value for +_destroy+. [:limit] Allows you to specify the maximum number of associated records that can be processed with the nested attributes. Limit also can be specified as a Proc or a Symbol pointing to a method that should return a number. If the size of the nested attributes array exceeds the specified limit, NestedAttributes::TooManyRecords exception is raised. If omitted, any number of associations can be processed. Note that the +:limit+ option is only applicable to one-to-many associations. [:update_only] For a one-to-one association, this option allows you to specify how nested attributes are going to be used when an associated record already exists. In general, an existing record may either be updated with the new set of attribute values or be replaced by a wholly new record containing those values. By default the +:update_only+ option is false and the nested attributes are used to update the existing record only if they include the record's <tt>:id</tt> value. Otherwise a new record will be instantiated and used to replace the existing one. However if the +:update_only+ option is true, the nested attributes are used to update the record's attributes always, regardless of whether the <tt>:id</tt> is present. The option is ignored for collection associations.  Examples: # creates avatar_attributes= accepts_nested_attributes_for :avatar, reject_if: proc { |attributes| attributes['name'].blank? } # creates avatar_attributes= accepts_nested_attributes_for :avatar, reject_if: :all_blank # creates avatar_attributes= and posts_attributes= accepts_nested_attributes_for :avatar, :posts, allow_destroy: true",
    "label": "",
    "id": "1506"
  },
  {
    "raw_code": "def generate_association_writer(association_name, type)\n          generated_association_methods.module_eval <<-eoruby, __FILE__, __LINE__ + 1\n            silence_redefinition_of_method :#{association_name}_attributes=\n            def #{association_name}_attributes=(attributes)\n              association = association(:#{association_name})\n              deprecated_associations_api_guard(association, __method__)\n              assign_nested_attributes_for_#{type}_association(:#{association_name}, attributes)\n            end\n          eoruby\n        end",
    "comment": "Generates a writer method for this association. Serves as a point for accessing the objects in the association. For example, this method could generate the following:  def pirate_attributes=(attributes) assign_nested_attributes_for_one_to_one_association(:pirate, attributes) end  This redirects the attempts to write objects in an association through the helper methods defined below. Makes it seem like the nested associations are just regular associations.",
    "label": "",
    "id": "1507"
  },
  {
    "raw_code": "def _destroy\n      marked_for_destruction?\n    end",
    "comment": "Returns ActiveRecord::AutosaveAssociation#marked_for_destruction? It's used in conjunction with fields_for to build a form element for the destruction of this association.  See ActionView::Helpers::FormHelper#fields_for for more info.",
    "label": "",
    "id": "1508"
  },
  {
    "raw_code": "def assign_nested_attributes_for_one_to_one_association(association_name, attributes)\n        if attributes.respond_to?(:permitted?)\n          attributes = attributes.to_h\n        end",
    "comment": "Assigns the given attributes to the association.  If an associated record does not yet exist, one will be instantiated. If an associated record already exists, the method's behavior depends on the value of the update_only option. If update_only is +false+ and the given attributes include an <tt>:id</tt> that matches the existing record's id, then the existing record will be modified. If no <tt>:id</tt> is provided it will be replaced with a new record. If update_only is +true+ the existing record will be modified regardless of whether an <tt>:id</tt> is provided.  If the given attributes include a matching <tt>:id</tt> attribute, or update_only is true, and a <tt>:_destroy</tt> key set to a truthy value, then the existing record will be marked for destruction.",
    "label": "",
    "id": "1509"
  },
  {
    "raw_code": "def assign_nested_attributes_for_collection_association(association_name, attributes_collection)\n        options = nested_attributes_options[association_name]\n        if attributes_collection.respond_to?(:permitted?)\n          attributes_collection = attributes_collection.to_h\n        end",
    "comment": "Assigns the given attributes to the collection association.  Hashes with an <tt>:id</tt> value matching an existing associated record will update that record. Hashes without an <tt>:id</tt> value will build a new record for the association. Hashes with a matching <tt>:id</tt> value and a <tt>:_destroy</tt> key set to a truthy value will mark the matched record for destruction.  For example:  assign_nested_attributes_for_collection_association(:people, { '1' => { id: '1', name: 'Peter' }, '2' => { name: 'John' }, '3' => { id: '2', _destroy: true } })  Will update the name of the Person with ID 1, build a new associated person with the name 'John', and mark the associated Person with ID 2 for destruction.  Also accepts an Array of attribute hashes:  assign_nested_attributes_for_collection_association(:people, [ { id: '1', name: 'Peter' }, { name: 'John' }, { id: '2', _destroy: true } ])",
    "label": "",
    "id": "1510"
  },
  {
    "raw_code": "def check_record_limit!(limit, attributes_collection)\n        if limit\n          limit = \\\n            case limit\n            when Symbol\n              send(limit)\n            when Proc\n              limit.call\n            else\n              limit\n            end",
    "comment": "Takes in a limit and checks if the attributes_collection has too many records. It accepts limit in the form of symbol, proc, or number-like object (anything that can be compared with an integer).  Raises TooManyRecords error if the attributes_collection is larger than the limit.",
    "label": "",
    "id": "1511"
  },
  {
    "raw_code": "def assign_to_or_mark_for_destruction(record, attributes, allow_destroy)\n        record.assign_attributes(attributes.except(*UNASSIGNABLE_KEYS))\n        record.mark_for_destruction if has_destroy_flag?(attributes) && allow_destroy\n      end",
    "comment": "Updates a record with the +attributes+ or marks it for destruction if +allow_destroy+ is +true+ and has_destroy_flag? returns +true+.",
    "label": "",
    "id": "1512"
  },
  {
    "raw_code": "def has_destroy_flag?(hash)\n        Type::Boolean.new.cast(hash[\"_destroy\"])\n      end",
    "comment": "Determines if a hash contains a truthy _destroy key.",
    "label": "",
    "id": "1513"
  },
  {
    "raw_code": "def reject_new_record?(association_name, attributes)\n        will_be_destroyed?(association_name, attributes) || call_reject_if(association_name, attributes)\n      end",
    "comment": "Determines if a new record should be rejected by checking has_destroy_flag? or if a <tt>:reject_if</tt> proc exists for this association and evaluates to +true+.",
    "label": "",
    "id": "1514"
  },
  {
    "raw_code": "def call_reject_if(association_name, attributes)\n        return false if will_be_destroyed?(association_name, attributes)\n\n        case callback = nested_attributes_options[association_name][:reject_if]\n        when Symbol\n          method(callback).arity == 0 ? send(callback) : send(callback, attributes)\n        when Proc\n          callback.call(attributes)\n        end",
    "comment": "Determines if a record with the particular +attributes+ should be rejected by calling the reject_if Symbol or Proc (if defined). The reject_if option is defined by +accepts_nested_attributes_for+.  Returns false if there is a +destroy_flag+ on the attributes.",
    "label": "",
    "id": "1515"
  },
  {
    "raw_code": "def will_be_destroyed?(association_name, attributes)\n        allow_destroy?(association_name) && has_destroy_flag?(attributes)\n      end",
    "comment": "Only take into account the destroy flag if <tt>:allow_destroy</tt> is true",
    "label": "",
    "id": "1516"
  },
  {
    "raw_code": "def no_touching(&block)\n        NoTouching.apply_to(self, &block)\n      end",
    "comment": "Lets you selectively disable calls to +touch+ for the duration of a block.  ==== Examples ActiveRecord::Base.no_touching do Project.first.touch  # does nothing Message.first.touch  # does nothing end  Project.no_touching do Project.first.touch  # does nothing Message.first.touch  # works, but does not touch the associated project end ",
    "label": "",
    "id": "1517"
  },
  {
    "raw_code": "def no_touching?\n      NoTouching.applied_to?(self.class)\n    end",
    "comment": "Returns +true+ if the class has +no_touching+ set, +false+ otherwise.  Project.no_touching do Project.first.no_touching? # true Message.first.no_touching? # false end ",
    "label": "",
    "id": "1518"
  },
  {
    "raw_code": "def create(attributes = nil, &block)\n        if attributes.is_a?(Array)\n          attributes.collect { |attr| create(attr, &block) }\n        else\n          object = new(attributes, &block)\n          object.save\n          object\n        end",
    "comment": "Creates an object (or multiple objects) and saves it to the database, if validations pass. The resulting object is returned whether the object was saved successfully to the database or not.  The +attributes+ parameter can be either a Hash or an Array of Hashes. These Hashes describe the attributes on the objects that are to be created.  ==== Examples # Create a single new object User.create(first_name: 'Jamie')  # Create an Array of new objects User.create([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }])  # Create a single object and pass it into a block to set other attributes. User.create(first_name: 'Jamie') do |u| u.is_admin = false end  # Creating an Array of new objects using a block, where the block is executed for each object: User.create([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }]) do |u| u.is_admin = false end",
    "label": "",
    "id": "1519"
  },
  {
    "raw_code": "def create!(attributes = nil, &block)\n        if attributes.is_a?(Array)\n          attributes.collect { |attr| create!(attr, &block) }\n        else\n          object = new(attributes, &block)\n          object.save!\n          object\n        end",
    "comment": "Creates an object (or multiple objects) and saves it to the database, if validations pass. Raises a RecordInvalid error if validations fail, unlike Base#create.  The +attributes+ parameter can be either a Hash or an Array of Hashes. These describe which attributes to be created on the object, or multiple objects when given an Array of Hashes.",
    "label": "",
    "id": "1520"
  },
  {
    "raw_code": "def build(attributes = nil, &block)\n        if attributes.is_a?(Array)\n          attributes.collect { |attr| build(attr, &block) }\n        else\n          new(attributes, &block)\n        end",
    "comment": "Builds an object (or multiple objects) and returns either the built object or a list of built objects.  The +attributes+ parameter can be either a Hash or an Array of Hashes. These Hashes describe the attributes on the objects that are to be built.  ==== Examples # Build a single new object User.build(first_name: 'Jamie')  # Build an Array of new objects User.build([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }])  # Build a single object and pass it into a block to set other attributes. User.build(first_name: 'Jamie') do |u| u.is_admin = false end  # Building an Array of new objects using a block, where the block is executed for each object: User.build([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }]) do |u| u.is_admin = false end",
    "label": "",
    "id": "1521"
  },
  {
    "raw_code": "def instantiate(attributes, column_types = {}, &block)\n        klass = discriminate_class_for_record(attributes)\n        instantiate_instance_of(klass, attributes, column_types, &block)\n      end",
    "comment": "Given an attributes hash, +instantiate+ returns a new instance of the appropriate class. Accepts only keys as strings.  For example, +Post.all+ may return Comments, Messages, and Emails by storing the record's subclass in a +type+ attribute. By calling +instantiate+ instead of +new+, finder methods ensure they get new instances of the appropriate class for each record.  See <tt>ActiveRecord::Inheritance#discriminate_class_for_record</tt> to see how this \"single-table\" inheritance mapping is implemented.",
    "label": "",
    "id": "1522"
  },
  {
    "raw_code": "def update(id = :all, attributes)\n        if id.is_a?(Array)\n          if id.any?(ActiveRecord::Base)\n            raise ArgumentError,\n              \"You are passing an array of ActiveRecord::Base instances to `update`. \" \\\n              \"Please pass the ids of the objects by calling `pluck(:id)` or `map(&:id)`.\"\n          end",
    "comment": "Updates an object (or multiple objects) and saves it to the database, if validations pass. The resulting object is returned whether the object was saved successfully to the database or not.  ==== Parameters  * +id+ - This should be the id or an array of ids to be updated. Optional argument, defaults to all records in the relation. * +attributes+ - This should be a hash of attributes or an array of hashes.  ==== Examples  # Updates one record Person.update(15, user_name: \"Samuel\", group: \"expert\")  # Updates multiple records people = { 1 => { \"first_name\" => \"David\" }, 2 => { \"first_name\" => \"Jeremy\" } } Person.update(people.keys, people.values)  # Updates multiple records from the result of a relation people = Person.where(group: \"expert\") people.update(group: \"masters\")  Note: Updating a large number of records will run an UPDATE query for each record, which may cause a performance issue. When running callbacks is not needed for each record update, it is preferred to use {update_all}[rdoc-ref:Relation#update_all] for updating all records in a single query.",
    "label": "",
    "id": "1523"
  },
  {
    "raw_code": "def update!(id = :all, attributes)\n        if id.is_a?(Array)\n          if id.any?(ActiveRecord::Base)\n            raise ArgumentError,\n              \"You are passing an array of ActiveRecord::Base instances to `update!`. \" \\\n              \"Please pass the ids of the objects by calling `pluck(:id)` or `map(&:id)`.\"\n          end",
    "comment": "Updates the object (or multiple objects) just like #update but calls #update! instead of +update+, so an exception is raised if the record is invalid and saving will fail.",
    "label": "",
    "id": "1524"
  },
  {
    "raw_code": "def query_constraints(*columns_list)\n        raise ArgumentError, \"You must specify at least one column to be used in querying\" if columns_list.empty?\n\n        @query_constraints_list = columns_list.map(&:to_s)\n        @has_query_constraints = @query_constraints_list\n      end",
    "comment": "Accepts a list of attribute names to be used in the WHERE clause of SELECT / UPDATE / DELETE queries and in the ORDER BY clause for +#first+ and +#last+ finder methods.  class Developer < ActiveRecord::Base query_constraints :company_id, :id end  developer = Developer.first # SELECT \"developers\".* FROM \"developers\" ORDER BY \"developers\".\"company_id\" ASC, \"developers\".\"id\" ASC LIMIT 1 developer.inspect # => #<Developer id: 1, company_id: 1, ...>  developer.update!(name: \"Nikita\") # UPDATE \"developers\" SET \"name\" = 'Nikita' WHERE \"developers\".\"company_id\" = 1 AND \"developers\".\"id\" = 1  # It is possible to update an attribute used in the query_constraints clause: developer.update!(company_id: 2) # UPDATE \"developers\" SET \"company_id\" = 2 WHERE \"developers\".\"company_id\" = 1 AND \"developers\".\"id\" = 1  developer.name = \"Bob\" developer.save! # UPDATE \"developers\" SET \"name\" = 'Bob' WHERE \"developers\".\"company_id\" = 1 AND \"developers\".\"id\" = 1  developer.destroy! # DELETE FROM \"developers\" WHERE \"developers\".\"company_id\" = 1 AND \"developers\".\"id\" = 1  developer.delete # DELETE FROM \"developers\" WHERE \"developers\".\"company_id\" = 1 AND \"developers\".\"id\" = 1  developer.reload # SELECT \"developers\".* FROM \"developers\" WHERE \"developers\".\"company_id\" = 1 AND \"developers\".\"id\" = 1 LIMIT 1",
    "label": "",
    "id": "1525"
  },
  {
    "raw_code": "def composite_query_constraints_list # :nodoc:\n        @composite_query_constraints_list ||= query_constraints_list || Array(primary_key)\n      end",
    "comment": "Returns an array of column names to be used in queries. The source of column names is derived from +query_constraints_list+ or +primary_key+. This method is for internal use when the primary key is to be treated as an array.",
    "label": "",
    "id": "1526"
  },
  {
    "raw_code": "def instantiate_instance_of(klass, attributes, column_types = {}, &block)\n          attributes = klass.attributes_builder.build_from_database(attributes, column_types)\n          klass.allocate.init_with_attributes(attributes, &block)\n        end",
    "comment": "Given a class, an attributes hash, +instantiate_instance_of+ returns a new instance of the class. Accepts only keys as strings.",
    "label": "",
    "id": "1527"
  },
  {
    "raw_code": "def discriminate_class_for_record(record)\n          self\n        end",
    "comment": "Called by +instantiate+ to decide which class to use for a new record instance.  See +ActiveRecord::Inheritance#discriminate_class_for_record+ for the single-table inheritance discriminator.",
    "label": "",
    "id": "1528"
  },
  {
    "raw_code": "def build_default_constraint\n          return unless default_scopes?(all_queries: true)\n\n          default_where_clause = default_scoped(all_queries: true).where_clause\n          default_where_clause.ast unless default_where_clause.empty?\n        end",
    "comment": "Called by +_update_record+ and +_delete_record+ to build `where` clause from default scopes. Skips empty scopes.",
    "label": "",
    "id": "1529"
  },
  {
    "raw_code": "def new_record?\n      @new_record\n    end",
    "comment": "Returns true if this object hasn't been saved yet -- that is, a record for the object doesn't exist in the database yet; otherwise, returns false.",
    "label": "",
    "id": "1530"
  },
  {
    "raw_code": "def previously_new_record?\n      @previously_new_record\n    end",
    "comment": "Returns true if this object was just created -- that is, prior to the last update or delete, the object didn't exist in the database and new_record? would have returned true.",
    "label": "",
    "id": "1531"
  },
  {
    "raw_code": "def previously_persisted?\n      !new_record? && destroyed?\n    end",
    "comment": "Returns true if this object was previously persisted but now it has been deleted.",
    "label": "",
    "id": "1532"
  },
  {
    "raw_code": "def destroyed?\n      @destroyed\n    end",
    "comment": "Returns true if this object has been destroyed, otherwise returns false.",
    "label": "",
    "id": "1533"
  },
  {
    "raw_code": "def persisted?\n      !(@new_record || @destroyed)\n    end",
    "comment": "Returns true if the record is persisted, i.e. it's not a new record and it was not destroyed, otherwise returns false.",
    "label": "",
    "id": "1534"
  },
  {
    "raw_code": "def save(**options, &block)\n      create_or_update(**options, &block)\n    rescue ActiveRecord::RecordInvalid\n      false\n    end",
    "comment": " :call-seq: save(**options)  Saves the model.  If the model is new, a record gets created in the database, otherwise the existing record gets updated.  By default, save always runs validations. If any of them fail the action is cancelled and #save returns +false+, and the record won't be saved. However, if you supply <tt>validate: false</tt>, validations are bypassed altogether. See ActiveRecord::Validations for more information.  By default, #save also sets the +updated_at+/+updated_on+ attributes to the current time. However, if you supply <tt>touch: false</tt>, these timestamps will not be updated.  There's a series of callbacks associated with #save. If any of the <tt>before_*</tt> callbacks throws +:abort+ the action is cancelled and #save returns +false+. See ActiveRecord::Callbacks for further details.  Attributes marked as readonly are silently ignored if the record is being updated.",
    "label": "",
    "id": "1535"
  },
  {
    "raw_code": "def save!(**options, &block)\n      create_or_update(**options, &block) || raise(RecordNotSaved.new(\"Failed to save the record\", self))\n    end",
    "comment": " :call-seq: save!(**options)  Saves the model.  If the model is new, a record gets created in the database, otherwise the existing record gets updated.  By default, #save! always runs validations. If any of them fail ActiveRecord::RecordInvalid gets raised, and the record won't be saved. However, if you supply <tt>validate: false</tt>, validations are bypassed altogether. See ActiveRecord::Validations for more information.  By default, #save! also sets the +updated_at+/+updated_on+ attributes to the current time. However, if you supply <tt>touch: false</tt>, these timestamps will not be updated.  There's a series of callbacks associated with #save!. If any of the <tt>before_*</tt> callbacks throws +:abort+ the action is cancelled and #save! raises ActiveRecord::RecordNotSaved. See ActiveRecord::Callbacks for further details.  Attributes marked as readonly are silently ignored if the record is being updated.  Unless an error is raised, returns true.",
    "label": "",
    "id": "1536"
  },
  {
    "raw_code": "def delete\n      _delete_row if persisted?\n      @destroyed = true\n      @previously_new_record = false\n      freeze\n    end",
    "comment": "Deletes the record in the database and freezes this instance to reflect that no changes should be made (since they can't be persisted). Returns the frozen instance.  The row is simply removed with an SQL +DELETE+ statement on the record's primary key, and no callbacks are executed.  Note that this will also delete records marked as {#readonly?}[rdoc-ref:Core#readonly?].  To enforce the object's +before_destroy+ and +after_destroy+ callbacks or any <tt>:dependent</tt> association options, use #destroy.",
    "label": "",
    "id": "1537"
  },
  {
    "raw_code": "def destroy\n      _raise_readonly_record_error if readonly?\n      destroy_associations\n      @_trigger_destroy_callback ||= persisted? && destroy_row > 0\n      @destroyed = true\n      @previously_new_record = false\n      freeze\n    end",
    "comment": "Deletes the record in the database and freezes this instance to reflect that no changes should be made (since they can't be persisted).  There's a series of callbacks associated with #destroy. If the <tt>before_destroy</tt> callback throws +:abort+ the action is cancelled and #destroy returns +false+. See ActiveRecord::Callbacks for further details.",
    "label": "",
    "id": "1538"
  },
  {
    "raw_code": "def destroy!\n      destroy || _raise_record_not_destroyed\n    end",
    "comment": "Deletes the record in the database and freezes this instance to reflect that no changes should be made (since they can't be persisted).  There's a series of callbacks associated with #destroy!. If the <tt>before_destroy</tt> callback throws +:abort+ the action is cancelled and #destroy! raises ActiveRecord::RecordNotDestroyed. See ActiveRecord::Callbacks for further details.",
    "label": "",
    "id": "1539"
  },
  {
    "raw_code": "def becomes(klass)\n      became = klass.allocate\n\n      became.send(:initialize) do |becoming|\n        @attributes.reverse_merge!(becoming.instance_variable_get(:@attributes))\n        becoming.instance_variable_set(:@attributes, @attributes)\n        becoming.instance_variable_set(:@mutations_from_database, @mutations_from_database ||= nil)\n        becoming.instance_variable_set(:@new_record, new_record?)\n        becoming.instance_variable_set(:@previously_new_record, previously_new_record?)\n        becoming.instance_variable_set(:@destroyed, destroyed?)\n        becoming.errors.copy!(errors)\n      end",
    "comment": "Returns an instance of the specified +klass+ with the attributes of the current record. This is mostly useful in relation to single table inheritance (STI) structures where you want a subclass to appear as the superclass. This can be used along with record identification in Action Pack to allow, say, <tt>Client < Company</tt> to do something like render <tt>partial: @client.becomes(Company)</tt> to render that instance using the companies/company partial instead of clients/client.  Note: The new instance will share a link to the same attributes as the original class. Therefore the STI column value will still be the same. Any change to the attributes on either instance will affect both instances. This includes any attribute initialization done by the new instance.  If you want to change the STI column as well, use #becomes! instead.",
    "label": "",
    "id": "1540"
  },
  {
    "raw_code": "def becomes!(klass)\n      became = becomes(klass)\n      sti_type = nil\n      if !klass.descends_from_active_record?\n        sti_type = klass.sti_name\n      end",
    "comment": "Wrapper around #becomes that also changes the instance's STI column value. This is especially useful if you want to persist the changed class in your database.  Note: The old instance's STI column value will be changed too, as both objects share the same set of attributes.",
    "label": "",
    "id": "1541"
  },
  {
    "raw_code": "def update_attribute(name, value)\n      name = name.to_s\n      verify_readonly_attribute(name)\n      public_send(\"#{name}=\", value)\n\n      save(validate: false)\n    end",
    "comment": "Updates a single attribute and saves the record. This is especially useful for boolean flags on existing records. Also note that  * Validation is skipped. * \\Callbacks are invoked. * updated_at/updated_on column is updated if that column is available. * Updates all the attributes that are dirty in this object.  This method raises an ActiveRecord::ActiveRecordError if the attribute is marked as readonly.  Also see #update_column.",
    "label": "",
    "id": "1542"
  },
  {
    "raw_code": "def update_attribute!(name, value)\n      name = name.to_s\n      verify_readonly_attribute(name)\n      public_send(\"#{name}=\", value)\n\n      save!(validate: false)\n    end",
    "comment": "Updates a single attribute and saves the record. This is especially useful for boolean flags on existing records. Also note that  * Validation is skipped. * \\Callbacks are invoked. * updated_at/updated_on column is updated if that column is available. * Updates all the attributes that are dirty in this object.  This method raises an ActiveRecord::ActiveRecordError if the attribute is marked as readonly.  If any of the <tt>before_*</tt> callbacks throws +:abort+ the action is cancelled and #update_attribute! raises ActiveRecord::RecordNotSaved. See ActiveRecord::Callbacks for further details.",
    "label": "",
    "id": "1543"
  },
  {
    "raw_code": "def update(attributes)\n      # The following transaction covers any possible database side-effects of the\n      # attributes assignment. For example, setting the IDs of a child collection.\n      with_transaction_returning_status do\n        assign_attributes(attributes)\n        save\n      end",
    "comment": "Updates the attributes of the model from the passed-in hash and saves the record, all wrapped in a transaction. If the object is invalid, the saving will fail and false will be returned.",
    "label": "",
    "id": "1544"
  },
  {
    "raw_code": "def update!(attributes)\n      # The following transaction covers any possible database side-effects of the\n      # attributes assignment. For example, setting the IDs of a child collection.\n      with_transaction_returning_status do\n        assign_attributes(attributes)\n        save!\n      end",
    "comment": "Updates its receiver just like #update but calls #save! instead of +save+, so an exception is raised if the record is invalid and saving will fail.",
    "label": "",
    "id": "1545"
  },
  {
    "raw_code": "def update_column(name, value, touch: nil)\n      update_columns(name => value, touch: touch)\n    end",
    "comment": "Equivalent to <code>update_columns(name => value)</code>.",
    "label": "",
    "id": "1546"
  },
  {
    "raw_code": "def update_columns(attributes)\n      raise ActiveRecordError, \"cannot update a new record\" if new_record?\n      raise ActiveRecordError, \"cannot update a destroyed record\" if destroyed?\n      _raise_readonly_record_error if readonly?\n\n      attributes = attributes.transform_keys do |key|\n        name = key.to_s\n        name = self.class.attribute_aliases[name] || name\n        verify_readonly_attribute(name) || name\n      end",
    "comment": "Updates the attributes directly in the database issuing an UPDATE SQL statement and sets them in the receiver:  user.update_columns(last_request_at: Time.current)  This is the fastest way to update attributes because it goes straight to the database, but take into account that in consequence the regular update procedures are totally bypassed. In particular:  * \\Validations are skipped. * \\Callbacks are skipped. * +updated_at+/+updated_on+ are updated if the +touch+ option is set to +true+. * However, attributes are serialized with the same rules as ActiveRecord::Relation#update_all  This method raises an ActiveRecord::ActiveRecordError when called on new objects, or when at least one of the attributes is marked as readonly.  ==== Parameters  * <tt>:touch</tt> option - Touch the timestamp columns when updating. * If attribute names are passed, they are updated along with +updated_at+/+updated_on+ attributes.  ==== Examples  # Update a single attribute. user.update_columns(last_request_at: Time.current)  # Update with touch option. user.update_columns(last_request_at: Time.current, touch: true)",
    "label": "",
    "id": "1547"
  },
  {
    "raw_code": "def increment(attribute, by = 1)\n      self[attribute] ||= 0\n      self[attribute] += by\n      self\n    end",
    "comment": "Initializes +attribute+ to zero if +nil+ and adds the value passed as +by+ (default is 1). The increment is performed directly on the underlying attribute, no setter is invoked. Only makes sense for number-based attributes. Returns +self+.",
    "label": "",
    "id": "1548"
  },
  {
    "raw_code": "def increment!(attribute, by = 1, touch: nil)\n      raise ActiveRecordError, \"cannot update a new record\" if new_record?\n      raise ActiveRecordError, \"cannot update a destroyed record\" if destroyed?\n\n      increment(attribute, by)\n      change = public_send(attribute) - (public_send(:\"#{attribute}_in_database\") || 0)\n      self.class.update_counters(id, attribute => change, touch: touch)\n      public_send(:\"clear_#{attribute}_change\")\n      self\n    end",
    "comment": "Wrapper around #increment that writes the update to the database. Only +attribute+ is updated; the record itself is not saved. This means that any other modified attributes will still be dirty. Validations and callbacks are skipped. Supports the +touch+ option from +update_counters+, see that for more.  This method raises an ActiveRecord::ActiveRecordError when called on new objects, or when at least one of the attributes is marked as readonly.  Returns +self+.",
    "label": "",
    "id": "1549"
  },
  {
    "raw_code": "def decrement(attribute, by = 1)\n      increment(attribute, -by)\n    end",
    "comment": "Initializes +attribute+ to zero if +nil+ and subtracts the value passed as +by+ (default is 1). The decrement is performed directly on the underlying attribute, no setter is invoked. Only makes sense for number-based attributes. Returns +self+.",
    "label": "",
    "id": "1550"
  },
  {
    "raw_code": "def decrement!(attribute, by = 1, touch: nil)\n      increment!(attribute, -by, touch: touch)\n    end",
    "comment": "Wrapper around #decrement that writes the update to the database. Only +attribute+ is updated; the record itself is not saved. This means that any other modified attributes will still be dirty. Validations and callbacks are skipped. Supports the +touch+ option from +update_counters+, see that for more. Returns +self+.",
    "label": "",
    "id": "1551"
  },
  {
    "raw_code": "def toggle(attribute)\n      self[attribute] = !public_send(\"#{attribute}?\")\n      self\n    end",
    "comment": "Assigns to +attribute+ the boolean opposite of <tt>attribute?</tt>. So if the predicate returns +true+ the attribute will become +false+. This method toggles directly the underlying value without calling any setter. Returns +self+.  Example:  user = User.first user.banned? # => false user.toggle(:banned) user.banned? # => true ",
    "label": "",
    "id": "1552"
  },
  {
    "raw_code": "def toggle!(attribute)\n      toggle(attribute).update_attribute(attribute, self[attribute])\n    end",
    "comment": "Wrapper around #toggle that saves the record. This method differs from its non-bang version in the sense that it passes through the attribute setter. Saving is not subjected to validation checks. Returns +true+ if the record could be saved.",
    "label": "",
    "id": "1553"
  },
  {
    "raw_code": "def reload(options = nil)\n      self.class.connection_pool.clear_query_cache\n\n      fresh_object = if apply_scoping?(options)\n        _find_record((options || {}).merge(all_queries: true))\n      else\n        self.class.unscoped { _find_record(options) }\n      end",
    "comment": "Reloads the record from the database.  This method finds the record by its primary key (which could be assigned manually) and modifies the receiver in-place:  account = Account.new # => #<Account id: nil, email: nil> account.id = 1 account.reload # Account Load (1.2ms)  SELECT \"accounts\".* FROM \"accounts\" WHERE \"accounts\".\"id\" = $1 LIMIT 1  [[\"id\", 1]] # => #<Account id: 1, email: 'account@example.com'>  Attributes are reloaded from the database, and caches busted, in particular the associations cache and the QueryCache.  If the record no longer exists in the database ActiveRecord::RecordNotFound is raised. Otherwise, in addition to the in-place modification the method returns +self+ for convenience.  The optional <tt>:lock</tt> flag option allows you to lock the reloaded record:  reload(lock: true) # reload with pessimistic locking  Reloading is commonly used in test suites to test something is actually written to the database, or when some action modifies the corresponding row in the database but not the object in memory:  assert account.deposit!(25) assert_equal 25, account.credit        # check it is updated in memory assert_equal 25, account.reload.credit # check it is also persisted  Another common use case is optimistic locking handling:  def with_optimistic_retry begin yield rescue ActiveRecord::StaleObjectError begin # Reload lock_version in particular. reload rescue ActiveRecord::RecordNotFound # If the record is gone there is nothing to do. else retry end end end ",
    "label": "",
    "id": "1554"
  },
  {
    "raw_code": "def touch(*names, time: nil)\n      _raise_record_not_touched_error unless persisted?\n      _raise_readonly_record_error if readonly?\n\n      attribute_names = timestamp_attributes_for_update_in_model\n      attribute_names = (attribute_names | names).map! do |name|\n        name = name.to_s\n        name = self.class.attribute_aliases[name] || name\n        verify_readonly_attribute(name)\n        name\n      end",
    "comment": "Saves the record with the updated_at/on attributes set to the current time or the time specified. Please note that no validation is performed and only the +after_touch+, +after_commit+ and +after_rollback+ callbacks are executed.  This method can be passed attribute names and an optional time argument. If attribute names are passed, they are updated along with updated_at/on attributes. If no time argument is passed, the current time is used as default.  product.touch                         # updates updated_at/on with current time product.touch(time: Time.new(2015, 2, 16, 0, 0, 0)) # updates updated_at/on with specified time product.touch(:designed_at)           # updates the designed_at attribute and updated_at/on product.touch(:started_at, :ended_at) # updates started_at, ended_at and updated_at/on attributes  If used along with {belongs_to}[rdoc-ref:Associations::ClassMethods#belongs_to] then +touch+ will invoke +touch+ method on associated object.  class Brake < ActiveRecord::Base belongs_to :car, touch: true end  class Car < ActiveRecord::Base belongs_to :corporation, touch: true end  # triggers @brake.car.touch and @brake.car.corporation.touch @brake.touch  Note that +touch+ must be used on a persisted object, or else an ActiveRecordError will be thrown. For example:  ball = Ball.new ball.touch(:updated_at)   # => raises ActiveRecordError ",
    "label": "",
    "id": "1555"
  },
  {
    "raw_code": "def destroy_associations\n      end",
    "comment": "A hook to be overridden by association modules.",
    "label": "",
    "id": "1556"
  },
  {
    "raw_code": "def _update_record(attribute_names = self.attribute_names)\n        attribute_names = attributes_for_update(attribute_names)\n\n        if attribute_names.empty?\n          affected_rows = 0\n          @_trigger_update_callback = true\n        else\n          affected_rows = _update_row(attribute_names)\n          @_trigger_update_callback = affected_rows == 1\n        end",
    "comment": "Updates the associated record with values matching those of the instance attributes. Returns the number of affected rows.",
    "label": "",
    "id": "1557"
  },
  {
    "raw_code": "def _create_record(attribute_names = self.attribute_names)\n        attribute_names = attributes_for_create(attribute_names)\n\n        self.class.with_connection do |connection|\n          returning_columns = self.class._returning_columns_for_insert(connection)\n\n          returning_values = self.class._insert_record(\n            connection,\n            attributes_with_values(attribute_names),\n            returning_columns\n          )\n\n          returning_columns.zip(returning_values).each do |column, value|\n            _write_attribute(column, type_for_attribute(column).deserialize(value)) if !_read_attribute(column)\n          end if returning_values\n        end",
    "comment": "Creates a record with values matching those of the instance attributes and returns its id.",
    "label": "",
    "id": "1558"
  },
  {
    "raw_code": "def pending?\n      @future_result.pending?\n    end",
    "comment": "Returns whether the associated query is still being executed or not.",
    "label": "",
    "id": "1559"
  },
  {
    "raw_code": "def value\n      return @value if defined? @value\n\n      result = @future_result.result\n      @value = if @block\n        @block.call(result)\n      else\n        result\n      end",
    "comment": "Returns the query result. If the query wasn't completed yet, accessing +#value+ will block until the query completes. If the query failed, +#value+ will raise the corresponding error.",
    "label": "",
    "id": "1560"
  },
  {
    "raw_code": "def then(&block)\n      Promise.new(@future_result, @block ? @block >> block : block)\n    end",
    "comment": "Returns a new +ActiveRecord::Promise+ that will apply the passed block when the value is accessed:  Post.async_pick(:title).then { |title| title.upcase }.value # => \"POST TITLE\"",
    "label": "",
    "id": "1561"
  },
  {
    "raw_code": "def find_by_sql(sql, binds = [], preparable: nil, allow_retry: false, &block)\n      result = with_connection do |c|\n        _query_by_sql(c, sql, binds, preparable: preparable, allow_retry: allow_retry)\n      end",
    "comment": "Executes a custom SQL query against your database and returns all the results. The results will be returned as an array, with the requested columns encapsulated as attributes of the model you call this method from. For example, if you call <tt>Product.find_by_sql</tt>, then the results will be returned in a +Product+ object with the attributes you specified in the SQL query.  If you call a complicated SQL query which spans multiple tables, the columns specified by the SELECT will be attributes of the model, whether or not they are columns of the corresponding table.  The +sql+ parameter is a full SQL query as a string. It will be called as is; there will be no database agnostic conversions performed. This should be a last resort because using database-specific terms will lock you into using that particular database engine, or require you to change your call if you switch engines.  # A simple SQL query spanning multiple tables Post.find_by_sql \"SELECT p.title, c.author FROM posts p, comments c WHERE p.id = c.post_id\" # => [#<Post:0x36bff9c @attributes={\"title\"=>\"Ruby Meetup\", \"author\"=>\"Quentin\"}>, ...]  You can use the same string replacement techniques as you can with ActiveRecord::QueryMethods#where :  Post.find_by_sql [\"SELECT title FROM posts WHERE author = ? AND created > ?\", author_id, start_date] Post.find_by_sql [\"SELECT body FROM comments WHERE author = :user_id OR approved_by = :user_id\", { :user_id => user_id }]  Note that building your own SQL query string from user input {may expose your application to injection attacks}[https://guides.rubyonrails.org/security.html#sql-injection].",
    "label": "",
    "id": "1562"
  },
  {
    "raw_code": "def async_find_by_sql(sql, binds = [], preparable: nil, allow_retry: false, &block)\n      with_connection do |c|\n        _query_by_sql(c, sql, binds, preparable: preparable, allow_retry: allow_retry, async: true)\n      end.then do |result|\n        _load_from_sql(result, &block)\n      end",
    "comment": "Same as #find_by_sql but perform the query asynchronously and returns an ActiveRecord::Promise.",
    "label": "",
    "id": "1563"
  },
  {
    "raw_code": "def count_by_sql(sql)\n      with_connection do |c|\n        c.select_value(sanitize_sql(sql), \"#{name} Count\").to_i\n      end",
    "comment": "Returns the result of an SQL statement that should only include a COUNT(*) in the SELECT part. The use of this method should be restricted to complicated SQL queries that can't be executed using the ActiveRecord::Calculations class methods. Look into those before using this method, as it could lock you into a specific database engine or require a code change to switch database engines.  Product.count_by_sql \"SELECT COUNT(*) FROM sales s, customers c WHERE s.customer_id = c.id\" # => 12  ==== Parameters  * +sql+ - An SQL statement which should return a count query from the database, see the example above.",
    "label": "",
    "id": "1564"
  },
  {
    "raw_code": "def async_count_by_sql(sql)\n      with_connection do |c|\n        c.select_value(sanitize_sql(sql), \"#{name} Count\", async: true).then(&:to_i)\n      end",
    "comment": "Same as #count_by_sql but perform the query asynchronously and returns an ActiveRecord::Promise.",
    "label": "",
    "id": "1565"
  },
  {
    "raw_code": "def cache(&block)\n        if connected? || !configurations.empty?\n          pool = connection_pool\n          was_enabled = pool.query_cache_enabled\n          begin\n            pool.enable_query_cache(&block)\n          ensure\n            pool.clear_query_cache unless was_enabled\n          end",
    "comment": "Enable the query cache within the block if Active Record is configured. If it's not, it will execute the given block.",
    "label": "",
    "id": "1566"
  },
  {
    "raw_code": "def uncached(dirties: true, &block)\n        if connected? || !configurations.empty?\n          connection_pool.disable_query_cache(dirties: dirties, &block)\n        else\n          yield\n        end",
    "comment": "Runs the block with the query cache disabled.  If the query cache was enabled before the block was executed, it is enabled again after it.  Set <tt>dirties: false</tt> to prevent query caches on all connections from being cleared by write operations. (By default, write operations dirty all connections' query caches in case they are replicas whose cache would now be outdated.)",
    "label": "",
    "id": "1567"
  },
  {
    "raw_code": "def comment(connection)\n          if cache_query_log_tags\n            self.cached_comment ||= uncached_comment(connection)\n          else\n            uncached_comment(connection)\n          end",
    "comment": "Returns an SQL comment +String+ containing the query log tags. Sets and returns a cached comment if <tt>cache_query_log_tags</tt> is +true+.",
    "label": "",
    "id": "1568"
  },
  {
    "raw_code": "def format(key, value)\n          \"#{key}:#{value}\"\n        end",
    "comment": "Formats the key value pairs into a string.",
    "label": "",
    "id": "1569"
  },
  {
    "raw_code": "def attr_readonly(*attributes)\n        self._attr_readonly |= attributes.map(&:to_s)\n\n        if ActiveRecord.raise_on_assign_to_attr_readonly\n          include(HasReadonlyAttributes)\n        end",
    "comment": "Attributes listed as readonly will be used to create a new record. Assigning a new value to a readonly attribute on a persisted record raises an error.  By setting +config.active_record.raise_on_assign_to_attr_readonly+ to +false+, it will not raise. The value will change in memory, but will not be persisted on +save+.  ==== Examples  class Post < ActiveRecord::Base attr_readonly :title end  post = Post.create!(title: \"Introducing Ruby on Rails!\") post.title = \"a different title\" # raises ActiveRecord::ReadonlyAttributeError post.update(title: \"a different title\") # raises ActiveRecord::ReadonlyAttributeError",
    "label": "",
    "id": "1570"
  },
  {
    "raw_code": "def readonly_attributes\n        _attr_readonly\n      end",
    "comment": "Returns an array of all the attributes that have been specified as readonly.",
    "label": "",
    "id": "1571"
  },
  {
    "raw_code": "def reflect_on_all_aggregations\n        aggregate_reflections.values\n      end",
    "comment": "Returns an array of AggregateReflection objects for all the aggregations in the class.",
    "label": "",
    "id": "1572"
  },
  {
    "raw_code": "def reflect_on_aggregation(aggregation)\n        aggregate_reflections[aggregation.to_sym]\n      end",
    "comment": "Returns the AggregateReflection object for the named +aggregation+ (use the symbol).  Account.reflect_on_aggregation(:balance) # => the balance AggregateReflection ",
    "label": "",
    "id": "1573"
  },
  {
    "raw_code": "def reflections\n        normalized_reflections.stringify_keys\n      end",
    "comment": "Returns a Hash of name of the reflection as the key and an AssociationReflection as the value.  Account.reflections # => {\"balance\" => AggregateReflection} ",
    "label": "",
    "id": "1574"
  },
  {
    "raw_code": "def reflect_on_all_associations(macro = nil)\n        association_reflections = normalized_reflections.values\n        association_reflections.select! { |reflection| reflection.macro == macro } if macro\n        association_reflections\n      end",
    "comment": "Returns an array of AssociationReflection objects for all the associations in the class. If you only want to reflect on a certain association type, pass in the symbol (<tt>:has_many</tt>, <tt>:has_one</tt>, <tt>:belongs_to</tt>) as the first parameter.  Example:  Account.reflect_on_all_associations             # returns an array of all associations Account.reflect_on_all_associations(:has_many)  # returns an array of all has_many associations ",
    "label": "",
    "id": "1575"
  },
  {
    "raw_code": "def reflect_on_association(association)\n        normalized_reflections[association.to_sym]\n      end",
    "comment": "Returns the AssociationReflection object for the +association+ (use the symbol).  Account.reflect_on_association(:owner)             # returns the owner AssociationReflection Invoice.reflect_on_association(:line_items).macro  # returns :has_many ",
    "label": "",
    "id": "1576"
  },
  {
    "raw_code": "def reflect_on_all_autosave_associations\n        reflections = normalized_reflections.values\n        reflections.select! { |reflection| reflection.options[:autosave] }\n        reflections\n      end",
    "comment": "Returns an array of AssociationReflection objects for all associations which have <tt>:autosave</tt> enabled.",
    "label": "",
    "id": "1577"
  },
  {
    "raw_code": "def build_association(attributes, &block)\n        klass.new(attributes, &block)\n      end",
    "comment": "Returns a new, unsaved instance of the associated class. +attributes+ will be passed to the class's constructor.",
    "label": "",
    "id": "1578"
  },
  {
    "raw_code": "def class_name\n        @class_name ||= -(options[:class_name] || derive_class_name).to_s\n      end",
    "comment": "Returns the class name for the macro.  <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>'Money'</tt> <tt>has_many :clients</tt> returns <tt>'Client'</tt>",
    "label": "",
    "id": "1579"
  },
  {
    "raw_code": "def scopes\n        scope ? [scope] : []\n      end",
    "comment": "Returns a list of scopes that should be applied for this Reflection object when querying the database.",
    "label": "",
    "id": "1580"
  },
  {
    "raw_code": "def inverse_which_updates_counter_cache\n        unless @inverse_which_updates_counter_cache_defined\n          if counter_cache_column\n            inverse_candidates = inverse_of ? [inverse_of] : klass.reflect_on_all_associations(:belongs_to)\n            @inverse_which_updates_counter_cache = inverse_candidates.find do |inverse|\n              inverse.counter_cache_column == counter_cache_column && (inverse.polymorphic? || inverse.klass == active_record)\n            end",
    "comment": "We need to avoid the following situation:  * An associated record is deleted via record.destroy * Hence the callbacks run, and they find a belongs_to on the record with a :counter_cache options which points back at our owner. So they update the counter cache. * In which case, we must make sure to *not* update the counter cache, or else it will be decremented twice.  Hence this method.",
    "label": "",
    "id": "1581"
  },
  {
    "raw_code": "def has_cached_counter?\n        options[:counter_cache] ||\n          inverse_which_updates_counter_cache && inverse_which_updates_counter_cache.options[:counter_cache] &&\n          active_record.has_attribute?(counter_cache_column)\n      end",
    "comment": "Returns whether this association has a counter cache.  The counter_cache option must be given on either the owner or inverse association, and the column must be present on the owner.",
    "label": "",
    "id": "1582"
  },
  {
    "raw_code": "def has_active_cached_counter?\n        return false unless has_cached_counter?\n\n        counter_cache = options[:counter_cache] ||\n                        (inverse_which_updates_counter_cache && inverse_which_updates_counter_cache.options[:counter_cache])\n\n        counter_cache[:active] != false\n      end",
    "comment": "Returns whether this association has a counter cache and its column values were backfilled (and so it is used internally by methods like +size+/+any?+/etc).",
    "label": "",
    "id": "1583"
  },
  {
    "raw_code": "def klass\n        @klass ||= _klass(class_name)\n      end",
    "comment": "Returns the class for the macro.  <tt>composed_of :balance, class_name: 'Money'</tt> returns the Money class <tt>has_many :clients</tt> returns the Client class  class Company < ActiveRecord::Base has_many :clients end  Company.reflect_on_association(:clients).klass # => Client  <b>Note:</b> Do not call +klass.new+ or +klass.create+ to instantiate a new association object. Use +build_association+ or +create_association+ instead. This allows plugins to hook into association object creation.",
    "label": "",
    "id": "1584"
  },
  {
    "raw_code": "def ==(other_aggregation)\n        super ||\n          other_aggregation.kind_of?(self.class) &&\n          name == other_aggregation.name &&\n          !other_aggregation.options.nil? &&\n          active_record == other_aggregation.active_record\n      end",
    "comment": "Returns +true+ if +self+ and +other_aggregation+ have the same +name+ attribute, +active_record+ attribute, and +other_aggregation+ has an options hash assigned to it.",
    "label": "",
    "id": "1585"
  },
  {
    "raw_code": "def collect_join_chain\n        [self]\n      end",
    "comment": "A chain of reflections from this one back to the owner. For more see the explanation in ThroughReflection.",
    "label": "",
    "id": "1586"
  },
  {
    "raw_code": "def clear_association_scope_cache # :nodoc:\n        klass.initialize_find_by_cache\n      end",
    "comment": "This is for clearing cache on the reflection. Useful for tests that need to compare SQL queries on associations.",
    "label": "",
    "id": "1587"
  },
  {
    "raw_code": "def macro; raise NotImplementedError; end\n\n      # Returns whether or not this association reflection is for a collection\n      # association. Returns +true+ if the +macro+ is either +has_many+ or\n      # +has_and_belongs_to_many+, +false+ otherwise.\n      def collection?\n        false\n      end\n\n      # Returns whether or not the association should be validated as part of\n      # the parent's validation.\n      #\n      # Unless you explicitly disable validation with\n      # <tt>validate: false</tt>, validation will take place when:\n      #\n      # * you explicitly enable validation; <tt>validate: true</tt>\n      # * you use autosave; <tt>autosave: true</tt>\n      # * the association is a +has_many+ association\n      def validate?\n        !options[:validate].nil? ? options[:validate] : (options[:autosave] == true || collection?)\n      end\n\n      # Returns +true+ if +self+ is a +belongs_to+ reflection.\n      def belongs_to?; false; end\n\n      # Returns +true+ if +self+ is a +has_one+ reflection.\n      def has_one?; false; end\n\n      def association_class; raise NotImplementedError; end\n\n      def polymorphic?\n        options[:polymorphic]\n      end\n\n      def polymorphic_name\n        active_record.polymorphic_name\n      end\n\n      def add_as_source(seed)\n        seed\n      end\n\n      def add_as_polymorphic_through(reflection, seed)\n        seed + [PolymorphicReflection.new(self, reflection)]\n      end\n\n      def add_as_through(seed)\n        seed + [self]\n      end\n\n      def extensions\n        Array(options[:extend])\n      end\n\n      def deprecated?\n        @deprecated\n      end\n\n      private\n        # Attempts to find the inverse association name automatically.\n        # If it cannot find a suitable inverse association name, it returns\n        # +nil+.\n        def inverse_name\n          unless defined?(@inverse_name)\n            @inverse_name = options.fetch(:inverse_of) { automatic_inverse_of }\n          end\n\n          @inverse_name\n        end\n\n        # returns either +nil+ or the inverse association name that it finds.\n        def automatic_inverse_of\n          if can_find_inverse_of_automatically?(self)\n            inverse_name = ActiveSupport::Inflector.underscore(options[:as] || active_record.name.demodulize).to_sym\n\n            begin\n              reflection = klass._reflect_on_association(inverse_name)\n              if !reflection && active_record.automatically_invert_plural_associations\n                plural_inverse_name = ActiveSupport::Inflector.pluralize(inverse_name)\n                reflection = klass._reflect_on_association(plural_inverse_name)\n              end\n            rescue NameError => error\n              raise unless error.name.to_s == class_name\n\n              # Give up: we couldn't compute the klass type so we won't be able\n              # to find any associations either.\n              reflection = false\n            end\n\n            if valid_inverse_reflection?(reflection)\n              reflection.name\n            end\n          end",
    "comment": "Returns the macro type.  <tt>has_many :clients</tt> returns <tt>:has_many</tt>",
    "label": "",
    "id": "1588"
  },
  {
    "raw_code": "def valid_inverse_reflection?(reflection)\n          reflection &&\n            reflection != self &&\n            foreign_key == reflection.foreign_key &&\n            klass <= reflection.active_record &&\n            can_find_inverse_of_automatically?(reflection, true)\n        end",
    "comment": "Checks if the inverse reflection that is returned from the +automatic_inverse_of+ method is a valid reflection. We must make sure that the reflection's active_record name matches up with the current reflection's klass name.",
    "label": "",
    "id": "1589"
  },
  {
    "raw_code": "def can_find_inverse_of_automatically?(reflection, inverse_reflection = false)\n          reflection.options[:inverse_of] != false &&\n            !reflection.options[:through] &&\n            !reflection.options[:foreign_key] &&\n            scope_allows_automatic_inverse_of?(reflection, inverse_reflection)\n        end",
    "comment": "Checks to see if the reflection doesn't have any options that prevent us from being able to guess the inverse automatically. First, the <tt>inverse_of</tt> option cannot be set to false. Second, we must have <tt>has_many</tt>, <tt>has_one</tt>, <tt>belongs_to</tt> associations. Third, we must not have options such as <tt>:foreign_key</tt> which prevent us from correctly guessing the inverse association.",
    "label": "",
    "id": "1590"
  },
  {
    "raw_code": "def scope_allows_automatic_inverse_of?(reflection, inverse_reflection)\n          if inverse_reflection\n            !reflection.scope\n          else\n            !reflection.scope || reflection.klass.automatic_scope_inversing\n          end",
    "comment": "Scopes on the potential inverse reflection prevent automatic <tt>inverse_of</tt>, since the scope could exclude the owner record we would inverse from. Scopes on the reflection itself allow for automatic <tt>inverse_of</tt> as long as <tt>config.active_record.automatic_scope_inversing<tt> is set to +true+ (the default for new applications).",
    "label": "",
    "id": "1591"
  },
  {
    "raw_code": "def source_reflection\n        return unless source_reflection_name\n\n        through_reflection.klass._reflect_on_association(source_reflection_name)\n      end",
    "comment": "Returns the source of the through reflection. It checks both a singularized and pluralized form for <tt>:belongs_to</tt> or <tt>:has_many</tt>.  class Post < ActiveRecord::Base has_many :taggings has_many :tags, through: :taggings end  class Tagging < ActiveRecord::Base belongs_to :post belongs_to :tag end  tags_reflection = Post.reflect_on_association(:tags) tags_reflection.source_reflection # => <ActiveRecord::Reflection::BelongsToReflection: @name=:tag, @active_record=Tagging, @plural_name=\"tags\"> ",
    "label": "",
    "id": "1592"
  },
  {
    "raw_code": "def through_reflection\n        active_record._reflect_on_association(options[:through])\n      end",
    "comment": "Returns the AssociationReflection object specified in the <tt>:through</tt> option of a HasManyThrough or HasOneThrough association.  class Post < ActiveRecord::Base has_many :taggings has_many :tags, through: :taggings end  tags_reflection = Post.reflect_on_association(:tags) tags_reflection.through_reflection # => <ActiveRecord::Reflection::HasManyReflection: @name=:taggings, @active_record=Post, @plural_name=\"taggings\"> ",
    "label": "",
    "id": "1593"
  },
  {
    "raw_code": "def collect_join_chain\n        collect_join_reflections [self]\n      end",
    "comment": "Returns an array of reflections which are involved in this association. Each item in the array corresponds to a table which will be part of the query for this association.  The chain is built by recursively calling #chain on the source reflection and the through reflection. The base case for the recursion is a normal association, which just returns [self] as its #chain.  class Post < ActiveRecord::Base has_many :taggings has_many :tags, through: :taggings end  tags_reflection = Post.reflect_on_association(:tags) tags_reflection.chain # => [<ActiveRecord::Reflection::ThroughReflection: @delegate_reflection=#<ActiveRecord::Reflection::HasManyReflection: @name=:tags...>, <ActiveRecord::Reflection::HasManyReflection: @name=:taggings, @options={}, @active_record=Post>] ",
    "label": "",
    "id": "1594"
  },
  {
    "raw_code": "def clear_association_scope_cache # :nodoc:\n        delegate_reflection.clear_association_scope_cache\n        source_reflection.clear_association_scope_cache\n        through_reflection.clear_association_scope_cache\n      end",
    "comment": "This is for clearing cache on the reflection. Useful for tests that need to compare SQL queries on associations.",
    "label": "",
    "id": "1595"
  },
  {
    "raw_code": "def nested?\n        source_reflection.through_reflection? || through_reflection.through_reflection?\n      end",
    "comment": "A through association is nested if there would be more than one join table",
    "label": "",
    "id": "1596"
  },
  {
    "raw_code": "def association_primary_key(klass = nil)\n        # Get the \"actual\" source reflection if the immediate source reflection has a\n        # source reflection itself\n        if primary_key = actual_source_reflection.options[:primary_key]\n          @association_primary_key ||= -primary_key.to_s\n        else\n          primary_key(klass || self.klass)\n        end",
    "comment": "We want to use the klass from this reflection, rather than just delegate straight to the source_reflection, because the source_reflection may be polymorphic. We still need to respect the source_reflection's :primary_key option, though.",
    "label": "",
    "id": "1597"
  },
  {
    "raw_code": "def source_reflection_names\n        options[:source] ? [options[:source]] : [name.to_s.singularize, name].uniq\n      end",
    "comment": "Gets an array of possible <tt>:through</tt> source reflection names in both singular and plural form.  class Post < ActiveRecord::Base has_many :taggings has_many :tags, through: :taggings end  tags_reflection = Post.reflect_on_association(:tags) tags_reflection.source_reflection_names # => [:tag, :tags] ",
    "label": "",
    "id": "1598"
  },
  {
    "raw_code": "def new(attributes = nil, &block)\n      if attributes.is_a?(Array)\n        attributes.collect { |attr| new(attr, &block) }\n      else\n        block = current_scope_restoring_block(&block)\n        scoping { _new(attributes, &block) }\n      end",
    "comment": "Initializes new record from relation while maintaining the current scope.  Expects arguments in the same format as {ActiveRecord::Base.new}[rdoc-ref:Core.new].  users = User.where(name: 'DHH') user = users.new # => #<User id: nil, name: \"DHH\", created_at: nil, updated_at: nil>  You can also pass a block to new with the new record as argument:  user = users.new { |user| user.name = 'Oscar' } user.name # => Oscar",
    "label": "",
    "id": "1599"
  },
  {
    "raw_code": "def create(attributes = nil, &block)\n      if attributes.is_a?(Array)\n        attributes.collect { |attr| create(attr, &block) }\n      else\n        block = current_scope_restoring_block(&block)\n        scoping { _create(attributes, &block) }\n      end",
    "comment": "Tries to create a new record with the same scoped attributes defined in the relation. Returns the initialized object if validation fails.  Expects arguments in the same format as {ActiveRecord::Base.create}[rdoc-ref:Persistence::ClassMethods#create].  ==== Examples  users = User.where(name: 'Oscar') users.create # => #<User id: 3, name: \"Oscar\", ...>  users.create(name: 'fxn') users.create # => #<User id: 4, name: \"fxn\", ...>  users.create { |user| user.name = 'tenderlove' } # => #<User id: 5, name: \"tenderlove\", ...>  users.create(name: nil) # validation on name # => #<User id: nil, name: nil, ...>",
    "label": "",
    "id": "1600"
  },
  {
    "raw_code": "def create!(attributes = nil, &block)\n      if attributes.is_a?(Array)\n        attributes.collect { |attr| create!(attr, &block) }\n      else\n        block = current_scope_restoring_block(&block)\n        scoping { _create!(attributes, &block) }\n      end",
    "comment": "Similar to #create, but calls {create!}[rdoc-ref:Persistence::ClassMethods#create!] on the base class. Raises an exception if a validation error occurs.  Expects arguments in the same format as {ActiveRecord::Base.create!}[rdoc-ref:Persistence::ClassMethods#create!].",
    "label": "",
    "id": "1601"
  },
  {
    "raw_code": "def find_or_create_by(attributes, &block)\n      find_by(attributes) || create_or_find_by(attributes, &block)\n    end",
    "comment": "Finds the first record with the given attributes, or creates a record with the attributes if one is not found:  # Find the first user named \"Penélope\" or create a new one. User.find_or_create_by(first_name: 'Penélope') # => #<User id: 1, first_name: \"Penélope\", last_name: nil>  # Find the first user named \"Penélope\" or create a new one. # We already have one so the existing record will be returned. User.find_or_create_by(first_name: 'Penélope') # => #<User id: 1, first_name: \"Penélope\", last_name: nil>  # Find the first user named \"Scarlett\" or create a new one with # a particular last name. User.create_with(last_name: 'Johansson').find_or_create_by(first_name: 'Scarlett') # => #<User id: 2, first_name: \"Scarlett\", last_name: \"Johansson\">  This method accepts a block, which is passed down to #create. The last example above can be alternatively written this way:  # Find the first user named \"Scarlett\" or create a new one with a # particular last name. User.find_or_create_by(first_name: 'Scarlett') do |user| user.last_name = 'Johansson' end # => #<User id: 2, first_name: \"Scarlett\", last_name: \"Johansson\">  This method always returns a record, but if creation was attempted and failed due to validation errors it won't be persisted, you get what #create returns in such situation.  If creation failed because of a unique constraint, this method will assume it encountered a race condition and will try finding the record once more. If somehow the second find still does not find a record because a concurrent DELETE happened, it will then raise an ActiveRecord::RecordNotFound exception.  Please note <b>this method is not atomic</b>, it runs first a SELECT, and if there are no results an INSERT is attempted. So if the table doesn't have a relevant unique constraint it could be the case that you end up with two or more similar records.",
    "label": "",
    "id": "1602"
  },
  {
    "raw_code": "def find_or_create_by!(attributes, &block)\n      find_by(attributes) || create_or_find_by!(attributes, &block)\n    end",
    "comment": "Like #find_or_create_by, but calls {create!}[rdoc-ref:Persistence::ClassMethods#create!] so an exception is raised if the created record is invalid.",
    "label": "",
    "id": "1603"
  },
  {
    "raw_code": "def create_or_find_by(attributes, &block)\n      with_connection do |connection|\n        record = nil\n        transaction(requires_new: true) do\n          record = create(attributes, &block)\n          record._last_transaction_return_status || raise(ActiveRecord::Rollback)\n        end",
    "comment": "Attempts to create a record with the given attributes in a table that has a unique database constraint on one or several of its columns. If a row already exists with one or several of these unique constraints, the exception such an insertion would normally raise is caught, and the existing record with those attributes is found using #find_by!.  This is similar to #find_or_create_by, but tries to create the record first. As such it is better suited for cases where the record is most likely not to exist yet.  There are several drawbacks to #create_or_find_by, though:  * The underlying table must have the relevant columns defined with unique database constraints. * A unique constraint violation may be triggered by only one, or at least less than all, of the given attributes. This means that the subsequent #find_by! may fail to find a matching record, which will then raise an ActiveRecord::RecordNotFound exception, rather than a record with the given attributes. * While we avoid the race condition between SELECT -> INSERT from #find_or_create_by, we actually have another race condition between INSERT -> SELECT, which can be triggered if a DELETE between those two statements is run by another client. But for most applications, that's a significantly less likely condition to hit. * It relies on exception handling to handle control flow, which may be marginally slower. * The primary key may auto-increment on each create, even if it fails. This can accelerate the problem of running out of integers, if the underlying table is still stuck on a primary key of type int (note: All \\Rails apps since 5.1+ have defaulted to bigint, which is not liable to this problem). * Columns with unique database constraints should not have uniqueness validations defined, otherwise #create will fail due to validation errors and #find_by will never be called.  This method will return a record if all given attributes are covered by unique constraints (unless the INSERT -> DELETE -> SELECT race condition is triggered), but if creation was attempted and failed due to validation errors it won't be persisted, you get what #create returns in such situation.",
    "label": "",
    "id": "1604"
  },
  {
    "raw_code": "def create_or_find_by!(attributes, &block)\n      with_connection do |connection|\n        record = nil\n        transaction(requires_new: true) do\n          record = create!(attributes, &block)\n          record._last_transaction_return_status || raise(ActiveRecord::Rollback)\n        end",
    "comment": "Like #create_or_find_by, but calls {create!}[rdoc-ref:Persistence::ClassMethods#create!] so an exception is raised if the created record is invalid.",
    "label": "",
    "id": "1605"
  },
  {
    "raw_code": "def find_or_initialize_by(attributes, &block)\n      find_by(attributes) || new(attributes, &block)\n    end",
    "comment": "Like #find_or_create_by, but calls {new}[rdoc-ref:Core.new] instead of {create}[rdoc-ref:Persistence::ClassMethods#create].",
    "label": "",
    "id": "1606"
  },
  {
    "raw_code": "def explain(*options)\n      ExplainProxy.new(self, options)\n    end",
    "comment": "Runs EXPLAIN on the query or queries triggered by this relation and returns the result as a string. The string is formatted imitating the ones printed by the database shell.  User.all.explain # EXPLAIN SELECT `users`.* FROM `users` # ...  Note that this method actually runs the queries, since the results of some are needed by the next ones when eager loading is going on.  To run EXPLAIN on queries created by +first+, +pluck+ and +count+, call these methods on +explain+:  User.all.explain.count # EXPLAIN SELECT COUNT(*) FROM `users` # ...  The column name can be passed if required:  User.all.explain.maximum(:id) # EXPLAIN SELECT MAX(`users`.`id`) FROM `users` # ...  Please see further details in the {Active Record Query Interface guide}[https://guides.rubyonrails.org/active_record_querying.html#running-explain].",
    "label": "",
    "id": "1607"
  },
  {
    "raw_code": "def to_ary\n      records.dup\n    end",
    "comment": "Converts relation objects to Array.",
    "label": "",
    "id": "1608"
  },
  {
    "raw_code": "def encode_with(coder)\n      coder.represent_seq(nil, records)\n    end",
    "comment": "Serializes the relation objects Array.",
    "label": "",
    "id": "1609"
  },
  {
    "raw_code": "def size\n      if loaded?\n        records.length\n      else\n        count(:all)\n      end",
    "comment": "Returns size of the records.",
    "label": "",
    "id": "1610"
  },
  {
    "raw_code": "def empty?\n      return true if @none\n\n      if loaded?\n        records.empty?\n      else\n        !exists?\n      end",
    "comment": "Returns true if there are no records.",
    "label": "",
    "id": "1611"
  },
  {
    "raw_code": "def none?(*args)\n      return true if @none\n\n      return super if args.present? || block_given?\n      empty?\n    end",
    "comment": "Returns true if there are no records.  When a pattern argument is given, this method checks whether elements in the Enumerable match the pattern via the case-equality operator (<tt>===</tt>).  posts.none?(Comment) # => true or false",
    "label": "",
    "id": "1612"
  },
  {
    "raw_code": "def any?(*args)\n      return false if @none\n\n      return super if args.present? || block_given?\n      !empty?\n    end",
    "comment": "Returns true if there are any records.  When a pattern argument is given, this method checks whether elements in the Enumerable match the pattern via the case-equality operator (<tt>===</tt>).  posts.any?(Post) # => true or false",
    "label": "",
    "id": "1613"
  },
  {
    "raw_code": "def one?(*args)\n      return false if @none\n\n      return super if args.present? || block_given?\n      return records.one? if loaded?\n      limited_count == 1\n    end",
    "comment": "Returns true if there is exactly one record.  When a pattern argument is given, this method checks whether elements in the Enumerable match the pattern via the case-equality operator (<tt>===</tt>).  posts.one?(Post) # => true or false",
    "label": "",
    "id": "1614"
  },
  {
    "raw_code": "def many?\n      return false if @none\n\n      return super if block_given?\n      return records.many? if loaded?\n      limited_count > 1\n    end",
    "comment": "Returns true if there is more than one record.",
    "label": "",
    "id": "1615"
  },
  {
    "raw_code": "def cache_key(timestamp_column = \"updated_at\")\n      @cache_keys ||= {}\n      @cache_keys[timestamp_column] ||= model.collection_cache_key(self, timestamp_column)\n    end",
    "comment": "Returns a stable cache key that can be used to identify this query. The cache key is built with a fingerprint of the SQL query.  Product.where(\"name like ?\", \"%Cosmic Encounter%\").cache_key # => \"products/query-1850ab3d302391b85b8693e941286659\"  If ActiveRecord::Base.collection_cache_versioning is turned off, as it was in \\Rails 6.0 and earlier, the cache key will also include a version.  ActiveRecord::Base.collection_cache_versioning = false Product.where(\"name like ?\", \"%Cosmic Encounter%\").cache_key # => \"products/query-1850ab3d302391b85b8693e941286659-1-20150714212553907087000\"  You can also pass a custom timestamp column to fetch the timestamp of the last updated record.  Product.where(\"name like ?\", \"%Game%\").cache_key(:last_reviewed_at)",
    "label": "",
    "id": "1616"
  },
  {
    "raw_code": "def cache_version(timestamp_column = :updated_at)\n      if model.collection_cache_versioning\n        @cache_versions ||= {}\n        @cache_versions[timestamp_column] ||= compute_cache_version(timestamp_column)\n      end",
    "comment": "Returns a cache version that can be used together with the cache key to form a recyclable caching scheme. The cache version is built with the number of records matching the query, and the timestamp of the last updated record. When a new record comes to match the query, or any of the existing records is updated or deleted, the cache version changes.  If the collection is loaded, the method will iterate through the records to generate the timestamp, otherwise it will trigger one SQL query like:  SELECT COUNT(*), MAX(\"products\".\"updated_at\") FROM \"products\" WHERE (name like '%Cosmic Encounter%')",
    "label": "",
    "id": "1617"
  },
  {
    "raw_code": "def cache_key_with_version\n      if version = cache_version\n        \"#{cache_key}-#{version}\"\n      else\n        cache_key\n      end",
    "comment": "Returns a cache key along with the version.",
    "label": "",
    "id": "1618"
  },
  {
    "raw_code": "def scoping(all_queries: nil, &block)\n      registry = model.scope_registry\n      if global_scope?(registry) && all_queries == false\n        raise ArgumentError, \"Scoping is set to apply to all queries and cannot be unset in a nested block.\"\n      elsif already_in_scope?(registry)\n        yield\n      else\n        _scoping(self, registry, all_queries, &block)\n      end",
    "comment": "Scope all queries to the current scope.  Comment.where(post_id: 1).scoping do Comment.first end # SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"post_id\" = 1 ORDER BY \"comments\".\"id\" ASC LIMIT 1  If <tt>all_queries: true</tt> is passed, scoping will apply to all queries for the relation including +update+ and +delete+ on instances. Once +all_queries+ is set to true it cannot be set to false in a nested block.  Please check unscoped if you want to remove all previous scopes (including the default_scope) during the execution of a block.",
    "label": "",
    "id": "1619"
  },
  {
    "raw_code": "def update_all(updates)\n      raise ArgumentError, \"Empty list of attributes to change\" if updates.blank?\n\n      return 0 if @none\n\n      invalid_methods = INVALID_METHODS_FOR_UPDATE_AND_DELETE_ALL.select do |method|\n        value = @values[method]\n        method == :distinct ? value : value&.any?\n      end",
    "comment": "Updates all records in the current relation with details given. This method constructs a single SQL UPDATE statement and sends it straight to the database. It does not instantiate the involved models and it does not trigger Active Record callbacks or validations. However, values passed to #update_all will still go through Active Record's normal type casting and serialization. Returns the number of rows affected.  Note: As Active Record callbacks are not triggered, this method will not automatically update +updated_at+/+updated_on+ columns.  ==== Parameters  * +updates+ - A string, array, or hash representing the SET part of an SQL statement. Any strings provided will be type cast, unless you use +Arel.sql+. (Don't pass user-provided values to +Arel.sql+.)  ==== Examples  # Update all customers with the given attributes Customer.update_all wants_email: true  # Update all books with 'Rails' in their title Book.where('title LIKE ?', '%Rails%').update_all(author: 'David')  # Update all books that match conditions, but limit it to 5 ordered by date Book.where('title LIKE ?', '%Rails%').order(:created_at).limit(5).update_all(author: 'David')  # Update all invoices and set the number column to its id value. Invoice.update_all('number = id')  # Update all books with 'Rails' in their title Book.where('title LIKE ?', '%Rails%').update_all(title: Arel.sql(\"title + ' - volume 1'\"))",
    "label": "",
    "id": "1620"
  },
  {
    "raw_code": "def insert(attributes, returning: nil, unique_by: nil, record_timestamps: nil)\n      insert_all([ attributes ], returning: returning, unique_by: unique_by, record_timestamps: record_timestamps)\n    end",
    "comment": "Inserts a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record's type casting and serialization.  See #insert_all for documentation.",
    "label": "",
    "id": "1621"
  },
  {
    "raw_code": "def insert_all(attributes, returning: nil, unique_by: nil, record_timestamps: nil)\n      InsertAll.execute(self, attributes, on_duplicate: :skip, returning: returning, unique_by: unique_by, record_timestamps: record_timestamps)\n    end",
    "comment": "Inserts multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record's type casting and serialization.  The +attributes+ parameter is an Array of Hashes. Every Hash determines the attributes for a single row and must have the same keys.  Rows are considered to be unique by every unique index on the table. Any duplicate rows are skipped. Override with <tt>:unique_by</tt> (see below).  Returns an ActiveRecord::Result with its contents based on <tt>:returning</tt> (see below).  ==== Options  [:returning] (PostgreSQL, SQLite3, and MariaDB only) An array of attributes to return for all successfully inserted records, which by default is the primary key. Pass <tt>returning: %w[ id name ]</tt> for both id and name or <tt>returning: false</tt> to omit the underlying <tt>RETURNING</tt> SQL clause entirely.  You can also pass an SQL string if you need more control on the return values (for example, <tt>returning: Arel.sql(\"id, name as new_name\")</tt>).  [:unique_by] (PostgreSQL and SQLite only) By default rows are considered to be unique by every unique index on the table. Any duplicate rows are skipped.  To skip rows according to just one unique index pass <tt>:unique_by</tt>.  Consider a Book model where no duplicate ISBNs make sense, but if any row has an existing id, or is not unique by another unique index, ActiveRecord::RecordNotUnique is raised.  Unique indexes can be identified by columns or name:  unique_by: :isbn unique_by: %i[ author_id name ] unique_by: :index_books_on_isbn  [:record_timestamps] By default, automatic setting of timestamp columns is controlled by the model's <tt>record_timestamps</tt> config, matching typical behavior.  To override this and force automatic setting of timestamp columns one way or the other, pass <tt>:record_timestamps</tt>:  record_timestamps: true  # Always set timestamps automatically record_timestamps: false # Never set timestamps automatically  Because it relies on the index information from the database <tt>:unique_by</tt> is recommended to be paired with Active Record's schema_cache.  ==== Example  # Insert records and skip inserting any duplicates. # Here \"Eloquent Ruby\" is skipped because its id is not unique.  Book.insert_all([ { id: 1, title: \"Rework\", author: \"David\" }, { id: 1, title: \"Eloquent Ruby\", author: \"Russ\" } ])  # insert_all works on chained scopes, and you can use create_with # to set default attributes for all inserted records.  author.books.create_with(created_at: Time.now).insert_all([ { id: 1, title: \"Rework\" }, { id: 2, title: \"Eloquent Ruby\" } ])",
    "label": "",
    "id": "1622"
  },
  {
    "raw_code": "def insert!(attributes, returning: nil, record_timestamps: nil)\n      insert_all!([ attributes ], returning: returning, record_timestamps: record_timestamps)\n    end",
    "comment": "Inserts a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record's type casting and serialization.  See #insert_all! for more.",
    "label": "",
    "id": "1623"
  },
  {
    "raw_code": "def insert_all!(attributes, returning: nil, record_timestamps: nil)\n      InsertAll.execute(self, attributes, on_duplicate: :raise, returning: returning, record_timestamps: record_timestamps)\n    end",
    "comment": "Inserts multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record's type casting and serialization.  The +attributes+ parameter is an Array of Hashes. Every Hash determines the attributes for a single row and must have the same keys.  Raises ActiveRecord::RecordNotUnique if any rows violate a unique index on the table. In that case, no rows are inserted.  To skip duplicate rows, see #insert_all. To replace them, see #upsert_all.  Returns an ActiveRecord::Result with its contents based on <tt>:returning</tt> (see below).  ==== Options  [:returning] (PostgreSQL, SQLite3, and MariaDB only) An array of attributes to return for all successfully inserted records, which by default is the primary key. Pass <tt>returning: %w[ id name ]</tt> for both id and name or <tt>returning: false</tt> to omit the underlying <tt>RETURNING</tt> SQL clause entirely.  You can also pass an SQL string if you need more control on the return values (for example, <tt>returning: Arel.sql(\"id, name as new_name\")</tt>).  [:record_timestamps] By default, automatic setting of timestamp columns is controlled by the model's <tt>record_timestamps</tt> config, matching typical behavior.  To override this and force automatic setting of timestamp columns one way or the other, pass <tt>:record_timestamps</tt>:  record_timestamps: true  # Always set timestamps automatically record_timestamps: false # Never set timestamps automatically  ==== Examples  # Insert multiple records Book.insert_all!([ { title: \"Rework\", author: \"David\" }, { title: \"Eloquent Ruby\", author: \"Russ\" } ])  # Raises ActiveRecord::RecordNotUnique because \"Eloquent Ruby\" # does not have a unique id. Book.insert_all!([ { id: 1, title: \"Rework\", author: \"David\" }, { id: 1, title: \"Eloquent Ruby\", author: \"Russ\" } ])",
    "label": "",
    "id": "1624"
  },
  {
    "raw_code": "def upsert(attributes, **kwargs)\n      upsert_all([ attributes ], **kwargs)\n    end",
    "comment": "Updates or inserts (upserts) a single record into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record's type casting and serialization.  See #upsert_all for documentation.",
    "label": "",
    "id": "1625"
  },
  {
    "raw_code": "def upsert_all(attributes, on_duplicate: :update, update_only: nil, returning: nil, unique_by: nil, record_timestamps: nil)\n      InsertAll.execute(self, attributes, on_duplicate: on_duplicate, update_only: update_only, returning: returning, unique_by: unique_by, record_timestamps: record_timestamps)\n    end",
    "comment": "Updates or inserts (upserts) multiple records into the database in a single SQL INSERT statement. It does not instantiate any models nor does it trigger Active Record callbacks or validations. Though passed values go through Active Record's type casting and serialization.  The +attributes+ parameter is an Array of Hashes. Every Hash determines the attributes for a single row and must have the same keys.  Returns an ActiveRecord::Result with its contents based on <tt>:returning</tt> (see below).  By default, +upsert_all+ will update all the columns that can be updated when there is a conflict. These are all the columns except primary keys, read-only columns, and columns covered by the optional +unique_by+.  ==== Options  [:returning] (PostgreSQL, SQLite3, and MariaDB only) An array of attributes to return for all successfully upserted records, which by default is the primary key. Pass <tt>returning: %w[ id name ]</tt> for both id and name or <tt>returning: false</tt> to omit the underlying <tt>RETURNING</tt> SQL clause entirely.  You can also pass an SQL string if you need more control on the return values (for example, <tt>returning: Arel.sql(\"id, name as new_name\")</tt>).  [:unique_by] (PostgreSQL and SQLite only) By default rows are considered to be unique by every unique index on the table. Any duplicate rows are skipped.  To skip rows according to just one unique index pass <tt>:unique_by</tt>.  Consider a Book model where no duplicate ISBNs make sense, but if any row has an existing id, or is not unique by another unique index, ActiveRecord::RecordNotUnique is raised.  Unique indexes can be identified by columns or name:  unique_by: :isbn unique_by: %i[ author_id name ] unique_by: :index_books_on_isbn  Because it relies on the index information from the database <tt>:unique_by</tt> is recommended to be paired with Active Record's schema_cache.  [:on_duplicate] Configure the SQL update sentence that will be used in case of conflict.  NOTE: If you use this option you must provide all the columns you want to update by yourself.  Example:  Commodity.upsert_all( [ { id: 2, name: \"Copper\", price: 4.84 }, { id: 4, name: \"Gold\", price: 1380.87 }, { id: 6, name: \"Aluminium\", price: 0.35 } ], on_duplicate: Arel.sql(\"price = GREATEST(commodities.price, EXCLUDED.price)\") )  See the related +:update_only+ option. Both options can't be used at the same time.  [:update_only] Provide a list of column names that will be updated in case of conflict. If not provided, +upsert_all+ will update all the columns that can be updated. These are all the columns except primary keys, read-only columns, and columns covered by the optional +unique_by+  Example:  Commodity.upsert_all( [ { id: 2, name: \"Copper\", price: 4.84 }, { id: 4, name: \"Gold\", price: 1380.87 }, { id: 6, name: \"Aluminium\", price: 0.35 } ], update_only: [:price] # Only prices will be updated )  See the related +:on_duplicate+ option. Both options can't be used at the same time.  [:record_timestamps] By default, automatic setting of timestamp columns is controlled by the model's <tt>record_timestamps</tt> config, matching typical behavior.  To override this and force automatic setting of timestamp columns one way or the other, pass <tt>:record_timestamps</tt>:  record_timestamps: true  # Always set timestamps automatically record_timestamps: false # Never set timestamps automatically  ==== Examples  # Inserts multiple records, performing an upsert when records have duplicate ISBNs. # Here \"Eloquent Ruby\" overwrites \"Rework\" because its ISBN is duplicate.  Book.upsert_all([ { title: \"Rework\", author: \"David\", isbn: \"1\" }, { title: \"Eloquent Ruby\", author: \"Russ\", isbn: \"1\" } ], unique_by: :isbn)  Book.find_by(isbn: \"1\").title # => \"Eloquent Ruby\"",
    "label": "",
    "id": "1626"
  },
  {
    "raw_code": "def update_counters(counters)\n      touch = counters.delete(:touch)\n\n      updates = {}\n      counters.each do |counter_name, value|\n        attr = table[counter_name]\n        updates[attr.name] = _increment_attribute(attr, value)\n      end",
    "comment": "Updates the counters of the records in the current relation.  ==== Parameters  * +counter+ - A Hash containing the names of the fields to update as keys and the amount to update as values. * <tt>:touch</tt> option - Touch the timestamp columns when updating. * If attributes names are passed, they are updated along with update_at/on attributes.  ==== Examples  # For Posts by a given author increment the comment_count by 1. Post.where(author_id: author.id).update_counters(comment_count: 1)",
    "label": "",
    "id": "1627"
  },
  {
    "raw_code": "def touch_all(*names, time: nil)\n      update_all model.touch_attributes_with_time(*names, time: time)\n    end",
    "comment": "Touches all records in the current relation, setting the +updated_at+/+updated_on+ attributes to the current time or the time specified. It does not instantiate the involved models, and it does not trigger Active Record callbacks or validations. This method can be passed attribute names and an optional time argument. If attribute names are passed, they are updated along with +updated_at+/+updated_on+ attributes. If no time argument is passed, the current time is used as default.  ==== Examples  # Touch all records Person.all.touch_all # => \"UPDATE \\\"people\\\" SET \\\"updated_at\\\" = '2018-01-04 22:55:23.132670'\"  # Touch multiple records with a custom attribute Person.all.touch_all(:created_at) # => \"UPDATE \\\"people\\\" SET \\\"updated_at\\\" = '2018-01-04 22:55:23.132670', \\\"created_at\\\" = '2018-01-04 22:55:23.132670'\"  # Touch multiple records with a specified time Person.all.touch_all(time: Time.new(2020, 5, 16, 0, 0, 0)) # => \"UPDATE \\\"people\\\" SET \\\"updated_at\\\" = '2020-05-16 00:00:00'\"  # Touch records with scope Person.where(name: 'David').touch_all # => \"UPDATE \\\"people\\\" SET \\\"updated_at\\\" = '2018-01-04 22:55:23.132670' WHERE \\\"people\\\".\\\"name\\\" = 'David'\"",
    "label": "",
    "id": "1628"
  },
  {
    "raw_code": "def destroy_all\n      records.each(&:destroy).tap { reset }\n    end",
    "comment": "Destroys the records by instantiating each record and calling its {#destroy}[rdoc-ref:Persistence#destroy] method. Each object's callbacks are executed (including <tt>:dependent</tt> association options). Returns the collection of objects that were destroyed; each will be frozen, to reflect that no changes should be made (since they can't be persisted).  Note: Instantiation, callback execution, and deletion of each record can be time consuming when you're removing many records at once. It generates at least one SQL +DELETE+ query per record (or possibly more, to enforce your callbacks). If you want to delete many rows quickly, without concern for their associations or callbacks, use #delete_all instead.  ==== Examples  Person.where(age: 0..18).destroy_all",
    "label": "",
    "id": "1629"
  },
  {
    "raw_code": "def delete_all\n      return 0 if @none\n\n      invalid_methods = INVALID_METHODS_FOR_UPDATE_AND_DELETE_ALL.select do |method|\n        value = @values[method]\n        method == :distinct ? value : value&.any?\n      end",
    "comment": "Deletes the records without instantiating the records first, and hence not calling the {#destroy}[rdoc-ref:Persistence#destroy] method nor invoking callbacks. This is a single SQL DELETE statement that goes straight to the database, much more efficient than #destroy_all. Be careful with relations though, in particular <tt>:dependent</tt> rules defined on associations are not honored. Returns the number of rows affected.  Post.where(person_id: 5).where(category: ['Something', 'Else']).delete_all  Both calls delete the affected posts all at once with a single DELETE statement. If you need to destroy dependent associations or call your <tt>before_*</tt> or +after_destroy+ callbacks, use the #destroy_all method instead.  If an invalid method is supplied, #delete_all raises an ActiveRecordError:  Post.distinct.delete_all # => ActiveRecord::ActiveRecordError: delete_all doesn't support distinct",
    "label": "",
    "id": "1630"
  },
  {
    "raw_code": "def delete(id_or_array)\n      return 0 if id_or_array.nil? || (id_or_array.is_a?(Array) && id_or_array.empty?)\n\n      where(model.primary_key => id_or_array).delete_all\n    end",
    "comment": "Deletes the row with a primary key matching the +id+ argument, using an SQL +DELETE+ statement, and returns the number of rows deleted. Active Record objects are not instantiated, so the object's callbacks are not executed, including any <tt>:dependent</tt> association options.  You can delete multiple rows at once by passing an Array of <tt>id</tt>s.  Note: Although it is often much faster than the alternative, #destroy, skipping callbacks might bypass business logic in your application that ensures referential integrity or performs other essential jobs.  ==== Examples  # Delete a single row Todo.delete(1)  # Delete multiple rows Todo.delete([2,3,4])",
    "label": "",
    "id": "1631"
  },
  {
    "raw_code": "def destroy(id)\n      multiple_ids = if model.composite_primary_key?\n        id.first.is_a?(Array)\n      else\n        id.is_a?(Array)\n      end",
    "comment": "Destroy an object (or multiple objects) that has the given id. The object is instantiated first, therefore all callbacks and filters are fired off before the object is deleted. This method is less efficient than #delete but allows cleanup methods and other actions to be run.  This essentially finds the object (or multiple objects) with the given id, creates a new object from the attributes, and then calls destroy on it.  ==== Parameters  * +id+ - This should be the id or an array of ids to be destroyed.  ==== Examples  # Destroy a single object Todo.destroy(1)  # Destroy multiple objects todos = [1,2,3] Todo.destroy(todos)",
    "label": "",
    "id": "1632"
  },
  {
    "raw_code": "def destroy_by(*args)\n      where(*args).destroy_all\n    end",
    "comment": "Finds and destroys all records matching the specified conditions. This is short-hand for <tt>relation.where(condition).destroy_all</tt>. Returns the collection of objects that were destroyed.  If no record is found, returns empty array.  Person.destroy_by(id: 13) Person.destroy_by(name: 'Spartacus', rating: 4) Person.destroy_by(\"published_at < ?\", 2.weeks.ago)",
    "label": "",
    "id": "1633"
  },
  {
    "raw_code": "def delete_by(*args)\n      where(*args).delete_all\n    end",
    "comment": "Finds and deletes all records matching the specified conditions. This is short-hand for <tt>relation.where(condition).delete_all</tt>. Returns the number of rows affected.  If no record is found, returns <tt>0</tt> as zero rows were affected.  Person.delete_by(id: 13) Person.delete_by(name: 'Spartacus', rating: 4) Person.delete_by(\"published_at < ?\", 2.weeks.ago)",
    "label": "",
    "id": "1634"
  },
  {
    "raw_code": "def load_async\n      with_connection do |c|\n        return load if !c.async_enabled?\n\n        unless loaded?\n          result = exec_main_query(async: !c.current_transaction.joinable?)\n\n          if result.is_a?(Array)\n            @records = result\n          else\n            @future_result = result\n          end",
    "comment": "Schedule the query to be performed from a background thread pool.  Post.where(published: true).load_async # => #<ActiveRecord::Relation>  When the +Relation+ is iterated, if the background query wasn't executed yet, it will be performed by the foreground thread.  Note that {config.active_record.async_query_executor}[https://guides.rubyonrails.org/configuring.html#config-active-record-async-query-executor] must be configured for queries to actually be executed concurrently. Otherwise it defaults to executing them in the foreground.  If the query was actually executed in the background, the Active Record logs will show it by prefixing the log line with <tt>ASYNC</tt>:  ASYNC Post Load (0.0ms) (db time 2ms)  SELECT \"posts\".* FROM \"posts\" LIMIT 100",
    "label": "",
    "id": "1635"
  },
  {
    "raw_code": "def scheduled?\n      !!@future_result\n    end",
    "comment": "Returns <tt>true</tt> if the relation was scheduled on the background thread pool.",
    "label": "",
    "id": "1636"
  },
  {
    "raw_code": "def load(&block)\n      if !loaded? || scheduled?\n        @records = exec_queries(&block)\n        @loaded = true\n      end",
    "comment": "Causes the records to be loaded from the database if they have not been loaded already. You can use this if for some reason you need to explicitly load some records before actually using them. The return value is the relation itself, not the records.  Post.where(published: true).load # => #<ActiveRecord::Relation>",
    "label": "",
    "id": "1637"
  },
  {
    "raw_code": "def reload\n      reset\n      load\n    end",
    "comment": "Forces reloading of relation.",
    "label": "",
    "id": "1638"
  },
  {
    "raw_code": "def to_sql\n      @to_sql ||= if eager_loading?\n        apply_join_dependency do |relation, join_dependency|\n          relation = join_dependency.apply_column_aliases(relation)\n          relation.to_sql\n        end",
    "comment": "Returns sql statement for the relation.  User.where(name: 'Oscar').to_sql # SELECT \"users\".* FROM \"users\"  WHERE \"users\".\"name\" = 'Oscar'",
    "label": "",
    "id": "1639"
  },
  {
    "raw_code": "def where_values_hash(relation_table_name = model.table_name) # :nodoc:\n      where_clause.to_h(relation_table_name)\n    end",
    "comment": "Returns a hash of where conditions.  User.where(name: 'Oscar').where_values_hash # => {name: \"Oscar\"}",
    "label": "",
    "id": "1640"
  },
  {
    "raw_code": "def eager_loading?\n      @should_eager_load ||=\n        eager_load_values.any? ||\n        includes_values.any? && (joined_includes_values.any? || references_eager_loaded_tables?)\n    end",
    "comment": "Returns true if relation needs eager loading.",
    "label": "",
    "id": "1641"
  },
  {
    "raw_code": "def joined_includes_values\n      includes_values & joins_values\n    end",
    "comment": "Joins that are also marked for preloading. In which case we should just eager load them. Note that this is a naive implementation because we could have strings and symbols which represent the same association, but that aren't matched by this. Also, we could have nested hashes which partially match, e.g. <tt>{ a: :b } & { a: [:b, :c] }</tt>",
    "label": "",
    "id": "1642"
  },
  {
    "raw_code": "def ==(other)\n      case other\n      when Associations::CollectionProxy, AssociationRelation\n        self == other.records\n      when Relation\n        other.to_sql == to_sql\n      when Array\n        records == other\n      end",
    "comment": "Compares two relations for equality.",
    "label": "",
    "id": "1643"
  },
  {
    "raw_code": "def blank?\n      records.blank?\n    end",
    "comment": "Returns true if relation is blank.",
    "label": "",
    "id": "1644"
  },
  {
    "raw_code": "def includes_column?(name)\n      @columns.include? name\n    end",
    "comment": "Returns true if this result set includes the column named +name+",
    "label": "",
    "id": "1645"
  },
  {
    "raw_code": "def length\n      @rows.length\n    end",
    "comment": "Returns the number of elements in the rows array.",
    "label": "",
    "id": "1646"
  },
  {
    "raw_code": "def each(&block)\n      if block_given?\n        hash_rows.each(&block)\n      else\n        hash_rows.to_enum { @rows.size }\n      end",
    "comment": "Calls the given block once for each element in row collection, passing row as parameter. Each row is a Hash-like, read only object.  To get real hashes, use +.to_a.each+.  Returns an +Enumerator+ if no block is given.",
    "label": "",
    "id": "1647"
  },
  {
    "raw_code": "def empty?\n      rows.empty?\n    end",
    "comment": "Returns true if there are no records, otherwise false.",
    "label": "",
    "id": "1648"
  },
  {
    "raw_code": "def to_ary\n      hash_rows\n    end",
    "comment": "Returns an array of hashes representing each row record.",
    "label": "",
    "id": "1649"
  },
  {
    "raw_code": "def last(n = nil)\n      n ? hash_rows.last(n) : hash_rows.last\n    end",
    "comment": "Returns the last record from the rows collection.",
    "label": "",
    "id": "1650"
  },
  {
    "raw_code": "def column_types\n      if @column_types\n        @types_hash ||= begin\n          types = {}\n          @columns.each_with_index do |name, index|\n            type = @column_types[index] || Type.default_value\n            types[name] = types[index] = type\n          end",
    "comment": "Returns the +ActiveRecord::Type+ type of all columns. Note that not all database adapters return the result types, so the hash may be empty.",
    "label": "",
    "id": "1651"
  },
  {
    "raw_code": "def sanitize_sql_for_conditions(condition)\n        return nil if condition.blank?\n\n        case condition\n        when Array; sanitize_sql_array(condition)\n        else        condition\n        end",
    "comment": "Accepts an array of SQL conditions and sanitizes them into a valid SQL fragment for a WHERE clause.  sanitize_sql_for_conditions([\"name=? and group_id=?\", \"foo'bar\", 4]) # => \"name='foo''bar' and group_id=4\"  sanitize_sql_for_conditions([\"name=:name and group_id=:group_id\", name: \"foo'bar\", group_id: 4]) # => \"name='foo''bar' and group_id='4'\"  sanitize_sql_for_conditions([\"name='%s' and group_id='%s'\", \"foo'bar\", 4]) # => \"name='foo''bar' and group_id='4'\"  This method will NOT sanitize an SQL string since it won't contain any conditions in it and will return the string as is.  sanitize_sql_for_conditions(\"name='foo''bar' and group_id='4'\") # => \"name='foo''bar' and group_id='4'\"  Note that this sanitization method is not schema-aware, hence won't do any type casting and will directly use the database adapter's +quote+ method. For MySQL specifically this means that numeric parameters will be quoted as strings to prevent query manipulation attacks.  sanitize_sql_for_conditions([\"role = ?\", 0]) # => \"role = '0'\"",
    "label": "",
    "id": "1652"
  },
  {
    "raw_code": "def sanitize_sql_for_assignment(assignments, default_table_name = table_name)\n        case assignments\n        when Array; sanitize_sql_array(assignments)\n        when Hash;  sanitize_sql_hash_for_assignment(assignments, default_table_name)\n        else        assignments\n        end",
    "comment": "Accepts an array or hash of SQL conditions and sanitizes them into a valid SQL fragment for a SET clause.  sanitize_sql_for_assignment([\"name=? and group_id=?\", nil, 4]) # => \"name=NULL and group_id=4\"  sanitize_sql_for_assignment([\"name=:name and group_id=:group_id\", name: nil, group_id: 4]) # => \"name=NULL and group_id=4\"  Post.sanitize_sql_for_assignment({ name: nil, group_id: 4 }) # => \"`posts`.`name` = NULL, `posts`.`group_id` = 4\"  This method will NOT sanitize an SQL string since it won't contain any conditions in it and will return the string as is.  sanitize_sql_for_assignment(\"name=NULL and group_id='4'\") # => \"name=NULL and group_id='4'\"  Note that this sanitization method is not schema-aware, hence won't do any type casting and will directly use the database adapter's +quote+ method. For MySQL specifically this means that numeric parameters will be quoted as strings to prevent query manipulation attacks.  sanitize_sql_for_assignment([\"role = ?\", 0]) # => \"role = '0'\"",
    "label": "",
    "id": "1653"
  },
  {
    "raw_code": "def sanitize_sql_for_order(condition)\n        if condition.is_a?(Array) && condition.first.to_s.include?(\"?\")\n          disallow_raw_sql!(\n            [condition.first],\n            permit: adapter_class.column_name_with_order_matcher\n          )\n\n          # Ensure we aren't dealing with a subclass of String that might\n          # override methods we use (e.g. Arel::Nodes::SqlLiteral).\n          if condition.first.kind_of?(String) && !condition.first.instance_of?(String)\n            condition = [String.new(condition.first), *condition[1..-1]]\n          end",
    "comment": "Accepts an array, or string of SQL conditions and sanitizes them into a valid SQL fragment for an ORDER clause.  sanitize_sql_for_order([Arel.sql(\"field(id, ?)\"), [1,3,2]]) # => \"field(id, 1,3,2)\"  sanitize_sql_for_order(\"id ASC\") # => \"id ASC\"",
    "label": "",
    "id": "1654"
  },
  {
    "raw_code": "def sanitize_sql_hash_for_assignment(attrs, table)\n        with_connection do |c|\n          attrs.map do |attr, value|\n            type = type_for_attribute(attr)\n            value = type.serialize(type.cast(value))\n            \"#{c.quote_table_name_for_assignment(table, attr)} = #{c.quote(value)}\"\n          end.join(\", \")\n        end",
    "comment": "Sanitizes a hash of attribute/value pairs into SQL conditions for a SET clause.  sanitize_sql_hash_for_assignment({ status: nil, group_id: 1 }, \"posts\") # => \"`posts`.`status` = NULL, `posts`.`group_id` = 1\"",
    "label": "",
    "id": "1655"
  },
  {
    "raw_code": "def sanitize_sql_like(string, escape_character = \"\\\\\")\n        if string.include?(escape_character) && escape_character != \"%\" && escape_character != \"_\"\n          string = string.gsub(escape_character, '\\0\\0')\n        end",
    "comment": "Sanitizes a +string+ so that it is safe to use within an SQL LIKE statement. This method uses +escape_character+ to escape all occurrences of itself, \"_\" and \"%\".  sanitize_sql_like(\"100% true!\") # => \"100\\\\% true!\"  sanitize_sql_like(\"snake_cased_string\") # => \"snake\\\\_cased\\\\_string\"  sanitize_sql_like(\"100% true!\", \"!\") # => \"100!% true!!\"  sanitize_sql_like(\"snake_cased_string\", \"!\") # => \"snake!_cased!_string\"",
    "label": "",
    "id": "1656"
  },
  {
    "raw_code": "def sanitize_sql_array(ary)\n        statement, *values = ary\n        if values.first.is_a?(Hash) && /:\\w+/.match?(statement)\n          with_connection do |c|\n            replace_named_bind_variables(c, statement, values.first)\n          end",
    "comment": "Accepts an array of conditions. The array has each value sanitized and interpolated into the SQL statement. If using named bind variables in SQL statements where a colon is required verbatim use a backslash to escape.  sanitize_sql_array([\"name=? and group_id=?\", \"foo'bar\", 4]) # => \"name='foo''bar' and group_id=4\"  sanitize_sql_array([\"name=:name and group_id=:group_id\", name: \"foo'bar\", group_id: 4]) # => \"name='foo''bar' and group_id=4\"  sanitize_sql_array([\"TO_TIMESTAMP(:date, 'YYYY/MM/DD HH12\\\\:MI\\\\:SS')\", date: \"foo\"]) # => \"TO_TIMESTAMP('foo', 'YYYY/MM/DD HH12:MI:SS')\"  sanitize_sql_array([\"name='%s' and group_id='%s'\", \"foo'bar\", 4]) # => \"name='foo''bar' and group_id='4'\"  Note that this sanitization method is not schema-aware, hence won't do any type casting and will directly use the database adapter's +quote+ method. For MySQL specifically this means that numeric parameters will be quoted as strings to prevent query manipulation attacks.  sanitize_sql_array([\"role = ?\", 0]) # => \"role = '0'\"  Before using this method, please consider if Arel.sql would be better for your use-case",
    "label": "",
    "id": "1657"
  },
  {
    "raw_code": "def define(info = {}, &block)\n          new.define(info, &block)\n        end",
    "comment": "Eval the given block. All methods available to the current connection adapter are available within the block, so you can easily use the database definition DSL to build up your schema ( {create_table}[rdoc-ref:ConnectionAdapters::SchemaStatements#create_table], {add_index}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_index], etc.).  The +info+ hash is optional, and if given is used to define metadata about the current schema (currently, only the schema's version):  ActiveRecord::Schema[7.0].define(version: 2038_01_19_000001) do ... end",
    "label": "",
    "id": "1658"
  },
  {
    "raw_code": "def formatted_version\n        stringified = @version.to_s\n        return stringified unless stringified.length == 14\n        stringified.insert(4, \"_\").insert(7, \"_\").insert(10, \"_\")\n      end",
    "comment": "turns 20170404131909 into \"2017_04_04_131909\"",
    "label": "",
    "id": "1659"
  },
  {
    "raw_code": "def extensions(stream)\n      end",
    "comment": "extensions are only supported by PostgreSQL",
    "label": "",
    "id": "1660"
  },
  {
    "raw_code": "def types(stream)\n      end",
    "comment": "(enum) types are only supported by PostgreSQL",
    "label": "",
    "id": "1661"
  },
  {
    "raw_code": "def schemas(stream)\n      end",
    "comment": "schemas are only supported by PostgreSQL",
    "label": "",
    "id": "1662"
  },
  {
    "raw_code": "def virtual_tables(stream)\n      end",
    "comment": "virtual tables are only supported by SQLite",
    "label": "",
    "id": "1663"
  },
  {
    "raw_code": "def indexes(table, stream)\n        if (indexes = @connection.indexes(table)).any?\n          add_index_statements = indexes.map do |index|\n            table_name = remove_prefix_and_suffix(index.table).inspect\n            \"  add_index #{([relation_name(table_name)] + index_parts(index)).join(', ')}\"\n          end",
    "comment": "Keep it for indexing materialized views",
    "label": "",
    "id": "1664"
  },
  {
    "raw_code": "def scope_attributes\n        all.scope_for_create\n      end",
    "comment": "Collects attributes from scopes that should be applied when creating an AR instance for the particular class this is called on.",
    "label": "",
    "id": "1665"
  },
  {
    "raw_code": "def scope_attributes?\n        current_scope\n      end",
    "comment": "Are there attributes associated with this scope?",
    "label": "",
    "id": "1666"
  },
  {
    "raw_code": "def value_for(scope_type, model, skip_inherited_scope = false)\n          return scope_type[model.name] if skip_inherited_scope\n          klass = model\n          base = model.base_class\n          while klass != base\n            value = scope_type[klass.name]\n            return value if value\n            klass = klass.superclass\n          end",
    "comment": "Obtains the value for a given +scope_type+ and +model+.",
    "label": "",
    "id": "1667"
  },
  {
    "raw_code": "def set_value_for(scope_type, model, value)\n          scope_type[model.name] = value\n        end",
    "comment": "Sets the +value+ for a given +scope_type+ and +model+.",
    "label": "",
    "id": "1668"
  },
  {
    "raw_code": "def authenticate_by(attributes)\n        passwords, identifiers = attributes.to_h.partition do |name, value|\n          !has_attribute?(name) && has_attribute?(\"#{name}_digest\")\n        end.map(&:to_h)\n\n        raise ArgumentError, \"One or more password arguments are required\" if passwords.empty?\n        raise ArgumentError, \"One or more finder arguments are required\" if identifiers.empty?\n\n        return if passwords.any? { |name, value| value.nil? || value.empty? }\n\n        if record = find_by(identifiers)\n          record if passwords.count { |name, value| record.public_send(:\"authenticate_#{name}\", value) } == passwords.size\n        else\n          new(passwords)\n          nil\n        end",
    "comment": "Given a set of attributes, finds a record using the non-password attributes, and then authenticates that record using the password attributes. Returns the record if authentication succeeds; otherwise, returns +nil+.  Regardless of whether a record is found, +authenticate_by+ will cryptographically digest the given password attributes. This behavior helps mitigate timing-based enumeration attacks, wherein an attacker can determine if a passworded record exists even without knowing the password.  Raises an ArgumentError if the set of attributes doesn't contain at least one password and one non-password attribute.  ==== Examples  class User < ActiveRecord::Base has_secure_password end  User.create(name: \"John Doe\", email: \"jdoe@example.com\", password: \"abc123\")  User.authenticate_by(email: \"jdoe@example.com\", password: \"abc123\").name # => \"John Doe\" (in 373.4ms) User.authenticate_by(email: \"jdoe@example.com\", password: \"wrong\")       # => nil (in 373.9ms) User.authenticate_by(email: \"wrong@example.com\", password: \"abc123\")     # => nil (in 373.6ms)  User.authenticate_by(email: \"jdoe@example.com\", password: nil) # => nil (no queries executed) User.authenticate_by(email: \"jdoe@example.com\", password: \"\")  # => nil (no queries executed)  User.authenticate_by(email: \"jdoe@example.com\") # => ArgumentError User.authenticate_by(password: \"abc123\")        # => ArgumentError",
    "label": "",
    "id": "1669"
  },
  {
    "raw_code": "def has_secure_token(attribute = :token, length: MINIMUM_TOKEN_LENGTH, on: ActiveRecord.generate_secure_token_on)\n        if length < MINIMUM_TOKEN_LENGTH\n          raise MinimumLengthError, \"Token requires a minimum length of #{MINIMUM_TOKEN_LENGTH} characters.\"\n        end",
    "comment": "Example using #has_secure_token  # Schema: User(token:string, auth_token:string) class User < ActiveRecord::Base has_secure_token has_secure_token :auth_token, length: 36 end  user = User.new user.save user.token # => \"pX27zsMN2ViQKta1bGfLmVJE\" user.auth_token # => \"tU9bLuZseefXQ4yQxQo8wjtBvsAfPc78os6R\" user.regenerate_token # => true user.regenerate_auth_token # => true  +SecureRandom::base58+ is used to generate at minimum a 24-character unique token, so collisions are highly unlikely.  Note that it's still possible to generate a race condition in the database in the same way that {validates_uniqueness_of}[rdoc-ref:Validations::ClassMethods#validates_uniqueness_of] can. You're encouraged to add a unique index in the database to deal with this even more unlikely scenario.  ==== Options  [+:length+] Length of the Secure Random, with a minimum of 24 characters. It will default to 24.  [+:on+] The callback when the value is generated. When called with <tt>on: :initialize</tt>, the value is generated in an <tt>after_initialize</tt> callback, otherwise the value will be used in a <tt>before_</tt> callback. When not specified, +:on+ will use the value of <tt>config.active_record.generate_secure_token_on</tt>, which defaults to +:initialize+ starting in \\Rails 7.1.",
    "label": "",
    "id": "1670"
  },
  {
    "raw_code": "def find_signed(signed_id, purpose: nil, on_rotation: nil)\n        raise UnknownPrimaryKey.new(self) if primary_key.nil?\n\n        options = { on_rotation: on_rotation }.compact\n        if id = signed_id_verifier.verified(signed_id, purpose: combine_signed_id_purposes(purpose), **options)\n          find_by primary_key => id\n        end",
    "comment": "Lets you find a record based on a signed id that's safe to put into the world without risk of tampering. This is particularly useful for things like password reset or email verification, where you want the bearer of the signed id to be able to interact with the underlying record, but usually only within a certain time period.  You set the time period that the signed id is valid for during generation, using the instance method <tt>signed_id(expires_in: 15.minutes)</tt>. If the time has elapsed before a signed find is attempted, the signed id will no longer be valid, and nil is returned.  It's possible to further restrict the use of a signed id with a purpose. This helps when you have a general base model, like a User, which might have signed ids for several things, like password reset or email verification. The purpose that was set during generation must match the purpose set when finding. If there's a mismatch, nil is again returned.  ==== Examples  signed_id = User.first.signed_id expires_in: 15.minutes, purpose: :password_reset  User.find_signed signed_id # => nil, since the purpose does not match  travel 16.minutes User.find_signed signed_id, purpose: :password_reset # => nil, since the signed id has expired  travel_back User.find_signed signed_id, purpose: :password_reset # => User.first",
    "label": "",
    "id": "1671"
  },
  {
    "raw_code": "def find_signed!(signed_id, purpose: nil, on_rotation: nil)\n        options = { on_rotation: on_rotation }.compact\n        if id = signed_id_verifier.verify(signed_id, purpose: combine_signed_id_purposes(purpose), **options)\n          find(id)\n        end",
    "comment": "Works like find_signed, but will raise an ActiveSupport::MessageVerifier::InvalidSignature exception if the +signed_id+ has either expired, has a purpose mismatch, is for another record, or has been tampered with. It will also raise an ActiveRecord::RecordNotFound exception if the valid signed id can't find a record.  ==== Examples  User.find_signed! \"bad data\" # => ActiveSupport::MessageVerifier::InvalidSignature  signed_id = User.first.signed_id User.first.destroy User.find_signed! signed_id # => ActiveRecord::RecordNotFound",
    "label": "",
    "id": "1672"
  },
  {
    "raw_code": "def signed_id_verifier=(verifier)\n        if signed_id_verifier_secret\n          @signed_id_verifier = verifier\n        else\n          self._signed_id_verifier = verifier\n        end",
    "comment": "Allows you to pass in a custom verifier used for the signed ids. This also allows you to use different verifiers for different classes. This is also helpful if you need to rotate keys, as you can prepare your custom verifier for that in advance. See ActiveSupport::MessageVerifier for details.",
    "label": "",
    "id": "1673"
  },
  {
    "raw_code": "def combine_signed_id_purposes(purpose)\n        [ base_class.name.underscore, purpose.to_s ].compact_blank.join(\"/\")\n      end",
    "comment": ":nodoc:",
    "label": "",
    "id": "1674"
  },
  {
    "raw_code": "def signed_id(expires_in: nil, expires_at: nil, purpose: nil)\n      raise ArgumentError, \"Cannot get a signed_id for a new record\" if new_record?\n\n      self.class.signed_id_verifier.generate id, expires_in: expires_in, expires_at: expires_at, purpose: self.class.combine_signed_id_purposes(purpose)\n    end",
    "comment": "Returns a signed id that's generated using a preconfigured +ActiveSupport::MessageVerifier+ instance.  This signed id is tamper proof, so it's safe to send in an email or otherwise share with the outside world. However, as with any message signed with a +ActiveSupport::MessageVerifier+, {the signed id is not encrypted}[link:classes/ActiveSupport/MessageVerifier.html#class-ActiveSupport::MessageVerifier-label-Signing+is+not+encryption]. It's just encoded and protected against tampering.  This means that the ID can be decoded by anyone; however, if tampered with (so to point to a different ID), the cryptographic signature will no longer match, and the signed id will be considered invalid and return nil when passed to +find_signed+ (or raise with +find_signed!+).  It can furthermore be set to expire (the default is not to expire), and scoped down with a specific purpose. If the expiration date has been exceeded before +find_signed+ is called, the id won't find the designated record. If a purpose is set, this too must match.  If you accidentally let a signed id out in the wild that you wish to retract sooner than its expiration date (or maybe you forgot to set an expiration date while meaning to!), you can use the purpose to essentially version the signed_id, like so:  user.signed_id purpose: :v2  And you then change your +find_signed+ calls to require this new purpose. Any old signed ids that were not created with the purpose will no longer find the record.",
    "label": "",
    "id": "1675"
  },
  {
    "raw_code": "def skip_transactional_tests_for_database(database_name)\n        use_transactional_tests_for_database(database_name, false)\n      end",
    "comment": "Do not use transactional tests for the given database. This overrides the default setting as defined by `use_transactional_tests`, which applies to all database connection pools not explicitly configured here.",
    "label": "",
    "id": "1676"
  },
  {
    "raw_code": "def use_transactional_tests_for_database(database_name, enabled = true)\n        self.database_transactions_config = database_transactions_config.merge(database_name => enabled)\n      end",
    "comment": "Enable or disable transactions per database. This overrides the default setting as defined by `use_transactional_tests`, which applies to all database connection pools not explicitly configured here.",
    "label": "",
    "id": "1677"
  },
  {
    "raw_code": "def set_fixture_class(class_names = {})\n        self.fixture_class_names = fixture_class_names.merge(class_names.stringify_keys)\n      end",
    "comment": "Sets the model class for a fixture when the class name cannot be inferred from the fixture name.  Examples:  set_fixture_class some_fixture:        SomeModel, 'namespaced/fixture' => Another::Model  The keys must be the fixture names, that coincide with the short paths to the fixture files.",
    "label": "",
    "id": "1678"
  },
  {
    "raw_code": "def uses_transaction(*methods)\n        @uses_transaction = [] unless defined?(@uses_transaction)\n        @uses_transaction.concat methods.map(&:to_s)\n      end",
    "comment": "Prevents automatically wrapping each specified test in a transaction, to allow application logic transactions to be tested in a top-level (non-nested) context.",
    "label": "",
    "id": "1679"
  },
  {
    "raw_code": "def fixture(fixture_set_name, *fixture_names)\n      active_record_fixture(fixture_set_name, *fixture_names)\n    end",
    "comment": "Generic fixture accessor for fixture names that may conflict with other methods.  assert_equal \"Ruby on Rails\", web_sites(:rubyonrails).name assert_equal \"Ruby on Rails\", fixture(:web_sites, :rubyonrails).name",
    "label": "",
    "id": "1680"
  },
  {
    "raw_code": "def setup_shared_connection_pool\n        handler = ActiveRecord::Base.connection_handler\n\n        handler.connection_pool_names.each do |name|\n          pool_manager = handler.send(:connection_name_to_pool_manager)[name]\n          pool_manager.shard_names.each do |shard_name|\n            writing_pool_config = pool_manager.get_pool_config(ActiveRecord.writing_role, shard_name)\n            @saved_pool_configs[name][shard_name] ||= {}\n            pool_manager.role_names.each do |role|\n              next unless pool_config = pool_manager.get_pool_config(role, shard_name)\n              next if pool_config == writing_pool_config\n\n              @saved_pool_configs[name][shard_name][role] = pool_config\n              pool_manager.set_pool_config(role, shard_name, writing_pool_config)\n            end",
    "comment": "Shares the writing connection pool with connections on other handlers.  In an application with a primary and replica the test fixtures need to share a connection pool so that the reading connection can see data in the open transaction on the writing connection.",
    "label": "",
    "id": "1681"
  },
  {
    "raw_code": "def clear_timestamp_attributes\n      all_timestamp_attributes_in_model.each do |attribute_name|\n        if self[attribute_name]\n          self[attribute_name] = nil\n          clear_attribute_change(attribute_name)\n        end",
    "comment": "Clear attributes and changed_attributes",
    "label": "",
    "id": "1682"
  },
  {
    "raw_code": "def find_by_token_for(purpose, token)\n        raise UnknownPrimaryKey.new(self) unless model.primary_key\n        model.token_definitions.fetch(purpose).resolve_token(token) { |id| find_by(model.primary_key => [id]) }\n      end",
    "comment": "Finds a record using a given +token+ for a predefined +purpose+. Returns +nil+ if the token is invalid or the record was not found.",
    "label": "",
    "id": "1683"
  },
  {
    "raw_code": "def find_by_token_for!(purpose, token)\n        model.token_definitions.fetch(purpose).resolve_token(token) { |id| find(id) } ||\n          (raise ActiveSupport::MessageVerifier::InvalidSignature)\n      end",
    "comment": "Finds a record using a given +token+ for a predefined +purpose+. Raises ActiveSupport::MessageVerifier::InvalidSignature if the token is invalid (e.g. expired, bad format, etc). Raises ActiveRecord::RecordNotFound if the token is valid but the record was not found.",
    "label": "",
    "id": "1684"
  },
  {
    "raw_code": "def generates_token_for(purpose, expires_in: nil, &block)\n        self.token_definitions = token_definitions.merge(purpose => TokenDefinition.new(self, purpose, expires_in, block))\n      end",
    "comment": "Defines the behavior of tokens generated for a specific +purpose+. A token can be generated by calling TokenFor#generate_token_for on a record. Later, that record can be fetched by calling #find_by_token_for (or #find_by_token_for!) with the same purpose and token.  Tokens are signed so that they are tamper-proof. Thus they can be exposed to outside world as, for example, password reset tokens.  By default, tokens do not expire. They can be configured to expire by specifying a duration via the +expires_in+ option. The duration becomes part of the token's signature, so changing the value of +expires_in+ will automatically invalidate previously generated tokens.  A block may also be specified. When generating a token with TokenFor#generate_token_for, the block will be evaluated in the context of the record, and its return value will be embedded in the token as JSON. Later, when fetching the record with #find_by_token_for, the block will be evaluated again in the context of the fetched record. If the two JSON values do not match, the token will be treated as invalid. Note that the value returned by the block <b>should not contain sensitive information</b> because it will be embedded in the token as <b>human-readable plaintext JSON</b>.  ==== Examples  class User < ActiveRecord::Base has_secure_password  generates_token_for :password_reset, expires_in: 15.minutes do # Last 10 characters of password salt, which changes when password is updated: password_salt&.last(10) end end  user = User.first  token = user.generate_token_for(:password_reset) User.find_by_token_for(:password_reset, token) # => user # 16 minutes later... User.find_by_token_for(:password_reset, token) # => nil  token = user.generate_token_for(:password_reset) User.find_by_token_for(:password_reset, token) # => user user.update!(password: \"new password\") User.find_by_token_for(:password_reset, token) # => nil",
    "label": "",
    "id": "1685"
  },
  {
    "raw_code": "def generate_token_for(purpose)\n      self.class.token_definitions.fetch(purpose).generate_token(self)\n    end",
    "comment": "Generates a token for a predefined +purpose+.  Use ClassMethods#generates_token_for to define a token purpose and behavior.",
    "label": "",
    "id": "1686"
  },
  {
    "raw_code": "def after_commit(&block)\n      if @internal_transaction.nil?\n        yield\n      else\n        @internal_transaction.after_commit(&block)\n      end",
    "comment": "Registers a block to be called after the transaction is fully committed.  If there is no currently open transactions, the block is called immediately, unless the transaction is finalized, in which case attempting to register the callback raises ActiveRecord::ActiveRecordError.  If the transaction has a parent transaction, the callback is transferred to the parent when the current transaction commits, or dropped when the current transaction is rolled back. This operation is repeated until the outermost transaction is reached.  If the callback raises an error, the transaction remains committed.",
    "label": "",
    "id": "1687"
  },
  {
    "raw_code": "def after_rollback(&block)\n      @internal_transaction&.after_rollback(&block)\n    end",
    "comment": "Registers a block to be called after the transaction is rolled back.  If there is no currently open transactions, the block is not called. But if the transaction is finalized, attempting to register the callback raises ActiveRecord::ActiveRecordError.  If the transaction is successfully committed but has a parent transaction, the callback is automatically added to the parent transaction.  If the entire chain of nested transactions are all successfully committed, the block is never called.",
    "label": "",
    "id": "1688"
  },
  {
    "raw_code": "def open?\n      !closed?\n    end",
    "comment": "Returns true if the transaction exists and isn't finalized yet.",
    "label": "",
    "id": "1689"
  },
  {
    "raw_code": "def closed?\n      @internal_transaction.nil? || @internal_transaction.closed?\n    end",
    "comment": "Returns true if the transaction doesn't exist or is finalized.",
    "label": "",
    "id": "1690"
  },
  {
    "raw_code": "def uuid\n      if @internal_transaction\n        @uuid ||= Digest::UUID.uuid_v4\n      end",
    "comment": "Returns a UUID for this transaction or +nil+ if no transaction is open.",
    "label": "",
    "id": "1691"
  },
  {
    "raw_code": "def transaction(**options, &block)\n        with_connection do |connection|\n          connection.pool.with_pool_transaction_isolation_level(ActiveRecord.default_transaction_isolation_level, connection.transaction_open?) do\n            connection.transaction(**options, &block)\n          end",
    "comment": "See the ConnectionAdapters::DatabaseStatements#transaction API docs.",
    "label": "",
    "id": "1692"
  },
  {
    "raw_code": "def with_pool_transaction_isolation_level(isolation_level, &block)\n        if current_transaction.open?\n          raise ActiveRecord::TransactionIsolationError, \"cannot set default isolation level while transaction is open\"\n        end",
    "comment": "Makes all transactions the current pool use the isolation level initiated within the block.",
    "label": "",
    "id": "1693"
  },
  {
    "raw_code": "def pool_transaction_isolation_level\n        connection_pool.pool_transaction_isolation_level\n      end",
    "comment": "Returns the default isolation level for the connection pool, set earlier by #with_pool_transaction_isolation_level.",
    "label": "",
    "id": "1694"
  },
  {
    "raw_code": "def current_transaction\n        connection_pool.active_connection&.current_transaction&.user_transaction || Transaction::NULL_TRANSACTION\n      end",
    "comment": "Returns a representation of the current transaction state, which can be a top level transaction, a savepoint, or the absence of a transaction.  An object is always returned, whether or not a transaction is currently active. To check if a transaction was opened, use <tt>current_transaction.open?</tt>.  See the ActiveRecord::Transaction documentation for detailed behavior.",
    "label": "",
    "id": "1695"
  },
  {
    "raw_code": "def after_commit(*args, &block)\n        set_options_for_callbacks!(args, prepend_option)\n        set_callback(:commit, :after, *args, &block)\n      end",
    "comment": "This callback is called after a record has been created, updated, or destroyed.  You can specify that the callback should only be fired by a certain action with the +:on+ option:  after_commit :do_foo, on: :create after_commit :do_bar, on: :update after_commit :do_baz, on: :destroy  after_commit :do_foo_bar, on: [:create, :update] after_commit :do_bar_baz, on: [:update, :destroy] ",
    "label": "",
    "id": "1696"
  },
  {
    "raw_code": "def after_save_commit(*args, &block)\n        set_options_for_callbacks!(args, on: [ :create, :update ], **prepend_option)\n        set_callback(:commit, :after, *args, &block)\n      end",
    "comment": "Shortcut for <tt>after_commit :hook, on: [ :create, :update ]</tt>.",
    "label": "",
    "id": "1697"
  },
  {
    "raw_code": "def after_create_commit(*args, &block)\n        set_options_for_callbacks!(args, on: :create, **prepend_option)\n        set_callback(:commit, :after, *args, &block)\n      end",
    "comment": "Shortcut for <tt>after_commit :hook, on: :create</tt>.",
    "label": "",
    "id": "1698"
  },
  {
    "raw_code": "def after_update_commit(*args, &block)\n        set_options_for_callbacks!(args, on: :update, **prepend_option)\n        set_callback(:commit, :after, *args, &block)\n      end",
    "comment": "Shortcut for <tt>after_commit :hook, on: :update</tt>.",
    "label": "",
    "id": "1699"
  },
  {
    "raw_code": "def after_destroy_commit(*args, &block)\n        set_options_for_callbacks!(args, on: :destroy, **prepend_option)\n        set_callback(:commit, :after, *args, &block)\n      end",
    "comment": "Shortcut for <tt>after_commit :hook, on: :destroy</tt>.",
    "label": "",
    "id": "1700"
  },
  {
    "raw_code": "def after_rollback(*args, &block)\n        set_options_for_callbacks!(args, prepend_option)\n        set_callback(:rollback, :after, *args, &block)\n      end",
    "comment": "This callback is called after a create, update, or destroy are rolled back.  Please check the documentation of #after_commit for options.",
    "label": "",
    "id": "1701"
  },
  {
    "raw_code": "def set_callback(name, *filter_list, &block)\n        options = filter_list.extract_options!\n        filter_list << options\n\n        if name.in?([:commit, :rollback]) && options[:on]\n          fire_on = Array(options[:on])\n          assert_valid_transaction_action(fire_on)\n          options[:if] = [\n            -> { transaction_include_any_action?(fire_on) },\n            *options[:if]\n          ]\n        end",
    "comment": "Similar to ActiveSupport::Callbacks::ClassMethods#set_callback, but with support for options available on #after_commit and #after_rollback callbacks.",
    "label": "",
    "id": "1702"
  },
  {
    "raw_code": "def transaction(**options, &block)\n      self.class.transaction(**options, &block)\n    end",
    "comment": "See ActiveRecord::Transactions::ClassMethods for detailed documentation.",
    "label": "",
    "id": "1703"
  },
  {
    "raw_code": "def committed!(should_run_callbacks: true) # :nodoc:\n      @_start_transaction_state = nil\n      if should_run_callbacks\n        @_committed_already_called = true\n        _run_commit_callbacks\n      end",
    "comment": "Call the #after_commit callbacks.  Ensure that it is not called if the object was never persisted (failed create), but call it after the commit of a destroyed object.",
    "label": "",
    "id": "1704"
  },
  {
    "raw_code": "def rolledback!(force_restore_state: false, should_run_callbacks: true) # :nodoc:\n      if should_run_callbacks\n        _run_rollback_callbacks\n      end",
    "comment": "Call the #after_rollback callbacks. The +force_restore_state+ argument indicates if the record state should be rolled back to the beginning or just to the last savepoint.",
    "label": "",
    "id": "1705"
  },
  {
    "raw_code": "def with_transaction_returning_status\n      self.class.with_connection do |connection|\n        connection.pool.with_pool_transaction_isolation_level(ActiveRecord.default_transaction_isolation_level, connection.transaction_open?) do\n          status = nil\n          ensure_finalize = !connection.transaction_open?\n\n          connection.transaction do\n            add_to_transaction(ensure_finalize || has_transactional_callbacks?)\n            remember_transaction_record_state\n\n            status = yield\n            raise ActiveRecord::Rollback unless status\n          end",
    "comment": "Executes a block within a transaction and captures its return value as a status flag. If the status is true, the transaction is committed, otherwise a ROLLBACK is issued. In any case, the status flag is returned.  This method is available within the context of an ActiveRecord::Base instance.",
    "label": "",
    "id": "1706"
  },
  {
    "raw_code": "def remember_transaction_record_state\n        @_start_transaction_state ||= {\n          id: id,\n          new_record: @new_record,\n          previously_new_record: @previously_new_record,\n          destroyed: @destroyed,\n          attributes: @attributes,\n          frozen?: frozen?,\n          level: 0\n        }\n        @_start_transaction_state[:level] += 1\n\n        if _committed_already_called\n          @_new_record_before_last_commit = false\n        else\n          @_new_record_before_last_commit = @_start_transaction_state[:new_record]\n        end",
    "comment": "Save the new record state and id of a record so it can be restored later if a transaction fails.",
    "label": "",
    "id": "1707"
  },
  {
    "raw_code": "def clear_transaction_record_state\n        return unless @_start_transaction_state\n        @_start_transaction_state[:level] -= 1\n        @_start_transaction_state = nil if @_start_transaction_state[:level] < 1\n      end",
    "comment": "Clear the new record state and id of a record.",
    "label": "",
    "id": "1708"
  },
  {
    "raw_code": "def restore_transaction_record_state(force_restore_state = false)\n        if restore_state = @_start_transaction_state\n          if force_restore_state || restore_state[:level] <= 1\n            @new_record = restore_state[:new_record]\n            @previously_new_record = restore_state[:previously_new_record]\n            @destroyed  = restore_state[:destroyed]\n            @attributes = restore_state[:attributes].map do |attr|\n              value = @attributes.fetch_value(attr.name)\n              attr = attr.with_value_from_user(value) if attr.value != value\n              attr\n            end",
    "comment": "Restore the new record state and id of a record that was previously saved by a call to save_record_state.",
    "label": "",
    "id": "1709"
  },
  {
    "raw_code": "def transaction_include_any_action?(actions)\n        actions.any? do |action|\n          case action\n          when :create\n            persisted? && @_new_record_before_last_commit\n          when :update\n            !(@_new_record_before_last_commit || destroyed?) && _trigger_update_callback\n          when :destroy\n            _trigger_destroy_callback\n          end",
    "comment": "Determine if a transaction included an action for :create, :update, or :destroy. Used in filtering callbacks.",
    "label": "",
    "id": "1710"
  },
  {
    "raw_code": "def add_to_transaction(ensure_finalize = true)\n        self.class.with_connection do |connection|\n          connection.add_transaction_record(self, ensure_finalize)\n        end",
    "comment": "Add the record to the current transaction so that the #after_rollback and #after_commit callbacks can be called.",
    "label": "",
    "id": "1711"
  },
  {
    "raw_code": "def lookup_ancestors # :nodoc:\n      klass = self\n      classes = [klass]\n      return classes if klass == ActiveRecord::Base\n\n      while !klass.base_class?\n        classes << klass = klass.superclass\n      end",
    "comment": "Set the lookup ancestors for ActiveModel.",
    "label": "",
    "id": "1712"
  },
  {
    "raw_code": "def i18n_scope # :nodoc:\n      :activerecord\n    end",
    "comment": "Set the i18n scope to override ActiveModel.",
    "label": "",
    "id": "1713"
  },
  {
    "raw_code": "def register(type_name, klass = nil, **options, &block)\n        registry.register(type_name, klass, **options, &block)\n      end",
    "comment": "Add a new type to the registry, allowing it to be referenced as a symbol by {ActiveRecord::Base.attribute}[rdoc-ref:Attributes::ClassMethods#attribute]. If your type is only meant to be used with a specific database adapter, you can do so by passing <tt>adapter: :postgresql</tt>. If your type has the same name as a native type for the current adapter, an exception will be raised unless you specify an +:override+ option. <tt>override: true</tt> will cause your type to be used instead of the native type. <tt>override: false</tt> will cause the native type to be used over yours if one exists.",
    "label": "",
    "id": "1714"
  },
  {
    "raw_code": "def save(**options)\n      perform_validations(options) ? super : false\n    end",
    "comment": "The validation process on save can be skipped by passing <tt>validate: false</tt>. The validation context can be changed by passing <tt>context: context</tt>. The regular {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] method is replaced with this when the validations module is mixed in, which it is by default.",
    "label": "",
    "id": "1715"
  },
  {
    "raw_code": "def save!(**options)\n      perform_validations(options) ? super : raise_validation_error\n    end",
    "comment": "Attempts to save the record just like {ActiveRecord::Base#save}[rdoc-ref:Base#save] but will raise an ActiveRecord::RecordInvalid exception instead of returning +false+ if the record is not valid.",
    "label": "",
    "id": "1716"
  },
  {
    "raw_code": "def valid?(context = nil)\n      context ||= default_validation_context\n      output = super(context)\n      errors.empty? && output\n    end",
    "comment": "Runs all the validations within the specified context. Returns +true+ if no errors are found, +false+ otherwise.  Aliased as #validate.  If the argument is +false+ (default is +nil+), the context is set to <tt>:create</tt> if {new_record?}[rdoc-ref:Persistence#new_record?] is +true+, and to <tt>:update</tt> if it is not. If the argument is an array of contexts, <tt>post.valid?([:create, :update])</tt>, the validations are run within multiple contexts.  \\Validations with no <tt>:on</tt> option will run no matter the context. \\Validations with some <tt>:on</tt> option will only run in the specified context.",
    "label": "",
    "id": "1717"
  },
  {
    "raw_code": "def self.version\n    gem_version\n  end",
    "comment": "Returns the currently loaded version of Active Record as a +Gem::Version+.",
    "label": "",
    "id": "1718"
  },
  {
    "raw_code": "def initialize(table_alias_length, aliases)\n        @aliases = aliases\n        @table_alias_length = table_alias_length\n      end",
    "comment": "table_joins is an array of arel joins which might conflict with the aliases we assign here",
    "label": "",
    "id": "1719"
  },
  {
    "raw_code": "def reset\n        @loaded = false\n        @stale_state = nil\n      end",
    "comment": "Resets the \\loaded flag to +false+ and sets the \\target to +nil+.",
    "label": "",
    "id": "1720"
  },
  {
    "raw_code": "def reload(force = false)\n        klass.connection_pool.clear_query_cache if force && klass\n        reset\n        reset_scope\n        load_target\n        self unless target.nil?\n      end",
    "comment": "Reloads the \\target and returns +self+ on success. The QueryCache is cleared if +force+ is true.",
    "label": "",
    "id": "1721"
  },
  {
    "raw_code": "def loaded?\n        @loaded\n      end",
    "comment": "Has the \\target been already \\loaded?",
    "label": "",
    "id": "1722"
  },
  {
    "raw_code": "def loaded!\n        @loaded = true\n        @stale_state = stale_state\n      end",
    "comment": "Asserts the \\target has been loaded setting the \\loaded flag to +true+.",
    "label": "",
    "id": "1723"
  },
  {
    "raw_code": "def stale_target?\n        loaded? && @stale_state != stale_state\n      end",
    "comment": "The target is stale if the target no longer points to the record(s) that the relevant foreign_key(s) refers to. If stale, the association accessor method on the owner will reload the target. It's up to subclasses to implement the stale_state method if relevant.  Note that if the target has not been loaded, it is not considered stale.",
    "label": "",
    "id": "1724"
  },
  {
    "raw_code": "def target=(target)\n        @target = target\n        loaded!\n      end",
    "comment": "Sets the target of this association to <tt>\\target</tt>, and the \\loaded flag to +true+.",
    "label": "",
    "id": "1725"
  },
  {
    "raw_code": "def set_inverse_instance(record)\n        if inverse = inverse_association_for(record)\n          inverse.inversed_from(owner)\n        end",
    "comment": "Set the inverse association, if possible",
    "label": "",
    "id": "1726"
  },
  {
    "raw_code": "def remove_inverse_instance(record)\n        if inverse = inverse_association_for(record)\n          inverse.inversed_from(nil)\n        end",
    "comment": "Remove the inverse association, if possible",
    "label": "",
    "id": "1727"
  },
  {
    "raw_code": "def klass\n        reflection.klass\n      end",
    "comment": "Returns the class of the target. belongs_to polymorphic overrides this to look at the polymorphic_type field on the owner.",
    "label": "",
    "id": "1728"
  },
  {
    "raw_code": "def load_target\n        @target = find_target(async: false) if (@stale_state && stale_target?) || find_target?\n\n        loaded! unless loaded?\n        target\n      rescue ActiveRecord::RecordNotFound\n        reset\n      end",
    "comment": "Loads the \\target if needed and returns it.  This method is abstract in the sense that it relies on +find_target+, which is expected to be provided by descendants.  If the \\target is already \\loaded it is just returned. Thus, you can call +load_target+ unconditionally to get the \\target.  ActiveRecord::RecordNotFound is rescued within the method, and it is not reraised. The proxy is \\reset and +nil+ is the return value.",
    "label": "",
    "id": "1729"
  },
  {
    "raw_code": "def marshal_dump\n        ivars = (instance_variables - [:@reflection, :@through_reflection]).map { |name| [name, instance_variable_get(name)] }\n        [@reflection.name, ivars]\n      end",
    "comment": "We can't dump @reflection and @through_reflection since it contains the scope proc",
    "label": "",
    "id": "1730"
  },
  {
    "raw_code": "def collection?\n        false\n      end",
    "comment": "Whether the association represents a single record or a collection of records.",
    "label": "",
    "id": "1731"
  },
  {
    "raw_code": "def ensure_klass_exists!\n          klass\n        end",
    "comment": "Reader and writer methods call this so that consistent errors are presented when the association target class does not exist.",
    "label": "",
    "id": "1732"
  },
  {
    "raw_code": "def association_scope\n          if klass\n            @association_scope ||= if disable_joins\n              DisableJoinsAssociationScope.scope(self)\n            else\n              AssociationScope.scope(self)\n            end",
    "comment": "The scope for this association.  Note that the association_scope is merged into the target_scope only when the scope method is called. This is because at that point the call may be surrounded by scope.scoping { ... } or unscoped { ... } etc, which affects the scope which actually gets built.",
    "label": "",
    "id": "1733"
  },
  {
    "raw_code": "def target_scope\n          AssociationRelation.create(klass, self).merge!(klass.scope_for_association)\n        end",
    "comment": "Can be overridden (i.e. in ThroughAssociation) to merge in other scopes (i.e. the through association's scope)",
    "label": "",
    "id": "1734"
  },
  {
    "raw_code": "def foreign_key_present?\n          false\n        end",
    "comment": "Returns true if there is a foreign key present on the owner which references the target. This is used to determine whether we can load the target if the owner is currently a new record (and therefore without a key). If the owner is a new record then foreign_key must be present in order to load target.  Currently implemented by belongs_to (vanilla and polymorphic) and has_one/has_many :through associations which go through a belongs_to.",
    "label": "",
    "id": "1735"
  },
  {
    "raw_code": "def raise_on_type_mismatch!(record)\n          unless record.is_a?(reflection.klass)\n            fresh_class = reflection.class_name.safe_constantize\n            unless fresh_class && record.is_a?(fresh_class)\n              message = \"#{reflection.class_name}(##{reflection.klass.object_id}) expected, \"\\\n                \"got #{record.inspect} which is an instance of #{record.class}(##{record.class.object_id})\"\n              raise ActiveRecord::AssociationTypeMismatch, message\n            end",
    "comment": "Raises ActiveRecord::AssociationTypeMismatch unless +record+ is of the kind of the class of the associated objects. Meant to be used as a safety check when you are about to assign an associated record.",
    "label": "",
    "id": "1736"
  },
  {
    "raw_code": "def inverse_reflection_for(record)\n          reflection.inverse_of\n        end",
    "comment": "Can be redefined by subclasses, notably polymorphic belongs_to The record parameter is necessary to support polymorphic inverses as we must check for the association in the specific class of the record.",
    "label": "",
    "id": "1737"
  },
  {
    "raw_code": "def invertible_for?(record)\n          foreign_key_for?(record) && inverse_reflection_for(record)\n        end",
    "comment": "Returns true if inverse association on the given record needs to be set. This method is redefined by subclasses.",
    "label": "",
    "id": "1738"
  },
  {
    "raw_code": "def foreign_key_for?(record)\n          foreign_key = Array(reflection.foreign_key)\n          foreign_key.all? { |key| record._has_attribute?(key) }\n        end",
    "comment": "Returns true if record contains the foreign_key",
    "label": "",
    "id": "1739"
  },
  {
    "raw_code": "def stale_state\n        end",
    "comment": "This should be implemented to return the values of the relevant key(s) on the owner, so that when stale_state is different from the value stored on the last find_target, the target is stale.  This is only relevant to certain associations, which is why it returns +nil+ by default.",
    "label": "",
    "id": "1740"
  },
  {
    "raw_code": "def skip_statement_cache?(scope)\n          reflection.has_scope? ||\n            scope.eager_loading? ||\n            klass.scope_attributes? ||\n            reflection.source_reflection.active_record.default_scopes.any?\n        end",
    "comment": "Returns true if statement cache should be skipped on the association reader.",
    "label": "",
    "id": "1741"
  },
  {
    "raw_code": "def reader\n        ensure_klass_exists!\n\n        if stale_target?\n          reload\n        end",
    "comment": "Implements the reader method, e.g. foo.items for Foo.has_many :items",
    "label": "",
    "id": "1742"
  },
  {
    "raw_code": "def writer(records)\n        replace(records)\n      end",
    "comment": "Implements the writer method, e.g. foo.items= for Foo.has_many :items",
    "label": "",
    "id": "1743"
  },
  {
    "raw_code": "def ids_reader\n        if loaded?\n          target.pluck(*reflection.association_primary_key)\n        elsif !target.empty?\n          load_target.pluck(*reflection.association_primary_key)\n        else\n          @association_ids ||= scope.pluck(*reflection.association_primary_key)\n        end",
    "comment": "Implements the ids reader method, e.g. foo.item_ids for Foo.has_many :items",
    "label": "",
    "id": "1744"
  },
  {
    "raw_code": "def ids_writer(ids)\n        primary_key = reflection.association_primary_key\n        pk_type = klass.type_for_attribute(primary_key)\n        ids = Array(ids).compact_blank\n        ids.map! { |id| pk_type.cast(id) }\n\n        records = if klass.composite_primary_key?\n          klass.where(primary_key => ids).index_by do |record|\n            primary_key.map { |primary_key| record._read_attribute(primary_key) }\n          end",
    "comment": "Implements the ids writer method, e.g. foo.item_ids= for Foo.has_many :items",
    "label": "",
    "id": "1745"
  },
  {
    "raw_code": "def concat(*records)\n        records = records.flatten\n        if owner.new_record?\n          skip_strict_loading { load_target }\n          concat_records(records)\n        else\n          transaction { concat_records(records) }\n        end",
    "comment": "Add +records+ to this association. Since +<<+ flattens its argument list and inserts each record, +push+ and +concat+ behave identically.",
    "label": "",
    "id": "1746"
  },
  {
    "raw_code": "def delete_all(dependent = nil)\n        if dependent && ![:nullify, :delete_all].include?(dependent)\n          raise ArgumentError, \"Valid values are :nullify or :delete_all\"\n        end",
    "comment": "Removes all records from the association without calling callbacks on the associated records. It honors the +:dependent+ option. However if the +:dependent+ value is +:destroy+ then in that case the +:delete_all+ deletion strategy for the association is applied.  You can force a particular deletion strategy by passing a parameter.  Example:  @author.books.delete_all(:nullify) @author.books.delete_all(:delete_all)  See delete for more info.",
    "label": "",
    "id": "1747"
  },
  {
    "raw_code": "def destroy_all\n        destroy(load_target).tap do\n          reset\n          loaded!\n        end",
    "comment": "Destroy all the records from this association.  See destroy for more info.",
    "label": "",
    "id": "1748"
  },
  {
    "raw_code": "def delete(*records)\n        delete_or_destroy(records, options[:dependent])\n      end",
    "comment": "Removes +records+ from this association calling +before_remove+ and +after_remove+ callbacks.  This method is abstract in the sense that +delete_records+ has to be provided by descendants. Note this method does not imply the records are actually removed from the database, that depends precisely on +delete_records+. They are in any case removed from the collection.",
    "label": "",
    "id": "1749"
  },
  {
    "raw_code": "def destroy(*records)\n        delete_or_destroy(records, :destroy)\n      end",
    "comment": "Deletes the +records+ and removes them from this association calling +before_remove+, +after_remove+, +before_destroy+ and +after_destroy+ callbacks.  Note that this method removes records from the database ignoring the +:dependent+ option.",
    "label": "",
    "id": "1750"
  },
  {
    "raw_code": "def size\n        if !find_target? || loaded?\n          target.size\n        elsif @association_ids\n          @association_ids.size\n        elsif !association_scope.group_values.empty?\n          load_target.size\n        elsif !association_scope.distinct_value && !target.empty?\n          unsaved_records = target.select(&:new_record?)\n          unsaved_records.size + count_records\n        else\n          count_records\n        end",
    "comment": "Returns the size of the collection by executing a SELECT COUNT(*) query if the collection hasn't been loaded, and calling <tt>collection.size</tt> if it has.  If the collection has been already loaded +size+ and +length+ are equivalent. If not and you are going to need the records anyway +length+ will take one less query. Otherwise +size+ is more efficient.  This method is abstract in the sense that it relies on +count_records+, which is a method descendants have to provide.",
    "label": "",
    "id": "1751"
  },
  {
    "raw_code": "def empty?\n        if loaded? || @association_ids || reflection.has_active_cached_counter?\n          size.zero?\n        else\n          target.empty? && !scope.exists?\n        end",
    "comment": "Returns true if the collection is empty.  If the collection has been loaded it is equivalent to <tt>collection.size.zero?</tt>. If the collection has not been loaded, it is equivalent to <tt>!collection.exists?</tt>. If the collection has not already been loaded and you are going to fetch the records anyway it is better to check <tt>collection.length.zero?</tt>.",
    "label": "",
    "id": "1752"
  },
  {
    "raw_code": "def replace(other_array)\n        other_array.each { |val| raise_on_type_mismatch!(val) }\n        original_target = skip_strict_loading { load_target }.dup\n\n        if owner.new_record?\n          replace_records(other_array, original_target)\n        else\n          replace_common_records_in_memory(other_array, original_target)\n          if other_array != original_target\n            transaction { replace_records(other_array, original_target) }\n          else\n            other_array\n          end",
    "comment": "Replace this collection with +other_array+. This will perform a diff and delete/add only records that have changed.",
    "label": "",
    "id": "1753"
  },
  {
    "raw_code": "def merge_target_lists(persisted, memory)\n          return persisted if memory.empty?\n\n          persisted.map! do |record|\n            if mem_record = memory.delete(record)\n\n              ((record.attribute_names & mem_record.attribute_names) - mem_record.changed_attribute_names_to_save - mem_record.class._attr_readonly).each do |name|\n                mem_record._write_attribute(name, record[name])\n              end",
    "comment": "We have some records loaded from the database (persisted) and some that are in-memory (memory). The same record may be represented in the persisted array and in the memory array.  So the task of this method is to merge them according to the following rules:  * The final array must not have duplicates * The order of the persisted array is to be preserved * Any changes made to attributes on objects in the memory array are to be preserved * Otherwise, attributes should have the value found in the database",
    "label": "",
    "id": "1754"
  },
  {
    "raw_code": "def insert_record(record, validate = true, raise = false, &block)\n          if raise\n            record.save!(validate: validate, &block)\n          else\n            record.save(validate: validate, &block)\n          end",
    "comment": "Do the relevant stuff to insert the given record into the association collection.",
    "label": "",
    "id": "1755"
  },
  {
    "raw_code": "def delete_records(records, method)\n          raise NotImplementedError\n        end",
    "comment": "Delete the given records from the association, using one of the methods +:destroy+, +:delete_all+ or +:nullify+ (or +nil+, in which case a default is used).",
    "label": "",
    "id": "1756"
  },
  {
    "raw_code": "def find_by_scan(*args)\n          expects_array = args.first.kind_of?(Array)\n          ids           = args.flatten.compact.map(&:to_s).uniq\n\n          if ids.size == 1\n            id = ids.first\n            record = load_target.detect { |r| id == r.id.to_s }\n            expects_array ? [ record ] : record\n          else\n            load_target.select { |r| ids.include?(r.id.to_s) }\n          end",
    "comment": "If the :inverse_of option has been specified, then #find scans the entire collection.",
    "label": "",
    "id": "1757"
  },
  {
    "raw_code": "def loaded?\n        @association.loaded?\n      end",
    "comment": "Returns +true+ if the association has been loaded, otherwise +false+.  person.pets.loaded? # => false person.pets.records person.pets.loaded? # => true",
    "label": "",
    "id": "1758"
  },
  {
    "raw_code": "def find(*args)\n        return super if block_given?\n        @association.find(*args)\n      end",
    "comment": " :method: select  :call-seq: select(*fields, &block)  Works in two ways.  *First:* Specify a subset of fields to be selected from the result set.  class Person < ActiveRecord::Base has_many :pets end  person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.select(:name) # => [ #      #<Pet id: nil, name: \"Fancy-Fancy\">, #      #<Pet id: nil, name: \"Spook\">, #      #<Pet id: nil, name: \"Choo-Choo\"> #    ]  person.pets.select(:id, :name) # => [ #      #<Pet id: 1, name: \"Fancy-Fancy\">, #      #<Pet id: 2, name: \"Spook\">, #      #<Pet id: 3, name: \"Choo-Choo\"> #    ]  Be careful because this also means you're initializing a model object with only the fields that you've selected. If you attempt to access a field except +id+ that is not in the initialized record you'll receive:  person.pets.select(:name).first.person_id # => ActiveModel::MissingAttributeError: missing attribute 'person_id' for Pet  *Second:* You can pass a block so it can be used just like <tt>Array#select</tt>. This builds an array of objects from the database for the scope, converting them into an array and iterating through them using <tt>Array#select</tt>.  person.pets.select { |pet| /oo/.match?(pet.name) } # => [ #      #<Pet id: 2, name: \"Spook\", person_id: 1>, #      #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ] Finds an object in the collection responding to the +id+. Uses the same rules as ActiveRecord::FinderMethods.find. Raises ActiveRecord::RecordNotFound error if the object cannot be found.  class Person < ActiveRecord::Base has_many :pets end  person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.find(1) # => #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1> person.pets.find(4) # => ActiveRecord::RecordNotFound: Couldn't find Pet with 'id'=4  person.pets.find(2) { |pet| pet.name.downcase! } # => #<Pet id: 2, name: \"fancy-fancy\", person_id: 1>  person.pets.find(2, 3) # => [ #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]",
    "label": "",
    "id": "1759"
  },
  {
    "raw_code": "def last(limit = nil)\n        load_target if find_from_target?\n        super\n      end",
    "comment": " :method: first  :call-seq: first(limit = nil)  Returns the first record, or the first +n+ records, from the collection. If the collection is empty, the first form returns +nil+, and the second form returns an empty array.  class Person < ActiveRecord::Base has_many :pets end  person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.first # => #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>  person.pets.first(2) # => [ #      #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #      #<Pet id: 2, name: \"Spook\", person_id: 1> #    ]  another_person_without.pets          # => [] another_person_without.pets.first    # => nil another_person_without.pets.first(3) # => []  :method: second  :call-seq: second()  Same as #first except returns only the second record.  :method: third  :call-seq: third()  Same as #first except returns only the third record.  :method: fourth  :call-seq: fourth()  Same as #first except returns only the fourth record.  :method: fifth  :call-seq: fifth()  Same as #first except returns only the fifth record.  :method: forty_two  :call-seq: forty_two()  Same as #first except returns only the forty second record. Also known as accessing \"the reddit\".  :method: third_to_last  :call-seq: third_to_last()  Same as #last except returns only the third-to-last record.  :method: second_to_last  :call-seq: second_to_last()  Same as #last except returns only the second-to-last record. Returns the last record, or the last +n+ records, from the collection. If the collection is empty, the first form returns +nil+, and the second form returns an empty array.  class Person < ActiveRecord::Base has_many :pets end  person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.last # => #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>  person.pets.last(2) # => [ #      #<Pet id: 2, name: \"Spook\", person_id: 1>, #      #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  another_person_without.pets         # => [] another_person_without.pets.last    # => nil another_person_without.pets.last(3) # => []",
    "label": "",
    "id": "1760"
  },
  {
    "raw_code": "def take(limit = nil)\n        load_target if find_from_target?\n        super\n      end",
    "comment": "Gives a record (or N records if a parameter is supplied) from the collection using the same rules as ActiveRecord::FinderMethods.take.  class Person < ActiveRecord::Base has_many :pets end  person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.take # => #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>  person.pets.take(2) # => [ #      #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #      #<Pet id: 2, name: \"Spook\", person_id: 1> #    ]  another_person_without.pets         # => [] another_person_without.pets.take    # => nil another_person_without.pets.take(2) # => []",
    "label": "",
    "id": "1761"
  },
  {
    "raw_code": "def build(attributes = {}, &block)\n        @association.build(attributes, &block)\n      end",
    "comment": "Returns a new object of the collection type that has been instantiated with +attributes+ and linked to this object, but have not yet been saved. You can pass an array of attributes hashes, this will return an array with the new objects.  class Person has_many :pets end  person.pets.build # => #<Pet id: nil, name: nil, person_id: 1>  person.pets.build(name: 'Fancy-Fancy') # => #<Pet id: nil, name: \"Fancy-Fancy\", person_id: 1>  person.pets.build([{name: 'Spook'}, {name: 'Choo-Choo'}, {name: 'Brain'}]) # => [ #      #<Pet id: nil, name: \"Spook\", person_id: 1>, #      #<Pet id: nil, name: \"Choo-Choo\", person_id: 1>, #      #<Pet id: nil, name: \"Brain\", person_id: 1> #    ]  person.pets.size  # => 5 # size of the collection person.pets.count # => 0 # count from database",
    "label": "",
    "id": "1762"
  },
  {
    "raw_code": "def create(attributes = {}, &block)\n        @association.create(attributes, &block)\n      end",
    "comment": "Returns a new object of the collection type that has been instantiated with attributes, linked to this object and that has already been saved (if it passes the validations).  class Person has_many :pets end  person.pets.create(name: 'Fancy-Fancy') # => #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>  person.pets.create([{name: 'Spook'}, {name: 'Choo-Choo'}]) # => [ #      #<Pet id: 2, name: \"Spook\", person_id: 1>, #      #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.size  # => 3 person.pets.count # => 3  person.pets.find(1, 2, 3) # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]",
    "label": "",
    "id": "1763"
  },
  {
    "raw_code": "def create!(attributes = {}, &block)\n        @association.create!(attributes, &block)\n      end",
    "comment": "Like #create, except that if the record is invalid, raises an exception.  class Person has_many :pets end  class Pet validates :name, presence: true end  person.pets.create!(name: nil) # => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank",
    "label": "",
    "id": "1764"
  },
  {
    "raw_code": "def replace(other_array)\n        @association.replace(other_array)\n      end",
    "comment": "Replaces this collection with +other_array+. This will perform a diff and delete/add only records that have changed.  class Person < ActiveRecord::Base has_many :pets end  person.pets # => [#<Pet id: 1, name: \"Gorby\", group: \"cats\", person_id: 1>]  other_pets = [Pet.new(name: 'Puff', group: 'celebrities')]  person.pets.replace(other_pets)  person.pets # => [#<Pet id: 2, name: \"Puff\", group: \"celebrities\", person_id: 1>]  If the supplied array has an incorrect association type, it raises an ActiveRecord::AssociationTypeMismatch error:  person.pets.replace([\"doo\", \"ggie\", \"gaga\"]) # => ActiveRecord::AssociationTypeMismatch: Pet expected, got String",
    "label": "",
    "id": "1765"
  },
  {
    "raw_code": "def delete_all(dependent = nil)\n        @association.delete_all(dependent).tap { reset_scope }\n      end",
    "comment": "Deletes all the records from the collection according to the strategy specified by the +:dependent+ option. If no +:dependent+ option is given, then it will follow the default strategy.  For <tt>has_many :through</tt> associations, the default deletion strategy is +:delete_all+.  For +has_many+ associations, the default deletion strategy is +:nullify+. This sets the foreign keys to +NULL+.  class Person < ActiveRecord::Base has_many :pets # dependent: :nullify option by default end  person.pets.size # => 3 person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.delete_all # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.size # => 0 person.pets      # => []  Pet.find(1, 2, 3) # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: nil>, #       #<Pet id: 2, name: \"Spook\", person_id: nil>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: nil> #    ]  Both +has_many+ and <tt>has_many :through</tt> dependencies default to the +:delete_all+ strategy if the +:dependent+ option is set to +:destroy+. Records are not instantiated and callbacks will not be fired.  class Person < ActiveRecord::Base has_many :pets, dependent: :destroy end  person.pets.size # => 3 person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.delete_all  Pet.find(1, 2, 3) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)  If it is set to <tt>:delete_all</tt>, all the objects are deleted *without* calling their +destroy+ method.  class Person < ActiveRecord::Base has_many :pets, dependent: :delete_all end  person.pets.size # => 3 person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.delete_all  Pet.find(1, 2, 3) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)",
    "label": "",
    "id": "1766"
  },
  {
    "raw_code": "def destroy_all\n        @association.destroy_all.tap { reset_scope }\n      end",
    "comment": "Deletes the records of the collection directly from the database ignoring the +:dependent+ option. Records are instantiated and it invokes +before_remove+, +after_remove+, +before_destroy+, and +after_destroy+ callbacks.  class Person < ActiveRecord::Base has_many :pets end  person.pets.size # => 3 person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.destroy_all  person.pets.size # => 0 person.pets      # => []  Pet.find(1) # => Couldn't find Pet with id=1",
    "label": "",
    "id": "1767"
  },
  {
    "raw_code": "def delete(*records)\n        @association.delete(*records).tap { reset_scope }\n      end",
    "comment": "Deletes the +records+ supplied from the collection according to the strategy specified by the +:dependent+ option. If no +:dependent+ option is given, then it will follow the default strategy. Returns an array with the deleted records.  For <tt>has_many :through</tt> associations, the default deletion strategy is +:delete_all+.  For +has_many+ associations, the default deletion strategy is +:nullify+. This sets the foreign keys to +NULL+.  class Person < ActiveRecord::Base has_many :pets # dependent: :nullify option by default end  person.pets.size # => 3 person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.delete(Pet.find(1)) # => [#<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>]  person.pets.size # => 2 person.pets # => [ #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  Pet.find(1) # => #<Pet id: 1, name: \"Fancy-Fancy\", person_id: nil>  If it is set to <tt>:destroy</tt> all the +records+ are removed by calling their +destroy+ method. See +destroy+ for more information.  class Person < ActiveRecord::Base has_many :pets, dependent: :destroy end  person.pets.size # => 3 person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.delete(Pet.find(1), Pet.find(3)) # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.size # => 1 person.pets # => [#<Pet id: 2, name: \"Spook\", person_id: 1>]  Pet.find(1, 3) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 3)  If it is set to <tt>:delete_all</tt>, all the +records+ are deleted *without* calling their +destroy+ method.  class Person < ActiveRecord::Base has_many :pets, dependent: :delete_all end  person.pets.size # => 3 person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.delete(Pet.find(1)) # => [#<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>]  person.pets.size # => 2 person.pets # => [ #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  Pet.find(1) # => ActiveRecord::RecordNotFound: Couldn't find Pet with 'id'=1  You can pass +Integer+ or +String+ values, it finds the records responding to the +id+ and executes delete on them.  class Person < ActiveRecord::Base has_many :pets end  person.pets.size # => 3 person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.delete(\"1\") # => [#<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>]  person.pets.delete(2, 3) # => [ #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]",
    "label": "",
    "id": "1768"
  },
  {
    "raw_code": "def destroy(*records)\n        @association.destroy(*records).tap { reset_scope }\n      end",
    "comment": "Destroys the +records+ supplied and removes them from the collection. This method will _always_ remove record from the database ignoring the +:dependent+ option. Returns an array with the removed records.  class Person < ActiveRecord::Base has_many :pets end  person.pets.size # => 3 person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.destroy(Pet.find(1)) # => [#<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>]  person.pets.size # => 2 person.pets # => [ #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.destroy(Pet.find(2), Pet.find(3)) # => [ #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.size  # => 0 person.pets       # => []  Pet.find(1, 2, 3) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)  You can pass +Integer+ or +String+ values, it finds the records responding to the +id+ and then deletes them from the database.  person.pets.size # => 3 person.pets # => [ #       #<Pet id: 4, name: \"Benny\", person_id: 1>, #       #<Pet id: 5, name: \"Brain\", person_id: 1>, #       #<Pet id: 6, name: \"Boss\",  person_id: 1> #    ]  person.pets.destroy(\"4\") # => #<Pet id: 4, name: \"Benny\", person_id: 1>  person.pets.size # => 2 person.pets # => [ #       #<Pet id: 5, name: \"Brain\", person_id: 1>, #       #<Pet id: 6, name: \"Boss\",  person_id: 1> #    ]  person.pets.destroy(5, 6) # => [ #       #<Pet id: 5, name: \"Brain\", person_id: 1>, #       #<Pet id: 6, name: \"Boss\",  person_id: 1> #    ]  person.pets.size  # => 0 person.pets       # => []  Pet.find(4, 5, 6) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (4, 5, 6)",
    "label": "",
    "id": "1769"
  },
  {
    "raw_code": "def calculate(operation, column_name)\n        null_scope? ? scope.calculate(operation, column_name) : super\n      end",
    "comment": " :method: distinct  :call-seq: distinct(value = true)  Specifies whether the records should be unique or not.  class Person < ActiveRecord::Base has_many :pets end  person.pets.select(:name) # => [ #      #<Pet name: \"Fancy-Fancy\">, #      #<Pet name: \"Fancy-Fancy\"> #    ]  person.pets.select(:name).distinct # => [#<Pet name: \"Fancy-Fancy\">]  person.pets.select(:name).distinct.distinct(false) # => [ #      #<Pet name: \"Fancy-Fancy\">, #      #<Pet name: \"Fancy-Fancy\"> #    ] --",
    "label": "",
    "id": "1770"
  },
  {
    "raw_code": "def size\n        @association.size\n      end",
    "comment": " :method: count  :call-seq: count(column_name = nil, &block)  Count all records.  class Person < ActiveRecord::Base has_many :pets end  # This will perform the count using SQL. person.pets.count # => 3 person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  Passing a block will select all of a person's pets in SQL and then perform the count using Ruby.  person.pets.count { |pet| pet.name.include?('-') } # => 2 Returns the size of the collection. If the collection hasn't been loaded, it executes a <tt>SELECT COUNT(*)</tt> query. Else it calls <tt>collection.size</tt>.  If the collection has been already loaded +size+ and +length+ are equivalent. If not and you are going to need the records anyway +length+ will take one less query. Otherwise +size+ is more efficient.  class Person < ActiveRecord::Base has_many :pets end  person.pets.size # => 3 # executes something like SELECT COUNT(*) FROM \"pets\" WHERE \"pets\".\"person_id\" = 1  person.pets # This will execute a SELECT * FROM query # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]  person.pets.size # => 3 # Because the collection is already loaded, this will behave like # collection.size and no SQL count query is executed.",
    "label": "",
    "id": "1771"
  },
  {
    "raw_code": "def empty?\n        @association.empty?\n      end",
    "comment": " :method: length  :call-seq: length()  Returns the size of the collection calling +size+ on the target. If the collection has been already loaded, +length+ and +size+ are equivalent. If not and you are going to need the records anyway this method will take one less query. Otherwise +size+ is more efficient.  class Person < ActiveRecord::Base has_many :pets end  person.pets.length # => 3 # executes something like SELECT \"pets\".* FROM \"pets\" WHERE \"pets\".\"person_id\" = 1  # Because the collection is loaded, you can # call the collection with no additional queries: person.pets # => [ #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #       #<Pet id: 2, name: \"Spook\", person_id: 1>, #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ] Returns +true+ if the collection is empty. If the collection has been loaded it is equivalent to <tt>collection.size.zero?</tt>. If the collection has not been loaded, it is equivalent to <tt>!collection.exists?</tt>. If the collection has not already been loaded and you are going to fetch the records anyway it is better to check <tt>collection.load.empty?</tt>.  class Person < ActiveRecord::Base has_many :pets end  person.pets.count  # => 1 person.pets.empty? # => false  person.pets.delete_all  person.pets.count  # => 0 person.pets.empty? # => true",
    "label": "",
    "id": "1772"
  },
  {
    "raw_code": "def include?(record)\n        !!@association.include?(record)\n      end",
    "comment": " :method: any?  :call-seq: any?()  Returns +true+ if the collection is not empty.  class Person < ActiveRecord::Base has_many :pets end  person.pets.count # => 0 person.pets.any?  # => false  person.pets << Pet.new(name: 'Snoop') person.pets.count # => 1 person.pets.any?  # => true  Calling it without a block when the collection is not yet loaded is equivalent to <tt>collection.exists?</tt>. If you're going to load the collection anyway, it is better to call <tt>collection.load.any?</tt> to avoid an extra query.  You can also pass a +block+ to define criteria. The behavior is the same, it returns true if the collection based on the criteria is not empty.  person.pets # => [#<Pet name: \"Snoop\", group: \"dogs\">]  person.pets.any? do |pet| pet.group == 'cats' end # => false  person.pets.any? do |pet| pet.group == 'dogs' end # => true  :method: many?  :call-seq: many?()  Returns true if the collection has more than one record. Equivalent to <tt>collection.size > 1</tt>.  class Person < ActiveRecord::Base has_many :pets end  person.pets.count # => 1 person.pets.many? # => false  person.pets << Pet.new(name: 'Snoopy') person.pets.count # => 2 person.pets.many? # => true  You can also pass a +block+ to define criteria. The behavior is the same, it returns true if the collection based on the criteria has more than one record.  person.pets # => [ #      #<Pet name: \"Gorby\", group: \"cats\">, #      #<Pet name: \"Puff\", group: \"cats\">, #      #<Pet name: \"Snoop\", group: \"dogs\"> #    ]  person.pets.many? do |pet| pet.group == 'dogs' end # => false  person.pets.many? do |pet| pet.group == 'cats' end # => true Returns +true+ if the given +record+ is present in the collection.  class Person < ActiveRecord::Base has_many :pets end  person.pets # => [#<Pet id: 20, name: \"Snoop\">]  person.pets.include?(Pet.find(20)) # => true person.pets.include?(Pet.find(21)) # => false",
    "label": "",
    "id": "1773"
  },
  {
    "raw_code": "def proxy_association\n        @association\n      end",
    "comment": "Returns the association object for the collection.  class Person < ActiveRecord::Base has_many :pets end  person.pets.proxy_association # => #<ActiveRecord::Associations::HasManyAssociation owner=\"#<Person:0x00>\">  Returns the same object as <tt>person.association(:pets)</tt>, allowing you to make calls like <tt>person.pets.proxy_association.owner</tt>.  See Associations::ClassMethods@Association+extensions for more.",
    "label": "",
    "id": "1774"
  },
  {
    "raw_code": "def scope\n        @scope ||= @association.scope\n      end",
    "comment": "Returns a Relation object for the records in this association",
    "label": "",
    "id": "1775"
  },
  {
    "raw_code": "def ==(other)\n        load_target == other\n      end",
    "comment": "Equivalent to <tt>Array#==</tt>. Returns +true+ if the two arrays contain the same number of elements and if each element is equal to the corresponding element in the +other+ array, otherwise returns +false+.  class Person < ActiveRecord::Base has_many :pets end  person.pets # => [ #      #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #      #<Pet id: 2, name: \"Spook\", person_id: 1> #    ]  other = person.pets.to_ary  person.pets == other # => true   Note that unpersisted records can still be seen as equal:  other = [Pet.new(id: 1), Pet.new(id: 2)]  person.pets == other # => true",
    "label": "",
    "id": "1776"
  },
  {
    "raw_code": "def records # :nodoc:\n        load_target\n      end",
    "comment": " :method: to_ary  :call-seq: to_ary()  Returns a new array of objects from the collection. If the collection hasn't been loaded, it fetches the records from the database.  class Person < ActiveRecord::Base has_many :pets end  person.pets # => [ #       #<Pet id: 4, name: \"Benny\", person_id: 1>, #       #<Pet id: 5, name: \"Brain\", person_id: 1>, #       #<Pet id: 6, name: \"Boss\",  person_id: 1> #    ]  other_pets = person.pets.to_ary # => [ #       #<Pet id: 4, name: \"Benny\", person_id: 1>, #       #<Pet id: 5, name: \"Brain\", person_id: 1>, #       #<Pet id: 6, name: \"Boss\",  person_id: 1> #    ]  other_pets.replace([Pet.new(name: 'BooGoo')])  other_pets # => [#<Pet id: nil, name: \"BooGoo\", person_id: 1>]  person.pets # This is not affected by replace # => [ #       #<Pet id: 4, name: \"Benny\", person_id: 1>, #       #<Pet id: 5, name: \"Brain\", person_id: 1>, #       #<Pet id: 6, name: \"Boss\",  person_id: 1> #    ]",
    "label": "",
    "id": "1777"
  },
  {
    "raw_code": "def <<(*records)\n        proxy_association.concat(records) && self\n      end",
    "comment": "Adds one or more +records+ to the collection by setting their foreign keys to the association's primary key. Since <tt><<</tt> flattens its argument list and inserts each record, +push+ and +concat+ behave identically. Returns +self+ so several appends may be chained together.  class Person < ActiveRecord::Base has_many :pets end  person.pets.size # => 0 person.pets << Pet.new(name: 'Fancy-Fancy') person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')] person.pets.size # => 3  person.id # => 1 person.pets # => [ #      #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>, #      #<Pet id: 2, name: \"Spook\", person_id: 1>, #      #<Pet id: 3, name: \"Choo-Choo\", person_id: 1> #    ]",
    "label": "",
    "id": "1778"
  },
  {
    "raw_code": "def clear\n        delete_all\n        self\n      end",
    "comment": "Equivalent to +delete_all+. The difference is that returns +self+, instead of an array with the deleted objects, so methods can be chained. See +delete_all+ for more information. Note that because +delete_all+ removes records by directly running an SQL query into the database, the +updated_at+ column of the object is not changed.",
    "label": "",
    "id": "1779"
  },
  {
    "raw_code": "def reload\n        proxy_association.reload(true)\n        reset_scope\n      end",
    "comment": "Reloads the collection from the database. Returns +self+.  class Person < ActiveRecord::Base has_many :pets end  person.pets # fetches pets from the database # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]  person.pets # uses the pets cache # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]  person.pets.reload # fetches pets from the database # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]",
    "label": "",
    "id": "1780"
  },
  {
    "raw_code": "def reset\n        proxy_association.reset\n        proxy_association.reset_scope\n        reset_scope\n      end",
    "comment": "Unloads the association. Returns +self+.  class Person < ActiveRecord::Base has_many :pets end  person.pets # fetches pets from the database # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]  person.pets # uses the pets cache # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]  person.pets.reset # clears the pets cache  person.pets  # fetches pets from the database # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]",
    "label": "",
    "id": "1781"
  },
  {
    "raw_code": "def set_owner_attributes(record)\n        return if options[:through]\n\n        primary_key_attribute_names = Array(reflection.join_primary_key)\n        foreign_key_attribute_names = Array(reflection.join_foreign_key)\n\n        primary_key_foreign_key_pairs = primary_key_attribute_names.zip(foreign_key_attribute_names)\n\n        primary_key_foreign_key_pairs.each do |primary_key, foreign_key|\n          value = owner._read_attribute(foreign_key)\n          record._write_attribute(primary_key, value)\n        end",
    "comment": "Sets the owner attributes on the given record",
    "label": "",
    "id": "1782"
  },
  {
    "raw_code": "def count_records\n          count = if reflection.has_active_cached_counter?\n            owner.read_attribute(reflection.counter_cache_column).to_i\n          else\n            scope.count(:all)\n          end",
    "comment": "Returns the number of records in this collection.  If the association has a counter cache it gets that value. Otherwise it will attempt to do a count via SQL, bounded to <tt>:limit</tt> if there's one. Some configuration options like :group make it impossible to do an SQL count, in those cases the array count will be used.  That does not depend on whether the collection has already been loaded or not. The +size+ method is the one that takes the loaded flag into account and delegates to +count_records+ if needed.  If the collection is empty the target is set to an empty array and the loaded flag is set to true as well.",
    "label": "",
    "id": "1783"
  },
  {
    "raw_code": "def delete_records(records, method)\n          if method == :destroy\n            records.each(&:destroy!)\n            update_counter(-records.length) unless reflection.inverse_updates_counter_cache?\n          else\n            query_constraints = reflection.klass.composite_query_constraints_list\n            values = records.map { |r| query_constraints.map { |col| r._read_attribute(col) } }\n            scope = self.scope.where(query_constraints => values)\n            update_counter(-delete_count(method, scope))\n          end",
    "comment": "Deletes the records according to the <tt>:dependent</tt> option.",
    "label": "",
    "id": "1784"
  },
  {
    "raw_code": "def build_through_record(record)\n          @through_records[record] ||= begin\n            ensure_mutable\n\n            attributes = through_scope_attributes\n            attributes[source_reflection.name] = record\n\n            through_association.build(attributes).tap do |new_record|\n              new_record.send(\"#{source_reflection.foreign_type}=\", options[:source_type]) if options[:source_type]\n            end",
    "comment": "The through record (built with build_record) is temporarily cached so that it may be reused if insert_record is subsequently called.  However, after insert_record has been called, the cache is cleared in order to allow multiple instances of the same record in an association.",
    "label": "",
    "id": "1785"
  },
  {
    "raw_code": "def invertible_for?(record)\n          false\n        end",
    "comment": "NOTE - not sure that we can actually cope with inverses here",
    "label": "",
    "id": "1786"
  },
  {
    "raw_code": "def set_new_record(record)\n          replace(record, false)\n        end",
    "comment": "The reason that the save param for replace is false, if for create (not just build), is because the setting of the foreign keys is actually handled by the scoping when the record is instantiated, and so they are set straight away and do not need to be updated within replace.",
    "label": "",
    "id": "1787"
  },
  {
    "raw_code": "def initialize(records:, associations:, scope: nil, available_records: [], associate_by_default: true)\n        @records = records\n        @associations = associations\n        @scope = scope\n        @available_records = available_records || []\n        @associate_by_default = associate_by_default\n\n        @tree = Branch.new(\n          parent: nil,\n          association: nil,\n          children: @associations,\n          associate_by_default: @associate_by_default,\n          scope: @scope\n        )\n        @tree.preloaded_records = @records\n      end",
    "comment": "Eager loads the named associations for the given Active Record record(s).  In this description, 'association name' shall refer to the name passed to an association creation method. For example, a model that specifies <tt>belongs_to :author</tt>, <tt>has_many :buyers</tt> has association names +:author+ and +:buyers+.  == Parameters +records+ is an array of ActiveRecord::Base. This array needs not be flat, i.e. +records+ itself may also contain arrays of records. In any case, +preload_associations+ will preload all associations records by flattening +records+.  +associations+ specifies one or more associations that you want to preload. It may be: - a Symbol or a String which specifies a single association name. For example, specifying +:books+ allows this method to preload all books for an Author. - an Array which specifies multiple association names. This array is processed recursively. For example, specifying <tt>[:avatar, :books]</tt> allows this method to preload an author's avatar as well as all of their books. - a Hash which specifies multiple association names, as well as association names for the to-be-preloaded association objects. For example, specifying <tt>{ author: :avatar }</tt> will preload a book's author, as well as that author's avatar.  +:associations+ has the same format as the arguments to ActiveRecord::QueryMethods#includes. So +associations+ could look like this:  :books [ :books, :author ] { author: :avatar } [ :books, { author: :avatar } ]  +available_records+ is an array of ActiveRecord::Base. The Preloader will try to use the objects in this array to preload the requested associations before querying the database. This can save database queries by reusing in-memory objects. The optimization is only applied to single associations (i.e. :belongs_to, :has_one) with no scopes.",
    "label": "",
    "id": "1788"
  },
  {
    "raw_code": "def reader\n        ensure_klass_exists!\n\n        if !loaded? || stale_target?\n          reload\n        end",
    "comment": "Implements the reader method, e.g. foo.bar for Foo.has_one :bar",
    "label": "",
    "id": "1789"
  },
  {
    "raw_code": "def reset\n        super\n        @target = nil\n        @future_target = nil\n      end",
    "comment": "Resets the \\loaded flag to +false+ and sets the \\target to +nil+.",
    "label": "",
    "id": "1790"
  },
  {
    "raw_code": "def writer(record)\n        replace(record)\n      end",
    "comment": "Implements the writer method, e.g. foo.bar= for Foo.belongs_to :bar",
    "label": "",
    "id": "1791"
  },
  {
    "raw_code": "def force_reload_reader\n        reload(true)\n        target\n      end",
    "comment": "Implements the reload reader method, e.g. foo.reload_bar for Foo.has_one :bar",
    "label": "",
    "id": "1792"
  },
  {
    "raw_code": "def target_scope\n          scope = super\n          reflection.chain.drop(1).each do |reflection|\n            relation = reflection.klass.scope_for_association\n            scope.merge!(\n              relation.except(:select, :create_with, :includes, :preload, :eager_load, :joins, :left_outer_joins)\n            )\n          end",
    "comment": "We merge in these scopes for two reasons:  1. To get the default_scope conditions for any of the other reflections in the chain 2. To get the type conditions for any STI models in the chain",
    "label": "",
    "id": "1793"
  },
  {
    "raw_code": "def construct_join_attributes(*records)\n          ensure_mutable\n\n          association_primary_key = source_reflection.association_primary_key(reflection.klass)\n\n          if Array(association_primary_key) == reflection.klass.composite_query_constraints_list && !options[:source_type]\n            join_attributes = { source_reflection.name => records }\n          else\n            assoc_pk_values = records.map { |record| record._read_attribute(association_primary_key) }\n            join_attributes = { source_reflection.foreign_key => assoc_pk_values }\n          end",
    "comment": "Construct attributes for :through pointing to owner and associate. This is used by the methods which create and delete records on the association.  We only support indirectly modifying through associations which have a belongs_to source. This is the \"has_many :tags, through: :taggings\" situation, where the join model typically has a belongs_to on both side. In other words, associations which could also be represented as has_and_belongs_to_many associations.  We do not support creating/deleting records on the association where the source has some other type, because this opens up a whole can of worms, and in basically any situation it is more natural for the user to just create or modify their join records directly as required.",
    "label": "",
    "id": "1794"
  },
  {
    "raw_code": "def stale_state\n          if through_reflection.belongs_to?\n            Array(through_reflection.foreign_key).filter_map do |foreign_key_column|\n              owner[foreign_key_column]\n            end.presence\n          end",
    "comment": "Note: this does not capture all cases, for example it would be impractical to try to properly support stale-checking for nested associations.",
    "label": "",
    "id": "1795"
  },
  {
    "raw_code": "def self.define_accessors(model, reflection)\n      mixin = model.generated_association_methods\n      name = reflection.name\n      define_readers(mixin, name)\n      define_writers(mixin, name)\n    end",
    "comment": "Defines the setter and getter methods for the association class Post < ActiveRecord::Base has_many :comments end  Post.first.comments and Post.first.comments= methods are defined by this method...",
    "label": "",
    "id": "1796"
  },
  {
    "raw_code": "def self.define_readers(mixin, name)\n      super\n\n      mixin.class_eval <<-CODE, __FILE__, __LINE__ + 1\n        def #{name.to_s.singularize}_ids\n          association = association(:#{name})\n          deprecated_associations_api_guard(association, __method__)\n          association.ids_reader\n        end\n      CODE\n    end",
    "comment": "Defines the setter and getter methods for the collection_singular_ids.",
    "label": "",
    "id": "1797"
  },
  {
    "raw_code": "def self.define_constructors(mixin, name)\n      mixin.class_eval <<-CODE, __FILE__, __LINE__ + 1\n        def build_#{name}(*args, &block)\n          association = association(:#{name})\n          deprecated_associations_api_guard(association, __method__)\n          association.build(*args, &block)\n        end\n\n        def create_#{name}(*args, &block)\n          association = association(:#{name})\n          deprecated_associations_api_guard(association, __method__)\n          association.create(*args, &block)\n        end\n\n        def create_#{name}!(*args, &block)\n          association = association(:#{name})\n          deprecated_associations_api_guard(association, __method__)\n          association.create!(*args, &block)\n        end\n      CODE\n    end",
    "comment": "Defines the (build|create)_association methods for belongs_to or has_one association",
    "label": "",
    "id": "1798"
  },
  {
    "raw_code": "def table\n          raise NotImplementedError\n        end",
    "comment": "An Arel::Table for the active_record",
    "label": "",
    "id": "1799"
  },
  {
    "raw_code": "def association_key_name\n          reflection.join_primary_key(klass)\n        end",
    "comment": "The name of the key on the associated records",
    "label": "",
    "id": "1800"
  },
  {
    "raw_code": "def owner_key_name\n            reflection.join_foreign_key\n          end",
    "comment": "The name of the key on the model which declares the association",
    "label": "",
    "id": "1801"
  },
  {
    "raw_code": "def preloader_for(reflection)\n            if reflection.options[:through]\n              ThroughAssociation\n            else\n              Association\n            end",
    "comment": "Returns a class containing the logic needed to load preload the data and attach it to a relation. The class returned implements a `run` method that accepts a preloader.",
    "label": "",
    "id": "1802"
  },
  {
    "raw_code": "def read_attribute_before_type_cast(attr_name)\n        name = attr_name.to_s\n        name = self.class.attribute_aliases[name] || name\n\n        attribute_before_type_cast(name)\n      end",
    "comment": "Returns the value of the attribute identified by +attr_name+ before typecasting and deserialization.  class Task < ActiveRecord::Base end  task = Task.new(id: '1', completed_on: '2012-10-21') task.read_attribute('id')                            # => 1 task.read_attribute_before_type_cast('id')           # => '1' task.read_attribute('completed_on')                  # => Sun, 21 Oct 2012 task.read_attribute_before_type_cast('completed_on') # => \"2012-10-21\" task.read_attribute_before_type_cast(:completed_on)  # => \"2012-10-21\"",
    "label": "",
    "id": "1803"
  },
  {
    "raw_code": "def read_attribute_for_database(attr_name)\n        name = attr_name.to_s\n        name = self.class.attribute_aliases[name] || name\n\n        attribute_for_database(name)\n      end",
    "comment": "Returns the value of the attribute identified by +attr_name+ after serialization.  class Book < ActiveRecord::Base enum :status, { draft: 1, published: 2 } end  book = Book.new(status: \"published\") book.read_attribute(:status)              # => \"published\" book.read_attribute_for_database(:status) # => 2",
    "label": "",
    "id": "1804"
  },
  {
    "raw_code": "def attributes_before_type_cast\n        @attributes.values_before_type_cast\n      end",
    "comment": "Returns a hash of attributes before typecasting and deserialization.  class Task < ActiveRecord::Base end  task = Task.new(title: nil, is_done: true, completed_on: '2012-10-21') task.attributes # => {\"id\"=>nil, \"title\"=>nil, \"is_done\"=>true, \"completed_on\"=>Sun, 21 Oct 2012, \"created_at\"=>nil, \"updated_at\"=>nil} task.attributes_before_type_cast # => {\"id\"=>nil, \"title\"=>nil, \"is_done\"=>true, \"completed_on\"=>\"2012-10-21\", \"created_at\"=>nil, \"updated_at\"=>nil}",
    "label": "",
    "id": "1805"
  },
  {
    "raw_code": "def attributes_for_database\n        @attributes.values_for_database\n      end",
    "comment": "Returns a hash of attributes for assignment to the database.",
    "label": "",
    "id": "1806"
  },
  {
    "raw_code": "def attribute_before_type_cast(attr_name)\n          @attributes[attr_name].value_before_type_cast\n        end",
    "comment": "Dispatch target for <tt>*_before_type_cast</tt> attribute methods.",
    "label": "",
    "id": "1807"
  },
  {
    "raw_code": "def id\n        if self.class.composite_primary_key?\n          @primary_key.map { |pk| _read_attribute(pk) }\n        else\n          super\n        end",
    "comment": "Returns the primary key column's value. If the primary key is composite, returns an array of the primary key column values.",
    "label": "",
    "id": "1808"
  },
  {
    "raw_code": "def id=(value)\n        if self.class.composite_primary_key?\n          raise TypeError, \"Expected value matching #{self.class.primary_key.inspect}, got #{value.inspect}.\" unless value.is_a?(Enumerable)\n          @primary_key.zip(value) { |attr, value| _write_attribute(attr, value) }\n        else\n          super\n        end",
    "comment": "Sets the primary key column's value. If the primary key is composite, raises TypeError when the set value not enumerable.",
    "label": "",
    "id": "1809"
  },
  {
    "raw_code": "def id?\n        if self.class.composite_primary_key?\n          @primary_key.all? { |col| _query_attribute(col) }\n        else\n          super\n        end",
    "comment": "Queries the primary key column's value. If the primary key is composite, all primary key column values must be queryable.",
    "label": "",
    "id": "1810"
  },
  {
    "raw_code": "def id_before_type_cast\n        if self.class.composite_primary_key?\n          @primary_key.map { |col| attribute_before_type_cast(col) }\n        else\n          super\n        end",
    "comment": "Returns the primary key column's value before type cast. If the primary key is composite, returns an array of primary key column values before type cast.",
    "label": "",
    "id": "1811"
  },
  {
    "raw_code": "def id_was\n        if self.class.composite_primary_key?\n          @primary_key.map { |col| attribute_was(col) }\n        else\n          super\n        end",
    "comment": "Returns the primary key column's previous value. If the primary key is composite, returns an array of primary key column previous values.",
    "label": "",
    "id": "1812"
  },
  {
    "raw_code": "def id_in_database\n        if self.class.composite_primary_key?\n          @primary_key.map { |col| attribute_in_database(col) }\n        else\n          super\n        end",
    "comment": "Returns the primary key column's value from the database. If the primary key is composite, returns an array of primary key column values from database.",
    "label": "",
    "id": "1813"
  },
  {
    "raw_code": "def reload(*)\n        super.tap do\n          @mutations_before_last_save = nil\n          @mutations_from_database = nil\n        end",
    "comment": "<tt>reload</tt> the record and clears changed attributes.",
    "label": "",
    "id": "1814"
  },
  {
    "raw_code": "def saved_change_to_attribute?(attr_name, **options)\n        mutations_before_last_save.changed?(attr_name.to_s, **options)\n      end",
    "comment": "Did this attribute change when we last saved?  This method is useful in after callbacks to determine if an attribute was changed during the save that triggered the callbacks to run. It can be invoked as +saved_change_to_name?+ instead of <tt>saved_change_to_attribute?(\"name\")</tt>.  ==== Options  [+from+] When specified, this method will return false unless the original value is equal to the given value.  [+to+] When specified, this method will return false unless the value will be changed to the given value.",
    "label": "",
    "id": "1815"
  },
  {
    "raw_code": "def saved_change_to_attribute(attr_name)\n        mutations_before_last_save.change_to_attribute(attr_name.to_s)\n      end",
    "comment": "Returns the change to an attribute during the last save. If the attribute was changed, the result will be an array containing the original value and the saved value.  This method is useful in after callbacks, to see the change in an attribute during the save that triggered the callbacks to run. It can be invoked as +saved_change_to_name+ instead of <tt>saved_change_to_attribute(\"name\")</tt>.",
    "label": "",
    "id": "1816"
  },
  {
    "raw_code": "def attribute_before_last_save(attr_name)\n        mutations_before_last_save.original_value(attr_name.to_s)\n      end",
    "comment": "Returns the original value of an attribute before the last save.  This method is useful in after callbacks to get the original value of an attribute before the save that triggered the callbacks to run. It can be invoked as +name_before_last_save+ instead of <tt>attribute_before_last_save(\"name\")</tt>.",
    "label": "",
    "id": "1817"
  },
  {
    "raw_code": "def saved_changes?\n        mutations_before_last_save.any_changes?\n      end",
    "comment": "Did the last call to +save+ have any changes to change?",
    "label": "",
    "id": "1818"
  },
  {
    "raw_code": "def saved_changes\n        mutations_before_last_save.changes\n      end",
    "comment": "Returns a hash containing all the changes that were just saved.",
    "label": "",
    "id": "1819"
  },
  {
    "raw_code": "def will_save_change_to_attribute?(attr_name, **options)\n        mutations_from_database.changed?(attr_name.to_s, **options)\n      end",
    "comment": "Will this attribute change the next time we save?  This method is useful in validations and before callbacks to determine if the next call to +save+ will change a particular attribute. It can be invoked as +will_save_change_to_name?+ instead of <tt>will_save_change_to_attribute?(\"name\")</tt>.  ==== Options  [+from+] When specified, this method will return false unless the original value is equal to the given value.  [+to+] When specified, this method will return false unless the value will be changed to the given value.",
    "label": "",
    "id": "1820"
  },
  {
    "raw_code": "def attribute_change_to_be_saved(attr_name)\n        mutations_from_database.change_to_attribute(attr_name.to_s)\n      end",
    "comment": "Returns the change to an attribute that will be persisted during the next save.  This method is useful in validations and before callbacks, to see the change to an attribute that will occur when the record is saved. It can be invoked as +name_change_to_be_saved+ instead of <tt>attribute_change_to_be_saved(\"name\")</tt>.  If the attribute will change, the result will be an array containing the original value and the new value about to be saved.",
    "label": "",
    "id": "1821"
  },
  {
    "raw_code": "def attribute_in_database(attr_name)\n        mutations_from_database.original_value(attr_name.to_s)\n      end",
    "comment": "Returns the value of an attribute in the database, as opposed to the in-memory value that will be persisted the next time the record is saved.  This method is useful in validations and before callbacks, to see the original value of an attribute prior to any changes about to be saved. It can be invoked as +name_in_database+ instead of <tt>attribute_in_database(\"name\")</tt>.",
    "label": "",
    "id": "1822"
  },
  {
    "raw_code": "def has_changes_to_save?\n        mutations_from_database.any_changes?\n      end",
    "comment": "Will the next call to +save+ have any changes to persist?",
    "label": "",
    "id": "1823"
  },
  {
    "raw_code": "def changes_to_save\n        mutations_from_database.changes\n      end",
    "comment": "Returns a hash containing all the changes that will be persisted during the next save.",
    "label": "",
    "id": "1824"
  },
  {
    "raw_code": "def changed_attribute_names_to_save\n        mutations_from_database.changed_attribute_names\n      end",
    "comment": "Returns an array of the names of any attributes that will change when the record is next saved.",
    "label": "",
    "id": "1825"
  },
  {
    "raw_code": "def attributes_in_database\n        mutations_from_database.changed_values\n      end",
    "comment": "Returns a hash of the attributes that will change when the record is next saved.  The hash keys are the attribute names, and the hash values are the original attribute values in the database (as opposed to the in-memory values about to be saved).",
    "label": "",
    "id": "1826"
  },
  {
    "raw_code": "def to_key\n        key = id\n        Array(key) if key\n      end",
    "comment": "Returns this record's primary key value wrapped in an array if one is available.",
    "label": "",
    "id": "1827"
  },
  {
    "raw_code": "def id\n        _read_attribute(@primary_key)\n      end",
    "comment": "Returns the primary key column's value. If the primary key is composite, returns an array of the primary key column values.",
    "label": "",
    "id": "1828"
  },
  {
    "raw_code": "def id=(value)\n        _write_attribute(@primary_key, value)\n      end",
    "comment": "Sets the primary key column's value. If the primary key is composite, raises TypeError when the set value not enumerable.",
    "label": "",
    "id": "1829"
  },
  {
    "raw_code": "def id?\n        _query_attribute(@primary_key)\n      end",
    "comment": "Queries the primary key column's value. If the primary key is composite, all primary key column values must be queryable.",
    "label": "",
    "id": "1830"
  },
  {
    "raw_code": "def id_before_type_cast\n        attribute_before_type_cast(@primary_key)\n      end",
    "comment": "Returns the primary key column's value before type cast. If the primary key is composite, returns an array of primary key column values before type cast.",
    "label": "",
    "id": "1831"
  },
  {
    "raw_code": "def id_was\n        attribute_was(@primary_key)\n      end",
    "comment": "Returns the primary key column's previous value. If the primary key is composite, returns an array of primary key column previous values.",
    "label": "",
    "id": "1832"
  },
  {
    "raw_code": "def id_in_database\n        attribute_in_database(@primary_key)\n      end",
    "comment": "Returns the primary key column's value from the database. If the primary key is composite, returns an array of primary key column values from database.",
    "label": "",
    "id": "1833"
  },
  {
    "raw_code": "def primary_key\n            reset_primary_key if PRIMARY_KEY_NOT_SET.equal?(@primary_key)\n            @primary_key\n          end",
    "comment": "Defines the primary key field -- can be overridden in subclasses. Overwriting will negate any effect of the +primary_key_prefix_type+ setting, though.",
    "label": "",
    "id": "1834"
  },
  {
    "raw_code": "def quoted_primary_key\n            adapter_class.quote_column_name(primary_key)\n          end",
    "comment": "Returns a quoted version of the primary key name.",
    "label": "",
    "id": "1835"
  },
  {
    "raw_code": "def primary_key=(value)\n            @primary_key = if value.is_a?(Array)\n              include CompositePrimaryKey\n              @primary_key = value.map { |v| -v.to_s }.freeze\n            elsif value\n              -value.to_s\n            end",
    "comment": "Sets the name of the primary key column.  class Project < ActiveRecord::Base self.primary_key = 'sysid' end  You can also define the #primary_key method yourself:  class Project < ActiveRecord::Base def self.primary_key 'foo_' + super end end  Project.primary_key # => \"foo_id\"",
    "label": "",
    "id": "1836"
  },
  {
    "raw_code": "def query_attribute(attr_name)\n        value = self.public_send(attr_name)\n\n        query_cast_attribute(attr_name, value)\n      end",
    "comment": "Returns +true+ or +false+ for the attribute identified by +attr_name+, depending on the attribute type and value.",
    "label": "",
    "id": "1837"
  },
  {
    "raw_code": "def read_attribute(attr_name, &block)\n        name = attr_name.to_s\n        name = self.class.attribute_aliases[name] || name\n\n        @attributes.fetch_value(name, &block)\n      end",
    "comment": "Returns the value of the attribute identified by +attr_name+ after it has been type cast. For example, a date attribute will cast \"2004-12-12\" to <tt>Date.new(2004, 12, 12)</tt>. (For information about specific type casting behavior, see the types under ActiveModel::Type.)",
    "label": "",
    "id": "1838"
  },
  {
    "raw_code": "def _read_attribute(attr_name, &block) # :nodoc:\n        @attributes.fetch_value(attr_name, &block)\n      end",
    "comment": "This method exists to avoid the expensive primary_key check internally, without breaking compatibility with the read_attribute API",
    "label": "",
    "id": "1839"
  },
  {
    "raw_code": "def serialize(attr_name, coder: nil, type: Object, comparable: false, yaml: {}, **options)\n          coder ||= default_column_serializer\n          unless coder\n            raise ArgumentError, <<~MSG.squish\n              missing keyword: :coder\n\n              If no default coder is configured, a coder must be provided to `serialize`.\n            MSG\n          end",
    "comment": "If you have an attribute that needs to be saved to the database as a serialized object, and retrieved by deserializing into the same object, then specify the name of that attribute using this method and serialization will be handled automatically.  The serialization format may be YAML, JSON, or any custom format using a custom coder class.  Keep in mind that database adapters handle certain serialization tasks for you. For instance: +json+ and +jsonb+ types in PostgreSQL will be converted between JSON object/array syntax and Ruby +Hash+ or +Array+ objects transparently. There is no need to use #serialize in this case.  For more complex cases, such as conversion to or from your application domain objects, consider using the ActiveRecord::Attributes API.  ==== Parameters  * +attr_name+ - The name of the attribute to serialize. * +coder+ The serializer implementation to use, e.g. +JSON+. * The attribute value will be serialized using the coder's <tt>dump(value)</tt> method, and will be deserialized using the coder's <tt>load(string)</tt> method. The +dump+ method may return +nil+ to serialize the value as +NULL+. * +type+ - Optional. What the type of the serialized object should be. * Attempting to serialize another type will raise an ActiveRecord::SerializationTypeMismatch error. * If the column is +NULL+ or starting from a new record, the default value will set to +type.new+ * +comparable+ - Specify whether the deserialized object is safely comparable for the purpose of detecting changes. Defaults to +false+ When set to +false+ the old and new values will be compared by their serialized representation (e.g. JSON or YAML), which can sometimes cause two objects that are semantically equal to be considered different. For instance two hashes with the same keys and values but a different order have a different serialized representation, but are semantically equal once deserialized. If set to +true+ the comparison will be done on the deserialized object. This options should only be enabled if the +type+ is known to have a proper <tt>==</tt> method that deeply compare the objects. * +yaml+ - Optional. Yaml specific options. The allowed config is: * +:permitted_classes+ - +Array+ with the permitted classes. * +:unsafe_load+ - Unsafely load YAML blobs, allow YAML to load any class.  ==== Options  * +:default+ - The default value to use when no value is provided. If this option is not passed, the previous default value (if any) will be used. Otherwise, the default will be +nil+.  ==== Choosing a serializer  While any serialization format can be used, it is recommended to carefully evaluate the properties of a serializer before using it, as migrating to another format later on can be difficult.  ===== Avoid accepting arbitrary types  When serializing data in a column, it is heavily recommended to make sure only expected types will be serialized. For instance some serializer like +Marshal+ or +YAML+ are capable of serializing almost any Ruby object.  This can lead to unexpected types being serialized, and it is important that type serialization remains backward and forward compatible as long as some database records still contain these serialized types.  class Address def initialize(line, city, country) @line, @city, @country = line, city, country end end  In the above example, if any of the +Address+ attributes is renamed, instances that were persisted before the change will be loaded with the old attributes. This problem is even worse when the serialized type comes from a dependency which doesn't expect to be serialized this way and may change its internal representation without notice.  As such, it is heavily recommended to instead convert these objects into primitives of the serialization format, for example:  class Address attr_reader :line, :city, :country  def self.load(payload) data = YAML.safe_load(payload) new(data[\"line\"], data[\"city\"], data[\"country\"]) end  def self.dump(address) YAML.safe_dump( \"line\" => address.line, \"city\" => address.city, \"country\" => address.country, ) end  def initialize(line, city, country) @line, @city, @country = line, city, country end end  class User < ActiveRecord::Base serialize :address, coder: Address end  This pattern allows to be more deliberate about what is serialized, and to evolve the format in a backward compatible way.  ===== Ensure serialization stability  Some serialization methods may accept some types they don't support by silently casting them to other types. This can cause bugs when the data is deserialized.  For instance the +JSON+ serializer provided in the standard library will silently cast unsupported types to +String+:  >> JSON.parse(JSON.dump(Struct.new(:foo))) # => \"#<Class:0x000000013090b4c0>\"  ==== Examples  ===== Serialize the +preferences+ attribute using YAML  class User < ActiveRecord::Base serialize :preferences, coder: YAML end  ===== Serialize the +preferences+ attribute using JSON  class User < ActiveRecord::Base serialize :preferences, coder: JSON end  ===== Serialize the +preferences+ +Hash+ using YAML  class User < ActiveRecord::Base serialize :preferences, type: Hash, coder: YAML end  ===== Serializes +preferences+ to YAML, permitting select classes  class User < ActiveRecord::Base serialize :preferences, coder: YAML, yaml: { permitted_classes: [Symbol, Time] } end  ===== Serialize the +preferences+ attribute using a custom coder  class Rot13JSON def self.rot13(string) string.tr(\"a-zA-Z\", \"n-za-mN-ZA-M\") end  # Serializes an attribute value to a string that will be stored in the database. def self.dump(value) rot13(ActiveSupport::JSON.dump(value)) end  # Deserializes a string from the database to an attribute value. def self.load(string) ActiveSupport::JSON.load(rot13(string)) end end  class User < ActiveRecord::Base serialize :preferences, coder: Rot13JSON end ",
    "label": "",
    "id": "1840"
  },
  {
    "raw_code": "def write_attribute(attr_name, value)\n        name = attr_name.to_s\n        name = self.class.attribute_aliases[name] || name\n\n        name = @primary_key if name == \"id\" && @primary_key\n        @attributes.write_from_user(name, value)\n      end",
    "comment": "Updates the attribute identified by +attr_name+ using the specified +value+. The attribute value will be type cast upon being read.",
    "label": "",
    "id": "1841"
  },
  {
    "raw_code": "def _write_attribute(attr_name, value) # :nodoc:\n        @attributes.write_from_user(attr_name, value)\n      end",
    "comment": "This method exists to avoid the expensive primary_key check internally, without breaking compatibility with the write_attribute API",
    "label": "",
    "id": "1842"
  },
  {
    "raw_code": "def assert_valid_value(object, action:)\n        unless object.nil? || object_class === object\n          raise SerializationTypeMismatch,\n            \"can't #{action} `#{@attr_name}`: was supposed to be a #{object_class}, but was a #{object.class}. -- #{object.inspect}\"\n        end",
    "comment": "Public because it's called by Type::Serialized",
    "label": "",
    "id": "1843"
  },
  {
    "raw_code": "def self.dbconsole(config, options = {})\n        raise NotImplementedError.new(\"#{self.class} should define `dbconsole` that accepts a db config and options to implement connecting to the db console\")\n      end",
    "comment": "Opens a database console session.",
    "label": "",
    "id": "1844"
  },
  {
    "raw_code": "def preventing_writes?\n        return true if replica?\n        return false if connection_descriptor.nil?\n\n        connection_descriptor.current_preventing_writes\n      end",
    "comment": "Determines whether writes are currently being prevented.  Returns true if the connection is a replica or returns the value of +current_preventing_writes+.",
    "label": "",
    "id": "1845"
  },
  {
    "raw_code": "def lease\n        if in_use?\n          msg = +\"Cannot lease connection, \"\n          if @owner == ActiveSupport::IsolatedExecutionState.context\n            msg << \"it is already leased by the current thread.\"\n          else\n            msg << \"it is already in use by a different thread: #{@owner}. \" \\\n                   \"Current thread: #{ActiveSupport::IsolatedExecutionState.context}.\"\n          end",
    "comment": "this method must only be called while holding connection pool's mutex",
    "label": "",
    "id": "1846"
  },
  {
    "raw_code": "def role\n        @pool.role\n      end",
    "comment": "The role (e.g. +:writing+) for the current connection. In a non-multi role application, +:writing+ is returned.",
    "label": "",
    "id": "1847"
  },
  {
    "raw_code": "def shard\n        @pool.shard\n      end",
    "comment": "The shard (e.g. +:default+) for the current connection. In a non-sharded application, +:default+ is returned.",
    "label": "",
    "id": "1848"
  },
  {
    "raw_code": "def expire(update_idle = true) # :nodoc:\n        if in_use?\n          if @owner != ActiveSupport::IsolatedExecutionState.context\n            raise ActiveRecordError, \"Cannot expire connection, \" \\\n              \"it is owned by a different thread: #{@owner}. \" \\\n              \"Current thread: #{ActiveSupport::IsolatedExecutionState.context}.\"\n          end",
    "comment": "this method must only be called while holding connection pool's mutex",
    "label": "",
    "id": "1849"
  },
  {
    "raw_code": "def steal! # :nodoc:\n        if in_use?\n          if @owner != ActiveSupport::IsolatedExecutionState.context\n            pool.send :remove_connection_from_thread_cache, self, @owner\n\n            @owner = ActiveSupport::IsolatedExecutionState.context\n          end",
    "comment": "this method must only be called while holding connection pool's mutex (and a desire for segfaults)",
    "label": "",
    "id": "1850"
  },
  {
    "raw_code": "def seconds_idle # :nodoc:\n        return 0 if in_use?\n        Process.clock_gettime(Process::CLOCK_MONOTONIC) - @idle_since\n      end",
    "comment": "Seconds since this connection was returned to the pool",
    "label": "",
    "id": "1851"
  },
  {
    "raw_code": "def seconds_since_last_activity # :nodoc:\n        if @raw_connection && @last_activity\n          Process.clock_gettime(Process::CLOCK_MONOTONIC) - @last_activity\n        end",
    "comment": "Seconds since this connection last communicated with the server",
    "label": "",
    "id": "1852"
  },
  {
    "raw_code": "def connection_age # :nodoc:\n        if @raw_connection && @connected_since\n          Process.clock_gettime(Process::CLOCK_MONOTONIC) - @connected_since\n        end",
    "comment": "Seconds since this connection was established. nil if not connected; infinity if the connection has been explicitly retired.",
    "label": "",
    "id": "1853"
  },
  {
    "raw_code": "def force_retirement # :nodoc:\n        @connected_since &&= -Float::INFINITY\n      end",
    "comment": "Mark the connection as needing to be retired, as if the age has exceeded the maximum allowed.",
    "label": "",
    "id": "1854"
  },
  {
    "raw_code": "def adapter_name\n        self.class::ADAPTER_NAME\n      end",
    "comment": "Returns the human-readable name of the adapter. Use mixed case - one can always use downcase if needed.",
    "label": "",
    "id": "1855"
  },
  {
    "raw_code": "def self.database_exists?(config)\n        new(config).database_exists?\n      end",
    "comment": "Does the database for this adapter exist?",
    "label": "",
    "id": "1856"
  },
  {
    "raw_code": "def supports_ddl_transactions?\n        false\n      end",
    "comment": "Does this adapter support DDL rollbacks in transactions? That is, would CREATE TABLE or ALTER TABLE get rolled back by a transaction?",
    "label": "",
    "id": "1857"
  },
  {
    "raw_code": "def supports_savepoints?\n        false\n      end",
    "comment": "Does this adapter support savepoints?",
    "label": "",
    "id": "1858"
  },
  {
    "raw_code": "def savepoint_errors_invalidate_transactions?\n        false\n      end",
    "comment": "Do TransactionRollbackErrors on savepoints affect the parent transaction?",
    "label": "",
    "id": "1859"
  },
  {
    "raw_code": "def supports_advisory_locks?\n        false\n      end",
    "comment": "Does this adapter support application-enforced advisory locking?",
    "label": "",
    "id": "1860"
  },
  {
    "raw_code": "def prefetch_primary_key?(table_name = nil)\n        false\n      end",
    "comment": "Should primary key values be selected from their corresponding sequence before the insert statement? If true, next_sequence_value is called before each insert to set the record's primary key.",
    "label": "",
    "id": "1861"
  },
  {
    "raw_code": "def supports_index_sort_order?\n        false\n      end",
    "comment": "Does this adapter support index sort order?",
    "label": "",
    "id": "1862"
  },
  {
    "raw_code": "def supports_partial_index?\n        false\n      end",
    "comment": "Does this adapter support partial indices?",
    "label": "",
    "id": "1863"
  },
  {
    "raw_code": "def supports_index_include?\n        false\n      end",
    "comment": "Does this adapter support including non-key columns?",
    "label": "",
    "id": "1864"
  },
  {
    "raw_code": "def supports_expression_index?\n        false\n      end",
    "comment": "Does this adapter support expression indices?",
    "label": "",
    "id": "1865"
  },
  {
    "raw_code": "def supports_explain?\n        false\n      end",
    "comment": "Does this adapter support explain?",
    "label": "",
    "id": "1866"
  },
  {
    "raw_code": "def supports_transaction_isolation?\n        false\n      end",
    "comment": "Does this adapter support setting the isolation level for a transaction?",
    "label": "",
    "id": "1867"
  },
  {
    "raw_code": "def supports_extensions?\n        false\n      end",
    "comment": "Does this adapter support database extensions?",
    "label": "",
    "id": "1868"
  },
  {
    "raw_code": "def supports_indexes_in_create?\n        false\n      end",
    "comment": "Does this adapter support creating indexes in the same statement as creating the table?",
    "label": "",
    "id": "1869"
  },
  {
    "raw_code": "def supports_foreign_keys?\n        false\n      end",
    "comment": "Does this adapter support creating foreign key constraints?",
    "label": "",
    "id": "1870"
  },
  {
    "raw_code": "def supports_validate_constraints?\n        false\n      end",
    "comment": "Does this adapter support creating invalid constraints?",
    "label": "",
    "id": "1871"
  },
  {
    "raw_code": "def supports_deferrable_constraints?\n        false\n      end",
    "comment": "Does this adapter support creating deferrable constraints?",
    "label": "",
    "id": "1872"
  },
  {
    "raw_code": "def supports_check_constraints?\n        false\n      end",
    "comment": "Does this adapter support creating check constraints?",
    "label": "",
    "id": "1873"
  },
  {
    "raw_code": "def supports_exclusion_constraints?\n        false\n      end",
    "comment": "Does this adapter support creating exclusion constraints?",
    "label": "",
    "id": "1874"
  },
  {
    "raw_code": "def supports_unique_constraints?\n        false\n      end",
    "comment": "Does this adapter support creating unique constraints?",
    "label": "",
    "id": "1875"
  },
  {
    "raw_code": "def supports_views?\n        false\n      end",
    "comment": "Does this adapter support views?",
    "label": "",
    "id": "1876"
  },
  {
    "raw_code": "def supports_materialized_views?\n        false\n      end",
    "comment": "Does this adapter support materialized views?",
    "label": "",
    "id": "1877"
  },
  {
    "raw_code": "def supports_datetime_with_precision?\n        false\n      end",
    "comment": "Does this adapter support datetime with precision?",
    "label": "",
    "id": "1878"
  },
  {
    "raw_code": "def supports_json?\n        false\n      end",
    "comment": "Does this adapter support JSON data type?",
    "label": "",
    "id": "1879"
  },
  {
    "raw_code": "def supports_comments?\n        false\n      end",
    "comment": "Does this adapter support metadata comments on database objects (tables, columns, indexes)?",
    "label": "",
    "id": "1880"
  },
  {
    "raw_code": "def supports_comments_in_create?\n        false\n      end",
    "comment": "Can comments for tables, columns, and indexes be specified in create/alter table statements?",
    "label": "",
    "id": "1881"
  },
  {
    "raw_code": "def supports_virtual_columns?\n        false\n      end",
    "comment": "Does this adapter support virtual columns?",
    "label": "",
    "id": "1882"
  },
  {
    "raw_code": "def supports_foreign_tables?\n        false\n      end",
    "comment": "Does this adapter support foreign/external tables?",
    "label": "",
    "id": "1883"
  },
  {
    "raw_code": "def supports_optimizer_hints?\n        false\n      end",
    "comment": "Does this adapter support optimizer hints?",
    "label": "",
    "id": "1884"
  },
  {
    "raw_code": "def disable_extension(name, **)\n      end",
    "comment": "This is meant to be implemented by the adapters that support extensions",
    "label": "",
    "id": "1885"
  },
  {
    "raw_code": "def enable_extension(name, **)\n      end",
    "comment": "This is meant to be implemented by the adapters that support extensions",
    "label": "",
    "id": "1886"
  },
  {
    "raw_code": "def create_enum(...) # :nodoc:\n      end",
    "comment": "This is meant to be implemented by the adapters that support custom enum types",
    "label": "",
    "id": "1887"
  },
  {
    "raw_code": "def drop_enum(...) # :nodoc:\n      end",
    "comment": "This is meant to be implemented by the adapters that support custom enum types",
    "label": "",
    "id": "1888"
  },
  {
    "raw_code": "def rename_enum(...) # :nodoc:\n      end",
    "comment": "This is meant to be implemented by the adapters that support custom enum types",
    "label": "",
    "id": "1889"
  },
  {
    "raw_code": "def add_enum_value(...) # :nodoc:\n      end",
    "comment": "This is meant to be implemented by the adapters that support custom enum types",
    "label": "",
    "id": "1890"
  },
  {
    "raw_code": "def rename_enum_value(...) # :nodoc:\n      end",
    "comment": "This is meant to be implemented by the adapters that support custom enum types",
    "label": "",
    "id": "1891"
  },
  {
    "raw_code": "def create_virtual_table(*) # :nodoc:\n      end",
    "comment": "This is meant to be implemented by the adapters that support virtual tables",
    "label": "",
    "id": "1892"
  },
  {
    "raw_code": "def drop_virtual_table(*) # :nodoc:\n      end",
    "comment": "This is meant to be implemented by the adapters that support virtual tables",
    "label": "",
    "id": "1893"
  },
  {
    "raw_code": "def get_advisory_lock(lock_id) # :nodoc:\n      end",
    "comment": "This is meant to be implemented by the adapters that support advisory locks  Return true if we got the lock, otherwise false",
    "label": "",
    "id": "1894"
  },
  {
    "raw_code": "def release_advisory_lock(lock_id) # :nodoc:\n      end",
    "comment": "This is meant to be implemented by the adapters that support advisory locks.  Return true if we released the lock, otherwise false",
    "label": "",
    "id": "1895"
  },
  {
    "raw_code": "def extensions\n        []\n      end",
    "comment": "A list of extensions, to be filled in by adapters that support them.",
    "label": "",
    "id": "1896"
  },
  {
    "raw_code": "def index_algorithms\n        {}\n      end",
    "comment": "A list of index algorithms, to be filled by adapters that support them.",
    "label": "",
    "id": "1897"
  },
  {
    "raw_code": "def disable_referential_integrity\n        yield\n      end",
    "comment": "REFERENTIAL INTEGRITY ==================================== Override to turn off referential integrity while executing <tt>&block</tt>.",
    "label": "",
    "id": "1898"
  },
  {
    "raw_code": "def check_all_foreign_keys_valid!\n      end",
    "comment": "Override to check all foreign key constraints in a database. The adapter should raise a +ActiveRecord::StatementInvalid+ if foreign key constraints are not met.",
    "label": "",
    "id": "1899"
  },
  {
    "raw_code": "def connected?\n        !@raw_connection.nil?\n      end",
    "comment": "CONNECTION MANAGEMENT ==================================== Checks whether the connection to the database was established. This doesn't include checking whether the database is actually capable of responding, i.e. whether the connection is stale.",
    "label": "",
    "id": "1900"
  },
  {
    "raw_code": "def active?\n      end",
    "comment": "Checks whether the connection to the database is still active. This includes checking whether the database is actually capable of responding, i.e. whether the connection isn't stale.",
    "label": "",
    "id": "1901"
  },
  {
    "raw_code": "def reconnect!(restore_transactions: false)\n        retries_available = connection_retries\n        deadline = retry_deadline && Process.clock_gettime(Process::CLOCK_MONOTONIC) + retry_deadline\n\n        @lock.synchronize do\n          @allow_preconnect = false\n\n          reconnect\n\n          enable_lazy_transactions!\n          @raw_connection_dirty = false\n          @last_activity = @connected_since = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n          @verified = true\n          @allow_preconnect = true\n\n          reset_transaction(restore: restore_transactions) do\n            clear_cache!(new_connection: true)\n            attempt_configure_connection\n          end",
    "comment": "Disconnects from the database if already connected, and establishes a new connection with the database. Implementors should define private #reconnect instead.",
    "label": "",
    "id": "1902"
  },
  {
    "raw_code": "def disconnect!\n        @lock.synchronize do\n          clear_cache!(new_connection: true)\n          reset_transaction\n          @raw_connection_dirty = false\n          @connected_since = nil\n        end",
    "comment": "Disconnects from the database if already connected. Otherwise, this method does nothing.",
    "label": "",
    "id": "1903"
  },
  {
    "raw_code": "def discard!\n        # This should be overridden by concrete adapters.\n      end",
    "comment": "Immediately forget this connection ever existed. Unlike disconnect!, this will not communicate with the server.  After calling this method, the behavior of all other methods becomes undefined. This is called internally just before a forked process gets rid of a connection that belonged to its parent.",
    "label": "",
    "id": "1904"
  },
  {
    "raw_code": "def reset!\n        clear_cache!(new_connection: true)\n        reset_transaction\n        attempt_configure_connection\n      end",
    "comment": "Reset the state of this connection, directing the DBMS to clear transactions and other connection-related server-side state. Usually a database-dependent operation.  If a database driver or protocol does not support such a feature, implementors may alias this to #reconnect!. Otherwise, implementors should call super immediately after resetting the connection (and while still holding @lock).",
    "label": "",
    "id": "1905"
  },
  {
    "raw_code": "def throw_away!\n        pool.remove self\n        disconnect!\n      end",
    "comment": "Removes the connection from the pool and disconnect it.",
    "label": "",
    "id": "1906"
  },
  {
    "raw_code": "def clear_cache!(new_connection: false)\n        if @statements\n          @lock.synchronize do\n            if new_connection\n              @statements.reset\n            else\n              @statements.clear\n            end",
    "comment": "Clear any caching the database adapter may be doing.",
    "label": "",
    "id": "1907"
  },
  {
    "raw_code": "def requires_reloading?\n        false\n      end",
    "comment": "Returns true if its required to reload the connection between requests for development mode.",
    "label": "",
    "id": "1908"
  },
  {
    "raw_code": "def verify!\n        unless active?\n          @lock.synchronize do\n            if @unconfigured_connection\n              @raw_connection = @unconfigured_connection\n              @unconfigured_connection = nil\n              attempt_configure_connection\n              @last_activity = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n              @verified = true\n              @allow_preconnect = true\n              return\n            end",
    "comment": "Checks whether the connection to the database is still active (i.e. not stale). This is done under the hood by calling #active?. If the connection is no longer active, then this method will reconnect to the database.",
    "label": "",
    "id": "1909"
  },
  {
    "raw_code": "def raw_connection\n        with_raw_connection do |conn|\n          disable_lazy_transactions!\n          @raw_connection_dirty = true\n          conn\n        end",
    "comment": "Provides access to the underlying database driver for this adapter. For example, this method returns a Mysql2::Client object in case of Mysql2Adapter, and a PG::Connection object in case of PostgreSQLAdapter.  This is useful for when you need to call a proprietary method such as PostgreSQL's lo_* methods.  Active Record cannot track if the database is getting modified using this client. If that is the case, generally you'll want to invalidate the query cache using +ActiveRecord::Base.clear_query_cache+.",
    "label": "",
    "id": "1910"
  },
  {
    "raw_code": "def close\n        pool.checkin self\n      end",
    "comment": "Check the connection back in to the connection pool",
    "label": "",
    "id": "1911"
  },
  {
    "raw_code": "def build_insert_sql(insert) # :nodoc:\n        if insert.skip_duplicates? || insert.update_duplicates?\n          raise NotImplementedError, \"#{self.class} should define `build_insert_sql` to implement adapter-specific logic for handling duplicates during INSERT\"\n        end",
    "comment": "Called by ActiveRecord::InsertAll, Passed an instance of ActiveRecord::InsertAll::Builder, This method implements standard bulk inserts for all databases, but should be overridden by adapters to implement common features with non-standard syntax like handling duplicates or returning values.",
    "label": "",
    "id": "1912"
  },
  {
    "raw_code": "def schema_version\n        pool.migration_context.current_version\n      end",
    "comment": "Returns the version identifier of the schema currently available in the database. This is generally equal to the number of the highest- numbered migration that has been executed, or 0 if no schema information is present / the database is empty.",
    "label": "",
    "id": "1913"
  },
  {
    "raw_code": "def with_raw_connection(allow_retry: false, materialize_transactions: true)\n          @lock.synchronize do\n            connect! if @raw_connection.nil? && reconnect_can_restore_state?\n\n            self.materialize_transactions if materialize_transactions\n\n            retries_available = allow_retry ? connection_retries : 0\n            deadline = retry_deadline && Process.clock_gettime(Process::CLOCK_MONOTONIC) + retry_deadline\n            reconnectable = reconnect_can_restore_state?\n\n            if @verified\n              # Cool, we're confident the connection's ready to use. (Note this might have\n              # become true during the above #materialize_transactions.)\n            elsif (last_activity = seconds_since_last_activity) && last_activity < verify_timeout\n              # We haven't actually verified the connection since we acquired it, but it\n              # has been used very recently. We're going to assume it's still okay.\n            elsif reconnectable\n              if allow_retry\n                # Not sure about the connection yet, but if anything goes wrong we can\n                # just reconnect and re-run our query\n              else\n                # We can reconnect if needed, but we don't trust the upcoming query to be\n                # safely re-runnable: let's verify the connection to be sure\n                verify!\n              end",
    "comment": "Lock the monitor, ensure we're properly connected and transactions are materialized, and then yield the underlying raw connection object.  If +allow_retry+ is true, a connection-related exception will cause an automatic reconnect and re-run of the block, up to the connection's configured +connection_retries+ setting and the configured +retry_deadline+ limit. (Note that when +allow_retry+ is true, it's possible to return without having marked the connection as verified. If the block is guaranteed to exercise the connection, consider calling `verified!` to avoid needless verification queries in subsequent calls.)  If +materialize_transactions+ is false, the block will be run without ensuring virtual transactions have been materialized in the DB server's state. The active transaction will also remain clean (if it is not already dirty), meaning it's able to be restored by reconnecting and opening an equivalent-depth set of new transactions. This should only be used by transaction control methods, and internal transaction-agnostic queries.    It's not the primary use case, so not something to optimize for, but note that this method does need to be re-entrant: +materialize_transactions+ will re-enter if it has work to do, and the yield block can also do so under some circumstances.  In the latter case, we really ought to guarantee the inner call will not reconnect (which would interfere with the still-yielded connection in the outer block), but we currently provide no special enforcement there. ",
    "label": "",
    "id": "1914"
  },
  {
    "raw_code": "def verified!\n          @last_activity = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n          @verified = true\n        end",
    "comment": "Mark the connection as verified. Call this inside a `with_raw_connection` block only when the block is guaranteed to exercise the raw connection.",
    "label": "",
    "id": "1915"
  },
  {
    "raw_code": "def any_raw_connection\n          @raw_connection || valid_raw_connection\n        end",
    "comment": "Returns a raw connection for internal use with methods that are known to both be thread-safe and not rely upon actual server communication. This is useful for e.g. string escaping methods.",
    "label": "",
    "id": "1916"
  },
  {
    "raw_code": "def valid_raw_connection\n          (@verified && @raw_connection) ||\n            # `allow_retry: false`, to force verification: the block won't\n            # raise, so a retry wouldn't help us get the valid connection we\n            # need.\n            with_raw_connection(allow_retry: false, materialize_transactions: false) { |conn| conn }\n        end",
    "comment": "Similar to any_raw_connection, but ensures it is validated and connected. Any method called on this result still needs to be independently thread-safe, so it probably shouldn't talk to the server... but some drivers fail if they know the connection has gone away.",
    "label": "",
    "id": "1917"
  },
  {
    "raw_code": "def build_result(columns:, rows:, column_types: nil)\n          ActiveRecord::Result.new(columns, rows, column_types)\n        end",
    "comment": "Builds the result object.  This is an internal hook to make possible connection adapters to build custom result objects with connection-specific data.",
    "label": "",
    "id": "1918"
  },
  {
    "raw_code": "def configure_connection\n          check_version\n        end",
    "comment": "Perform any necessary initialization upon the newly-established @raw_connection -- this is the place to modify the adapter's connection settings, run queries to configure any application-global \"session\" variables, etc.  Implementations may assume this method will only be called while holding @lock (or from #initialize).",
    "label": "",
    "id": "1919"
  },
  {
    "raw_code": "def supports_optimizer_hints?\n        !mariadb? && database_version >= \"5.7.7\"\n      end",
    "comment": "See https://dev.mysql.com/doc/refman/en/optimizer-hints.html for more details.",
    "label": "",
    "id": "1920"
  },
  {
    "raw_code": "def supports_disabling_indexes?\n        if mariadb?\n          database_version >= \"10.6.0\"\n        else\n          database_version >= \"8.0.0\"\n        end",
    "comment": "See https://dev.mysql.com/doc/refman/8.0/en/invisible-indexes.html for more details on MySQL feature. See https://mariadb.com/kb/en/ignored-indexes/ for more details on the MariaDB feature.",
    "label": "",
    "id": "1921"
  },
  {
    "raw_code": "def error_number(exception) # :nodoc:\n        raise NotImplementedError\n      end",
    "comment": "Must return the MySQL error number from the exception, if the exception has an error number.",
    "label": "",
    "id": "1922"
  },
  {
    "raw_code": "def disable_referential_integrity # :nodoc:\n        old = query_value(\"SELECT @@FOREIGN_KEY_CHECKS\")\n\n        begin\n          update(\"SET FOREIGN_KEY_CHECKS = 0\")\n          yield\n        ensure\n          update(\"SET FOREIGN_KEY_CHECKS = #{old}\") if active?\n        end",
    "comment": "REFERENTIAL INTEGRITY ====================================",
    "label": "",
    "id": "1923"
  },
  {
    "raw_code": "def begin_db_transaction # :nodoc:\n        internal_execute(\"BEGIN\", \"TRANSACTION\", allow_retry: true, materialize_transactions: false)\n      end",
    "comment": "-- DATABASE STATEMENTS ====================================== ++",
    "label": "",
    "id": "1924"
  },
  {
    "raw_code": "def recreate_database(name, options = {})\n        drop_database(name)\n        sql = create_database(name, options)\n        reconnect!\n        sql\n      end",
    "comment": "SCHEMA STATEMENTS ======================================== Drops the database specified on the +name+ attribute and creates it again using the provided +options+.",
    "label": "",
    "id": "1925"
  },
  {
    "raw_code": "def create_database(name, options = {})\n        if options[:collation]\n          execute \"CREATE DATABASE #{quote_table_name(name)} DEFAULT COLLATE #{quote_table_name(options[:collation])}\"\n        elsif options[:charset]\n          execute \"CREATE DATABASE #{quote_table_name(name)} DEFAULT CHARACTER SET #{quote_table_name(options[:charset])}\"\n        elsif row_format_dynamic_by_default?\n          execute \"CREATE DATABASE #{quote_table_name(name)} DEFAULT CHARACTER SET `utf8mb4`\"\n        else\n          raise \"Configure a supported :charset and ensure innodb_large_prefix is enabled to support indexes on varchar(255) string columns.\"\n        end",
    "comment": "Create a new MySQL database with optional <tt>:charset</tt> and <tt>:collation</tt>. Charset defaults to utf8mb4.  Example: create_database 'charset_test', charset: 'latin1', collation: 'latin1_bin' create_database 'matt_development' create_database 'matt_development', charset: :big5",
    "label": "",
    "id": "1926"
  },
  {
    "raw_code": "def drop_database(name) # :nodoc:\n        execute \"DROP DATABASE IF EXISTS #{quote_table_name(name)}\"\n      end",
    "comment": "Drops a MySQL database.  Example: drop_database('sebastian_development')",
    "label": "",
    "id": "1927"
  },
  {
    "raw_code": "def charset\n        show_variable \"character_set_database\"\n      end",
    "comment": "Returns the database character set.",
    "label": "",
    "id": "1928"
  },
  {
    "raw_code": "def collation\n        show_variable \"collation_database\"\n      end",
    "comment": "Returns the database collation strategy.",
    "label": "",
    "id": "1929"
  },
  {
    "raw_code": "def rename_table(table_name, new_name, **options)\n        validate_table_length!(new_name) unless options[:_uses_legacy_table_name]\n        schema_cache.clear_data_source_cache!(table_name.to_s)\n        schema_cache.clear_data_source_cache!(new_name.to_s)\n        execute \"RENAME TABLE #{quote_table_name(table_name)} TO #{quote_table_name(new_name)}\"\n        rename_table_indexes(table_name, new_name, **options)\n      end",
    "comment": "Renames a table.  Example: rename_table('octopuses', 'octopi')",
    "label": "",
    "id": "1930"
  },
  {
    "raw_code": "def drop_table(*table_names, **options)\n        table_names.each { |table_name| schema_cache.clear_data_source_cache!(table_name.to_s) }\n        execute \"DROP#{' TEMPORARY' if options[:temporary]} TABLE#{' IF EXISTS' if options[:if_exists]} #{table_names.map { |table_name| quote_table_name(table_name) }.join(', ')}#{' CASCADE' if options[:force] == :cascade}\"\n      end",
    "comment": "Drops a table or tables from the database.  [<tt>:force</tt>] Set to +:cascade+ to drop dependent objects as well. Defaults to false. [<tt>:if_exists</tt>] Set to +true+ to only drop the table if it exists. Defaults to false. [<tt>:temporary</tt>] Set to +true+ to drop temporary table. Defaults to false.  Although this command ignores most +options+ and the block if one is given, it can be helpful to provide these in a migration's +change+ method so it can be reverted. In that case, +options+ and the block will be used by #create_table except if you provide more than one table which is not supported.",
    "label": "",
    "id": "1931"
  },
  {
    "raw_code": "def build_change_column_definition(table_name, column_name, type, **options) # :nodoc:\n        column = column_for(table_name, column_name)\n        type ||= column.sql_type\n\n        unless options.key?(:default)\n          options[:default] = if column.default_function\n            -> { column.default_function }\n          else\n            column.default\n          end",
    "comment": "Builds a ChangeColumnDefinition object.  This definition object contains information about the column change that would occur if the same arguments were passed to #change_column. See #change_column for information about passing a +table_name+, +column_name+, +type+ and other options that can be passed.",
    "label": "",
    "id": "1932"
  },
  {
    "raw_code": "def show_variable(name)\n        query_value(\"SELECT @@#{name}\", \"SCHEMA\", materialize_transactions: false, allow_retry: true)\n      rescue ActiveRecord::StatementInvalid\n        nil\n      end",
    "comment": "SHOW VARIABLES LIKE 'name'",
    "label": "",
    "id": "1933"
  },
  {
    "raw_code": "def columns_for_distinct(columns, orders) # :nodoc:\n        order_columns = orders.compact_blank.map { |s|\n          # Convert Arel node to string\n          s = visitor.compile(s) unless s.is_a?(String)\n          # Remove any ASC/DESC modifiers\n          s.gsub(/\\s+(?:ASC|DESC)\\b/i, \"\")\n        }.compact_blank.map.with_index { |column, i| \"#{column} AS alias_#{i}\" }\n\n        (order_columns << super).join(\", \")\n      end",
    "comment": "In MySQL 5.7.5 and up, ONLY_FULL_GROUP_BY affects handling of queries that use DISTINCT and ORDER BY. It requires the ORDER BY columns in the select list for distinct queries, and requires that the ORDER BY include the distinct column. See https://dev.mysql.com/doc/refman/en/group-by-handling.html",
    "label": "",
    "id": "1934"
  },
  {
    "raw_code": "def quote_string(string)\n        with_raw_connection(allow_retry: true, materialize_transactions: false) do |connection|\n          connection.escape(string)\n        end",
    "comment": "-- QUOTING ================================================== ++ Quotes strings for use in SQL input.",
    "label": "",
    "id": "1935"
  },
  {
    "raw_code": "def initialize(name, cast_type, default, sql_type_metadata = nil, null = true, default_function = nil, collation: nil, comment: nil, **)\n        @name = name.freeze\n        @cast_type = cast_type\n        @sql_type_metadata = sql_type_metadata\n        @null = null\n        @default = default.nil? || cast_type.mutable? ? default : cast_type.deserialize(default)\n        @default_function = default_function\n        @collation = collation\n        @comment = comment\n      end",
    "comment": "Instantiates a new column in the table.  +name+ is the column's name, such as <tt>supplier_id</tt> in <tt>supplier_id bigint</tt>. +default+ is the type-casted default value, such as +new+ in <tt>sales_stage varchar(20) default 'new'</tt>. +sql_type_metadata+ is various information about the type of the column +null+ determines if this column allows +NULL+ values.",
    "label": "",
    "id": "1936"
  },
  {
    "raw_code": "def human_name\n        Base.human_attribute_name(@name)\n      end",
    "comment": "Returns the human name of the column name.  ===== Examples Column.new('sales_stage', ...).human_name # => 'Sales stage'",
    "label": "",
    "id": "1937"
  },
  {
    "raw_code": "def auto_incremented_by_db?\n        false\n      end",
    "comment": "whether the column is auto-populated by the database using a sequence",
    "label": "",
    "id": "1938"
  },
  {
    "raw_code": "def connected?\n        !(@raw_connection.nil? || @raw_connection.closed?)\n      end",
    "comment": "-- CONNECTION MANAGEMENT ==================================== ++",
    "label": "",
    "id": "1939"
  },
  {
    "raw_code": "def disconnect!\n        @lock.synchronize do\n          super\n          @raw_connection&.close\n          @raw_connection = nil\n        end",
    "comment": "Disconnects from the database if already connected. Otherwise, this method does nothing.",
    "label": "",
    "id": "1940"
  },
  {
    "raw_code": "def initialize(...)\n        super\n\n        conn_params = @config.compact\n\n        # Map ActiveRecords param names to PGs.\n        conn_params[:user] = conn_params.delete(:username) if conn_params[:username]\n        conn_params[:dbname] = conn_params.delete(:database) if conn_params[:database]\n\n        # Forward only valid config params to PG::Connection.connect.\n        valid_conn_param_keys = PG::Connection.conndefaults_hash.keys + [:requiressl]\n        conn_params.slice!(*valid_conn_param_keys)\n\n        @connection_parameters = conn_params\n\n        @max_identifier_length = nil\n        @type_map = nil\n        @raw_connection = nil\n        @notice_receiver_sql_warnings = []\n\n        @use_insert_returning = @config.key?(:insert_returning) ? self.class.type_cast_config_to_boolean(@config[:insert_returning]) : true\n      end",
    "comment": "Initializes and connects a PostgreSQL adapter.",
    "label": "",
    "id": "1941"
  },
  {
    "raw_code": "def active?\n        @lock.synchronize do\n          return false unless @raw_connection\n          @raw_connection.query \";\"\n          verified!\n        end",
    "comment": "Is this connection alive and ready for queries?",
    "label": "",
    "id": "1942"
  },
  {
    "raw_code": "def disconnect!\n        @lock.synchronize do\n          super\n          @raw_connection&.close rescue nil\n          @raw_connection = nil\n        end",
    "comment": "Disconnects from the database if already connected. Otherwise, this method does nothing.",
    "label": "",
    "id": "1943"
  },
  {
    "raw_code": "def disable_extension(name, force: false)\n        _schema, name = name.to_s.split(\".\").values_at(-2, -1)\n        internal_exec_query(\"DROP EXTENSION IF EXISTS \\\"#{name}\\\"#{' CASCADE' if force == :cascade}\").tap {\n          reload_type_map\n        }\n      end",
    "comment": "Removes an extension from the database.  [<tt>:force</tt>] Set to +:cascade+ to drop dependent objects as well. Defaults to false.",
    "label": "",
    "id": "1944"
  },
  {
    "raw_code": "def enum_types\n        query = <<~SQL\n          SELECT\n            type.typname AS name,\n            type.OID AS oid,\n            n.nspname AS schema,\n            array_agg(enum.enumlabel ORDER BY enum.enumsortorder) AS value\n          FROM pg_enum AS enum\n          JOIN pg_type AS type ON (type.oid = enum.enumtypid)\n          JOIN pg_namespace n ON type.typnamespace = n.oid\n          WHERE n.nspname = ANY (current_schemas(false))\n          GROUP BY type.OID, n.nspname, type.typname;\n        SQL\n\n        internal_exec_query(query, \"SCHEMA\", allow_retry: true, materialize_transactions: false).cast_values.each_with_object({}) do |row, memo|\n          name, schema = row[0], row[2]\n          schema = nil if schema == current_schema\n          full_name = [schema, name].compact.join(\".\")\n          memo[full_name] = row.last\n        end.to_a\n      end",
    "comment": "Returns a list of defined enum types, and their values.",
    "label": "",
    "id": "1945"
  },
  {
    "raw_code": "def create_enum(name, values, **options)\n        sql_values = values.map { |s| quote(s) }.join(\", \")\n        scope = quoted_scope(name)\n        query = <<~SQL\n          DO $$\n          BEGIN\n              IF NOT EXISTS (\n                SELECT 1\n                FROM pg_type t\n                JOIN pg_namespace n ON t.typnamespace = n.oid\n                WHERE t.typname = #{scope[:name]}\n                  AND n.nspname = #{scope[:schema]}\n              ) THEN\n                  CREATE TYPE #{quote_table_name(name)} AS ENUM (#{sql_values});\n              END IF;\n          END\n          $$;\n        SQL\n        internal_exec_query(query).tap { reload_type_map }\n      end",
    "comment": "Given a name and an array of values, creates an enum type.",
    "label": "",
    "id": "1946"
  },
  {
    "raw_code": "def drop_enum(name, values = nil, **options)\n        query = <<~SQL\n          DROP TYPE#{' IF EXISTS' if options[:if_exists]} #{quote_table_name(name)};\n        SQL\n        internal_exec_query(query).tap { reload_type_map }\n      end",
    "comment": "Drops an enum type.  If the <tt>if_exists: true</tt> option is provided, the enum is dropped only if it exists. Otherwise, if the enum doesn't exist, an error is raised.  The +values+ parameter will be ignored if present. It can be helpful to provide this in a migration's +change+ method so it can be reverted. In that case, +values+ will be used by #create_enum.",
    "label": "",
    "id": "1947"
  },
  {
    "raw_code": "def rename_enum(name, new_name = nil, **options)\n        new_name ||= options.fetch(:to) do\n          raise ArgumentError, \"rename_enum requires two from/to name positional arguments.\"\n        end",
    "comment": "Rename an existing enum type to something else.",
    "label": "",
    "id": "1948"
  },
  {
    "raw_code": "def add_enum_value(type_name, value, **options)\n        before, after = options.values_at(:before, :after)\n        sql = +\"ALTER TYPE #{quote_table_name(type_name)} ADD VALUE\"\n        sql << \" IF NOT EXISTS\" if options[:if_not_exists]\n        sql << \" #{quote(value)}\"\n\n        if before && after\n          raise ArgumentError, \"Cannot have both :before and :after at the same time\"\n        elsif before\n          sql << \" BEFORE #{quote(before)}\"\n        elsif after\n          sql << \" AFTER #{quote(after)}\"\n        end",
    "comment": "Add enum value to an existing enum type.",
    "label": "",
    "id": "1949"
  },
  {
    "raw_code": "def rename_enum_value(type_name, **options)\n        unless database_version >= 10_00_00 # >= 10.0\n          raise ArgumentError, \"Renaming enum values is only supported in PostgreSQL 10 or later\"\n        end",
    "comment": "Rename enum value on an existing enum type.",
    "label": "",
    "id": "1950"
  },
  {
    "raw_code": "def max_identifier_length\n        @max_identifier_length ||= query_value(\"SHOW max_identifier_length\", \"SCHEMA\").to_i\n      end",
    "comment": "Returns the configured maximum supported identifier length supported by PostgreSQL",
    "label": "",
    "id": "1951"
  },
  {
    "raw_code": "def session_auth=(user)\n        clear_cache!\n        internal_execute(\"SET SESSION AUTHORIZATION #{user}\", nil, materialize_transactions: true)\n      end",
    "comment": "Set the authorized user for this session",
    "label": "",
    "id": "1952"
  },
  {
    "raw_code": "def get_database_version # :nodoc:\n        with_raw_connection do |conn|\n          version = conn.server_version\n          if version == 0\n            raise ActiveRecord::ConnectionNotEstablished, \"Could not determine PostgreSQL version\"\n          end",
    "comment": "Returns the version of the connected PostgreSQL server.",
    "label": "",
    "id": "1953"
  },
  {
    "raw_code": "def extract_value_from_default(default)\n          case default\n            # Quoted types\n          when /\\A[(B]?'(.*)'.*::\"?([\\w. ]+)\"?(?:\\[\\])?\\z/m\n            # The default 'now'::date is CURRENT_DATE\n            if $1 == \"now\" && $2 == \"date\"\n              nil\n            else\n              $1.gsub(\"''\", \"'\")\n            end",
    "comment": "Extracts the value from a PostgreSQL column default definition.",
    "label": "",
    "id": "1954"
  },
  {
    "raw_code": "def is_cached_plan_failure?(pgerror)\n          pgerror.result.result_error_field(PG::PG_DIAG_SQLSTATE) == FEATURE_NOT_SUPPORTED &&\n            pgerror.result.result_error_field(PG::PG_DIAG_SOURCE_FUNCTION) == \"RevalidateCachedQuery\"\n        rescue\n          false\n        end",
    "comment": "Annoyingly, the code for prepared statements whose return value may have changed is FEATURE_NOT_SUPPORTED.  This covers various different error types so we need to do additional work to classify the exception definitively as a ActiveRecord::PreparedStatementCacheExpired  Check here for more details: https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/backend/utils/cache/plancache.c#l573",
    "label": "",
    "id": "1955"
  },
  {
    "raw_code": "def sql_key(sql)\n          \"#{schema_search_path}-#{sql}\"\n        end",
    "comment": "Returns the statement identifier for the client side cache of statements",
    "label": "",
    "id": "1956"
  },
  {
    "raw_code": "def prepare_statement(sql, binds, conn)\n          sql_key = sql_key(sql)\n          unless @statements.key? sql_key\n            nextkey = @statements.next_key\n            begin\n              conn.prepare nextkey, sql\n            rescue => e\n              raise translate_exception_class(e, sql, binds)\n            end",
    "comment": "Prepare the statement if it hasn't been prepared, return the statement key.",
    "label": "",
    "id": "1957"
  },
  {
    "raw_code": "def connect\n          @raw_connection = self.class.new_client(@connection_parameters)\n        rescue ConnectionNotEstablished => ex\n          raise ex.set_pool(@pool)\n        end",
    "comment": "Connects to a PostgreSQL server and sets up the adapter depending on the connected server's characteristics.",
    "label": "",
    "id": "1958"
  },
  {
    "raw_code": "def configure_connection\n          super\n\n          if @config[:encoding]\n            @raw_connection.set_client_encoding(@config[:encoding])\n          end",
    "comment": "Configures the encoding, verbosity, schema search path, and time zone of the connection. This is called by #connect and should not be called manually.",
    "label": "",
    "id": "1959"
  },
  {
    "raw_code": "def column_definitions(table_name)\n          query(<<~SQL, \"SCHEMA\")\n              SELECT a.attname, format_type(a.atttypid, a.atttypmod),\n                     pg_get_expr(d.adbin, d.adrelid), a.attnotnull, a.atttypid, a.atttypmod,\n                     c.collname, col_description(a.attrelid, a.attnum) AS comment,\n                     #{supports_identity_columns? ? 'attidentity' : quote('')} AS identity,\n                     #{supports_virtual_columns? ? 'attgenerated' : quote('')} as attgenerated\n                FROM pg_attribute a\n                LEFT JOIN pg_attrdef d ON a.attrelid = d.adrelid AND a.attnum = d.adnum\n                LEFT JOIN pg_type t ON a.atttypid = t.oid\n                LEFT JOIN pg_collation c ON a.attcollation = c.oid AND a.attcollation <> t.typcollation\n               WHERE a.attrelid = #{quote(quote_table_name(table_name))}::regclass\n                 AND a.attnum > 0 AND NOT a.attisdropped\n               ORDER BY a.attnum\n          SQL\n        end",
    "comment": "Returns the list of a table's column names, data types, and default values.  The underlying query is roughly: SELECT column.name, column.type, default.value, column.comment FROM column LEFT JOIN default ON column.table_id = default.table_id AND column.num = default.column_num WHERE column.table_id = get_table_id('table_name') AND column.num > 0 AND NOT column.is_dropped ORDER BY column.num  If the table name is not prefixed with a schema, the database will take the first match from the schema search path.  Query implementation notes: - format_type includes the column size constraint, e.g. varchar(50) - ::regclass is a function that gives the id for a table name",
    "label": "",
    "id": "1960"
  },
  {
    "raw_code": "def data_source_exists?(pool, name)\n        return if ignored_table?(name)\n\n        if @data_sources.empty?\n          tables_to_cache(pool).each do |source|\n            @data_sources[source] = true\n          end",
    "comment": "A cached lookup for table existence.",
    "label": "",
    "id": "1961"
  },
  {
    "raw_code": "def add(pool, table_name)\n        pool.with_connection do\n          if data_source_exists?(pool, table_name)\n            primary_keys(pool, table_name)\n            columns(pool, table_name)\n            columns_hash(pool, table_name)\n            indexes(pool, table_name)\n          end",
    "comment": "Add internal cache for table with +table_name+.",
    "label": "",
    "id": "1962"
  },
  {
    "raw_code": "def columns(pool, table_name)\n        if ignored_table?(table_name)\n          raise ActiveRecord::StatementInvalid.new(\"Table '#{table_name}' doesn't exist\", connection_pool: pool)\n        end",
    "comment": "Get the columns for a table",
    "label": "",
    "id": "1963"
  },
  {
    "raw_code": "def columns_hash(pool, table_name)\n        @columns_hash.fetch(table_name) do\n          @columns_hash[deep_deduplicate(table_name)] = columns(pool, table_name).index_by(&:name).freeze\n        end",
    "comment": "Get the columns for a table as a hash, key is the column name value is the column object.",
    "label": "",
    "id": "1964"
  },
  {
    "raw_code": "def columns_hash?(_pool, table_name)\n        @columns_hash.key?(table_name)\n      end",
    "comment": "Checks whether the columns hash is already cached for a table.",
    "label": "",
    "id": "1965"
  },
  {
    "raw_code": "def clear_data_source_cache!(_connection, name)\n        @columns.delete name\n        @columns_hash.delete name\n        @primary_keys.delete name\n        @data_sources.delete name\n        @indexes.delete name\n      end",
    "comment": "Clear out internal caches for the data source +name+.",
    "label": "",
    "id": "1966"
  },
  {
    "raw_code": "def disconnect!\n        super\n\n        @raw_connection&.close rescue nil\n        @raw_connection = nil\n      end",
    "comment": "Disconnects from the database if already connected. Otherwise, this method does nothing.",
    "label": "",
    "id": "1967"
  },
  {
    "raw_code": "def encoding\n        any_raw_connection.encoding.to_s\n      end",
    "comment": "Returns the current database encoding format as a string, e.g. 'UTF-8'",
    "label": "",
    "id": "1968"
  },
  {
    "raw_code": "def disable_referential_integrity # :nodoc:\n        old_foreign_keys = query_value(\"PRAGMA foreign_keys\")\n        old_defer_foreign_keys = query_value(\"PRAGMA defer_foreign_keys\")\n\n        begin\n          execute(\"PRAGMA defer_foreign_keys = ON\")\n          execute(\"PRAGMA foreign_keys = OFF\")\n          yield\n        ensure\n          execute(\"PRAGMA defer_foreign_keys = #{old_defer_foreign_keys}\")\n          execute(\"PRAGMA foreign_keys = #{old_foreign_keys}\")\n        end",
    "comment": "REFERENTIAL INTEGRITY ====================================",
    "label": "",
    "id": "1969"
  },
  {
    "raw_code": "def primary_keys(table_name) # :nodoc:\n        pks = table_structure(table_name).select { |f| f[\"pk\"] > 0 }\n        pks.sort_by { |f| f[\"pk\"] }.map { |f| f[\"name\"] }\n      end",
    "comment": "SCHEMA STATEMENTS ========================================",
    "label": "",
    "id": "1970"
  },
  {
    "raw_code": "def virtual_tables\n        query = <<~SQL\n          SELECT name, sql FROM sqlite_master WHERE sql LIKE 'CREATE VIRTUAL %';\n        SQL\n\n        exec_query(query, \"SCHEMA\").cast_values.each_with_object({}) do |row, memo|\n          table_name, sql = row[0], row[1]\n          _, module_name, arguments = sql.match(VIRTUAL_TABLE_REGEX).to_a\n          memo[table_name] = [module_name, arguments]\n        end.to_a\n      end",
    "comment": "Returns a list of defined virtual tables",
    "label": "",
    "id": "1971"
  },
  {
    "raw_code": "def create_virtual_table(table_name, module_name, values)\n        exec_query \"CREATE VIRTUAL TABLE IF NOT EXISTS #{table_name} USING #{module_name} (#{values.join(\", \")})\"\n      end",
    "comment": "Creates a virtual table  Example: create_virtual_table :emails, :fts5, ['sender', 'title', 'body']",
    "label": "",
    "id": "1972"
  },
  {
    "raw_code": "def drop_virtual_table(table_name, module_name, values, **options)\n        drop_table(table_name)\n      end",
    "comment": "Drops a virtual table  Although this command ignores +module_name+ and +values+, it can be helpful to provide these in a migration's +change+ method so it can be reverted. In that case, +module_name+, +values+ and +options+ will be used by #create_virtual_table.",
    "label": "",
    "id": "1973"
  },
  {
    "raw_code": "def rename_table(table_name, new_name, **options)\n        validate_table_length!(new_name) unless options[:_uses_legacy_table_name]\n        schema_cache.clear_data_source_cache!(table_name.to_s)\n        schema_cache.clear_data_source_cache!(new_name.to_s)\n        exec_query \"ALTER TABLE #{quote_table_name(table_name)} RENAME TO #{quote_table_name(new_name)}\"\n        rename_table_indexes(table_name, new_name, **options)\n      end",
    "comment": "Renames a table.  Example: rename_table('octopuses', 'octopi')",
    "label": "",
    "id": "1974"
  },
  {
    "raw_code": "def bind_params_length\n          999\n        end",
    "comment": "See https://www.sqlite.org/limits.html, the default value is 999 when not configured.",
    "label": "",
    "id": "1975"
  },
  {
    "raw_code": "def invalid_alter_table_type?(type, options)\n          type == :primary_key || options[:primary_key] ||\n            options[:null] == false && options[:default].nil? ||\n            (type == :virtual && options[:stored])\n        end",
    "comment": "See: https://www.sqlite.org/lang_altertable.html SQLite has an additional restriction on the ALTER TABLE statement",
    "label": "",
    "id": "1976"
  },
  {
    "raw_code": "def reset\n        cache.clear\n      end",
    "comment": "Clear the pool without deallocating; this is only safe when we know the server has independently deallocated all statements (e.g. due to a reconnect, or a DISCARD ALL)",
    "label": "",
    "id": "1977"
  },
  {
    "raw_code": "def connection_pool_list(role = nil)\n        if role.nil? || role == :all\n          connection_name_to_pool_manager.values.flat_map { |m| m.pool_configs.map(&:pool) }\n        else\n          connection_name_to_pool_manager.values.flat_map { |m| m.pool_configs(role).map(&:pool) }\n        end",
    "comment": "Returns the pools for a connection handler and given role. If +:all+ is passed, all pools belonging to the connection handler will be returned.",
    "label": "",
    "id": "1978"
  },
  {
    "raw_code": "def active_connections?(role = nil)\n        each_connection_pool(role).any?(&:active_connection?)\n      end",
    "comment": "Returns true if there are any active connections among the connection pools that the ConnectionHandler is managing.",
    "label": "",
    "id": "1979"
  },
  {
    "raw_code": "def clear_active_connections!(role = nil)\n        each_connection_pool(role).each do |pool|\n          pool.release_connection\n          pool.disable_query_cache!\n        end",
    "comment": "Returns any connections in use by the current thread back to the pool.",
    "label": "",
    "id": "1980"
  },
  {
    "raw_code": "def clear_reloadable_connections!(role = nil)\n        each_connection_pool(role).each(&:clear_reloadable_connections!)\n      end",
    "comment": "Clears reloadable connection caches in all connection pools.  See ConnectionPool#clear_reloadable_connections! for details.",
    "label": "",
    "id": "1981"
  },
  {
    "raw_code": "def flush_idle_connections!(role = nil)\n        each_connection_pool(role).each(&:flush!)\n      end",
    "comment": "Disconnects all currently idle connections.  See ConnectionPool#flush! for details.",
    "label": "",
    "id": "1982"
  },
  {
    "raw_code": "def retrieve_connection(connection_name, role: ActiveRecord::Base.current_role, shard: ActiveRecord::Base.current_shard) # :nodoc:\n        pool = retrieve_connection_pool(connection_name, role: role, shard: shard, strict: true)\n        pool.lease_connection\n      end",
    "comment": "Locate the connection of the nearest super class. This can be an active or defined connection: if it is the latter, it will be opened and set as the active connection for the class it was defined for (not necessarily the current class).",
    "label": "",
    "id": "1983"
  },
  {
    "raw_code": "def connected?(connection_name, role: ActiveRecord::Base.current_role, shard: ActiveRecord::Base.current_shard)\n        pool = retrieve_connection_pool(connection_name, role: role, shard: shard)\n        pool && pool.connected?\n      end",
    "comment": "Returns true if a connection that's accessible to this class has already been opened.",
    "label": "",
    "id": "1984"
  },
  {
    "raw_code": "def retrieve_connection_pool(connection_name, role: ActiveRecord::Base.current_role, shard: ActiveRecord::Base.current_shard, strict: false)\n        pool_manager = get_pool_manager(connection_name)\n        pool = pool_manager&.get_pool_config(role, shard)&.pool\n\n        if strict && !pool\n          selector = [\n            (\"'#{shard}' shard\" unless shard == ActiveRecord::Base.default_shard),\n            (\"'#{role}' role\" unless role == ActiveRecord::Base.default_role),\n          ].compact.join(\" and \")\n\n          selector = [\n            (connection_name unless connection_name == \"ActiveRecord::Base\"),\n            selector.presence,\n          ].compact.join(\" with \")\n\n          selector = \" for #{selector}\" if selector.present?\n\n          message = \"No database connection defined#{selector}.\"\n\n          raise ConnectionNotDefined.new(message, connection_name: connection_name, shard: shard, role: role)\n        end",
    "comment": "Retrieving the connection pool happens a lot, so we cache it in @connection_name_to_pool_manager. This makes retrieving the connection pool O(1) once the process is warm. When a connection is established or removed, we invalidate the cache.",
    "label": "",
    "id": "1985"
  },
  {
    "raw_code": "def get_pool_manager(connection_name)\n          connection_name_to_pool_manager[connection_name]\n        end",
    "comment": "Returns the pool manager for a connection name / identifier.",
    "label": "",
    "id": "1986"
  },
  {
    "raw_code": "def set_pool_manager(connection_descriptor)\n          connection_name_to_pool_manager[connection_descriptor.name] ||= PoolManager.new\n        end",
    "comment": "Get the existing pool manager or initialize and assign a new one.",
    "label": "",
    "id": "1987"
  },
  {
    "raw_code": "def resolve_pool_config(config, connection_name, role, shard)\n          db_config = Base.configurations.resolve(config)\n          db_config.validate!\n          raise(AdapterNotSpecified, \"database configuration does not specify adapter\") unless db_config.adapter\n          ConnectionAdapters::PoolConfig.new(connection_name, db_config, role, shard)\n        end",
    "comment": "Returns an instance of PoolConfig for a given adapter. Accepts a hash one layer deep that contains all connection information.  == Example  config = { \"production\" => { \"host\" => \"localhost\", \"database\" => \"foo\", \"adapter\" => \"sqlite3\" } } pool_config = Base.configurations.resolve_pool_config(:production) pool_config.db_config.configuration_hash # => { host: \"localhost\", database: \"foo\", adapter: \"sqlite3\" } ",
    "label": "",
    "id": "1988"
  },
  {
    "raw_code": "def initialize(pool_config)\n        super()\n\n        @pool_config = pool_config\n        @db_config = pool_config.db_config\n        @role = pool_config.role\n        @shard = pool_config.shard\n\n        @checkout_timeout = db_config.checkout_timeout\n        @idle_timeout = db_config.idle_timeout\n        @max_connections = db_config.max_connections\n        @min_connections = db_config.min_connections\n        @max_age = db_config.max_age\n        @keepalive = db_config.keepalive\n\n        # This variable tracks the cache of threads mapped to reserved connections, with the\n        # sole purpose of speeding up the +connection+ method. It is not the authoritative\n        # registry of which thread owns which connection. Connection ownership is tracked by\n        # the +connection.owner+ attr on each +connection+ instance.\n        # The invariant works like this: if there is mapping of <tt>thread => conn</tt>,\n        # then that +thread+ does indeed own that +conn+. However, an absence of such\n        # mapping does not mean that the +thread+ doesn't own the said connection. In\n        # that case +conn.owner+ attr should be consulted.\n        # Access and modification of <tt>@leases</tt> does not require\n        # synchronization.\n        @leases = LeaseRegistry.new\n\n        @connections         = []\n        @automatic_reconnect = true\n\n        # Connection pool allows for concurrent (outside the main +synchronize+ section)\n        # establishment of new connections. This variable tracks the number of threads\n        # currently in the process of independently establishing connections to the DB.\n        @now_connecting = 0\n\n        # Sometimes otherwise-idle connections are temporarily held by the Reaper for\n        # maintenance. This variable tracks the number of connections currently in that\n        # state -- if a thread requests a connection and there are none available, it\n        # will await any in-maintenance connections in preference to creating a new one.\n        @maintaining = 0\n\n        @threads_blocking_new_connections = 0\n\n        @available = ConnectionLeasingQueue.new self\n        @pinned_connection = nil\n        @pinned_connections_depth = 0\n\n        @async_executor = build_async_executor\n\n        @schema_cache = nil\n\n        @activated = false\n        @original_context = ActiveSupport::IsolatedExecutionState.context\n\n        @reaper_lock = Monitor.new\n        @reaper = Reaper.new(self, db_config.reaping_frequency)\n        @reaper.run\n      end",
    "comment": "Creates a new ConnectionPool object. +pool_config+ is a PoolConfig object which describes database connection information (e.g. adapter, host name, username, password, etc), as well as the maximum size for this ConnectionPool.  The default ConnectionPool maximum size is 5.",
    "label": "",
    "id": "1989"
  },
  {
    "raw_code": "def lease_connection\n        lease = connection_lease\n        lease.connection ||= checkout\n        lease.sticky = true\n        lease.connection\n      end",
    "comment": "Retrieve the connection associated with the current thread, or call #checkout to obtain one if necessary.  #lease_connection can be called any number of times; the connection is held in a cache keyed by a thread.",
    "label": "",
    "id": "1990"
  },
  {
    "raw_code": "def active_connection?\n        connection_lease.connection\n      end",
    "comment": "Returns true if there is an open connection being used for the current thread.  This method only works for connections that have been obtained through #lease_connection or #with_connection methods. Connections obtained through #checkout will not be detected by #active_connection?",
    "label": "",
    "id": "1991"
  },
  {
    "raw_code": "def release_connection(existing_lease = nil)\n        return if self.discarded?\n\n        if conn = connection_lease.release\n          checkin conn\n          return true\n        end",
    "comment": "Signal that the thread is finished with the current connection. #release_connection releases the connection-thread association and returns the connection to the pool.  This method only works for connections that have been obtained through #lease_connection or #with_connection methods, connections obtained through #checkout will not be automatically released.",
    "label": "",
    "id": "1992"
  },
  {
    "raw_code": "def with_connection(prevent_permanent_checkout: false)\n        lease = connection_lease\n        sticky_was = lease.sticky\n        lease.sticky = false if prevent_permanent_checkout\n\n        if lease.connection\n          begin\n            yield lease.connection\n          ensure\n            lease.sticky = sticky_was if prevent_permanent_checkout && !sticky_was\n          end",
    "comment": "Yields a connection from the connection pool to the block. If no connection is already checked out by the current thread, a connection will be checked out from the pool, yielded to the block, and then returned to the pool when the block is finished. If a connection has already been checked out on the current thread, such as via #lease_connection or #with_connection, that existing connection will be the one yielded and it will not be returned to the pool automatically at the end of the block; it is expected that such an existing connection will be properly returned to the pool by the code that checked it out.",
    "label": "",
    "id": "1993"
  },
  {
    "raw_code": "def connected?\n        synchronize { @connections.any?(&:connected?) }\n      end",
    "comment": "Returns true if a connection has already been opened.",
    "label": "",
    "id": "1994"
  },
  {
    "raw_code": "def connections\n        synchronize { @connections.dup }\n      end",
    "comment": "Returns an array containing the connections currently in the pool. Access to the array does not require synchronization on the pool because the array is newly created and not retained by the pool.  However; this method bypasses the ConnectionPool's thread-safe connection access pattern. A returned connection may be owned by another thread, unowned, or by happen-stance owned by the calling thread.  Calling methods on a connection without ownership is subject to the thread-safety guarantees of the underlying method. Many of the methods on connection adapter classes are inherently multi-thread unsafe.",
    "label": "",
    "id": "1995"
  },
  {
    "raw_code": "def disconnect(raise_on_acquisition_timeout = true)\n        @reaper_lock.synchronize do\n          return if self.discarded?\n\n          with_exclusively_acquired_all_connections(raise_on_acquisition_timeout) do\n            synchronize do\n              return if self.discarded?\n              @connections.each do |conn|\n                if conn.in_use?\n                  conn.steal!\n                  checkin conn\n                end",
    "comment": "Disconnects all connections in the pool, and clears the pool.  Raises: - ActiveRecord::ExclusiveConnectionTimeoutError if unable to gain ownership of all connections in the pool within a timeout interval (default duration is <tt>spec.db_config.checkout_timeout * 2</tt> seconds).",
    "label": "",
    "id": "1996"
  },
  {
    "raw_code": "def disconnect!\n        disconnect(false)\n      end",
    "comment": "Disconnects all connections in the pool, and clears the pool.  The pool first tries to gain ownership of all connections. If unable to do so within a timeout interval (default duration is <tt>spec.db_config.checkout_timeout * 2</tt> seconds), then the pool is forcefully disconnected without any regard for other connection owning threads.",
    "label": "",
    "id": "1997"
  },
  {
    "raw_code": "def discard! # :nodoc:\n        @reaper_lock.synchronize do\n          synchronize do\n            return if self.discarded?\n            @connections.each do |conn|\n              conn.discard!\n            end",
    "comment": "Discards all connections in the pool (even if they're currently leased!), along with the pool itself. Any further interaction with the pool (except #spec and #schema_cache) is undefined.  See AbstractAdapter#discard!",
    "label": "",
    "id": "1998"
  },
  {
    "raw_code": "def clear_reloadable_connections(raise_on_acquisition_timeout = true)\n        with_exclusively_acquired_all_connections(raise_on_acquisition_timeout) do\n          synchronize do\n            @connections.each do |conn|\n              if conn.in_use?\n                conn.steal!\n                checkin conn\n              end",
    "comment": "Clears reloadable connections from the pool and re-connects connections that require reloading.  Raises: - ActiveRecord::ExclusiveConnectionTimeoutError if unable to gain ownership of all connections in the pool within a timeout interval (default duration is <tt>spec.db_config.checkout_timeout * 2</tt> seconds).",
    "label": "",
    "id": "1999"
  },
  {
    "raw_code": "def clear_reloadable_connections!\n        clear_reloadable_connections(false)\n      end",
    "comment": "Clears reloadable connections from the pool and re-connects connections that require reloading.  The pool first tries to gain ownership of all connections. If unable to do so within a timeout interval (default duration is <tt>spec.db_config.checkout_timeout * 2</tt> seconds), then the pool forcefully clears the cache and reloads connections without any regard for other connection owning threads.",
    "label": "",
    "id": "2000"
  },
  {
    "raw_code": "def checkout(checkout_timeout = @checkout_timeout)\n        return checkout_and_verify(acquire_connection(checkout_timeout)) unless @pinned_connection\n\n        @pinned_connection.lock.synchronize do\n          synchronize do\n            # The pinned connection may have been cleaned up before we synchronized, so check if it is still present\n            if @pinned_connection\n              @pinned_connection.verify!\n\n              # Any leased connection must be in @connections otherwise\n              # some methods like #connected? won't behave correctly\n              unless @connections.include?(@pinned_connection)\n                @connections << @pinned_connection\n              end",
    "comment": "Check-out a database connection from the pool, indicating that you want to use it. You should call #checkin when you no longer need this.  This is done by either returning and leasing existing connection, or by creating a new connection and leasing it.  If all connections are leased and the pool is at capacity (meaning the number of currently leased connections is greater than or equal to the size limit set), an ActiveRecord::ConnectionTimeoutError exception will be raised.  Returns: an AbstractAdapter object.  Raises: - ActiveRecord::ConnectionTimeoutError no connection can be obtained from the pool.",
    "label": "",
    "id": "2001"
  },
  {
    "raw_code": "def checkin(conn)\n        return if @pinned_connection.equal?(conn)\n\n        conn.lock.synchronize do\n          synchronize do\n            connection_lease.clear(conn)\n            conn.expire\n            @available.add conn\n          end",
    "comment": "Check-in a database connection back into the pool, indicating that you no longer need this connection.  +conn+: an AbstractAdapter object, which was obtained by earlier by calling #checkout on this pool.",
    "label": "",
    "id": "2002"
  },
  {
    "raw_code": "def remove(conn)\n        needs_new_connection = false\n\n        synchronize do\n          remove_connection_from_thread_cache conn\n\n          @connections.delete conn\n          @available.delete conn\n\n          # @available.any_waiting? => true means that prior to removing this\n          # conn, the pool was at its max size (@connections.size == @max_connections).\n          # This would mean that any threads stuck waiting in the queue wouldn't\n          # know they could checkout_new_connection, so let's do it for them.\n          # Because condition-wait loop is encapsulated in the Queue class\n          # (that in turn is oblivious to ConnectionPool implementation), threads\n          # that are \"stuck\" there are helpless. They have no way of creating\n          # new connections and are completely reliant on us feeding available\n          # connections into the Queue.\n          needs_new_connection = @available.num_waiting > @maintaining\n        end",
    "comment": "Remove a connection from the connection pool. The connection will remain open and active but will no longer be managed by this pool.",
    "label": "",
    "id": "2003"
  },
  {
    "raw_code": "def reap\n        stale_connections = synchronize do\n          return if self.discarded?\n          @connections.select do |conn|\n            conn.in_use? && !conn.owner.alive?\n          end.each do |conn|\n            conn.steal!\n          end",
    "comment": "Recover lost connections for the pool. A lost connection can occur if a programmer forgets to checkin a connection at the end of a thread or a thread dies unexpectedly.",
    "label": "",
    "id": "2004"
  },
  {
    "raw_code": "def flush(minimum_idle = @idle_timeout)\n        return if minimum_idle.nil?\n\n        removed_connections = synchronize do\n          return if self.discarded?\n\n          idle_connections = @connections.select do |conn|\n            !conn.in_use? && conn.seconds_idle >= minimum_idle\n          end.sort_by { |conn| -conn.seconds_idle } # sort longest idle first\n\n          # Don't go below our configured pool minimum unless we're flushing\n          # everything\n          idles_to_retain =\n            if minimum_idle > 0\n              @min_connections - (@connections.size - idle_connections.size)\n            else\n              0\n            end",
    "comment": "Disconnect all connections that have been idle for at least +minimum_idle+ seconds. Connections currently checked out, or that were checked in less than +minimum_idle+ seconds ago, are unaffected.",
    "label": "",
    "id": "2005"
  },
  {
    "raw_code": "def flush!\n        reap\n        flush(-1)\n\n        # Stop maintaining the minimum size until reactivated\n        @activated = false\n      end",
    "comment": "Disconnect all currently idle connections. Connections currently checked out are unaffected. The pool will stop maintaining its minimum size until it is reactivated (such as by a subsequent checkout).",
    "label": "",
    "id": "2006"
  },
  {
    "raw_code": "def prepopulate\n        need_new_connections = nil\n\n        synchronize do\n          return if self.discarded?\n\n          # We don't want to start prepopulating until we know the pool is wanted,\n          # so we can avoid maintaining full pools in one-off scripts etc.\n          return unless @activated\n\n          need_new_connections = @connections.size < @min_connections\n        end",
    "comment": "Ensure that the pool contains at least the configured minimum number of connections.",
    "label": "",
    "id": "2007"
  },
  {
    "raw_code": "def preconnect\n        sequential_maintenance -> c { (!c.connected? || !c.verified?) && c.allow_preconnect } do |conn|\n          conn.connect!\n        rescue\n          # Wholesale rescue: there's nothing we can do but move on. The\n          # connection will go back to the pool, and the next consumer will\n          # presumably try to connect again -- which will either work, or\n          # fail and they'll be able to report the exception.\n        end",
    "comment": "Preconnect all connections in the pool. This saves pool users from having to wait for a connection to be established when first using it after checkout.",
    "label": "",
    "id": "2008"
  },
  {
    "raw_code": "def keep_alive(threshold = @keepalive)\n        return if threshold.nil?\n\n        sequential_maintenance -> c { (c.seconds_since_last_activity || 0) > c.pool_jitter(threshold) } do |conn|\n          # conn.active? will cause some amount of network activity, which is all\n          # we need to provide a keepalive signal.\n          #\n          # If it returns false, the connection is already broken; disconnect,\n          # so it can be found and repaired.\n          conn.disconnect! unless conn.active?\n        end",
    "comment": "Prod any connections that have been idle for longer than the configured keepalive time. This will incidentally verify the connection is still alive, but the main purpose is to show the server (and any intermediate network hops) that we're still here and using the connection.",
    "label": "",
    "id": "2009"
  },
  {
    "raw_code": "def recycle!\n        synchronize do\n          return if self.discarded?\n\n          @connections.each do |conn|\n            conn.force_retirement\n          end",
    "comment": "Immediately mark all current connections as due for replacement, equivalent to them having reached +max_age+ -- even if there is no +max_age+ configured.",
    "label": "",
    "id": "2010"
  },
  {
    "raw_code": "def stat\n        synchronize do\n          {\n            size: size,\n            connections: @connections.size,\n            busy: @connections.count { |c| c.in_use? && c.owner.alive? },\n            dead: @connections.count { |c| c.in_use? && !c.owner.alive? },\n            idle: @connections.count { |c| !c.in_use? },\n            waiting: num_waiting_in_queue,\n            checkout_timeout: checkout_timeout\n          }\n        end",
    "comment": "Returns the connection pool's usage statistic.  ActiveRecord::Base.connection_pool.stat # => { size: 15, connections: 1, busy: 1, dead: 0, idle: 0, waiting: 0, checkout_timeout: 5 }",
    "label": "",
    "id": "2011"
  },
  {
    "raw_code": "def sequential_maintenance(candidate_selector, &maintenance_work)\n          # This hash doesn't need to be synchronized, because it's only\n          # used by one thread at a time: the +perform_work+ block gives\n          # up its right to +connections_visited+ when it schedules the\n          # next iteration.\n          connections_visited = Hash.new(false)\n          connections_visited.compare_by_identity\n\n          perform_work = lambda do\n            connection_to_maintain = nil\n\n            synchronize do\n              unless self.discarded?\n                if connection_to_maintain = @connections.select { |conn| !conn.in_use? }.select(&candidate_selector).sort_by(&:seconds_idle).find { |conn| !connections_visited[conn] }\n                  checkout_for_maintenance connection_to_maintain\n                end",
    "comment": "Perform maintenance work on pool connections. This method will select a connection to work on by calling the +candidate_selector+ proc while holding the pool lock. If a connection is selected, it will be checked out for maintenance and passed to the +maintenance_work+ proc. The connection will always be returned to the pool after the proc completes.  If the pool has async threads, all work will be scheduled there. Otherwise, this method will block until all work is complete.  Each connection will only be processed once per call to this method, but (particularly in the async case) there is no protection against a second call to this method starting to work through the list before the first call has completed. (Though regular pool behavior will prevent two instances from working on the same specific connection at the same time.)",
    "label": "",
    "id": "2012"
  },
  {
    "raw_code": "def checkout_for_maintenance(conn)\n          synchronize do\n            @maintaining += 1\n            @available.delete(conn)\n            conn.lease\n            conn\n          end",
    "comment": "Directly check a specific connection out of the pool. Skips callbacks.  The connection must later either #return_from_maintenance or #remove_from_maintenance, or the pool will hang.",
    "label": "",
    "id": "2013"
  },
  {
    "raw_code": "def return_from_maintenance(conn)\n          synchronize do\n            conn.expire(false)\n            @available.add_back(conn)\n            @maintaining -= 1\n          end",
    "comment": "Return a connection to the pool after it has been checked out for maintenance. Does not update the connection's idle time, and skips callbacks. -- We assume that a connection that has required maintenance is less desirable (either it's been idle for a long time, or it was just created and hasn't been used yet). We'll put it at the back of the queue.",
    "label": "",
    "id": "2014"
  },
  {
    "raw_code": "def remove_from_maintenance(conn)\n          synchronize do\n            @maintaining -= 1\n            remove conn\n          end",
    "comment": "Remove a connection from the pool after it has been checked out for maintenance. It will be automatically replaced with a new connection if necessary.",
    "label": "",
    "id": "2015"
  },
  {
    "raw_code": "def bulk_make_new_connections(num_new_conns_needed)\n          num_new_conns_needed.times do\n            # try_to_checkout_new_connection will not exceed pool's @max_connections limit\n            if new_conn = try_to_checkout_new_connection\n              # make the new_conn available to the starving threads stuck @available Queue\n              checkin(new_conn)\n            end",
    "comment": "-- this is unfortunately not concurrent",
    "label": "",
    "id": "2016"
  },
  {
    "raw_code": "def with_exclusively_acquired_all_connections(raise_on_acquisition_timeout = true)\n          @reaper_lock.synchronize do\n            with_new_connections_blocked do\n              attempt_to_checkout_all_existing_connections(raise_on_acquisition_timeout)\n              yield\n            end",
    "comment": "Take control of all existing connections so a \"group\" action such as reload/disconnect can be performed safely. It is no longer enough to wrap it in +synchronize+ because some pool's actions are allowed to be performed outside of the main +synchronize+ block.",
    "label": "",
    "id": "2017"
  },
  {
    "raw_code": "def checkout_for_exclusive_access(checkout_timeout)\n          checkout(checkout_timeout)\n        rescue ConnectionTimeoutError\n          # this block can't be easily moved into attempt_to_checkout_all_existing_connections's\n          # rescue block, because doing so would put it outside of synchronize section, without\n          # being in a critical section thread_report might become inaccurate\n          msg = +\"could not obtain ownership of all database connections in #{checkout_timeout} seconds\"\n\n          thread_report = []\n          @connections.each do |conn|\n            unless conn.owner == ActiveSupport::IsolatedExecutionState.context\n              thread_report << \"#{conn} is owned by #{conn.owner}\"\n            end",
    "comment": "-- Must be called in a synchronize block.",
    "label": "",
    "id": "2018"
  },
  {
    "raw_code": "def acquire_connection(checkout_timeout)\n          # NOTE: we rely on <tt>@available.poll</tt> and +try_to_checkout_new_connection+ to\n          # +conn.lease+ the returned connection (and to do this in a +synchronized+\n          # section). This is not the cleanest implementation, as ideally we would\n          # <tt>synchronize { conn.lease }</tt> in this method, but by leaving it to <tt>@available.poll</tt>\n          # and +try_to_checkout_new_connection+ we can piggyback on +synchronize+ sections\n          # of the said methods and avoid an additional +synchronize+ overhead.\n          if conn = @available.poll || try_to_queue_for_background_connection(checkout_timeout) || try_to_checkout_new_connection\n            conn\n          else\n            reap\n            # Retry after reaping, which may return an available connection,\n            # remove an inactive connection, or both\n            if conn = @available.poll || try_to_queue_for_background_connection(checkout_timeout) || try_to_checkout_new_connection\n              conn\n            else\n              @available.poll(checkout_timeout)\n            end",
    "comment": "Acquire a connection by one of 1) immediately removing one from the queue of available connections, 2) creating a new connection if the pool is not at capacity, 3) waiting on the queue for a connection to become available.  Raises: - ActiveRecord::ConnectionTimeoutError if a connection could not be acquired  -- Implementation detail: the connection returned by +acquire_connection+ will already be \"+connection.lease+ -ed\" to the current thread.",
    "label": "",
    "id": "2019"
  },
  {
    "raw_code": "def try_to_queue_for_background_connection(checkout_timeout)\n          return unless @maintaining > 0\n\n          synchronize do\n            return unless @maintaining > @available.num_waiting\n\n            # We are guaranteed the \"maintaining\" thread will return its promised\n            # connection within one maintenance-unit of time. Thus we can safely\n            # do a blocking wait with (functionally) no timeout.\n            @available.poll(100)\n          end",
    "comment": "-- If new connections are already being established in the background, and there are fewer threads already waiting than the number of upcoming connections, we can just get in queue and wait to be handed a connection. This avoids us overshooting the required connection count by starting a new connection ourselves, and is likely to be faster too (because at least some of the time it takes to establish a new connection must have already passed).  If background connections are available, this method will block and return a connection. If no background connections are available, it will immediately return +nil+.",
    "label": "",
    "id": "2020"
  },
  {
    "raw_code": "def remove_connection_from_thread_cache(conn, owner_thread = conn.owner)\n          if owner_thread\n            @leases[owner_thread].clear(conn)\n          end",
    "comment": "-- if owner_thread param is omitted, this must be called in synchronize block",
    "label": "",
    "id": "2021"
  },
  {
    "raw_code": "def try_to_checkout_new_connection\n          # first in synchronized section check if establishing new conns is allowed\n          # and increment @now_connecting, to prevent overstepping this pool's @max_connections\n          # constraint\n          do_checkout = synchronize do\n            return if self.discarded?\n\n            if @threads_blocking_new_connections.zero? && (@max_connections.nil? || (@connections.size + @now_connecting) < @max_connections) && (!block_given? || yield)\n              if @connections.size > 0 || @original_context != ActiveSupport::IsolatedExecutionState.context\n                @activated = true\n              end",
    "comment": "If the pool is not at a <tt>@max_connections</tt> limit, establish new connection. Connecting to the DB is done outside main synchronized section.  If a block is supplied, it is an additional constraint (checked while holding the pool lock) on whether a new connection should be established. -- Implementation constraint: a newly established connection returned by this method must be in the +.leased+ state.",
    "label": "",
    "id": "2022"
  },
  {
    "raw_code": "def table_name_length\n        max_identifier_length\n      end",
    "comment": "Returns the maximum length of a table name.",
    "label": "",
    "id": "2023"
  },
  {
    "raw_code": "def table_alias_length\n        max_identifier_length\n      end",
    "comment": "Returns the maximum length of a table alias.",
    "label": "",
    "id": "2024"
  },
  {
    "raw_code": "def index_name_length\n        max_identifier_length\n      end",
    "comment": "Returns the maximum length of an index name.",
    "label": "",
    "id": "2025"
  },
  {
    "raw_code": "def to_sql(arel_or_sql_string, binds = [])\n        sql, _ = to_sql_and_binds(arel_or_sql_string, binds)\n        sql\n      end",
    "comment": "Converts an arel AST to SQL",
    "label": "",
    "id": "2026"
  },
  {
    "raw_code": "def cacheable_query(klass, arel) # :nodoc:\n        if prepared_statements\n          collector = collector()\n          collector.retryable = true\n          sql, binds = visitor.compile(arel.ast, collector)\n          query = klass.query(sql, retryable: collector.retryable)\n        else\n          collector = klass.partial_query_collector\n          collector.retryable = true\n          parts, binds = visitor.compile(arel.ast, collector)\n          query = klass.partial_query(parts, retryable: collector.retryable)\n        end",
    "comment": "This is used in the StatementCache object. It returns an object that can be used to query the database repeatedly.",
    "label": "",
    "id": "2027"
  },
  {
    "raw_code": "def select_all(arel, name = nil, binds = [], preparable: nil, async: false, allow_retry: false)\n        arel = arel_from_relation(arel)\n        sql, binds, preparable, allow_retry = to_sql_and_binds(arel, binds, preparable, allow_retry)\n\n        select(sql, name, binds,\n          prepare: prepared_statements && preparable,\n          async: async && FutureResult::SelectAll,\n          allow_retry: allow_retry\n        )\n      rescue ::RangeError\n        ActiveRecord::Result.empty(async: async)\n      end",
    "comment": "Returns an ActiveRecord::Result instance.",
    "label": "",
    "id": "2028"
  },
  {
    "raw_code": "def select_one(arel, name = nil, binds = [], async: false)\n        select_all(arel, name, binds, async: async).then(&:first)\n      end",
    "comment": "Returns a record hash with the column names as keys and column values as values.",
    "label": "",
    "id": "2029"
  },
  {
    "raw_code": "def select_value(arel, name = nil, binds = [], async: false)\n        select_rows(arel, name, binds, async: async).then { |rows| single_value_from_rows(rows) }\n      end",
    "comment": "Returns a single value from a record",
    "label": "",
    "id": "2030"
  },
  {
    "raw_code": "def select_values(arel, name = nil, binds = [])\n        select_rows(arel, name, binds).map(&:first)\n      end",
    "comment": "Returns an array of the values of the first column in a select: select_values(\"SELECT id FROM companies LIMIT 3\") => [1,2,3]",
    "label": "",
    "id": "2031"
  },
  {
    "raw_code": "def select_rows(arel, name = nil, binds = [], async: false)\n        select_all(arel, name, binds, async: async).then(&:rows)\n      end",
    "comment": "Returns an array of arrays containing the field values. Order is the same as that returned by +columns+.",
    "label": "",
    "id": "2032"
  },
  {
    "raw_code": "def write_query?(sql)\n        raise NotImplementedError\n      end",
    "comment": "Determines whether the SQL statement is a write query.",
    "label": "",
    "id": "2033"
  },
  {
    "raw_code": "def execute(sql, name = nil, allow_retry: false)\n        internal_execute(sql, name, allow_retry: allow_retry)\n      end",
    "comment": "Executes the SQL statement in the context of this connection and returns the raw result from the connection adapter.  Setting +allow_retry+ to true causes the db to reconnect and retry executing the SQL statement in case of a connection-related exception. This option should only be enabled for known idempotent queries.  Note: the query is assumed to have side effects and the query cache will be cleared. If the query is read-only, consider using #select_all instead.  Note: depending on your database connector, the result returned by this method may be manually memory managed. Consider using #exec_query wrapper instead.",
    "label": "",
    "id": "2034"
  },
  {
    "raw_code": "def exec_query(sql, name = \"SQL\", binds = [], prepare: false)\n        internal_exec_query(sql, name, binds, prepare: prepare)\n      end",
    "comment": "Executes +sql+ statement in the context of this connection using +binds+ as the bind substitutes. +name+ is logged along with the executed +sql+ statement.  Note: the query is assumed to have side effects and the query cache will be cleared. If the query is read-only, consider using #select_all instead.",
    "label": "",
    "id": "2035"
  },
  {
    "raw_code": "def exec_insert(sql, name = nil, binds = [], pk = nil, sequence_name = nil, returning: nil)\n        sql, binds = sql_for_insert(sql, pk, binds, returning)\n        internal_exec_query(sql, name, binds)\n      end",
    "comment": "Executes insert +sql+ statement in the context of this connection using +binds+ as the bind substitutes. +name+ is logged along with the executed +sql+ statement. Some adapters support the `returning` keyword argument which allows to control the result of the query: `nil` is the default value and maintains default behavior. If an array of column names is passed - the result will contain values of the specified columns from the inserted row.",
    "label": "",
    "id": "2036"
  },
  {
    "raw_code": "def exec_delete(sql, name = nil, binds = [])\n        affected_rows(internal_execute(sql, name, binds))\n      end",
    "comment": "Executes delete +sql+ statement in the context of this connection using +binds+ as the bind substitutes. +name+ is logged along with the executed +sql+ statement.",
    "label": "",
    "id": "2037"
  },
  {
    "raw_code": "def exec_update(sql, name = nil, binds = [])\n        affected_rows(internal_execute(sql, name, binds))\n      end",
    "comment": "Executes update +sql+ statement in the context of this connection using +binds+ as the bind substitutes. +name+ is logged along with the executed +sql+ statement.",
    "label": "",
    "id": "2038"
  },
  {
    "raw_code": "def insert(arel, name = nil, pk = nil, id_value = nil, sequence_name = nil, binds = [], returning: nil)\n        sql, binds = to_sql_and_binds(arel, binds)\n        value = exec_insert(sql, name, binds, pk, sequence_name, returning: returning)\n\n        return returning_column_values(value) unless returning.nil?\n\n        id_value || last_inserted_id(value)\n      end",
    "comment": "Executes an INSERT query and returns the new record's ID  +id_value+ will be returned unless the value is +nil+, in which case the database will attempt to calculate the last inserted id and return that value.  If the next id was calculated in advance (as in Oracle), it should be passed in as +id_value+. Some adapters support the `returning` keyword argument which allows defining the return value of the method: `nil` is the default value and maintains default behavior. If an array of column names is passed - an array of is returned from the method representing values of the specified columns from the inserted row.",
    "label": "",
    "id": "2039"
  },
  {
    "raw_code": "def update(arel, name = nil, binds = [])\n        sql, binds = to_sql_and_binds(arel, binds)\n        exec_update(sql, name, binds)\n      end",
    "comment": "Executes the update statement and returns the number of rows affected.",
    "label": "",
    "id": "2040"
  },
  {
    "raw_code": "def delete(arel, name = nil, binds = [])\n        sql, binds = to_sql_and_binds(arel, binds)\n        exec_delete(sql, name, binds)\n      end",
    "comment": "Executes the delete statement and returns the number of rows affected.",
    "label": "",
    "id": "2041"
  },
  {
    "raw_code": "def truncate(table_name, name = nil)\n        execute(build_truncate_statement(table_name), name)\n      end",
    "comment": "Executes the truncate statement.",
    "label": "",
    "id": "2042"
  },
  {
    "raw_code": "def transaction(requires_new: nil, isolation: nil, joinable: true, &block)\n        # If we're running inside the single, non-joinable transaction that\n        # ActiveRecord::TestFixtures starts around each example (depth == 1),\n        # an `isolation:` hint must be validated then ignored so that the\n        # adapter isn't asked to change the isolation level mid-transaction.\n        if isolation && !requires_new && open_transactions == 1 && !current_transaction.joinable?\n          iso = isolation.to_sym\n\n          unless transaction_isolation_levels.include?(iso)\n            raise ActiveRecord::TransactionIsolationError,\n                  \"invalid transaction isolation level: #{iso.inspect}\"\n          end",
    "comment": "Runs the given block in a database transaction, and returns the result of the block.  == Transaction callbacks  #transaction yields an ActiveRecord::Transaction object on which it is possible to register callback:  ActiveRecord::Base.transaction do |transaction| transaction.before_commit { puts \"before commit!\" } transaction.after_commit { puts \"after commit!\" } transaction.after_rollback { puts \"after rollback!\" } end  == Nested transactions support  #transaction calls can be nested. By default, this makes all database statements in the nested transaction block become part of the parent transaction. For example, the following behavior may be surprising:  ActiveRecord::Base.transaction do Post.create(title: 'first') ActiveRecord::Base.transaction do Post.create(title: 'second') raise ActiveRecord::Rollback end end  This creates both \"first\" and \"second\" posts. Reason is the ActiveRecord::Rollback exception in the nested block does not issue a ROLLBACK. Since these exceptions are captured in transaction blocks, the parent block does not see it and the real transaction is committed.  Most databases don't support true nested transactions. At the time of writing, the only database that supports true nested transactions that we're aware of, is MS-SQL.  In order to get around this problem, #transaction will emulate the effect of nested transactions, by using savepoints: https://dev.mysql.com/doc/refman/en/savepoint.html.  It is safe to call this method if a database transaction is already open, i.e. if #transaction is called within another #transaction block. In case of a nested call, #transaction will behave as follows:  - The block will be run without doing anything. All database statements that happen within the block are effectively appended to the already open database transaction. - However, if +:requires_new+ is set, the block will be wrapped in a database savepoint acting as a sub-transaction.  In order to get a ROLLBACK for the nested transaction you may ask for a real sub-transaction by passing <tt>requires_new: true</tt>. If anything goes wrong, the database rolls back to the beginning of the sub-transaction without rolling back the parent transaction. If we add it to the previous example:  ActiveRecord::Base.transaction do Post.create(title: 'first') ActiveRecord::Base.transaction(requires_new: true) do Post.create(title: 'second') raise ActiveRecord::Rollback end end  only post with title \"first\" is created.  See ActiveRecord::Transactions to learn more.  === Caveats  MySQL doesn't support DDL transactions. If you perform a DDL operation, then any created savepoints will be automatically released. For example, if you've created a savepoint, then you execute a CREATE TABLE statement, then the savepoint that was created will be automatically released.  This means that, on MySQL, you shouldn't execute DDL operations inside a #transaction call that you know might create a savepoint. Otherwise, #transaction will raise exceptions when it tries to release the already-automatically-released savepoints:  Model.lease_connection.transaction do  # BEGIN Model.lease_connection.transaction(requires_new: true) do  # CREATE SAVEPOINT active_record_1 Model.lease_connection.create_table(...) # active_record_1 now automatically released end  # RELEASE SAVEPOINT active_record_1  <--- BOOM! database error! end  == Transaction isolation  If your database supports setting the isolation level for a transaction, you can set it like so:  Post.transaction(isolation: :serializable) do # ... end  Valid isolation levels are:  * <tt>:read_uncommitted</tt> * <tt>:read_committed</tt> * <tt>:repeatable_read</tt> * <tt>:serializable</tt>  You should consult the documentation for your database to understand the semantics of these different levels:  * https://www.postgresql.org/docs/current/static/transaction-iso.html * https://dev.mysql.com/doc/refman/en/set-transaction.html  An ActiveRecord::TransactionIsolationError will be raised if:  * The adapter does not support setting the isolation level * You are joining an existing open transaction * You are creating a nested (savepoint) transaction  The mysql2, trilogy, and postgresql adapters support setting the transaction isolation level. :args: (requires_new: nil, isolation: nil, &block)",
    "label": "",
    "id": "2043"
  },
  {
    "raw_code": "def add_transaction_record(record, ensure_finalize = true)\n        current_transaction.add_record(record, ensure_finalize)\n      end",
    "comment": "Register a record with the current transaction so that its after_commit and after_rollback callbacks can be called.",
    "label": "",
    "id": "2044"
  },
  {
    "raw_code": "def begin_db_transaction()    end\n\n      def begin_deferred_transaction(isolation_level = nil) # :nodoc:\n        if isolation_level\n          begin_isolated_db_transaction(isolation_level)\n        else\n          begin_db_transaction\n        end\n      end",
    "comment": "Begins the transaction (and turns off auto-committing).",
    "label": "",
    "id": "2045"
  },
  {
    "raw_code": "def begin_isolated_db_transaction(isolation)\n        raise ActiveRecord::TransactionIsolationError, \"adapter does not support setting transaction isolation\"\n      end",
    "comment": "Begins the transaction with the isolation level set. Raises an error by default; adapters that support setting the isolation level should implement this method.",
    "label": "",
    "id": "2046"
  },
  {
    "raw_code": "def reset_isolation_level\n      end",
    "comment": "Hook point called after an isolated DB transaction is committed or rolled back. Most adapters don't need to implement anything because the isolation level is set on a per transaction basis. But some databases like SQLite set it on a per connection level and need to explicitly reset it after commit or rollback.",
    "label": "",
    "id": "2047"
  },
  {
    "raw_code": "def commit_db_transaction()   end\n\n      # Rolls back the transaction (and turns on auto-committing). Must be\n      # done if the transaction block raises an exception or returns false.\n      def rollback_db_transaction\n        exec_rollback_db_transaction\n      rescue ActiveRecord::ConnectionNotEstablished, ActiveRecord::ConnectionFailed\n        # Connection's gone; that counts as a rollback\n      end\n\n      def exec_rollback_db_transaction() end # :nodoc:\n\n      def restart_db_transaction\n        exec_restart_db_transaction\n      end\n\n      def exec_restart_db_transaction() end # :nodoc:\n\n      def rollback_to_savepoint(name = nil)\n        exec_rollback_to_savepoint(name)\n      end\n\n      def default_sequence_name(table, column)\n        nil\n      end\n\n      # Set the sequence to the max value of the table's column.\n      def reset_sequence!(table, column, sequence = nil)\n        # Do nothing by default. Implement for PostgreSQL, Oracle, ...\n      end\n\n      # Inserts the given fixture into the table. Overridden in adapters that require\n      # something beyond a simple insert (e.g. Oracle).\n      # Most of adapters should implement +insert_fixtures_set+ that leverages bulk SQL insert.\n      # We keep this method to provide fallback\n      # for databases like SQLite that do not support bulk inserts.\n      def insert_fixture(fixture, table_name)\n        execute(build_fixture_sql(Array.wrap(fixture), table_name), \"Fixture Insert\")\n      end\n\n      def insert_fixtures_set(fixture_set, tables_to_delete = [])\n        fixture_inserts = build_fixture_statements(fixture_set)\n        table_deletes = tables_to_delete.map { |table| \"DELETE FROM #{quote_table_name(table)}\" }\n        statements = table_deletes + fixture_inserts\n\n        transaction(requires_new: true) do\n          disable_referential_integrity do\n            execute_batch(statements, \"Fixtures Load\")\n          end\n        end\n      end\n\n      def empty_insert_statement_value(primary_key = nil)\n        \"DEFAULT VALUES\"\n      end\n\n      # Fixture value is quoted by Arel, however scalar values\n      # are not quotable. In this case we want to convert\n      # the column value to YAML.\n      def with_yaml_fallback(value) # :nodoc:\n        if value.is_a?(Hash) || value.is_a?(Array)\n          YAML.dump(value)\n        else\n          value\n        end\n      end",
    "comment": "Commits the transaction (and turns on auto-committing).",
    "label": "",
    "id": "2048"
  },
  {
    "raw_code": "def high_precision_current_timestamp\n        HIGH_PRECISION_CURRENT_TIMESTAMP\n      end",
    "comment": "Returns an Arel SQL literal for the CURRENT_TIMESTAMP for usage with arbitrary precision date/time columns.  Adapters supporting datetime with precision should override this to provide as much precision as is available.",
    "label": "",
    "id": "2049"
  },
  {
    "raw_code": "def raw_exec_query(...) # :nodoc:\n        cast_result(raw_execute(...))\n      end",
    "comment": "Same as raw_execute but returns an ActiveRecord::Result object.",
    "label": "",
    "id": "2050"
  },
  {
    "raw_code": "def internal_exec_query(...) # :nodoc:\n        cast_result(internal_execute(...))\n      end",
    "comment": "Execute a query and returns an ActiveRecord::Result",
    "label": "",
    "id": "2051"
  },
  {
    "raw_code": "def raw_execute(sql, name = nil, binds = [], prepare: false, async: false, allow_retry: false, materialize_transactions: true, batch: false)\n          type_casted_binds = type_casted_binds(binds)\n          log(sql, name, binds, type_casted_binds, async: async, allow_retry: allow_retry) do |notification_payload|\n            with_raw_connection(allow_retry: allow_retry, materialize_transactions: materialize_transactions) do |conn|\n              result = perform_query(conn, sql, binds, type_casted_binds, prepare: prepare, notification_payload: notification_payload, batch: batch)\n              handle_warnings(result, sql)\n              result\n            end",
    "comment": "Lowest level way to execute a query. Doesn't check for illegal writes, doesn't annotate queries, yields a native result object.",
    "label": "",
    "id": "2052"
  },
  {
    "raw_code": "def cast_result(raw_result)\n          raise NotImplementedError\n        end",
    "comment": "Receive a native adapter result object and returns an ActiveRecord::Result object.",
    "label": "",
    "id": "2053"
  },
  {
    "raw_code": "def internal_execute(sql, name = \"SQL\", binds = [], prepare: false, async: false, allow_retry: false, materialize_transactions: true, &block)\n          sql = preprocess_query(sql)\n          raw_execute(sql, name, binds, prepare: prepare, async: async, allow_retry: allow_retry, materialize_transactions: materialize_transactions, &block)\n        end",
    "comment": "Same as #internal_exec_query, but yields a native adapter result",
    "label": "",
    "id": "2054"
  },
  {
    "raw_code": "def select(sql, name = nil, binds = [], prepare: false, async: false, allow_retry: false)\n          if async && async_enabled?\n            if current_transaction.joinable?\n              raise AsynchronousQueryInsideTransactionError, \"Asynchronous queries are not allowed inside transactions\"\n            end",
    "comment": "Returns an ActiveRecord::Result instance.",
    "label": "",
    "id": "2055"
  },
  {
    "raw_code": "def disable_query_cache(dirties: true)\n          cache = query_cache\n          old_enabled, cache.enabled, old_dirties, cache.dirties = cache.enabled, false, cache.dirties, dirties\n          begin\n            yield\n          ensure\n            cache.enabled, cache.dirties = old_enabled, old_dirties\n          end",
    "comment": "Disable the query cache within the block.",
    "label": "",
    "id": "2056"
  },
  {
    "raw_code": "def cache(&block)\n        pool.enable_query_cache(&block)\n      end",
    "comment": "Enable the query cache within the block.",
    "label": "",
    "id": "2057"
  },
  {
    "raw_code": "def uncached(dirties: true, &block)\n        pool.disable_query_cache(dirties: dirties, &block)\n      end",
    "comment": "Disable the query cache within the block.  Set <tt>dirties: false</tt> to prevent query caches on all connections from being cleared by write operations. (By default, write operations dirty all connections' query caches in case they are replicas whose cache would now be outdated.)",
    "label": "",
    "id": "2058"
  },
  {
    "raw_code": "def clear_query_cache\n        pool.clear_query_cache\n      end",
    "comment": "Clears the query cache.  One reason you may wish to call this method explicitly is between queries that ask the database to randomize results. Otherwise the cache would see the same SQL query and repeatedly return the same result each time, silently undermining the randomness you were expecting.",
    "label": "",
    "id": "2059"
  },
  {
    "raw_code": "def cache_notification_info(sql, name, binds)\n          {\n            sql: sql,\n            binds: binds,\n            type_casted_binds: -> { type_casted_binds(binds) },\n            name: name,\n            connection: self,\n            transaction: current_transaction.user_transaction.presence,\n            cached: true\n          }\n        end",
    "comment": "Database adapters can override this method to provide custom cache information.",
    "label": "",
    "id": "2060"
  },
  {
    "raw_code": "def column_name_matcher\n          /\n            \\A\n            (\n              (?:\n                # table_name.column_name | function(one or no argument)\n                ((?:\\w+\\.)?\\w+ | \\w+\\((?:|\\g<2>)\\))\n              )\n              (?:(?:\\s+AS)?\\s+\\w+)?\n            )\n            (?:\\s*,\\s*\\g<1>)*\n            \\z\n          /ix\n        end",
    "comment": "Regexp for column names (with or without a table name prefix). Matches the following:  \"#{table_name}.#{column_name}\" \"#{column_name}\"",
    "label": "",
    "id": "2061"
  },
  {
    "raw_code": "def column_name_with_order_matcher\n          /\n            \\A\n            (\n              (?:\n                # table_name.column_name | function(one or no argument)\n                ((?:\\w+\\.)?\\w+ | \\w+\\((?:|\\g<2>)\\))\n              )\n              (?:\\s+ASC|\\s+DESC)?\n              (?:\\s+NULLS\\s+(?:FIRST|LAST))?\n            )\n            (?:\\s*,\\s*\\g<1>)*\n            \\z\n          /ix\n        end",
    "comment": "Regexp for column names with order (with or without a table name prefix, with or without various order modifiers). Matches the following:  \"#{table_name}.#{column_name}\" \"#{table_name}.#{column_name} #{direction}\" \"#{table_name}.#{column_name} #{direction} NULLS FIRST\" \"#{table_name}.#{column_name} NULLS LAST\" \"#{column_name}\" \"#{column_name} #{direction}\" \"#{column_name} #{direction} NULLS FIRST\" \"#{column_name} NULLS LAST\"",
    "label": "",
    "id": "2062"
  },
  {
    "raw_code": "def quote_column_name(column_name)\n          raise NotImplementedError\n        end",
    "comment": "Quotes the column name. Must be implemented by subclasses",
    "label": "",
    "id": "2063"
  },
  {
    "raw_code": "def quote_table_name(table_name)\n          quote_column_name(table_name)\n        end",
    "comment": "Quotes the table name. Defaults to column name quoting.",
    "label": "",
    "id": "2064"
  },
  {
    "raw_code": "def quote(value)\n        case value\n        when String, Symbol, ActiveSupport::Multibyte::Chars\n          \"'#{quote_string(value.to_s)}'\"\n        when true       then quoted_true\n        when false      then quoted_false\n        when nil        then \"NULL\"\n        # BigDecimals need to be put in a non-normalized form and quoted.\n        when BigDecimal then value.to_s(\"F\")\n        when Numeric then value.to_s\n        when Type::Binary::Data then quoted_binary(value)\n        when Type::Time::Value then \"'#{quoted_time(value)}'\"\n        when Date, Time then \"'#{quoted_date(value)}'\"\n        when Class      then \"'#{value}'\"\n        else\n          raise TypeError, \"can't quote #{value.class.name}\"\n        end",
    "comment": "Quotes the column value to help prevent {SQL injection attacks}[https://en.wikipedia.org/wiki/SQL_injection].",
    "label": "",
    "id": "2065"
  },
  {
    "raw_code": "def type_cast(value)\n        case value\n        when Symbol, Type::Binary::Data, ActiveSupport::Multibyte::Chars\n          value.to_s\n        when true       then unquoted_true\n        when false      then unquoted_false\n        # BigDecimals need to be put in a non-normalized form and quoted.\n        when BigDecimal then value.to_s(\"F\")\n        when nil, Numeric, String then value\n        when Type::Time::Value then quoted_time(value)\n        when Date, Time then quoted_date(value)\n        else\n          raise TypeError, \"can't cast #{value.class.name}\"\n        end",
    "comment": "Cast a +value+ to a type that the database understands. For example, SQLite does not understand dates, so this method will convert a Date to a String.",
    "label": "",
    "id": "2066"
  },
  {
    "raw_code": "def cast_bound_value(value) # :nodoc:\n        value\n      end",
    "comment": "Cast a value to be used as a bound parameter of unknown type. For example, MySQL might perform dangerous castings when comparing a string to a number, so this method will cast numbers to string.",
    "label": "",
    "id": "2067"
  },
  {
    "raw_code": "def quote_string(s)\n        s.gsub(\"\\\\\", '\\&\\&').gsub(\"'\", \"''\") # ' (for ruby-mode)\n      end",
    "comment": "Quotes a string, escaping any ' (single quote) and \\ (backslash) characters.",
    "label": "",
    "id": "2068"
  },
  {
    "raw_code": "def quote_column_name(column_name)\n        self.class.quote_column_name(column_name)\n      end",
    "comment": "Quotes the column name.",
    "label": "",
    "id": "2069"
  },
  {
    "raw_code": "def quote_table_name(table_name)\n        self.class.quote_table_name(table_name)\n      end",
    "comment": "Quotes the table name.",
    "label": "",
    "id": "2070"
  },
  {
    "raw_code": "def quote_table_name_for_assignment(table, attr)\n        quote_table_name(\"#{table}.#{attr}\")\n      end",
    "comment": "Override to return the quoted table name for assignment. Defaults to table quoting.  This works for MySQL where table.column can be used to resolve ambiguity.  We override this in the sqlite3 and postgresql adapters to use only the column name (as per syntax requirements).",
    "label": "",
    "id": "2071"
  },
  {
    "raw_code": "def quoted_date(value)\n        if value.acts_like?(:time)\n          if default_timezone == :utc\n            value = value.getutc if !value.utc?\n          else\n            value = value.getlocal\n          end",
    "comment": "Quote date/time values for use in SQL input. Includes microseconds if the value is a Time responding to usec.",
    "label": "",
    "id": "2072"
  },
  {
    "raw_code": "def table_modifier_in_create(o)\n          \" TEMPORARY\" if o.temporary\n        end",
    "comment": "Returns any SQL string to go between CREATE and TABLE. May be nil.",
    "label": "",
    "id": "2073"
  },
  {
    "raw_code": "def primary_key(name, type = :primary_key, **options)\n        column(name, type, **options, primary_key: true)\n      end",
    "comment": "Appends a primary key definition to the table definition. Can be called multiple times, but this is probably not a good idea.",
    "label": "",
    "id": "2074"
  },
  {
    "raw_code": "def columns; @columns_hash.values; end\n\n      # Returns a ColumnDefinition for the column with name +name+.\n      def [](name)\n        @columns_hash[name.to_s]\n      end\n\n      # Instantiates a new column for the table.\n      # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]\n      # for available options.\n      #\n      # Additional options are:\n      # * <tt>:index</tt> -\n      #   Create an index for the column. Can be either <tt>true</tt> or an options hash.\n      #\n      # This method returns <tt>self</tt>.\n      #\n      # == Examples\n      #\n      #  # Assuming `td` is an instance of TableDefinition\n      #  td.column(:granted, :boolean, index: true)\n      #\n      # == Short-hand examples\n      #\n      # Instead of calling #column directly, you can also work with the short-hand definitions for the default types.\n      # They use the type as the method name instead of as a parameter and allow for multiple columns to be defined\n      # in a single statement.\n      #\n      # What can be written like this with the regular calls to column:\n      #\n      #   create_table :products do |t|\n      #     t.column :shop_id,     :integer\n      #     t.column :creator_id,  :integer\n      #     t.column :item_number, :string\n      #     t.column :name,        :string, default: \"Untitled\"\n      #     t.column :value,       :string, default: \"Untitled\"\n      #     t.column :created_at,  :datetime\n      #     t.column :updated_at,  :datetime\n      #   end\n      #   add_index :products, :item_number\n      #\n      # can also be written as follows using the short-hand:\n      #\n      #   create_table :products do |t|\n      #     t.integer :shop_id, :creator_id\n      #     t.string  :item_number, index: true\n      #     t.string  :name, :value, default: \"Untitled\"\n      #     t.timestamps null: false\n      #   end\n      #\n      # There's a short-hand method for each of the type values declared at the top. And then there's\n      # TableDefinition#timestamps that'll add +created_at+ and +updated_at+ as datetimes.\n      #\n      # TableDefinition#references will add an appropriately-named _id column, plus a corresponding _type\n      # column if the <tt>:polymorphic</tt> option is supplied. If <tt>:polymorphic</tt> is a hash of\n      # options, these will be used when creating the <tt>_type</tt> column. The <tt>:index</tt> option\n      # will also create an index, similar to calling {add_index}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_index].\n      # So what can be written like this:\n      #\n      #   create_table :taggings do |t|\n      #     t.integer :tag_id, :tagger_id, :taggable_id\n      #     t.string  :tagger_type\n      #     t.string  :taggable_type, default: 'Photo'\n      #   end\n      #   add_index :taggings, :tag_id, name: 'index_taggings_on_tag_id'\n      #   add_index :taggings, [:tagger_id, :tagger_type]\n      #\n      # Can also be written as follows using references:\n      #\n      #   create_table :taggings do |t|\n      #     t.references :tag, index: { name: 'index_taggings_on_tag_id' }\n      #     t.references :tagger, polymorphic: true\n      #     t.references :taggable, polymorphic: { default: 'Photo' }, index: false\n      #   end\n      def column(name, type, index: nil, **options)\n        name = name.to_s\n        type = type.to_sym if type\n\n        raise_on_duplicate_column(name)\n        @columns_hash[name] = new_column_definition(name, type, **options)\n\n        if index\n          index_options = index.is_a?(Hash) ? index : {}\n          index(name, **index_options)\n        end\n\n        self\n      end",
    "comment": "Returns an array of ColumnDefinition objects for the columns of the table.",
    "label": "",
    "id": "2075"
  },
  {
    "raw_code": "def remove_column(name)\n        @columns_hash.delete name.to_s\n      end",
    "comment": "remove the column +name+ from the table. remove_column(:account_id)",
    "label": "",
    "id": "2076"
  },
  {
    "raw_code": "def index(column_name, **options)\n        indexes << [column_name, options]\n      end",
    "comment": "Adds index options to the indexes hash, keyed by column name This is primarily used to track indexes that need to be created after the table  index(:account_id, name: 'index_projects_on_account_id')",
    "label": "",
    "id": "2077"
  },
  {
    "raw_code": "def timestamps(**options)\n        options[:null] = false if options[:null].nil?\n\n        if !options.key?(:precision) && @conn.supports_datetime_with_precision?\n          options[:precision] = 6\n        end",
    "comment": "Appends <tt>:datetime</tt> columns <tt>:created_at</tt> and <tt>:updated_at</tt> to the table. See {connection.add_timestamps}[rdoc-ref:SchemaStatements#add_timestamps]  t.timestamps null: false",
    "label": "",
    "id": "2078"
  },
  {
    "raw_code": "def references(*args, **options)\n        args.each do |ref_name|\n          ReferenceDefinition.new(ref_name, **options).add_to(self)\n        end",
    "comment": "Adds a reference.  t.references(:user) t.belongs_to(:supplier, foreign_key: true) t.belongs_to(:supplier, foreign_key: true, type: :integer)  See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.",
    "label": "",
    "id": "2079"
  },
  {
    "raw_code": "def column(column_name, type, index: nil, **options)\n        raise_on_if_exist_options(options)\n        @base.add_column(name, column_name, type, **options)\n        if index\n          index_options = index.is_a?(Hash) ? index : {}\n          index(column_name, **index_options)\n        end",
    "comment": "Adds a new column to the named table.  t.column(:name, :string)  See TableDefinition#column for details of the options you can use.",
    "label": "",
    "id": "2080"
  },
  {
    "raw_code": "def column_exists?(column_name, type = nil, **options)\n        @base.column_exists?(name, column_name, type, **options)\n      end",
    "comment": "Checks to see if a column exists.  t.string(:name) unless t.column_exists?(:name, :string)  See {connection.column_exists?}[rdoc-ref:SchemaStatements#column_exists?]",
    "label": "",
    "id": "2081"
  },
  {
    "raw_code": "def index(column_name, **options)\n        raise_on_if_exist_options(options)\n        @base.add_index(name, column_name, **options)\n      end",
    "comment": "Adds a new index to the table. +column_name+ can be a single Symbol, or an Array of Symbols.  t.index(:name) t.index([:branch_id, :party_id], unique: true) t.index([:branch_id, :party_id], unique: true, name: 'by_branch_party')  See {connection.add_index}[rdoc-ref:SchemaStatements#add_index] for details of the options you can use.",
    "label": "",
    "id": "2082"
  },
  {
    "raw_code": "def index_exists?(column_name = nil, **options)\n        @base.index_exists?(name, column_name, **options)\n      end",
    "comment": "Checks to see if an index exists.  unless t.index_exists?(:branch_id) t.index(:branch_id) end  See {connection.index_exists?}[rdoc-ref:SchemaStatements#index_exists?]",
    "label": "",
    "id": "2083"
  },
  {
    "raw_code": "def rename_index(index_name, new_index_name)\n        @base.rename_index(name, index_name, new_index_name)\n      end",
    "comment": "Renames the given index on the table.  t.rename_index(:user_id, :account_id)  See {connection.rename_index}[rdoc-ref:SchemaStatements#rename_index]",
    "label": "",
    "id": "2084"
  },
  {
    "raw_code": "def timestamps(**options)\n        raise_on_if_exist_options(options)\n        @base.add_timestamps(name, **options)\n      end",
    "comment": "Adds timestamps (+created_at+ and +updated_at+) columns to the table.  t.timestamps(null: false)  See {connection.add_timestamps}[rdoc-ref:SchemaStatements#add_timestamps]",
    "label": "",
    "id": "2085"
  },
  {
    "raw_code": "def change(column_name, type, **options)\n        raise_on_if_exist_options(options)\n        @base.change_column(name, column_name, type, **options)\n      end",
    "comment": "Changes the column's definition according to the new options.  t.change(:name, :string, limit: 80) t.change(:description, :text)  See TableDefinition#column for details of the options you can use.",
    "label": "",
    "id": "2086"
  },
  {
    "raw_code": "def change_default(column_name, default_or_changes)\n        @base.change_column_default(name, column_name, default_or_changes)\n      end",
    "comment": "Sets a new default value for a column.  t.change_default(:qualification, 'new') t.change_default(:authorized, 1) t.change_default(:status, from: nil, to: \"draft\")  See {connection.change_column_default}[rdoc-ref:SchemaStatements#change_column_default]",
    "label": "",
    "id": "2087"
  },
  {
    "raw_code": "def change_null(column_name, null, default = nil)\n        @base.change_column_null(name, column_name, null, default)\n      end",
    "comment": "Sets or removes a NOT NULL constraint on a column.  t.change_null(:qualification, true) t.change_null(:qualification, false, 0)  See {connection.change_column_null}[rdoc-ref:SchemaStatements#change_column_null]",
    "label": "",
    "id": "2088"
  },
  {
    "raw_code": "def remove(*column_names, **options)\n        raise_on_if_exist_options(options)\n        @base.remove_columns(name, *column_names, **options)\n      end",
    "comment": "Removes the column(s) from the table definition.  t.remove(:qualification) t.remove(:qualification, :experience)  See {connection.remove_columns}[rdoc-ref:SchemaStatements#remove_columns]",
    "label": "",
    "id": "2089"
  },
  {
    "raw_code": "def remove_index(column_name = nil, **options)\n        raise_on_if_exist_options(options)\n        @base.remove_index(name, column_name, **options)\n      end",
    "comment": "Removes the given index from the table.  t.remove_index(:branch_id) t.remove_index(column: [:branch_id, :party_id]) t.remove_index(name: :by_branch_party) t.remove_index(:branch_id, name: :by_branch_party)  See {connection.remove_index}[rdoc-ref:SchemaStatements#remove_index]",
    "label": "",
    "id": "2090"
  },
  {
    "raw_code": "def remove_timestamps(**options)\n        @base.remove_timestamps(name, **options)\n      end",
    "comment": "Removes the timestamp columns (+created_at+ and +updated_at+) from the table.  t.remove_timestamps  See {connection.remove_timestamps}[rdoc-ref:SchemaStatements#remove_timestamps]",
    "label": "",
    "id": "2091"
  },
  {
    "raw_code": "def rename(column_name, new_column_name)\n        @base.rename_column(name, column_name, new_column_name)\n      end",
    "comment": "Renames a column.  t.rename(:description, :name)  See {connection.rename_column}[rdoc-ref:SchemaStatements#rename_column]",
    "label": "",
    "id": "2092"
  },
  {
    "raw_code": "def references(*args, **options)\n        raise_on_if_exist_options(options)\n        args.each do |ref_name|\n          @base.add_reference(name, ref_name, **options)\n        end",
    "comment": "Adds a reference.  t.references(:user) t.belongs_to(:supplier, foreign_key: true)  See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.",
    "label": "",
    "id": "2093"
  },
  {
    "raw_code": "def remove_references(*args, **options)\n        raise_on_if_exist_options(options)\n        args.each do |ref_name|\n          @base.remove_reference(name, ref_name, **options)\n        end",
    "comment": "Removes a reference. Optionally removes a +type+ column.  t.remove_references(:user) t.remove_belongs_to(:supplier, polymorphic: true)  See {connection.remove_reference}[rdoc-ref:SchemaStatements#remove_reference]",
    "label": "",
    "id": "2094"
  },
  {
    "raw_code": "def foreign_key(*args, **options)\n        raise_on_if_exist_options(options)\n        @base.add_foreign_key(name, *args, **options)\n      end",
    "comment": "Adds a foreign key to the table using a supplied table name.  t.foreign_key(:authors) t.foreign_key(:authors, column: :author_id, primary_key: \"id\")  See {connection.add_foreign_key}[rdoc-ref:SchemaStatements#add_foreign_key]",
    "label": "",
    "id": "2095"
  },
  {
    "raw_code": "def remove_foreign_key(*args, **options)\n        raise_on_if_exist_options(options)\n        @base.remove_foreign_key(name, *args, **options)\n      end",
    "comment": "Removes the given foreign key from the table.  t.remove_foreign_key(:authors) t.remove_foreign_key(column: :author_id)  See {connection.remove_foreign_key}[rdoc-ref:SchemaStatements#remove_foreign_key]",
    "label": "",
    "id": "2096"
  },
  {
    "raw_code": "def foreign_key_exists?(*args, **options)\n        @base.foreign_key_exists?(name, *args, **options)\n      end",
    "comment": "Checks to see if a foreign key exists.  t.foreign_key(:authors) unless t.foreign_key_exists?(:authors)  See {connection.foreign_key_exists?}[rdoc-ref:SchemaStatements#foreign_key_exists?]",
    "label": "",
    "id": "2097"
  },
  {
    "raw_code": "def check_constraint(*args, **options)\n        @base.add_check_constraint(name, *args, **options)\n      end",
    "comment": "Adds a check constraint.  t.check_constraint(\"price > 0\", name: \"price_check\")  See {connection.add_check_constraint}[rdoc-ref:SchemaStatements#add_check_constraint]",
    "label": "",
    "id": "2098"
  },
  {
    "raw_code": "def remove_check_constraint(*args, **options)\n        @base.remove_check_constraint(name, *args, **options)\n      end",
    "comment": "Removes the given check constraint from the table.  t.remove_check_constraint(name: \"price_check\")  See {connection.remove_check_constraint}[rdoc-ref:SchemaStatements#remove_check_constraint]",
    "label": "",
    "id": "2099"
  },
  {
    "raw_code": "def check_constraint_exists?(*args, **options)\n        @base.check_constraint_exists?(name, *args, **options)\n      end",
    "comment": "Checks if a check_constraint exists on a table.  unless t.check_constraint_exists?(name: \"price_check\") t.check_constraint(\"price > 0\", name: \"price_check\") end  See {connection.check_constraint_exists?}[rdoc-ref:SchemaStatements#check_constraint_exists?]",
    "label": "",
    "id": "2100"
  },
  {
    "raw_code": "def native_database_types\n        {}\n      end",
    "comment": "Returns a hash of mappings from the abstract data types to the native database types. See TableDefinition#column for details on the recognized abstract data types.",
    "label": "",
    "id": "2101"
  },
  {
    "raw_code": "def table_comment(table_name)\n        nil\n      end",
    "comment": "Returns the table comment that's stored in database metadata.",
    "label": "",
    "id": "2102"
  },
  {
    "raw_code": "def table_alias_for(table_name)\n        table_name[0...table_alias_length].tr(\".\", \"_\")\n      end",
    "comment": "Truncates a table alias according to the limits of the current adapter.",
    "label": "",
    "id": "2103"
  },
  {
    "raw_code": "def data_sources\n        query_values(data_source_sql, \"SCHEMA\")\n      rescue NotImplementedError\n        tables | views\n      end",
    "comment": "Returns the relation names usable to back Active Record models. For most adapters this means all #tables and #views.",
    "label": "",
    "id": "2104"
  },
  {
    "raw_code": "def data_source_exists?(name)\n        query_values(data_source_sql(name), \"SCHEMA\").any? if name.present?\n      rescue NotImplementedError\n        data_sources.include?(name.to_s)\n      end",
    "comment": "Checks to see if the data source +name+ exists on the database.  data_source_exists?(:ebooks) ",
    "label": "",
    "id": "2105"
  },
  {
    "raw_code": "def tables\n        query_values(data_source_sql(type: \"BASE TABLE\"), \"SCHEMA\")\n      end",
    "comment": "Returns an array of table names defined in the database.",
    "label": "",
    "id": "2106"
  },
  {
    "raw_code": "def table_exists?(table_name)\n        query_values(data_source_sql(table_name, type: \"BASE TABLE\"), \"SCHEMA\").any? if table_name.present?\n      rescue NotImplementedError\n        tables.include?(table_name.to_s)\n      end",
    "comment": "Checks to see if the table +table_name+ exists on the database.  table_exists?(:developers) ",
    "label": "",
    "id": "2107"
  },
  {
    "raw_code": "def views\n        query_values(data_source_sql(type: \"VIEW\"), \"SCHEMA\")\n      end",
    "comment": "Returns an array of view names defined in the database.",
    "label": "",
    "id": "2108"
  },
  {
    "raw_code": "def view_exists?(view_name)\n        query_values(data_source_sql(view_name, type: \"VIEW\"), \"SCHEMA\").any? if view_name.present?\n      rescue NotImplementedError\n        views.include?(view_name.to_s)\n      end",
    "comment": "Checks to see if the view +view_name+ exists on the database.  view_exists?(:ebooks) ",
    "label": "",
    "id": "2109"
  },
  {
    "raw_code": "def indexes(table_name)\n        raise NotImplementedError, \"#indexes is not implemented\"\n      end",
    "comment": "Returns an array of indexes for the given table.",
    "label": "",
    "id": "2110"
  },
  {
    "raw_code": "def index_exists?(table_name, column_name = nil, **options)\n        indexes(table_name).any? { |i| i.defined_for?(column_name, **options) }\n      end",
    "comment": "Checks to see if an index exists on a table for a given index definition.  # Check an index exists index_exists?(:suppliers, :company_id)  # Check an index on multiple columns exists index_exists?(:suppliers, [:company_id, :company_type])  # Check a unique index exists index_exists?(:suppliers, :company_id, unique: true)  # Check an index with a custom name exists index_exists?(:suppliers, :company_id, name: \"idx_company_id\")  # Check a valid index exists (PostgreSQL only) index_exists?(:suppliers, :company_id, valid: true) ",
    "label": "",
    "id": "2111"
  },
  {
    "raw_code": "def columns(table_name)\n        table_name = table_name.to_s\n        definitions = column_definitions(table_name)\n        definitions.map do |field|\n          new_column_from_field(table_name, field, definitions)\n        end",
    "comment": "Returns an array of +Column+ objects for the table specified by +table_name+.",
    "label": "",
    "id": "2112"
  },
  {
    "raw_code": "def column_exists?(table_name, column_name, type = nil, **options)\n        column_name = column_name.to_s\n        checks = []\n        checks << lambda { |c| c.name == column_name }\n        checks << lambda { |c| c.type == type.to_sym rescue nil } if type\n        column_options_keys.each do |attr|\n          checks << lambda { |c| c.send(attr) == options[attr] } if options.key?(attr)\n        end",
    "comment": "Checks to see if a column exists in a given table.  # Check a column exists column_exists?(:suppliers, :name)  # Check a column exists of a particular type # # This works for standard non-casted types (eg. string) but is unreliable # for types that may get cast to something else (eg. char, bigint). column_exists?(:suppliers, :name, :string)  # Check a column exists with a specific definition column_exists?(:suppliers, :name, :string, limit: 100) column_exists?(:suppliers, :name, :string, default: 'default') column_exists?(:suppliers, :name, :string, null: false) column_exists?(:suppliers, :tax, :decimal, precision: 8, scale: 2) ",
    "label": "",
    "id": "2113"
  },
  {
    "raw_code": "def primary_key(table_name)\n        pk = primary_keys(table_name)\n        pk = pk.first unless pk.size > 1\n        pk\n      end",
    "comment": "Returns just a table's primary key",
    "label": "",
    "id": "2114"
  },
  {
    "raw_code": "def create_table(table_name, id: :primary_key, primary_key: nil, force: nil, **options, &block)\n        validate_create_table_options!(options)\n        validate_table_length!(table_name) unless options[:_uses_legacy_table_name]\n\n        if force && options.key?(:if_not_exists)\n          raise ArgumentError, \"Options `:force` and `:if_not_exists` cannot be used simultaneously.\"\n        end",
    "comment": "Creates a new table with the name +table_name+. +table_name+ may either be a String or a Symbol.  There are two ways to work with #create_table. You can use the block form or the regular form, like this:  === Block form  # create_table() passes a TableDefinition object to the block. # This form will not only create the table, but also columns for the # table.  create_table(:suppliers) do |t| t.column :name, :string, limit: 60 # Other fields here end  === Block form, with shorthand  # You can also use the column types as method calls, rather than calling the column method. create_table(:suppliers) do |t| t.string :name, limit: 60 # Other fields here end  === Regular form  # Creates a table called 'suppliers' with no columns. create_table(:suppliers) # Add a column to 'suppliers'. add_column(:suppliers, :name, :string, {limit: 60})  The +options+ hash can include the following keys: [<tt>:id</tt>] Whether to automatically add a primary key column. Defaults to true. Join tables for {ActiveRecord::Base.has_and_belongs_to_many}[rdoc-ref:Associations::ClassMethods#has_and_belongs_to_many] should set it to false.  A Symbol can be used to specify the type of the generated primary key column.  A Hash can be used to specify the generated primary key column creation options. See {add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column] for available options. [<tt>:primary_key</tt>] The name of the primary key, if one is to be added automatically. Defaults to +id+. If <tt>:id</tt> is false, then this option is ignored.  If an array is passed, a composite primary key will be created.  Note that Active Record models will automatically detect their primary key. This can be avoided by using {self.primary_key=}[rdoc-ref:AttributeMethods::PrimaryKey::ClassMethods#primary_key=] on the model to define the key explicitly.  [<tt>:options</tt>] Any extra options you want appended to the table definition. [<tt>:temporary</tt>] Make a temporary table. [<tt>:force</tt>] Set to true to drop the table before creating it. Set to +:cascade+ to drop dependent objects as well. Defaults to false. [<tt>:if_not_exists</tt>] Set to true to avoid raising an error when the table already exists. Defaults to false. [<tt>:as</tt>] SQL to use to generate the table. When this option is used, the block is ignored, as are the <tt>:id</tt> and <tt>:primary_key</tt> options.  ====== Add a backend specific option to the generated SQL (MySQL)  create_table(:suppliers, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8mb4')  generates:  CREATE TABLE suppliers ( id bigint auto_increment PRIMARY KEY ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4  ====== Rename the primary key column  create_table(:objects, primary_key: 'guid') do |t| t.column :name, :string, limit: 80 end  generates:  CREATE TABLE objects ( guid bigint auto_increment PRIMARY KEY, name varchar(80) )  ====== Change the primary key column type  create_table(:tags, id: :string) do |t| t.column :label, :string end  generates:  CREATE TABLE tags ( id varchar PRIMARY KEY, label varchar )  ====== Create a composite primary key  create_table(:orders, primary_key: [:product_id, :client_id]) do |t| t.belongs_to :product t.belongs_to :client end  generates:  CREATE TABLE orders ( product_id bigint NOT NULL, client_id bigint NOT NULL );  ALTER TABLE ONLY \"orders\" ADD CONSTRAINT orders_pkey PRIMARY KEY (product_id, client_id);  ====== Do not add a primary key column  create_table(:categories_suppliers, id: false) do |t| t.column :category_id, :bigint t.column :supplier_id, :bigint end  generates:  CREATE TABLE categories_suppliers ( category_id bigint, supplier_id bigint )  ====== Create a temporary table based on a query  create_table(:long_query, temporary: true, as: \"SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id\")  generates:  CREATE TEMPORARY TABLE long_query AS SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id  See also TableDefinition#column for details on how to create columns.",
    "label": "",
    "id": "2115"
  },
  {
    "raw_code": "def build_create_table_definition(table_name, id: :primary_key, primary_key: nil, force: nil, **options)\n        table_definition = create_table_definition(table_name, **options.extract!(*valid_table_definition_options, :_skip_validate_options))\n        table_definition.set_primary_key(table_name, id, primary_key, **options.extract!(*valid_primary_key_options, :_skip_validate_options))\n\n        yield table_definition if block_given?\n\n        table_definition\n      end",
    "comment": "Returns a TableDefinition object containing information about the table that would be created if the same arguments were passed to #create_table. See #create_table for information about passing a +table_name+, and other additional options that can be passed.",
    "label": "",
    "id": "2116"
  },
  {
    "raw_code": "def create_join_table(table_1, table_2, column_options: {}, **options)\n        join_table_name = find_join_table_name(table_1, table_2, options)\n\n        column_options.reverse_merge!(null: false, index: false)\n\n        t1_ref, t2_ref = [table_1, table_2].map { |t| reference_name_for_table(t) }\n\n        create_table(join_table_name, **options.merge!(id: false)) do |td|\n          td.references t1_ref, **column_options\n          td.references t2_ref, **column_options\n          yield td if block_given?\n        end",
    "comment": "Creates a new join table with the name created using the lexical order of the first two arguments. These arguments can be a String or a Symbol.  # Creates a table called 'assemblies_parts' with no id. create_join_table(:assemblies, :parts)  # Creates a table called 'paper_boxes_papers' with no id. create_join_table('papers', 'paper_boxes')  A duplicate prefix is combined into a single prefix. This is useful for namespaced models like Music::Artist and Music::Record:  # Creates a table called 'music_artists_records' with no id. create_join_table('music_artists', 'music_records')  See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use in +column_options+. +column_options+ will be applied to both columns.  You can pass an +options+ hash which can include the following keys: [<tt>:table_name</tt>] Sets the table name, overriding the default. [<tt>:options</tt>] Any extra options you want appended to the table definition. [<tt>:temporary</tt>] Make a temporary table. [<tt>:force</tt>] Set to true to drop the table before creating it. Defaults to false.  Note that #create_join_table does not create any indices by default; you can use its block form to do so yourself:  create_join_table :products, :categories do |t| t.index :product_id t.index :category_id end  ====== Add foreign keys with delete cascade  create_join_table(:assemblies, :parts, column_options: { foreign_key: { on_delete: :cascade } })  generates:  CREATE TABLE assemblies_parts ( assembly_id bigint NOT NULL, part_id bigint NOT NULL, CONSTRAINT fk_rails_0d8a572d89 FOREIGN KEY (\"assembly_id\") REFERENCES \"assemblies\" (\"id\") ON DELETE CASCADE, CONSTRAINT fk_rails_ec7b48402b FOREIGN KEY (\"part_id\") REFERENCES \"parts\" (\"id\") ON DELETE CASCADE )  ====== Add a backend specific option to the generated SQL (MySQL)  create_join_table(:assemblies, :parts, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8')  generates:  CREATE TABLE assemblies_parts ( assembly_id bigint NOT NULL, part_id bigint NOT NULL, ) ENGINE=InnoDB DEFAULT CHARSET=utf8 ",
    "label": "",
    "id": "2117"
  },
  {
    "raw_code": "def build_create_join_table_definition(table_1, table_2, column_options: {}, **options) # :nodoc:\n        join_table_name = find_join_table_name(table_1, table_2, options)\n        column_options.reverse_merge!(null: false, index: false)\n\n        t1_ref, t2_ref = [table_1, table_2].map { |t| reference_name_for_table(t) }\n\n        build_create_table_definition(join_table_name, **options.merge!(id: false)) do |td|\n          td.references t1_ref, **column_options\n          td.references t2_ref, **column_options\n          yield td if block_given?\n        end",
    "comment": "Builds a TableDefinition object for a join table.  This definition object contains information about the table that would be created if the same arguments were passed to #create_join_table. See #create_join_table for information about what arguments should be passed.",
    "label": "",
    "id": "2118"
  },
  {
    "raw_code": "def drop_join_table(table_1, table_2, **options)\n        join_table_name = find_join_table_name(table_1, table_2, options)\n        drop_table(join_table_name, **options)\n      end",
    "comment": "Drops the join table specified by the given arguments. See #create_join_table and #drop_table for details.  Although this command ignores the block if one is given, it can be helpful to provide one in a migration's +change+ method so it can be reverted. In that case, the block will be used by #create_join_table.",
    "label": "",
    "id": "2119"
  },
  {
    "raw_code": "def change_table(table_name, base = self, **options)\n        if supports_bulk_alter? && options[:bulk]\n          recorder = ActiveRecord::Migration::CommandRecorder.new(self)\n          yield update_table_definition(table_name, recorder)\n          bulk_change_table(table_name, recorder.commands)\n        else\n          yield update_table_definition(table_name, base)\n        end",
    "comment": "A block for changing columns in +table+.  # change_table() yields a Table instance change_table(:suppliers) do |t| t.column :name, :string, limit: 60 # Other column alterations here end  The +options+ hash can include the following keys: [<tt>:bulk</tt>] Set this to true to make this a bulk alter query, such as  ALTER TABLE `users` ADD COLUMN age INT, ADD COLUMN birthdate DATETIME ...  Defaults to false.  Only supported on the MySQL and PostgreSQL adapter, ignored elsewhere.  ====== Add a column  change_table(:suppliers) do |t| t.column :name, :string, limit: 60 end  ====== Change type of a column  change_table(:suppliers) do |t| t.change :metadata, :json end  ====== Add 2 integer columns  change_table(:suppliers) do |t| t.integer :width, :height, null: false, default: 0 end  ====== Add created_at/updated_at columns  change_table(:suppliers) do |t| t.timestamps end  ====== Add a foreign key column  change_table(:suppliers) do |t| t.references :company end  Creates a <tt>company_id(bigint)</tt> column.  ====== Add a polymorphic foreign key column  change_table(:suppliers) do |t| t.belongs_to :company, polymorphic: true end  Creates <tt>company_type(varchar)</tt> and <tt>company_id(bigint)</tt> columns.  ====== Remove a column  change_table(:suppliers) do |t| t.remove :company end  ====== Remove several columns  change_table(:suppliers) do |t| t.remove :company_id t.remove :width, :height end  ====== Remove an index  change_table(:suppliers) do |t| t.remove_index :company_id end  See also Table for details on all of the various column transformations.",
    "label": "",
    "id": "2120"
  },
  {
    "raw_code": "def rename_table(table_name, new_name, **)\n        raise NotImplementedError, \"rename_table is not implemented\"\n      end",
    "comment": "Renames a table.  rename_table('octopuses', 'octopi') ",
    "label": "",
    "id": "2121"
  },
  {
    "raw_code": "def drop_table(*table_names, **options)\n        table_names.each do |table_name|\n          schema_cache.clear_data_source_cache!(table_name.to_s)\n          execute \"DROP TABLE#{' IF EXISTS' if options[:if_exists]} #{quote_table_name(table_name)}\"\n        end",
    "comment": "Drops a table or tables from the database.  [<tt>:force</tt>] Set to +:cascade+ to drop dependent objects as well. Defaults to false. [<tt>:if_exists</tt>] Set to +true+ to only drop the table if it exists. Defaults to false.  Although this command ignores most +options+ and the block if one is given, it can be helpful to provide these in a migration's +change+ method so it can be reverted. In that case, +options+ and the block will be used by #create_table except if you provide more than one table which is not supported.",
    "label": "",
    "id": "2122"
  },
  {
    "raw_code": "def add_column(table_name, column_name, type, **options)\n        add_column_def = build_add_column_definition(table_name, column_name, type, **options)\n        return unless add_column_def\n\n        execute schema_creation.accept(add_column_def)\n      end",
    "comment": "Add a new +type+ column named +column_name+ to +table_name+.  See {ActiveRecord::ConnectionAdapters::TableDefinition.column}[rdoc-ref:ActiveRecord::ConnectionAdapters::TableDefinition#column].  The +type+ parameter is normally one of the migration's native types, which is one of the following: <tt>:primary_key</tt>, <tt>:string</tt>, <tt>:text</tt>, <tt>:integer</tt>, <tt>:bigint</tt>, <tt>:float</tt>, <tt>:decimal</tt>, <tt>:numeric</tt>, <tt>:datetime</tt>, <tt>:time</tt>, <tt>:date</tt>, <tt>:binary</tt>, <tt>:blob</tt>, <tt>:boolean</tt>.  You may use a type not in this list as long as it is supported by your database (for example, \"polygon\" in MySQL), but this will not be database agnostic and should usually be avoided.  Available options are (none of these exists by default): * <tt>:comment</tt> - Specifies the comment for the column. This option is ignored by some backends. * <tt>:collation</tt> - Specifies the collation for a <tt>:string</tt> or <tt>:text</tt> column. If not specified, the column will have the same collation as the table. * <tt>:default</tt> - The column's default value. Use +nil+ for +NULL+. * <tt>:limit</tt> - Requests a maximum column length. This is the number of characters for a <tt>:string</tt> column and number of bytes for <tt>:text</tt>, <tt>:binary</tt>, <tt>:blob</tt>, and <tt>:integer</tt> columns. This option is ignored by some backends. * <tt>:null</tt> - Allows or disallows +NULL+ values in the column. * <tt>:precision</tt> - Specifies the precision for the <tt>:decimal</tt>, <tt>:numeric</tt>, <tt>:datetime</tt>, and <tt>:time</tt> columns. * <tt>:scale</tt> - Specifies the scale for the <tt>:decimal</tt> and <tt>:numeric</tt> columns. * <tt>:if_not_exists</tt> - Specifies if the column already exists to not try to re-add it. This will avoid duplicate column errors.  Note: The precision is the total number of significant digits, and the scale is the number of digits that can be stored following the decimal point. For example, the number 123.45 has a precision of 5 and a scale of 2. A decimal with a precision of 5 and a scale of 2 can range from -999.99 to 999.99.  Please be aware of different RDBMS implementations behavior with <tt>:decimal</tt> columns: * The SQL standard says the default scale should be 0, <tt>:scale</tt> <= <tt>:precision</tt>, and makes no comments about the requirements of <tt>:precision</tt>. * MySQL: <tt>:precision</tt> [1..65], <tt>:scale</tt> [0..30]. Default is (10,0). * PostgreSQL: <tt>:precision</tt> [1..infinity], <tt>:scale</tt> [0..infinity]. No default. * SQLite3: No restrictions on <tt>:precision</tt> and <tt>:scale</tt>, but the maximum supported <tt>:precision</tt> is 16. No default. * Oracle: <tt>:precision</tt> [1..38], <tt>:scale</tt> [-84..127]. Default is (38,0). * SqlServer: <tt>:precision</tt> [1..38], <tt>:scale</tt> [0..38]. Default (38,0).  == Examples  add_column(:users, :picture, :binary, limit: 2.megabytes) # ALTER TABLE \"users\" ADD \"picture\" blob(2097152)  add_column(:articles, :status, :string, limit: 20, default: 'draft', null: false) # ALTER TABLE \"articles\" ADD \"status\" varchar(20) DEFAULT 'draft' NOT NULL  add_column(:answers, :bill_gates_money, :decimal, precision: 15, scale: 2) # ALTER TABLE \"answers\" ADD \"bill_gates_money\" decimal(15,2)  add_column(:measurements, :sensor_reading, :decimal, precision: 30, scale: 20) # ALTER TABLE \"measurements\" ADD \"sensor_reading\" decimal(30,20)  # While :scale defaults to zero on most databases, it # probably wouldn't hurt to include it. add_column(:measurements, :huge_integer, :decimal, precision: 30) # ALTER TABLE \"measurements\" ADD \"huge_integer\" decimal(30)  # Defines a column that stores an array of a type. add_column(:users, :skills, :text, array: true) # ALTER TABLE \"users\" ADD \"skills\" text[]  # Defines a column with a database-specific type. add_column(:shapes, :triangle, 'polygon') # ALTER TABLE \"shapes\" ADD \"triangle\" polygon  # Ignores the method call if the column exists add_column(:shapes, :triangle, 'polygon', if_not_exists: true)",
    "label": "",
    "id": "2123"
  },
  {
    "raw_code": "def build_add_column_definition(table_name, column_name, type, **options) # :nodoc:\n        return if options[:if_not_exists] == true && column_exists?(table_name, column_name)\n\n        if supports_datetime_with_precision?\n          if type == :datetime && !options.key?(:precision)\n            options[:precision] = 6\n          end",
    "comment": "Builds an AlterTable object for adding a column to a table.  This definition object contains information about the column that would be created if the same arguments were passed to #add_column. See #add_column for information about passing a +table_name+, +column_name+, +type+ and other options that can be passed.",
    "label": "",
    "id": "2124"
  },
  {
    "raw_code": "def remove_columns(table_name, *column_names, type: nil, **options)\n        if column_names.empty?\n          raise ArgumentError.new(\"You must specify at least one column name. Example: remove_columns(:people, :first_name)\")\n        end",
    "comment": "Removes the given columns from the table definition.  remove_columns(:suppliers, :qualification, :experience)  +type+ and other column options can be passed to make migration reversible.  remove_columns(:suppliers, :qualification, :experience, type: :string, null: false)",
    "label": "",
    "id": "2125"
  },
  {
    "raw_code": "def remove_column(table_name, column_name, type = nil, **options)\n        return if options[:if_exists] == true && !column_exists?(table_name, column_name)\n\n        execute \"ALTER TABLE #{quote_table_name(table_name)} #{remove_column_for_alter(table_name, column_name, type, **options)}\"\n      end",
    "comment": "Removes the column from the table definition.  remove_column(:suppliers, :qualification)  The +type+ and +options+ parameters will be ignored if present. It can be helpful to provide these in a migration's +change+ method so it can be reverted. In that case, +type+ and +options+ will be used by #add_column. Depending on the database you're using, indexes using this column may be automatically removed or modified to remove this column from the index.  If the options provided include an +if_exists+ key, it will be used to check if the column does not exist. This will silently ignore the migration rather than raising if the column was already removed.  remove_column(:suppliers, :qualification, if_exists: true)",
    "label": "",
    "id": "2126"
  },
  {
    "raw_code": "def change_column(table_name, column_name, type, **options)\n        raise NotImplementedError, \"change_column is not implemented\"\n      end",
    "comment": "Changes the column's definition according to the new options. See TableDefinition#column for details of the options you can use.  change_column(:suppliers, :name, :string, limit: 80) change_column(:accounts, :description, :text) ",
    "label": "",
    "id": "2127"
  },
  {
    "raw_code": "def change_column_default(table_name, column_name, default_or_changes)\n        raise NotImplementedError, \"change_column_default is not implemented\"\n      end",
    "comment": "Sets a new default value for a column:  change_column_default(:suppliers, :qualification, 'new') change_column_default(:accounts, :authorized, 1)  Setting the default to +nil+ effectively drops the default:  change_column_default(:users, :email, nil)  Passing a hash containing +:from+ and +:to+ will make this change reversible in migration:  change_column_default(:posts, :state, from: nil, to: \"draft\") ",
    "label": "",
    "id": "2128"
  },
  {
    "raw_code": "def build_change_column_default_definition(table_name, column_name, default_or_changes) # :nodoc:\n        raise NotImplementedError, \"build_change_column_default_definition is not implemented\"\n      end",
    "comment": "Builds a ChangeColumnDefaultDefinition object.  This definition object contains information about the column change that would occur if the same arguments were passed to #change_column_default. See #change_column_default for information about passing a +table_name+, +column_name+, +type+ and other options that can be passed.",
    "label": "",
    "id": "2129"
  },
  {
    "raw_code": "def change_column_null(table_name, column_name, null, default = nil)\n        raise NotImplementedError, \"change_column_null is not implemented\"\n      end",
    "comment": "Sets or removes a <tt>NOT NULL</tt> constraint on a column. The +null+ flag indicates whether the value can be +NULL+. For example  change_column_null(:users, :nickname, false)  says nicknames cannot be +NULL+ (adds the constraint), whereas  change_column_null(:users, :nickname, true)  allows them to be +NULL+ (drops the constraint).  The method accepts an optional fourth argument to replace existing <tt>NULL</tt>s with some other value. Use that one when enabling the constraint if needed, since otherwise those rows would not be valid.  Please note the fourth argument does not set a column's default.",
    "label": "",
    "id": "2130"
  },
  {
    "raw_code": "def rename_column(table_name, column_name, new_column_name)\n        raise NotImplementedError, \"rename_column is not implemented\"\n      end",
    "comment": "Renames a column.  rename_column(:suppliers, :description, :name) ",
    "label": "",
    "id": "2131"
  },
  {
    "raw_code": "def add_index(table_name, column_name, **options)\n        create_index = build_create_index_definition(table_name, column_name, **options)\n        execute schema_creation.accept(create_index)\n      end",
    "comment": "Adds a new index to the table. +column_name+ can be a single Symbol, or an Array of Symbols.  The index will be named after the table and the column name(s), unless you pass <tt>:name</tt> as an option.  ====== Creating a simple index  add_index(:suppliers, :name)  generates:  CREATE INDEX index_suppliers_on_name ON suppliers(name)  ====== Creating a index which already exists  add_index(:suppliers, :name, if_not_exists: true)  generates:  CREATE INDEX IF NOT EXISTS index_suppliers_on_name ON suppliers(name)  Note: Not supported by MySQL.  ====== Creating a unique index  add_index(:accounts, [:branch_id, :party_id], unique: true)  generates:  CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id)  ====== Creating a named index  add_index(:accounts, [:branch_id, :party_id], unique: true, name: 'by_branch_party')  generates:  CREATE UNIQUE INDEX by_branch_party ON accounts(branch_id, party_id)  ====== Creating an index with specific key length  add_index(:accounts, :name, name: 'by_name', length: 10)  generates:  CREATE INDEX by_name ON accounts(name(10))  ====== Creating an index with specific key lengths for multiple keys  add_index(:accounts, [:name, :surname], name: 'by_name_surname', length: {name: 10, surname: 15})  generates:  CREATE INDEX by_name_surname ON accounts(name(10), surname(15))  Note: only supported by MySQL  ====== Creating an index with a sort order (desc or asc, asc is the default)  add_index(:accounts, [:branch_id, :party_id, :surname], name: 'by_branch_desc_party', order: {branch_id: :desc, party_id: :asc})  generates:  CREATE INDEX by_branch_desc_party ON accounts(branch_id DESC, party_id ASC, surname)  Note: MySQL only supports index order from 8.0.1 onwards (earlier versions accepted the syntax but ignored it).  ====== Creating a partial index  add_index(:accounts, [:branch_id, :party_id], unique: true, where: \"active\")  generates:  CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id) WHERE active  Note: Partial indexes are only supported for PostgreSQL and SQLite.  ====== Creating an index that includes additional columns  add_index(:accounts, :branch_id,  include: :party_id)  generates:  CREATE INDEX index_accounts_on_branch_id ON accounts USING btree(branch_id) INCLUDE (party_id)  Note: only supported by PostgreSQL.  ====== Creating an index where NULLs are treated equally  add_index(:people, :last_name, nulls_not_distinct: true)  generates:  CREATE INDEX index_people_on_last_name ON people (last_name) NULLS NOT DISTINCT  Note: only supported by PostgreSQL version 15.0.0 and greater.  ====== Creating an index with a specific method  add_index(:developers, :name, using: 'btree')  generates:  CREATE INDEX index_developers_on_name ON developers USING btree (name) -- PostgreSQL CREATE INDEX index_developers_on_name USING btree ON developers (name) -- MySQL  Note: only supported by PostgreSQL and MySQL  ====== Creating an index with a specific operator class  add_index(:developers, :name, using: 'gist', opclass: :gist_trgm_ops) # CREATE INDEX developers_on_name ON developers USING gist (name gist_trgm_ops) -- PostgreSQL  add_index(:developers, [:name, :city], using: 'gist', opclass: { city: :gist_trgm_ops }) # CREATE INDEX developers_on_name_and_city ON developers USING gist (name, city gist_trgm_ops) -- PostgreSQL  add_index(:developers, [:name, :city], using: 'gist', opclass: :gist_trgm_ops) # CREATE INDEX developers_on_name_and_city ON developers USING gist (name gist_trgm_ops, city gist_trgm_ops) -- PostgreSQL  Note: only supported by PostgreSQL  ====== Creating an index with a specific type  add_index(:developers, :name, type: :fulltext)  generates:  CREATE FULLTEXT INDEX index_developers_on_name ON developers (name) -- MySQL  Note: only supported by MySQL.  ====== Creating an index with a specific algorithm  add_index(:developers, :name, algorithm: :concurrently) # CREATE INDEX CONCURRENTLY developers_on_name on developers (name) -- PostgreSQL  add_index(:developers, :name, algorithm: :inplace) # CREATE INDEX `index_developers_on_name` ON `developers` (`name`) ALGORITHM = INPLACE -- MySQL  Note: only supported by PostgreSQL and MySQL.  Concurrently adding an index is not supported in a transaction.  For more information see the {\"Transactional Migrations\" section}[rdoc-ref:Migration].  ====== Creating an index that is not used by queries  add_index(:developers, :name, enabled: false)  generates:  CREATE INDEX index_developers_on_name ON developers (name) INVISIBLE -- MySQL  CREATE INDEX index_developers_on_name ON developers (name) IGNORED -- MariaDB  Note: only supported by MySQL version 8.0.0 and greater, and MariaDB version 10.6.0 and greater. ",
    "label": "",
    "id": "2132"
  },
  {
    "raw_code": "def build_create_index_definition(table_name, column_name, **options) # :nodoc:\n        index, algorithm, if_not_exists = add_index_options(table_name, column_name, **options)\n        CreateIndexDefinition.new(index, algorithm, if_not_exists)\n      end",
    "comment": "Builds a CreateIndexDefinition object.  This definition object contains information about the index that would be created if the same arguments were passed to #add_index. See #add_index for information about passing a +table_name+, +column_name+, and other additional options that can be passed.",
    "label": "",
    "id": "2133"
  },
  {
    "raw_code": "def remove_index(table_name, column_name = nil, **options)\n        return if options[:if_exists] && !index_exists?(table_name, column_name, **options)\n\n        index_name = index_name_for_remove(table_name, column_name, options)\n\n        execute \"DROP INDEX #{quote_column_name(index_name)} ON #{quote_table_name(table_name)}\"\n      end",
    "comment": "Removes the given index from the table.  Removes the index on +branch_id+ in the +accounts+ table if exactly one such index exists.  remove_index :accounts, :branch_id  Removes the index on +branch_id+ in the +accounts+ table if exactly one such index exists.  remove_index :accounts, column: :branch_id  Removes the index on +branch_id+ and +party_id+ in the +accounts+ table if exactly one such index exists.  remove_index :accounts, column: [:branch_id, :party_id]  Removes the index named +by_branch_party+ in the +accounts+ table.  remove_index :accounts, name: :by_branch_party  Removes the index on +branch_id+ named +by_branch_party+ in the +accounts+ table.  remove_index :accounts, :branch_id, name: :by_branch_party  Checks if the index exists before trying to remove it. Will silently ignore indexes that don't exist.  remove_index :accounts, if_exists: true  Removes the index named +by_branch_party+ in the +accounts+ table +concurrently+.  remove_index :accounts, name: :by_branch_party, algorithm: :concurrently  Note: only supported by PostgreSQL.  Concurrently removing an index is not supported in a transaction.  For more information see the {\"Transactional Migrations\" section}[rdoc-ref:Migration].",
    "label": "",
    "id": "2134"
  },
  {
    "raw_code": "def rename_index(table_name, old_name, new_name)\n        old_name = old_name.to_s\n        new_name = new_name.to_s\n        validate_index_length!(table_name, new_name)\n\n        # this is a naive implementation; some DBs may support this more efficiently (PostgreSQL, for instance)\n        old_index_def = indexes(table_name).detect { |i| i.name == old_name }\n        return unless old_index_def\n        add_index(table_name, old_index_def.columns, name: new_name, unique: old_index_def.unique)\n        remove_index(table_name, name: old_name)\n      end",
    "comment": "Renames an index.  Rename the +index_people_on_last_name+ index to +index_users_on_last_name+:  rename_index :people, 'index_people_on_last_name', 'index_users_on_last_name' ",
    "label": "",
    "id": "2135"
  },
  {
    "raw_code": "def index_name_exists?(table_name, index_name)\n        index_name = index_name.to_s\n        indexes(table_name).detect { |i| i.name == index_name }\n      end",
    "comment": "Verifies the existence of an index with a given name.",
    "label": "",
    "id": "2136"
  },
  {
    "raw_code": "def add_reference(table_name, ref_name, **options)\n        ReferenceDefinition.new(ref_name, **options).add(table_name, self)\n      end",
    "comment": "Adds a reference. The reference column is a bigint by default, the <tt>:type</tt> option can be used to specify a different type. Optionally adds a +_type+ column, if <tt>:polymorphic</tt> option is provided.  The +options+ hash can include the following keys: [<tt>:type</tt>] The reference column type. Defaults to +:bigint+. [<tt>:index</tt>] Add an appropriate index. Defaults to true. See #add_index for usage of this option. [<tt>:foreign_key</tt>] Add an appropriate foreign key constraint. Defaults to false, pass true to add. In case the join table can't be inferred from the association pass <tt>:to_table</tt> with the appropriate table name. [<tt>:polymorphic</tt>] Whether an additional +_type+ column should be added. Defaults to false. [<tt>:null</tt>] Whether the column allows nulls. Defaults to true.  ====== Create a user_id bigint column without an index  add_reference(:products, :user, index: false)  ====== Create a user_id string column  add_reference(:products, :user, type: :string)  ====== Create supplier_id, supplier_type columns  add_reference(:products, :supplier, polymorphic: true)  ====== Create a supplier_id column with a unique index  add_reference(:products, :supplier, index: { unique: true })  ====== Create a supplier_id column with a named index  add_reference(:products, :supplier, index: { name: \"my_supplier_index\" })  ====== Create a supplier_id column and appropriate foreign key  add_reference(:products, :supplier, foreign_key: true)  ====== Create a supplier_id column and a foreign key to the firms table  add_reference(:products, :supplier, foreign_key: { to_table: :firms }) ",
    "label": "",
    "id": "2137"
  },
  {
    "raw_code": "def remove_reference(table_name, ref_name, foreign_key: false, polymorphic: false, **options)\n        conditional_options = options.slice(:if_exists, :if_not_exists)\n\n        if foreign_key\n          reference_name = Base.pluralize_table_names ? ref_name.to_s.pluralize : ref_name\n          if foreign_key.is_a?(Hash)\n            foreign_key_options = foreign_key.merge(conditional_options)\n          else\n            foreign_key_options = { to_table: reference_name, **conditional_options }\n          end",
    "comment": "Removes the reference(s). Also removes a +type+ column if one exists.  ====== Remove the reference  remove_reference(:products, :user, index: false)  ====== Remove polymorphic reference  remove_reference(:products, :supplier, polymorphic: true)  ====== Remove the reference with a foreign key  remove_reference(:products, :user, foreign_key: true) ",
    "label": "",
    "id": "2138"
  },
  {
    "raw_code": "def foreign_keys(table_name)\n        raise NotImplementedError, \"foreign_keys is not implemented\"\n      end",
    "comment": "Returns an array of foreign keys for the given table. The foreign keys are represented as ForeignKeyDefinition objects.",
    "label": "",
    "id": "2139"
  },
  {
    "raw_code": "def add_foreign_key(from_table, to_table, **options)\n        return unless use_foreign_keys?\n\n        options = foreign_key_options(from_table, to_table, options)\n        return if options[:if_not_exists] == true && foreign_key_exists?(from_table, to_table, **options.slice(:column, :primary_key))\n\n        at = create_alter_table from_table\n        at.add_foreign_key to_table, options\n\n        execute schema_creation.accept(at)\n      end",
    "comment": "Adds a new foreign key. +from_table+ is the table with the key column, +to_table+ contains the referenced primary key.  The foreign key will be named after the following pattern: <tt>fk_rails_<identifier></tt>. +identifier+ is a 10 character long string which is deterministically generated from the +from_table+ and +column+. A custom name can be specified with the <tt>:name</tt> option.  ====== Creating a simple foreign key  add_foreign_key :articles, :authors  generates:  ALTER TABLE \"articles\" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY (\"author_id\") REFERENCES \"authors\" (\"id\")  ====== Creating a foreign key, ignoring method call if the foreign key exists  add_foreign_key(:articles, :authors, if_not_exists: true)  ====== Creating a foreign key on a specific column  add_foreign_key :articles, :users, column: :author_id, primary_key: \"lng_id\"  generates:  ALTER TABLE \"articles\" ADD CONSTRAINT fk_rails_58ca3d3a82 FOREIGN KEY (\"author_id\") REFERENCES \"users\" (\"lng_id\")  ====== Creating a composite foreign key  Assuming \"carts\" table has \"(shop_id, user_id)\" as a primary key.  add_foreign_key :orders, :carts, primary_key: [:shop_id, :user_id]  generates:  ALTER TABLE \"orders\" ADD CONSTRAINT fk_rails_6f5e4cb3a4 FOREIGN KEY (\"cart_shop_id\", \"cart_user_id\") REFERENCES \"carts\" (\"shop_id\", \"user_id\")  ====== Creating a cascading foreign key  add_foreign_key :articles, :authors, on_delete: :cascade  generates:  ALTER TABLE \"articles\" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY (\"author_id\") REFERENCES \"authors\" (\"id\") ON DELETE CASCADE  The +options+ hash can include the following keys: [<tt>:column</tt>] The foreign key column name on +from_table+. Defaults to <tt>to_table.singularize + \"_id\"</tt>. Pass an array to create a composite foreign key. [<tt>:primary_key</tt>] The primary key column name on +to_table+. Defaults to +id+. Pass an array to create a composite foreign key. [<tt>:name</tt>] The constraint name. Defaults to <tt>fk_rails_<identifier></tt>. [<tt>:on_delete</tt>] Action that happens <tt>ON DELETE</tt>. Valid values are +:nullify+, +:cascade+, and +:restrict+ [<tt>:on_update</tt>] Action that happens <tt>ON UPDATE</tt>. Valid values are +:nullify+, +:cascade+, and +:restrict+ [<tt>:if_not_exists</tt>] Specifies if the foreign key already exists to not try to re-add it. This will avoid duplicate column errors. [<tt>:validate</tt>] (PostgreSQL only) Specify whether or not the constraint should be validated. Defaults to +true+. [<tt>:deferrable</tt>] (PostgreSQL only) Specify whether or not the foreign key should be deferrable. Valid values are booleans or +:deferred+ or +:immediate+ to specify the default behavior. Defaults to +false+.",
    "label": "",
    "id": "2140"
  },
  {
    "raw_code": "def remove_foreign_key(from_table, to_table = nil, **options)\n        return unless use_foreign_keys?\n        return if options.delete(:if_exists) == true && !foreign_key_exists?(from_table, to_table, **options.slice(:column))\n\n        fk_name_to_delete = foreign_key_for!(from_table, to_table: to_table, **options).name\n\n        at = create_alter_table from_table\n        at.drop_foreign_key fk_name_to_delete\n\n        execute schema_creation.accept(at)\n      end",
    "comment": "Removes the given foreign key from the table. Any option parameters provided will be used to re-add the foreign key in case of a migration rollback. It is recommended that you provide any options used when creating the foreign key so that the migration can be reverted properly.  Removes the foreign key on +accounts.branch_id+.  remove_foreign_key :accounts, :branches  Removes the foreign key on +accounts.owner_id+.  remove_foreign_key :accounts, column: :owner_id  Removes the foreign key on +accounts.owner_id+.  remove_foreign_key :accounts, to_table: :owners  Removes the foreign key named +special_fk_name+ on the +accounts+ table.  remove_foreign_key :accounts, name: :special_fk_name  Checks if the foreign key exists before trying to remove it. Will silently ignore indexes that don't exist.  remove_foreign_key :accounts, :branches, if_exists: true  The +options+ hash accepts the same keys as SchemaStatements#add_foreign_key with an addition of [<tt>:to_table</tt>] The name of the table that contains the referenced primary key.",
    "label": "",
    "id": "2141"
  },
  {
    "raw_code": "def foreign_key_exists?(from_table, to_table = nil, **options)\n        foreign_key_for(from_table, to_table: to_table, **options).present?\n      end",
    "comment": "Checks to see if a foreign key exists on a table for a given foreign key definition.  # Checks to see if a foreign key exists. foreign_key_exists?(:accounts, :branches)  # Checks to see if a foreign key on a specified column exists. foreign_key_exists?(:accounts, column: :owner_id)  # Checks to see if a foreign key with a custom name exists. foreign_key_exists?(:accounts, name: \"special_fk_name\") ",
    "label": "",
    "id": "2142"
  },
  {
    "raw_code": "def check_constraints(table_name)\n        raise NotImplementedError\n      end",
    "comment": "Returns an array of check constraints for the given table. The check constraints are represented as CheckConstraintDefinition objects.",
    "label": "",
    "id": "2143"
  },
  {
    "raw_code": "def add_check_constraint(table_name, expression, if_not_exists: false, **options)\n        return unless supports_check_constraints?\n\n        options = check_constraint_options(table_name, expression, options)\n        return if if_not_exists && check_constraint_exists?(table_name, **options)\n\n        at = create_alter_table(table_name)\n        at.add_check_constraint(expression, options)\n\n        execute schema_creation.accept(at)\n      end",
    "comment": "Adds a new check constraint to the table. +expression+ is a String representation of verifiable boolean condition.  add_check_constraint :products, \"price > 0\", name: \"price_check\"  generates:  ALTER TABLE \"products\" ADD CONSTRAINT price_check CHECK (price > 0)  The +options+ hash can include the following keys: [<tt>:name</tt>] The constraint name. Defaults to <tt>chk_rails_<identifier></tt>. [<tt>:if_not_exists</tt>] Silently ignore if the constraint already exists, rather than raise an error. [<tt>:validate</tt>] (PostgreSQL only) Specify whether or not the constraint should be validated. Defaults to +true+.",
    "label": "",
    "id": "2144"
  },
  {
    "raw_code": "def remove_check_constraint(table_name, expression = nil, if_exists: false, **options)\n        return unless supports_check_constraints?\n\n        return if if_exists && !check_constraint_exists?(table_name, **options)\n\n        chk_name_to_delete = check_constraint_for!(table_name, expression: expression, **options).name\n\n        at = create_alter_table(table_name)\n        at.drop_check_constraint(chk_name_to_delete)\n\n        execute schema_creation.accept(at)\n      end",
    "comment": "Removes the given check constraint from the table. Removing a check constraint that does not exist will raise an error.  remove_check_constraint :products, name: \"price_check\"  To silently ignore a non-existent check constraint rather than raise an error, use the +if_exists+ option.  remove_check_constraint :products, name: \"price_check\", if_exists: true  The +expression+ parameter will be ignored if present. It can be helpful to provide this in a migration's +change+ method so it can be reverted. In that case, +expression+ will be used by #add_check_constraint.",
    "label": "",
    "id": "2145"
  },
  {
    "raw_code": "def check_constraint_exists?(table_name, **options)\n        if !options.key?(:name) && !options.key?(:expression)\n          raise ArgumentError, \"At least one of :name or :expression must be supplied\"\n        end",
    "comment": "Checks to see if a check constraint exists on a table for a given check constraint definition.  check_constraint_exists?(:products, name: \"price_check\") ",
    "label": "",
    "id": "2146"
  },
  {
    "raw_code": "def columns_for_distinct(columns, orders) # :nodoc:\n        columns\n      end",
    "comment": "Given a set of columns and an ORDER BY clause, returns the columns for a SELECT DISTINCT. PostgreSQL, MySQL, and Oracle override this for custom DISTINCT syntax - they require the order columns appear in the SELECT.  columns_for_distinct(\"posts.id\", [\"posts.created_at desc\"]) ",
    "label": "",
    "id": "2147"
  },
  {
    "raw_code": "def add_timestamps(table_name, **options)\n        fragments = add_timestamps_for_alter(table_name, **options)\n        execute \"ALTER TABLE #{quote_table_name(table_name)} #{fragments.join(', ')}\"\n      end",
    "comment": "Adds timestamps (+created_at+ and +updated_at+) columns to +table_name+. Additional options (like +:null+) are forwarded to #add_column.  add_timestamps(:suppliers, null: true) ",
    "label": "",
    "id": "2148"
  },
  {
    "raw_code": "def remove_timestamps(table_name, **options)\n        remove_columns table_name, :updated_at, :created_at\n      end",
    "comment": "Removes the timestamp columns (+created_at+ and +updated_at+) from the table definition.  remove_timestamps(:suppliers) ",
    "label": "",
    "id": "2149"
  },
  {
    "raw_code": "def change_table_comment(table_name, comment_or_changes)\n        raise NotImplementedError, \"#{self.class} does not support changing table comments\"\n      end",
    "comment": "Changes the comment for a table or removes it if +nil+.  Passing a hash containing +:from+ and +:to+ will make this change reversible in migration:  change_table_comment(:posts, from: \"old_comment\", to: \"new_comment\")",
    "label": "",
    "id": "2150"
  },
  {
    "raw_code": "def change_column_comment(table_name, column_name, comment_or_changes)\n        raise NotImplementedError, \"#{self.class} does not support changing column comments\"\n      end",
    "comment": "Changes the comment for a column or removes it if +nil+.  Passing a hash containing +:from+ and +:to+ will make this change reversible in migration:  change_column_comment(:posts, :state, from: \"old_comment\", to: \"new_comment\")",
    "label": "",
    "id": "2151"
  },
  {
    "raw_code": "def enable_index(table_name, index_name)\n        raise NotImplementedError, \"#{self.class} does not support enabling indexes\"\n      end",
    "comment": "Enables an index to be used by queries.  enable_index(:users, :email)",
    "label": "",
    "id": "2152"
  },
  {
    "raw_code": "def disable_index(table_name, index_name)\n        raise NotImplementedError, \"#{self.class} does not support disabling indexes\"\n      end",
    "comment": "Prevents an index from being used by queries.  disable_index(:users, :email)",
    "label": "",
    "id": "2153"
  },
  {
    "raw_code": "def schema_creation # :nodoc:\n        SchemaCreation.new(self)\n      end",
    "comment": "Returns an instance of SchemaCreation, which can be used to visit a schema definition object and return DDL.",
    "label": "",
    "id": "2154"
  },
  {
    "raw_code": "def max_index_name_size\n        62\n      end",
    "comment": "Returns the maximum length of an index name in bytes.",
    "label": "",
    "id": "2155"
  },
  {
    "raw_code": "def add_options_for_index_columns(quoted_columns, **options)\n          if supports_index_sort_order?\n            quoted_columns = add_index_sort_order(quoted_columns, **options)\n          end",
    "comment": "Overridden by the MySQL adapter for supporting index lengths and by the PostgreSQL adapter for supporting operator classes.",
    "label": "",
    "id": "2156"
  },
  {
    "raw_code": "def expression_column_name?(column_name)\n          column_name.is_a?(String) && /\\W/.match?(column_name)\n        end",
    "comment": "Try to identify whether the given column name is an expression",
    "label": "",
    "id": "2157"
  },
  {
    "raw_code": "def isolation\n        @parent_transaction.isolation\n      end",
    "comment": "Delegates to parent transaction's isolation level",
    "label": "",
    "id": "2158"
  },
  {
    "raw_code": "def after_failure_actions(transaction, error)\n          return unless transaction.is_a?(RealTransaction)\n          return unless error.is_a?(ActiveRecord::PreparedStatementCacheExpired)\n          @connection.clear_cache!\n        end",
    "comment": "Deallocate invalidated prepared statements outside of the transaction",
    "label": "",
    "id": "2159"
  },
  {
    "raw_code": "def any_waiting?\n          synchronize do\n            @num_waiting > 0\n          end",
    "comment": "Test if any threads are currently waiting on the queue.",
    "label": "",
    "id": "2160"
  },
  {
    "raw_code": "def num_waiting\n          synchronize do\n            @num_waiting\n          end",
    "comment": "Returns the number of threads currently waiting on this queue.",
    "label": "",
    "id": "2161"
  },
  {
    "raw_code": "def add(element)\n          synchronize do\n            @queue.push element\n            @cond.signal\n          end",
    "comment": "Add +element+ to the queue.  Never blocks.",
    "label": "",
    "id": "2162"
  },
  {
    "raw_code": "def add_back(element)\n          synchronize do\n            @queue.unshift element\n            @cond.signal\n          end",
    "comment": "Add +element+ to the back of the queue.  Never blocks.",
    "label": "",
    "id": "2163"
  },
  {
    "raw_code": "def delete(element)\n          synchronize do\n            @queue.delete(element)\n          end",
    "comment": "If +element+ is in the queue, remove and return it, or +nil+.",
    "label": "",
    "id": "2164"
  },
  {
    "raw_code": "def clear\n          synchronize do\n            @queue.clear\n          end",
    "comment": "Remove all elements from the queue.",
    "label": "",
    "id": "2165"
  },
  {
    "raw_code": "def size\n          synchronize do\n            @queue.size\n          end",
    "comment": "Number of elements in the queue.",
    "label": "",
    "id": "2166"
  },
  {
    "raw_code": "def poll(timeout = nil)\n          synchronize { internal_poll(timeout) }\n        end",
    "comment": "Remove the head of the queue.  If +timeout+ is not given, remove and return the head of the queue if the number of available elements is strictly greater than the number of threads currently waiting (that is, don't jump ahead in line).  Otherwise, return +nil+.  If +timeout+ is given, block if there is no element available, waiting up to +timeout+ seconds for an element to become available.  Raises: - ActiveRecord::ConnectionTimeoutError if +timeout+ is given and no element becomes available within +timeout+ seconds,",
    "label": "",
    "id": "2167"
  },
  {
    "raw_code": "def any?\n            !@queue.empty?\n          end",
    "comment": "Test if the queue currently contains any elements.",
    "label": "",
    "id": "2168"
  },
  {
    "raw_code": "def can_remove_no_wait?\n            @queue.size > @num_waiting\n          end",
    "comment": "A thread can remove an element from the queue without waiting if and only if the number of currently available connections is strictly greater than the number of waiting threads.",
    "label": "",
    "id": "2169"
  },
  {
    "raw_code": "def remove\n            @queue.pop\n          end",
    "comment": "Removes and returns the head of the queue if possible, or +nil+.",
    "label": "",
    "id": "2170"
  },
  {
    "raw_code": "def no_wait_poll\n            remove if can_remove_no_wait?\n          end",
    "comment": "Remove and return the head of the queue if the number of available elements is strictly greater than the number of threads currently waiting.  Otherwise, return +nil+.",
    "label": "",
    "id": "2171"
  },
  {
    "raw_code": "def wait_poll(timeout)\n            @num_waiting += 1\n\n            t0 = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n            elapsed = 0\n            loop do\n              @cond.wait(timeout - elapsed)\n\n              return remove if any?\n\n              elapsed = Process.clock_gettime(Process::CLOCK_MONOTONIC) - t0\n              if elapsed >= timeout\n                msg = \"could not obtain a connection from the pool within %0.3f seconds (waited %0.3f seconds); all pooled connections were in use\" %\n                  [timeout, elapsed]\n                raise ConnectionTimeoutError, msg\n              end",
    "comment": "Waits on the queue up to +timeout+ seconds, then removes and returns the head of the queue.",
    "label": "",
    "id": "2172"
  },
  {
    "raw_code": "def initialize(lock, other_cond, preferred_thread)\n            @real_cond = lock.new_cond\n            @other_cond = other_cond\n            @preferred_thread = preferred_thread\n            @num_waiting_on_real_cond = 0\n          end",
    "comment": "semantics of condition variables guarantee that +broadcast+, +broadcast_on_biased+, +signal+ and +wait+ methods are only called while holding a lock",
    "label": "",
    "id": "2173"
  },
  {
    "raw_code": "def analyze_without_explain?\n            mariadb? && database_version >= \"10.1.0\"\n          end",
    "comment": "https://mariadb.com/kb/en/analyze-statement/",
    "label": "",
    "id": "2174"
  },
  {
    "raw_code": "def pp(result, elapsed)\n          widths    = compute_column_widths(result)\n          separator = build_separator(widths)\n\n          pp = []\n\n          pp << separator\n          pp << build_cells(result.columns, widths)\n          pp << separator\n\n          result.rows.each do |row|\n            pp << build_cells(row, widths)\n          end",
    "comment": "Pretty prints the result of an EXPLAIN in a way that resembles the output of the MySQL shell:  +----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+ | id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra       | +----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+ |  1 | SIMPLE      | users | const | PRIMARY       | PRIMARY | 4       | const |    1 |             | |  1 | SIMPLE      | posts | ALL   | NULL          | NULL    | NULL    | NULL  |    1 | Using where | +----+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+ 2 rows in set (0.00 sec)  This is an exercise in Ruby hyperrealism :).",
    "label": "",
    "id": "2175"
  },
  {
    "raw_code": "def type_cast(value) # :nodoc:\n          case value\n          when ActiveSupport::TimeWithZone\n            # We need to check explicitly for ActiveSupport::TimeWithZone because\n            # we need to transform it to Time objects but we don't want to\n            # transform Time objects to themselves.\n            if default_timezone == :utc\n              value.getutc\n            else\n              value.getlocal\n            end",
    "comment": "Override +type_cast+ we pass to mysql2 Date and Time objects instead of Strings since MySQL adapters are able to handle those classes more efficiently.",
    "label": "",
    "id": "2176"
  },
  {
    "raw_code": "def enable_index(index_name)\n          @base.enable_index(name, index_name)\n        end",
    "comment": "Enables an index to be used by query optimizers.  t.enable_index(:email)  Note: only supported by MySQL version 8.0.0 and greater, and MariaDB version 10.6.0 and greater.  See {connection.enable_index}[rdoc-ref:SchemaStatements#enable_index]",
    "label": "",
    "id": "2177"
  },
  {
    "raw_code": "def disable_index(index_name)\n          @base.disable_index(name, index_name)\n        end",
    "comment": "Disables an index not to be used by query optimizers.  t.disable_index(:email)  Note: only supported by MySQL version 8.0.0 and greater, and MariaDB version 10.6.0 and greater.  See {connection.disable_index}[rdoc-ref:SchemaStatements#disable_index]",
    "label": "",
    "id": "2178"
  },
  {
    "raw_code": "def indexes(table_name)\n          indexes = []\n          current_index = nil\n          internal_exec_query(\"SHOW KEYS FROM #{quote_table_name(table_name)}\", \"SCHEMA\").each do |row|\n            if current_index != row[\"Key_name\"]\n              next if row[\"Key_name\"] == \"PRIMARY\" # skip the primary key\n              current_index = row[\"Key_name\"]\n\n              mysql_index_type = row[\"Index_type\"].downcase.to_sym\n              case mysql_index_type\n              when :fulltext, :spatial\n                index_type = mysql_index_type\n              when :btree, :hash\n                index_using = mysql_index_type\n              end",
    "comment": "Returns an array of indexes for the given table.",
    "label": "",
    "id": "2179"
  },
  {
    "raw_code": "def type_to_sql(type, limit: nil, precision: nil, scale: nil, size: limit_to_size(limit, type), unsigned: nil, **)\n          sql =\n            case type.to_s\n            when \"integer\"\n              integer_to_sql(limit)\n            when \"text\"\n              type_with_size_to_sql(\"text\", size)\n            when \"blob\"\n              type_with_size_to_sql(\"blob\", size)\n            when \"binary\"\n              if (0..0xfff) === limit\n                \"varbinary(#{limit})\"\n              else\n                type_with_size_to_sql(\"blob\", size)\n              end",
    "comment": "Maps logical Rails types to MySQL-specific data types.",
    "label": "",
    "id": "2180"
  },
  {
    "raw_code": "def select_all(*, **) # :nodoc:\n          if ExplainRegistry.collect? && prepared_statements\n            unprepared_statement { super }\n          else\n            super\n          end",
    "comment": "Returns an ActiveRecord::Result instance.",
    "label": "",
    "id": "2181"
  },
  {
    "raw_code": "def query(sql, name = nil, allow_retry: true, materialize_transactions: true) # :nodoc:\n          result = internal_execute(sql, name, allow_retry:, materialize_transactions:)\n          result.map_types!(@type_map_for_results).values\n        end",
    "comment": "Queries the database and returns the results in an Array-like object",
    "label": "",
    "id": "2182"
  },
  {
    "raw_code": "def execute(...) # :nodoc:\n          super\n        ensure\n          @notice_receiver_sql_warnings = []\n        end",
    "comment": "Executes an SQL statement, returning a PG::Result object on success or raising a PG::Error exception otherwise.  Setting +allow_retry+ to true causes the db to reconnect and retry executing the SQL statement in case of a connection-related exception. This option should only be enabled for known idempotent queries.  Note: the PG::Result object is manually memory managed; if you don't need it specifically, you may want consider the <tt>exec_query</tt> wrapper.",
    "label": "",
    "id": "2183"
  },
  {
    "raw_code": "def begin_db_transaction # :nodoc:\n          internal_execute(\"BEGIN\", \"TRANSACTION\", allow_retry: true, materialize_transactions: false)\n        end",
    "comment": "Begins a transaction.",
    "label": "",
    "id": "2184"
  },
  {
    "raw_code": "def commit_db_transaction # :nodoc:\n          internal_execute(\"COMMIT\", \"TRANSACTION\", allow_retry: false, materialize_transactions: true)\n        end",
    "comment": "Commits a transaction.",
    "label": "",
    "id": "2185"
  },
  {
    "raw_code": "def exec_rollback_db_transaction # :nodoc:\n          cancel_any_running_query\n          internal_execute(\"ROLLBACK\", \"TRANSACTION\", allow_retry: false, materialize_transactions: true)\n        end",
    "comment": "Aborts a transaction.",
    "label": "",
    "id": "2186"
  },
  {
    "raw_code": "def set_constraints(deferred, *constraints)\n          unless %i[deferred immediate].include?(deferred)\n            raise ArgumentError, \"deferred must be :deferred or :immediate\"\n          end",
    "comment": "Set when constraints will be checked for the current transaction.  Not passing any specific constraint names will set the value for all deferrable constraints.  [<tt>deferred</tt>] Valid values are +:deferred+ or +:immediate+.  See https://www.postgresql.org/docs/current/sql-set-constraints.html",
    "label": "",
    "id": "2187"
  },
  {
    "raw_code": "def last_insert_id_result(sequence_name)\n            internal_exec_query(\"SELECT currval(#{quote(sequence_name)})\", \"SQL\")\n          end",
    "comment": "Returns the current ID of a table's sequence.",
    "label": "",
    "id": "2188"
  },
  {
    "raw_code": "def pp(result)\n          header = result.columns.first\n          lines  = result.rows.map(&:first)\n\n          # We add 2 because there's one char of padding at both sides, note\n          # the extra hyphens in the example above.\n          width = [header, *lines].map(&:length).max + 2\n\n          pp = []\n\n          pp << header.center(width).rstrip\n          pp << \"-\" * width\n\n          pp += lines.map { |line| \" #{line}\" }\n\n          nrows = result.rows.length\n          rows_label = nrows == 1 ? \"row\" : \"rows\"\n          pp << \"(#{nrows} #{rows_label})\"\n\n          pp.join(\"\\n\") + \"\\n\"\n        end",
    "comment": "Pretty prints the result of an EXPLAIN in a way that resembles the output of the PostgreSQL shell:  QUERY PLAN ------------------------------------------------------------------------------ Nested Loop Left Join  (cost=0.00..37.24 rows=8 width=0) Join Filter: (posts.user_id = users.id) ->  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4) Index Cond: (id = 1) ->  Seq Scan on posts  (cost=0.00..28.88 rows=8 width=4) Filter: (posts.user_id = 1) (6 rows) ",
    "label": "",
    "id": "2189"
  },
  {
    "raw_code": "def quote_column_name(name) # :nodoc:\n            QUOTED_COLUMN_NAMES[name] ||= PG::Connection.quote_ident(name.to_s).freeze\n          end",
    "comment": "Quotes column names for use in SQL queries.",
    "label": "",
    "id": "2190"
  },
  {
    "raw_code": "def quote_table_name(name) # :nodoc:\n            QUOTED_TABLE_NAMES[name] ||= Utils.extract_schema_qualified_name(name.to_s).quoted.freeze\n          end",
    "comment": "Checks the following cases:  - table_name - \"table.name\" - schema_name.table_name - schema_name.\"table.name\" - \"schema.name\".table_name - \"schema.name\".\"table.name\"",
    "label": "",
    "id": "2191"
  },
  {
    "raw_code": "def escape_bytea(value)\n          valid_raw_connection.escape_bytea(value) if value\n        end",
    "comment": "Escapes binary strings for bytea input to the database.",
    "label": "",
    "id": "2192"
  },
  {
    "raw_code": "def unescape_bytea(value)\n          valid_raw_connection.unescape_bytea(value) if value\n        end",
    "comment": "Unescapes bytea output from a database to the binary string it represents. NOTE: This is NOT an inverse of escape_bytea! This is only to be used on escaped binary output from database drive.",
    "label": "",
    "id": "2193"
  },
  {
    "raw_code": "def quote_string(s) # :nodoc:\n          with_raw_connection(allow_retry: true, materialize_transactions: false) do |connection|\n            connection.escape(s)\n          end",
    "comment": "Quotes strings for use in SQL input.",
    "label": "",
    "id": "2194"
  },
  {
    "raw_code": "def quote_schema_name(schema_name)\n          quote_column_name(schema_name)\n        end",
    "comment": "Quotes schema names for use in SQL queries.",
    "label": "",
    "id": "2195"
  },
  {
    "raw_code": "def quoted_date(value) # :nodoc:\n          if value.year <= 0\n            bce_year = format(\"%04d\", -value.year + 1)\n            super.sub(/^-?\\d+/, bce_year) + \" BC\"\n          else\n            super\n          end",
    "comment": "Quote date/time values for use in SQL input.",
    "label": "",
    "id": "2196"
  },
  {
    "raw_code": "def quote_default_expression(value, column) # :nodoc:\n          if value.is_a?(Proc)\n            value.call\n          elsif column.type == :uuid && value.is_a?(String) && value.include?(\"()\")\n            value # Does not quote function default values for UUID columns\n          elsif column.respond_to?(:array?)\n            # TODO: Remove fetch_cast_type and the need for connection after we release 8.1.\n            quote(column.fetch_cast_type(self).serialize(value))\n          else\n            super\n          end",
    "comment": "`column` may be either an instance of Column or ColumnDefinition.",
    "label": "",
    "id": "2197"
  },
  {
    "raw_code": "def lookup_cast_type(sql_type) # :nodoc:\n          super(query_value(\"SELECT #{quote(sql_type)}::regtype::oid\", \"SCHEMA\").to_i)\n        end",
    "comment": "TODO: Make this method private after we release 8.1.",
    "label": "",
    "id": "2198"
  },
  {
    "raw_code": "def table_modifier_in_create(o)\n            # A table cannot be both TEMPORARY and UNLOGGED, since all TEMPORARY\n            # tables are already UNLOGGED.\n            if o.temporary\n              \" TEMPORARY\"\n            elsif o.unlogged\n              \" UNLOGGED\"\n            end",
    "comment": "Returns any SQL string to go between CREATE and TABLE. May be nil.",
    "label": "",
    "id": "2199"
  },
  {
    "raw_code": "def primary_key(name, type = :primary_key, **options)\n          if type == :uuid\n            options[:default] = options.fetch(:default, \"gen_random_uuid()\")\n          end",
    "comment": "Defines the primary key field. Use of the native PostgreSQL UUID type is supported, and can be used by defining your tables as such:  create_table :stuffs, id: :uuid do |t| t.string :content t.timestamps end  By default, this will use the <tt>gen_random_uuid()</tt> function.  To use a UUID primary key without any defaults, set the +:default+ option to +nil+:  create_table :stuffs, id: false do |t| t.primary_key :id, :uuid, default: nil t.uuid :foo_id t.timestamps end  You may also pass a custom stored procedure that returns a UUID or use a different UUID generation function from another library.  Note that setting the UUID primary key default value to +nil+ will require you to assure that you always provide a UUID value before saving a record (as primary keys cannot be +nil+). This might be done via the +SecureRandom.uuid+ method and a +before_save+ callback, for instance.",
    "label": "",
    "id": "2200"
  },
  {
    "raw_code": "def exclusion_constraint(...)\n          @base.add_exclusion_constraint(name, ...)\n        end",
    "comment": "Adds an exclusion constraint.  t.exclusion_constraint(\"price WITH =, availability_range WITH &&\", using: :gist, name: \"price_check\")  See {connection.add_exclusion_constraint}[rdoc-ref:SchemaStatements#add_exclusion_constraint]",
    "label": "",
    "id": "2201"
  },
  {
    "raw_code": "def remove_exclusion_constraint(...)\n          @base.remove_exclusion_constraint(name, ...)\n        end",
    "comment": "Removes the given exclusion constraint from the table.  t.remove_exclusion_constraint(name: \"price_check\")  See {connection.remove_exclusion_constraint}[rdoc-ref:SchemaStatements#remove_exclusion_constraint]",
    "label": "",
    "id": "2202"
  },
  {
    "raw_code": "def unique_constraint(...)\n          @base.add_unique_constraint(name, ...)\n        end",
    "comment": "Adds a unique constraint.  t.unique_constraint(:position, name: 'unique_position', deferrable: :deferred, nulls_not_distinct: true)  See {connection.add_unique_constraint}[rdoc-ref:SchemaStatements#add_unique_constraint]",
    "label": "",
    "id": "2203"
  },
  {
    "raw_code": "def remove_unique_constraint(...)\n          @base.remove_unique_constraint(name, ...)\n        end",
    "comment": "Removes the given unique constraint from the table.  t.remove_unique_constraint(name: \"unique_position\")  See {connection.remove_unique_constraint}[rdoc-ref:SchemaStatements#remove_unique_constraint]",
    "label": "",
    "id": "2204"
  },
  {
    "raw_code": "def validate_constraint(...)\n          @base.validate_constraint(name, ...)\n        end",
    "comment": "Validates the given constraint on the table.  t.check_constraint(\"price > 0\", name: \"price_check\", validate: false) t.validate_constraint \"price_check\"  See {connection.validate_constraint}[rdoc-ref:SchemaStatements#validate_constraint]",
    "label": "",
    "id": "2205"
  },
  {
    "raw_code": "def validate_check_constraint(...)\n          @base.validate_check_constraint(name, ...)\n        end",
    "comment": "Validates the given check constraint on the table  t.check_constraint(\"price > 0\", name: \"price_check\", validate: false) t.validate_check_constraint name: \"price_check\"  See {connection.validate_check_constraint}[rdoc-ref:SchemaStatements#validate_check_constraint]",
    "label": "",
    "id": "2206"
  },
  {
    "raw_code": "def recreate_database(name, options = {}) # :nodoc:\n          drop_database(name)\n          create_database(name, options)\n        end",
    "comment": "Drops the database specified on the +name+ attribute and creates it again using the provided +options+.",
    "label": "",
    "id": "2207"
  },
  {
    "raw_code": "def create_database(name, options = {})\n          options = { encoding: \"utf8\" }.merge!(options.symbolize_keys)\n\n          option_string = options.each_with_object(+\"\") do |(key, value), memo|\n            memo << case key\n                    when :owner\n                      \" OWNER = \\\"#{value}\\\"\"\n                    when :template\n                      \" TEMPLATE = \\\"#{value}\\\"\"\n                    when :encoding\n                      \" ENCODING = '#{value}'\"\n                    when :locale_provider\n                      \" LOCALE_PROVIDER = '#{value}'\"\n                    when :locale\n                      \" LOCALE = '#{value}'\"\n                    when :collation\n                      \" LC_COLLATE = '#{value}'\"\n                    when :ctype\n                      \" LC_CTYPE = '#{value}'\"\n                    when :tablespace\n                      \" TABLESPACE = \\\"#{value}\\\"\"\n                    when :connection_limit\n                      \" CONNECTION LIMIT = #{value}\"\n                    else\n                      \"\"\n            end",
    "comment": "Create a new PostgreSQL database. Options include <tt>:owner</tt>, <tt>:template</tt>, <tt>:encoding</tt> (defaults to utf8), <tt>:locale_provider</tt>, <tt>:locale</tt>, <tt>:collation</tt>, <tt>:ctype</tt>, <tt>:tablespace</tt>, and <tt>:connection_limit</tt> (note that MySQL uses <tt>:charset</tt> while PostgreSQL uses <tt>:encoding</tt>).  Example: create_database config[:database], config create_database 'foo_development', encoding: 'unicode'",
    "label": "",
    "id": "2208"
  },
  {
    "raw_code": "def drop_database(name) # :nodoc:\n          execute \"DROP DATABASE IF EXISTS #{quote_table_name(name)}\"\n        end",
    "comment": "Drops a PostgreSQL database.  Example: drop_database 'matt_development'",
    "label": "",
    "id": "2209"
  },
  {
    "raw_code": "def schema_exists?(name)\n          query_value(\"SELECT COUNT(*) FROM pg_namespace WHERE nspname = #{quote(name)}\", \"SCHEMA\").to_i > 0\n        end",
    "comment": "Returns true if schema exists.",
    "label": "",
    "id": "2210"
  },
  {
    "raw_code": "def index_name_exists?(table_name, index_name)\n          table = quoted_scope(table_name)\n          index = quoted_scope(index_name)\n\n          query_value(<<~SQL, \"SCHEMA\").to_i > 0\n            SELECT COUNT(*)\n            FROM pg_class t\n            INNER JOIN pg_index d ON t.oid = d.indrelid\n            INNER JOIN pg_class i ON d.indexrelid = i.oid\n            LEFT JOIN pg_namespace n ON n.oid = t.relnamespace\n            WHERE i.relkind IN ('i', 'I')\n              AND i.relname = #{index[:name]}\n              AND t.relname = #{table[:name]}\n              AND n.nspname = #{table[:schema]}\n          SQL\n        end",
    "comment": "Verifies existence of an index with a given name.",
    "label": "",
    "id": "2211"
  },
  {
    "raw_code": "def indexes(table_name) # :nodoc:\n          scope = quoted_scope(table_name)\n\n          result = query(<<~SQL, \"SCHEMA\")\n            SELECT distinct i.relname, d.indisunique, d.indkey, pg_get_indexdef(d.indexrelid),\n                            pg_catalog.obj_description(i.oid, 'pg_class') AS comment, d.indisvalid,\n                            ARRAY(\n                              SELECT pg_get_indexdef(d.indexrelid, k + 1, true)\n                              FROM generate_subscripts(d.indkey, 1) AS k\n                              ORDER BY k\n                            ) AS columns\n            FROM pg_class t\n            INNER JOIN pg_index d ON t.oid = d.indrelid\n            INNER JOIN pg_class i ON d.indexrelid = i.oid\n            LEFT JOIN pg_namespace n ON n.oid = t.relnamespace\n            WHERE i.relkind IN ('i', 'I')\n              AND d.indisprimary = 'f'\n              AND t.relname = #{scope[:name]}\n              AND n.nspname = #{scope[:schema]}\n            ORDER BY i.relname\n          SQL\n\n          result.map do |row|\n            index_name = row[0]\n            unique = row[1]\n            indkey = row[2].split(\" \").map(&:to_i)\n            inddef = row[3]\n            comment = row[4]\n            valid = row[5]\n            columns = decode_string_array(row[6]).map { |c| Utils.unquote_identifier(c.strip.gsub('\"\"', '\"')) }\n\n            using, expressions, include, nulls_not_distinct, where = inddef.scan(/ USING (\\w+?) \\((.+?)\\)(?: INCLUDE \\((.+?)\\))?( NULLS NOT DISTINCT)?(?: WHERE (.+))?\\z/m).flatten\n\n            orders = {}\n            opclasses = {}\n            include_columns = include ? include.split(\",\").map { |c| Utils.unquote_identifier(c.strip.gsub('\"\"', '\"')) } : []\n\n            if indkey.include?(0)\n              columns = expressions\n            else\n              # prevent INCLUDE columns from being matched\n              columns.reject! { |c| include_columns.include?(c) }\n\n              # add info on sort order (only desc order is explicitly specified, asc is the default)\n              # and non-default opclasses\n              expressions.scan(/(?<column>\\w+)\"?\\s?(?<opclass>\\w+_ops(_\\w+)?)?\\s?(?<desc>DESC)?\\s?(?<nulls>NULLS (?:FIRST|LAST))?/).each do |column, opclass, desc, nulls|\n                opclasses[column] = opclass.to_sym if opclass\n                if nulls\n                  orders[column] = [desc, nulls].compact.join(\" \")\n                else\n                  orders[column] = :desc if desc\n                end",
    "comment": "Returns an array of indexes for the given table.",
    "label": "",
    "id": "2212"
  },
  {
    "raw_code": "def table_comment(table_name) # :nodoc:\n          scope = quoted_scope(table_name, type: \"BASE TABLE\")\n          if scope[:name]\n            query_value(<<~SQL, \"SCHEMA\")\n              SELECT pg_catalog.obj_description(c.oid, 'pg_class')\n              FROM pg_catalog.pg_class c\n                LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n              WHERE c.relname = #{scope[:name]}\n                AND c.relkind IN (#{scope[:type]})\n                AND n.nspname = #{scope[:schema]}\n            SQL\n          end",
    "comment": "Returns a comment stored in database for given table",
    "label": "",
    "id": "2213"
  },
  {
    "raw_code": "def table_partition_definition(table_name) # :nodoc:\n          scope = quoted_scope(table_name, type: \"BASE TABLE\")\n\n          query_value(<<~SQL, \"SCHEMA\")\n            SELECT pg_catalog.pg_get_partkeydef(c.oid)\n            FROM pg_catalog.pg_class c\n              LEFT JOIN pg_namespace n ON n.oid = c.relnamespace\n            WHERE c.relname = #{scope[:name]}\n              AND c.relkind IN (#{scope[:type]})\n              AND n.nspname = #{scope[:schema]}\n          SQL\n        end",
    "comment": "Returns the partition definition of a given table",
    "label": "",
    "id": "2214"
  },
  {
    "raw_code": "def inherited_table_names(table_name) # :nodoc:\n          scope = quoted_scope(table_name, type: \"BASE TABLE\")\n\n          query_values(<<~SQL, \"SCHEMA\")\n            SELECT parent.relname\n            FROM pg_catalog.pg_inherits i\n              JOIN pg_catalog.pg_class child ON i.inhrelid = child.oid\n              JOIN pg_catalog.pg_class parent ON i.inhparent = parent.oid\n              LEFT JOIN pg_namespace n ON n.oid = child.relnamespace\n            WHERE child.relname = #{scope[:name]}\n              AND child.relkind IN (#{scope[:type]})\n              AND n.nspname = #{scope[:schema]}\n          SQL\n        end",
    "comment": "Returns the inherited table name of a given table",
    "label": "",
    "id": "2215"
  },
  {
    "raw_code": "def current_database\n          query_value(\"SELECT current_database()\", \"SCHEMA\")\n        end",
    "comment": "Returns the current database name.",
    "label": "",
    "id": "2216"
  },
  {
    "raw_code": "def current_schema\n          query_value(\"SELECT current_schema\", \"SCHEMA\")\n        end",
    "comment": "Returns the current schema name.",
    "label": "",
    "id": "2217"
  },
  {
    "raw_code": "def current_schemas # :nodoc:\n          schemas = query_value(\"SELECT current_schemas(false)\", \"SCHEMA\")\n          decoder = PG::TextDecoder::Array.new\n          decoder.decode(schemas)\n        end",
    "comment": "Returns an array of the names of all schemas presently in the effective search path, in their priority order.",
    "label": "",
    "id": "2218"
  },
  {
    "raw_code": "def encoding\n          query_value(\"SELECT pg_encoding_to_char(encoding) FROM pg_database WHERE datname = current_database()\", \"SCHEMA\")\n        end",
    "comment": "Returns the current database encoding format.",
    "label": "",
    "id": "2219"
  },
  {
    "raw_code": "def collation\n          query_value(\"SELECT datcollate FROM pg_database WHERE datname = current_database()\", \"SCHEMA\")\n        end",
    "comment": "Returns the current database collation.",
    "label": "",
    "id": "2220"
  },
  {
    "raw_code": "def ctype\n          query_value(\"SELECT datctype FROM pg_database WHERE datname = current_database()\", \"SCHEMA\")\n        end",
    "comment": "Returns the current database ctype.",
    "label": "",
    "id": "2221"
  },
  {
    "raw_code": "def schema_names\n          query_values(<<~SQL, \"SCHEMA\")\n            SELECT nspname\n              FROM pg_namespace\n             WHERE nspname !~ '^pg_.*'\n               AND nspname NOT IN ('information_schema')\n             ORDER by nspname;\n          SQL\n        end",
    "comment": "Returns an array of schema names.",
    "label": "",
    "id": "2222"
  },
  {
    "raw_code": "def create_schema(schema_name, force: nil, if_not_exists: nil)\n          if force && if_not_exists\n            raise ArgumentError, \"Options `:force` and `:if_not_exists` cannot be used simultaneously.\"\n          end",
    "comment": "Creates a schema for the given schema name.",
    "label": "",
    "id": "2223"
  },
  {
    "raw_code": "def drop_schema(schema_name, **options)\n          execute \"DROP SCHEMA#{' IF EXISTS' if options[:if_exists]} #{quote_schema_name(schema_name)} CASCADE\"\n        end",
    "comment": "Drops the schema for the given schema name.",
    "label": "",
    "id": "2224"
  },
  {
    "raw_code": "def rename_schema(schema_name, new_name)\n          execute \"ALTER SCHEMA #{quote_schema_name(schema_name)} RENAME TO #{quote_schema_name(new_name)}\"\n        end",
    "comment": "Renames the schema for the given schema name.",
    "label": "",
    "id": "2225"
  },
  {
    "raw_code": "def schema_search_path=(schema_csv)\n          return if schema_csv == @schema_search_path\n          if schema_csv\n            internal_execute(\"SET search_path TO #{schema_csv}\")\n            @schema_search_path = schema_csv\n          end",
    "comment": "Sets the schema search path to a string of comma-separated schema names. Names beginning with $ have to be quoted (e.g. $user => '$user'). See: https://www.postgresql.org/docs/current/static/ddl-schemas.html  This should be not be called manually but set in database.yml.",
    "label": "",
    "id": "2226"
  },
  {
    "raw_code": "def schema_search_path\n          @schema_search_path ||= query_value(\"SHOW search_path\", \"SCHEMA\")\n        end",
    "comment": "Returns the active schema search path.",
    "label": "",
    "id": "2227"
  },
  {
    "raw_code": "def client_min_messages\n          query_value(\"SHOW client_min_messages\", \"SCHEMA\")\n        end",
    "comment": "Returns the current client message level.",
    "label": "",
    "id": "2228"
  },
  {
    "raw_code": "def client_min_messages=(level)\n          internal_execute(\"SET client_min_messages TO '#{level}'\", \"SCHEMA\")\n        end",
    "comment": "Set the client message level.",
    "label": "",
    "id": "2229"
  },
  {
    "raw_code": "def default_sequence_name(table_name, pk = \"id\") # :nodoc:\n          return nil if pk.is_a?(Array)\n\n          result = serial_sequence(table_name, pk)\n          return nil unless result\n          Utils.extract_schema_qualified_name(result).to_s\n        rescue ActiveRecord::StatementInvalid\n          PostgreSQL::Name.new(nil, \"#{table_name}_#{pk}_seq\").to_s\n        end",
    "comment": "Returns the sequence name for a table's primary key or some other specified key.",
    "label": "",
    "id": "2230"
  },
  {
    "raw_code": "def set_pk_sequence!(table, value) # :nodoc:\n          pk, sequence = pk_and_sequence_for(table)\n\n          if pk\n            if sequence\n              quoted_sequence = quote_table_name(sequence)\n\n              internal_execute(\"SELECT setval(#{quote(quoted_sequence)}, #{value})\", \"SCHEMA\")\n            else\n              @logger.warn \"#{table} has primary key #{pk} with no default sequence.\" if @logger\n            end",
    "comment": "Sets the sequence of a table's primary key to the specified value.",
    "label": "",
    "id": "2231"
  },
  {
    "raw_code": "def reset_pk_sequence!(table, pk = nil, sequence = nil) # :nodoc:\n          unless pk && sequence\n            default_pk, default_sequence = pk_and_sequence_for(table)\n\n            pk ||= default_pk\n            sequence ||= default_sequence\n          end",
    "comment": "Resets the sequence of a table's primary key to the maximum value.",
    "label": "",
    "id": "2232"
  },
  {
    "raw_code": "def pk_and_sequence_for(table) # :nodoc:\n          # First try looking for a sequence with a dependency on the\n          # given table's primary key.\n          result = query(<<~SQL, \"SCHEMA\")[0]\n            SELECT attr.attname, nsp.nspname, seq.relname\n            FROM pg_class      seq,\n                 pg_attribute  attr,\n                 pg_depend     dep,\n                 pg_constraint cons,\n                 pg_namespace  nsp\n            WHERE seq.oid           = dep.objid\n              AND seq.relkind       = 'S'\n              AND attr.attrelid     = dep.refobjid\n              AND attr.attnum       = dep.refobjsubid\n              AND attr.attrelid     = cons.conrelid\n              AND attr.attnum       = cons.conkey[1]\n              AND seq.relnamespace  = nsp.oid\n              AND cons.contype      = 'p'\n              AND dep.classid       = 'pg_class'::regclass\n              AND dep.refobjid      = #{quote(quote_table_name(table))}::regclass\n          SQL\n\n          if result.nil? || result.empty?\n            result = query(<<~SQL, \"SCHEMA\")[0]\n              SELECT attr.attname, nsp.nspname,\n                CASE\n                  WHEN pg_get_expr(def.adbin, def.adrelid) !~* 'nextval' THEN NULL\n                  WHEN split_part(pg_get_expr(def.adbin, def.adrelid), '''', 2) ~ '.' THEN\n                    substr(split_part(pg_get_expr(def.adbin, def.adrelid), '''', 2),\n                           strpos(split_part(pg_get_expr(def.adbin, def.adrelid), '''', 2), '.')+1)\n                  ELSE split_part(pg_get_expr(def.adbin, def.adrelid), '''', 2)\n                END\n              FROM pg_class       t\n              JOIN pg_attribute   attr ON (t.oid = attrelid)\n              JOIN pg_attrdef     def  ON (adrelid = attrelid AND adnum = attnum)\n              JOIN pg_constraint  cons ON (conrelid = adrelid AND adnum = conkey[1])\n              JOIN pg_namespace   nsp  ON (t.relnamespace = nsp.oid)\n              WHERE t.oid = #{quote(quote_table_name(table))}::regclass\n                AND cons.contype = 'p'\n                AND pg_get_expr(def.adbin, def.adrelid) ~* 'nextval|uuid_generate|gen_random_uuid'\n            SQL\n          end",
    "comment": "Returns a table's primary key and belonging sequence.",
    "label": "",
    "id": "2233"
  },
  {
    "raw_code": "def rename_table(table_name, new_name, **options)\n          validate_table_length!(new_name) unless options[:_uses_legacy_table_name]\n          clear_cache!\n          schema_cache.clear_data_source_cache!(table_name.to_s)\n          schema_cache.clear_data_source_cache!(new_name.to_s)\n          execute \"ALTER TABLE #{quote_table_name(table_name)} RENAME TO #{quote_table_name(new_name)}\"\n          pk, seq = pk_and_sequence_for(new_name)\n          if pk\n            # PostgreSQL automatically creates an index for PRIMARY KEY with name consisting of\n            # truncated table name and \"_pkey\" suffix fitting into max_identifier_length number of characters.\n            max_pkey_prefix = max_identifier_length - \"_pkey\".size\n            idx = \"#{table_name[0, max_pkey_prefix]}_pkey\"\n            new_idx = \"#{new_name[0, max_pkey_prefix]}_pkey\"\n            execute \"ALTER INDEX #{quote_table_name(idx)} RENAME TO #{quote_table_name(new_idx)}\"\n\n            # PostgreSQL automatically creates a sequence for PRIMARY KEY with name consisting of\n            # truncated table name and \"#{primary_key}_seq\" suffix fitting into max_identifier_length number of characters.\n            max_seq_prefix = max_identifier_length - \"_#{pk}_seq\".size\n            if seq && seq.identifier == \"#{table_name[0, max_seq_prefix]}_#{pk}_seq\"\n              new_seq = \"#{new_name[0, max_seq_prefix]}_#{pk}_seq\"\n              execute \"ALTER TABLE #{seq.quoted} RENAME TO #{quote_table_name(new_seq)}\"\n            end",
    "comment": "Renames a table. Also renames a table's primary key sequence if the sequence name exists and matches the Active Record default.  Example: rename_table('octopuses', 'octopi')",
    "label": "",
    "id": "2234"
  },
  {
    "raw_code": "def build_change_column_definition(table_name, column_name, type, **options) # :nodoc:\n          td = create_table_definition(table_name)\n          cd = td.new_column_definition(column_name, type, **options)\n          ChangeColumnDefinition.new(cd, column_name)\n        end",
    "comment": "Builds a ChangeColumnDefinition object.  This definition object contains information about the column change that would occur if the same arguments were passed to #change_column. See #change_column for information about passing a +table_name+, +column_name+, +type+ and other options that can be passed.",
    "label": "",
    "id": "2235"
  },
  {
    "raw_code": "def change_column_default(table_name, column_name, default_or_changes) # :nodoc:\n          execute \"ALTER TABLE #{quote_table_name(table_name)} #{change_column_default_for_alter(table_name, column_name, default_or_changes)}\"\n        end",
    "comment": "Changes the default value of a table column.",
    "label": "",
    "id": "2236"
  },
  {
    "raw_code": "def change_column_comment(table_name, column_name, comment_or_changes) # :nodoc:\n          clear_cache!\n          comment = extract_new_comment_value(comment_or_changes)\n          execute \"COMMENT ON COLUMN #{quote_table_name(table_name)}.#{quote_column_name(column_name)} IS #{quote(comment)}\"\n        end",
    "comment": "Adds comment for given table column or drops it if +comment+ is a +nil+",
    "label": "",
    "id": "2237"
  },
  {
    "raw_code": "def change_table_comment(table_name, comment_or_changes) # :nodoc:\n          clear_cache!\n          comment = extract_new_comment_value(comment_or_changes)\n          execute \"COMMENT ON TABLE #{quote_table_name(table_name)} IS #{quote(comment)}\"\n        end",
    "comment": "Adds comment for given table or drops it if +comment+ is a +nil+",
    "label": "",
    "id": "2238"
  },
  {
    "raw_code": "def rename_column(table_name, column_name, new_column_name) # :nodoc:\n          clear_cache!\n          execute(\"ALTER TABLE #{quote_table_name(table_name)} #{rename_column_sql(table_name, column_name, new_column_name)}\")\n          rename_column_indexes(table_name, column_name, new_column_name)\n        end",
    "comment": "Renames a column in a table.",
    "label": "",
    "id": "2239"
  },
  {
    "raw_code": "def rename_index(table_name, old_name, new_name)\n          validate_index_length!(table_name, new_name)\n\n          schema, = extract_schema_qualified_name(table_name)\n          execute \"ALTER INDEX #{quote_table_name(schema) + '.' if schema}#{quote_column_name(old_name)} RENAME TO #{quote_table_name(new_name)}\"\n        end",
    "comment": "Renames an index of a table. Raises error if length of new index name is greater than allowed limit.",
    "label": "",
    "id": "2240"
  },
  {
    "raw_code": "def exclusion_constraints(table_name)\n          scope = quoted_scope(table_name)\n\n          exclusion_info = internal_exec_query(<<-SQL, \"SCHEMA\")\n            SELECT conname, pg_get_constraintdef(c.oid) AS constraintdef, c.condeferrable, c.condeferred\n            FROM pg_constraint c\n            JOIN pg_class t ON c.conrelid = t.oid\n            JOIN pg_namespace n ON n.oid = c.connamespace\n            WHERE c.contype = 'x'\n              AND t.relname = #{scope[:name]}\n              AND n.nspname = #{scope[:schema]}\n          SQL\n\n          exclusion_info.map do |row|\n            method_and_elements, predicate = row[\"constraintdef\"].split(\" WHERE \")\n            method_and_elements_parts = method_and_elements.match(/EXCLUDE(?: USING (?<using>\\S+))? \\((?<expression>.+)\\)/)\n            predicate.remove!(/ DEFERRABLE(?: INITIALLY (?:IMMEDIATE|DEFERRED))?/) if predicate\n            predicate = predicate.from(2).to(-3) if predicate # strip 2 opening and closing parentheses\n\n            deferrable = extract_constraint_deferrable(row[\"condeferrable\"], row[\"condeferred\"])\n\n            options = {\n              name: row[\"conname\"],\n              using: method_and_elements_parts[\"using\"].to_sym,\n              where: predicate,\n              deferrable: deferrable\n            }\n\n            ExclusionConstraintDefinition.new(table_name, method_and_elements_parts[\"expression\"], options)\n          end",
    "comment": "Returns an array of exclusion constraints for the given table. The exclusion constraints are represented as ExclusionConstraintDefinition objects.",
    "label": "",
    "id": "2241"
  },
  {
    "raw_code": "def unique_constraints(table_name)\n          scope = quoted_scope(table_name)\n\n          unique_info = internal_exec_query(<<~SQL, \"SCHEMA\", allow_retry: true, materialize_transactions: false)\n            SELECT c.conname, c.conrelid, c.condeferrable, c.condeferred, pg_get_constraintdef(c.oid) AS constraintdef,\n            (\n              SELECT array_agg(a.attname ORDER BY idx)\n              FROM (\n                SELECT idx, c.conkey[idx] AS conkey_elem\n                FROM generate_subscripts(c.conkey, 1) AS idx\n              ) indexed_conkeys\n              JOIN pg_attribute a ON a.attrelid = t.oid\n              AND a.attnum = indexed_conkeys.conkey_elem\n            ) AS conkey_names\n            FROM pg_constraint c\n            JOIN pg_class t ON c.conrelid = t.oid\n            JOIN pg_namespace n ON n.oid = c.connamespace\n            WHERE c.contype = 'u'\n              AND t.relname = #{scope[:name]}\n              AND n.nspname = #{scope[:schema]}\n          SQL\n\n          unique_info.map do |row|\n            columns = decode_string_array(row[\"conkey_names\"])\n\n            nulls_not_distinct = row[\"constraintdef\"].start_with?(\"UNIQUE NULLS NOT DISTINCT\")\n            deferrable = extract_constraint_deferrable(row[\"condeferrable\"], row[\"condeferred\"])\n\n            options = {\n              name: row[\"conname\"],\n              nulls_not_distinct: nulls_not_distinct,\n              deferrable: deferrable\n            }\n\n            UniqueConstraintDefinition.new(table_name, columns, options)\n          end",
    "comment": "Returns an array of unique constraints for the given table. The unique constraints are represented as UniqueConstraintDefinition objects.",
    "label": "",
    "id": "2242"
  },
  {
    "raw_code": "def add_exclusion_constraint(table_name, expression, **options)\n          options = exclusion_constraint_options(table_name, expression, options)\n          at = create_alter_table(table_name)\n          at.add_exclusion_constraint(expression, options)\n\n          execute schema_creation.accept(at)\n        end",
    "comment": "Adds a new exclusion constraint to the table. +expression+ is a String representation of a list of exclusion elements and operators.  add_exclusion_constraint :products, \"price WITH =, availability_range WITH &&\", using: :gist, name: \"price_check\"  generates:  ALTER TABLE \"products\" ADD CONSTRAINT price_check EXCLUDE USING gist (price WITH =, availability_range WITH &&)  The +options+ hash can include the following keys: [<tt>:name</tt>] The constraint name. Defaults to <tt>excl_rails_<identifier></tt>. [<tt>:deferrable</tt>] Specify whether or not the exclusion constraint should be deferrable. Valid values are +false+ or +:immediate+ or +:deferred+ to specify the default behavior. Defaults to +false+. [<tt>:using</tt>] Specify which index method to use when creating this exclusion constraint (e.g. +:btree+, +:gist+ etc). [<tt>:where</tt>] Specify an exclusion constraint on a subset of the table (internally PostgreSQL creates a partial index for this).",
    "label": "",
    "id": "2243"
  },
  {
    "raw_code": "def remove_exclusion_constraint(table_name, expression = nil, **options)\n          excl_name_to_delete = exclusion_constraint_for!(table_name, expression: expression, **options).name\n\n          remove_constraint(table_name, excl_name_to_delete)\n        end",
    "comment": "Removes the given exclusion constraint from the table.  remove_exclusion_constraint :products, name: \"price_check\"  The +expression+ parameter will be ignored if present. It can be helpful to provide this in a migration's +change+ method so it can be reverted. In that case, +expression+ will be used by #add_exclusion_constraint.",
    "label": "",
    "id": "2244"
  },
  {
    "raw_code": "def add_unique_constraint(table_name, column_name = nil, **options)\n          options = unique_constraint_options(table_name, column_name, options)\n          at = create_alter_table(table_name)\n          at.add_unique_constraint(column_name, options)\n\n          execute schema_creation.accept(at)\n        end",
    "comment": "Adds a new unique constraint to the table.  add_unique_constraint :sections, [:position], deferrable: :deferred, name: \"unique_position\", nulls_not_distinct: true  generates:  ALTER TABLE \"sections\" ADD CONSTRAINT unique_position UNIQUE (position) DEFERRABLE INITIALLY DEFERRED  If you want to change an existing unique index to deferrable, you can use :using_index to create deferrable unique constraints.  add_unique_constraint :sections, deferrable: :deferred, name: \"unique_position\", using_index: \"index_sections_on_position\"  The +options+ hash can include the following keys: [<tt>:name</tt>] The constraint name. Defaults to <tt>uniq_rails_<identifier></tt>. [<tt>:deferrable</tt>] Specify whether or not the unique constraint should be deferrable. Valid values are +false+ or +:immediate+ or +:deferred+ to specify the default behavior. Defaults to +false+. [<tt>:using_index</tt>] To specify an existing unique index name. Defaults to +nil+. [<tt>:nulls_not_distinct</tt>] Create a unique constraint where NULLs are treated equally. Note: only supported by PostgreSQL version 15.0.0 and greater.",
    "label": "",
    "id": "2245"
  },
  {
    "raw_code": "def remove_unique_constraint(table_name, column_name = nil, **options)\n          unique_name_to_delete = unique_constraint_for!(table_name, column: column_name, **options).name\n\n          remove_constraint(table_name, unique_name_to_delete)\n        end",
    "comment": "Removes the given unique constraint from the table.  remove_unique_constraint :sections, name: \"unique_position\"  The +column_name+ parameter will be ignored if present. It can be helpful to provide this in a migration's +change+ method so it can be reverted. In that case, +column_name+ will be used by #add_unique_constraint.",
    "label": "",
    "id": "2246"
  },
  {
    "raw_code": "def type_to_sql(type, limit: nil, precision: nil, scale: nil, array: nil, enum_type: nil, **) # :nodoc:\n          sql = \\\n            case type.to_s\n            when \"binary\"\n              # PostgreSQL doesn't support limits on binary (bytea) columns.\n              # The hard limit is 1GB, because of a 32-bit size field, and TOAST.\n              case limit\n              when nil, 0..0x3fffffff; super(type)\n              else raise ArgumentError, \"No binary type has byte size #{limit}. The limit on binary can be at most 1GB - 1byte.\"\n              end",
    "comment": "Maps logical Rails types to PostgreSQL-specific data types.",
    "label": "",
    "id": "2247"
  },
  {
    "raw_code": "def columns_for_distinct(columns, orders) # :nodoc:\n          order_columns = orders.compact_blank.map { |s|\n            # Convert Arel node to string\n            s = visitor.compile(s) unless s.is_a?(String)\n            # Remove any ASC/DESC modifiers\n            s.gsub(/\\s+(?:ASC|DESC)\\b/i, \"\")\n             .gsub(/\\s+NULLS\\s+(?:FIRST|LAST)\\b/i, \"\")\n          }.compact_blank.map.with_index { |column, i| \"#{column} AS alias_#{i}\" }\n\n          (order_columns << super).join(\", \")\n        end",
    "comment": "PostgreSQL requires the ORDER BY columns in the select list for distinct queries, and requires that the ORDER BY include the distinct column.",
    "label": "",
    "id": "2248"
  },
  {
    "raw_code": "def validate_constraint(table_name, constraint_name)\n          at = create_alter_table table_name\n          at.validate_constraint constraint_name\n\n          execute schema_creation.accept(at)\n        end",
    "comment": "Validates the given constraint.  Validates the constraint named +constraint_name+ on +accounts+.  validate_constraint :accounts, :constraint_name",
    "label": "",
    "id": "2249"
  },
  {
    "raw_code": "def validate_foreign_key(from_table, to_table = nil, **options)\n          fk_name_to_validate = foreign_key_for!(from_table, to_table: to_table, **options).name\n\n          validate_constraint from_table, fk_name_to_validate\n        end",
    "comment": "Validates the given foreign key.  Validates the foreign key on +accounts.branch_id+.  validate_foreign_key :accounts, :branches  Validates the foreign key on +accounts.owner_id+.  validate_foreign_key :accounts, column: :owner_id  Validates the foreign key named +special_fk_name+ on the +accounts+ table.  validate_foreign_key :accounts, name: :special_fk_name  The +options+ hash accepts the same keys as SchemaStatements#add_foreign_key.",
    "label": "",
    "id": "2250"
  },
  {
    "raw_code": "def validate_check_constraint(table_name, **options)\n          chk_name_to_validate = check_constraint_for!(table_name, **options).name\n\n          validate_constraint table_name, chk_name_to_validate\n        end",
    "comment": "Validates the given check constraint.  validate_check_constraint :products, name: \"price_check\"  The +options+ hash accepts the same keys as {add_check_constraint}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_check_constraint].",
    "label": "",
    "id": "2251"
  },
  {
    "raw_code": "def extract_schema_qualified_name(string)\n          schema, table = string.scan(/[^\".]+|\"[^\"]*\"/)\n          if table.nil?\n            table = schema\n            schema = nil\n          end",
    "comment": "Returns an instance of <tt>ActiveRecord::ConnectionAdapters::PostgreSQL::Name</tt> extracted from +string+. +schema+ is +nil+ if not specified in +string+. +schema+ and +identifier+ exclude surrounding quotes (regardless of whether provided in +string+) +string+ supports the range of schema/table references understood by PostgreSQL, for example:  * <tt>table_name</tt> * <tt>\"table.name\"</tt> * <tt>schema_name.table_name</tt> * <tt>schema_name.\"table.name\"</tt> * <tt>\"schema_name\".table_name</tt> * <tt>\"schema.name\".\"table name\"</tt>",
    "label": "",
    "id": "2252"
  },
  {
    "raw_code": "def changed?(old_value, new_value, _new_value_before_type_cast)\n            !old_value.eql?(new_value) || !old_value.nil? && old_value.prefix != new_value.prefix\n          end",
    "comment": "TODO: Remove when IPAddr#== compares IPAddr#prefix. See https://github.com/ruby/ipaddr/issues/21",
    "label": "",
    "id": "2253"
  },
  {
    "raw_code": "def changed_in_place?(raw_old_value, new_value)\n            deserialize(raw_old_value) != new_value\n          end",
    "comment": "Will compare the Hash equivalents of +raw_old_value+ and +new_value+. By comparing hashes, this avoids an edge case where the order of the keys change between the two hashes, and they would not be marked as equal.",
    "label": "",
    "id": "2254"
  },
  {
    "raw_code": "def unquote(value)\n              if value.start_with?('\"') && value.end_with?('\"')\n                unquoted_value = value[1..-2]\n                unquoted_value.gsub!('\"\"', '\"')\n                unquoted_value.gsub!(\"\\\\\\\\\", \"\\\\\")\n                unquoted_value\n              else\n                value\n              end",
    "comment": "When formatting the bound values of range types, PostgreSQL quotes the bound value using double-quotes in certain conditions. Within a double-quoted string, literal \" and \\ characters are themselves escaped. In input, PostgreSQL accepts multiple escape styles for \" (either \\\" or \"\") but in output always uses \"\". See: * https://www.postgresql.org/docs/current/rangetypes.html#RANGETYPES-IO * https://www.postgresql.org/docs/current/rowtypes.html#ROWTYPES-IO-SYNTAX",
    "label": "",
    "id": "2255"
  },
  {
    "raw_code": "def initialize(delim, subtype)\n            @delim   = delim\n            @subtype = subtype\n          end",
    "comment": "+delim+ corresponds to the `typdelim` column in the pg_types table.  +subtype+ is derived from the `typelem` column in the pg_types table.",
    "label": "",
    "id": "2256"
  },
  {
    "raw_code": "def cast(value)\n            value\n          end",
    "comment": "FIXME: this should probably split on +delim+ and use +subtype+ to cast the values.  Unfortunately, the current Rails behavior is to just return the string.",
    "label": "",
    "id": "2257"
  },
  {
    "raw_code": "def pp(result)\n          result.rows.map do |row|\n            row.join(\"|\")\n          end.join(\"\\n\") + \"\\n\"\n        end",
    "comment": "Pretty prints the result of an EXPLAIN QUERY PLAN in a way that resembles the output of the SQLite shell:  0|0|0|SEARCH TABLE users USING INTEGER PRIMARY KEY (rowid=?) (~1 rows) 0|1|1|SCAN TABLE posts (~100000 rows) ",
    "label": "",
    "id": "2258"
  },
  {
    "raw_code": "def indexes(table_name)\n          internal_exec_query(\"PRAGMA index_list(#{quote_table_name(table_name)})\", \"SCHEMA\").filter_map do |row|\n            # Indexes SQLite creates implicitly for internal use start with \"sqlite_\".\n            # See https://www.sqlite.org/fileformat2.html#intschema\n            next if row[\"name\"].start_with?(\"sqlite_\")\n\n            index_sql = query_value(<<~SQL, \"SCHEMA\")\n              SELECT sql\n              FROM sqlite_master\n              WHERE name = #{quote(row['name'])} AND type = 'index'\n              UNION ALL\n              SELECT sql\n              FROM sqlite_temp_master\n              WHERE name = #{quote(row['name'])} AND type = 'index'\n            SQL\n\n            /\\bON\\b\\s*\"?(\\w+?)\"?\\s*\\((?<expressions>.+?)\\)(?:\\s*WHERE\\b\\s*(?<where>.+))?(?:\\s*\\/\\*.*\\*\\/)?\\z/i =~ index_sql\n\n            columns = internal_exec_query(\"PRAGMA index_info(#{quote(row['name'])})\", \"SCHEMA\").map do |col|\n              col[\"name\"]\n            end",
    "comment": "Returns an array of indexes for the given table.",
    "label": "",
    "id": "2259"
  },
  {
    "raw_code": "def is_column_the_rowid?(field, column_definitions)\n            return false unless INTEGER_REGEX.match?(field[\"type\"]) && field[\"pk\"] == 1\n            # is the primary key a single column?\n            column_definitions.one? { |c| c[\"pk\"] > 0 }\n          end",
    "comment": "if a rowid table has a primary key that consists of a single column and the declared type of that column is \"INTEGER\" in any mixture of upper and lower case, then the column becomes an alias for the rowid.",
    "label": "",
    "id": "2260"
  },
  {
    "raw_code": "def initialize(url)\n        raise \"Database URL cannot be empty\" if url.blank?\n        @uri     = uri_parser.parse(url)\n        @adapter = resolved_adapter\n\n        if @uri.opaque\n          @uri.opaque, @query = @uri.opaque.split(\"?\", 2)\n        else\n          @query = @uri.query\n        end",
    "comment": "== Example  url = \"postgresql://foo:bar@localhost:9000/foo_test?pool=5&timeout=3000\" ConnectionUrlResolver.new(url).to_hash # => { adapter:  \"postgresql\", host:     \"localhost\", port:     9000, database: \"foo_test\", username: \"foo\", password: \"bar\", pool:     \"5\", timeout:  \"3000\" }",
    "label": "",
    "id": "2261"
  },
  {
    "raw_code": "def to_hash\n        config = raw_config.compact_blank\n        config.map { |key, value| config[key] = uri_parser.unescape(value) if value.is_a? String }\n        config\n      end",
    "comment": "Converts the given URL to a full connection hash.",
    "label": "",
    "id": "2262"
  },
  {
    "raw_code": "def query_hash\n          Hash[(@query || \"\").split(\"&\").map { |pair| pair.split(\"=\", 2) }].symbolize_keys\n        end",
    "comment": "Converts the query parameters of the URI into a hash.  \"localhost?pool=5&reaping_frequency=2\" # => { pool: \"5\", reaping_frequency: \"2\" }  returns empty hash if no query present.  \"localhost\" # => {}",
    "label": "",
    "id": "2263"
  },
  {
    "raw_code": "def database_from_path\n          if @adapter == \"sqlite3\"\n            # 'sqlite3:/foo' is absolute, because that makes sense. The\n            # corresponding relative version, 'sqlite3:foo', is handled\n            # elsewhere, as an \"opaque\".\n\n            uri.path\n          else\n            # Only SQLite uses a filename as the \"database\" name; for\n            # anything else, a leading slash would be silly.\n\n            uri.path.delete_prefix(\"/\")\n          end",
    "comment": "Returns name of the database.",
    "label": "",
    "id": "2264"
  },
  {
    "raw_code": "def initialize(env_name, name, configuration_hash)\n        super(env_name, name)\n        @configuration_hash = configuration_hash.symbolize_keys.freeze\n        validate_configuration!\n      end",
    "comment": "Initialize a new `HashConfig` object  #### Parameters  *   `env_name` - The Rails environment, i.e. \"development\". *   `name` - The db config name. In a standard two-tier database configuration this will default to \"primary\". In a multiple database three-tier database configuration this corresponds to the name used in the second tier, for example \"primary_readonly\". *   `configuration_hash` - The config hash. This is the hash that contains the database adapter, name, and other important information for database connections. ",
    "label": "",
    "id": "2265"
  },
  {
    "raw_code": "def replica?\n        configuration_hash[:replica]\n      end",
    "comment": "Determines whether a database configuration is for a replica / readonly connection. If the `replica` key is present in the config, `replica?` will return `true`.",
    "label": "",
    "id": "2266"
  },
  {
    "raw_code": "def migrations_paths\n        configuration_hash[:migrations_paths]\n      end",
    "comment": "The migrations paths for a database configuration. If the `migrations_paths` key is present in the config, `migrations_paths` will return its value.",
    "label": "",
    "id": "2267"
  },
  {
    "raw_code": "def schema_cache_path\n        configuration_hash[:schema_cache_path]\n      end",
    "comment": "The path to the schema cache dump file for a database. If omitted, the filename will be read from ENV or a default will be derived.",
    "label": "",
    "id": "2268"
  },
  {
    "raw_code": "def seeds?\n        configuration_hash.fetch(:seeds, primary?)\n      end",
    "comment": "Determines whether the db:prepare task should seed the database from db/seeds.rb.  If the `seeds` key is present in the config, `seeds?` will return its value.  Otherwise, it will return `true` for the primary database and `false` for all other configs.",
    "label": "",
    "id": "2269"
  },
  {
    "raw_code": "def schema_dump(format = schema_format)\n        if configuration_hash.key?(:schema_dump)\n          if config = configuration_hash[:schema_dump]\n            config\n          end",
    "comment": "Determines whether to dump the schema/structure files and the filename that should be used.  If `configuration_hash[:schema_dump]` is set to `false` or `nil` the schema will not be dumped.  If the config option is set that will be used. Otherwise Rails will generate the filename from the database config name.",
    "label": "",
    "id": "2270"
  },
  {
    "raw_code": "def initialize(env_name, name, url, configuration_hash = {})\n        super(env_name, name, configuration_hash)\n\n        @url = url\n        @configuration_hash = @configuration_hash.merge(build_url_hash)\n\n        if @configuration_hash[:schema_dump] == \"false\"\n          @configuration_hash[:schema_dump] = false\n        end",
    "comment": "Initialize a new +UrlConfig+ object  ==== Options  * <tt>:env_name</tt> - The \\Rails environment, i.e. \"development\". * <tt>:name</tt> - The db config name. In a standard two-tier database configuration this will default to \"primary\". In a multiple database three-tier database configuration this corresponds to the name used in the second tier, for example \"primary_readonly\". * <tt>:url</tt> - The database URL. * <tt>:config</tt> - The config hash. This is the hash that contains the database adapter, name, and other important information for database connections.",
    "label": "",
    "id": "2271"
  },
  {
    "raw_code": "def build_url_hash\n          if url.nil? || url.start_with?(\"jdbc:\", \"http:\", \"https:\")\n            { url: url }\n          else\n            ConnectionUrlResolver.new(url).to_hash\n          end",
    "comment": "Return a Hash that can be merged into the main config that represents the passed in url",
    "label": "",
    "id": "2272"
  },
  {
    "raw_code": "def encrypt(clean_text, key:, deterministic: false)\n        cipher_for(key, deterministic: deterministic).encrypt(clean_text).tap do |message|\n          message.headers.encoding = clean_text.encoding.name unless clean_text.encoding == DEFAULT_ENCODING\n        end",
    "comment": "Encrypts the provided text and return an encrypted +Message+.",
    "label": "",
    "id": "2273"
  },
  {
    "raw_code": "def decrypt(encrypted_message, key:)\n        try_to_decrypt_with_each(encrypted_message, keys: Array(key)).tap do |decrypted_text|\n          decrypted_text.force_encoding(encrypted_message.headers.encoding || DEFAULT_ENCODING)\n        end",
    "comment": "Decrypt the provided +Message+.  When +key+ is an Array, it will try all the keys raising a +ActiveRecord::Encryption::Errors::Decryption+ if none works.",
    "label": "",
    "id": "2274"
  },
  {
    "raw_code": "def previous=(previous_schemes_properties)\n        previous_schemes_properties.each do |properties|\n          add_previous_scheme(**properties)\n        end",
    "comment": "Configure previous encryption schemes.  config.active_record.encryption.previous = [ { key_provider: MyOldKeyProvider.new } ]",
    "label": "",
    "id": "2275"
  },
  {
    "raw_code": "def on_encrypted_attribute_declared(&block)\n          self.encrypted_attribute_declaration_listeners ||= Concurrent::Array.new\n          self.encrypted_attribute_declaration_listeners << block\n        end",
    "comment": "Register callback to be invoked when an encrypted attribute is declared.  === Example  ActiveRecord::Encryption.on_encrypted_attribute_declared do |klass, attribute_name| ... end",
    "label": "",
    "id": "2276"
  },
  {
    "raw_code": "def with_encryption_context(properties)\n          self.custom_contexts ||= []\n          self.custom_contexts << default_context.dup\n          properties.each do |key, value|\n            self.current_custom_context.send(\"#{key}=\", value)\n          end",
    "comment": "Configures a custom encryption context to use when running the provided block of code.  It supports overriding all the properties defined in +Context+.  Example:  ActiveRecord::Encryption.with_encryption_context(encryptor: ActiveRecord::Encryption::NullEncryptor.new) do ... end  Encryption contexts can be nested.",
    "label": "",
    "id": "2277"
  },
  {
    "raw_code": "def without_encryption(&block)\n          with_encryption_context encryptor: ActiveRecord::Encryption::NullEncryptor.new, &block\n        end",
    "comment": "Runs the provided block in an encryption context where encryption is disabled:  * Reading encrypted content will return its ciphertexts. * Writing encrypted content will write its clear text.",
    "label": "",
    "id": "2278"
  },
  {
    "raw_code": "def protecting_encrypted_data(&block)\n          with_encryption_context encryptor: ActiveRecord::Encryption::EncryptingOnlyEncryptor.new, frozen_encryption: true, &block\n        end",
    "comment": "Runs the provided block in an encryption context where:  * Reading encrypted content will return its ciphertext. * Writing encrypted content will fail.",
    "label": "",
    "id": "2279"
  },
  {
    "raw_code": "def context\n          self.current_custom_context || self.default_context\n        end",
    "comment": "Returns the current context. By default it will return the current context.",
    "label": "",
    "id": "2280"
  },
  {
    "raw_code": "def encrypts(*names, key_provider: nil, key: nil, deterministic: false, support_unencrypted_data: nil, downcase: false, ignore_case: false, previous: [], compress: true, compressor: nil, **context_properties)\n          self.encrypted_attributes ||= Set.new # not using :default because the instance would be shared across classes\n\n          names.each do |name|\n            encrypt_attribute name, key_provider: key_provider, key: key, deterministic: deterministic, support_unencrypted_data: support_unencrypted_data, downcase: downcase, ignore_case: ignore_case, previous: previous, compress: compress, compressor: compressor, **context_properties\n          end",
    "comment": "Encrypts the +name+ attribute.  ==== Options  * <tt>:key_provider</tt> - A key provider to provide encryption and decryption keys. Defaults to +ActiveRecord::Encryption.key_provider+. * <tt>:key</tt> - A password to derive the key from. It's a shorthand for a +:key_provider+ that serves derivated keys. Both options can't be used at the same time. * <tt>:deterministic</tt> - By default, encryption is not deterministic. It will use a random initialization vector for each encryption operation. This means that encrypting the same content with the same key twice will generate different ciphertexts. When set to +true+, it will generate the initialization vector based on the encrypted content. This means that the same content will generate the same ciphertexts. This enables querying encrypted text with Active Record. Deterministic encryption will use the oldest encryption scheme to encrypt new data by default. You can change this by setting <tt>deterministic: { fixed: false }</tt>. That will make it use the newest encryption scheme for encrypting new data. * <tt>:support_unencrypted_data</tt> - When true, unencrypted data can be read normally. When false, it will raise errors. Falls back to +config.active_record.encryption.support_unencrypted_data+ if no value is provided. This is useful for scenarios where you encrypt one column, and want to disable support for unencrypted data without having to tweak the global setting. * <tt>:downcase</tt> - When true, it converts the encrypted content to downcase automatically. This allows to effectively ignore case when querying data. Notice that the case is lost. Use +:ignore_case+ if you are interested in preserving it. * <tt>:ignore_case</tt> - When true, it behaves like +:downcase+ but, it also preserves the original case in a specially designated column +original_<name>+. When reading the encrypted content, the version with the original case is served. But you can still execute queries that will ignore the case. This option can only be used when +:deterministic+ is true. * <tt>:context_properties</tt> - Additional properties that will override +Context+ settings when this attribute is encrypted and decrypted. E.g: +encryptor:+, +cipher:+, +message_serializer:+, etc. * <tt>:previous</tt> - List of previous encryption schemes. When provided, they will be used in order when trying to read the attribute. Each entry of the list can contain the properties supported by #encrypts. Also, when deterministic encryption is used, they will be used to generate additional ciphertexts to check in the queries.",
    "label": "",
    "id": "2281"
  },
  {
    "raw_code": "def deterministic_encrypted_attributes\n          @deterministic_encrypted_attributes ||= encrypted_attributes&.find_all do |attribute_name|\n            type_for_attribute(attribute_name).deterministic?\n          end",
    "comment": "Returns the list of deterministic encryptable attributes in the model class.",
    "label": "",
    "id": "2282"
  },
  {
    "raw_code": "def source_attribute_from_preserved_attribute(attribute_name)\n          attribute_name.to_s.sub(ORIGINAL_ATTRIBUTE_PREFIX, \"\") if attribute_name.start_with?(ORIGINAL_ATTRIBUTE_PREFIX)\n        end",
    "comment": "Given a attribute name, it returns the name of the source attribute when it's a preserved one.",
    "label": "",
    "id": "2283"
  },
  {
    "raw_code": "def encrypted_attribute?(attribute_name)\n        name = attribute_name.to_s\n        name = self.class.attribute_aliases[name] || name\n\n        return false unless self.class.encrypted_attributes&.include? name.to_sym\n\n        type = type_for_attribute(name)\n        type.encrypted? read_attribute_before_type_cast(name)\n      end",
    "comment": "Returns whether a given attribute is encrypted or not.",
    "label": "",
    "id": "2284"
  },
  {
    "raw_code": "def ciphertext_for(attribute_name)\n        if encrypted_attribute?(attribute_name)\n          read_attribute_before_type_cast(attribute_name)\n        else\n          read_attribute_for_database(attribute_name)\n        end",
    "comment": "Returns the ciphertext for +attribute_name+.",
    "label": "",
    "id": "2285"
  },
  {
    "raw_code": "def encrypt\n        encrypt_attributes if has_encrypted_attributes?\n      end",
    "comment": "Encrypts all the encryptable attributes and saves the changes.",
    "label": "",
    "id": "2286"
  },
  {
    "raw_code": "def decrypt\n        decrypt_attributes if has_encrypted_attributes?\n      end",
    "comment": "Decrypts all the encryptable attributes and saves the changes.",
    "label": "",
    "id": "2287"
  },
  {
    "raw_code": "def initialize(scheme:, cast_type: ActiveModel::Type::String.new, previous_type: false, default: nil)\n        super()\n        @scheme = scheme\n        @cast_type = cast_type\n        @previous_type = previous_type\n        @default = default\n      end",
    "comment": "==== Options  * <tt>:scheme</tt> - A +Scheme+ with the encryption properties for this attribute. * <tt>:cast_type</tt> - A type that will be used to serialize (before encrypting) and deserialize (after decrypting). ActiveModel::Type::String by default.",
    "label": "",
    "id": "2288"
  },
  {
    "raw_code": "def initialize(compress: true, compressor: nil)\n        @compress = compress\n        @compressor = compressor || ActiveRecord::Encryption.config.compressor\n      end",
    "comment": "==== Options  [+:compress+] Boolean indicating whether records should be compressed before encryption. Defaults to +true+.  [+:compressor+] The compressor to use. It must respond to +deflate+ and +inflate+. If not provided, will default to +ActiveRecord::Encryption.config.compressor+, which itself defaults to +Zlib+.",
    "label": "",
    "id": "2289"
  },
  {
    "raw_code": "def encrypt(clear_text, key_provider: default_key_provider, cipher_options: {})\n        clear_text = force_encoding_if_needed(clear_text) if cipher_options[:deterministic]\n\n        validate_payload_type(clear_text)\n        serialize_message build_encrypted_message(clear_text, key_provider: key_provider, cipher_options: cipher_options)\n      end",
    "comment": "Encrypts +clean_text+ and returns the encrypted result.  Internally, it will:  1. Create a new ActiveRecord::Encryption::Message. 2. Compress and encrypt +clean_text+ as the message payload. 3. Serialize it with +ActiveRecord::Encryption.message_serializer+ (+ActiveRecord::Encryption::SafeMarshal+ by default). 4. Encode the result with Base64.  ==== Options  [+:key_provider+] Key provider to use for the encryption operation. It will default to +ActiveRecord::Encryption.key_provider+ when not provided.  [+:cipher_options+] Cipher-specific options that will be passed to the Cipher configured in +ActiveRecord::Encryption.cipher+.",
    "label": "",
    "id": "2290"
  },
  {
    "raw_code": "def decrypt(encrypted_text, key_provider: default_key_provider, cipher_options: {})\n        message = deserialize_message(encrypted_text)\n        keys = key_provider.decryption_keys(message)\n        raise Errors::Decryption unless keys.present?\n        uncompress_if_needed(cipher.decrypt(message, key: keys.collect(&:secret), **cipher_options), message.headers.compressed)\n      rescue *(ENCODING_ERRORS + DECRYPT_ERRORS)\n        raise Errors::Decryption\n      end",
    "comment": "Decrypts an +encrypted_text+ and returns the result as clean text.  ==== Options  [+:key_provider+] Key provider to use for the encryption operation. It will default to +ActiveRecord::Encryption.key_provider+ when not provided.  [+:cipher_options+] Cipher-specific options that will be passed to the Cipher configured in +ActiveRecord::Encryption.cipher+.",
    "label": "",
    "id": "2291"
  },
  {
    "raw_code": "def encrypted?(text)\n        deserialize_message(text)\n        true\n      rescue Errors::Encoding, *DECRYPT_ERRORS\n        false\n      end",
    "comment": "Returns whether the text is encrypted or not.",
    "label": "",
    "id": "2292"
  },
  {
    "raw_code": "def compress_if_worth_it(string)\n          if compress? && string.bytesize > THRESHOLD_TO_JUSTIFY_COMPRESSION\n            [compress(string), true]\n          else\n            [string, false]\n          end",
    "comment": "Under certain threshold, ZIP compression is actually worse that not compressing",
    "label": "",
    "id": "2293"
  },
  {
    "raw_code": "def generate_random_key(length: key_length)\n        SecureRandom.random_bytes(length)\n      end",
    "comment": "Returns a random key. The key will have a size in bytes of +:length+ (configured +Cipher+'s length by default)",
    "label": "",
    "id": "2294"
  },
  {
    "raw_code": "def generate_random_hex_key(length: key_length)\n        generate_random_key(length: length).unpack(\"H*\")[0]\n      end",
    "comment": "Returns a random key in hexadecimal format. The key will have a size in bytes of +:length+ (configured +Cipher+'s length by default)  Hexadecimal format is handy for representing keys as printable text. To maximize the space of characters used, it is good practice including not printable characters. Hexadecimal format ensures that generated keys are representable with plain text  To convert back to the original string with the desired length:  [ value ].pack(\"H*\")",
    "label": "",
    "id": "2295"
  },
  {
    "raw_code": "def derive_key_from(password, length: key_length)\n        ActiveSupport::KeyGenerator.new(password, hash_digest_class: hash_digest_class)\n          .generate_key(key_derivation_salt, length)\n      end",
    "comment": "Derives a key from the given password. The key will have a size in bytes of +:length+ (configured +Cipher+'s length by default)  The generated key will be salted with the value of +ActiveRecord::Encryption.key_derivation_salt+",
    "label": "",
    "id": "2296"
  },
  {
    "raw_code": "def encryption_key\n        @encryption_key ||= @keys.last.tap do |key|\n          key.public_tags.encrypted_data_key_id = key.id if ActiveRecord::Encryption.config.store_key_references\n        end",
    "comment": "Returns the last key in the list as the active key to perform encryptions  When +ActiveRecord::Encryption.config.store_key_references+ is true, the key will include a public tag referencing the key itself. That key will be stored in the public headers of the encrypted message",
    "label": "",
    "id": "2297"
  },
  {
    "raw_code": "def decryption_keys(encrypted_message)\n        if encrypted_message.headers.encrypted_data_key_id\n          keys_grouped_by_id[encrypted_message.headers.encrypted_data_key_id]\n        else\n          @keys\n        end",
    "comment": "Returns the list of decryption keys  When the message holds a reference to its encryption key, it will return an array with that key. If not, it will return the list of keys.",
    "label": "",
    "id": "2298"
  },
  {
    "raw_code": "def []=(key, value)\n        raise Errors::EncryptedContentIntegrity, \"Properties can't be overridden: #{key}\" if key?(key)\n        validate_value_type(value)\n        data[key] = value\n      end",
    "comment": "Set a value for a given key  It will raise an +EncryptedContentIntegrity+ if the value exists",
    "label": "",
    "id": "2299"
  },
  {
    "raw_code": "def initialize(secret, deterministic: false)\n          @secret = secret\n          @deterministic = deterministic\n        end",
    "comment": "When iv not provided, it will generate a random iv on each encryption operation (default and recommended operation)",
    "label": "",
    "id": "2300"
  },
  {
    "raw_code": "def self.open(file)\n        x = new file\n        block_given? ? yield(x) : x\n      end",
    "comment": " Open a fixture file named +file+.  When called with a block, the block is called with the filehandle and the filehandle is automatically closed when the block finishes.",
    "label": "",
    "id": "2301"
  },
  {
    "raw_code": "def validate(data)\n          unless Hash === data || YAML::Omap === data\n            raise Fixture::FormatError, \"fixture is not a hash: #{@file}\"\n          end",
    "comment": "Validate our unmarshalled data.",
    "label": "",
    "id": "2302"
  },
  {
    "raw_code": "def locking_enabled?\n            lock_optimistically && columns_hash[locking_column]\n          end",
    "comment": "Returns true if the +lock_optimistically+ flag is set to true (which it is, by default) and the table includes the +locking_column+ column (defaults to +lock_version+).",
    "label": "",
    "id": "2303"
  },
  {
    "raw_code": "def locking_column=(value)\n            reload_schema_from_cache\n            @locking_column = value.to_s\n          end",
    "comment": "Set the column to use for optimistic locking. Defaults to +lock_version+.",
    "label": "",
    "id": "2304"
  },
  {
    "raw_code": "def reset_locking_column\n            self.locking_column = DEFAULT_LOCKING_COLUMN\n          end",
    "comment": "Reset the column used for optimistic locking back to the +lock_version+ default.",
    "label": "",
    "id": "2305"
  },
  {
    "raw_code": "def update_counters(id, counters)\n            counters = counters.merge(locking_column => 1) if locking_enabled?\n            super\n          end",
    "comment": "Make sure the lock version column gets updated when counters are updated.",
    "label": "",
    "id": "2306"
  },
  {
    "raw_code": "def lock!(lock = true)\n        if self.class.current_preventing_writes\n          raise ActiveRecord::ReadOnlyError, \"Lock query attempted while in readonly mode\"\n        end",
    "comment": "Obtain a row lock on this record. Reloads the record to obtain the requested lock. Pass an SQL locking clause to append the end of the SELECT statement or pass true for \"FOR UPDATE\" (the default, an exclusive row lock). Returns the locked record.",
    "label": "",
    "id": "2307"
  },
  {
    "raw_code": "def with_lock(*args)\n        transaction_opts = args.extract_options!\n        lock = args.present? ? args.first : true\n        transaction(**transaction_opts) do\n          lock!(lock)\n          yield\n        end",
    "comment": "Wraps the passed block in a transaction, reloading the object with a lock before yielding. You can pass the SQL locking clause as an optional argument (see #lock!).  You can also pass options like <tt>requires_new:</tt>, <tt>isolation:</tt>, and <tt>joinable:</tt> to the wrapping transaction (see ActiveRecord::ConnectionAdapters::DatabaseStatements#transaction).",
    "label": "",
    "id": "2308"
  },
  {
    "raw_code": "def call(env)\n        request = ActionDispatch::Request.new(env)\n\n        select_database(request) do\n          @app.call(env)\n        end",
    "comment": "Middleware that determines which database connection to use in a multiple database application.",
    "label": "",
    "id": "2309"
  },
  {
    "raw_code": "def self.convert_time_to_timestamp(time)\n            time.to_i * 1000 + time.usec / 1000\n          end",
    "comment": "Converts time to a timestamp that represents milliseconds since epoch.",
    "label": "",
    "id": "2310"
  },
  {
    "raw_code": "def self.convert_timestamp_to_time(timestamp)\n            timestamp ? Time.at(timestamp / 1000, (timestamp % 1000) * 1000) : Time.at(0)\n          end",
    "comment": "Converts milliseconds since epoch timestamp into a time object.",
    "label": "",
    "id": "2311"
  },
  {
    "raw_code": "def revert\n        @reverting = !@reverting\n        previous = @commands\n        @commands = []\n        yield\n      ensure\n        @commands = previous.concat(@commands.reverse)\n        @reverting = !@reverting\n      end",
    "comment": "While executing the given block, the recorded will be in reverting mode. All commands recorded will end up being recorded reverted and in reverse order. For example:  recorder.revert{ recorder.record(:rename_table, [:old, :new]) } # same effect as recorder.record(:rename_table, [:new, :old])",
    "label": "",
    "id": "2312"
  },
  {
    "raw_code": "def record(*command, &block)\n        if @reverting\n          @commands << inverse_of(*command, &block)\n        else\n          @commands << (command << block)\n        end",
    "comment": "Record +command+. +command+ should be a method name and arguments. For example:  recorder.record(:method_name, [:arg1, :arg2])",
    "label": "",
    "id": "2313"
  },
  {
    "raw_code": "def inverse_of(command, args, &block)\n        method = :\"invert_#{command}\"\n        raise IrreversibleMigration, <<~MSG unless respond_to?(method, true)\n          This migration uses #{command}, which is not automatically reversible.\n          To make the migration reversible you can either:\n          1. Define #up and #down methods in place of the #change method.\n          2. Use the #reversible method to define reversible behavior.\n        MSG\n        send(method, args, &block)\n      end",
    "comment": "Returns the inverse of the given command. For example:  recorder.inverse_of(:rename_table, [:old, :new]) # => [:rename_table, [:new, :old]]  If the inverse of a command requires several commands, returns array of commands.  recorder.inverse_of(:remove_columns, [:some_table, :foo, :bar, type: :string]) # => [[:add_column, :some_table, :foo, :string], [:add_column, :some_table, :bar, :string]]  This method will raise an +IrreversibleMigration+ exception if it cannot invert the +command+.",
    "label": "",
    "id": "2314"
  },
  {
    "raw_code": "def method_missing(method, ...)\n          if delegate.respond_to?(method)\n            delegate.public_send(method, ...)\n          else\n            super\n          end",
    "comment": "Forwards any missing method call to the \\target.",
    "label": "",
    "id": "2315"
  },
  {
    "raw_code": "def find_each(start: nil, finish: nil, batch_size: 1000, error_on_ignore: nil, cursor: primary_key, order: DEFAULT_ORDER, &block)\n      if block_given?\n        find_in_batches(start: start, finish: finish, batch_size: batch_size, error_on_ignore: error_on_ignore, cursor: cursor, order: order) do |records|\n          records.each(&block)\n        end",
    "comment": "Looping through a collection of records from the database (using the Scoping::Named::ClassMethods.all method, for example) is very inefficient since it will try to instantiate all the objects at once.  In that case, batch processing methods allow you to work with the records in batches, thereby greatly reducing memory consumption.  The #find_each method uses #find_in_batches with a batch size of 1000 (or as specified by the +:batch_size+ option).  Person.find_each do |person| person.do_awesome_stuff end  Person.where(\"age > 21\").find_each do |person| person.party_all_night! end  If you do not provide a block to #find_each, it will return an Enumerator for chaining with other methods:  Person.find_each.with_index do |person, index| person.award_trophy(index + 1) end  ==== Options * <tt>:batch_size</tt> - Specifies the size of the batch. Defaults to 1000. * <tt>:start</tt> - Specifies the cursor column value to start from, inclusive of the value. * <tt>:finish</tt> - Specifies the cursor column value to end at, inclusive of the value. * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when an order is present in the relation. * <tt>:cursor</tt> - Specifies the column to use for batching (can be a column name or an array of column names). Defaults to primary key. * <tt>:order</tt> - Specifies the cursor column order (can be +:asc+ or +:desc+ or an array consisting of :asc or :desc). Defaults to +:asc+.  class Order < ActiveRecord::Base self.primary_key = [:id_1, :id_2] end  Order.find_each(order: [:asc, :desc])  In the above code, +id_1+ is sorted in ascending order and +id_2+ in descending order.  Limits are honored, and if present there is no requirement for the batch size: it can be less than, equal to, or greater than the limit.  The options +start+ and +finish+ are especially useful if you want multiple workers dealing with the same processing queue. You can make worker 1 handle all the records between id 1 and 9999 and worker 2 handle from 10000 and beyond by setting the +:start+ and +:finish+ option on each worker.  # In worker 1, let's process until 9999 records. Person.find_each(finish: 9_999) do |person| person.party_all_night! end  # In worker 2, let's process from record 10_000 and onwards. Person.find_each(start: 10_000) do |person| person.party_all_night! end  NOTE: Order can be ascending (:asc) or descending (:desc). It is automatically set to ascending on the primary key (\"id ASC\"). This also means that this method only works when the cursor column is orderable (e.g. an integer or string).  NOTE: When using custom columns for batching, they should include at least one unique column (e.g. primary key) as a tiebreaker. Also, to reduce the likelihood of race conditions, all columns should be static (unchangeable after it was set).  NOTE: By its nature, batch processing is subject to race conditions if other processes are modifying the database.",
    "label": "",
    "id": "2316"
  },
  {
    "raw_code": "def find_in_batches(start: nil, finish: nil, batch_size: 1000, error_on_ignore: nil, cursor: primary_key, order: DEFAULT_ORDER)\n      relation = self\n      unless block_given?\n        return to_enum(:find_in_batches, start: start, finish: finish, batch_size: batch_size, error_on_ignore: error_on_ignore, cursor: cursor, order: order) do\n          cursor = Array(cursor)\n          total = apply_limits(relation, cursor, start, finish, build_batch_orders(cursor, order)).size\n          (total - 1).div(batch_size) + 1\n        end",
    "comment": "Yields each batch of records that was found by the find options as an array.  Person.where(\"age > 21\").find_in_batches do |group| sleep(50) # Make sure it doesn't get too crowded in there! group.each { |person| person.party_all_night! } end  If you do not provide a block to #find_in_batches, it will return an Enumerator for chaining with other methods:  Person.find_in_batches.with_index do |group, batch| puts \"Processing group ##{batch}\" group.each(&:recover_from_last_night!) end  To be yielded each record one by one, use #find_each instead.  ==== Options * <tt>:batch_size</tt> - Specifies the size of the batch. Defaults to 1000. * <tt>:start</tt> - Specifies the cursor column value to start from, inclusive of the value. * <tt>:finish</tt> - Specifies the cursor column value to end at, inclusive of the value. * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when an order is present in the relation. * <tt>:cursor</tt> - Specifies the column to use for batching (can be a column name or an array of column names). Defaults to primary key. * <tt>:order</tt> - Specifies the cursor column order (can be +:asc+ or +:desc+ or an array consisting of :asc or :desc). Defaults to +:asc+.  class Order < ActiveRecord::Base self.primary_key = [:id_1, :id_2] end  Order.find_in_batches(order: [:asc, :desc])  In the above code, +id_1+ is sorted in ascending order and +id_2+ in descending order.  Limits are honored, and if present there is no requirement for the batch size: it can be less than, equal to, or greater than the limit.  The options +start+ and +finish+ are especially useful if you want multiple workers dealing with the same processing queue. You can make worker 1 handle all the records between id 1 and 9999 and worker 2 handle from 10000 and beyond by setting the +:start+ and +:finish+ option on each worker.  # Let's process from record 10_000 on. Person.find_in_batches(start: 10_000) do |group| group.each { |person| person.party_all_night! } end  NOTE: Order can be ascending (:asc) or descending (:desc). It is automatically set to ascending on the primary key (\"id ASC\"). This also means that this method only works when the cursor column is orderable (e.g. an integer or string).  NOTE: When using custom columns for batching, they should include at least one unique column (e.g. primary key) as a tiebreaker. Also, to reduce the likelihood of race conditions, all columns should be static (unchangeable after it was set).  NOTE: By its nature, batch processing is subject to race conditions if other processes are modifying the database.",
    "label": "",
    "id": "2317"
  },
  {
    "raw_code": "def in_batches(of: 1000, start: nil, finish: nil, load: false, error_on_ignore: nil, cursor: primary_key, order: DEFAULT_ORDER, use_ranges: nil, &block)\n      cursor = Array(cursor).map(&:to_s)\n      ensure_valid_options_for_batching!(cursor, start, finish, order)\n\n      if arel.orders.present?\n        act_on_ignored_order(error_on_ignore)\n      end",
    "comment": "Yields ActiveRecord::Relation objects to work with a batch of records.  Person.where(\"age > 21\").in_batches do |relation| relation.delete_all sleep(10) # Throttle the delete queries end  If you do not provide a block to #in_batches, it will return a BatchEnumerator which is enumerable.  Person.in_batches.each_with_index do |relation, batch_index| puts \"Processing relation ##{batch_index}\" relation.delete_all end  Examples of calling methods on the returned BatchEnumerator object:  Person.in_batches.delete_all Person.in_batches.update_all(awesome: true) Person.in_batches.each_record(&:party_all_night!)  ==== Options * <tt>:of</tt> - Specifies the size of the batch. Defaults to 1000. * <tt>:load</tt> - Specifies if the relation should be loaded. Defaults to false. * <tt>:start</tt> - Specifies the cursor column value to start from, inclusive of the value. * <tt>:finish</tt> - Specifies the cursor column value to end at, inclusive of the value. * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when an order is present in the relation. * <tt>:cursor</tt> - Specifies the column to use for batching (can be a column name or an array of column names). Defaults to primary key. * <tt>:order</tt> - Specifies the cursor column order (can be +:asc+ or +:desc+ or an array consisting of :asc or :desc). Defaults to +:asc+.  class Order < ActiveRecord::Base self.primary_key = [:id_1, :id_2] end  Order.in_batches(order: [:asc, :desc])  In the above code, +id_1+ is sorted in ascending order and +id_2+ in descending order.  * <tt>:use_ranges</tt> - Specifies whether to use range iteration (id >= x AND id <= y). It can make iterating over the whole or almost whole tables several times faster. Only whole table iterations use this style of iteration by default. You can disable this behavior by passing +false+. If you iterate over the table and the only condition is, e.g., <tt>archived_at: nil</tt> (and only a tiny fraction of the records are archived), it makes sense to opt in to this approach.  Limits are honored, and if present there is no requirement for the batch size, it can be less than, equal, or greater than the limit.  The options +start+ and +finish+ are especially useful if you want multiple workers dealing with the same processing queue. You can make worker 1 handle all the records between id 1 and 9999 and worker 2 handle from 10000 and beyond by setting the +:start+ and +:finish+ option on each worker.  # Let's process from record 10_000 on. Person.in_batches(start: 10_000).update_all(awesome: true)  An example of calling where query method on the relation:  Person.in_batches.each do |relation| relation.update_all('age = age + 1') relation.where('age > 21').update_all(should_party: true) relation.where('age <= 21').delete_all end  NOTE: If you are going to iterate through each record, you should call #each_record on the yielded BatchEnumerator:  Person.in_batches.each_record(&:party_all_night!)  NOTE: Order can be ascending (:asc) or descending (:desc). It is automatically set to ascending on the primary key (\"id ASC\"). This also means that this method only works when the cursor column is orderable (e.g. an integer or string).  NOTE: When using custom columns for batching, they should include at least one unique column (e.g. primary key) as a tiebreaker. Also, to reduce the likelihood of race conditions, all columns should be static (unchangeable after it was set).  NOTE: By its nature, batch processing is subject to race conditions if other processes are modifying the database.",
    "label": "",
    "id": "2318"
  },
  {
    "raw_code": "def compare_values_for_order(values1, values2, order)\n        values1.each_with_index do |element1, index|\n          element2 = values2[index]\n          direction = order[index]\n          comparison = element1 <=> element2\n          comparison = -comparison if direction == :desc\n          return comparison if comparison != 0\n        end",
    "comment": "This is a custom implementation of `<=>` operator, which also takes into account how the collection will be ordered.",
    "label": "",
    "id": "2319"
  },
  {
    "raw_code": "def column_alias_for(field)\n          column_alias = +field\n          column_alias.gsub!(/\\*/, \"all\")\n          column_alias.gsub!(/\\W+/, \" \")\n          column_alias.strip!\n          column_alias.gsub!(/ +/, \"_\")\n          @connection.table_alias_for(column_alias)\n        end",
    "comment": "Converts the given field to the value that the database adapter returns as a usable column name:  column_alias_for(\"users.id\")                 # => \"users_id\" column_alias_for(\"sum(id)\")                  # => \"sum_id\" column_alias_for(\"count(distinct users.id)\") # => \"count_distinct_users_id\" column_alias_for(\"count(*)\")                 # => \"count_all\"",
    "label": "",
    "id": "2320"
  },
  {
    "raw_code": "def count(column_name = nil)\n      if block_given?\n        unless column_name.nil?\n          raise ArgumentError, \"Column name argument is not supported when a block is passed.\"\n        end",
    "comment": "Count the records.  Person.count # => the total count of all people  Person.count(:age) # => returns the total count of all people whose age is present in database  Person.count(:all) # => performs a COUNT(*) (:all is an alias for '*')  Person.distinct.count(:age) # => counts the number of different age values  If +count+ is used with {Relation#group}[rdoc-ref:QueryMethods#group], it returns a Hash whose keys represent the aggregated column, and the values are the respective amounts:  Person.group(:city).count # => { 'Rome' => 5, 'Paris' => 3 }  If +count+ is used with {Relation#group}[rdoc-ref:QueryMethods#group] for multiple columns, it returns a Hash whose keys are an array containing the individual values of each column and the value of each key would be the count.  Article.group(:status, :category).count # =>  {[\"draft\", \"business\"]=>10, [\"draft\", \"technology\"]=>4, [\"published\", \"technology\"]=>2}  If +count+ is used with {Relation#select}[rdoc-ref:QueryMethods#select], it will count the selected columns:  Person.select(:age).count # => counts the number of different age values  Note: not all valid {Relation#select}[rdoc-ref:QueryMethods#select] expressions are valid +count+ expressions. The specifics differ between databases. In invalid cases, an error from the database is thrown.  When given a block, calls the block with each record in the relation and returns the number of records for which the block returns a truthy value.  Person.count { |person| person.age > 21 } # => counts the number of people older that 21  If the relation hasn't been loaded yet, calling +count+ with a block will load all records in the relation. If there are a lot of records in the relation, loading all records could result in performance issues.",
    "label": "",
    "id": "2321"
  },
  {
    "raw_code": "def async_count(column_name = nil)\n      async.count(column_name)\n    end",
    "comment": "Same as #count, but performs the query asynchronously and returns an ActiveRecord::Promise.",
    "label": "",
    "id": "2322"
  },
  {
    "raw_code": "def average(column_name)\n      calculate(:average, column_name)\n    end",
    "comment": "Calculates the average value on a given column. Returns +nil+ if there's no row. See #calculate for examples with options.  Person.average(:age) # => 35.8",
    "label": "",
    "id": "2323"
  },
  {
    "raw_code": "def async_average(column_name)\n      async.average(column_name)\n    end",
    "comment": "Same as #average, but performs the query asynchronously and returns an ActiveRecord::Promise.",
    "label": "",
    "id": "2324"
  },
  {
    "raw_code": "def minimum(column_name)\n      calculate(:minimum, column_name)\n    end",
    "comment": "Calculates the minimum value on a given column. The value is returned with the same data type of the column, or +nil+ if there's no row. See #calculate for examples with options.  Person.minimum(:age) # => 7",
    "label": "",
    "id": "2325"
  },
  {
    "raw_code": "def async_minimum(column_name)\n      async.minimum(column_name)\n    end",
    "comment": "Same as #minimum, but performs the query asynchronously and returns an ActiveRecord::Promise.",
    "label": "",
    "id": "2326"
  },
  {
    "raw_code": "def maximum(column_name)\n      calculate(:maximum, column_name)\n    end",
    "comment": "Calculates the maximum value on a given column. The value is returned with the same data type of the column, or +nil+ if there's no row. See #calculate for examples with options.  Person.maximum(:age) # => 93",
    "label": "",
    "id": "2327"
  },
  {
    "raw_code": "def async_maximum(column_name)\n      async.maximum(column_name)\n    end",
    "comment": "Same as #maximum, but performs the query asynchronously and returns an ActiveRecord::Promise.",
    "label": "",
    "id": "2328"
  },
  {
    "raw_code": "def sum(initial_value_or_column = 0, &block)\n      if block_given?\n        map(&block).sum(initial_value_or_column)\n      else\n        calculate(:sum, initial_value_or_column)\n      end",
    "comment": "Calculates the sum of values on a given column. The value is returned with the same data type of the column, +0+ if there's no row. See #calculate for examples with options.  Person.sum(:age) # => 4562  When given a block, calls the block with each record in the relation and returns the sum of +initial_value_or_column+ plus the block return values:  Person.sum { |person| person.age } # => 4562 Person.sum(1000) { |person| person.age } # => 5562  If the relation hasn't been loaded yet, calling +sum+ with a block will load all records in the relation. If there are a lot of records in the relation, loading all records could result in performance issues.",
    "label": "",
    "id": "2329"
  },
  {
    "raw_code": "def async_sum(identity_or_column = nil)\n      async.sum(identity_or_column)\n    end",
    "comment": "Same as #sum, but performs the query asynchronously and returns an ActiveRecord::Promise.",
    "label": "",
    "id": "2330"
  },
  {
    "raw_code": "def calculate(operation, column_name)\n      operation = operation.to_s.downcase\n\n      if @none\n        case operation\n        when \"count\", \"sum\"\n          result = group_values.any? ? Hash.new : 0\n          return @async ? Promise::Complete.new(result) : result\n        when \"average\", \"minimum\", \"maximum\"\n          result = group_values.any? ? Hash.new : nil\n          return @async ? Promise::Complete.new(result) : result\n        end",
    "comment": "This calculates aggregate values in the given column. Methods for #count, #sum, #average, #minimum, and #maximum have been added as shortcuts.  Person.calculate(:count, :all) # The same as Person.count Person.average(:age) # SELECT AVG(age) FROM people...  # Selects the minimum age for any family without any minors Person.group(:last_name).having(\"min(age) > 17\").minimum(:age)  Person.sum(\"2 * age\")  There are two basic forms of output:  * Single aggregate value: The single value is type cast to Integer for COUNT, Float for AVG, and the given column's type for everything else.  * Grouped values: This returns an ordered hash of the values and groups them. It takes either a column name, or the name of a belongs_to association.  values = Person.group('last_name').maximum(:age) puts values[\"Drake\"] # => 43  drake  = Family.find_by(last_name: 'Drake') values = Person.group(:family).maximum(:age) # Person belongs_to :family puts values[drake] # => 43  values.each do |family, max_age| ... end",
    "label": "",
    "id": "2331"
  },
  {
    "raw_code": "def pluck(*column_names)\n      if @none\n        if @async\n          return Promise::Complete.new([])\n        else\n          return []\n        end",
    "comment": "Use #pluck as a shortcut to select one or more attributes without loading an entire record object per row.  Person.pluck(:name)  instead of  Person.all.map(&:name)  Pluck returns an Array of attribute values type-casted to match the plucked column names, if they can be deduced. Plucking an SQL fragment returns String values by default.  Person.pluck(:name) # SELECT people.name FROM people # => ['David', 'Jeremy', 'Jose']  Person.pluck(:id, :name) # SELECT people.id, people.name FROM people # => [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]  Person.distinct.pluck(:role) # SELECT DISTINCT role FROM people # => ['admin', 'member', 'guest']  Person.where(age: 21).limit(5).pluck(:id) # SELECT people.id FROM people WHERE people.age = 21 LIMIT 5 # => [2, 3]  Comment.joins(:person).pluck(:id, person: :id) # SELECT comments.id, person.id FROM comments INNER JOIN people person ON person.id = comments.person_id # => [[1, 2], [2, 2]]  Comment.joins(:person).pluck(:id, person: [:id, :name]) # SELECT comments.id, person.id, person.name FROM comments INNER JOIN people person ON person.id = comments.person_id # => [[1, 2, 'David'], [2, 2, 'David']]  Person.pluck(Arel.sql('DATEDIFF(updated_at, created_at)')) # SELECT DATEDIFF(updated_at, created_at) FROM people # => ['0', '27761', '173']  Be aware that #pluck ignores any previous select clauses  Person.select(:name).pluck(:id) # SELECT people.id FROM people  See also #ids.",
    "label": "",
    "id": "2332"
  },
  {
    "raw_code": "def async_pluck(*column_names)\n      async.pluck(*column_names)\n    end",
    "comment": "Same as #pluck, but performs the query asynchronously and returns an ActiveRecord::Promise.",
    "label": "",
    "id": "2333"
  },
  {
    "raw_code": "def pick(*column_names)\n      if loaded? && all_attributes?(column_names)\n        result = records.pick(*column_names)\n        return @async ? Promise::Complete.new(result) : result\n      end",
    "comment": "Pick the value(s) from the named column(s) in the current relation. This is short-hand for <tt>relation.limit(1).pluck(*column_names).first</tt>, and is primarily useful when you have a relation that's already narrowed down to a single row.  Just like #pluck, #pick will only load the actual value, not the entire record object, so it's also more efficient. The value is, again like with pluck, typecast by the column type.  Person.where(id: 1).pick(:name) # SELECT people.name FROM people WHERE id = 1 LIMIT 1 # => 'David'  Person.where(id: 1).pick(:name, :email_address) # SELECT people.name, people.email_address FROM people WHERE id = 1 LIMIT 1 # => [ 'David', 'david@loudthinking.com' ]",
    "label": "",
    "id": "2334"
  },
  {
    "raw_code": "def async_pick(*column_names)\n      async.pick(*column_names)\n    end",
    "comment": "Same as #pick, but performs the query asynchronously and returns an ActiveRecord::Promise.",
    "label": "",
    "id": "2335"
  },
  {
    "raw_code": "def ids\n      primary_key_array = Array(primary_key)\n\n      if loaded?\n        result = records.map do |record|\n          if primary_key_array.one?\n            record._read_attribute(primary_key_array.first)\n          else\n            primary_key_array.map { |column| record._read_attribute(column) }\n          end",
    "comment": "Returns the base model's ID's for the relation using the table's primary key  Person.ids # SELECT people.id FROM people Person.joins(:company).ids # SELECT people.id FROM people INNER JOIN companies ON companies.id = people.company_id",
    "label": "",
    "id": "2336"
  },
  {
    "raw_code": "def async_ids\n      async.ids\n    end",
    "comment": "Same as #ids, but performs the query asynchronously and returns an ActiveRecord::Promise.",
    "label": "",
    "id": "2337"
  },
  {
    "raw_code": "def find(*args)\n      return super if block_given?\n      find_with_ids(*args)\n    end",
    "comment": "Find by id - This can either be a specific id (ID), a list of ids (ID, ID, ID), or an array of ids ([ID, ID, ID]). `ID` refers to an \"identifier\". For models with a single-column primary key, `ID` will be a single value, and for models with a composite primary key, it will be an array of values. If one or more records cannot be found for the requested ids, then ActiveRecord::RecordNotFound will be raised. If the primary key is an integer, find by id coerces its arguments by using +to_i+.  Person.find(1)          # returns the object for ID = 1 Person.find(\"1\")        # returns the object for ID = 1 Person.find(\"31-sarah\") # returns the object for ID = 31 Person.find(1, 2, 6)    # returns an array for objects with IDs in (1, 2, 6) Person.find([7, 17])    # returns an array for objects with IDs in (7, 17), or with composite primary key [7, 17] Person.find([1])        # returns an array for the object with ID = 1 Person.where(\"administrator = 1\").order(\"created_on DESC\").find(1)  ==== Find a record for a composite primary key model TravelRoute.primary_key = [:origin, :destination]  TravelRoute.find([\"Ottawa\", \"London\"]) # => #<TravelRoute origin: \"Ottawa\", destination: \"London\">  TravelRoute.find([[\"Paris\", \"Montreal\"]]) # => [#<TravelRoute origin: \"Paris\", destination: \"Montreal\">]  TravelRoute.find([\"New York\", \"Las Vegas\"], [\"New York\", \"Portland\"]) # => [ #      #<TravelRoute origin: \"New York\", destination: \"Las Vegas\">, #      #<TravelRoute origin: \"New York\", destination: \"Portland\"> #    ]  TravelRoute.find([[\"Berlin\", \"London\"], [\"Barcelona\", \"Lisbon\"]]) # => [ #      #<TravelRoute origin: \"Berlin\", destination: \"London\">, #      #<TravelRoute origin: \"Barcelona\", destination: \"Lisbon\"> #    ]  NOTE: The returned records are in the same order as the ids you provide. If you want the results to be sorted by database, you can use ActiveRecord::QueryMethods#where method and provide an explicit ActiveRecord::QueryMethods#order option. But ActiveRecord::QueryMethods#where method doesn't raise ActiveRecord::RecordNotFound.  ==== Find with lock  Example for find with a lock: Imagine two concurrent transactions: each will read <tt>person.visits == 2</tt>, add 1 to it, and save, resulting in two saves of <tt>person.visits = 3</tt>. By locking the row, the second transaction has to wait until the first is finished; we get the expected <tt>person.visits == 4</tt>.  Person.transaction do person = Person.lock(true).find(1) person.visits += 1 person.save! end  ==== Variations of #find  Person.where(name: 'Spartacus', rating: 4) # returns a chainable list (which can be empty).  Person.find_by(name: 'Spartacus', rating: 4) # returns the first item or nil.  Person.find_or_initialize_by(name: 'Spartacus', rating: 4) # returns the first item or returns a new instance (requires you call .save to persist against the database).  Person.find_or_create_by(name: 'Spartacus', rating: 4) # returns the first item or creates it and returns it.  ==== Alternatives for #find  Person.where(name: 'Spartacus', rating: 4).exists?(conditions = :none) # returns a boolean indicating if any record with the given conditions exist.  Person.where(name: 'Spartacus', rating: 4).select(\"field1, field2, field3\") # returns a chainable list of instances with only the mentioned fields.  Person.where(name: 'Spartacus', rating: 4).ids # returns an Array of ids.  Person.where(name: 'Spartacus', rating: 4).pluck(:field1, :field2) # returns an Array of the required fields.  ==== Edge Cases  Person.find(37)          # raises ActiveRecord::RecordNotFound exception if the record with the given ID does not exist. Person.find([37])        # raises ActiveRecord::RecordNotFound exception if the record with the given ID in the input array does not exist. Person.find(nil)         # raises ActiveRecord::RecordNotFound exception if the argument is nil. Person.find([])          # returns an empty array if the argument is an empty array. Person.find              # raises ActiveRecord::RecordNotFound exception if the argument is not provided.",
    "label": "",
    "id": "2338"
  },
  {
    "raw_code": "def find_by(arg, *args)\n      where(arg, *args).take\n    end",
    "comment": "Finds the first record matching the specified conditions. There is no implied ordering so if order matters, you should specify it yourself.  If no record is found, returns <tt>nil</tt>.  Post.find_by name: 'Spartacus', rating: 4 Post.find_by \"published_at < ?\", 2.weeks.ago",
    "label": "",
    "id": "2339"
  },
  {
    "raw_code": "def find_by!(arg, *args)\n      where(arg, *args).take!\n    end",
    "comment": "Like #find_by, except that if no record is found, raises an ActiveRecord::RecordNotFound error.",
    "label": "",
    "id": "2340"
  },
  {
    "raw_code": "def take(limit = nil)\n      limit ? find_take_with_limit(limit) : find_take\n    end",
    "comment": "Gives a record (or N records if a parameter is supplied) without any implied order. The order will depend on the database implementation. If an order is supplied it will be respected.  Person.take # returns an object fetched by SELECT * FROM people LIMIT 1 Person.take(5) # returns 5 objects fetched by SELECT * FROM people LIMIT 5 Person.where([\"name LIKE '%?'\", name]).take",
    "label": "",
    "id": "2341"
  },
  {
    "raw_code": "def take!\n      take || raise_record_not_found_exception!\n    end",
    "comment": "Same as #take but raises ActiveRecord::RecordNotFound if no record is found. Note that #take! accepts no arguments.",
    "label": "",
    "id": "2342"
  },
  {
    "raw_code": "def sole\n      found, undesired = take(2)\n\n      if found.nil?\n        raise_record_not_found_exception!\n      elsif undesired.nil?\n        found\n      else\n        raise ActiveRecord::SoleRecordExceeded.new(model)\n      end",
    "comment": "Finds the sole matching record. Raises ActiveRecord::RecordNotFound if no record is found. Raises ActiveRecord::SoleRecordExceeded if more than one record is found.  Product.where([\"price = %?\", price]).sole",
    "label": "",
    "id": "2343"
  },
  {
    "raw_code": "def find_sole_by(arg, *args)\n      where(arg, *args).sole\n    end",
    "comment": "Finds the sole matching record. Raises ActiveRecord::RecordNotFound if no record is found. Raises ActiveRecord::SoleRecordExceeded if more than one record is found.  Product.find_sole_by([\"price = %?\", price])",
    "label": "",
    "id": "2344"
  },
  {
    "raw_code": "def first(limit = nil)\n      if limit\n        find_nth_with_limit(0, limit)\n      else\n        find_nth 0\n      end",
    "comment": "Find the first record (or first N records if a parameter is supplied). If no order is defined it will order by primary key.  Person.first # returns the first object fetched by SELECT * FROM people ORDER BY people.id LIMIT 1 Person.where([\"user_name = ?\", user_name]).first Person.where([\"user_name = :u\", { u: user_name }]).first Person.order(\"created_on DESC\").offset(5).first Person.first(3) # returns the first three objects fetched by SELECT * FROM people ORDER BY people.id LIMIT 3 ",
    "label": "",
    "id": "2345"
  },
  {
    "raw_code": "def first!\n      first || raise_record_not_found_exception!\n    end",
    "comment": "Same as #first but raises ActiveRecord::RecordNotFound if no record is found. Note that #first! accepts no arguments.",
    "label": "",
    "id": "2346"
  },
  {
    "raw_code": "def last(limit = nil)\n      return find_last(limit) if loaded? || has_limit_or_offset?\n\n      result = ordered_relation.limit(limit)\n      result = result.reverse_order!\n\n      limit ? result.reverse : result.first\n    end",
    "comment": "Find the last record (or last N records if a parameter is supplied). If no order is defined it will order by primary key.  Person.last # returns the last object fetched by SELECT * FROM people Person.where([\"user_name = ?\", user_name]).last Person.order(\"created_on DESC\").offset(5).last Person.last(3) # returns the last three objects fetched by SELECT * FROM people.  Take note that in that last case, the results are sorted in ascending order:  [#<Person id:2>, #<Person id:3>, #<Person id:4>]  and not:  [#<Person id:4>, #<Person id:3>, #<Person id:2>]",
    "label": "",
    "id": "2347"
  },
  {
    "raw_code": "def last!\n      last || raise_record_not_found_exception!\n    end",
    "comment": "Same as #last but raises ActiveRecord::RecordNotFound if no record is found. Note that #last! accepts no arguments.",
    "label": "",
    "id": "2348"
  },
  {
    "raw_code": "def second\n      find_nth 1\n    end",
    "comment": "Find the second record. If no order is defined it will order by primary key.  Person.second # returns the second object fetched by SELECT * FROM people Person.offset(3).second # returns the second object from OFFSET 3 (which is OFFSET 4) Person.where([\"user_name = :u\", { u: user_name }]).second",
    "label": "",
    "id": "2349"
  },
  {
    "raw_code": "def second!\n      second || raise_record_not_found_exception!\n    end",
    "comment": "Same as #second but raises ActiveRecord::RecordNotFound if no record is found.",
    "label": "",
    "id": "2350"
  },
  {
    "raw_code": "def third\n      find_nth 2\n    end",
    "comment": "Find the third record. If no order is defined it will order by primary key.  Person.third # returns the third object fetched by SELECT * FROM people Person.offset(3).third # returns the third object from OFFSET 3 (which is OFFSET 5) Person.where([\"user_name = :u\", { u: user_name }]).third",
    "label": "",
    "id": "2351"
  },
  {
    "raw_code": "def third!\n      third || raise_record_not_found_exception!\n    end",
    "comment": "Same as #third but raises ActiveRecord::RecordNotFound if no record is found.",
    "label": "",
    "id": "2352"
  },
  {
    "raw_code": "def fourth\n      find_nth 3\n    end",
    "comment": "Find the fourth record. If no order is defined it will order by primary key.  Person.fourth # returns the fourth object fetched by SELECT * FROM people Person.offset(3).fourth # returns the fourth object from OFFSET 3 (which is OFFSET 6) Person.where([\"user_name = :u\", { u: user_name }]).fourth",
    "label": "",
    "id": "2353"
  },
  {
    "raw_code": "def fourth!\n      fourth || raise_record_not_found_exception!\n    end",
    "comment": "Same as #fourth but raises ActiveRecord::RecordNotFound if no record is found.",
    "label": "",
    "id": "2354"
  },
  {
    "raw_code": "def fifth\n      find_nth 4\n    end",
    "comment": "Find the fifth record. If no order is defined it will order by primary key.  Person.fifth # returns the fifth object fetched by SELECT * FROM people Person.offset(3).fifth # returns the fifth object from OFFSET 3 (which is OFFSET 7) Person.where([\"user_name = :u\", { u: user_name }]).fifth",
    "label": "",
    "id": "2355"
  },
  {
    "raw_code": "def fifth!\n      fifth || raise_record_not_found_exception!\n    end",
    "comment": "Same as #fifth but raises ActiveRecord::RecordNotFound if no record is found.",
    "label": "",
    "id": "2356"
  },
  {
    "raw_code": "def forty_two\n      find_nth 41\n    end",
    "comment": "Find the forty-second record. Also known as accessing \"the reddit\". If no order is defined it will order by primary key.  Person.forty_two # returns the forty-second object fetched by SELECT * FROM people Person.offset(3).forty_two # returns the forty-second object from OFFSET 3 (which is OFFSET 44) Person.where([\"user_name = :u\", { u: user_name }]).forty_two",
    "label": "",
    "id": "2357"
  },
  {
    "raw_code": "def forty_two!\n      forty_two || raise_record_not_found_exception!\n    end",
    "comment": "Same as #forty_two but raises ActiveRecord::RecordNotFound if no record is found.",
    "label": "",
    "id": "2358"
  },
  {
    "raw_code": "def third_to_last\n      find_nth_from_last 3\n    end",
    "comment": "Find the third-to-last record. If no order is defined it will order by primary key.  Person.third_to_last # returns the third-to-last object fetched by SELECT * FROM people Person.offset(3).third_to_last # returns the third-to-last object from OFFSET 3 Person.where([\"user_name = :u\", { u: user_name }]).third_to_last",
    "label": "",
    "id": "2359"
  },
  {
    "raw_code": "def third_to_last!\n      third_to_last || raise_record_not_found_exception!\n    end",
    "comment": "Same as #third_to_last but raises ActiveRecord::RecordNotFound if no record is found.",
    "label": "",
    "id": "2360"
  },
  {
    "raw_code": "def second_to_last\n      find_nth_from_last 2\n    end",
    "comment": "Find the second-to-last record. If no order is defined it will order by primary key.  Person.second_to_last # returns the second-to-last object fetched by SELECT * FROM people Person.offset(3).second_to_last # returns the second-to-last object from OFFSET 3 Person.where([\"user_name = :u\", { u: user_name }]).second_to_last",
    "label": "",
    "id": "2361"
  },
  {
    "raw_code": "def second_to_last!\n      second_to_last || raise_record_not_found_exception!\n    end",
    "comment": "Same as #second_to_last but raises ActiveRecord::RecordNotFound if no record is found.",
    "label": "",
    "id": "2362"
  },
  {
    "raw_code": "def exists?(conditions = :none)\n      return false if @none\n\n      if Base === conditions\n        raise ArgumentError, <<-MSG.squish\n          You are passing an instance of ActiveRecord::Base to `exists?`.\n          Please pass the id of the object by calling `.id`.\n        MSG\n      end",
    "comment": "Returns true if a record exists in the table that matches the +id+ or conditions given, or false otherwise. The argument can take six forms:  * Integer - Finds the record with this primary key. * String - Finds the record with a primary key corresponding to this string (such as <tt>'5'</tt>). * Array - Finds the record that matches these +where+-style conditions (such as <tt>['name LIKE ?', \"%#{query}%\"]</tt>). * Hash - Finds the record that matches these +where+-style conditions (such as <tt>{name: 'David'}</tt>). * +false+ - Returns always +false+. * No args - Returns +false+ if the relation is empty, +true+ otherwise.  For more information about specifying conditions as a hash or array, see the Conditions section in the introduction to ActiveRecord::Base.  Note: You can't pass in a condition as a string (like <tt>name = 'Jamie'</tt>), since it would be sanitized and then queried against the primary key column, like <tt>id = 'name = \\'Jamie\\''</tt>.  Person.exists?(5) Person.exists?('5') Person.exists?(['name LIKE ?', \"%#{query}%\"]) Person.exists?(id: [1, 4, 8]) Person.exists?(name: 'David') Person.exists?(false) Person.exists? Person.where(name: 'Spartacus', rating: 4).exists?",
    "label": "",
    "id": "2363"
  },
  {
    "raw_code": "def include?(record)\n      # The existing implementation relies on receiving an Active Record instance as the input parameter named record.\n      # Any non-Active Record object passed to this implementation is guaranteed to return `false`.\n      return false unless record.is_a?(model)\n\n      if loaded? || offset_value || limit_value || having_clause.any?\n        records.include?(record)\n      else\n        id = if record.class.composite_primary_key?\n          record.class.primary_key.zip(record.id).to_h\n        else\n          record.id\n        end",
    "comment": "Returns true if the relation contains the given record or false otherwise.  No query is performed if the relation is loaded; the given record is compared to the records in memory. If the relation is unloaded, an efficient existence query is performed, as in #exists?.",
    "label": "",
    "id": "2364"
  },
  {
    "raw_code": "def raise_record_not_found_exception!(ids = nil, result_size = nil, expected_size = nil, key = primary_key, not_found_ids = nil) # :nodoc:\n      conditions = \" [#{arel.where_sql(model)}]\" unless where_clause.empty?\n\n      name = model.name\n\n      if ids.nil?\n        error = +\"Couldn't find #{name}\"\n        error << \" with#{conditions}\" if conditions\n        raise RecordNotFound.new(error, name, key)\n      elsif Array.wrap(ids).size == 1\n        id = Array.wrap(ids)[0]\n        error = \"Couldn't find #{name} with '#{key}'=#{id.inspect}#{conditions}\"\n        raise RecordNotFound.new(error, name, key, ids)\n      else\n        error = +\"Couldn't find all #{name.pluralize} with '#{key}': \"\n        error << \"(#{ids.map(&:inspect).join(\", \")})#{conditions} (found #{result_size} results, but was looking for #{expected_size}).\"\n        error << \" Couldn't find #{name.pluralize(not_found_ids.size)} with #{key.to_s.pluralize(not_found_ids.size)} #{not_found_ids.map(&:inspect).join(', ')}.\" if not_found_ids\n        raise RecordNotFound.new(error, name, key, ids)\n      end",
    "comment": "This method is called whenever no records are found with either a single id or multiple ids and raises an ActiveRecord::RecordNotFound exception.  The error message is different depending on whether a single id or multiple ids are provided. If multiple ids are provided, then the number of results obtained should be provided in the +result_size+ argument and the expected number of results should be provided in the +expected_size+ argument.",
    "label": "",
    "id": "2365"
  },
  {
    "raw_code": "def other\n        other = Relation.create(\n          relation.model,\n          table: relation.table,\n          predicate_builder: relation.predicate_builder\n        )\n        hash.each do |k, v|\n          k = :_select if k == :select\n          if Array === v\n            other.public_send(\"#{k}!\", *v)\n          else\n            other.public_send(\"#{k}!\", v)\n          end",
    "comment": "Applying values to a relation has some side effects. E.g. interpolation might take place for where values. So we should build a relation to merge in rather than directly merging the values.",
    "label": "",
    "id": "2366"
  },
  {
    "raw_code": "def register_handler(klass, handler)\n      @handlers.unshift([klass, handler])\n    end",
    "comment": "Define how a class is converted to Arel nodes when passed to +where+. The handler can be any object that responds to +call+, and will be used for any value that <tt>===</tt> the class given. For example:  MyCustomDateRange = Struct.new(:start, :end) handler = proc do |column, range| Arel::Nodes::Between.new(column, Arel::Nodes::And.new([range.start, range.end]) ) end ActiveRecord::PredicateBuilder.new(\"users\").register_handler(MyCustomDateRange, handler)",
    "label": "",
    "id": "2367"
  },
  {
    "raw_code": "def not(opts, *rest)\n        where_clause = @scope.send(:build_where_clause, opts, rest)\n\n        @scope.where_clause += where_clause.invert\n\n        @scope\n      end",
    "comment": "Returns a new relation expressing WHERE + NOT condition according to the conditions in the arguments.  #not accepts conditions as a string, array, or hash. See QueryMethods#where for more details on each format.  User.where.not(\"name = 'Jon'\") # SELECT * FROM users WHERE NOT (name = 'Jon')  User.where.not([\"name = ?\", \"Jon\"]) # SELECT * FROM users WHERE NOT (name = 'Jon')  User.where.not(name: \"Jon\") # SELECT * FROM users WHERE name != 'Jon'  User.where.not(name: nil) # SELECT * FROM users WHERE name IS NOT NULL  User.where.not(name: %w(Ko1 Nobu)) # SELECT * FROM users WHERE name NOT IN ('Ko1', 'Nobu')  User.where.not(name: \"Jon\", role: \"admin\") # SELECT * FROM users WHERE NOT (name = 'Jon' AND role = 'admin')  If there is a non-nil condition on a nullable column in the hash condition, the records that have nil values on the nullable column won't be returned. User.create!(nullable_country: nil) User.where.not(nullable_country: \"UK\") # SELECT * FROM users WHERE NOT (nullable_country = 'UK') # => []",
    "label": "",
    "id": "2368"
  },
  {
    "raw_code": "def associated(*associations)\n        associations.each do |association|\n          reflection = scope_association_reflection(association)\n          unless @scope.joins_values.include?(reflection.name) || @scope.left_outer_joins_values.include?(reflection.name)\n            @scope.joins!(association)\n          end",
    "comment": "Returns a new relation with joins and where clause to identify associated relations.  For example, posts that are associated to a related author:  Post.where.associated(:author) # SELECT \"posts\".* FROM \"posts\" # INNER JOIN \"authors\" ON \"authors\".\"id\" = \"posts\".\"author_id\" # WHERE \"authors\".\"id\" IS NOT NULL  Additionally, multiple relations can be combined. This will return posts associated to both an author and any comments:  Post.where.associated(:author, :comments) # SELECT \"posts\".* FROM \"posts\" # INNER JOIN \"authors\" ON \"authors\".\"id\" = \"posts\".\"author_id\" # INNER JOIN \"comments\" ON \"comments\".\"post_id\" = \"posts\".\"id\" # WHERE \"authors\".\"id\" IS NOT NULL AND \"comments\".\"id\" IS NOT NULL  You can define join type in the scope and +associated+ will not use `JOIN` by default.  Post.left_joins(:author).where.associated(:author) # SELECT \"posts\".* FROM \"posts\" # LEFT OUTER JOIN \"authors\" \"authors\".\"id\" = \"posts\".\"author_id\" # WHERE \"authors\".\"id\" IS NOT NULL  Post.left_joins(:comments).where.associated(:author) # SELECT \"posts\".* FROM \"posts\" # INNER JOIN \"authors\" ON \"authors\".\"id\" = \"posts\".\"author_id\" # LEFT OUTER JOIN \"comments\" ON \"comments\".\"post_id\" = \"posts\".\"id\" #  WHERE \"author\".\"id\" IS NOT NULL",
    "label": "",
    "id": "2369"
  },
  {
    "raw_code": "def missing(*associations)\n        associations.each do |association|\n          reflection = scope_association_reflection(association)\n          @scope.left_outer_joins!(association)\n          association_conditions = Array(reflection.association_primary_key).index_with(nil)\n          if reflection.options[:class_name]\n            @scope.where!(association => association_conditions)\n          else\n            @scope.where!(reflection.table_name => association_conditions)\n          end",
    "comment": "Returns a new relation with left outer joins and where clause to identify missing relations.  For example, posts that are missing a related author:  Post.where.missing(:author) # SELECT \"posts\".* FROM \"posts\" # LEFT OUTER JOIN \"authors\" ON \"authors\".\"id\" = \"posts\".\"author_id\" # WHERE \"authors\".\"id\" IS NULL  Additionally, multiple relations can be combined. This will return posts that are missing both an author and any comments:  Post.where.missing(:author, :comments) # SELECT \"posts\".* FROM \"posts\" # LEFT OUTER JOIN \"authors\" ON \"authors\".\"id\" = \"posts\".\"author_id\" # LEFT OUTER JOIN \"comments\" ON \"comments\".\"post_id\" = \"posts\".\"id\" # WHERE \"authors\".\"id\" IS NULL AND \"comments\".\"id\" IS NULL",
    "label": "",
    "id": "2370"
  },
  {
    "raw_code": "def with(*args)\n      raise ArgumentError, \"ActiveRecord::Relation#with does not accept a block\" if block_given?\n      check_if_method_has_arguments!(__callee__, args)\n      spawn.with!(*args)\n    end",
    "comment": "Add a Common Table Expression (CTE) that you can then reference within another SELECT statement.  Note: CTE's are only supported in MySQL for versions 8.0 and above. You will not be able to use CTE's with MySQL 5.7.  Post.with(posts_with_tags: Post.where(\"tags_count > ?\", 0)) # => ActiveRecord::Relation # WITH posts_with_tags AS ( #   SELECT * FROM posts WHERE (tags_count > 0) # ) # SELECT * FROM posts  You can also pass an array of sub-queries to be joined in a +UNION ALL+.  Post.with(posts_with_tags_or_comments: [Post.where(\"tags_count > ?\", 0), Post.where(\"comments_count > ?\", 0)]) # => ActiveRecord::Relation # WITH posts_with_tags_or_comments AS ( #  (SELECT * FROM posts WHERE (tags_count > 0)) #  UNION ALL #  (SELECT * FROM posts WHERE (comments_count > 0)) # ) # SELECT * FROM posts  Once you define Common Table Expression you can use custom +FROM+ value or +JOIN+ to reference it.  Post.with(posts_with_tags: Post.where(\"tags_count > ?\", 0)).from(\"posts_with_tags AS posts\") # => ActiveRecord::Relation # WITH posts_with_tags AS ( #  SELECT * FROM posts WHERE (tags_count > 0) # ) # SELECT * FROM posts_with_tags AS posts  Post.with(posts_with_tags: Post.where(\"tags_count > ?\", 0)).joins(\"JOIN posts_with_tags ON posts_with_tags.id = posts.id\") # => ActiveRecord::Relation # WITH posts_with_tags AS ( #   SELECT * FROM posts WHERE (tags_count > 0) # ) # SELECT * FROM posts JOIN posts_with_tags ON posts_with_tags.id = posts.id  It is recommended to pass a query as ActiveRecord::Relation. If that is not possible and you have verified it is safe for the database, you can pass it as SQL literal using +Arel+.  Post.with(popular_posts: Arel.sql(\"... complex sql to calculate posts popularity ...\"))  Great caution should be taken to avoid SQL injection vulnerabilities. This method should not be used with unsafe values that include unsanitized input.  To add multiple CTEs just pass multiple key-value pairs  Post.with( posts_with_comments: Post.where(\"comments_count > ?\", 0), posts_with_tags: Post.where(\"tags_count > ?\", 0) )  or chain multiple +.with+ calls  Post .with(posts_with_comments: Post.where(\"comments_count > ?\", 0)) .with(posts_with_tags: Post.where(\"tags_count > ?\", 0))",
    "label": "",
    "id": "2371"
  },
  {
    "raw_code": "def with!(*args) # :nodoc:\n      args = process_with_args(args)\n      self.with_values |= args\n      self\n    end",
    "comment": "Like #with, but modifies relation in place.",
    "label": "",
    "id": "2372"
  },
  {
    "raw_code": "def with_recursive(*args)\n      check_if_method_has_arguments!(__callee__, args)\n      spawn.with_recursive!(*args)\n    end",
    "comment": "Add a recursive Common Table Expression (CTE) that you can then reference within another SELECT statement.  Post.with_recursive(post_and_replies: [Post.where(id: 42), Post.joins('JOIN post_and_replies ON posts.in_reply_to_id = post_and_replies.id')]) # => ActiveRecord::Relation # WITH RECURSIVE post_and_replies AS ( #   (SELECT * FROM posts WHERE id = 42) #   UNION ALL #   (SELECT * FROM posts JOIN post_and_replies ON posts.in_reply_to_id = post_and_replies.id) # ) # SELECT * FROM posts  See `#with` for more information.",
    "label": "",
    "id": "2373"
  },
  {
    "raw_code": "def with_recursive!(*args) # :nodoc:\n      args = process_with_args(args)\n      self.with_values |= args\n      @with_is_recursive = true\n      self\n    end",
    "comment": "Like #with_recursive but modifies the relation in place.",
    "label": "",
    "id": "2374"
  },
  {
    "raw_code": "def reselect(*args)\n      check_if_method_has_arguments!(__callee__, args)\n      args = process_select_args(args)\n      spawn.reselect!(*args)\n    end",
    "comment": "Allows you to change a previously set select statement.  Post.select(:title, :body) # SELECT `posts`.`title`, `posts`.`body` FROM `posts`  Post.select(:title, :body).reselect(:created_at) # SELECT `posts`.`created_at` FROM `posts`  This is short-hand for <tt>unscope(:select).select(fields)</tt>. Note that we're unscoping the entire select statement.",
    "label": "",
    "id": "2375"
  },
  {
    "raw_code": "def reselect!(*args) # :nodoc:\n      self.select_values = args\n      self\n    end",
    "comment": "Same as #reselect but operates on relation in-place instead of copying.",
    "label": "",
    "id": "2376"
  },
  {
    "raw_code": "def group(*args)\n      check_if_method_has_arguments!(__callee__, args)\n      spawn.group!(*args)\n    end",
    "comment": "Allows to specify a group attribute:  User.group(:name) # SELECT \"users\".* FROM \"users\" GROUP BY name  Returns an array with distinct records based on the +group+ attribute:  User.select([:id, :name]) # => [#<User id: 1, name: \"Oscar\">, #<User id: 2, name: \"Oscar\">, #<User id: 3, name: \"Foo\">]  User.group(:name) # => [#<User id: 3, name: \"Foo\", ...>, #<User id: 2, name: \"Oscar\", ...>]  User.group('name AS grouped_name, age') # => [#<User id: 3, name: \"Foo\", age: 21, ...>, #<User id: 2, name: \"Oscar\", age: 21, ...>, #<User id: 5, name: \"Foo\", age: 23, ...>]  Passing in an array of attributes to group by is also supported.  User.select([:id, :first_name]).group(:id, :first_name).first(3) # => [#<User id: 1, first_name: \"Bill\">, #<User id: 2, first_name: \"Earl\">, #<User id: 3, first_name: \"Beto\">]",
    "label": "",
    "id": "2377"
  },
  {
    "raw_code": "def regroup(*args)\n      check_if_method_has_arguments!(__callee__, args)\n      spawn.regroup!(*args)\n    end",
    "comment": "Allows you to change a previously set group statement.  Post.group(:title, :body) # SELECT `posts`.`*` FROM `posts` GROUP BY `posts`.`title`, `posts`.`body`  Post.group(:title, :body).regroup(:title) # SELECT `posts`.`*` FROM `posts` GROUP BY `posts`.`title`  This is short-hand for <tt>unscope(:group).group(fields)</tt>. Note that we're unscoping the entire group statement.",
    "label": "",
    "id": "2378"
  },
  {
    "raw_code": "def regroup!(*args) # :nodoc:\n      self.group_values = args\n      self\n    end",
    "comment": "Same as #regroup but operates on relation in-place instead of copying.",
    "label": "",
    "id": "2379"
  },
  {
    "raw_code": "def order(*args)\n      check_if_method_has_arguments!(__callee__, args) do\n        sanitize_order_arguments(args)\n      end",
    "comment": "Applies an <code>ORDER BY</code> clause to a query.  #order accepts arguments in one of several formats.  === symbols  The symbol represents the name of the column you want to order the results by.  User.order(:name) # SELECT \"users\".* FROM \"users\" ORDER BY \"users\".\"name\" ASC  By default, the order is ascending. If you want descending order, you can map the column name symbol to +:desc+.  User.order(email: :desc) # SELECT \"users\".* FROM \"users\" ORDER BY \"users\".\"email\" DESC  Multiple columns can be passed this way, and they will be applied in the order specified.  User.order(:name, email: :desc) # SELECT \"users\".* FROM \"users\" ORDER BY \"users\".\"name\" ASC, \"users\".\"email\" DESC  === strings  Strings are passed directly to the database, allowing you to specify simple SQL expressions.  This could be a source of SQL injection, so only strings composed of plain column names and simple <code>function(column_name)</code> expressions with optional +ASC+/+DESC+ modifiers are allowed.  User.order('name') # SELECT \"users\".* FROM \"users\" ORDER BY name  User.order('name DESC') # SELECT \"users\".* FROM \"users\" ORDER BY name DESC  User.order('name DESC, email') # SELECT \"users\".* FROM \"users\" ORDER BY name DESC, email  === Arel  If you need to pass in complicated expressions that you have verified are safe for the database, you can use Arel.  User.order(Arel.sql('end_date - start_date')) # SELECT \"users\".* FROM \"users\" ORDER BY end_date - start_date  Custom query syntax, like JSON columns for PostgreSQL, is supported in this way.  User.order(Arel.sql(\"payload->>'kind'\")) # SELECT \"users\".* FROM \"users\" ORDER BY payload->>'kind'",
    "label": "",
    "id": "2380"
  },
  {
    "raw_code": "def order!(*args) # :nodoc:\n      preprocess_order_args(args) unless args.empty?\n      self.order_values |= args\n      self\n    end",
    "comment": "Same as #order but operates on relation in-place instead of copying.",
    "label": "",
    "id": "2381"
  },
  {
    "raw_code": "def in_order_of(column, values, filter: true)\n      model.disallow_raw_sql!([column], permit: model.adapter_class.column_name_with_order_matcher)\n      return spawn.none! if values.empty?\n\n      references = column_references([column])\n      self.references_values |= references unless references.empty?\n\n      values = values.map { |value| model.type_caster.type_cast_for_database(column, value) }\n      arel_column = column.is_a?(Arel::Nodes::SqlLiteral) ? column : order_column(column.to_s)\n\n      scope = spawn.order!(build_case_for_value_position(arel_column, values, filter: filter))\n\n      if filter\n        where_clause =\n          if values.include?(nil)\n            arel_column.in(values.compact).or(arel_column.eq(nil))\n          else\n            arel_column.in(values)\n          end",
    "comment": "Applies an <tt>ORDER BY</tt> clause based on a given +column+, ordered and filtered by a specific set of +values+.  User.in_order_of(:id, [1, 5, 3]) # SELECT \"users\".* FROM \"users\" #   WHERE \"users\".\"id\" IN (1, 5, 3) #   ORDER BY CASE #     WHEN \"users\".\"id\" = 1 THEN 1 #     WHEN \"users\".\"id\" = 5 THEN 2 #     WHEN \"users\".\"id\" = 3 THEN 3 #   END ASC  +column+ can point to an enum column; the actual query generated may be different depending on the database adapter and the column definition.  class Conversation < ActiveRecord::Base enum :status, [ :active, :archived ] end  Conversation.in_order_of(:status, [:archived, :active]) # SELECT \"conversations\".* FROM \"conversations\" #   WHERE \"conversations\".\"status\" IN (1, 0) #   ORDER BY CASE #     WHEN \"conversations\".\"status\" = 1 THEN 1 #     WHEN \"conversations\".\"status\" = 0 THEN 2 #   END ASC  +values+ can also include +nil+.  Conversation.in_order_of(:status, [nil, :archived, :active]) # SELECT \"conversations\".* FROM \"conversations\" #   WHERE (\"conversations\".\"status\" IN (1, 0) OR \"conversations\".\"status\" IS NULL) #   ORDER BY CASE #     WHEN \"conversations\".\"status\" IS NULL THEN 1 #     WHEN \"conversations\".\"status\" = 1 THEN 2 #     WHEN \"conversations\".\"status\" = 0 THEN 3 #   END ASC  +filter+ can be set to +false+ to include all results instead of only the ones specified in +values+.  Conversation.in_order_of(:status, [:archived, :active], filter: false) # SELECT \"conversations\".* FROM \"conversations\" #   ORDER BY CASE #     WHEN \"conversations\".\"status\" = 1 THEN 1 #     WHEN \"conversations\".\"status\" = 0 THEN 2 #     ELSE 3 #   END ASC",
    "label": "",
    "id": "2382"
  },
  {
    "raw_code": "def reorder(*args)\n      check_if_method_has_arguments!(__callee__, args) do\n        sanitize_order_arguments(args)\n      end",
    "comment": "Replaces any existing order defined on the relation with the specified order.  User.order('email DESC').reorder('id ASC') # generated SQL has 'ORDER BY id ASC'  Subsequent calls to order on the same relation will be appended. For example:  User.order('email DESC').reorder('id ASC').order('name ASC')  generates a query with <tt>ORDER BY id ASC, name ASC</tt>.",
    "label": "",
    "id": "2383"
  },
  {
    "raw_code": "def reorder!(*args) # :nodoc:\n      preprocess_order_args(args)\n      args.uniq!\n      self.reordering_value = true\n      self.order_values = args\n      self\n    end",
    "comment": "Same as #reorder but operates on relation in-place instead of copying.",
    "label": "",
    "id": "2384"
  },
  {
    "raw_code": "def unscope(*args)\n      check_if_method_has_arguments!(__callee__, args)\n      spawn.unscope!(*args)\n    end",
    "comment": "Removes an unwanted relation that is already defined on a chain of relations. This is useful when passing around chains of relations and would like to modify the relations without reconstructing the entire chain.  User.order('email DESC').unscope(:order) == User.all  The method arguments are symbols which correspond to the names of the methods which should be unscoped. The valid arguments are given in VALID_UNSCOPING_VALUES. The method can also be called with multiple arguments. For example:  User.order('email DESC').select('id').where(name: \"John\") .unscope(:order, :select, :where) == User.all  One can additionally pass a hash as an argument to unscope specific +:where+ values. This is done by passing a hash with a single key-value pair. The key should be +:where+ and the value should be the where value to unscope. For example:  User.where(name: \"John\", active: true).unscope(where: :name) == User.where(active: true)  This method is similar to #except, but unlike #except, it persists across merges:  User.order('email').merge(User.except(:order)) == User.order('email')  User.order('email').merge(User.unscope(:order)) == User.all  This means it can be used in association definitions:  has_many :comments, -> { unscope(where: :trashed) } ",
    "label": "",
    "id": "2385"
  },
  {
    "raw_code": "def joins(*args)\n      check_if_method_has_arguments!(__callee__, args)\n      spawn.joins!(*args)\n    end",
    "comment": "Performs JOINs on +args+. The given symbol(s) should match the name of the association(s).  User.joins(:posts) # SELECT \"users\".* # FROM \"users\" # INNER JOIN \"posts\" ON \"posts\".\"user_id\" = \"users\".\"id\"  Multiple joins:  User.joins(:posts, :account) # SELECT \"users\".* # FROM \"users\" # INNER JOIN \"posts\" ON \"posts\".\"user_id\" = \"users\".\"id\" # INNER JOIN \"accounts\" ON \"accounts\".\"id\" = \"users\".\"account_id\"  Nested joins:  User.joins(posts: [:comments]) # SELECT \"users\".* # FROM \"users\" # INNER JOIN \"posts\" ON \"posts\".\"user_id\" = \"users\".\"id\" # INNER JOIN \"comments\" ON \"comments\".\"post_id\" = \"posts\".\"id\"  You can use strings in order to customize your joins:  User.joins(\"LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id\") # SELECT \"users\".* FROM \"users\" LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id",
    "label": "",
    "id": "2386"
  },
  {
    "raw_code": "def left_outer_joins(*args)\n      check_if_method_has_arguments!(__callee__, args)\n      spawn.left_outer_joins!(*args)\n    end",
    "comment": "Performs LEFT OUTER JOINs on +args+:  User.left_outer_joins(:posts) # SELECT \"users\".* FROM \"users\" LEFT OUTER JOIN \"posts\" ON \"posts\".\"user_id\" = \"users\".\"id\" ",
    "label": "",
    "id": "2387"
  },
  {
    "raw_code": "def where(*args)\n      if args.empty?\n        WhereChain.new(spawn)\n      elsif args.length == 1 && args.first.blank?\n        self\n      else\n        spawn.where!(*args)\n      end",
    "comment": "Returns a new relation, which is the result of filtering the current relation according to the conditions in the arguments.  #where accepts conditions in one of several formats. In the examples below, the resulting SQL is given as an illustration; the actual query generated may be different depending on the database adapter.  === \\String  A single string, without additional arguments, is passed to the query constructor as an SQL fragment, and used in the where clause of the query.  Client.where(\"orders_count = '2'\") # SELECT * from clients where orders_count = '2';  Note that building your own string from user input may expose your application to injection attacks if not done properly. As an alternative, it is recommended to use one of the following methods.  === \\Array  If an array is passed, then the first element of the array is treated as a template, and the remaining elements are inserted into the template to generate the condition. Active Record takes care of building the query to avoid injection attacks, and will convert from the ruby type to the database type where needed. Elements are inserted into the string in the order in which they appear.  User.where([\"name = ? and email = ?\", \"Joe\", \"joe@example.com\"]) # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';  Alternatively, you can use named placeholders in the template, and pass a hash as the second element of the array. The names in the template are replaced with the corresponding values from the hash.  User.where([\"name = :name and email = :email\", { name: \"Joe\", email: \"joe@example.com\" }]) # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';  This can make for more readable code in complex queries.  Lastly, you can use sprintf-style % escapes in the template. This works slightly differently than the previous methods; you are responsible for ensuring that the values in the template are properly quoted. The values are passed to the connector for quoting, but the caller is responsible for ensuring they are enclosed in quotes in the resulting SQL. After quoting, the values are inserted using the same escapes as the Ruby core method +Kernel::sprintf+.  User.where([\"name = '%s' and email = '%s'\", \"Joe\", \"joe@example.com\"]) # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';  If #where is called with multiple arguments, these are treated as if they were passed as the elements of a single array.  User.where(\"name = :name and email = :email\", { name: \"Joe\", email: \"joe@example.com\" }) # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';  When using strings to specify conditions, you can use any operator available from the database. While this provides the most flexibility, you can also unintentionally introduce dependencies on the underlying database. If your code is intended for general consumption, test with multiple database backends.  === \\Hash  #where will also accept a hash condition, in which the keys are fields and the values are values to be searched for.  Fields can be symbols or strings. Values can be single values, arrays, or ranges.  User.where(name: \"Joe\", email: \"joe@example.com\") # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com'  User.where(name: [\"Alice\", \"Bob\"]) # SELECT * FROM users WHERE name IN ('Alice', 'Bob')  User.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight) # SELECT * FROM users WHERE (created_at BETWEEN '2012-06-09 07:00:00.000000' AND '2012-06-10 07:00:00.000000')  In the case of a belongs_to relationship, an association key can be used to specify the model if an ActiveRecord object is used as the value.  author = Author.find(1)  # The following queries will be equivalent: Post.where(author: author) Post.where(author_id: author)  This also works with polymorphic belongs_to relationships:  treasure = Treasure.create(name: 'gold coins') treasure.price_estimates << PriceEstimate.create(price: 125)  # The following queries will be equivalent: PriceEstimate.where(estimate_of: treasure) PriceEstimate.where(estimate_of_type: 'Treasure', estimate_of_id: treasure)  Hash conditions may also be specified in a tuple-like syntax. Hash keys may be an array of columns with an array of tuples as values.  Article.where([:author_id, :id] => [[15, 1], [15, 2]]) # SELECT * FROM articles WHERE author_id = 15 AND id = 1 OR author_id = 15 AND id = 2  === Joins  If the relation is the result of a join, you may create a condition which uses any of the tables in the join. For string and array conditions, use the table name in the condition.  User.joins(:posts).where(\"posts.created_at < ?\", Time.now)  For hash conditions, you can either use the table name in the key, or use a sub-hash.  User.joins(:posts).where(\"posts.published\" => true) User.joins(:posts).where(posts: { published: true })  === No Argument  If no argument is passed, #where returns a new instance of WhereChain, that can be chained with WhereChain#not, WhereChain#missing, or WhereChain#associated.  Chaining with WhereChain#not:  User.where.not(name: \"Jon\") # SELECT * FROM users WHERE name != 'Jon'  Chaining with WhereChain#associated:  Post.where.associated(:author) # SELECT \"posts\".* FROM \"posts\" # INNER JOIN \"authors\" ON \"authors\".\"id\" = \"posts\".\"author_id\" # WHERE \"authors\".\"id\" IS NOT NULL  Chaining with WhereChain#missing:  Post.where.missing(:author) # SELECT \"posts\".* FROM \"posts\" # LEFT OUTER JOIN \"authors\" ON \"authors\".\"id\" = \"posts\".\"author_id\" # WHERE \"authors\".\"id\" IS NULL  === Blank Condition  If the condition is any blank-ish object, then #where is a no-op and returns the current relation.",
    "label": "",
    "id": "2388"
  },
  {
    "raw_code": "def rewhere(conditions)\n      return unscope(:where) if conditions.nil?\n\n      scope = spawn\n      where_clause = scope.build_where_clause(conditions)\n\n      scope.unscope!(where: where_clause.extract_attributes)\n      scope.where_clause += where_clause\n      scope\n    end",
    "comment": "Allows you to change a previously set where condition for a given attribute, instead of appending to that condition.  Post.where(trashed: true).where(trashed: false) # WHERE `trashed` = 1 AND `trashed` = 0  Post.where(trashed: true).rewhere(trashed: false) # WHERE `trashed` = 0  Post.where(active: true).where(trashed: true).rewhere(trashed: false) # WHERE `active` = 1 AND `trashed` = 0  This is short-hand for <tt>unscope(where: conditions.keys).where(conditions)</tt>. Note that unlike reorder, we're only unscoping the named conditions -- not the entire where statement.",
    "label": "",
    "id": "2389"
  },
  {
    "raw_code": "def invert_where\n      spawn.invert_where!\n    end",
    "comment": "Allows you to invert an entire where clause instead of manually applying conditions.  class User scope :active, -> { where(accepted: true, locked: false) } end  User.where(accepted: true) # WHERE `accepted` = 1  User.where(accepted: true).invert_where # WHERE `accepted` != 1  User.active # WHERE `accepted` = 1 AND `locked` = 0  User.active.invert_where # WHERE NOT (`accepted` = 1 AND `locked` = 0)  Be careful because this inverts all conditions before +invert_where+ call.  class User scope :active, -> { where(accepted: true, locked: false) } scope :inactive, -> { active.invert_where } # Do not attempt it end  # It also inverts `where(role: 'admin')` unexpectedly. User.where(role: 'admin').inactive # WHERE NOT (`role` = 'admin' AND `accepted` = 1 AND `locked` = 0) ",
    "label": "",
    "id": "2390"
  },
  {
    "raw_code": "def structurally_compatible?(other)\n      structurally_incompatible_values_for(other).empty?\n    end",
    "comment": "Checks whether the given relation is structurally compatible with this relation, to determine if it's possible to use the #and and #or methods without raising an error. Structurally compatible is defined as: they must be scoping the same model, and they must differ only by #where (if no #group has been defined) or #having (if a #group is present).  Post.where(\"id = 1\").structurally_compatible?(Post.where(\"author_id = 3\")) # => true  Post.joins(:comments).structurally_compatible?(Post.where(\"id = 1\")) # => false ",
    "label": "",
    "id": "2391"
  },
  {
    "raw_code": "def and(other)\n      if other.is_a?(Relation)\n        spawn.and!(other)\n      else\n        raise ArgumentError, \"You have passed #{other.class.name} object to #and. Pass an ActiveRecord::Relation object instead.\"\n      end",
    "comment": "Returns a new relation, which is the logical intersection of this relation and the one passed as an argument.  The two relations must be structurally compatible: they must be scoping the same model, and they must differ only by #where (if no #group has been defined) or #having (if a #group is present).  Post.where(id: [1, 2]).and(Post.where(id: [2, 3])) # SELECT `posts`.* FROM `posts` WHERE `posts`.`id` IN (1, 2) AND `posts`.`id` IN (2, 3) ",
    "label": "",
    "id": "2392"
  },
  {
    "raw_code": "def or(other)\n      if other.is_a?(Relation)\n        if @none\n          other.spawn\n        else\n          spawn.or!(other)\n        end",
    "comment": "Returns a new relation, which is the logical union of this relation and the one passed as an argument.  The two relations must be structurally compatible: they must be scoping the same model, and they must differ only by #where (if no #group has been defined) or #having (if a #group is present).  Post.where(\"id = 1\").or(Post.where(\"author_id = 3\")) # SELECT `posts`.* FROM `posts` WHERE ((id = 1) OR (author_id = 3)) ",
    "label": "",
    "id": "2393"
  },
  {
    "raw_code": "def having(opts, *rest)\n      opts.blank? ? self : spawn.having!(opts, *rest)\n    end",
    "comment": "Allows to specify a HAVING clause. Note that you can't use HAVING without also specifying a GROUP clause.  Order.having('SUM(price) > 30').group('user_id')",
    "label": "",
    "id": "2394"
  },
  {
    "raw_code": "def limit(value)\n      spawn.limit!(value)\n    end",
    "comment": "Specifies a limit for the number of records to retrieve.  User.limit(10) # generated SQL has 'LIMIT 10'  User.limit(10).limit(20) # generated SQL has 'LIMIT 20'",
    "label": "",
    "id": "2395"
  },
  {
    "raw_code": "def offset(value)\n      spawn.offset!(value)\n    end",
    "comment": "Specifies the number of rows to skip before returning rows.  User.offset(10) # generated SQL has \"OFFSET 10\"  Should be used with order.  User.offset(10).order(\"name ASC\")",
    "label": "",
    "id": "2396"
  },
  {
    "raw_code": "def lock(locks = true)\n      spawn.lock!(locks)\n    end",
    "comment": "Specifies locking settings (default to +true+). For more information on locking, please see ActiveRecord::Locking.",
    "label": "",
    "id": "2397"
  },
  {
    "raw_code": "def none\n      spawn.none!\n    end",
    "comment": "Returns a chainable relation with zero records.  The returned relation implements the Null Object pattern. It is an object with defined null behavior and always returns an empty array of records without querying the database.  Any subsequent condition chained to the returned relation will continue generating an empty relation and will not fire any query to the database.  Used in cases where a method or scope could return zero records but the result needs to be chainable.  For example:  @posts = current_user.visible_posts.where(name: params[:name]) # the visible_posts method is expected to return a chainable Relation  def visible_posts case role when 'Country Manager' Post.where(country: country) when 'Reviewer' Post.published when 'Bad User' Post.none # It can't be chained if [] is returned. end end ",
    "label": "",
    "id": "2398"
  },
  {
    "raw_code": "def readonly(value = true)\n      spawn.readonly!(value)\n    end",
    "comment": "Mark a relation as readonly. Attempting to update a record will result in an error.  users = User.readonly users.first.save # => ActiveRecord::ReadOnlyRecord: User is marked as readonly  To make a readonly relation writable, pass +false+.  users.readonly(false) users.first.save # => true",
    "label": "",
    "id": "2399"
  },
  {
    "raw_code": "def strict_loading(value = true)\n      spawn.strict_loading!(value)\n    end",
    "comment": "Sets the returned relation to strict_loading mode. This will raise an error if the record tries to lazily load an association.  user = User.strict_loading.first user.comments.to_a # => ActiveRecord::StrictLoadingViolationError",
    "label": "",
    "id": "2400"
  },
  {
    "raw_code": "def create_with(value)\n      spawn.create_with!(value)\n    end",
    "comment": "Sets attributes to be used when creating new records from a relation object.  users = User.where(name: 'Oscar') users.new.name # => 'Oscar'  users = users.create_with(name: 'DHH') users.new.name # => 'DHH'  You can pass +nil+ to #create_with to reset attributes:  users = users.create_with(nil) users.new.name # => 'Oscar'",
    "label": "",
    "id": "2401"
  },
  {
    "raw_code": "def from(value, subquery_name = nil)\n      spawn.from!(value, subquery_name)\n    end",
    "comment": "Specifies the table from which the records will be fetched. For example:  Topic.select('title').from('posts') # SELECT title FROM posts  Can accept other relation objects. For example:  Topic.select('title').from(Topic.approved) # SELECT title FROM (SELECT * FROM topics WHERE approved = 't') subquery  Passing a second argument (string or symbol), creates the alias for the SQL from clause. Otherwise the alias \"subquery\" is used:  Topic.select('a.title').from(Topic.approved, :a) # SELECT a.title FROM (SELECT * FROM topics WHERE approved = 't') a  It does not add multiple arguments to the SQL from clause. The last +from+ chained is the one used:  Topic.select('title').from(Topic.approved).from(Topic.inactive) # SELECT title FROM (SELECT topics.* FROM topics WHERE topics.active = 'f') subquery  For multiple arguments for the SQL from clause, you can pass a string with the exact elements in the SQL from list:  color = \"red\" Color .from(\"colors c, JSONB_ARRAY_ELEMENTS(colored_things) AS colorvalues(colorvalue)\") .where(\"colorvalue->>'color' = ?\", color) .select(\"c.*\").to_a # SELECT c.* # FROM colors c, JSONB_ARRAY_ELEMENTS(colored_things) AS colorvalues(colorvalue) # WHERE (colorvalue->>'color' = 'red')",
    "label": "",
    "id": "2402"
  },
  {
    "raw_code": "def distinct(value = true)\n      spawn.distinct!(value)\n    end",
    "comment": "Specifies whether the records should be unique or not. For example:  User.select(:name) # Might return two records with the same name  User.select(:name).distinct # Returns 1 record per distinct name  User.select(:name).distinct.distinct(false) # You can also remove the uniqueness",
    "label": "",
    "id": "2403"
  },
  {
    "raw_code": "def distinct!(value = true) # :nodoc:\n      self.distinct_value = value\n      self\n    end",
    "comment": "Like #distinct, but modifies relation in place.",
    "label": "",
    "id": "2404"
  },
  {
    "raw_code": "def extending(*modules, &block)\n      if modules.any? || block\n        spawn.extending!(*modules, &block)\n      else\n        self\n      end",
    "comment": "Used to extend a scope with additional methods, either through a module or through a block provided.  The object returned is a relation, which can be further extended.  === Using a \\Module  module Pagination def page(number) # pagination code goes here end end  scope = Model.all.extending(Pagination) scope.page(params[:page])  You can also pass a list of modules:  scope = Model.all.extending(Pagination, SomethingElse)  === Using a Block  scope = Model.all.extending do def page(number) # pagination code goes here end end scope.page(params[:page])  You can also use a block and a module list:  scope = Model.all.extending(Pagination) do def per_page(number) # pagination code goes here end end",
    "label": "",
    "id": "2405"
  },
  {
    "raw_code": "def optimizer_hints(*args)\n      check_if_method_has_arguments!(__callee__, args)\n      spawn.optimizer_hints!(*args)\n    end",
    "comment": "Specify optimizer hints to be used in the SELECT statement.  Example (for MySQL):  Topic.optimizer_hints(\"MAX_EXECUTION_TIME(50000)\", \"NO_INDEX_MERGE(topics)\") # SELECT /*+ MAX_EXECUTION_TIME(50000) NO_INDEX_MERGE(topics) */ `topics`.* FROM `topics`  Example (for PostgreSQL with pg_hint_plan):  Topic.optimizer_hints(\"SeqScan(topics)\", \"Parallel(topics 8)\") # SELECT /*+ SeqScan(topics) Parallel(topics 8) */ \"topics\".* FROM \"topics\"",
    "label": "",
    "id": "2406"
  },
  {
    "raw_code": "def reverse_order\n      spawn.reverse_order!\n    end",
    "comment": "Reverse the existing order clause on the relation.  User.order('name ASC').reverse_order # generated SQL has 'ORDER BY name DESC'",
    "label": "",
    "id": "2407"
  },
  {
    "raw_code": "def annotate(*args)\n      check_if_method_has_arguments!(__callee__, args)\n      spawn.annotate!(*args)\n    end",
    "comment": "Adds an SQL comment to queries generated from this relation. For example:  User.annotate(\"selecting user names\").select(:name) # SELECT \"users\".\"name\" FROM \"users\" /* selecting user names */  User.annotate(\"selecting\", \"user\", \"names\").select(:name) # SELECT \"users\".\"name\" FROM \"users\" /* selecting */ /* user */ /* names */  The SQL block comment delimiters, \"/*\" and \"*/\", will be added automatically.  Some escaping is performed, however untrusted user input should not be used.",
    "label": "",
    "id": "2408"
  },
  {
    "raw_code": "def annotate!(*args) # :nodoc:\n      self.annotate_values |= args\n      self\n    end",
    "comment": "Like #annotate, but modifies relation in place.",
    "label": "",
    "id": "2409"
  },
  {
    "raw_code": "def uniq!(name)\n      if values = @values[name]\n        values.uniq! if values.is_a?(Array) && !values.empty?\n      end",
    "comment": "Deduplicate multiple values.",
    "label": "",
    "id": "2410"
  },
  {
    "raw_code": "def excluding(*records)\n      relations = records.extract! { |element| element.is_a?(Relation) }\n      records.flatten!(1)\n      records.compact!\n\n      unless records.all?(model) && relations.all? { |relation| relation.model == model }\n        raise ArgumentError, \"You must only pass a single or collection of #{model.name} objects to ##{__callee__}.\"\n      end",
    "comment": "Excludes the specified record (or collection of records) from the resulting relation. For example:  Post.excluding(post) # SELECT \"posts\".* FROM \"posts\" WHERE \"posts\".\"id\" != 1  Post.excluding(post_one, post_two) # SELECT \"posts\".* FROM \"posts\" WHERE \"posts\".\"id\" NOT IN (1, 2)  Post.excluding(Post.drafts) # SELECT \"posts\".* FROM \"posts\" WHERE \"posts\".\"id\" NOT IN (3, 4, 5)  This can also be called on associations. As with the above example, either a single record of collection thereof may be specified:  post = Post.find(1) comment = Comment.find(2) post.comments.excluding(comment) # SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"post_id\" = 1 AND \"comments\".\"id\" != 2  This is short-hand for <tt>.where.not(id: post.id)</tt> and <tt>.where.not(id: [post_one.id, post_two.id])</tt>.  An <tt>ArgumentError</tt> will be raised if either no records are specified, or if any of the records in the collection (if a collection is passed in) are not instances of the same model that the relation is scoping.",
    "label": "",
    "id": "2411"
  },
  {
    "raw_code": "def arel(aliases = nil) # :nodoc:\n      @arel ||= build_arel(aliases)\n    end",
    "comment": "Returns the Arel object associated with the relation.",
    "label": "",
    "id": "2412"
  },
  {
    "raw_code": "def check_if_method_has_arguments!(method_name, args, message = nil)\n        if args.blank?\n          raise ArgumentError, message || \"The method .#{method_name}() must contain arguments.\"\n        else\n          yield args if block_given?\n\n          args.flatten!\n          args.compact_blank!\n        end",
    "comment": "Checks to make sure that the arguments are not blank. Note that if some blank-like object were initially passed into the query method, then this method will not raise an error.  Example:  Post.references()   # raises an error Post.references([]) # does not raise an error  This particular method should be called with a method_name (__callee__) and the args passed into that method as an input. For example:  def references(*args) check_if_method_has_arguments!(__callee__, args) ... end",
    "label": "",
    "id": "2413"
  },
  {
    "raw_code": "def merge(other, *rest)\n      if other.is_a?(Array)\n        records & other\n      elsif other\n        spawn.merge!(other, *rest)\n      else\n        raise ArgumentError, \"invalid argument: #{other.inspect}.\"\n      end",
    "comment": "Merges in the conditions from <tt>other</tt>, if <tt>other</tt> is an ActiveRecord::Relation. Returns an array representing the intersection of the resulting records with <tt>other</tt>, if <tt>other</tt> is an array.  Post.where(published: true).joins(:comments).merge( Comment.where(spam: false) ) # Performs a single join query with both where conditions.  recent_posts = Post.order('created_at DESC').first(5) Post.where(published: true).merge(recent_posts) # Returns the intersection of all published posts with the 5 most recently created posts. # (This is just an example. You'd probably want to do this with a single query!)  Procs will be evaluated by merge:  Post.where(published: true).merge(-> { joins(:comments) }) # => Post.where(published: true).joins(:comments)  This is mainly intended for sharing common conditions between multiple associations.  For conditions that exist in both relations, those from <tt>other</tt> will take precedence. To find the intersection of two relations, use QueryMethods#and.",
    "label": "",
    "id": "2414"
  },
  {
    "raw_code": "def except(*skips)\n      relation_with values.except(*skips)\n    end",
    "comment": "Removes the condition(s) specified in +skips+ from the query.  Post.order('id asc').except(:order)                  # removes the order condition Post.where('id > 10').order('id asc').except(:where) # removes the where condition but keeps the order",
    "label": "",
    "id": "2415"
  },
  {
    "raw_code": "def only(*onlies)\n      relation_with values.slice(*onlies)\n    end",
    "comment": "Keeps only the condition(s) specified in +onlies+ in the query, removing all others.  Post.order('id asc').only(:where)         # keeps only the where condition, removes the order Post.order('id asc').only(:where, :order) # keeps only the where and order conditions",
    "label": "",
    "id": "2416"
  },
  {
    "raw_code": "def batch_size\n        @of\n      end",
    "comment": "The size of the batches yielded by the BatchEnumerator.",
    "label": "",
    "id": "2417"
  },
  {
    "raw_code": "def each_record(&block)\n        return to_enum(:each_record) unless block_given?\n\n        @relation.to_enum(:in_batches, of: @of, start: @start, finish: @finish, load: true, cursor: @cursor, order: @order).each do |relation|\n          relation.records.each(&block)\n        end",
    "comment": "Looping through a collection of records from the database (using the +all+ method, for example) is very inefficient since it will try to instantiate all the objects at once.  In that case, batch processing methods allow you to work with the records in batches, thereby greatly reducing memory consumption.  Person.in_batches.each_record do |person| person.do_awesome_stuff end  Person.where(\"age > 21\").in_batches(of: 10).each_record do |person| person.party_all_night! end  If you do not provide a block to #each_record, it will return an Enumerator for chaining with other methods:  Person.in_batches.each_record.with_index do |person, index| person.award_trophy(index + 1) end",
    "label": "",
    "id": "2418"
  },
  {
    "raw_code": "def delete_all\n        sum(&:delete_all)\n      end",
    "comment": "Deletes records in batches. Returns the total number of rows affected.  Person.in_batches.delete_all  See Relation#delete_all for details of how each batch is deleted.",
    "label": "",
    "id": "2419"
  },
  {
    "raw_code": "def update_all(updates)\n        sum do |relation|\n          relation.update_all(updates)\n        end",
    "comment": "Updates records in batches. Returns the total number of rows affected.  Person.in_batches.update_all(\"age = age + 1\")  See Relation#update_all for details of how each batch is updated.",
    "label": "",
    "id": "2420"
  },
  {
    "raw_code": "def touch_all(...)\n        sum do |relation|\n          relation.touch_all(...)\n        end",
    "comment": "Touches records in batches. Returns the total number of rows affected.  Person.in_batches.touch_all  See Relation#touch_all for details of how each batch is touched.",
    "label": "",
    "id": "2421"
  },
  {
    "raw_code": "def destroy_all\n        sum do |relation|\n          relation.destroy_all.count(&:destroyed?)\n        end",
    "comment": "Destroys records in batches. Returns the total number of rows affected.  Person.where(\"age < 10\").in_batches.destroy_all  See Relation#destroy_all for details of how each batch is destroyed.",
    "label": "",
    "id": "2422"
  },
  {
    "raw_code": "def each(&block)\n        enum = @relation.to_enum(:in_batches, of: @of, start: @start, finish: @finish, load: false, cursor: @cursor, order: @order, use_ranges: @use_ranges)\n        return enum.each(&block) if block_given?\n        enum\n      end",
    "comment": "Yields an ActiveRecord::Relation object for each batch of records.  Person.in_batches.each do |relation| relation.update_all(awesome: true) end",
    "label": "",
    "id": "2423"
  },
  {
    "raw_code": "def unscoped(&block)\n          block_given? ? relation.scoping(&block) : relation\n        end",
    "comment": "Returns a scope for the model without the previously set scopes.  class Post < ActiveRecord::Base belongs_to :user  def self.default_scope where(published: true) end end  class User < ActiveRecord::Base has_many :posts end  Post.all                                  # Fires \"SELECT * FROM posts WHERE published = true\" Post.unscoped.all                         # Fires \"SELECT * FROM posts\" Post.where(published: false).unscoped.all # Fires \"SELECT * FROM posts\" User.find(1).posts                        # Fires \"SELECT * FROM posts WHERE published = true AND posts.user_id = 1\" User.find(1).posts.unscoped               # Fires \"SELECT * FROM posts\"  This method also accepts a block. All queries inside the block will not use the previously set scopes.  Post.unscoped { Post.limit(10) # Fires \"SELECT * FROM posts LIMIT 10\" }",
    "label": "",
    "id": "2424"
  },
  {
    "raw_code": "def scope_attributes? # :nodoc:\n          super || default_scopes.any? || respond_to?(:default_scope)\n        end",
    "comment": "Are there attributes associated with this scope?",
    "label": "",
    "id": "2425"
  },
  {
    "raw_code": "def default_scopes?(all_queries: false)\n          if all_queries\n            self.default_scopes.any?(&:all_queries)\n          else\n            self.default_scopes.any?\n          end",
    "comment": "Checks if the model has any default scopes. If all_queries is set to true, the method will check if there are any default_scopes for the model  where +all_queries+ is true.",
    "label": "",
    "id": "2426"
  },
  {
    "raw_code": "def default_scope(scope = nil, all_queries: nil, &block) # :doc:\n            scope = block if block_given?\n\n            if scope.is_a?(Relation) || !scope.respond_to?(:call)\n              raise ArgumentError,\n                \"Support for calling #default_scope without a block is removed. For example instead \" \\\n                \"of `default_scope where(color: 'red')`, please use \" \\\n                \"`default_scope { where(color: 'red') }`. (Alternatively you can just redefine \" \\\n                \"self.default_scope.)\"\n            end",
    "comment": "Use this macro in your model to set a default scope for all operations on the model.  class Article < ActiveRecord::Base default_scope { where(published: true) } end  Article.all # SELECT * FROM articles WHERE published = true  The #default_scope is also applied while creating/building a record. It is not applied while updating or deleting a record.  Article.new.published    # => true Article.create.published # => true  To apply a #default_scope when updating or deleting a record, add <tt>all_queries: true</tt>:  class Article < ActiveRecord::Base default_scope -> { where(blog_id: 1) }, all_queries: true end  Applying a default scope to all queries will ensure that records are always queried by the additional conditions. Note that only where clauses apply, as it does not make sense to add order to queries that return a single object by primary key.  Article.find(1).destroy # DELETE ... FROM `articles` where ID = 1 AND blog_id = 1;  (You can also pass any object which responds to +call+ to the +default_scope+ macro, and it will be called when building the default scope.)  If you use multiple #default_scope declarations in your model then they will be merged together:  class Article < ActiveRecord::Base default_scope { where(published: true) } default_scope { where(rating: 'G') } end  Article.all # SELECT * FROM articles WHERE published = true AND rating = 'G'  This is also the case with inheritance and module includes where the parent or module defines a #default_scope and the child or including class defines a second one.  If you need to do more complex things with a default scope, you can alternatively define it as a class method:  class Article < ActiveRecord::Base def self.default_scope # Should return a scope, you can call 'super' here etc. end end",
    "label": "",
    "id": "2427"
  },
  {
    "raw_code": "def execute_scope?(all_queries, default_scope_obj)\n            all_queries.nil? || all_queries && default_scope_obj.all_queries\n          end",
    "comment": "If all_queries is nil, only execute on select and insert queries.  If all_queries is true, check if the default_scope object has all_queries set, then execute on all queries; select, insert, update, delete, and reload.",
    "label": "",
    "id": "2428"
  },
  {
    "raw_code": "def evaluate_default_scope\n            return if ignore_default_scope?\n\n            begin\n              self.ignore_default_scope = true\n              yield\n            ensure\n              self.ignore_default_scope = false\n            end",
    "comment": "The ignore_default_scope flag is used to prevent an infinite recursion situation where a default scope references a scope which has a default scope which references a scope...",
    "label": "",
    "id": "2429"
  },
  {
    "raw_code": "def all(all_queries: nil)\n          scope = current_scope\n\n          if scope\n            if self == scope.model\n              scope.clone\n            else\n              relation.merge!(scope)\n            end",
    "comment": "Returns an ActiveRecord::Relation scope object.  posts = Post.all posts.size # Fires \"select count(*) from  posts\" and returns the count posts.each {|p| puts p.name } # Fires \"select * from posts\" and loads post objects  fruits = Fruit.all fruits = fruits.where(color: 'red') if options[:red_only] fruits = fruits.limit(10) if limited?  You can define a scope that applies to all finders using {default_scope}[rdoc-ref:Scoping::Default::ClassMethods#default_scope].",
    "label": "",
    "id": "2430"
  },
  {
    "raw_code": "def default_scoped(scope = relation, all_queries: nil)\n          build_default_scope(scope, all_queries: all_queries) || scope\n        end",
    "comment": "Returns a scope for the model with default scopes.",
    "label": "",
    "id": "2431"
  },
  {
    "raw_code": "def scope(name, body, &block)\n          unless body.respond_to?(:call)\n            raise ArgumentError, \"The scope body needs to be callable.\"\n          end",
    "comment": "Adds a class method for retrieving and querying objects. The method is intended to return an ActiveRecord::Relation object, which is composable with other scopes. If it returns +nil+ or +false+, an {all}[rdoc-ref:Scoping::Named::ClassMethods#all] scope is returned instead.  A \\scope represents a narrowing of a database query, such as <tt>where(color: :red).select('shirts.*').includes(:washing_instructions)</tt>.  class Shirt < ActiveRecord::Base scope :red, -> { where(color: 'red') } scope :dry_clean_only, -> { joins(:washing_instructions).where('washing_instructions.dry_clean_only = ?', true) } end  The above calls to #scope define class methods <tt>Shirt.red</tt> and <tt>Shirt.dry_clean_only</tt>. <tt>Shirt.red</tt>, in effect, represents the query <tt>Shirt.where(color: 'red')</tt>.  Note that this is simply 'syntactic sugar' for defining an actual class method:  class Shirt < ActiveRecord::Base def self.red where(color: 'red') end end  Unlike <tt>Shirt.find(...)</tt>, however, the object returned by <tt>Shirt.red</tt> is not an Array but an ActiveRecord::Relation, which is composable with other scopes; it resembles the association object constructed by a {has_many}[rdoc-ref:Associations::ClassMethods#has_many] declaration. For instance, you can invoke <tt>Shirt.red.first</tt>, <tt>Shirt.red.count</tt>, <tt>Shirt.red.where(size: 'small')</tt>. Also, just as with the association objects, named \\scopes act like an Array, implementing Enumerable; <tt>Shirt.red.each(&block)</tt>, <tt>Shirt.red.first</tt>, and <tt>Shirt.red.inject(memo, &block)</tt> all behave as if <tt>Shirt.red</tt> really was an array.  These named \\scopes are composable. For instance, <tt>Shirt.red.dry_clean_only</tt> will produce all shirts that are both red and dry clean only. Nested finds and calculations also work with these compositions: <tt>Shirt.red.dry_clean_only.count</tt> returns the number of garments for which these criteria obtain. Similarly with <tt>Shirt.red.dry_clean_only.average(:thread_count)</tt>.  All scopes are available as class methods on the ActiveRecord::Base descendant upon which the \\scopes were defined. But they are also available to {has_many}[rdoc-ref:Associations::ClassMethods#has_many] associations. If,  class Person < ActiveRecord::Base has_many :shirts end  then <tt>elton.shirts.red.dry_clean_only</tt> will return all of Elton's red, dry clean only shirts.  \\Named scopes can also have extensions, just as with {has_many}[rdoc-ref:Associations::ClassMethods#has_many] declarations:  class Shirt < ActiveRecord::Base scope :red, -> { where(color: 'red') } do def dom_id 'red_shirts' end end end  Scopes can also be used while creating/building a record.  class Article < ActiveRecord::Base scope :published, -> { where(published: true) } end  Article.published.new.published    # => true Article.published.create.published # => true  \\Class methods on your model are automatically available on scopes. Assuming the following setup:  class Article < ActiveRecord::Base scope :published, -> { where(published: true) } scope :featured, -> { where(featured: true) }  def self.latest_article order('published_at desc').first end  def self.titles pluck(:title) end end  We are able to call the methods like this:  Article.published.featured.latest_article Article.featured.titles",
    "label": "",
    "id": "2432"
  },
  {
    "raw_code": "def dump_schema_cache(conn_or_pool, filename)\n        conn_or_pool.schema_cache.dump_to(filename)\n      end",
    "comment": "Dumps the schema cache in YAML format for the connection into the file  ==== Examples ActiveRecord::Tasks::DatabaseTasks.dump_schema_cache(ActiveRecord::Base.lease_connection, \"tmp/schema_dump.yaml\")",
    "label": "",
    "id": "2433"
  },
  {
    "raw_code": "def database_adapter_for(db_config, *arguments)\n          klass = class_for_adapter(db_config.adapter)\n          converted = klass.respond_to?(:using_database_configurations?) && klass.using_database_configurations?\n\n          config = converted ? db_config : db_config.configuration_hash\n          klass.new(config, *arguments)\n        end",
    "comment": "Create a new instance for the specified db configuration object For classes that have been converted to use db_config objects, pass a `DatabaseConfig`, otherwise pass a `Hash`",
    "label": "",
    "id": "2434"
  },
  {
    "raw_code": "def assert_queries_count(count = nil, include_schema: false, &block)\n        ActiveRecord::Base.lease_connection.materialize_transactions unless include_schema\n\n        counter = SQLCounter.new\n        ActiveSupport::Notifications.subscribed(counter, \"sql.active_record\") do\n          result = _assert_nothing_raised_or_warn(\"assert_queries_count\", &block)\n          queries = include_schema ? counter.log_all : counter.log\n          if count\n            assert_equal count, queries.size, \"#{queries.size} instead of #{count} queries were executed. Queries: #{queries.join(\"\\n\\n\")}\"\n          else\n            assert_operator queries.size, :>=, 1, \"1 or more queries expected, but none were executed.#{queries.empty? ? '' : \"\\nQueries:\\n#{queries.join(\"\\n\")}\"}\"\n          end",
    "comment": "Asserts that the number of SQL queries executed in the given block matches the expected count.  # Check for exact number of queries assert_queries_count(1) { Post.first }  # Check for any number of queries assert_queries_count { Post.first }  Any unmaterialized transactions will be materialized to ensure only queries attempted intside the block are counted.  If the +:include_schema+ option is provided, any queries (including schema related) are counted. Setting this option also skips leasing a connection to materialize pending transactions since we want to count queries executed at connection open (e.g., type map).  assert_queries_count(1, include_schema: true) { Post.columns } ",
    "label": "",
    "id": "2435"
  },
  {
    "raw_code": "def assert_no_queries(include_schema: false, &block)\n        assert_queries_count(0, include_schema: include_schema, &block)\n      end",
    "comment": "Asserts that no SQL queries are executed in the given block.  assert_no_queries { post.comments }  If the +:include_schema+ option is provided, any queries (including schema related) are counted.  assert_no_queries(include_schema: true) { Post.columns } ",
    "label": "",
    "id": "2436"
  },
  {
    "raw_code": "def assert_queries_match(match, count: nil, include_schema: false, &block)\n        ActiveRecord::Base.lease_connection.materialize_transactions\n\n        counter = SQLCounter.new\n        ActiveSupport::Notifications.subscribed(counter, \"sql.active_record\") do\n          result = _assert_nothing_raised_or_warn(\"assert_queries_match\", &block)\n          queries = include_schema ? counter.log_all : counter.log\n          matched_queries = queries.select { |query| match === query }\n\n          if count\n            assert_equal count, matched_queries.size, \"#{matched_queries.size} instead of #{count} queries were executed.#{queries.empty? ? '' : \"\\nQueries:\\n#{queries.join(\"\\n\")}\"}\"\n          else\n            assert_operator matched_queries.size, :>=, 1, \"1 or more queries expected, but none were executed.#{queries.empty? ? '' : \"\\nQueries:\\n#{queries.join(\"\\n\")}\"}\"\n          end",
    "comment": "Asserts that the SQL queries executed in the given block match expected pattern.  # Check for exact number of queries assert_queries_match(/LIMIT \\?/, count: 1) { Post.first }  # Check for any number of queries assert_queries_match(/LIMIT \\?/) { Post.first }  If the +:include_schema+ option is provided, any queries (including schema related) that match the matcher are considered.  assert_queries_match(/FROM pg_attribute/i, include_schema: true) { Post.columns } ",
    "label": "",
    "id": "2437"
  },
  {
    "raw_code": "def assert_no_queries_match(match, include_schema: false, &block)\n        assert_queries_match(match, count: 0, include_schema: include_schema, &block)\n      end",
    "comment": "Asserts that no SQL queries matching the pattern are executed in the given block.  assert_no_queries_match(/SELECT/i) { post.comments }  If the +:include_schema+ option is provided, any queries (including schema related) that match the matcher are counted.  assert_no_queries_match(/FROM pg_attribute/i, include_schema: true) { Post.columns } ",
    "label": "",
    "id": "2438"
  },
  {
    "raw_code": "def validates_absence_of(*attr_names)\n        validates_with AbsenceValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates that the specified attributes are not present (as defined by Object#present?). If the attribute is an association, the associated object is also considered not present if it is marked for destruction.  See ActiveModel::Validations::HelperMethods.validates_absence_of for more information.",
    "label": "",
    "id": "2439"
  },
  {
    "raw_code": "def validates_associated(*attr_names)\n        validates_with AssociatedValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates whether the associated object or objects are all valid. Works with any kind of association.  class Book < ActiveRecord::Base has_many :pages belongs_to :library  validates_associated :pages, :library end  WARNING: This validation must not be used on both ends of an association. Doing so will lead to a circular dependency and cause infinite recursion.  NOTE: This validation will not fail if the association hasn't been assigned. If you want to ensure that the association is both present and guaranteed to be valid, you also need to use {validates_presence_of}[rdoc-ref:Validations::ClassMethods#validates_presence_of].  Configuration options:  * <tt>:message</tt> - A custom error message (default is: \"is invalid\"). * <tt>:on</tt> - Specifies the contexts where this validation is active. Runs in all validation contexts by default +nil+. You can pass a symbol or an array of symbols. (e.g. <tt>on: :create</tt> or <tt>on: :custom_validation_context</tt> or <tt>on: [:create, :custom_validation_context]</tt>) * <tt>:if</tt> - Specifies a method, proc, or string to call to determine if the validation should occur (e.g. <tt>if: :allow_validation</tt>, or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method, proc or string should return or evaluate to a +true+ or +false+ value. * <tt>:unless</tt> - Specifies a method, proc, or string to call to determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>, or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The method, proc, or string should return or evaluate to a +true+ or +false+ value.",
    "label": "",
    "id": "2440"
  },
  {
    "raw_code": "def validates_length_of(*attr_names)\n        validates_with LengthValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates that the specified attributes match the length restrictions supplied. If the attribute is an association, records that are marked for destruction are not counted.  See ActiveModel::Validations::HelperMethods.validates_length_of for more information.",
    "label": "",
    "id": "2441"
  },
  {
    "raw_code": "def validates_numericality_of(*attr_names)\n        validates_with NumericalityValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates whether the value of the specified attribute is numeric by trying to convert it to a float with +Kernel.Float+ (if <tt>only_integer</tt> is +false+) or applying it to the regular expression <tt>/\\A[\\+\\-]?\\d+\\z/</tt> (if <tt>only_integer</tt> is set to +true+). +Kernel.Float+ precision defaults to the column's precision value or 15.  See ActiveModel::Validations::HelperMethods.validates_numericality_of for more information.",
    "label": "",
    "id": "2442"
  },
  {
    "raw_code": "def validates_presence_of(*attr_names)\n        validates_with PresenceValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates that the specified attributes are not blank (as defined by Object#blank?). If the attribute is an association, the associated object is also considered blank if it is marked for destruction.  class Person < ActiveRecord::Base has_one :face validates_presence_of :face end  The face attribute must be in the object and it cannot be blank or marked for destruction.  This validator defers to the Active Model validation for presence, adding the check to see that an associated object is not marked for destruction. This prevents the parent object from validating successfully and saving, which then deletes the associated object, thus putting the parent object into an invalid state.  See ActiveModel::Validations::HelperMethods.validates_presence_of for more information.  NOTE: This validation will not fail while using it with an association if the latter was assigned but not valid. If you want to ensure that it is both present and valid, you also need to use {validates_associated}[rdoc-ref:Validations::ClassMethods#validates_associated].",
    "label": "",
    "id": "2443"
  },
  {
    "raw_code": "def find_finder_class_for(record)\n        current_class = record.class\n        found_class = nil\n        loop do\n          found_class = current_class unless current_class.abstract_class?\n          break if current_class == @klass\n          current_class = current_class.superclass\n        end",
    "comment": "The check for an existing value should be run from a class that isn't abstract. This means working down from the current class (self), to the first non-abstract class.",
    "label": "",
    "id": "2444"
  },
  {
    "raw_code": "def validates_uniqueness_of(*attr_names)\n        validates_with UniquenessValidator, _merge_attributes(attr_names)\n      end",
    "comment": "Validates whether the value of the specified attributes are unique across the system. Useful for making sure that only one user can be named \"davidhh\".  class Person < ActiveRecord::Base validates_uniqueness_of :user_name end  It can also validate whether the value of the specified attributes are unique based on a <tt>:scope</tt> parameter:  class Person < ActiveRecord::Base validates_uniqueness_of :user_name, scope: :account_id end  Or even multiple scope parameters. For example, making sure that a teacher can only be on the schedule once per semester for a particular class.  class TeacherSchedule < ActiveRecord::Base validates_uniqueness_of :teacher_id, scope: [:semester_id, :class_id] end  It is also possible to limit the uniqueness constraint to a set of records matching certain conditions. In this example archived articles are not being taken into consideration when validating uniqueness of the title attribute:  class Article < ActiveRecord::Base validates_uniqueness_of :title, conditions: -> { where.not(status: 'archived') } end  To build conditions based on the record's state, define the conditions callable with a parameter, which will be the record itself. This example validates the title is unique for the year of publication:  class Article < ActiveRecord::Base validates_uniqueness_of :title, conditions: ->(article) { published_at = article.published_at where(published_at: published_at.beginning_of_year..published_at.end_of_year) } end  When the record is created, a check is performed to make sure that no record exists in the database with the given value for the specified attribute (that maps to a column). When the record is updated, the same check is made but disregarding the record itself.  Configuration options:  * <tt>:message</tt> - Specifies a custom error message (default is: \"has already been taken\"). * <tt>:scope</tt> - One or more columns by which to limit the scope of the uniqueness constraint. * <tt>:conditions</tt> - Specify the conditions to be included as a <tt>WHERE</tt> SQL fragment to limit the uniqueness constraint lookup (e.g. <tt>conditions: -> { where(status: 'active') }</tt>). * <tt>:case_sensitive</tt> - Looks for an exact match. Ignored by non-text columns. The default behavior respects the default database collation. * <tt>:allow_nil</tt> - If set to +true+, skips this validation if the attribute is +nil+ (default is +false+). * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the attribute is blank (default is +false+). * <tt>:if</tt> - Specifies a method, proc, or string to call to determine if the validation should occur (e.g. <tt>if: :allow_validation</tt>, or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method, proc or string should return or evaluate to a +true+ or +false+ value. * <tt>:unless</tt> - Specifies a method, proc, or string to call to determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>, or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The method, proc, or string should return or evaluate to a +true+ or +false+ value.  === Concurrency and integrity  Using this validation method in conjunction with {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] does not guarantee the absence of duplicate record insertions, because uniqueness checks on the application level are inherently prone to race conditions. For example, suppose that two users try to post a Comment at the same time, and a Comment's title must be unique. At the database-level, the actions performed by these users could be interleaved in the following manner:  User 1                 |               User 2 ------------------------------------+-------------------------------------- # User 1 checks whether there's     | # already a comment with the title  | # 'My Post'. This is not the case.  | SELECT * FROM comments              | WHERE title = 'My Post'             | | | # User 2 does the same thing and also | # infers that their title is unique. | SELECT * FROM comments | WHERE title = 'My Post' | # User 1 inserts their comment.     | INSERT INTO comments                | (title, content) VALUES             | ('My Post', 'hi!')                  | | | # User 2 does the same thing. | INSERT INTO comments | (title, content) VALUES | ('My Post', 'hello!') | | # ^^^^^^ | # Boom! We now have a duplicate | # title!  The best way to work around this problem is to add a unique index to the database table using {connection.add_index}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_index]. In the rare case that a race condition occurs, the database will guarantee the field's uniqueness.  When the database catches such a duplicate insertion, {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] will raise an ActiveRecord::StatementInvalid exception. You can either choose to let this error propagate (which will result in the default \\Rails exception page being shown), or you can catch it and restart the transaction (e.g. by telling the user that the title already exists, and asking them to re-enter the title). This technique is also known as {optimistic concurrency control}[https://en.wikipedia.org/wiki/Optimistic_concurrency_control].  The bundled ActiveRecord::ConnectionAdapters distinguish unique index constraint errors from other types of database errors by throwing an ActiveRecord::RecordNotUnique exception. For other adapters you will have to parse the (database-specific) exception message to detect such a case.  The following bundled adapters throw the ActiveRecord::RecordNotUnique exception:  * ActiveRecord::ConnectionAdapters::Mysql2Adapter. * ActiveRecord::ConnectionAdapters::TrilogyAdapter. * ActiveRecord::ConnectionAdapters::SQLite3Adapter. * ActiveRecord::ConnectionAdapters::PostgreSQLAdapter.",
    "label": "",
    "id": "2445"
  },
  {
    "raw_code": "def lower(column)\n      Nodes::NamedFunction.new \"LOWER\", [Nodes.build_quoted(column)]\n    end",
    "comment": " Create a LOWER() function",
    "label": "",
    "id": "2446"
  },
  {
    "raw_code": "def exists\n      Arel::Nodes::Exists.new @ast\n    end",
    "comment": " Produces an Arel::Nodes::Exists node",
    "label": "",
    "id": "2447"
  },
  {
    "raw_code": "def table(table)\n      @ast.relation = table\n      self\n    end",
    "comment": " UPDATE +table+",
    "label": "",
    "id": "2448"
  },
  {
    "raw_code": "def lower\n        relation.lower self\n      end",
    "comment": " Create a node for lowering this attribute",
    "label": "",
    "id": "2449"
  },
  {
    "raw_code": "def not\n        Nodes::Not.new self\n      end",
    "comment": " Factory method to create a Nodes::Not node that has the recipient of the caller as a child.",
    "label": "",
    "id": "2450"
  },
  {
    "raw_code": "def or(right)\n        Nodes::Grouping.new Nodes::Or.new([self, right])\n      end",
    "comment": " Factory method to create a Nodes::Grouping node that has an Nodes::Or node as a child.",
    "label": "",
    "id": "2451"
  },
  {
    "raw_code": "def and(right)\n        Nodes::And.new [self, right]\n      end",
    "comment": " Factory method to create an Nodes::And node.",
    "label": "",
    "id": "2452"
  },
  {
    "raw_code": "def to_sql(engine = Table.engine)\n        collector = Arel::Collectors::SQLString.new\n        engine.with_connection do |connection|\n          connection.visitor.accept(self, collector).value\n        end",
    "comment": "FIXME: this method should go away.  I don't like people calling to_sql on non-head nodes.  This forces us to walk the AST until we can find a node that has a \"relation\" member.  Maybe we should just use `Table.engine`?  :'(",
    "label": "",
    "id": "2453"
  },
  {
    "raw_code": "def visit_Arel_Nodes_SelectStatement(o, collector)\n          if o.offset && !o.limit\n            o.limit = Arel::Nodes::Limit.new(18446744073709551615)\n          end",
    "comment": " :'( To retrieve all rows from a certain offset up to the end of the result set, you can use some large number for the second parameter. https://dev.mysql.com/doc/refman/en/select.html",
    "label": "",
    "id": "2454"
  },
  {
    "raw_code": "def prepare_update_statement(o)\n          if o.offset || has_group_by_and_having?(o) ||\n            has_join_sources?(o) && has_limit_or_offset_or_orders?(o)\n            super\n          else\n            o\n          end",
    "comment": "In the simple case, MySQL allows us to place JOINs directly into the UPDATE query. However, this does not allow for LIMIT, OFFSET and ORDER. To support these, we must use a subquery.",
    "label": "",
    "id": "2455"
  },
  {
    "raw_code": "def build_subselect(key, o)\n          subselect = super\n\n          # Materialize subquery by adding distinct\n          # to work with MySQL 5.7.6 which sets optimizer_switch='derived_merge=on'\n          unless has_limit_or_offset_or_orders?(subselect)\n            core = subselect.cores.last\n            core.set_quantifier = Arel::Nodes::Distinct.new\n          end",
    "comment": "MySQL doesn't automatically create a temporary table for use subquery, so we have to give it some prompting in the form of a subsubquery.",
    "label": "",
    "id": "2456"
  },
  {
    "raw_code": "def prepare_update_statement(o)\n          if o.key && has_join_sources?(o) && !has_group_by_and_having?(o) && !has_limit_or_offset_or_orders?(o)\n            # Join clauses cannot reference the target table, so alias the\n            # updated table, place the entire relation in the FROM clause, and\n            # add a self-join (which requires the primary key)\n            stmt = o.clone\n            stmt.relation, stmt.wheres = o.relation.clone, o.wheres.clone\n            stmt.relation.right = [stmt.relation.left, *stmt.relation.right]\n            stmt.relation.left = stmt.relation.left.alias(\"__active_record_update_alias\")\n            Array.wrap(o.key).each do |key|\n              stmt.wheres << key.eq(stmt.relation.left[key.name])\n            end",
    "comment": "In the simple case, PostgreSQL allows us to place FROM or JOINs directly into the UPDATE query. However, this does not allow for LIMIT, OFFSET and ORDER. To support these, we must use a subquery.",
    "label": "",
    "id": "2457"
  },
  {
    "raw_code": "def visit_Arel_Nodes_Lock(o, collector)\n          collector\n        end",
    "comment": "Locks are not supported in SQLite",
    "label": "",
    "id": "2458"
  },
  {
    "raw_code": "def infix_value_with_paren(o, collector, value, suppress_parens = false)\n          collector << \"( \" unless suppress_parens\n\n          left = o.left.is_a?(Nodes::Grouping) ? o.left.expr : o.left\n          collector = if left.class == o.class\n            infix_value_with_paren(left, collector, value, true)\n          else\n            grouping_parentheses left, collector, false\n          end",
    "comment": "Queries used in UNION should not be wrapped by parentheses, because it is an invalid syntax in SQLite.",
    "label": "",
    "id": "2459"
  },
  {
    "raw_code": "def visit_Arel_Nodes_SelectOptions(o, collector)\n          collector = maybe_visit o.limit, collector\n          collector = maybe_visit o.offset, collector\n          maybe_visit o.lock, collector\n        end",
    "comment": "The Oracle enhanced adapter uses this private method, see https://github.com/rsim/oracle-enhanced/issues/2186",
    "label": "",
    "id": "2460"
  },
  {
    "raw_code": "def visit_Arel_Nodes_NullsFirst(o, collector)\n          visit o.expr, collector\n          collector << \" NULLS FIRST\"\n        end",
    "comment": "NullsFirst is available on all but MySQL, where it is redefined.",
    "label": "",
    "id": "2461"
  },
  {
    "raw_code": "def prepare_update_statement(o)\n          if o.key && (has_limit_or_offset_or_orders?(o) || has_join_sources?(o))\n            stmt = o.clone\n            stmt.limit = nil\n            stmt.offset = nil\n            stmt.orders = []\n            columns = Arel::Nodes::Grouping.new(o.key)\n            stmt.wheres = [Nodes::In.new(columns, [build_subselect(o.key, o)])]\n            stmt.relation = o.relation.left if has_join_sources?(o)\n            stmt.groups = o.groups unless o.groups.empty?\n            stmt.havings = o.havings unless o.havings.empty?\n            stmt\n          else\n            o\n          end",
    "comment": "The default strategy for an UPDATE with joins is to use a subquery. This doesn't work on MySQL (even when aliasing the tables), but MySQL allows using JOIN directly in an UPDATE statement, so in the MySQL visitor we redefine this to do that.",
    "label": "",
    "id": "2462"
  },
  {
    "raw_code": "def build_subselect(key, o)\n          stmt             = Nodes::SelectStatement.new\n          core             = stmt.cores.first\n          core.froms       = o.relation\n          core.wheres      = o.wheres\n          core.projections = [key]\n          core.groups      = o.groups unless o.groups.empty?\n          core.havings     = o.havings unless o.havings.empty?\n          stmt.limit       = o.limit\n          stmt.offset      = o.offset\n          stmt.orders      = o.orders\n          stmt\n        end",
    "comment": "FIXME: we should probably have a 2-pass visitor for this",
    "label": "",
    "id": "2463"
  },
  {
    "raw_code": "def grouping_parentheses(o, collector, always_wrap_selects = true)\n          if o.is_a?(Nodes::SelectStatement) && (always_wrap_selects || require_parentheses?(o))\n            collector << \"(\"\n            visit o, collector\n            collector << \")\"\n            collector\n          else\n            visit o, collector\n          end",
    "comment": "Used by some visitors to enclose select queries in parentheses",
    "label": "",
    "id": "2464"
  },
  {
    "raw_code": "def self.base_root\n        __dir__\n      end",
    "comment": "Set the current directory as base for the inherited generators.",
    "label": "",
    "id": "2465"
  },
  {
    "raw_code": "def next_migration_number(dirname)\n          next_migration_number = current_migration_number(dirname) + 1\n          ActiveRecord::Migration.next_migration_number(next_migration_number)\n        end",
    "comment": "Implement the required interface for Rails::Generators::Migration.",
    "label": "",
    "id": "2466"
  },
  {
    "raw_code": "def create_application_record\n        template \"application_record.rb\", application_record_file_name\n      end",
    "comment": "FIXME: Change this file to a symlink once RubyGems 2.5.0 is required.",
    "label": "",
    "id": "2467"
  },
  {
    "raw_code": "def set_local_assigns!\n          @migration_template = \"migration.rb\"\n          case file_name\n          when /^(add)_.*_to_(.*)/, /^(remove)_.*?_from_(.*)/\n            @migration_action = $1\n            @table_name       = normalize_table_name($2)\n          when /join_table/\n            if attributes.length == 2\n              @migration_action = \"join\"\n              @join_tables      = pluralize_table_names? ? attributes.map(&:plural_name) : attributes.map(&:singular_name)\n\n              set_index_names\n            end",
    "comment": "Sets the default migration template that is being used for the generation of the migration. Depending on command line arguments, the migration template and the table name instance variables are set up.",
    "label": "",
    "id": "2468"
  },
  {
    "raw_code": "def validate_file_name!\n          unless /^[_a-z0-9]+$/.match?(file_name)\n            raise IllegalMigrationNameError.new(file_name)\n          end",
    "comment": "A migration file name can only contain underscores (_), lowercase characters, and numbers 0-9. Any other file name will raise an IllegalMigrationNameError.",
    "label": "",
    "id": "2469"
  },
  {
    "raw_code": "def create_migration_file\n        return if skip_migration_creation?\n        attributes.each { |a| a.attr_options.delete(:index) if a.reference? && !a.has_index? } if options[:indexes] == false\n        migration_template \"create_table_migration.rb\", File.join(db_migrate_path, \"create_#{table_name}.rb\")\n      end",
    "comment": "creates the migration file for the model.",
    "label": "",
    "id": "2470"
  },
  {
    "raw_code": "def skip_migration_creation?\n          custom_parent? && !database || !migration\n        end",
    "comment": "Skip creating migration file if: - options parent is present and database option is not present - migrations option is nil or false",
    "label": "",
    "id": "2471"
  },
  {
    "raw_code": "def parent_class_name\n          if custom_parent?\n            parent\n          elsif database\n            abstract_class_name\n          else\n            parent\n          end",
    "comment": "Used by the migration template to determine the parent name of the model",
    "label": "",
    "id": "2472"
  },
  {
    "raw_code": "def test_a_marked_for_destruction_record_should_not_be_be_marked_after_reload\n    @pirate.mark_for_destruction\n    @pirate.ship.mark_for_destruction\n\n    assert_not_predicate @pirate.reload, :marked_for_destruction?\n    assert_not_predicate @pirate.ship.reload, :marked_for_destruction?\n  end",
    "comment": "reload",
    "label": "",
    "id": "2473"
  },
  {
    "raw_code": "def test_should_destroy_a_child_association_as_part_of_the_save_transaction_if_it_was_marked_for_destruction\n    assert_not_predicate @pirate.ship, :marked_for_destruction?\n\n    @pirate.ship.mark_for_destruction\n    id = @pirate.ship.id\n\n    assert_predicate @pirate.ship, :marked_for_destruction?\n    assert Ship.find_by_id(id)\n\n    @pirate.save\n    assert_nil @pirate.reload.ship\n    assert_nil Ship.find_by_id(id)\n  end",
    "comment": "has_one",
    "label": "",
    "id": "2474"
  },
  {
    "raw_code": "def test_should_destroy_a_parent_association_as_part_of_the_save_transaction_if_it_was_marked_for_destruction\n    assert_not_predicate @ship.pirate, :marked_for_destruction?\n\n    @ship.pirate.mark_for_destruction\n    id = @ship.pirate.id\n\n    assert_predicate @ship.pirate, :marked_for_destruction?\n    assert Pirate.find_by_id(id)\n\n    @ship.save\n    assert_nil @ship.reload.pirate\n    assert_nil Pirate.find_by_id(id)\n  end",
    "comment": "belongs_to",
    "label": "",
    "id": "2475"
  },
  {
    "raw_code": "def test_autosave_cpk_association_should_destroy_parent_association_when_marked_for_destruction\n    book = Cpk::Book.new(title: \"Book\", id: [1, 2])\n    Cpk::Order.create!(id: [3, 4], book: book)\n\n    book.order.mark_for_destruction\n\n    assert book.save\n    assert_nil book.reload.order\n    assert_nil Cpk::Order.find_by(id: 4, shop_id: 3)\n  end",
    "comment": "belongs_to for CPK",
    "label": "",
    "id": "2476"
  },
  {
    "raw_code": "def test_should_not_include_default_clause_when_default_is_null\n        column_def = ColumnDefinition.new(\"title\", \"string\", limit: 20)\n        assert_equal \"title varchar(20)\", @viz.accept(column_def)\n      end",
    "comment": "Avoid column definitions in create table statements like: `title` varchar(255) DEFAULT NULL",
    "label": "",
    "id": "2477"
  },
  {
    "raw_code": "def test_checkout_fairness\n        skip_fiber_testing\n\n        @pool.instance_variable_set(:@max_connections, 10)\n        expected = (1..@pool.size).to_a.freeze\n        # check out all connections so our threads start out waiting\n        conns = expected.map { @pool.checkout }\n        mutex = Mutex.new\n        order = []\n        errors = []\n        dispose_held_connections = Concurrent::Event.new\n\n        threads = expected.map do |i|\n          t = new_thread {\n            begin\n              @pool.checkout # never checked back in\n              mutex.synchronize { order << i }\n\n              # if the thread terminates, its connection may be\n              # reclaimed by the pool, so we need to hold on to it\n              # until we're done trickling in connections\n              dispose_held_connections.wait\n            rescue => e\n              mutex.synchronize { errors << e }\n            end",
    "comment": "The connection pool is \"fair\" if threads waiting for connections receive them in the order in which they began waiting.  This ensures that we don't timeout one HTTP request even while well under capacity in a multi-threaded environment such as a Java servlet container.  We don't need strict fairness: if two connections become available at the same time, it's fine if two threads that were waiting acquire the connections out of order.  Thus this test prepares waiting threads and then trickles in available connections slowly, ensuring the wakeup order is correct in this case.",
    "label": "",
    "id": "2478"
  },
  {
    "raw_code": "def test_checkout_fairness_by_group\n        skip_fiber_testing\n\n        @pool.instance_variable_set(:@max_connections, 10)\n        # take all the connections\n        conns = (1..10).map { @pool.checkout }\n        mutex = Mutex.new\n        successes = []    # threads that successfully got a connection\n        errors = []\n        dispose_held_connections = Concurrent::Event.new\n\n        make_thread = proc do |i|\n          t = new_thread {\n            begin\n              @pool.checkout # never checked back in\n              mutex.synchronize { successes << i }\n\n              dispose_held_connections.wait\n            rescue => e\n              mutex.synchronize { errors << e }\n            end",
    "comment": "As mentioned in #test_checkout_fairness, we don't care about strict fairness.  This test creates two groups of threads: group1 whose members all start waiting before any thread in group2.  Enough connections are checked in to wakeup all group1 threads, and the fact that only group1 and no group2 threads acquired a connection is enforced.",
    "label": "",
    "id": "2479"
  },
  {
    "raw_code": "def test_sequential_maintenance_loop_is_incremental\n        work_queue = []\n        work_collector = Object.new\n        work_collector.define_singleton_method(:post) do |&block|\n          work_queue << block\n        end",
    "comment": "-- This is testing a private method... but testing its public callers would be much more complicated, as well as needing duplicate coverage.",
    "label": "",
    "id": "2480"
  },
  {
    "raw_code": "def test_anonymous_class_exception\n        anonymous = Class.new(ActiveRecord::Base)\n\n        assert_raises(RuntimeError) do\n          anonymous.establish_connection\n        end",
    "comment": "make sure exceptions are thrown when establish_connection is called with an anonymous class",
    "label": "",
    "id": "2481"
  },
  {
    "raw_code": "def test_mysql_not_null_defaults_non_strict\n      using_strict(false) do\n        with_mysql_not_null_table do |klass|\n          record = klass.new\n          assert_nil record.non_null_integer\n          assert_nil record.non_null_string\n          assert_nil record.non_null_text\n          assert_nil record.non_null_blob\n\n          record.save!\n          record.reload\n\n          assert_equal 0,  record.non_null_integer\n          assert_equal \"\", record.non_null_string\n          assert_equal \"\", record.non_null_text\n          assert_equal \"\", record.non_null_blob\n        end",
    "comment": "Strict mode controls how MySQL handles invalid or missing values in data-change statements such as INSERT or UPDATE. A value can be invalid for several reasons. For example, it might have the wrong data type for the column, or it might be out of range. A value is missing when a new row to be inserted does not contain a value for a non-NULL column that has no explicit DEFAULT clause in its definition. (For a NULL column, NULL is inserted if the value is missing.)  If strict mode is not in effect, MySQL inserts adjusted values for invalid or missing values and produces warnings. In strict mode, you can produce this behavior by using INSERT IGNORE or UPDATE IGNORE.  https://dev.mysql.com/doc/refman/en/sql-mode.html#sql-mode-strict",
    "label": "",
    "id": "2482"
  },
  {
    "raw_code": "def setup\n    Person.create first_name: \"foo\"\n  end",
    "comment": "Dummy to force column loads so query counts are clean.",
    "label": "",
    "id": "2483"
  },
  {
    "raw_code": "def test_find_with_string\n    assert_equal(Topic.find(1).title, Topic.find(\"1\").title)\n  end",
    "comment": "find should handle strings that come from URLs (example: Category.find(params[:id]))",
    "label": "",
    "id": "2484"
  },
  {
    "raw_code": "def test_exists_with_nil_arg\n    assert_equal false, Topic.exists?(nil)\n    assert_equal true, Topic.exists?\n\n    assert_equal false, Topic.first.replies.exists?(nil)\n    assert_equal true, Topic.first.replies.exists?\n  end",
    "comment": "exists? should handle nil for id's that come from URLs and always return false (example: Topic.exists?(params[:id])) where params[:id] is nil",
    "label": "",
    "id": "2485"
  },
  {
    "raw_code": "def test_exists_with_order_and_distinct\n    assert_equal true, Topic.order(:id).distinct.exists?\n  end",
    "comment": "Ensure +exists?+ runs without an error by excluding distinct value. See https://github.com/rails/rails/pull/26981.",
    "label": "",
    "id": "2486"
  },
  {
    "raw_code": "def test_exists_with_order\n    assert_equal true, Topic.order(Arel.sql(\"invalid sql here\")).exists?\n  end",
    "comment": "Ensure +exists?+ runs without an error by excluding order value.",
    "label": "",
    "id": "2487"
  },
  {
    "raw_code": "def test_first_without_order_columns_and_raise_on_missing_required_finder_order_columns_disabled\n    raise_on_missing_required_finder_order_columns_before = ActiveRecord.raise_on_missing_required_finder_order_columns\n    ActiveRecord.raise_on_missing_required_finder_order_columns = false\n\n    assert_nil Edge.primary_key\n    assert_nil Edge.implicit_order_column\n    assert_nil Edge.query_constraints_list\n    assert_nothing_raised do\n      assert_deprecated(/Calling order dependent finder methods/, ActiveRecord.deprecator) do\n        Edge.all.first\n      end",
    "comment": "TODO: Remove this test when we remove the deprecated `raise_on_missing_required_finder_order_columns`",
    "label": "",
    "id": "2488"
  },
  {
    "raw_code": "def test_last_without_order_columns_and_raise_on_missing_required_finder_order_columns_disabled\n    raise_on_missing_required_finder_order_columns_before = ActiveRecord.raise_on_missing_required_finder_order_columns\n    ActiveRecord.raise_on_missing_required_finder_order_columns = false\n\n    assert_nil Edge.primary_key\n    assert_nil Edge.implicit_order_column\n    assert_nil Edge.query_constraints_list\n    error = assert_raises(ActiveRecord::IrreversibleOrderError) do\n      assert_deprecated(/Calling order dependent finder methods/, ActiveRecord.deprecator) do\n        Edge.all.last\n      end",
    "comment": "TODO: Remove this test when we remove `raise_on_missing_required_finder_order_columns`",
    "label": "",
    "id": "2489"
  },
  {
    "raw_code": "def setup\n    @first = true\n  end",
    "comment": "fixtures :topics",
    "label": "",
    "id": "2490"
  },
  {
    "raw_code": "def test_number1\n    assert true\n  end",
    "comment": "if foreign keys are implemented and fixtures are not deleted in reverse order then this test case will raise StatementInvalid",
    "label": "",
    "id": "2491"
  },
  {
    "raw_code": "def with_two_connections\n      run_without_connection do |original_connection|\n        ActiveRecord::Base.establish_connection(original_connection.merge(pool_size: 2))\n        begin\n          ddl_connection = ActiveRecord::Base.connection_pool.checkout\n          begin\n            yield original_connection, ddl_connection\n          ensure\n            ActiveRecord::Base.connection_pool.checkin ddl_connection\n          end",
    "comment": "Rails will automatically clear the prepared statements on the connection that runs the migration, so we use two connections to simulate what would actually happen on a production system; we'd have one connection running the migration from the rake task (\"ddl_connection\" here), and we'd have another connection in a web worker.",
    "label": "",
    "id": "2492"
  },
  {
    "raw_code": "def test_lock_destroy\n    p1 = Person.find(1)\n    p2 = Person.find(1)\n    assert_equal 0, p1.lock_version\n    assert_equal 0, p2.lock_version\n\n    p1.first_name = \"stu\"\n    p1.save!\n    assert_equal 1, p1.lock_version\n    assert_equal 0, p2.lock_version\n\n    assert_raises(ActiveRecord::StaleObjectError) { p2.destroy }\n\n    assert p1.destroy\n    assert_predicate p1, :frozen?\n    assert_predicate p1, :destroyed?\n    assert_raises(ActiveRecord::RecordNotFound) { Person.find(1) }\n  end",
    "comment": "See Lighthouse ticket #1966",
    "label": "",
    "id": "2493"
  },
  {
    "raw_code": "def test_update_without_attributes_does_not_only_update_lock_version\n    assert_nothing_raised do\n      p1 = Person.create!(first_name: \"anika\")\n      lock_version = p1.lock_version\n      p1.save\n      p1.reload\n      assert_equal lock_version, p1.lock_version\n    end",
    "comment": "Useful for partial updates, don't only update the lock_version if there is nothing else being updated.",
    "label": "",
    "id": "2494"
  },
  {
    "raw_code": "def test_destroy_dependents\n    # Establish dependent relationship between Person and PersonalLegacyThing\n    add_counter_column_to(Person, \"personal_legacy_things_count\")\n    PersonalLegacyThing.reset_column_information\n\n    # Make sure that counter incrementing doesn't cause problems\n    p1 = Person.new(first_name: \"fjord\")\n    p1.save!\n    t = PersonalLegacyThing.new(person: p1)\n    t.save!\n    p1.reload\n    assert_equal 1, p1.personal_legacy_things_count\n    assert p1.destroy\n    assert_equal true, p1.frozen?\n    assert_raises(ActiveRecord::RecordNotFound) { Person.find(p1.id) }\n    assert_raises(ActiveRecord::RecordNotFound) { PersonalLegacyThing.find(t.id) }\n  ensure\n    remove_counter_column_from(Person, \"personal_legacy_things_count\")\n    PersonalLegacyThing.reset_column_information\n  end",
    "comment": "See Lighthouse ticket #1966",
    "label": "",
    "id": "2495"
  },
  {
    "raw_code": "def test_typical_find_with_lock\n      assert_nothing_raised do\n        Person.transaction do\n          Person.lock.find(1)\n        end",
    "comment": "Test typical find.",
    "label": "",
    "id": "2496"
  },
  {
    "raw_code": "def test_eager_find_with_lock\n        assert_nothing_raised do\n          Person.transaction do\n            Person.includes(:readers).lock.find(1)\n          end",
    "comment": "Test locked eager find.",
    "label": "",
    "id": "2497"
  },
  {
    "raw_code": "def new_isolated_reminder_class\n      Class.new(Reminder) {\n        def self.name; \"Reminder\"; end\n        def self.base_class; self; end\n      }\n    end\n\n    def clear_statement_cache(model)\n      model.connection_handler.each_connection_pool do |pool|\n        pool.connections.each(&:clear_cache!)\n      end\n    end\n\n    def with_another_process_holding_lock(lock_id)\n      thread_lock = Concurrent::CountDownLatch.new\n      test_terminated = Concurrent::CountDownLatch.new\n\n      other_process = Thread.new do\n        conn = ActiveRecord::Base.connection_pool.checkout\n        conn.get_advisory_lock(lock_id)\n        thread_lock.count_down\n        test_terminated.wait # hold the lock open until we tested everything\n      ensure\n        conn.release_advisory_lock(lock_id)\n        ActiveRecord::Base.connection_pool.checkin(conn)\n      end\n\n      thread_lock.wait # wait until the 'other process' has the lock\n\n      yield\n\n      test_terminated.count_down\n      other_process.join\n    end",
    "comment": "This is needed to isolate class_attribute assignments like `table_name_prefix` for each test case.",
    "label": "",
    "id": "2498"
  },
  {
    "raw_code": "def test_eager_loading_in_modules\n    clients = []\n\n    assert_nothing_raised do\n      clients << MyApplication::Business::Client.references(:accounts).merge!(includes: { firm: :account }, where: \"accounts.id IS NOT NULL\").find(3)\n      clients << MyApplication::Business::Client.includes(firm: :account).find(3)\n    end",
    "comment": "An eager loading condition to force the eager loading model into the old join model.",
    "label": "",
    "id": "2499"
  },
  {
    "raw_code": "def checkout_checkin_connections(max_connections, threads)\n        ActiveRecord::Base.establish_connection(@connection.merge(max_connections: max_connections, checkout_timeout: 0.5))\n        @connection_count = 0\n        @timed_out = 0\n        threads.times do\n          Thread.new do\n            conn = ActiveRecord::Base.connection_pool.checkout\n            sleep 0.1\n            ActiveRecord::Base.connection_pool.checkin conn\n            @connection_count += 1\n          rescue ActiveRecord::ConnectionTimeoutError\n            @timed_out += 1\n          end.join\n        end",
    "comment": "Will deadlock due to lack of Monitor timeouts in 1.9",
    "label": "",
    "id": "2500"
  },
  {
    "raw_code": "def hash\n      1\n    end",
    "comment": "this isn't very realistic, but it is the worst case and therefore a good case to test",
    "label": "",
    "id": "2501"
  },
  {
    "raw_code": "def test_quoted_datetime_local\n        with_timezone_config default: :local do\n          t = Time.now.change(usec: 0).to_datetime\n          assert_equal t.to_fs(:db), @quoter.quoted_date(t)\n        end",
    "comment": " DateTime doesn't define getlocal, so make sure it does nothing",
    "label": "",
    "id": "2502"
  },
  {
    "raw_code": "def test_nil_time\n        fp = FakePool.new\n        assert_not fp.reaped\n        reaper = ConnectionPool::Reaper.new(fp, nil)\n        reaper.run\n        assert_not fp.reaped\n      ensure\n        fp.discard!\n      end",
    "comment": "A reaper with nil time should never reap connections",
    "label": "",
    "id": "2503"
  },
  {
    "raw_code": "def test_reap_flush_on_discarded_pool\n        pool_config = duplicated_pool_config\n        pool = ConnectionPool.new(pool_config)\n\n        pool.discard!\n        assert_nothing_raised do\n          pool.reap\n          pool.flush\n        end",
    "comment": "This doesn't test the reaper directly, but we want to test the action it would take on a discarded pool",
    "label": "",
    "id": "2504"
  },
  {
    "raw_code": "def create_test_fixtures(*fixture_names)\n      ActiveRecord::FixtureSet.create_fixtures(FIXTURES_ROOT + \"/reserved_words\", fixture_names)\n    end",
    "comment": "custom fixture loader, uses FixtureSet#create_fixtures and appends base_path to the current file's path",
    "label": "",
    "id": "2505"
  },
  {
    "raw_code": "def assert_queries_match(match, count: nil, include_schema: false, &block)\n      counter = SQLCounter.new\n      ActiveSupport::Notifications.subscribed(counter, \"sql.active_record\") do\n        result = _assert_nothing_raised_or_warn(\"assert_queries_match\", &block)\n        queries = include_schema ? counter.log_all : counter.log\n        matched_queries = queries.select { |query| match === query }\n\n        if count\n          assert_equal count, matched_queries.size, \"#{matched_queries.size} instead of #{count} queries were executed.#{queries.empty? ? '' : \"\\nQueries:\\n#{queries.join(\"\\n\")}\"}\"\n        else\n          assert_operator matched_queries.size, :>=, 1, \"1 or more queries expected, but none were executed.#{queries.empty? ? '' : \"\\nQueries:\\n#{queries.join(\"\\n\")}\"}\"\n        end",
    "comment": "Redefine existing assertion method to explicitly not materialize transactions.",
    "label": "",
    "id": "2506"
  },
  {
    "raw_code": "def test_transaction_per_thread\n      threads = 3.times.map do\n        Thread.new do\n          Topic.transaction do\n            topic = Topic.find(1)\n            topic.approved = !topic.approved?\n            assert topic.save!\n            topic.approved = !topic.approved?\n            assert topic.save!\n          end",
    "comment": "This will cause transactions to overlap and fail unless they are performed on separate database connections.",
    "label": "",
    "id": "2507"
  },
  {
    "raw_code": "def test_transaction_isolation__read_committed\n      # Should be invariant.\n      original_salary = Developer.find(1).salary\n      temporary_salary = 200000\n\n      assert_nothing_raised do\n        threads = (1..3).map do\n          Thread.new do\n            Developer.transaction do\n              # Expect original salary.\n              dev = Developer.find(1)\n              assert_equal original_salary, dev.salary\n\n              dev.salary = temporary_salary\n              dev.save!\n\n              # Expect temporary salary.\n              dev = Developer.find(1)\n              assert_equal temporary_salary, dev.salary\n\n              dev.salary = original_salary\n              dev.save!\n\n              # Expect original salary.\n              dev = Developer.find(1)\n              assert_equal original_salary, dev.salary\n            end",
    "comment": "Test for dirty reads among simultaneous transactions.",
    "label": "",
    "id": "2508"
  },
  {
    "raw_code": "def test_before_commit_exception_should_pop_transaction_stack\n    @first.before_commit_block { raise \"better pop this txn from the stack!\" }\n\n    original_txn = @first.class.lease_connection.current_transaction\n\n    begin\n      @first.save!\n      fail\n    rescue\n      assert_equal original_txn, @first.class.lease_connection.current_transaction\n    end",
    "comment": "FIXME: Test behavior, not implementation.",
    "label": "",
    "id": "2509"
  },
  {
    "raw_code": "def supports_analyze?\n      conn.mariadb? && conn.database_version >= \"10.1.0\"\n    end",
    "comment": "https://mariadb.com/kb/en/analyze-statement/",
    "label": "",
    "id": "2510"
  },
  {
    "raw_code": "def make_parent_transaction_dirty\n        Sample.take\n      end",
    "comment": "This should cause the next nested transaction to be a savepoint transaction.",
    "label": "",
    "id": "2511"
  },
  {
    "raw_code": "def test_multi_results\n    rows = @connection.select_rows(\"CALL ten();\")\n    assert_equal 10, rows[0][0].to_i, \"ten() did not return 10 as expected: #{rows.inspect}\"\n\n    assert_predicate @connection, :active?, \"Bad connection use by '#{@connection.class}.select_rows'\"\n  end",
    "comment": "Test that MySQL allows multiple results for stored procedures  In MySQL 5.6, CLIENT_MULTI_RESULTS is enabled by default. https://dev.mysql.com/doc/refman/en/call.html",
    "label": "",
    "id": "2512"
  },
  {
    "raw_code": "def test_connection_options\n      params = ActiveRecord::Base.connection_db_config.configuration_hash.dup\n      params[:options] = \"-c geqo=off\"\n      NonExistentTable.establish_connection(params)\n\n      # Verify the connection param has been applied.\n      expect = NonExistentTable.lease_connection.query(\"show geqo\").first.first\n      assert_equal \"off\", expect\n    ensure\n      NonExistentTable.remove_connection\n    end",
    "comment": "Ensure, we can set connection params using the example of Generic Query Optimizer (geqo). It is 'on' per default.",
    "label": "",
    "id": "2513"
  },
  {
    "raw_code": "def test_structure_dump\n      assert_equal \"\", File.read(@filename)\n\n      config = @configuration.dup\n      config[\"database\"] = ARTest.config[\"connections\"][\"postgresql\"][\"arunit\"][\"database\"]\n\n      ActiveRecord::Tasks::DatabaseTasks.structure_dump(config, @filename)\n\n      assert File.read(@filename).include?(\"PostgreSQL database dump complete\")\n    end",
    "comment": "This test actually runs a dump so we can ensure all the arguments are parsed correctly. All other tests in this class just mock the call (using assert_called_with) to make the tests quicker.",
    "label": "",
    "id": "2514"
  },
  {
    "raw_code": "def make_parent_transaction_dirty\n        Bit.take\n      end",
    "comment": "These tests are coordinating a controlled sequence of accesses to rows in `samples` table under serializable isolation. We need to run a query to dirty our transaction, but must avoid touching `samples` rows because otherwise our no-op query becomes an active participant of the test setup",
    "label": "",
    "id": "2515"
  },
  {
    "raw_code": "def test_nil_timeout\n        conn = SQLite3Adapter.new(\n          database: \":memory:\",\n          adapter: \"sqlite3\",\n          timeout: nil,\n        )\n        conn.connect!\n        assert conn, \"made a connection\"\n      end",
    "comment": "connection is OK with a nil timeout",
    "label": "",
    "id": "2516"
  },
  {
    "raw_code": "def test_encoding\n        assert_equal \"UTF-8\", @conn.encoding\n      end",
    "comment": "sqlite3 defaults to UTF-8 encoding",
    "label": "",
    "id": "2517"
  },
  {
    "raw_code": "def fake_pg_caster\n          Object.new.tap do |caster|\n            def caster.type_cast_for_database(attr_name, value)\n              if attr_name == \"tags\"\n                \"{#{value.join(\",\")}}\"\n              else\n                value\n              end\n            end",
    "comment": "Mimic PG::TextDecoder::Array casting",
    "label": "",
    "id": "2518"
  },
  {
    "raw_code": "def fake_pg_caster\n      Object.new.tap do |caster|\n        def caster.type_for_attribute(attr_name)\n          STRING_TYPE\n        end\n      end",
    "comment": "map that converts attribute names to a caster",
    "label": "",
    "id": "2519"
  },
  {
    "raw_code": "def send(*args)\n        super\n      rescue\n        # Both threads try (and fail) to dispatch to the subclass's name\n        @barrier.wait\n        raise\n      ensure\n        # Then one thread successfully completes (updating the dispatch\n        # table in the process) before the other finishes raising its\n        # exception.\n        Thread.current[:delay].wait if Thread.current[:delay]\n      end",
    "comment": "This is terrible, but it's the only way to reliably reproduce the possible race where two threads attempt to correct the dispatch hash at the same time.",
    "label": "",
    "id": "2520"
  },
  {
    "raw_code": "def test_nested_loading_does_not_raise_exception_when_association_does_not_exist\n    assert_nothing_raised do\n      Post.all.merge!(includes: { author: :non_existing_association }).find(posts(:authorless).id)\n    end",
    "comment": "Regression test for 21c75e5",
    "label": "",
    "id": "2521"
  },
  {
    "raw_code": "def test_has_and_belongs_to_many_should_not_instantiate_same_records_multiple_times\n    welcome    = posts(:welcome)\n    categories = Category.includes(:posts)\n\n    general    = categories.find { |c| c == categories(:general) }\n    technology = categories.find { |c| c == categories(:technology) }\n\n    post1 = general.posts.to_a.find { |p| p == welcome }\n    post2 = technology.posts.to_a.find { |p| p == welcome }\n\n    assert_same post1, post2\n  end",
    "comment": "Since the preloader for habtm gets raw row hashes from the database and then instantiates them, this test ensures that it only instantiates one actual object per record from the database.",
    "label": "",
    "id": "2522"
  },
  {
    "raw_code": "def assert_equal_after_sort(item1, item2, item3 = nil)\n      assert_equal(item1.sort { |a, b| a.id <=> b.id }, item2.sort { |a, b| a.id <=> b.id })\n      assert_equal(item3.sort { |a, b| a.id <=> b.id }, item2.sort { |a, b| a.id <=> b.id }) if item3\n    end",
    "comment": "Eager includes of has many and habtm associations aren't necessarily sorted in the same way",
    "label": "",
    "id": "2523"
  },
  {
    "raw_code": "def test_build_and_create_should_not_happen_within_scope\n    car = cars(:honda)\n    scope = car.foo_bulbs.where_values_hash\n\n    bulb = car.foo_bulbs.build\n    assert_not_equal scope, bulb.scope_after_initialize.where_values_hash\n\n    bulb = car.foo_bulbs.create\n    assert_not_equal scope, bulb.scope_after_initialize.where_values_hash\n\n    bulb = car.foo_bulbs.create!\n    assert_not_equal scope, bulb.scope_after_initialize.where_values_hash\n  end",
    "comment": "When creating objects on the association, we must not do it within a scope (even though it would be convenient), because this would cause that scope to be applied to any callbacks etc.",
    "label": "",
    "id": "2524"
  },
  {
    "raw_code": "def setup\n    Person.create first_name: \"gummy\"\n    Reader.create person_id: 0, post_id: 0\n  end",
    "comment": "Dummies to force column loads so query counts are clean.",
    "label": "",
    "id": "2525"
  },
  {
    "raw_code": "def find_post_with_dependency(post_id, association, association_name, dependency)\n      class_name = \"PostWith#{association.to_s.classify}#{dependency.to_s.classify}\"\n      Post.find(post_id).update_columns type: class_name\n      klass = Object.const_set(class_name, Class.new(ActiveRecord::Base))\n      klass.table_name = \"posts\"\n      klass.public_send(association, association_name, as: :taggable, dependent: dependency)\n      klass.find(post_id)\n    end",
    "comment": "create dynamic Post models to allow different dependency options",
    "label": "",
    "id": "2526"
  },
  {
    "raw_code": "def test_has_many_through_has_many_with_has_many_through_source_reflection\n    general = tags(:general)\n    assert_equal [general, general], authors(:david).tags\n  end",
    "comment": "Through associations can either use the has_many or has_one macros.  has_many - Source reflection can be has_many, has_one, belongs_to or has_and_belongs_to_many - Through reflection can be has_many, has_one, belongs_to or has_and_belongs_to_many  has_one - Source reflection can be has_one or belongs_to - Through reflection can be has_one or belongs_to  Additionally, the source reflection and/or through reflection may be subject to polymorphism and/or STI.  When testing these, we need to make sure it works via loading the association directly, or joining the association, or including the association. We also need to ensure that associations are readonly where relevant. has_many through Source: has_many through Through: has_many",
    "label": "",
    "id": "2527"
  },
  {
    "raw_code": "def test_has_many_through_has_many_through_with_has_many_source_reflection\n    luke, david = subscribers(:first), subscribers(:second)\n    assert_equal [luke, david, david], authors(:david).subscribers.order(\"subscribers.nick\")\n  end",
    "comment": "has_many through Source: has_many Through: has_many through",
    "label": "",
    "id": "2528"
  },
  {
    "raw_code": "def test_has_many_through_has_one_with_has_one_through_source_reflection\n    assert_equal [member_types(:founding)], members(:groucho).nested_member_types\n  end",
    "comment": "has_many through Source: has_one through Through: has_one",
    "label": "",
    "id": "2529"
  },
  {
    "raw_code": "def test_has_many_through_has_one_through_with_has_one_source_reflection\n    assert_equal [sponsors(:moustache_club_sponsor_for_groucho)], members(:groucho).nested_sponsors\n  end",
    "comment": "has_many through Source: has_one Through: has_one through",
    "label": "",
    "id": "2530"
  },
  {
    "raw_code": "def test_has_many_through_has_one_with_has_many_through_source_reflection\n    groucho_details, other_details = member_details(:groucho), member_details(:some_other_guy)\n\n    assert_equal [groucho_details, other_details],\n                 members(:groucho).organization_member_details.order(\"member_details.id\")\n  end",
    "comment": "has_many through Source: has_many through Through: has_one",
    "label": "",
    "id": "2531"
  },
  {
    "raw_code": "def test_has_many_through_has_one_through_with_has_many_source_reflection\n    groucho_details, other_details = member_details(:groucho), member_details(:some_other_guy)\n\n    assert_equal [groucho_details, other_details],\n                 members(:groucho).organization_member_details_2.order(\"member_details.id\")\n  end",
    "comment": "has_many through Source: has_many Through: has_one through",
    "label": "",
    "id": "2532"
  },
  {
    "raw_code": "def test_has_many_through_has_many_with_has_and_belongs_to_many_source_reflection\n    general, cooking = categories(:general), categories(:cooking)\n\n    assert_equal [general, cooking], authors(:bob).post_categories.order(\"categories.id\")\n  end",
    "comment": "has_many through Source: has_and_belongs_to_many Through: has_many",
    "label": "",
    "id": "2533"
  },
  {
    "raw_code": "def test_has_many_through_has_and_belongs_to_many_with_has_many_source_reflection\n    greetings, more = comments(:greetings), comments(:more_greetings)\n\n    assert_equal [greetings, more], categories(:technology).post_comments.order(\"comments.id\")\n  end",
    "comment": "has_many through Source: has_many Through: has_and_belongs_to_many",
    "label": "",
    "id": "2534"
  },
  {
    "raw_code": "def test_has_many_through_has_many_with_has_many_through_habtm_source_reflection\n    greetings, more = comments(:greetings), comments(:more_greetings)\n\n    assert_equal [greetings, more], authors(:bob).category_post_comments.order(\"comments.id\")\n  end",
    "comment": "has_many through Source: has_many through a habtm Through: has_many through",
    "label": "",
    "id": "2535"
  },
  {
    "raw_code": "def test_has_many_through_has_many_through_with_belongs_to_source_reflection\n    assert_equal [tags(:general), tags(:general)], authors(:david).tagging_tags\n  end",
    "comment": "has_many through Source: belongs_to Through: has_many through",
    "label": "",
    "id": "2536"
  },
  {
    "raw_code": "def test_has_many_through_belongs_to_with_has_many_through_source_reflection\n    welcome_general, thinking_general = taggings(:welcome_general), taggings(:thinking_general)\n\n    assert_equal [welcome_general, thinking_general],\n                 categorizations(:david_welcome_general).post_taggings.order(\"taggings.id\")\n  end",
    "comment": "has_many through Source: has_many through Through: belongs_to",
    "label": "",
    "id": "2537"
  },
  {
    "raw_code": "def test_has_one_through_has_one_with_has_one_through_source_reflection\n    assert_equal member_types(:founding), members(:groucho).nested_member_type\n  end",
    "comment": "has_one through Source: has_one through Through: has_one",
    "label": "",
    "id": "2538"
  },
  {
    "raw_code": "def test_has_one_through_has_one_through_with_belongs_to_source_reflection\n    assert_equal categories(:general), members(:groucho).club_category\n  end",
    "comment": "has_one through Source: belongs_to Through: has_one through",
    "label": "",
    "id": "2539"
  },
  {
    "raw_code": "def test_url_from_environment\n          pool_config = resolve_db_config :production, \"production\" => \"abstract://foo?encoding=utf8\"\n\n          assert_equal({\n            adapter:  \"abstract\",\n            host:     \"foo\",\n            encoding: \"utf8\"\n          }, pool_config.configuration_hash)\n        end",
    "comment": "The abstract adapter is used simply to bypass the bit of code that checks that the adapter file can be required in.",
    "label": "",
    "id": "2540"
  },
  {
    "raw_code": "def test_wrong_fixture_format_string\n        tmp_yaml [\"empty\", \"yml\"], \"qwerty\" do |t|\n          assert_raises(ActiveRecord::Fixture::FormatError) do\n            File.open(t.path) { |fh| fh.to_a }\n          end",
    "comment": "A valid YAML file is not necessarily a value Fixture file. Make sure an exception is raised if the format is not valid Fixture format.",
    "label": "",
    "id": "2541"
  },
  {
    "raw_code": "def test_independent_render_contexts\n        yaml1 = \"<% def leaked_method; 'leak'; end %>\\n\"\n        yaml2 = \"one:\\n  name: <%= leaked_method %>\\n\"\n        tmp_yaml [\"leaky\", \"yml\"], yaml1 do |t1|\n          tmp_yaml [\"curious\", \"yml\"], yaml2 do |t2|\n            File.open(t1.path) { |fh| fh.to_a }\n            assert_raises(NameError) do\n              File.open(t2.path) { |fh| fh.to_a }\n            end",
    "comment": "Make sure that each fixture gets its own rendering context so that fixtures are independent.",
    "label": "",
    "id": "2542"
  },
  {
    "raw_code": "def test_add_invalid_check_constraint\n            @connection.add_check_constraint :trades, \"quantity > 0\", name: \"quantity_check\", validate: false\n\n            check_constraints = @connection.check_constraints(\"trades\")\n            assert_equal 1, check_constraints.size\n\n            cc = check_constraints.first\n            assert_predicate cc, :validated?\n          end",
    "comment": "Check constraint should still be created, but should not be invalid",
    "label": "",
    "id": "2543"
  },
  {
    "raw_code": "def test_add_rename\n        add_column \"test_models\", \"girlfriend\", :string\n        TestModel.reset_column_information\n\n        TestModel.create girlfriend: \"bobette\"\n\n        rename_column \"test_models\", \"girlfriend\", \"exgirlfriend\"\n\n        TestModel.reset_column_information\n        bob = TestModel.first\n\n        assert_equal \"bobette\", bob.exgirlfriend\n      end",
    "comment": "FIXME: this is more of an integration test with AR::Base and the schema modifications.  Maybe we should move this?",
    "label": "",
    "id": "2544"
  },
  {
    "raw_code": "def test_rename_column_using_symbol_arguments\n        add_column :test_models, :first_name, :string\n\n        TestModel.create first_name: \"foo\"\n\n        rename_column :test_models, :first_name, :nick_name\n        TestModel.reset_column_information\n        assert_includes TestModel.column_names, \"nick_name\"\n        assert_equal [\"foo\"], TestModel.all.map(&:nick_name)\n      end",
    "comment": "FIXME: another integration test.  We should decouple this from the AR::Base implementation.",
    "label": "",
    "id": "2545"
  },
  {
    "raw_code": "def test_rename_column\n        add_column \"test_models\", \"first_name\", \"string\"\n\n        TestModel.create first_name: \"foo\"\n\n        rename_column \"test_models\", \"first_name\", \"nick_name\"\n        TestModel.reset_column_information\n        assert_includes TestModel.column_names, \"nick_name\"\n        assert_equal [\"foo\"], TestModel.all.map(&:nick_name)\n      end",
    "comment": "FIXME: another integration test.  We should decouple this from the AR::Base implementation.",
    "label": "",
    "id": "2546"
  },
  {
    "raw_code": "def test_native_decimal_insert_manual_vs_automatic\n          correct_value = \"0012345678901234567890.0123456789\".to_d\n\n          connection.add_column \"test_models\", \"wealth\", :decimal, precision: \"30\", scale: \"10\"\n\n          connection.execute \"insert into test_models (wealth) values (12345678901234567890.0123456789)\"\n\n          # SELECT\n          row = TestModel.first\n          assert_kind_of BigDecimal, row.wealth\n\n          # If this assert fails, that means the SELECT is broken!\n          assert_equal correct_value, row.wealth\n\n          # Reset to old state\n          TestModel.delete_all\n\n          # Now use the Rails insertion\n          TestModel.create wealth: BigDecimal(\"12345678901234567890.0123456789\")\n\n          # SELECT\n          row = TestModel.first\n          assert_kind_of BigDecimal, row.wealth\n\n          # If these asserts fail, that means the INSERT (create function, or cast to SQL) is broken!\n          assert_equal correct_value, row.wealth\n        end",
    "comment": "We specifically do a manual INSERT here, and then test only the SELECT functionality. This allows us to more easily catch INSERT being broken, but SELECT actually working fine.",
    "label": "",
    "id": "2547"
  },
  {
    "raw_code": "def test_add_invalid_foreign_key\n            @connection.add_foreign_key :astronauts, :rockets, column: \"rocket_id\", validate: false\n\n            foreign_keys = @connection.foreign_keys(\"astronauts\")\n            assert_equal 1, foreign_keys.size\n\n            fk = foreign_keys.first\n            assert_predicate fk, :validated?\n          end",
    "comment": "Foreign key should still be created, but should not be invalid",
    "label": "",
    "id": "2548"
  },
  {
    "raw_code": "def test_understands_migrations_created_out_of_order\n          # With a prior file before even initialization\n          create_migration \"05\", \"create_bar\"\n          quietly { run_migrations }\n          assert_no_pending_migrations\n\n          # It understands the new migration created at 01\n          create_migration \"01\", \"create_foo\"\n          assert_pending_migrations(\"01_create_foo.rb\")\n        end",
    "comment": "Regression test for https://github.com/rails/rails/pull/29759",
    "label": "",
    "id": "2549"
  },
  {
    "raw_code": "def test_create_with_empty_hash_will_not_reset\n    jamis = PoorDeveloperCalledJamis.create_with(name: \"Aaron\").create_with({}).new\n    assert_equal \"Aaron\", jamis.name\n  end",
    "comment": "FIXME: I don't know if this is *desired* behavior, but it is *today's* behavior.",
    "label": "",
    "id": "2550"
  },
  {
    "raw_code": "def test_spaces_in_scope_names\n    klass = Class.new(ActiveRecord::Base) do\n      self.table_name = \"topics\"\n      scope :\"title containing space\", ->(space: \" \") { where(\"title LIKE '%#{space}%'\") }\n      scope :approved, -> { where(approved: true) }\n    end",
    "comment": "Method delegation for scope names which look like /\\A[a-zA-Z_]\\w*[!?]?\\z/ has been done by evaluating a string with a plain def statement. For scope names which contain spaces this approach doesn't work.",
    "label": "",
    "id": "2551"
  },
  {
    "raw_code": "def test_scopes_are_cached_on_associations\n    post = posts(:welcome)\n\n    Post.cache do\n      assert_queries_count(1) { post.comments.containing_the_letter_e.to_a }\n      assert_no_queries { post.comments.containing_the_letter_e.to_a }\n    end",
    "comment": "Note: these next two are kinda odd because they are essentially just testing that the query cache works as it should, but they are here for legacy reasons as there was previously a separate cache on association proxies, and these show that that is not necessary.",
    "label": "",
    "id": "2552"
  },
  {
    "raw_code": "def test_generate_message_invalid_with_default_message\n    assert_equal \"is invalid\", @topic.errors.generate_message(:title, :invalid, value: \"title\")\n  end",
    "comment": "validates_associated: generate_message(attr_name, :invalid, :message => custom_message, :value => value)",
    "label": "",
    "id": "2553"
  },
  {
    "raw_code": "def test_generate_message_taken_with_default_message\n    assert_equal \"has already been taken\", @topic.errors.generate_message(:title, :taken, value: \"title\")\n  end",
    "comment": "validates_uniqueness_of: generate_message(attr_name, :taken, :message => custom_message)",
    "label": "",
    "id": "2554"
  },
  {
    "raw_code": "def self.ast\n    raise\n  end",
    "comment": "Should be delegated `ast` and `locked` to `arel`.",
    "label": "",
    "id": "2555"
  },
  {
    "raw_code": "def self.greeting\n    raise\n  end",
    "comment": "Should not be called if extending modules that having the method exists on an association.",
    "label": "",
    "id": "2556"
  },
  {
    "raw_code": "def self.destroyed_client_ids\n    @destroyed_client_ids ||= Hash.new { |h, k| h[k] = [] }\n  end",
    "comment": "Record destruction so we can test whether firm.clients.clear has is calling client.destroy, deleting from the database, or setting foreign keys to NULL.",
    "label": "",
    "id": "2557"
  },
  {
    "raw_code": "def rating?\n    query_attribute :rating\n  end",
    "comment": "Used to test that read and question methods are not generated for these attributes",
    "label": "",
    "id": "2558"
  },
  {
    "raw_code": "def column(name, sql_type = nil, options = {})\n    lease_connection.merge_column(table_name, name, sql_type, options)\n  end",
    "comment": "mock out self.columns so no pesky db is needed for these tests",
    "label": "",
    "id": "2559"
  },
  {
    "raw_code": "def self.open\n    approved\n  end",
    "comment": "Method on Kernel",
    "label": "",
    "id": "2560"
  },
  {
    "raw_code": "def self.load(data:); end\n  def self.select(data:); end\nend\n\nclass SillyReply < Topic\n  belongs_to :reply, foreign_key: \"parent_id\", counter_cache: :replies_count\nend",
    "comment": "Methods both on Kernel and Relation",
    "label": "",
    "id": "2561"
  },
  {
    "raw_code": "def topic_id\n    id\n  end",
    "comment": "trivial method for testing Array#to_xml with :methods",
    "label": "",
    "id": "2562"
  },
  {
    "raw_code": "def raw_transaction_open?(connection)\n    if current_adapter?(:PostgreSQLAdapter)\n      connection.instance_variable_get(:@raw_connection).transaction_status == ::PG::PQTRANS_INTRANS\n    elsif current_adapter?(:Mysql2Adapter, :TrilogyAdapter)\n      begin\n        connection.instance_variable_get(:@raw_connection).query(\"SAVEPOINT transaction_test\")\n        connection.instance_variable_get(:@raw_connection).query(\"RELEASE SAVEPOINT transaction_test\")\n\n        true\n      rescue\n        false\n      end",
    "comment": "Detects whether the server side of the connection physically has a transaction open, independently of the adapter's opinion. Skips if we don't know how to detect this.",
    "label": "",
    "id": "2563"
  },
  {
    "raw_code": "def remote_disconnect(connection)\n    if current_adapter?(:PostgreSQLAdapter)\n      # Connection was left in a bad state, need to reconnect to simulate fresh disconnect\n      connection.verify! if connection.instance_variable_get(:@raw_connection).status == ::PG::CONNECTION_BAD\n      unless connection.instance_variable_get(:@raw_connection).transaction_status == ::PG::PQTRANS_INTRANS\n        connection.instance_variable_get(:@raw_connection).async_exec(\"begin\")\n      end",
    "comment": "Arrange for the server to disconnect the connection, leaving it broken (by setting, and then sleeping to exceed, a very short timeout). Skips if we can't do so.",
    "label": "",
    "id": "2564"
  },
  {
    "raw_code": "def kill_connection_from_server(connection_id, pool = ActiveRecord::Base.connection_pool)\n    actor_connection = pool.checkout\n    pool.remove(actor_connection)\n\n    case actor_connection.adapter_name\n    when \"Mysql2\", \"Trilogy\"\n      actor_connection.execute(\"KILL #{connection_id}\")\n    when \"PostgreSQL\"\n      actor_connection.execute(\"SELECT pg_terminate_backend(#{connection_id})\")\n    else\n      skip(\"kill_connection_from_server unsupported\")\n    end",
    "comment": "Uses a separate connection to admin-kill the connection with the given ID from the server side. Skips if we can't do so.",
    "label": "",
    "id": "2565"
  },
  {
    "raw_code": "def reset_connection\n    original_connection = ActiveRecord::Base.remove_connection\n    ActiveRecord::Base.establish_connection(original_connection)\n  end",
    "comment": "Used to drop all cache query plans in tests.",
    "label": "",
    "id": "2566"
  },
  {
    "raw_code": "def send_blob_byte_range_data(blob, range_header, disposition: nil)\n      ranges = Rack::Utils.get_byte_ranges(range_header, blob.byte_size)\n\n      return head(:range_not_satisfiable) if ranges.blank? || ranges.all?(&:blank?)\n\n      if ranges.length == 1\n        range = ranges.first\n        content_type = blob.content_type_for_serving\n        data = blob.download_chunk(range)\n\n        response.headers[\"Content-Range\"] = \"bytes #{range.begin}-#{range.end}/#{blob.byte_size}\"\n      else\n        boundary = SecureRandom.hex\n        content_type = \"multipart/byteranges; boundary=#{boundary}\"\n        data = +\"\"\n\n        ranges.compact.each do |range|\n          chunk = blob.download_chunk(range)\n\n          data << \"\\r\\n--#{boundary}\\r\\n\"\n          data << \"Content-Type: #{blob.content_type_for_serving}\\r\\n\"\n          data << \"Content-Range: bytes #{range.begin}-#{range.end}/#{blob.byte_size}\\r\\n\\r\\n\"\n          data << chunk\n        end",
    "comment": "Stream the blob in byte ranges specified through the header",
    "label": "",
    "id": "2567"
  },
  {
    "raw_code": "def send_blob_stream(blob, disposition: nil) # :doc:\n      send_stream(\n          filename: blob.filename.sanitized,\n          disposition: blob.forced_disposition_for_serving || disposition || DEFAULT_BLOB_STREAMING_DISPOSITION,\n          type: blob.content_type_for_serving) do |stream|\n        blob.download do |chunk|\n          stream.write chunk\n        end",
    "comment": "Stream the blob from storage directly to the response. The disposition can be controlled by setting +disposition+. The content type and filename is set directly from the +blob+.",
    "label": "",
    "id": "2568"
  },
  {
    "raw_code": "def purge\n    transaction do\n      delete\n      record.touch if record&.persisted?\n    end",
    "comment": "Synchronously deletes the attachment and {purges the blob}[rdoc-ref:ActiveStorage::Blob#purge].",
    "label": "",
    "id": "2569"
  },
  {
    "raw_code": "def purge_later\n    transaction do\n      delete\n      record.touch if record&.persisted?\n    end",
    "comment": "Deletes the attachment and {enqueues a background job}[rdoc-ref:ActiveStorage::Blob#purge_later] to purge the blob.",
    "label": "",
    "id": "2570"
  },
  {
    "raw_code": "def variant(transformations)\n    transformations = transformations_by_name(transformations)\n    blob.variant(transformations)\n  end",
    "comment": "Returns an ActiveStorage::Variant or ActiveStorage::VariantWithRecord instance for the attachment with the set of +transformations+ provided. Example:  avatar.variant(resize_to_limit: [100, 100]).processed.url  or if you are using pre-defined variants:  avatar.variant(:thumb).processed.url  See ActiveStorage::Blob::Representable#variant for more information.  Raises an +ArgumentError+ if +transformations+ is a +Symbol+ which is an unknown pre-defined variant of the attachment.",
    "label": "",
    "id": "2571"
  },
  {
    "raw_code": "def preview(transformations)\n    transformations = transformations_by_name(transformations)\n    blob.preview(transformations)\n  end",
    "comment": "Returns an ActiveStorage::Preview instance for the attachment with the set of +transformations+ provided. Example:  video.preview(resize_to_limit: [100, 100]).processed.url  or if you are using pre-defined variants:  video.preview(:thumb).processed.url  See ActiveStorage::Blob::Representable#preview for more information.  Raises an +ArgumentError+ if +transformations+ is a +Symbol+ which is an unknown pre-defined variant of the attachment.",
    "label": "",
    "id": "2572"
  },
  {
    "raw_code": "def representation(transformations)\n    transformations = transformations_by_name(transformations)\n    blob.representation(transformations)\n  end",
    "comment": "Returns an ActiveStorage::Preview or an ActiveStorage::Variant for the attachment with set of +transformations+ provided. Example:  avatar.representation(resize_to_limit: [100, 100]).processed.url  or if you are using pre-defined variants:  avatar.representation(:thumb).processed.url  See ActiveStorage::Blob::Representable#representation for more information.  Raises an +ArgumentError+ if +transformations+ is a +Symbol+ which is an unknown pre-defined variant of the attachment.",
    "label": "",
    "id": "2573"
  },
  {
    "raw_code": "def find_signed(id, record: nil, purpose: :blob_id)\n      super(id, purpose: purpose)\n    end",
    "comment": "You can use the signed ID of a blob to refer to it on the client side without fear of tampering. This is particularly helpful for direct uploads where the client-side needs to refer to the blob that was created ahead of the upload itself on form submission.  The signed ID is also used to create stable URLs for the blob through the BlobsController.",
    "label": "",
    "id": "2574"
  },
  {
    "raw_code": "def find_signed!(id, record: nil, purpose: :blob_id)\n      super(id, purpose: purpose)\n    end",
    "comment": "Works like +find_signed+, but will raise an +ActiveSupport::MessageVerifier::InvalidSignature+ exception if the +signed_id+ has either expired, has a purpose mismatch, or has been tampered with. It will also raise an +ActiveRecord::RecordNotFound+ exception if the valid signed id can't find a record.",
    "label": "",
    "id": "2575"
  },
  {
    "raw_code": "def create_and_upload!(key: nil, io:, filename:, content_type: nil, metadata: nil, service_name: nil, identify: true, record: nil)\n      create_after_unfurling!(key: key, io: io, filename: filename, content_type: content_type, metadata: metadata, service_name: service_name, identify: identify).tap do |blob|\n        blob.upload_without_unfurling(io)\n      end",
    "comment": "Creates a new blob instance and then uploads the contents of the given <tt>io</tt> to the service. The blob instance is going to be saved before the upload begins to prevent the upload clobbering another due to key collisions. When providing a content type, pass <tt>identify: false</tt> to bypass automatic content type inference.",
    "label": "",
    "id": "2576"
  },
  {
    "raw_code": "def create_before_direct_upload!(key: nil, filename:, byte_size:, checksum:, content_type: nil, metadata: nil, service_name: nil, record: nil)\n      create! key: key, filename: filename, byte_size: byte_size, checksum: checksum, content_type: content_type, metadata: metadata, service_name: service_name\n    end",
    "comment": "Returns a saved blob _without_ uploading a file to the service. This blob will point to a key where there is no file yet. It's intended to be used together with a client-side upload, which will first create the blob in order to produce the signed URL for uploading. This signed URL points to the key generated by the blob. Once the form using the direct upload is submitted, the blob can be associated with the right record using the signed ID.",
    "label": "",
    "id": "2577"
  },
  {
    "raw_code": "def generate_unique_secure_token(length: MINIMUM_TOKEN_LENGTH)\n      SecureRandom.base36(length)\n    end",
    "comment": "To prevent problems with case-insensitive filesystems, especially in combination with databases which treat indices as case-sensitive, all blob keys generated are going to only contain the base-36 character alphabet and will therefore be lowercase. To maintain the same or higher amount of entropy as in the base-58 encoding used by +has_secure_token+ the number of bytes used is increased to 28 from the standard 24",
    "label": "",
    "id": "2578"
  },
  {
    "raw_code": "def combine_signed_id_purposes(purpose) # :nodoc:\n      purpose.to_s\n    end",
    "comment": "Customize signed ID purposes for backwards compatibility.",
    "label": "",
    "id": "2579"
  },
  {
    "raw_code": "def signed_id_verifier # :nodoc:\n      @signed_id_verifier ||= ActiveStorage.verifier\n    end",
    "comment": "Customize the default signed ID verifier for backwards compatibility.  We override the reader (.signed_id_verifier) instead of just calling the writer (.signed_id_verifier=) to guard against the case where ActiveStorage.verifier isn't yet initialized at load time.",
    "label": "",
    "id": "2580"
  },
  {
    "raw_code": "def compose(blobs, key: nil, filename:, content_type: nil, metadata: nil)\n      raise ActiveRecord::RecordNotSaved, \"All blobs must be persisted.\" if blobs.any?(&:new_record?)\n\n      content_type ||= blobs.pluck(:content_type).compact.first\n\n      new(key: key, filename: filename, content_type: content_type, metadata: metadata, byte_size: blobs.sum(&:byte_size)).tap do |combined_blob|\n        combined_blob.compose(blobs.pluck(:key))\n        combined_blob.save!\n      end",
    "comment": "Concatenate multiple blobs into a single \"composed\" blob.",
    "label": "",
    "id": "2581"
  },
  {
    "raw_code": "def signed_id(purpose: :blob_id, expires_in: nil, expires_at: nil)\n    super\n  end",
    "comment": "Returns a signed ID for this blob that's suitable for reference on the client-side without fear of tampering.",
    "label": "",
    "id": "2582"
  },
  {
    "raw_code": "def key\n    # We can't wait until the record is first saved to have a key for it\n    self[:key] ||= self.class.generate_unique_secure_token(length: MINIMUM_TOKEN_LENGTH)\n  end",
    "comment": "Returns the key pointing to the file on the service that's associated with this blob. The key is the secure-token format from \\Rails in lower case. So it'll look like: xtapjjcjiudrlk3tmwyjgpuobabd. This key is not intended to be revealed directly to the user. Always refer to blobs using the signed_id or a verified form of the key.",
    "label": "",
    "id": "2583"
  },
  {
    "raw_code": "def filename\n    ActiveStorage::Filename.new(self[:filename])\n  end",
    "comment": "Returns an ActiveStorage::Filename instance of the filename that can be queried for basename, extension, and a sanitized version of the filename that's safe to use in URLs.",
    "label": "",
    "id": "2584"
  },
  {
    "raw_code": "def image?\n    content_type.start_with?(\"image\")\n  end",
    "comment": "Returns true if the content_type of this blob is in the image range, like image/png.",
    "label": "",
    "id": "2585"
  },
  {
    "raw_code": "def audio?\n    content_type.start_with?(\"audio\")\n  end",
    "comment": "Returns true if the content_type of this blob is in the audio range, like audio/mpeg.",
    "label": "",
    "id": "2586"
  },
  {
    "raw_code": "def video?\n    content_type.start_with?(\"video\")\n  end",
    "comment": "Returns true if the content_type of this blob is in the video range, like video/mp4.",
    "label": "",
    "id": "2587"
  },
  {
    "raw_code": "def text?\n    content_type.start_with?(\"text\")\n  end",
    "comment": "Returns true if the content_type of this blob is in the text range, like text/plain.",
    "label": "",
    "id": "2588"
  },
  {
    "raw_code": "def url(expires_in: ActiveStorage.service_urls_expire_in, disposition: :inline, filename: nil, **options)\n    service.url key, expires_in: expires_in, filename: ActiveStorage::Filename.wrap(filename || self.filename),\n      content_type: content_type_for_serving, disposition: forced_disposition_for_serving || disposition, **options\n  end",
    "comment": "Returns the URL of the blob on the service. This returns a permanent URL for public files, and returns a short-lived URL for private files. Private files are signed, and not for public use. Instead, the URL should only be exposed as a redirect from a stable, possibly authenticated URL. Hiding the URL behind a redirect also allows you to change services without updating all URLs.",
    "label": "",
    "id": "2589"
  },
  {
    "raw_code": "def service_url_for_direct_upload(expires_in: ActiveStorage.service_urls_expire_in)\n    service.url_for_direct_upload key, expires_in: expires_in, content_type: content_type, content_length: byte_size, checksum: checksum, custom_metadata: custom_metadata\n  end",
    "comment": "Returns a URL that can be used to directly upload a file for this blob on the service. This URL is intended to be short-lived for security and only generated on-demand by the client-side JavaScript responsible for doing the uploading.",
    "label": "",
    "id": "2590"
  },
  {
    "raw_code": "def service_headers_for_direct_upload\n    service.headers_for_direct_upload key, filename: filename, content_type: content_type, content_length: byte_size, checksum: checksum, custom_metadata: custom_metadata\n  end",
    "comment": "Returns a Hash of headers for +service_url_for_direct_upload+ requests.",
    "label": "",
    "id": "2591"
  },
  {
    "raw_code": "def upload(io, identify: true)\n    unfurl io, identify: identify\n    upload_without_unfurling io\n  end",
    "comment": "Uploads the +io+ to the service on the +key+ for this blob. Blobs are intended to be immutable, so you shouldn't be using this method after a file has already been uploaded to fit with a blob. If you want to create a derivative blob, you should instead simply create a new blob based on the old one.  Prior to uploading, we compute the checksum, which is sent to the service for transit integrity validation. If the checksum does not match what the service receives, an exception will be raised. We also measure the size of the +io+ and store that in +byte_size+ on the blob record. The content type is automatically extracted from the +io+ unless you specify a +content_type+ and pass +identify+ as false.  Normally, you do not have to call this method directly at all. Use the +create_and_upload!+ class method instead. If you do use this method directly, make sure you are using it on a persisted Blob as otherwise another blob's data might get overwritten on the service.",
    "label": "",
    "id": "2592"
  },
  {
    "raw_code": "def download(&block)\n    service.download key, &block\n  end",
    "comment": "Downloads the file associated with this blob. If no block is given, the entire file is read into memory and returned. That'll use a lot of RAM for very large files. If a block is given, then the download is streamed and yielded in chunks.",
    "label": "",
    "id": "2593"
  },
  {
    "raw_code": "def download_chunk(range)\n    service.download_chunk key, range\n  end",
    "comment": "Downloads a part of the file associated with this blob.",
    "label": "",
    "id": "2594"
  },
  {
    "raw_code": "def open(tmpdir: nil, &block)\n    service.open(\n      key,\n      checksum: checksum,\n      verify: !composed,\n      name: [ \"ActiveStorage-#{id}-\", filename.extension_with_delimiter ],\n      tmpdir: tmpdir,\n      &block\n    )\n  end",
    "comment": "Downloads the blob to a tempfile on disk. Yields the tempfile.  The tempfile's name is prefixed with +ActiveStorage-+ and the blob's ID. Its extension matches that of the blob.  By default, the tempfile is created in <tt>Dir.tmpdir</tt>. Pass +tmpdir:+ to create it in a different directory:  blob.open(tmpdir: \"/path/to/tmp\") do |file| # ... end  The tempfile is automatically closed and unlinked after the given block is executed.  Raises ActiveStorage::IntegrityError if the downloaded data does not match the blob's checksum.",
    "label": "",
    "id": "2595"
  },
  {
    "raw_code": "def delete\n    service.delete(key)\n    service.delete_prefixed(\"variants/#{key}/\") if image?\n  end",
    "comment": "Deletes the files on the service associated with the blob. This should only be done if the blob is going to be deleted as well or you will essentially have a dead reference. It's recommended to use #purge and #purge_later methods in most circumstances.",
    "label": "",
    "id": "2596"
  },
  {
    "raw_code": "def purge\n    destroy\n    delete if previously_persisted?\n  rescue ActiveRecord::InvalidForeignKey\n  end",
    "comment": "Destroys the blob record and then deletes the file on the service. This is the recommended way to dispose of unwanted blobs. Note, though, that deleting the file off the service will initiate an HTTP connection to the service, which may be slow or prevented, so you should not use this method inside a transaction or in callbacks. Use #purge_later instead.",
    "label": "",
    "id": "2597"
  },
  {
    "raw_code": "def purge_later\n    ActiveStorage::PurgeJob.perform_later(self)\n  end",
    "comment": "Enqueues an ActiveStorage::PurgeJob to call #purge. This is the recommended way to purge blobs from a transaction, an Active Record callback, or in any other real-time scenario.",
    "label": "",
    "id": "2598"
  },
  {
    "raw_code": "def service\n    services.fetch(service_name)\n  end",
    "comment": "Returns an instance of service, which can be configured globally or per attachment",
    "label": "",
    "id": "2599"
  },
  {
    "raw_code": "def wrap(filename)\n      filename.kind_of?(self) ? filename : new(filename)\n    end",
    "comment": "Returns a Filename instance based on the given filename. If the filename is a Filename, it is returned unmodified. If it is a String, it is passed to ActiveStorage::Filename.new.",
    "label": "",
    "id": "2600"
  },
  {
    "raw_code": "def base\n    File.basename @filename, extension_with_delimiter\n  end",
    "comment": "Returns the part of the filename preceding any extension.  ActiveStorage::Filename.new(\"racecar.jpg\").base # => \"racecar\" ActiveStorage::Filename.new(\"racecar\").base     # => \"racecar\" ActiveStorage::Filename.new(\".gitignore\").base  # => \".gitignore\"",
    "label": "",
    "id": "2601"
  },
  {
    "raw_code": "def extension_with_delimiter\n    File.extname @filename\n  end",
    "comment": "Returns the extension of the filename (i.e. the substring following the last dot, excluding a dot at the beginning) with the dot that precedes it. If the filename has no extension, an empty string is returned.  ActiveStorage::Filename.new(\"racecar.jpg\").extension_with_delimiter # => \".jpg\" ActiveStorage::Filename.new(\"racecar\").extension_with_delimiter     # => \"\" ActiveStorage::Filename.new(\".gitignore\").extension_with_delimiter  # => \"\"",
    "label": "",
    "id": "2602"
  },
  {
    "raw_code": "def extension_without_delimiter\n    extension_with_delimiter.from(1).to_s\n  end",
    "comment": "Returns the extension of the filename (i.e. the substring following the last dot, excluding a dot at the beginning). If the filename has no extension, an empty string is returned.  ActiveStorage::Filename.new(\"racecar.jpg\").extension_without_delimiter # => \"jpg\" ActiveStorage::Filename.new(\"racecar\").extension_without_delimiter     # => \"\" ActiveStorage::Filename.new(\".gitignore\").extension_without_delimiter  # => \"\"",
    "label": "",
    "id": "2603"
  },
  {
    "raw_code": "def sanitized\n    @filename.encode(Encoding::UTF_8, invalid: :replace, undef: :replace, replace: \"�\").strip.tr(\"\\u{202E}%$|:;/<>?*\\\"\\t\\r\\n\\\\\", \"-\")\n  end",
    "comment": "Returns the sanitized filename.  ActiveStorage::Filename.new(\"foo:bar.jpg\").sanitized # => \"foo-bar.jpg\" ActiveStorage::Filename.new(\"foo/bar.jpg\").sanitized # => \"foo-bar.jpg\"  Characters considered unsafe for storage (e.g. \\, $, and the RTL override character) are replaced with a dash.",
    "label": "",
    "id": "2604"
  },
  {
    "raw_code": "def to_s\n    sanitized.to_s\n  end",
    "comment": "Returns the sanitized version of the filename.",
    "label": "",
    "id": "2605"
  },
  {
    "raw_code": "def processed\n    process unless processed?\n    variant.processed if variant?\n    self\n  end",
    "comment": "Processes the preview if it has not been processed yet. Returns the receiving +ActiveStorage::Preview+ instance for convenience:  blob.preview(resize_to_limit: [100, 100]).processed.url  Processing a preview generates an image from its blob and attaches the preview image to the blob. Because the preview image is stored with the blob, it is only generated once.",
    "label": "",
    "id": "2606"
  },
  {
    "raw_code": "def image\n    blob.preview_image\n  end",
    "comment": "Returns the blob's attached preview image.",
    "label": "",
    "id": "2607"
  },
  {
    "raw_code": "def url(**options)\n    if processed?\n      presentation.url(**options)\n    else\n      raise UnprocessedError\n    end",
    "comment": "Returns the URL of the preview's variant on the service. Raises ActiveStorage::Preview::UnprocessedError if the preview has not been processed yet.  This method synchronously processes a variant of the preview image, so do not call it in views. Instead, generate a stable URL that redirects to the URL returned by this method.",
    "label": "",
    "id": "2608"
  },
  {
    "raw_code": "def key\n    if processed?\n      presentation.key\n    else\n      raise UnprocessedError\n    end",
    "comment": "Returns a combination key of the blob and the variation that together identifies a specific variant.",
    "label": "",
    "id": "2609"
  },
  {
    "raw_code": "def download(&block)\n    if processed?\n      presentation.download(&block)\n    else\n      raise UnprocessedError\n    end",
    "comment": "Downloads the file associated with this preview's variant. If no block is given, the entire file is read into memory and returned. That'll use a lot of RAM for very large files. If a block is given, then the download is streamed and yielded in chunks. Raises ActiveStorage::Preview::UnprocessedError if the preview has not been processed yet.",
    "label": "",
    "id": "2610"
  },
  {
    "raw_code": "def processed\n    process unless processed?\n    self\n  end",
    "comment": "Returns the variant instance itself after it's been processed or an existing processing has been found on the service.",
    "label": "",
    "id": "2611"
  },
  {
    "raw_code": "def key\n    \"variants/#{blob.key}/#{OpenSSL::Digest::SHA256.hexdigest(variation.key)}\"\n  end",
    "comment": "Returns a combination key of the blob and the variation that together identifies a specific variant.",
    "label": "",
    "id": "2612"
  },
  {
    "raw_code": "def url(expires_in: ActiveStorage.service_urls_expire_in, disposition: :inline)\n    service.url key, expires_in: expires_in, disposition: disposition, filename: filename, content_type: content_type\n  end",
    "comment": "Returns the URL of the blob variant on the service. See ActiveStorage::Blob#url for details.  Use <tt>url_for(variant)</tt> (or the implied form, like <tt>link_to variant</tt> or <tt>redirect_to variant</tt>) to get the stable URL for a variant that points to the ActiveStorage::Representations::ProxyController or ActiveStorage::Representations::RedirectController, which in turn will use this +service_call+ method for its redirection.",
    "label": "",
    "id": "2613"
  },
  {
    "raw_code": "def download(&block)\n    service.download key, &block\n  end",
    "comment": "Downloads the file associated with this variant. If no block is given, the entire file is read into memory and returned. That'll use a lot of RAM for very large files. If a block is given, then the download is streamed and yielded in chunks.",
    "label": "",
    "id": "2614"
  },
  {
    "raw_code": "def image\n    self\n  end",
    "comment": "Returns the receiving variant. Allows ActiveStorage::Variant and ActiveStorage::Preview instances to be used interchangeably.",
    "label": "",
    "id": "2615"
  },
  {
    "raw_code": "def destroy\n    service.delete(key)\n  end",
    "comment": "Deletes variant file from service.",
    "label": "",
    "id": "2616"
  },
  {
    "raw_code": "def destroy\n    record&.destroy\n  end",
    "comment": "Destroys record and deletes file from service.",
    "label": "",
    "id": "2617"
  },
  {
    "raw_code": "def wrap(variator)\n      case variator\n      when self\n        variator\n      when String\n        decode variator\n      else\n        new variator\n      end",
    "comment": "Returns a Variation instance based on the given variator. If the variator is a Variation, it is returned unmodified. If it is a String, it is passed to ActiveStorage::Variation.decode. Otherwise, it is assumed to be a transformations Hash and is passed directly to the constructor.",
    "label": "",
    "id": "2618"
  },
  {
    "raw_code": "def decode(key)\n      new ActiveStorage.verifier.verify(key, purpose: :variation)\n    end",
    "comment": "Returns a Variation instance with the transformations that were encoded by +encode+.",
    "label": "",
    "id": "2619"
  },
  {
    "raw_code": "def encode(transformations)\n      ActiveStorage.verifier.generate(transformations, purpose: :variation)\n    end",
    "comment": "Returns a signed key for the +transformations+, which can be used to refer to a specific variation in a URL or combined key (like <tt>ActiveStorage::Variant#key</tt>).",
    "label": "",
    "id": "2620"
  },
  {
    "raw_code": "def transform(file, &block)\n    ActiveSupport::Notifications.instrument(\"transform.active_storage\") do\n      transformer.transform(file, format: format, &block)\n    end",
    "comment": "Accepts a File object, performs the +transformations+ against it, and saves the transformed image into a temporary file.",
    "label": "",
    "id": "2621"
  },
  {
    "raw_code": "def key\n    self.class.encode(transformations)\n  end",
    "comment": "Returns a signed key for all the +transformations+ that this variation was instantiated with.",
    "label": "",
    "id": "2622"
  },
  {
    "raw_code": "def analyze\n    update! metadata: metadata.merge(extract_metadata_via_analyzer)\n  end",
    "comment": "Extracts and stores metadata from the file associated with this blob using a relevant analyzer. Active Storage comes with built-in analyzers for images and videos. See ActiveStorage::Analyzer::ImageAnalyzer and ActiveStorage::Analyzer::VideoAnalyzer for information about the specific attributes they extract and the third-party libraries they require.  To choose the analyzer for a blob, Active Storage calls +accept?+ on each registered analyzer in order. It uses the first analyzer for which +accept?+ returns true when given the blob. If no registered analyzer accepts the blob, no metadata is extracted from it.  In a \\Rails application, add or remove analyzers by manipulating +Rails.application.config.active_storage.analyzers+ in an initializer:  # Add a custom analyzer for Microsoft Office documents: Rails.application.config.active_storage.analyzers.append DOCXAnalyzer  # Remove the built-in video analyzer: Rails.application.config.active_storage.analyzers.delete ActiveStorage::Analyzer::VideoAnalyzer  Outside of a \\Rails application, manipulate +ActiveStorage.analyzers+ instead.  You won't ordinarily need to call this method from a \\Rails application. New blobs are automatically and asynchronously analyzed via #analyze_later when they're attached for the first time.",
    "label": "",
    "id": "2623"
  },
  {
    "raw_code": "def analyze_later\n    if analyzer_class.analyze_later?\n      ActiveStorage::AnalyzeJob.perform_later(self)\n    else\n      analyze\n    end",
    "comment": "Enqueues an ActiveStorage::AnalyzeJob which calls #analyze, or calls #analyze inline based on analyzer class configuration.  This method is automatically called for a blob when it's attached for the first time. You can call it to analyze a blob again (e.g. if you add a new analyzer or modify an existing one).",
    "label": "",
    "id": "2624"
  },
  {
    "raw_code": "def analyzed?\n    analyzed\n  end",
    "comment": "Returns true if the blob has been analyzed.",
    "label": "",
    "id": "2625"
  },
  {
    "raw_code": "def variant(transformations)\n    if variable?\n      variant_class.new(self, ActiveStorage::Variation.wrap(transformations).default_to(default_variant_transformations))\n    else\n      raise ActiveStorage::InvariableError, \"Can't transform blob with ID=#{id} and content_type=#{content_type}\"\n    end",
    "comment": "Returns an ActiveStorage::Variant or ActiveStorage::VariantWithRecord instance with the set of +transformations+ provided. This is only relevant for image files, and it allows any image to be transformed for size, colors, and the like. Example:  avatar.variant(resize_to_limit: [100, 100]).processed.url  This will create and process a variant of the avatar blob that's constrained to a height and width of 100px. Then it'll upload said variant to the service according to a derivative key of the blob and the transformations.  Frequently, though, you don't actually want to transform the variant right away. But rather simply refer to a specific variant that can be created by a controller on-demand. Like so:  <%= image_tag Current.user.avatar.variant(resize_to_limit: [100, 100]) %>  This will create a URL for that specific blob with that specific variant, which the ActiveStorage::Representations::ProxyController or ActiveStorage::Representations::RedirectController can then produce on-demand.  Raises ActiveStorage::InvariableError if the variant processor cannot transform the blob. To determine whether a blob is variable, call ActiveStorage::Blob#variable?.  ==== Options  Options are defined by the {image_processing gem}[https://github.com/janko/image_processing], and depend on which variant processor you are using: {Vips}[https://github.com/janko/image_processing/blob/master/doc/vips.md] or {MiniMagick}[https://github.com/janko/image_processing/blob/master/doc/minimagick.md]. However, both variant processors support the following options:  [+:resize_to_limit+] Downsizes the image to fit within the specified dimensions while retaining the original aspect ratio. Will only resize the image if it's larger than the specified dimensions.  user.avatar.variant(resize_to_limit: [100, 100])  [+:resize_to_fit+] Resizes the image to fit within the specified dimensions while retaining the original aspect ratio. Will downsize the image if it's larger than the specified dimensions or upsize if it's smaller.  user.avatar.variant(resize_to_fit: [100, 100])  [+:resize_to_fill+] Resizes the image to fill the specified dimensions while retaining the original aspect ratio. If necessary, will crop the image in the larger dimension.  user.avatar.variant(resize_to_fill: [100, 100])  [+:resize_and_pad+] Resizes the image to fit within the specified dimensions while retaining the original aspect ratio. If necessary, will pad the remaining area with transparent color if source image has alpha channel, black otherwise.  user.avatar.variant(resize_and_pad: [100, 100])  [+:crop+] Extracts an area from an image. The first two arguments are the left and top edges of area to extract, while the last two arguments are the width and height of the area to extract.  user.avatar.variant(crop: [20, 50, 300, 300])  [+:rotate+] Rotates the image by the specified angle.  user.avatar.variant(rotate: 90)  Some options, including those listed above, can accept additional processor-specific values which can be passed as a trailing hash:  <!-- Vips supports configuring `crop` for many of its transformations --> <%= image_tag user.avatar.variant(resize_to_fill: [100, 100, { crop: :centre }]) %>  If migrating an existing application between MiniMagick and Vips, you will need to update processor-specific options:  <!-- MiniMagick --> <%= image_tag user.avatar.variant(resize_to_limit: [100, 100], format: :jpeg, sampling_factor: \"4:2:0\", strip: true, interlace: \"JPEG\", colorspace: \"sRGB\", quality: 80) %>  <!-- Vips --> <%= image_tag user.avatar.variant(resize_to_limit: [100, 100], format: :jpeg, saver: { subsample_mode: \"on\", strip: true, interlace: true, quality: 80 }) %> ",
    "label": "",
    "id": "2626"
  },
  {
    "raw_code": "def variable?\n    ActiveStorage.variable_content_types.include?(content_type)\n  end",
    "comment": "Returns true if the variant processor can transform the blob (its content type is in +ActiveStorage.variable_content_types+).",
    "label": "",
    "id": "2627"
  },
  {
    "raw_code": "def preview(transformations)\n    if previewable?\n      ActiveStorage::Preview.new(self, transformations)\n    else\n      raise ActiveStorage::UnpreviewableError, \"No previewer found for blob with ID=#{id} and content_type=#{content_type}\"\n    end",
    "comment": "Returns an ActiveStorage::Preview instance with the set of +transformations+ provided. A preview is an image generated from a non-image blob. Active Storage comes with built-in previewers for videos and PDF documents. The video previewer extracts the first frame from a video and the PDF previewer extracts the first page from a PDF document.  blob.preview(resize_to_limit: [100, 100]).processed.url  Avoid processing previews synchronously in views. Instead, link to a controller action that processes them on demand. Active Storage provides one, but you may want to create your own (for example, if you need authentication). Here’s how to use the built-in version:  <%= image_tag video.preview(resize_to_limit: [100, 100]) %>  This method raises ActiveStorage::UnpreviewableError if no previewer accepts the receiving blob. To determine whether a blob is accepted by any previewer, call ActiveStorage::Blob#previewable?.",
    "label": "",
    "id": "2628"
  },
  {
    "raw_code": "def previewable?\n    ActiveStorage.previewers.any? { |klass| klass.accept?(self) }\n  end",
    "comment": "Returns true if any registered previewer accepts the blob. By default, this will return true for videos and PDF documents.",
    "label": "",
    "id": "2629"
  },
  {
    "raw_code": "def representation(transformations)\n    case\n    when previewable?\n      preview transformations\n    when variable?\n      variant transformations\n    else\n      raise ActiveStorage::UnrepresentableError, \"No previewer found and can't transform blob with ID=#{id} and content_type=#{content_type}\"\n    end",
    "comment": "Returns an ActiveStorage::Preview for a previewable blob or an ActiveStorage::Variant for a variable image blob.  blob.representation(resize_to_limit: [100, 100]).processed.url  Raises ActiveStorage::UnrepresentableError if the receiving blob is neither variable nor previewable. Call ActiveStorage::Blob#representable? to determine whether a blob is representable.  See ActiveStorage::Blob#preview and ActiveStorage::Blob#variant for more information.",
    "label": "",
    "id": "2630"
  },
  {
    "raw_code": "def representable?\n    variable? || previewable?\n  end",
    "comment": "Returns true if the blob is variable or previewable.",
    "label": "",
    "id": "2631"
  },
  {
    "raw_code": "def self.accept?(blob)\n      false\n    end",
    "comment": "Implement this method in a concrete subclass. Have it return true when given a blob from which the analyzer can extract metadata.",
    "label": "",
    "id": "2632"
  },
  {
    "raw_code": "def self.analyze_later?\n      true\n    end",
    "comment": "Implement this method in concrete subclasses. It will determine if blob analysis should be done in a job or performed inline. By default, analysis is enqueued in a job.",
    "label": "",
    "id": "2633"
  },
  {
    "raw_code": "def metadata\n      raise NotImplementedError\n    end",
    "comment": "Override this method in a concrete subclass. Have it return a Hash of metadata.",
    "label": "",
    "id": "2634"
  },
  {
    "raw_code": "def download_blob_to_tempfile(&block) # :doc:\n        blob.open tmpdir: tmpdir, &block\n      end",
    "comment": "Downloads the blob to a tempfile on disk. Yields the tempfile.",
    "label": "",
    "id": "2635"
  },
  {
    "raw_code": "def self.blob(filename:, **attributes)\n      new.prepare Blob.new(filename: filename, key: generate_unique_secure_token), **attributes\n    end",
    "comment": "Generate a YAML-encoded representation of an ActiveStorage::Blob instance's attributes, resolve the file relative to the directory mentioned by ActiveSupport::Testing::FileFixtures.file_fixture, and upload the file to the Service  ==== Examples  # tests/fixtures/active_storage/blobs.yml second_thumbnail_blob: <%= ActiveStorage::FixtureSet.blob( filename: \"second.svg\", ) %>  third_thumbnail_blob: <%= ActiveStorage::FixtureSet.blob( filename: \"third.svg\", content_type: \"image/svg+xml\", service_name: \"public\" ) %> ",
    "label": "",
    "id": "2636"
  },
  {
    "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of Active Storage as a +Gem::Version+.",
    "label": "",
    "id": "2637"
  },
  {
    "raw_code": "def self.accept?(blob)\n      false\n    end",
    "comment": "Implement this method in a concrete subclass. Have it return true when given a blob from which the previewer can generate an image.",
    "label": "",
    "id": "2638"
  },
  {
    "raw_code": "def preview(**options)\n      raise NotImplementedError\n    end",
    "comment": "Override this method in a concrete subclass. Have it yield an attachable preview image (i.e. anything accepted by ActiveStorage::Attached::One#attach). Pass the additional options to the underlying blob that is created.",
    "label": "",
    "id": "2639"
  },
  {
    "raw_code": "def download_blob_to_tempfile(&block) # :doc:\n        blob.open tmpdir: tmpdir, &block\n      end",
    "comment": "Downloads the blob to a tempfile on disk. Yields the tempfile.",
    "label": "",
    "id": "2640"
  },
  {
    "raw_code": "def draw(*argv) # :doc:\n        open_tempfile do |file|\n          instrument :preview, key: blob.key do\n            capture(*argv, to: file)\n          end",
    "comment": "Executes a system command, capturing its binary output in a tempfile. Yields the tempfile.  Use this method to shell out to a system library (e.g. muPDF or FFmpeg) for preview image generation. The resulting tempfile can be used as the +:io+ value in an attachable Hash:  def preview download_blob_to_tempfile do |input| draw \"my-drawing-command\", input.path, \"--format\", \"png\", \"-\" do |output| yield io: output, filename: \"#{blob.filename.base}.png\", content_type: \"image/png\" end end end  The output tempfile is opened in the directory returned by #tmpdir.",
    "label": "",
    "id": "2641"
  },
  {
    "raw_code": "def reflect_on_all_attachments\n          attachment_reflections.values\n        end",
    "comment": "Returns an array of reflection objects for all the attachments in the class.",
    "label": "",
    "id": "2642"
  },
  {
    "raw_code": "def reflect_on_attachment(attachment)\n          attachment_reflections[attachment.to_s]\n        end",
    "comment": "Returns the reflection object for the named +attachment+.  User.reflect_on_attachment(:avatar) # => the avatar reflection ",
    "label": "",
    "id": "2643"
  },
  {
    "raw_code": "def configure(service_name, configurations)\n        Configurator.build(service_name, configurations)\n      end",
    "comment": "Configure an Active Storage service by name from a set of configurations, typically loaded from a YAML file. The Active Storage engine uses this to set the global Active Storage service when the app boots.",
    "label": "",
    "id": "2644"
  },
  {
    "raw_code": "def build(configurator:, name:, service: nil, **service_config) # :nodoc:\n        new(**service_config).tap do |service_instance|\n          service_instance.name = name\n        end",
    "comment": "Override in subclasses that stitch together multiple services and hence need to build additional services using the configurator.  Passes the configurator and all of the service's config as keyword args.  See MirrorService for an example.",
    "label": "",
    "id": "2645"
  },
  {
    "raw_code": "def upload(key, io, checksum: nil, **options)\n      raise NotImplementedError\n    end",
    "comment": "Upload the +io+ to the +key+ specified. If a +checksum+ is provided, the service will ensure a match when the upload has completed or raise an ActiveStorage::IntegrityError.",
    "label": "",
    "id": "2646"
  },
  {
    "raw_code": "def update_metadata(key, **metadata)\n    end",
    "comment": "Update metadata for the file identified by +key+ in the service. Override in subclasses only if the service needs to store specific metadata that has to be updated upon identification.",
    "label": "",
    "id": "2647"
  },
  {
    "raw_code": "def download(key)\n      raise NotImplementedError\n    end",
    "comment": "Return the content of the file at the +key+.",
    "label": "",
    "id": "2648"
  },
  {
    "raw_code": "def download_chunk(key, range)\n      raise NotImplementedError\n    end",
    "comment": "Return the partial content in the byte +range+ of the file at the +key+.",
    "label": "",
    "id": "2649"
  },
  {
    "raw_code": "def compose(source_keys, destination_key, filename: nil, content_type: nil, disposition: nil, custom_metadata: {})\n      raise NotImplementedError\n    end",
    "comment": "Concatenate multiple files into a single \"composed\" file.",
    "label": "",
    "id": "2650"
  },
  {
    "raw_code": "def delete(key)\n      raise NotImplementedError\n    end",
    "comment": "Delete the file at the +key+.",
    "label": "",
    "id": "2651"
  },
  {
    "raw_code": "def delete_prefixed(prefix)\n      raise NotImplementedError\n    end",
    "comment": "Delete files at keys starting with the +prefix+.",
    "label": "",
    "id": "2652"
  },
  {
    "raw_code": "def exist?(key)\n      raise NotImplementedError\n    end",
    "comment": "Return +true+ if a file exists at the +key+.",
    "label": "",
    "id": "2653"
  },
  {
    "raw_code": "def url(key, **options)\n      instrument :url, key: key do |payload|\n        generated_url =\n          if public?\n            public_url(key, **options)\n          else\n            private_url(key, **options)\n          end",
    "comment": "Returns the URL for the file at the +key+. This returns a permanent URL for public files, and returns a short-lived URL for private files. For private files you can provide the +disposition+ (+:inline+ or +:attachment+), +filename+, and +content_type+ that you wish the file to be served with on request. Additionally, you can also provide the amount of seconds the URL will be valid for, specified in +expires_in+.",
    "label": "",
    "id": "2654"
  },
  {
    "raw_code": "def url_for_direct_upload(key, expires_in:, content_type:, content_length:, checksum:, custom_metadata: {})\n      raise NotImplementedError\n    end",
    "comment": "Returns a signed, temporary URL that a direct upload file can be PUT to on the +key+. The URL will be valid for the amount of seconds specified in +expires_in+. You must also provide the +content_type+, +content_length+, and +checksum+ of the file that will be uploaded. All these attributes will be validated by the service upon upload.",
    "label": "",
    "id": "2655"
  },
  {
    "raw_code": "def headers_for_direct_upload(key, filename:, content_type:, content_length:, checksum:, custom_metadata: {})\n      {}\n    end",
    "comment": "Returns a Hash of headers for +url_for_direct_upload+ requests.",
    "label": "",
    "id": "2656"
  },
  {
    "raw_code": "def self.version\n    gem_version\n  end",
    "comment": "Returns the currently loaded version of Active Storage as a +Gem::Version+.",
    "label": "",
    "id": "2657"
  },
  {
    "raw_code": "def attachments\n      change.present? ? change.attachments : record.public_send(\"#{name}_attachments\")\n    end",
    "comment": "Returns all the associated attachment records.  All methods called on this proxy object that aren't listed here will automatically be delegated to +attachments+.",
    "label": "",
    "id": "2658"
  },
  {
    "raw_code": "def blobs\n      change.present? ? change.blobs : record.public_send(\"#{name}_blobs\")\n    end",
    "comment": "Returns all attached blobs.",
    "label": "",
    "id": "2659"
  },
  {
    "raw_code": "def attach(*attachables)\n      record.public_send(\"#{name}=\", blobs + attachables.flatten)\n      if record.persisted? && !record.changed?\n        return if !record.save\n      end",
    "comment": "Attaches one or more +attachables+ to the record.  If the record is persisted and unchanged, the attachments are saved to the database immediately. Otherwise, they'll be saved to the DB when the record is next saved.  document.images.attach(params[:images]) # Array of ActionDispatch::Http::UploadedFile objects document.images.attach(params[:signed_blob_id]) # Signed reference to blob from direct upload document.images.attach(io: File.open(\"/path/to/racecar.jpg\"), filename: \"racecar.jpg\", content_type: \"image/jpeg\") document.images.attach([ first_blob, second_blob ])",
    "label": "",
    "id": "2660"
  },
  {
    "raw_code": "def attached?\n      attachments.any?\n    end",
    "comment": "Returns true if any attachments have been made.  class Gallery < ApplicationRecord has_many_attached :photos end  Gallery.new.photos.attached? # => false",
    "label": "",
    "id": "2661"
  },
  {
    "raw_code": "def has_one_attached(name, dependent: :purge_later, service: nil, strict_loading: false)\n        Attached::Model.validate_service_configuration(service, self, name) unless service.is_a?(Proc)\n\n        generated_association_methods.class_eval <<-CODE, __FILE__, __LINE__ + 1\n          # frozen_string_literal: true\n          def #{name}\n            @active_storage_attached ||= {}\n            @active_storage_attached[:#{name}] ||= ActiveStorage::Attached::One.new(\"#{name}\", self)\n          end\n\n          def #{name}=(attachable)\n            attachment_changes[\"#{name}\"] =\n              if attachable.nil? || attachable == \"\"\n                ActiveStorage::Attached::Changes::DeleteOne.new(\"#{name}\", self)\n              else\n                ActiveStorage::Attached::Changes::CreateOne.new(\"#{name}\", self, attachable)\n              end\n          end",
    "comment": "Specifies the relation between a single attachment and the model.  class User < ApplicationRecord has_one_attached :avatar end  There is no column defined on the model side, Active Storage takes care of the mapping between your records and the attachment.  Under the covers, this relationship is implemented as a +has_one+ association to an ActiveStorage::Attachment record and a +has_one-through+ association to an ActiveStorage::Blob record. These associations are available as +avatar_attachment+ and +avatar_blob+. But you shouldn't need to work with these associations directly in most circumstances.  Instead, +has_one_attached+ generates an ActiveStorage::Attached::One proxy to provide access to the associations and factory methods, like +attach+:  user.avatar.attach(uploaded_file)  The +:dependent+ option defaults to +:purge_later+. This means the attachment will be purged (i.e. destroyed) in the background whenever the record is destroyed. If an ActiveJob::Backend queue adapter is not set in the application set it to +purge+ instead.  If you need the attachment to use a service which differs from the globally configured one, pass the +:service+ option. For example:  class User < ActiveRecord::Base has_one_attached :avatar, service: :s3 end  +:service+ can also be specified as a proc, and it will be called with the model instance:  class User < ActiveRecord::Base has_one_attached :avatar, service: ->(user) { user.in_europe_region? ? :s3_europe : :s3_usa } end  To avoid N+1 queries, you can include the attached blobs in your query like so:  User.with_attached_avatar  If you need to enable +strict_loading+ to prevent lazy loading of attachment, pass the +:strict_loading+ option. You can do:  class User < ApplicationRecord has_one_attached :avatar, strict_loading: true end  Note: Active Storage relies on polymorphic associations, which in turn store class names in the database. When renaming classes that use <tt>has_one_attached</tt>, make sure to also update the class names in the <tt>active_storage_attachments.record_type</tt> polymorphic type column of the corresponding rows.",
    "label": "",
    "id": "2662"
  },
  {
    "raw_code": "def has_many_attached(name, dependent: :purge_later, service: nil, strict_loading: false)\n        Attached::Model.validate_service_configuration(service, self, name) unless service.is_a?(Proc)\n\n        generated_association_methods.class_eval <<-CODE, __FILE__, __LINE__ + 1\n          # frozen_string_literal: true\n          def #{name}\n            @active_storage_attached ||= {}\n            @active_storage_attached[:#{name}] ||= ActiveStorage::Attached::Many.new(\"#{name}\", self)\n          end\n\n          def #{name}=(attachables)\n            attachables = Array(attachables).compact_blank\n            pending_uploads = attachment_changes[\"#{name}\"].try(:pending_uploads)\n\n            attachment_changes[\"#{name}\"] = if attachables.none?\n              ActiveStorage::Attached::Changes::DeleteMany.new(\"#{name}\", self)\n            else\n              ActiveStorage::Attached::Changes::CreateMany.new(\"#{name}\", self, attachables, pending_uploads: pending_uploads)\n            end\n          end",
    "comment": "Specifies the relation between multiple attachments and the model.  class Gallery < ApplicationRecord has_many_attached :photos end  There are no columns defined on the model side, Active Storage takes care of the mapping between your records and the attachments.  Under the covers, this relationship is implemented as a +has_many+ association to an ActiveStorage::Attachment record and a +has_many-through+ association to an ActiveStorage::Blob record. These associations are available as +photos_attachments+ and +photos_blobs+. But you shouldn't need to work with these associations directly in most circumstances.  Instead, +has_many_attached+ generates an ActiveStorage::Attached::Many proxy to provide access to the associations and factory methods, like +attach+:  user.photos.attach(uploaded_file)  The +:dependent+ option defaults to +:purge_later+. This means the attachments will be purged (i.e. destroyed) in the background whenever the record is destroyed. If an ActiveJob::Backend queue adapter is not set in the application set it to +purge+ instead.  If you need the attachment to use a service which differs from the globally configured one, pass the +:service+ option. For example:  class Gallery < ActiveRecord::Base has_many_attached :photos, service: :s3 end  +:service+ can also be specified as a proc, and it will be called with the model instance:  class Gallery < ActiveRecord::Base has_many_attached :photos, service: ->(gallery) { gallery.personal? ? :personal_s3 : :s3 } end  To avoid N+1 queries, you can include the attached blobs in your query like so:  Gallery.where(user: Current.user).with_attached_photos  If you need to enable +strict_loading+ to prevent lazy loading of attachments, pass the +:strict_loading+ option. You can do:  class Gallery < ApplicationRecord has_many_attached :photos, strict_loading: true end  Note: Active Storage relies on polymorphic associations, which in turn store class names in the database. When renaming classes that use <tt>has_many</tt>, make sure to also update the class names in the <tt>active_storage_attachments.record_type</tt> polymorphic type column of the corresponding rows.",
    "label": "",
    "id": "2663"
  },
  {
    "raw_code": "def attachment\n      change.present? ? change.attachment : record.public_send(\"#{name}_attachment\")\n    end",
    "comment": "Returns the associated attachment record.  You don't have to call this method to access the attachment's methods as they are all available at the model level.",
    "label": "",
    "id": "2664"
  },
  {
    "raw_code": "def blank?\n      !attached?\n    end",
    "comment": "Returns +true+ if an attachment is not attached.  class User < ApplicationRecord has_one_attached :avatar end  User.new.avatar.blank? # => true",
    "label": "",
    "id": "2665"
  },
  {
    "raw_code": "def attach(attachable)\n      record.public_send(\"#{name}=\", attachable)\n      if record.persisted? && !record.changed?\n        return if !record.save\n      end",
    "comment": "Attaches an +attachable+ to the record.  If the record is persisted and unchanged, the attachment is saved to the database immediately. Otherwise, it'll be saved to the DB when the record is next saved.  person.avatar.attach(params[:avatar]) # ActionDispatch::Http::UploadedFile object person.avatar.attach(params[:signed_blob_id]) # Signed reference to blob from direct upload person.avatar.attach(io: File.open(\"/path/to/face.jpg\"), filename: \"face.jpg\", content_type: \"image/jpeg\") person.avatar.attach(avatar_blob) # ActiveStorage::Blob object",
    "label": "",
    "id": "2666"
  },
  {
    "raw_code": "def attached?\n      attachment.present?\n    end",
    "comment": "Returns +true+ if an attachment has been made.  class User < ApplicationRecord has_one_attached :avatar end  User.new.avatar.attached? # => false",
    "label": "",
    "id": "2667"
  },
  {
    "raw_code": "def stream(key)\n        file = file_for(key, skip_lookup: false)\n\n        chunk_size = 5.megabytes\n        offset = 0\n\n        raise ActiveStorage::FileNotFoundError unless file.present?\n\n        while offset < file.size\n          yield file.download(range: offset..(offset + chunk_size - 1)).string\n          offset += chunk_size\n        end",
    "comment": "Reads the file for the given key in chunks, yielding each to the block.",
    "label": "",
    "id": "2668"
  },
  {
    "raw_code": "def self.build(primary:, mirrors:, name:, configurator:, **options) # :nodoc:\n      new(\n        primary: configurator.build(primary),\n        mirrors: mirrors.collect { |mirror_name| configurator.build mirror_name }\n      ).tap do |service_instance|\n        service_instance.name = name\n      end",
    "comment": "Stitch together from named services.",
    "label": "",
    "id": "2669"
  },
  {
    "raw_code": "def upload(key, io, checksum: nil, **options)\n      io.rewind\n      primary.upload key, io, checksum: checksum, **options\n      mirror_later key, checksum: checksum\n    end",
    "comment": "Upload the +io+ to the +key+ specified to all services. The upload to the primary service is done synchronously whereas the upload to the mirrors is done asynchronously. If a +checksum+ is provided, all services will ensure a match when the upload has completed or raise an ActiveStorage::IntegrityError.",
    "label": "",
    "id": "2670"
  },
  {
    "raw_code": "def delete(key)\n      perform_across_services :delete, key\n    end",
    "comment": "Delete the file at the +key+ on all services.",
    "label": "",
    "id": "2671"
  },
  {
    "raw_code": "def delete_prefixed(prefix)\n      perform_across_services :delete_prefixed, prefix\n    end",
    "comment": "Delete files at keys starting with the +prefix+ on all services.",
    "label": "",
    "id": "2672"
  },
  {
    "raw_code": "def mirror(key, checksum:)\n      instrument :mirror, key: key, checksum: checksum do\n        if (mirrors_in_need_of_mirroring = mirrors.select { |service| !service.exist?(key) }).any?\n          primary.open(key, checksum: checksum) do |io|\n            mirrors_in_need_of_mirroring.each do |service|\n              io.rewind\n              service.upload key, io, checksum: checksum\n            end",
    "comment": "Copy the file at the +key+ from the primary service to each of the mirrors where it doesn't already exist.",
    "label": "",
    "id": "2673"
  },
  {
    "raw_code": "def stream(key)\n        object = object_for(key)\n\n        chunk_size = 5.megabytes\n        offset = 0\n\n        raise ActiveStorage::FileNotFoundError unless object.exists?\n\n        while offset < object.content_length\n          yield object.get(range: \"bytes=#{offset}-#{offset + chunk_size - 1}\").body.string.force_encoding(Encoding::BINARY)\n          offset += chunk_size\n        end",
    "comment": "Reads the object for the given key in chunks, yielding each to the block.",
    "label": "",
    "id": "2674"
  },
  {
    "raw_code": "def transform(file, format:)\n        output = process(file, format: format)\n\n        begin\n          yield output\n        ensure\n          output.close!\n        end",
    "comment": "Applies the transformations to the source image in +file+, producing a target image in the specified +format+. Yields an open Tempfile containing the target image. Closes and unlinks the output tempfile after yielding to the given block. Returns the result of the block.",
    "label": "",
    "id": "2675"
  },
  {
    "raw_code": "def process(file, format:) # :doc:\n          raise NotImplementedError\n        end",
    "comment": "Returns an open Tempfile containing a transformed image in the given +format+. All subclasses implement this method.",
    "label": "",
    "id": "2676"
  },
  {
    "raw_code": "def action(name, &block)\n        _actions[name] = block\n      end",
    "comment": "Defines an action that can resolve the error.  class PendingMigrationError < MigrationError include ActiveSupport::ActionableError  action \"Run pending migrations\" do ActiveRecord::Tasks::DatabaseTasks.migrate end end",
    "label": "",
    "id": "2677"
  },
  {
    "raw_code": "def any?(*candidates)\n      if candidates.none?\n        super\n      else\n        candidates.any? do |candidate|\n          include?(candidate.to_sym) || include?(candidate.to_s)\n        end",
    "comment": "Passes each element of +candidates+ collection to ArrayInquirer collection. The method returns true if any element from the ArrayInquirer collection is equal to the stringified or symbolized form of any element in the +candidates+ collection.  If +candidates+ collection is not given, method returns true.  variants = ActiveSupport::ArrayInquirer.new([:phone, :tablet])  variants.any?                      # => true variants.any?(:phone, :tablet)     # => true variants.any?('phone', 'desktop')  # => true variants.any?(:desktop, :watch)    # => false",
    "label": "",
    "id": "2678"
  },
  {
    "raw_code": "def clean(backtrace, kind = :silent)\n      filtered = filter_backtrace(backtrace)\n\n      case kind\n      when :silent\n        silence(filtered)\n      when :noise\n        noise(filtered)\n      else\n        filtered\n      end",
    "comment": "Returns the backtrace after all filters and silencers have been run against it. Filters run first, then silencers.",
    "label": "",
    "id": "2679"
  },
  {
    "raw_code": "def clean_locations(locations, kind = :silent)\n      locations.select { |location| clean_frame(location, kind) }\n    end",
    "comment": "Given an array of Thread::Backtrace::Location objects, returns an array with the clean ones:  clean_locations = backtrace_cleaner.clean_locations(caller_locations)  Filters and silencers receive strings as usual. However, the +path+ attributes of the locations in the returned array are the original, unfiltered ones, since locations are immutable.",
    "label": "",
    "id": "2680"
  },
  {
    "raw_code": "def clean_frame(frame, kind = :silent)\n      frame = frame.to_s\n      @filters.each do |f|\n        frame = f.call(frame.to_s)\n      end",
    "comment": "Returns the frame with all filters applied. returns +nil+ if the frame was silenced.",
    "label": "",
    "id": "2681"
  },
  {
    "raw_code": "def first_clean_frame(kind = :silent)\n        caller_location_skipped = false\n\n        Thread.each_caller_location do |location|\n          unless caller_location_skipped\n            caller_location_skipped = true\n            next\n          end",
    "comment": "Returns the first clean frame of the caller's backtrace, or +nil+.  Frames are strings.",
    "label": "",
    "id": "2682"
  },
  {
    "raw_code": "def first_clean_location(kind = :silent)\n        caller_location_skipped = false\n\n        Thread.each_caller_location do |location|\n          unless caller_location_skipped\n            caller_location_skipped = true\n            next\n          end",
    "comment": "Returns the first clean location of the caller's call stack, or +nil+.  Locations are Thread::Backtrace::Location objects. Since they are immutable, their +path+ attributes are the original ones, but filters are applied internally so silencers can still rely on them.",
    "label": "",
    "id": "2683"
  },
  {
    "raw_code": "def first_clean_frame(kind = :silent)\n        Thread.each_caller_location(2) do |location|\n          frame = clean_frame(location, kind)\n          return frame if frame\n        end",
    "comment": "Returns the first clean frame of the caller's backtrace, or +nil+.  Frames are strings.",
    "label": "",
    "id": "2684"
  },
  {
    "raw_code": "def first_clean_location(kind = :silent)\n        Thread.each_caller_location(2) do |location|\n          return location if clean_frame(location, kind)\n        end",
    "comment": "Returns the first clean location of the caller's call stack, or +nil+.  Locations are Thread::Backtrace::Location objects. Since they are immutable, their +path+ attributes are the original ones, but filters are applied internally so silencers can still rely on them.",
    "label": "",
    "id": "2685"
  },
  {
    "raw_code": "def add_filter(&block)\n      @filters << block\n    end",
    "comment": "Adds a filter from the block provided. Each line in the backtrace will be mapped against this filter.  # Will turn \"/my/rails/root/app/models/person.rb\" into \"app/models/person.rb\" root = \"#{Rails.root}/\" backtrace_cleaner.add_filter { |line| line.delete_prefix(root) }",
    "label": "",
    "id": "2686"
  },
  {
    "raw_code": "def add_silencer(&block)\n      @silencers << block\n    end",
    "comment": "Adds a silencer from the block provided. If the silencer returns +true+ for a given line, it will be excluded from the clean backtrace.  # Will reject all lines that include the word \"puma\", like \"/gems/puma/server.rb\" or \"/app/my_puma_server/rb\" backtrace_cleaner.add_silencer { |line| /puma/.match?(line) }",
    "label": "",
    "id": "2687"
  },
  {
    "raw_code": "def remove_silencers!\n      @silencers = []\n    end",
    "comment": "Removes all silencers, but leaves in the filters. Useful if your context of debugging suddenly expands as you suspect a bug in one of the libraries you use.",
    "label": "",
    "id": "2688"
  },
  {
    "raw_code": "def remove_filters!\n      @filters = []\n    end",
    "comment": "Removes all filters, but leaves in the silencers. Useful if you suddenly need to see entire filepaths in the backtrace that you had already filtered out.",
    "label": "",
    "id": "2689"
  },
  {
    "raw_code": "def self.realtime(unit = :float_second, &block)\n      time_start = Process.clock_gettime(Process::CLOCK_MONOTONIC, unit)\n      yield\n      Process.clock_gettime(Process::CLOCK_MONOTONIC, unit) - time_start\n    end",
    "comment": "Benchmark realtime in the specified time unit. By default, the returned unit is in seconds.  ActiveSupport::Benchmark.realtime { sleep 0.1 } # => 0.10007  ActiveSupport::Benchmark.realtime(:float_millisecond) { sleep 0.1 } # => 100.07  `unit` can be any of the values accepted by Ruby's `Process.clock_gettime`.",
    "label": "",
    "id": "2690"
  },
  {
    "raw_code": "def benchmark(message = \"Benchmarking\", options = {}, &block)\n      if logger\n        options.assert_valid_keys(:level, :silence)\n        options[:level] ||= :info\n\n        result = nil\n        ms = ActiveSupport::Benchmark.realtime(:float_millisecond) do\n          result = options[:silence] ? logger.silence(&block) : yield\n        end",
    "comment": "Allows you to measure the execution time of a block in a template and records the result to the log. Wrap this block around expensive operations or possible bottlenecks to get a time reading for the operation. For example, let's say you thought your file processing method was taking too long; you could wrap it in a benchmark block.  <% benchmark 'Process data files' do %> <%= expensive_files_operation %> <% end %>  That would add something like \"Process data files (345.2ms)\" to the log, which you can then use to compare timings when optimizing your code.  You may give an optional logger level (<tt>:debug</tt>, <tt>:info</tt>, <tt>:warn</tt>, <tt>:error</tt>) as the <tt>:level</tt> option. The default logger level value is <tt>:info</tt>.  <% benchmark 'Low-level files', level: :debug do %> <%= lowlevel_files_operation %> <% end %>  Finally, you can pass true as the third argument to silence all log activity (other than the timing information) from inside the block. This is great for boiling down a noisy block to just a single statement that produces one log line:  <% benchmark 'Process data files', level: :info, silence: true do %> <%= expensive_and_chatty_files_operation %> <% end %>",
    "label": "",
    "id": "2691"
  },
  {
    "raw_code": "def broadcast_to(*loggers)\n      @broadcasts.concat(loggers)\n    end",
    "comment": "Add logger(s) to the broadcast.  broadcast_logger = ActiveSupport::BroadcastLogger.new broadcast_logger.broadcast_to(Logger.new(STDOUT), Logger.new(STDERR))",
    "label": "",
    "id": "2692"
  },
  {
    "raw_code": "def stop_broadcasting_to(logger)\n      @broadcasts.delete(logger)\n    end",
    "comment": "Remove a logger from the broadcast. When a logger is removed, messages sent to the broadcast will no longer be written to its sink.  sink = Logger.new(STDOUT) broadcast_logger = ActiveSupport::BroadcastLogger.new  broadcast_logger.stop_broadcasting_to(sink)",
    "label": "",
    "id": "2693"
  },
  {
    "raw_code": "def level\n      @broadcasts.map(&:level).min\n    end",
    "comment": "Returns the lowest level of all the loggers in the broadcast.",
    "label": "",
    "id": "2694"
  },
  {
    "raw_code": "def debug?\n      @broadcasts.any? { |logger| logger.debug? }\n    end",
    "comment": "True if the log level allows entries with severity +Logger::DEBUG+ to be written to at least one broadcast. False otherwise.",
    "label": "",
    "id": "2695"
  },
  {
    "raw_code": "def debug!\n      dispatch(:debug!)\n    end",
    "comment": "Sets the log level to +Logger::DEBUG+ for the whole broadcast.",
    "label": "",
    "id": "2696"
  },
  {
    "raw_code": "def info?\n      @broadcasts.any? { |logger| logger.info? }\n    end",
    "comment": "True if the log level allows entries with severity +Logger::INFO+ to be written to at least one broadcast. False otherwise.",
    "label": "",
    "id": "2697"
  },
  {
    "raw_code": "def info!\n      dispatch(:info!)\n    end",
    "comment": "Sets the log level to +Logger::INFO+ for the whole broadcast.",
    "label": "",
    "id": "2698"
  },
  {
    "raw_code": "def warn?\n      @broadcasts.any? { |logger| logger.warn? }\n    end",
    "comment": "True if the log level allows entries with severity +Logger::WARN+ to be written to at least one broadcast. False otherwise.",
    "label": "",
    "id": "2699"
  },
  {
    "raw_code": "def warn!\n      dispatch(:warn!)\n    end",
    "comment": "Sets the log level to +Logger::WARN+ for the whole broadcast.",
    "label": "",
    "id": "2700"
  },
  {
    "raw_code": "def error?\n      @broadcasts.any? { |logger| logger.error? }\n    end",
    "comment": "True if the log level allows entries with severity +Logger::ERROR+ to be written to at least one broadcast. False otherwise.",
    "label": "",
    "id": "2701"
  },
  {
    "raw_code": "def error!\n      dispatch(:error!)\n    end",
    "comment": "Sets the log level to +Logger::ERROR+ for the whole broadcast.",
    "label": "",
    "id": "2702"
  },
  {
    "raw_code": "def fatal?\n      @broadcasts.any? { |logger| logger.fatal? }\n    end",
    "comment": "True if the log level allows entries with severity +Logger::FATAL+ to be written to at least one broadcast. False otherwise.",
    "label": "",
    "id": "2703"
  },
  {
    "raw_code": "def fatal!\n      dispatch(:fatal!)\n    end",
    "comment": "Sets the log level to +Logger::FATAL+ for the whole broadcast.",
    "label": "",
    "id": "2704"
  },
  {
    "raw_code": "def lookup_store(store = nil, *parameters)\n        case store\n        when Symbol\n          options = parameters.extract_options!\n          retrieve_store_class(store).new(*parameters, **options)\n        when Array\n          lookup_store(*store)\n        when nil\n          ActiveSupport::Cache::MemoryStore.new\n        else\n          store\n        end",
    "comment": "Creates a new Store object according to the given options.  If no arguments are passed to this method, then a new ActiveSupport::Cache::MemoryStore object will be returned.  If you pass a Symbol as the first argument, then a corresponding cache store class under the ActiveSupport::Cache namespace will be created. For example:  ActiveSupport::Cache.lookup_store(:memory_store) # => returns a new ActiveSupport::Cache::MemoryStore object  ActiveSupport::Cache.lookup_store(:mem_cache_store) # => returns a new ActiveSupport::Cache::MemCacheStore object  Any additional arguments will be passed to the corresponding cache store class's constructor:  ActiveSupport::Cache.lookup_store(:file_store, '/tmp/cache') # => same as: ActiveSupport::Cache::FileStore.new('/tmp/cache')  If the first argument is not a Symbol, then it will simply be returned:  ActiveSupport::Cache.lookup_store(MyOwnCacheStore.new) # => returns MyOwnCacheStore.new",
    "label": "",
    "id": "2705"
  },
  {
    "raw_code": "def expand_cache_key(key, namespace = nil)\n        expanded_cache_key = namespace ? +\"#{namespace}/\" : +\"\"\n\n        if prefix = ENV[\"RAILS_CACHE_ID\"] || ENV[\"RAILS_APP_VERSION\"]\n          expanded_cache_key << \"#{prefix}/\"\n        end",
    "comment": "Expands out the +key+ argument into a key that can be used for the cache store. Optionally accepts a namespace, and all keys will be scoped within that namespace.  If the +key+ argument provided is an array, or responds to +to_a+, then each of elements in the array will be turned into parameters/keys and concatenated into a single key. For example:  ActiveSupport::Cache.expand_cache_key([:foo, :bar])               # => \"foo/bar\" ActiveSupport::Cache.expand_cache_key([:foo, :bar], \"namespace\")  # => \"namespace/foo/bar\"  The +key+ argument can also respond to +cache_key+ or +to_param+.",
    "label": "",
    "id": "2706"
  },
  {
    "raw_code": "def retrieve_store_class(store)\n          # require_relative cannot be used here because the class might be\n          # provided by another gem, like redis-activesupport for example.\n          require \"active_support/cache/#{store}\"\n        rescue LoadError => e\n          raise \"Could not find cache store adapter for #{store} (#{e})\"\n        else\n          ActiveSupport::Cache.const_get(store.to_s.camelize)\n        end",
    "comment": "Obtains the specified cache store class, given the name of the +store+. Raises an error when the store class cannot be found.",
    "label": "",
    "id": "2707"
  },
  {
    "raw_code": "def initialize(options = nil)\n        @options = options ? validate_options(normalize_options(options)) : {}\n\n        @options[:compress] = true unless @options.key?(:compress)\n        @options[:compress_threshold] ||= DEFAULT_COMPRESS_LIMIT\n\n        @max_key_size = @options.delete(:max_key_size)\n        @max_key_size = MAX_KEY_SIZE if @max_key_size.nil? # allow 'false' as a value\n\n        @coder = @options.delete(:coder) do\n          legacy_serializer = Cache.format_version < 7.1 && !@options[:serializer]\n          serializer = @options.delete(:serializer) || default_serializer\n          serializer = Cache::SerializerWithFallback[serializer] if serializer.is_a?(Symbol)\n          compressor = @options.delete(:compressor) { Zlib }\n\n          Cache::Coder.new(serializer, compressor, legacy_serializer: legacy_serializer)\n        end",
    "comment": "Creates a new cache.  ==== Options  [+:namespace+] Sets the namespace for the cache. This option is especially useful if your application shares a cache with other applications.  [+:serializer+] The serializer for cached values. Must respond to +dump+ and +load+.  The default serializer depends on the cache format version (set via +config.active_support.cache_format_version+ when using Rails). The default serializer for each format version includes a fallback mechanism to deserialize values from any format version. This behavior makes it easy to migrate between format versions without invalidating the entire cache.  You can also specify <tt>serializer: :message_pack</tt> to use a preconfigured serializer based on ActiveSupport::MessagePack. The +:message_pack+ serializer includes the same deserialization fallback mechanism, allowing easy migration from (or to) the default serializer. The +:message_pack+ serializer may improve performance, but it requires the +msgpack+ gem.  [+:compressor+] The compressor for serialized cache values. Must respond to +deflate+ and +inflate+.  The default compressor is +Zlib+. To define a new custom compressor that also decompresses old cache entries, you can check compressed values for Zlib's <tt>\"\\x78\"</tt> signature:  module MyCompressor def self.deflate(dumped) # compression logic... (make sure result does not start with \"\\x78\"!) end  def self.inflate(compressed) if compressed.start_with?(\"\\x78\") Zlib.inflate(compressed) else # decompression logic... end end end  ActiveSupport::Cache.lookup_store(:redis_cache_store, compressor: MyCompressor)  [+:coder+] The coder for serializing and (optionally) compressing cache entries. Must respond to +dump+ and +load+.  The default coder composes the serializer and compressor, and includes some performance optimizations. If you only need to override the serializer or compressor, you should specify the +:serializer+ or +:compressor+ options instead.  If the store can handle cache entries directly, you may also specify <tt>coder: nil</tt> to omit the serializer, compressor, and coder. For example, if you are using ActiveSupport::Cache::MemoryStore and can guarantee that cache values will not be mutated, you can specify <tt>coder: nil</tt> to avoid the overhead of safeguarding against mutation.  The +:coder+ option is mutually exclusive with the +:serializer+ and +:compressor+ options. Specifying them together will raise an +ArgumentError+.  Any other specified options are treated as default options for the relevant cache operations, such as #read, #write, and #fetch.",
    "label": "",
    "id": "2708"
  },
  {
    "raw_code": "def silence!\n        @silence = true\n        self\n      end",
    "comment": "Silences the logger.",
    "label": "",
    "id": "2709"
  },
  {
    "raw_code": "def mute\n        previous_silence, @silence = @silence, true\n        yield\n      ensure\n        @silence = previous_silence\n      end",
    "comment": "Silences the logger within a block.",
    "label": "",
    "id": "2710"
  },
  {
    "raw_code": "def fetch(name, options = nil, &block)\n        if block_given?\n          options = merged_options(options)\n          key = normalize_key(name, options)\n\n          entry = nil\n          unless options[:force]\n            instrument(:read, key, options) do |payload|\n              cached_entry = read_entry(key, **options, event: payload)\n              entry = handle_expired_entry(cached_entry, key, options)\n              if entry\n                if entry.mismatched?(normalize_version(name, options))\n                  entry = nil\n                else\n                  begin\n                    entry.value\n                  rescue DeserializationError\n                    entry = nil\n                  end",
    "comment": "Fetches data from the cache, using the given key. If there is data in the cache with the given key, then that data is returned.  If there is no such data in the cache (a cache miss), then +nil+ will be returned. However, if a block has been passed, that block will be passed the key and executed in the event of a cache miss. The return value of the block will be written to the cache under the given cache key, and that return value will be returned.  cache.write('today', 'Monday') cache.fetch('today')  # => \"Monday\"  cache.fetch('city')   # => nil cache.fetch('city') do 'Duckburgh' end cache.fetch('city')   # => \"Duckburgh\"  ==== Options  Internally, +fetch+ calls +read_entry+, and calls +write_entry+ on a cache miss. Thus, +fetch+ supports the same options as #read and #write. Additionally, +fetch+ supports the following options:  * <tt>force: true</tt> - Forces a cache \"miss,\" meaning we treat the cache value as missing even if it's present. Passing a block is required when +force+ is true so this always results in a cache write.  cache.write('today', 'Monday') cache.fetch('today', force: true) { 'Tuesday' } # => 'Tuesday' cache.fetch('today', force: true) # => ArgumentError  The +:force+ option is useful when you're calling some other method to ask whether you should force a cache write. Otherwise, it's clearer to just call +write+.  * <tt>skip_nil: true</tt> - Prevents caching a nil result:  cache.fetch('foo') { nil } cache.fetch('bar', skip_nil: true) { nil } cache.exist?('foo') # => true cache.exist?('bar') # => false  * +:race_condition_ttl+ - Specifies the number of seconds during which an expired value can be reused while a new value is being generated. This can be used to prevent race conditions when cache entries expire, by preventing multiple processes from simultaneously regenerating the same entry (also known as the dog pile effect).  When a process encounters a cache entry that has expired less than +:race_condition_ttl+ seconds ago, it will bump the expiration time by +:race_condition_ttl+ seconds before generating a new value. During this extended time window, while the process generates a new value, other processes will continue to use the old value. After the first process writes the new value, other processes will then use it.  If the first process errors out while generating a new value, another process can try to generate a new value after the extended time window has elapsed.  # Set all values to expire after one second. cache = ActiveSupport::Cache::MemoryStore.new(expires_in: 1)  cache.write(\"foo\", \"original value\") val_1 = nil val_2 = nil p cache.read(\"foo\") # => \"original value\"  sleep 1 # wait until the cache expires  t1 = Thread.new do # fetch does the following: # 1. gets an recent expired entry # 2. extends the expiry by 2 seconds (race_condition_ttl) # 3. regenerates the new value val_1 = cache.fetch(\"foo\", race_condition_ttl: 2) do sleep 1 \"new value 1\" end end  # Wait until t1 extends the expiry of the entry # but before generating the new value sleep 0.1  val_2 = cache.fetch(\"foo\", race_condition_ttl: 2) do # This block won't be executed because t1 extended the expiry \"new value 2\" end  t1.join  p val_1 # => \"new value 1\" p val_2 # => \"original value\" p cache.fetch(\"foo\") # => \"new value 1\"  # The entry requires 3 seconds to expire (expires_in + race_condition_ttl) # We have waited 2 seconds already (sleep(1) + t1.join) thus we need to wait 1 # more second to see the entry expire. sleep 1  p cache.fetch(\"foo\") # => nil  ==== Dynamic Options  In some cases it may be necessary to dynamically compute options based on the cached value. To support this, an ActiveSupport::Cache::WriteOptions instance is passed as the second argument to the block. For example:  cache.fetch(\"authentication-token:#{user.id}\") do |key, options| token = authenticate_to_service options.expires_at = token.expires_at token end ",
    "label": "",
    "id": "2711"
  },
  {
    "raw_code": "def read(name, options = nil)\n        options = merged_options(options)\n        key     = normalize_key(name, options)\n        version = normalize_version(name, options)\n\n        instrument(:read, key, options) do |payload|\n          entry = read_entry(key, **options, event: payload)\n\n          if entry\n            if entry.expired?\n              delete_entry(key, **options)\n              payload[:hit] = false if payload\n              nil\n            elsif entry.mismatched?(version)\n              payload[:hit] = false if payload\n              nil\n            else\n              payload[:hit] = true if payload\n              begin\n                entry.value\n              rescue DeserializationError\n                payload[:hit] = false\n                nil\n              end",
    "comment": "Reads data from the cache, using the given key. If there is data in the cache with the given key, then that data is returned. Otherwise, +nil+ is returned.  Note, if data was written with the <tt>:expires_in</tt> or <tt>:version</tt> options, both of these conditions are applied before the data is returned.  ==== Options  * +:namespace+ - Replace the store namespace for this call. * +:version+ - Specifies a version for the cache entry. If the cached version does not match the requested version, the read will be treated as a cache miss. This feature is used to support recyclable cache keys.  Other options will be handled by the specific cache store implementation.",
    "label": "",
    "id": "2712"
  },
  {
    "raw_code": "def read_multi(*names)\n        return {} if names.empty?\n\n        options = names.extract_options!\n        options = merged_options(options)\n        keys    = names.map { |name| normalize_key(name, options) }\n\n        instrument_multi :read_multi, keys, options do |payload|\n          read_multi_entries(names, **options, event: payload).tap do |results|\n            payload[:hits] = results.keys.map { |name| normalize_key(name, options) }\n          end",
    "comment": "Reads multiple values at once from the cache. Options can be passed in the last argument.  Some cache implementation may optimize this method.  Returns a hash mapping the names provided to the values found.",
    "label": "",
    "id": "2713"
  },
  {
    "raw_code": "def write_multi(hash, options = nil)\n        return hash if hash.empty?\n\n        options = merged_options(options)\n        normalized_hash = hash.transform_keys { |key| normalize_key(key, options) }\n\n        instrument_multi :write_multi, normalized_hash, options do |payload|\n          entries = hash.each_with_object({}) do |(name, value), memo|\n            memo[normalize_key(name, options)] = Entry.new(value, **options, version: normalize_version(name, options))\n          end",
    "comment": "Cache Storage API to write multiple values at once.",
    "label": "",
    "id": "2714"
  },
  {
    "raw_code": "def fetch_multi(*names)\n        raise ArgumentError, \"Missing block: `Cache#fetch_multi` requires a block.\" unless block_given?\n        return {} if names.empty?\n\n        options = names.extract_options!\n        options = merged_options(options)\n        keys    = names.map { |name| normalize_key(name, options) }\n        writes  = {}\n        ordered = instrument_multi :read_multi, keys, options do |payload|\n          if options[:force]\n            reads = {}\n          else\n            reads = read_multi_entries(names, **options)\n          end",
    "comment": "Fetches data from the cache, using the given keys. If there is data in the cache with the given keys, then that data is returned. Otherwise, the supplied block is called for each key for which there was no data, and the result will be written to the cache and returned. Therefore, you need to pass a block that returns the data to be written to the cache. If you do not want to write the cache when the cache is not found, use #read_multi.  Returns a hash with the data for each of the names. For example:  cache.write(\"bim\", \"bam\") cache.fetch_multi(\"bim\", \"unknown_key\") do |key| \"Fallback value for key: #{key}\" end # => { \"bim\" => \"bam\", #      \"unknown_key\" => \"Fallback value for key: unknown_key\" }  You may also specify additional options via the +options+ argument. See #fetch for details. Other options are passed to the underlying cache implementation. For example:  cache.fetch_multi(\"fizz\", expires_in: 5.seconds) do |key| \"buzz\" end # => {\"fizz\"=>\"buzz\"} cache.read(\"fizz\") # => \"buzz\" sleep(6) cache.read(\"fizz\") # => nil",
    "label": "",
    "id": "2715"
  },
  {
    "raw_code": "def write(name, value, options = nil)\n        options = merged_options(options)\n        key = normalize_key(name, options)\n\n        instrument(:write, key, options) do\n          entry = Entry.new(value, **options, version: normalize_version(name, options))\n          write_entry(key, entry, **options)\n        end",
    "comment": "Writes the value to the cache with the key. The value must be supported by the +coder+'s +dump+ and +load+ methods.  Returns +true+ if the write succeeded, +nil+ if there was an error talking to the cache backend, or +false+ if the write failed for another reason.  By default, cache entries larger than 1kB are compressed. Compression allows more data to be stored in the same memory footprint, leading to fewer cache evictions and higher hit rates.  ==== Options  * <tt>compress: false</tt> - Disables compression of the cache entry.  * +:compress_threshold+ - The compression threshold, specified in bytes. \\Cache entries larger than this threshold will be compressed. Defaults to +1.kilobyte+.  * +:expires_in+ - Sets a relative expiration time for the cache entry, specified in seconds. +:expire_in+ and +:expired_in+ are aliases for +:expires_in+.  cache = ActiveSupport::Cache::MemoryStore.new(expires_in: 5.minutes) cache.write(key, value, expires_in: 1.minute) # Set a lower value for one entry  * +:expires_at+ - Sets an absolute expiration time for the cache entry.  cache = ActiveSupport::Cache::MemoryStore.new cache.write(key, value, expires_at: Time.now.at_end_of_hour)  * +:version+ - Specifies a version for the cache entry. When reading from the cache, if the cached version does not match the requested version, the read will be treated as a cache miss. This feature is used to support recyclable cache keys.  * +:unless_exist+ - Prevents overwriting an existing cache entry.  Other options will be handled by the specific cache store implementation.",
    "label": "",
    "id": "2716"
  },
  {
    "raw_code": "def delete(name, options = nil)\n        options = merged_options(options)\n        key = normalize_key(name, options)\n\n        instrument(:delete, key, options) do\n          delete_entry(key, **options)\n        end",
    "comment": "Deletes an entry in the cache. Returns +true+ if an entry is deleted and +false+ otherwise.  Options are passed to the underlying cache implementation.",
    "label": "",
    "id": "2717"
  },
  {
    "raw_code": "def delete_multi(names, options = nil)\n        return 0 if names.empty?\n\n        options = merged_options(options)\n        names.map! { |key| normalize_key(key, options) }\n\n        instrument_multi(:delete_multi, names, options) do\n          delete_multi_entries(names, **options)\n        end",
    "comment": "Deletes multiple entries in the cache. Returns the number of deleted entries.  Options are passed to the underlying cache implementation.",
    "label": "",
    "id": "2718"
  },
  {
    "raw_code": "def exist?(name, options = nil)\n        options = merged_options(options)\n        key = normalize_key(name, options)\n\n        instrument(:exist?, key) do |payload|\n          entry = read_entry(key, **options, event: payload)\n          (entry && !entry.expired? && !entry.mismatched?(normalize_version(name, options))) || false\n        end",
    "comment": "Returns +true+ if the cache contains an entry for the given key.  Options are passed to the underlying cache implementation.",
    "label": "",
    "id": "2719"
  },
  {
    "raw_code": "def delete_matched(matcher, options = nil)\n        raise NotImplementedError.new(\"#{self.class.name} does not support delete_matched\")\n      end",
    "comment": "Deletes all entries with keys matching the pattern.  Options are passed to the underlying cache implementation.  Some implementations may not support this method.",
    "label": "",
    "id": "2720"
  },
  {
    "raw_code": "def increment(name, amount = 1, options = nil)\n        raise NotImplementedError.new(\"#{self.class.name} does not support increment\")\n      end",
    "comment": "Increments an integer value in the cache.  Options are passed to the underlying cache implementation.  Some implementations may not support this method.",
    "label": "",
    "id": "2721"
  },
  {
    "raw_code": "def decrement(name, amount = 1, options = nil)\n        raise NotImplementedError.new(\"#{self.class.name} does not support decrement\")\n      end",
    "comment": "Decrements an integer value in the cache.  Options are passed to the underlying cache implementation.  Some implementations may not support this method.",
    "label": "",
    "id": "2722"
  },
  {
    "raw_code": "def read_counter(name, **options)\n        options = merged_options(options).merge(raw: true)\n        read(name, **options)&.to_i\n      end",
    "comment": "Reads a counter that was set by #increment / #decrement.  cache.write_counter(\"foo\", 1) cache.read_counter(\"foo\") # => 1 cache.increment(\"foo\") cache.read_counter(\"foo\") # => 2  Options are passed to the underlying cache implementation.",
    "label": "",
    "id": "2723"
  },
  {
    "raw_code": "def write_counter(name, value, **options)\n        options = merged_options(options).merge(raw: true)\n        write(name, value.to_i, **options)\n      end",
    "comment": "Writes a counter that can then be modified by #increment / #decrement.  cache.write_counter(\"foo\", 1) cache.read_counter(\"foo\") # => 1 cache.increment(\"foo\") cache.read_counter(\"foo\") # => 2  Options are passed to the underlying cache implementation.",
    "label": "",
    "id": "2724"
  },
  {
    "raw_code": "def cleanup(options = nil)\n        raise NotImplementedError.new(\"#{self.class.name} does not support cleanup\")\n      end",
    "comment": "Cleans up the cache by removing expired entries.  Options are passed to the underlying cache implementation.  Some implementations may not support this method.",
    "label": "",
    "id": "2725"
  },
  {
    "raw_code": "def clear(options = nil)\n        raise NotImplementedError.new(\"#{self.class.name} does not support clear\")\n      end",
    "comment": "Clears the entire cache. Be careful with this method since it could affect other processes if shared cache is being used.  The options hash is passed to the underlying cache implementation.  Some implementations may not support this method.",
    "label": "",
    "id": "2726"
  },
  {
    "raw_code": "def namespace\n        @options[:namespace]\n      end",
    "comment": "Get the current namespace",
    "label": "",
    "id": "2727"
  },
  {
    "raw_code": "def namespace=(namespace)\n        @options[:namespace] = namespace\n      end",
    "comment": "Set the current namespace. Note, this will be ignored if custom options are passed to cache wills with a namespace key.",
    "label": "",
    "id": "2728"
  },
  {
    "raw_code": "def key_matcher(pattern, options) # :doc:\n          prefix = options[:namespace].is_a?(Proc) ? options[:namespace].call : options[:namespace]\n          if prefix\n            source = pattern.source\n            if source.start_with?(\"^\")\n              source = source[1, source.length]\n            else\n              source = \".*#{source[0, source.length]}\"\n            end",
    "comment": "Adds the namespace defined in the options to a pattern designed to match keys. Implementations that support delete_matched should call this method to translate a pattern that matches names into one that matches namespaced keys.",
    "label": "",
    "id": "2729"
  },
  {
    "raw_code": "def read_entry(key, **options)\n          raise NotImplementedError.new\n        end",
    "comment": "Reads an entry from the cache implementation. Subclasses must implement this method.",
    "label": "",
    "id": "2730"
  },
  {
    "raw_code": "def write_entry(key, entry, **options)\n          raise NotImplementedError.new\n        end",
    "comment": "Writes an entry to the cache implementation. Subclasses must implement this method.",
    "label": "",
    "id": "2731"
  },
  {
    "raw_code": "def read_multi_entries(names, **options)\n          names.each_with_object({}) do |name, results|\n            key   = normalize_key(name, options)\n            entry = read_entry(key, **options)\n\n            next unless entry\n\n            version = normalize_version(name, options)\n\n            if entry.expired?\n              delete_entry(key, **options)\n            elsif !entry.mismatched?(version)\n              results[name] = entry.value\n            end",
    "comment": "Reads multiple entries from the cache implementation. Subclasses MAY implement this method.",
    "label": "",
    "id": "2732"
  },
  {
    "raw_code": "def write_multi_entries(hash, **options)\n          hash.each do |key, entry|\n            write_entry key, entry, **options\n          end",
    "comment": "Writes multiple entries to the cache implementation. Subclasses MAY implement this method.",
    "label": "",
    "id": "2733"
  },
  {
    "raw_code": "def delete_entry(key, **options)\n          raise NotImplementedError.new\n        end",
    "comment": "Deletes an entry from the cache implementation. Subclasses must implement this method.",
    "label": "",
    "id": "2734"
  },
  {
    "raw_code": "def delete_multi_entries(entries, **options)\n          entries.count { |key| delete_entry(key, **options) }\n        end",
    "comment": "Deletes multiples entries in the cache implementation. Subclasses MAY implement this method.",
    "label": "",
    "id": "2735"
  },
  {
    "raw_code": "def merged_options(call_options)\n          if call_options\n            call_options = normalize_options(call_options)\n            if call_options.key?(:expires_in) && call_options.key?(:expires_at)\n              raise ArgumentError, \"Either :expires_in or :expires_at can be supplied, but not both\"\n            end",
    "comment": "Merges the default options with ones specific to a method call.",
    "label": "",
    "id": "2736"
  },
  {
    "raw_code": "def normalize_options(options)\n          options = options.dup\n          OPTION_ALIASES.each do |canonical_name, aliases|\n            alias_key = aliases.detect { |key| options.key?(key) }\n            options[canonical_name] ||= options[alias_key] if alias_key\n            options.except!(*aliases)\n          end",
    "comment": "Normalize aliased options to their canonical form",
    "label": "",
    "id": "2737"
  },
  {
    "raw_code": "def normalize_key(key, options = nil)\n          key = expand_and_namespace_key(key, options)\n          truncate_key(key)\n        end",
    "comment": "Expands, namespaces and truncates the cache key. Raises an exception when the key is +nil+ or an empty string. May be overridden by cache stores to do additional normalization.",
    "label": "",
    "id": "2738"
  },
  {
    "raw_code": "def namespace_key(key, call_options = nil)\n          namespace = if call_options&.key?(:namespace)\n            call_options[:namespace]\n          else\n            options[:namespace]\n          end",
    "comment": "Prefix the key with a namespace string:  namespace_key 'foo', namespace: 'cache' # => 'cache:foo'  With a namespace block:  namespace_key 'foo', namespace: -> { 'cache' } # => 'cache:foo'",
    "label": "",
    "id": "2739"
  },
  {
    "raw_code": "def expanded_key(key)\n          return key.cache_key.to_s if key.respond_to?(:cache_key)\n\n          case key\n          when Array\n            if key.size > 1\n              key.collect { |element| expanded_key(element) }\n            else\n              expanded_key(key.first)\n            end",
    "comment": "Expands key to be a consistent string value. Invokes +cache_key+ if object responds to +cache_key+. Otherwise, +to_param+ method will be called. If the key is a Hash, then keys will be sorted alphabetically.",
    "label": "",
    "id": "2740"
  },
  {
    "raw_code": "def expires_in=(expires_in)\n        @options.delete(:expires_at)\n        @options[:expires_in] = expires_in\n      end",
    "comment": "Sets the Cache entry's +expires_in+ value. If an +expires_at+ option was previously set, this will unset it since +expires_in+ and +expires_at+ cannot both be set.",
    "label": "",
    "id": "2741"
  },
  {
    "raw_code": "def expires_at=(expires_at)\n        @options.delete(:expires_in)\n        @options[:expires_at] = expires_at\n      end",
    "comment": "Sets the Cache entry's +expires_at+ value. If an +expires_in+ option was previously set, this will unset it since +expires_at+ and +expires_in+ cannot both be set.",
    "label": "",
    "id": "2742"
  },
  {
    "raw_code": "def run_callbacks(kind, type = nil)\n      callbacks = __callbacks[kind.to_sym]\n\n      if callbacks.empty?\n        yield if block_given?\n      else\n        env = Filters::Environment.new(self, false, nil)\n\n        next_sequence = callbacks.compile(type)\n\n        # Common case: no 'around' callbacks defined\n        if next_sequence.final?\n          next_sequence.invoke_before(env)\n          env.value = !env.halted && (!block_given? || yield)\n          next_sequence.invoke_after(env)\n          env.value\n        else\n          invoke_sequence = Proc.new do\n            skipped = nil\n\n            while true\n              current = next_sequence\n              current.invoke_before(env)\n              if current.final?\n                env.value = !env.halted && (!block_given? || yield)\n              elsif current.skip?(env)\n                (skipped ||= []) << current\n                next_sequence = next_sequence.nested\n                next\n              else\n                next_sequence = next_sequence.nested\n                begin\n                  target, block, method, *arguments = current.expand_call_template(env, invoke_sequence)\n                  target.send(method, *arguments, &block)\n                ensure\n                  next_sequence = current\n                end",
    "comment": "Runs the callbacks for the given event.  Calls the before and around callbacks in the order they were set, yields the block (if given one), and then runs the after callbacks in reverse order.  If the callback chain was halted, returns +false+. Otherwise returns the result of the block, +nil+ if no callbacks have been set, or +true+ if callbacks have been set but no block is given.  run_callbacks :save do save end  --  As this method is used in many places, and often wraps large portions of user code, it has an additional design goal of minimizing its impact on the visible call stack. An exception from inside a :before or :after callback can be as noisy as it likes -- but when control has passed smoothly through and into the supplied block, we want as little evidence as possible that we were here.",
    "label": "",
    "id": "2743"
  },
  {
    "raw_code": "def halted_callback_hook(filter, name)\n      end",
    "comment": "A hook invoked every time a before callback is halted. This can be overridden in ActiveSupport::Callbacks implementors in order to provide better debugging/logging.",
    "label": "",
    "id": "2744"
  },
  {
    "raw_code": "def apply(callback_sequence)\n          compiled.apply(callback_sequence)\n        end",
    "comment": "Wraps code with filter",
    "label": "",
    "id": "2745"
  },
  {
    "raw_code": "def expand(target, value, block)\n            [target, block, @method_name]\n          end",
    "comment": "Return the parts needed to make this call, with the given input values.  Returns an array of the form:  [target, block, method, *arguments]  This array can be used as such:  target.send(method, *arguments, &block)  The actual invocation is left up to the caller to minimize call stack pollution.",
    "label": "",
    "id": "2746"
  },
  {
    "raw_code": "def self.build(filter, callback)\n          case filter\n          when Symbol\n            MethodCall.new(filter)\n          when Conditionals::Value\n            ProcCall.new(filter)\n          when ::Proc\n            case filter.arity\n            when 2\n              InstanceExec2.new(filter)\n            when 1, -2\n              InstanceExec1.new(filter)\n            else\n              InstanceExec0.new(filter)\n            end",
    "comment": "Filters support:  Symbols:: A method to call. Procs::   A proc to call with the object. Objects:: An object with a <tt>before_foo</tt> method on it to call.  All of these objects are converted into a CallTemplate and handled the same after this point.",
    "label": "",
    "id": "2747"
  },
  {
    "raw_code": "def __update_callbacks(name) # :nodoc:\n          self.descendants.prepend(self).reverse_each do |target|\n            chain = target.get_callbacks name\n            yield target, chain.dup\n          end",
    "comment": "This is used internally to append, prepend and skip callbacks to the CallbackChain.",
    "label": "",
    "id": "2748"
  },
  {
    "raw_code": "def set_callback(name, *filter_list, &block)\n          type, filters, options = normalize_callback_params(filter_list, block)\n\n          self_chain = get_callbacks name\n          mapped = filters.map do |filter|\n            Callback.build(self_chain, filter, type, options)\n          end",
    "comment": "Install a callback for the given event.  set_callback :save, :before, :before_method set_callback :save, :after,  :after_method, if: :condition set_callback :save, :around, ->(r, block) { stuff; result = block.call; stuff }  The second argument indicates whether the callback is to be run +:before+, +:after+, or +:around+ the event. If omitted, +:before+ is assumed. This means the first example above can also be written as:  set_callback :save, :before_method  The callback can be specified as a symbol naming an instance method; as a proc, lambda, or block; or as an object that responds to a certain method determined by the <tt>:scope</tt> argument to #define_callbacks.  If a proc, lambda, or block is given, its body is evaluated in the context of the current object. It can also optionally accept the current object as an argument.  Before and around callbacks are called in the order that they are set; after callbacks are called in the reverse order.  Around callbacks can access the return value from the event, if it wasn't halted, from the +yield+ call.  ===== Options  * <tt>:if</tt> - A symbol or an array of symbols, each naming an instance method or a proc; the callback will be called only when they all return a true value.  If a proc is given, its body is evaluated in the context of the current object. It can also optionally accept the current object as an argument. * <tt>:unless</tt> - A symbol or an array of symbols, each naming an instance method or a proc; the callback will be called only when they all return a false value.  If a proc is given, its body is evaluated in the context of the current object. It can also optionally accept the current object as an argument. * <tt>:prepend</tt> - If +true+, the callback will be prepended to the existing chain rather than appended.",
    "label": "",
    "id": "2749"
  },
  {
    "raw_code": "def skip_callback(name, *filter_list, &block)\n          type, filters, options = normalize_callback_params(filter_list, block)\n\n          options[:raise] = true unless options.key?(:raise)\n\n          __update_callbacks(name) do |target, chain|\n            filters.each do |filter|\n              callback = chain.find { |c| c.matches?(type, filter) }\n\n              if !callback && options[:raise]\n                raise ArgumentError, \"#{type.to_s.capitalize} #{name} callback #{filter.inspect} has not been defined\"\n              end",
    "comment": "Skip a previously set callback. Like #set_callback, <tt>:if</tt> or <tt>:unless</tt> options may be passed in order to control when the callback is skipped.  Note: this example uses +PersonRecord+ and +#saving_message+, which you can see defined here[rdoc-ref:ActiveSupport::Callbacks]  class Writer < PersonRecord attr_accessor :age skip_callback :save, :before, :saving_message, if: -> { age > 18 } end  When if option returns true, callback is skipped.  writer = Writer.new writer.age = 20 writer.save  Output: - save saved  When if option returns false, callback is NOT skipped.  young_writer = Writer.new young_writer.age = 17 young_writer.save  Output: saving... - save saved  An <tt>ArgumentError</tt> will be raised if the callback has not already been set (unless the <tt>:raise</tt> option is set to <tt>false</tt>).",
    "label": "",
    "id": "2750"
  },
  {
    "raw_code": "def reset_callbacks(name)\n          callbacks = get_callbacks name\n\n          self.descendants.each do |target|\n            chain = target.get_callbacks(name).dup\n            callbacks.each { |c| chain.delete(c) }\n            target.set_callbacks name, chain\n          end",
    "comment": "Remove all set callbacks for the given event.",
    "label": "",
    "id": "2751"
  },
  {
    "raw_code": "def define_callbacks(*names)\n          options = names.extract_options!\n\n          names.each do |name|\n            name = name.to_sym\n\n            module_eval <<-RUBY, __FILE__, __LINE__ + 1\n              def _run_#{name}_callbacks\n                yield if block_given?\n              end\n              silence_redefinition_of_method(:_run_#{name}_callbacks)\n\n              def _run_#{name}_callbacks!(&block)\n                run_callbacks #{name.inspect}, &block\n              end\n\n              def self._#{name}_callbacks\n                get_callbacks(#{name.inspect})\n              end\n\n              def self._#{name}_callbacks=(value)\n                set_callbacks(#{name.inspect}, value)\n              end\n\n              def _#{name}_callbacks\n                __callbacks[#{name.inspect}]\n              end\n            RUBY\n\n            ([self] + self.descendants).each do |target|\n              target.set_callbacks name, CallbackChain.new(name, options)\n            end",
    "comment": "Define sets of events in the object life cycle that support callbacks.  define_callbacks :validate define_callbacks :initialize, :save, :destroy  ===== Options  * <tt>:terminator</tt> - Determines when a before filter will halt the callback chain, preventing following before and around callbacks from being called and the event from being triggered. This should be a lambda to be executed. The current object and the result lambda of the callback will be provided to the terminator lambda.  define_callbacks :validate, terminator: ->(target, result_lambda) { result_lambda.call == false }  In this example, if any before validate callbacks returns +false+, any successive before and around callback is not executed.  The default terminator halts the chain when a callback throws +:abort+.  * <tt>:skip_after_callbacks_if_terminated</tt> - Determines if after callbacks should be terminated by the <tt>:terminator</tt> option. By default after callbacks are executed no matter if callback chain was terminated or not. This option has no effect if <tt>:terminator</tt> option is set to +nil+.  * <tt>:scope</tt> - Indicates which methods should be executed when an object is used as a callback.  class Audit def before(caller) puts 'Audit: before is called' end  def before_save(caller) puts 'Audit: before_save is called' end end  class Account include ActiveSupport::Callbacks  define_callbacks :save set_callback :save, :before, Audit.new  def save run_callbacks :save do puts 'save in main' end end end  In the above case whenever you save an account the method <tt>Audit#before</tt> will be called. On the other hand  define_callbacks :save, scope: [:kind, :name]  would trigger <tt>Audit#before_save</tt> instead. That's constructed by calling <tt>#{kind}_#{name}</tt> on the given instance. In this case \"kind\" is \"before\" and \"name\" is \"save\". In this context +:kind+ and +:name+ have special meanings: +:kind+ refers to the kind of callback (before/after/around) and +:name+ refers to the method on which callbacks are being defined.  A declaration like  define_callbacks :save, scope: [:name]  would call <tt>Audit#save</tt>.  ===== Notes  +names+ passed to +define_callbacks+ must not end with <tt>!</tt>, <tt>?</tt> or <tt>=</tt>.  Calling +define_callbacks+ multiple times with the same +names+ will overwrite previous callbacks registered with #set_callback.",
    "label": "",
    "id": "2752"
  },
  {
    "raw_code": "def included(base = nil, &block)\n      if base.nil?\n        if instance_variable_defined?(:@_included_block)\n          if @_included_block.source_location != block.source_location\n            raise MultipleIncludedBlocks\n          end",
    "comment": "Evaluate given block in context of base class, so that you can write class macros here. When you define more than one +included+ block, it raises an exception.",
    "label": "",
    "id": "2753"
  },
  {
    "raw_code": "def prepended(base = nil, &block)\n      if base.nil?\n        if instance_variable_defined?(:@_prepended_block)\n          if @_prepended_block.source_location != block.source_location\n            raise MultiplePrependBlocks\n          end",
    "comment": "Evaluate given block in context of base class, so that you can write class macros here. When you define more than one +prepended+ block, it raises an exception.",
    "label": "",
    "id": "2754"
  },
  {
    "raw_code": "def class_methods(&class_methods_module_definition)\n      mod = const_defined?(:ClassMethods, false) ?\n        const_get(:ClassMethods) :\n        const_set(:ClassMethods, Module.new)\n\n      mod.module_eval(&class_methods_module_definition)\n    end",
    "comment": "Define class methods from given block. You can define private class methods as well.  module Example extend ActiveSupport::Concern  class_methods do def foo; puts 'foo'; end  private def bar; puts 'bar'; end end end  class Buzz include Example end  Buzz.foo # => \"foo\" Buzz.bar # => private method 'bar' called for Buzz:Class(NoMethodError)",
    "label": "",
    "id": "2755"
  },
  {
    "raw_code": "def self.compile_methods!(keys)\n        keys.reject { |m| method_defined?(m) }.each do |key|\n          class_eval <<-RUBY, __FILE__, __LINE__ + 1\n            def #{key}; _get(#{key.inspect}); end\n          RUBY\n        end\n      end",
    "comment": "Compiles reader methods so we don't have to go through method_missing.",
    "label": "",
    "id": "2756"
  },
  {
    "raw_code": "def config\n        @_config ||= if respond_to?(:superclass) && superclass.respond_to?(:config)\n          superclass.config.inheritable_copy\n        else\n          # create a new \"anonymous\" class that will host the compiled reader methods\n          Class.new(Configuration).new\n        end",
    "comment": "Reads and writes attributes from a configuration OrderedOptions.  require \"active_support/configurable\"  class User include ActiveSupport::Configurable end  User.config.allowed_access = true User.config.level = 1  User.config.allowed_access # => true User.config.level          # => 1",
    "label": "",
    "id": "2757"
  },
  {
    "raw_code": "def configure\n        yield config\n      end",
    "comment": "Configure values from within the passed block.  require \"active_support/configurable\"  class User include ActiveSupport::Configurable end  User.allowed_access # => nil  User.configure do |config| config.allowed_access = true end  User.allowed_access # => true",
    "label": "",
    "id": "2758"
  },
  {
    "raw_code": "def config_accessor(*names, instance_reader: true, instance_writer: true, instance_accessor: true, default: nil) # :doc:\n        names.each do |name|\n          raise NameError.new(\"invalid config attribute name\") unless /\\A[_A-Za-z]\\w*\\z/.match?(name)\n\n          reader, reader_line = \"def #{name}; config.#{name}; end\", __LINE__\n          writer, writer_line = \"def #{name}=(value); config.#{name} = value; end\", __LINE__\n\n          singleton_class.class_eval reader, __FILE__, reader_line\n          singleton_class.class_eval writer, __FILE__, writer_line\n\n          if instance_accessor\n            class_eval reader, __FILE__, reader_line if instance_reader\n            class_eval writer, __FILE__, writer_line if instance_writer\n          end",
    "comment": "Allows you to add shortcut so that you don't have to refer to attribute through config. Also look at the example for config to contrast.  Defines both class and instance config accessors.  class User include ActiveSupport::Configurable config_accessor :allowed_access end  User.allowed_access # => nil User.allowed_access = false User.allowed_access # => false  user = User.new user.allowed_access # => false user.allowed_access = true user.allowed_access # => true  User.allowed_access # => false  The attribute name must be a valid method name in Ruby.  class User include ActiveSupport::Configurable config_accessor :\"1_Badname\" end # => NameError: invalid config attribute name  To omit the instance writer method, pass <tt>instance_writer: false</tt>. To omit the instance reader method, pass <tt>instance_reader: false</tt>.  class User include ActiveSupport::Configurable config_accessor :allowed_access, instance_reader: false, instance_writer: false end  User.allowed_access = false User.allowed_access # => false  User.new.allowed_access = true # => NoMethodError User.new.allowed_access        # => NoMethodError  Or pass <tt>instance_accessor: false</tt>, to omit both instance methods.  class User include ActiveSupport::Configurable config_accessor :allowed_access, instance_accessor: false end  User.allowed_access = false User.allowed_access # => false  User.new.allowed_access = true # => NoMethodError User.new.allowed_access        # => NoMethodError  Also you can pass <tt>default</tt> or a block to set up the attribute with a default value.  class User include ActiveSupport::Configurable config_accessor :allowed_access, default: false config_accessor :hair_colors do [:brown, :black, :blonde, :red] end end  User.allowed_access # => false User.hair_colors # => [:brown, :black, :blonde, :red]",
    "label": "",
    "id": "2759"
  },
  {
    "raw_code": "def config\n      @_config ||= self.class.config.inheritable_copy\n    end",
    "comment": "Reads and writes attributes from a configuration OrderedOptions.  require \"active_support/configurable\"  class User include ActiveSupport::Configurable end  user = User.new  user.config.allowed_access = true user.config.level = 1  user.config.allowed_access # => true user.config.level          # => 1",
    "label": "",
    "id": "2760"
  },
  {
    "raw_code": "def self.run(title = \"Continuous Integration\", subtitle = \"Running tests, style checks, and security audits\", &block)\n      new.tap do |ci|\n        ENV[\"CI\"] = \"true\"\n        ci.heading title, subtitle, padding: false\n        ci.report(title, &block)\n        abort unless ci.success?\n      end",
    "comment": "Perform a CI run. Execute each step, show their results and runtime, and exit with a non-zero status if there are any failures.  Pass an optional title, subtitle, and a block that declares the steps to be executed.  Sets the CI environment variable to \"true\" to allow for conditional behavior in the app, like enabling eager loading and disabling logging.  Example:  ActiveSupport::ContinuousIntegration.run do step \"Setup\", \"bin/setup --skip-server\" step \"Style: Ruby\", \"bin/rubocop\" step \"Security: Gem audit\", \"bin/bundler-audit\" step \"Tests: Rails\", \"bin/rails test test:system\"  if success? step \"Signoff: Ready for merge and deploy\", \"gh signoff\" else failure \"Skipping signoff; CI failed.\", \"Fix the issues and try again.\" end end",
    "label": "",
    "id": "2761"
  },
  {
    "raw_code": "def step(title, *command)\n      heading title, command.join(\" \"), type: :title\n      report(title) { results << system(*command) }\n    end",
    "comment": "Declare a step with a title and a command. The command can either be given as a single string or as multiple strings that will be passed to `system` as individual arguments (and therefore correctly escaped for paths etc).  Examples:  step \"Setup\", \"bin/setup\" step \"Single test\", \"bin/rails\", \"test\", \"--name\", \"test_that_is_one\"",
    "label": "",
    "id": "2762"
  },
  {
    "raw_code": "def success?\n      results.all?\n    end",
    "comment": "Returns true if all steps were successful.",
    "label": "",
    "id": "2763"
  },
  {
    "raw_code": "def failure(title, subtitle = nil)\n      heading title, subtitle, type: :error\n    end",
    "comment": "Display an error heading with the title and optional subtitle to reflect that the run failed.",
    "label": "",
    "id": "2764"
  },
  {
    "raw_code": "def heading(heading, subtitle = nil, type: :banner, padding: true)\n      echo \"#{padding ? \"\\n\\n\" : \"\"}#{heading}\", type: type\n      echo \"#{subtitle}#{padding ? \"\\n\" : \"\"}\", type: :subtitle if subtitle\n    end",
    "comment": "Display a colorized heading followed by an optional subtitle.  Examples:  heading \"Smoke Testing\", \"End-to-end tests verifying key functionality\", padding: false heading \"Skipping video encoding tests\", \"Install FFmpeg to run these tests\", type: :error  See ActiveSupport::ContinuousIntegration::COLORS for a complete list of options.",
    "label": "",
    "id": "2765"
  },
  {
    "raw_code": "def echo(text, type:)\n      puts colorize(text, type)\n    end",
    "comment": "Echo text to the terminal in the color corresponding to the type of the text.  Examples:  echo \"This is going to be green!\", type: :success echo \"This is going to be red!\", type: :error  See ActiveSupport::ContinuousIntegration::COLORS for a complete list of options.",
    "label": "",
    "id": "2766"
  },
  {
    "raw_code": "def report(title, &block)\n      Signal.trap(\"INT\") { abort colorize(:error, \"\\n❌ #{title} interrupted\") }\n\n      ci = self.class.new\n      elapsed = timing { ci.instance_eval(&block) }\n\n      if ci.success?\n        echo \"\\n✅ #{title} passed in #{elapsed}\", type: :success\n      else\n        echo \"\\n❌ #{title} failed in #{elapsed}\", type: :error\n      end",
    "comment": ":nodoc:",
    "label": "",
    "id": "2767"
  },
  {
    "raw_code": "def instance\n        current_instances[current_instances_key] ||= new\n      end",
    "comment": "Returns singleton instance for this class in this thread. If none exists, one is created.",
    "label": "",
    "id": "2768"
  },
  {
    "raw_code": "def attribute(*names, default: NOT_SET)\n        invalid_attribute_names = names.map(&:to_sym) & INVALID_ATTRIBUTE_NAMES\n        if invalid_attribute_names.any?\n          raise ArgumentError, \"Restricted attribute names: #{invalid_attribute_names.join(\", \")}\"\n        end",
    "comment": "Declares one or more attributes that will be given both class and instance accessor methods.  ==== Options  * <tt>:default</tt> - The default value for the attributes. If the value is a proc or lambda, it will be called whenever an instance is constructed. Otherwise, the value will be duplicated with +#dup+. Default values are re-assigned when the attributes are reset.",
    "label": "",
    "id": "2769"
  },
  {
    "raw_code": "def before_reset(*methods, &block)\n        set_callback :reset, :before, *methods, &block\n      end",
    "comment": "Calls this callback before #reset is called on the instance. Used for resetting external collaborators that depend on current values.",
    "label": "",
    "id": "2770"
  },
  {
    "raw_code": "def resets(*methods, &block)\n        set_callback :reset, :after, *methods, &block\n      end",
    "comment": "Calls this callback after #reset is called on the instance. Used for resetting external collaborators, like Time.zone.",
    "label": "",
    "id": "2771"
  },
  {
    "raw_code": "def set(attributes, &block)\n      with(**attributes, &block)\n    end",
    "comment": "Expose one or more attributes within a block. Old values are returned after the block concludes. Example demonstrating the common use of needing to set Current attributes outside the request-cycle:  class Chat::PublicationJob < ApplicationJob def perform(attributes, room_number, creator) Current.set(person: creator) do Chat::Publisher.publish(attributes: attributes, room_number: room_number) end end end",
    "label": "",
    "id": "2772"
  },
  {
    "raw_code": "def reset\n      run_callbacks :reset do\n        self.attributes = resolve_defaults\n      end",
    "comment": "Reset all attributes. Should be called before and after actions, when used as a per-request singleton.",
    "label": "",
    "id": "2773"
  },
  {
    "raw_code": "def deep_merge(other, &block)\n      dup.deep_merge!(other, &block)\n    end",
    "comment": "Returns a new instance with the values from +other+ merged recursively.  class Hash include ActiveSupport::DeepMergeable end  hash_1 = { a: true, b: { c: [1, 2, 3] } } hash_2 = { a: false, b: { x: [3, 4, 5] } }  hash_1.deep_merge(hash_2) # => { a: false, b: { c: [1, 2, 3], x: [3, 4, 5] } }  A block can be provided to merge non-<tt>DeepMergeable</tt> values:  hash_1 = { a: 100, b: 200, c: { c1: 100 } } hash_2 = { b: 250, c: { c1: 200 } }  hash_1.deep_merge(hash_2) do |key, this_val, other_val| this_val + other_val end # => { a: 100, b: 450, c: { c1: 300 } } ",
    "label": "",
    "id": "2774"
  },
  {
    "raw_code": "def deep_merge!(other, &block)\n      merge!(other) do |key, this_val, other_val|\n        if this_val.is_a?(DeepMergeable) && this_val.deep_merge?(other_val)\n          this_val.deep_merge(other_val, &block)\n        elsif block_given?\n          block.call(key, this_val, other_val)\n        else\n          other_val\n        end",
    "comment": "Same as #deep_merge, but modifies +self+.",
    "label": "",
    "id": "2775"
  },
  {
    "raw_code": "def deep_merge?(other)\n      other.is_a?(self.class)\n    end",
    "comment": "Returns true if +other+ can be deep merged into +self+. Classes may override this method to restrict or expand the domain of deep mergeable values. Defaults to checking that +other+ is of type +self.class+.",
    "label": "",
    "id": "2776"
  },
  {
    "raw_code": "def self.run_interlock(&block)\n      interlock.running(&block)\n    end",
    "comment": ":doc: Execute the supplied block without interference from any concurrent loads.",
    "label": "",
    "id": "2777"
  },
  {
    "raw_code": "def self.load_interlock(&block)\n      ActiveSupport.deprecator.warn(\n        \"ActiveSupport::Dependencies.load_interlock is deprecated and \" \\\n        \"will be removed in Rails 9.0. The loading interlock is no longer \" \\\n        \"used since Rails switched to Zeitwerk for autoloading.\"\n      )\n      yield if block\n    end",
    "comment": "Execute the supplied block while holding an exclusive lock, preventing any other thread from being inside a #run_interlock block at the same time.",
    "label": "",
    "id": "2778"
  },
  {
    "raw_code": "def self.unload_interlock(&block)\n      interlock.unloading(&block)\n    end",
    "comment": "Execute the supplied block while holding an exclusive lock, preventing any other thread from being inside a #run_interlock block at the same time.",
    "label": "",
    "id": "2779"
  },
  {
    "raw_code": "def self.clear\n      unload_interlock do\n        _autoloaded_tracked_classes.clear\n        autoloader.reload\n      end",
    "comment": "Private method that reloads constants autoloaded by the main autoloader.  Rails.application.reloader.reload! is the public interface for application reload. That involves more things, like deleting unloaded classes from the internal state of the descendants tracker, or reloading routes.",
    "label": "",
    "id": "2780"
  },
  {
    "raw_code": "def self.search_for_file(relpath)\n      relpath += \".rb\" unless relpath.end_with?(\".rb\")\n      autoload_paths.each do |autoload_path|\n        abspath = File.join(autoload_path, relpath)\n        return abspath if File.file?(abspath)\n      end",
    "comment": "Private method used by require_dependency.",
    "label": "",
    "id": "2781"
  },
  {
    "raw_code": "def self.eager_load?(path)\n      _eager_load_paths.member?(path)\n    end",
    "comment": "Private method that helps configuring the autoloaders.",
    "label": "",
    "id": "2782"
  },
  {
    "raw_code": "def initialize(deprecation_horizon = \"8.2\", gem_name = \"Rails\")\n      self.gem_name = gem_name\n      self.deprecation_horizon = deprecation_horizon\n      # By default, warnings are not silenced and debugging is off.\n      self.silenced = false\n      self.debug = false\n      @silence_counter = Concurrent::ThreadLocalVar.new(0)\n      @explicitly_allowed_warnings = Concurrent::ThreadLocalVar.new(nil)\n    end",
    "comment": "It accepts two parameters on initialization. The first is a version of library and the second is a library name.  ActiveSupport::Deprecation.new('2.0', 'MyLibrary')",
    "label": "",
    "id": "2783"
  },
  {
    "raw_code": "def parse(iso8601duration)\n        parts = ISO8601Parser.new(iso8601duration).parse!\n        new(calculate_total_seconds(parts), parts)\n      end",
    "comment": "Creates a new Duration from string formatted according to ISO 8601 Duration.  See {ISO 8601}[https://en.wikipedia.org/wiki/ISO_8601#Durations] for more information. This method allows negative parts to be present in pattern. If invalid string is provided, it will raise +ActiveSupport::Duration::ISO8601Parser::ParsingError+.",
    "label": "",
    "id": "2784"
  },
  {
    "raw_code": "def build(value)\n        unless value.is_a?(::Numeric)\n          raise TypeError, \"can't build an #{self.name} from a #{value.class.name}\"\n        end",
    "comment": "Creates a new Duration from a seconds value that is converted to the individual parts:  ActiveSupport::Duration.build(31556952).parts # => {:years=>1} ActiveSupport::Duration.build(2716146).parts  # => {:months=>1, :days=>1} ",
    "label": "",
    "id": "2785"
  },
  {
    "raw_code": "def parts\n      @parts.dup\n    end",
    "comment": "Returns a copy of the parts hash that defines the duration.  5.minutes.parts # => {:minutes=>5} 3.years.parts # => {:years=>3}",
    "label": "",
    "id": "2786"
  },
  {
    "raw_code": "def <=>(other)\n      if Duration === other\n        value <=> other.value\n      elsif Numeric === other\n        value <=> other\n      end",
    "comment": "Compares one Duration with another or a Numeric to this Duration. Numeric values are treated as seconds.",
    "label": "",
    "id": "2787"
  },
  {
    "raw_code": "def +(other)\n      if Duration === other\n        parts = @parts.merge(other._parts) do |_key, value, other_value|\n          value + other_value\n        end",
    "comment": "Adds another Duration or a Numeric to this Duration. Numeric values are treated as seconds.",
    "label": "",
    "id": "2788"
  },
  {
    "raw_code": "def -(other)\n      self + (-other)\n    end",
    "comment": "Subtracts another Duration or a Numeric from this Duration. Numeric values are treated as seconds.",
    "label": "",
    "id": "2789"
  },
  {
    "raw_code": "def *(other)\n      if Scalar === other || Duration === other\n        Duration.new(value * other.value, @parts.transform_values { |number| number * other.value }, @variable || other.variable?)\n      elsif Numeric === other\n        Duration.new(value * other, @parts.transform_values { |number| number * other }, @variable)\n      else\n        raise_type_error(other)\n      end",
    "comment": "Multiplies this Duration by a Numeric and returns a new Duration.",
    "label": "",
    "id": "2790"
  },
  {
    "raw_code": "def /(other)\n      if Scalar === other\n        Duration.new(value / other.value, @parts.transform_values { |number| number / other.value }, @variable)\n      elsif Duration === other\n        value / other.value\n      elsif Numeric === other\n        Duration.new(value / other, @parts.transform_values { |number| number / other }, @variable)\n      else\n        raise_type_error(other)\n      end",
    "comment": "Divides this Duration by a Numeric and returns a new Duration.",
    "label": "",
    "id": "2791"
  },
  {
    "raw_code": "def %(other)\n      if Duration === other || Scalar === other\n        Duration.build(value % other.value)\n      elsif Numeric === other\n        Duration.build(value % other)\n      else\n        raise_type_error(other)\n      end",
    "comment": "Returns the modulo of this Duration by another Duration or Numeric. Numeric values are treated as seconds.",
    "label": "",
    "id": "2792"
  },
  {
    "raw_code": "def ==(other)\n      if Duration === other\n        other.value == value\n      else\n        other == value\n      end",
    "comment": "Returns +true+ if +other+ is also a Duration instance with the same +value+, or if <tt>other == value</tt>.",
    "label": "",
    "id": "2793"
  },
  {
    "raw_code": "def to_s\n      @value.to_s\n    end",
    "comment": "Returns the amount of seconds a duration covers as a string. For more information check to_i method.  1.day.to_s # => \"86400\"",
    "label": "",
    "id": "2794"
  },
  {
    "raw_code": "def to_i\n      @value.to_i\n    end",
    "comment": "Returns the number of seconds that this Duration represents.  1.minute.to_i   # => 60 1.hour.to_i     # => 3600 1.day.to_i      # => 86400  Note that this conversion makes some assumptions about the duration of some periods, e.g. months are always 1/12 of year and years are 365.2425 days:  # equivalent to (1.year / 12).to_i 1.month.to_i    # => 2629746  # equivalent to 365.2425.days.to_i 1.year.to_i     # => 31556952  In such cases, Ruby's core Date[https://docs.ruby-lang.org/en/master/Date.html] and Time[https://docs.ruby-lang.org/en/master/Time.html] should be used for precision date and time arithmetic.",
    "label": "",
    "id": "2795"
  },
  {
    "raw_code": "def in_minutes\n      in_seconds / SECONDS_PER_MINUTE.to_f\n    end",
    "comment": "Returns the amount of minutes a duration covers as a float  1.day.in_minutes # => 1440.0",
    "label": "",
    "id": "2796"
  },
  {
    "raw_code": "def in_hours\n      in_seconds / SECONDS_PER_HOUR.to_f\n    end",
    "comment": "Returns the amount of hours a duration covers as a float  1.day.in_hours # => 24.0",
    "label": "",
    "id": "2797"
  },
  {
    "raw_code": "def in_days\n      in_seconds / SECONDS_PER_DAY.to_f\n    end",
    "comment": "Returns the amount of days a duration covers as a float  12.hours.in_days # => 0.5",
    "label": "",
    "id": "2798"
  },
  {
    "raw_code": "def in_weeks\n      in_seconds / SECONDS_PER_WEEK.to_f\n    end",
    "comment": "Returns the amount of weeks a duration covers as a float  2.months.in_weeks # => 8.696",
    "label": "",
    "id": "2799"
  },
  {
    "raw_code": "def in_months\n      in_seconds / SECONDS_PER_MONTH.to_f\n    end",
    "comment": "Returns the amount of months a duration covers as a float  9.weeks.in_months # => 2.07",
    "label": "",
    "id": "2800"
  },
  {
    "raw_code": "def in_years\n      in_seconds / SECONDS_PER_YEAR.to_f\n    end",
    "comment": "Returns the amount of years a duration covers as a float  30.days.in_years # => 0.082",
    "label": "",
    "id": "2801"
  },
  {
    "raw_code": "def eql?(other)\n      Duration === other && other.value.eql?(value)\n    end",
    "comment": "Returns +true+ if +other+ is also a Duration instance, which has the same parts as this one.",
    "label": "",
    "id": "2802"
  },
  {
    "raw_code": "def since(time = ::Time.current)\n      sum(1, time)\n    end",
    "comment": "Calculates a new Time or Date that is as far in the future as this Duration represents.",
    "label": "",
    "id": "2803"
  },
  {
    "raw_code": "def ago(time = ::Time.current)\n      sum(-1, time)\n    end",
    "comment": "Calculates a new Time or Date that is as far in the past as this Duration represents.",
    "label": "",
    "id": "2804"
  },
  {
    "raw_code": "def iso8601(precision: nil)\n      ISO8601Serializer.new(self, precision: precision).serialize\n    end",
    "comment": "Build ISO 8601 Duration string for this duration. The +precision+ parameter can be used to limit seconds' precision of duration.",
    "label": "",
    "id": "2805"
  },
  {
    "raw_code": "def register(name, url_pattern, aliases: [])\n        editor = new(url_pattern)\n        @editors[name] = editor\n        aliases.each do |a|\n          @editors[a] = editor\n        end",
    "comment": "Registers a URL pattern for opening file in a given editor. This allows Rails to generate clickable links to control known editors.  Example:  ActiveSupport::Editor.register(\"myeditor\", \"myeditor://%s:%d\")",
    "label": "",
    "id": "2806"
  },
  {
    "raw_code": "def current\n        if @current == false\n          @current = if editor_name = ENV[\"RAILS_EDITOR\"] || ENV[\"EDITOR\"]\n            @editors[editor_name]\n          end",
    "comment": "Returns the current editor pattern if it is known. First check for the `RAILS_EDITOR` environment variable, and if it's missing, check for the `EDITOR` environment variable.",
    "label": "",
    "id": "2807"
  },
  {
    "raw_code": "def find(name)\n        @editors[name]\n      end",
    "comment": ":nodoc:",
    "label": "",
    "id": "2808"
  },
  {
    "raw_code": "def read\n      super\n    rescue ActiveSupport::EncryptedFile::MissingContentError\n      # Allow a config to be started without a file present\n      \"\"\n    end",
    "comment": "Reads the file and returns the decrypted content. See EncryptedFile#read.",
    "label": "",
    "id": "2809"
  },
  {
    "raw_code": "def config\n      @config ||= deep_symbolize_keys(deserialize(read))\n    end",
    "comment": "Returns the decrypted content as a Hash with symbolized keys.  my_config = ActiveSupport::EncryptedConfiguration.new(...) my_config.read # => \"some_secret: 123\\nsome_namespace:\\n  another_secret: 456\"  my_config.config # => { some_secret: 123, some_namespace: { another_secret: 789 } } ",
    "label": "",
    "id": "2810"
  },
  {
    "raw_code": "def key\n      read_env_key || read_key_file || handle_missing_key\n    end",
    "comment": "Returns the encryption key, first trying the environment variable specified by +env_key+, then trying the key file specified by +key_path+. If +raise_if_missing_key+ is true, raises MissingKeyError if the environment variable is not set and the key file does not exist.",
    "label": "",
    "id": "2811"
  },
  {
    "raw_code": "def key?\n      read_env_key || read_key_file\n    end",
    "comment": "Returns truthy if #key is truthy. Returns falsy otherwise. Unlike #key, does not raise MissingKeyError when +raise_if_missing_key+ is true.",
    "label": "",
    "id": "2812"
  },
  {
    "raw_code": "def read\n      if !key.nil? && content_path.exist?\n        decrypt content_path.binread.strip\n      else\n        raise MissingContentError, content_path\n      end",
    "comment": "Reads the file and returns the decrypted content.  Raises: - MissingKeyError if the key is missing and +raise_if_missing_key+ is true. - MissingContentError if the encrypted file does not exist or otherwise if the key is missing. - ActiveSupport::MessageEncryptor::InvalidMessage if the content cannot be decrypted or verified.",
    "label": "",
    "id": "2813"
  },
  {
    "raw_code": "def local?\n      @local\n    end",
    "comment": "Returns true if we're in the development or test environment.",
    "label": "",
    "id": "2814"
  },
  {
    "raw_code": "def handle(*error_classes, severity: :warning, context: {}, fallback: nil, source: DEFAULT_SOURCE)\n      error_classes = DEFAULT_RESCUE if error_classes.empty?\n      yield\n    rescue *error_classes => error\n      report(error, handled: true, severity: severity, context: context, source: source)\n      fallback.call if fallback\n    end",
    "comment": "Evaluates the given block, reporting and swallowing any unhandled error. If no error is raised, returns the return value of the block. Otherwise, returns the result of +fallback.call+, or +nil+ if +fallback+ is not specified.  # Will report a TypeError to all subscribers and return nil. Rails.error.handle do 1 + '1' end  Can be restricted to handle only specific error classes:  maybe_tags = Rails.error.handle(Redis::BaseError) { redis.get(\"tags\") }  ==== Options  * +:severity+ - This value is passed along to subscribers to indicate how important the error report is. Can be +:error+, +:warning+, or +:info+. Defaults to +:warning+.  * +:context+ - Extra information that is passed along to subscribers. For example:  Rails.error.handle(context: { section: \"admin\" }) do # ... end  * +:fallback+ - A callable that provides +handle+'s return value when an unhandled error is raised. For example:  user = Rails.error.handle(fallback: -> { User.anonymous }) do User.find_by(params) end  * +:source+ - This value is passed along to subscribers to indicate the source of the error. Subscribers can use this value to ignore certain errors. Defaults to <tt>\"application\"</tt>.",
    "label": "",
    "id": "2815"
  },
  {
    "raw_code": "def record(*error_classes, severity: :error, context: {}, source: DEFAULT_SOURCE)\n      error_classes = DEFAULT_RESCUE if error_classes.empty?\n      yield\n    rescue *error_classes => error\n      report(error, handled: false, severity: severity, context: context, source: source)\n      raise\n    end",
    "comment": "Evaluates the given block, reporting and re-raising any unhandled error. If no error is raised, returns the return value of the block.  # Will report a TypeError to all subscribers and re-raise it. Rails.error.record do 1 + '1' end  Can be restricted to handle only specific error classes:  tags = Rails.error.record(Redis::BaseError) { redis.get(\"tags\") }  ==== Options  * +:severity+ - This value is passed along to subscribers to indicate how important the error report is. Can be +:error+, +:warning+, or +:info+. Defaults to +:error+.  * +:context+ - Extra information that is passed along to subscribers. For example:  Rails.error.record(context: { section: \"admin\" }) do # ... end  * +:source+ - This value is passed along to subscribers to indicate the source of the error. Subscribers can use this value to ignore certain errors. Defaults to <tt>\"application\"</tt>.",
    "label": "",
    "id": "2816"
  },
  {
    "raw_code": "def unexpected(error, severity: :warning, context: {}, source: DEFAULT_SOURCE)\n      error = RuntimeError.new(error) if error.is_a?(String)\n\n      if @debug_mode\n        ensure_backtrace(error)\n        raise UnexpectedError, \"#{error.class.name}: #{error.message}\", error.backtrace, cause: error\n      else\n        report(error, handled: true, severity: severity, context: context, source: source)\n      end",
    "comment": "Either report the given error when in production, or raise it when in development or test.  When called in production, after the error is reported, this method will return nil and execution will continue.  When called in development, the original error is wrapped in a different error class to ensure it's not being rescued higher in the stack and will be surfaced to the developer.  This method is intended for reporting violated assertions about preconditions, or similar cases that can and should be gracefully handled in production, but that aren't supposed to happen.  The error can be either an exception instance or a String.  example:  def edit if published? Rails.error.unexpected(\"[BUG] Attempting to edit a published article, that shouldn't be possible\") return false end # ... end ",
    "label": "",
    "id": "2817"
  },
  {
    "raw_code": "def subscribe(subscriber)\n      unless subscriber.respond_to?(:report)\n        raise ArgumentError, \"Error subscribers must respond to #report\"\n      end",
    "comment": "Register a new error subscriber. The subscriber must respond to  report(Exception, handled: Boolean, severity: (:error OR :warning OR :info), context: Hash, source: String)  The +report+ method <b>should never</b> raise an error.",
    "label": "",
    "id": "2818"
  },
  {
    "raw_code": "def unsubscribe(subscriber)\n      @subscribers.delete_if { |s| subscriber === s }\n    end",
    "comment": "Unregister an error subscriber. Accepts either a subscriber or a class.  subscriber = MyErrorSubscriber.new Rails.error.subscribe(subscriber)  Rails.error.unsubscribe(subscriber) # or Rails.error.unsubscribe(MyErrorSubscriber)",
    "label": "",
    "id": "2819"
  },
  {
    "raw_code": "def disable(subscriber)\n      disabled_subscribers = (ActiveSupport::IsolatedExecutionState[self] ||= [])\n      disabled_subscribers << subscriber\n      begin\n        yield\n      ensure\n        disabled_subscribers.delete(subscriber)\n      end",
    "comment": "Prevent a subscriber from being notified of errors for the duration of the block. You may pass in the subscriber itself, or its class.  This can be helpful for error reporting service integrations, when they wish to handle any errors higher in the stack.",
    "label": "",
    "id": "2820"
  },
  {
    "raw_code": "def set_context(...)\n      ActiveSupport::ExecutionContext.set(...)\n    end",
    "comment": "Update the execution context that is accessible to error subscribers. Any context passed to #handle, #record, or #report will be merged with the context set here.  Rails.error.set_context(section: \"checkout\", user_id: @user.id) ",
    "label": "",
    "id": "2821"
  },
  {
    "raw_code": "def add_middleware(middleware)\n      @context_middlewares.use(middleware)\n    end",
    "comment": "Add a middleware to modify the error context before it is sent to subscribers.  Middleware is added to a stack of callables run on an error's execution context before passing to subscribers. Allows creation of entries in error context that are shared by all subscribers.  A context middleware receives the same parameters as #report. It must return a hash - the middleware stack returns the hash after it has run through all middlewares. A middleware can mutate or replace the hash.  Rails.error.add_middleware(-> (error, context) { context.merge({ foo: :bar }) }) ",
    "label": "",
    "id": "2822"
  },
  {
    "raw_code": "def report(error, handled: true, severity: handled ? :warning : :error, context: {}, source: DEFAULT_SOURCE)\n      return if error.instance_variable_defined?(:@__rails_error_reported)\n      raise ArgumentError, \"Reported error must be an Exception, got: #{error.inspect}\" unless error.is_a?(Exception)\n\n      ensure_backtrace(error)\n\n      unless SEVERITIES.include?(severity)\n        raise ArgumentError, \"severity must be one of #{SEVERITIES.map(&:inspect).join(\", \")}, got: #{severity.inspect}\"\n      end",
    "comment": "Report an error directly to subscribers. You can use this method when the block-based #handle and #record methods are not suitable.  Rails.error.report(error)  The +error+ argument must be an instance of Exception.  Rails.error.report(Exception.new(\"Something went wrong\"))  Otherwise you can use #unexpected to report an error which does accept a string argument.",
    "label": "",
    "id": "2823"
  },
  {
    "raw_code": "def use(middleware)\n          unless middleware.respond_to?(:call)\n            raise ArgumentError, \"Error context middleware must respond to #call\"\n          end",
    "comment": "Add a middleware to the error context stack.",
    "label": "",
    "id": "2824"
  },
  {
    "raw_code": "def execute(error, handled:, severity:, context:, source:)\n          @stack.inject(context) { |c, middleware| middleware.call(error, context: c, handled:, severity:, source:) }\n        end",
    "comment": "Run all middlewares in the stack",
    "label": "",
    "id": "2825"
  },
  {
    "raw_code": "def subscribe(subscriber, &filter)\n      unless subscriber.respond_to?(:emit)\n        raise ArgumentError, \"Event subscriber #{subscriber.class.name} must respond to #emit\"\n      end",
    "comment": "Registers a new event subscriber. The subscriber must respond to  emit(event: Hash)  The event hash will have the following keys:  name: String (The name of the event) payload: Hash, Object (The payload of the event, or the event object itself) tags: Hash (The tags of the event) context: Hash (The context of the event) timestamp: Float (The timestamp of the event, in nanoseconds) source_location: Hash (The source location of the event, containing the filepath, lineno, and label)  An optional filter proc can be provided to only receive a subset of events:  Rails.event.subscribe(subscriber) { |event| event[:name].start_with?(\"user.\") } Rails.event.subscribe(subscriber) { |event| event[:payload].is_a?(UserEvent) } ",
    "label": "",
    "id": "2826"
  },
  {
    "raw_code": "def unsubscribe(subscriber)\n      @subscribers.delete_if { |s| subscriber === s[:subscriber] }\n    end",
    "comment": "Unregister an event subscriber. Accepts either a subscriber or a class.  subscriber = MyEventSubscriber.new Rails.event.subscribe(subscriber)  Rails.event.unsubscribe(subscriber) # or Rails.event.unsubscribe(MyEventSubscriber)",
    "label": "",
    "id": "2827"
  },
  {
    "raw_code": "def notify(name_or_object, payload = nil, caller_depth: 1, **kwargs)\n      name = resolve_name(name_or_object)\n      payload = resolve_payload(name_or_object, payload, **kwargs)\n\n      event = {\n        name: name,\n        payload: payload,\n        tags: TagStack.tags,\n        context: context_store.context,\n        timestamp: Process.clock_gettime(Process::CLOCK_REALTIME, :nanosecond),\n      }\n\n      caller_location = caller_locations(caller_depth, 1)&.first\n\n      if caller_location\n        source_location = {\n          filepath: caller_location.path,\n          lineno: caller_location.lineno,\n          label: caller_location.label,\n        }\n        event[:source_location] = source_location\n      end",
    "comment": "Reports an event to all registered subscribers. An event name and payload can be provided:  Rails.event.notify(\"user.created\", { id: 123 }) # Emits event: #  { #    name: \"user.created\", #    payload: { id: 123 }, #    tags: {}, #    context: {}, #    timestamp: 1738964843208679035, #    source_location: { filepath: \"path/to/file.rb\", lineno: 123, label: \"UserService#create\" } #  }  Alternatively, an event object can be provided:  Rails.event.notify(UserCreatedEvent.new(id: 123)) # Emits event: #  { #    name: \"UserCreatedEvent\", #    payload: #<UserCreatedEvent:0x111>, #    tags: {}, #    context: {}, #    timestamp: 1738964843208679035, #    source_location: { filepath: \"path/to/file.rb\", lineno: 123, label: \"UserService#create\" } #  }  ==== Arguments  * +:payload+ - The event payload when using string/symbol event names.  * +:caller_depth+ - The stack depth to use for source location (default: 1).  * +:kwargs+ - Additional payload data when using string/symbol event names.",
    "label": "",
    "id": "2828"
  },
  {
    "raw_code": "def with_debug\n      prior = Fiber[:event_reporter_debug_mode]\n      Fiber[:event_reporter_debug_mode] = true\n      yield\n    ensure\n      Fiber[:event_reporter_debug_mode] = prior\n    end",
    "comment": "Temporarily enables debug mode for the duration of the block. Calls to +debug+ will only be reported if debug mode is enabled.  Rails.event.with_debug do Rails.event.debug(\"sql.query\", { sql: \"SELECT * FROM users\" }) end",
    "label": "",
    "id": "2829"
  },
  {
    "raw_code": "def debug_mode?\n      @debug_mode || Fiber[:event_reporter_debug_mode]\n    end",
    "comment": "Check if debug mode is currently enabled. Debug mode is enabled on the reporter via +with_debug+, and in local environments.",
    "label": "",
    "id": "2830"
  },
  {
    "raw_code": "def debug(name_or_object, payload = nil, caller_depth: 1, **kwargs)\n      if debug_mode?\n        if block_given?\n          notify(name_or_object, payload, caller_depth: caller_depth + 1, **kwargs.merge(yield))\n        else\n          notify(name_or_object, payload, caller_depth: caller_depth + 1, **kwargs)\n        end",
    "comment": "Report an event only when in debug mode. For example:  Rails.event.debug(\"sql.query\", { sql: \"SELECT * FROM users\" })  ==== Arguments  * +:payload+ - The event payload when using string/symbol event names.  * +:caller_depth+ - The stack depth to use for source location (default: 1).  * +:kwargs+ - Additional payload data when using string/symbol event names.",
    "label": "",
    "id": "2831"
  },
  {
    "raw_code": "def tagged(*args, **kwargs, &block)\n      TagStack.with_tags(*args, **kwargs, &block)\n    end",
    "comment": "Add tags to events to supply additional context. Tags operate in a stack-oriented manner, so all events emitted within the block inherit the same set of tags. For example:  Rails.event.tagged(\"graphql\") do Rails.event.notify(\"user.created\", { id: 123 }) end  # Emits event: # { #    name: \"user.created\", #    payload: { id: 123 }, #    tags: { graphql: true }, #    context: {}, #    timestamp: 1738964843208679035, #    source_location: { filepath: \"path/to/file.rb\", lineno: 123, label: \"UserService#create\" } #  }  Tags can be provided as arguments or as keyword arguments, and can be nested:  Rails.event.tagged(\"graphql\") do # Other code here... Rails.event.tagged(section: \"admin\") do Rails.event.notify(\"user.created\", { id: 123 }) end end  # Emits event: #  { #    name: \"user.created\", #    payload: { id: 123 }, #    tags: { section: \"admin\", graphql: true }, #    context: {}, #    timestamp: 1738964843208679035, #    source_location: { filepath: \"path/to/file.rb\", lineno: 123, label: \"UserService#create\" } #  }  The +tagged+ API can also receive a tag object:  graphql_tag = GraphqlTag.new(operation_name: \"user_created\", operation_type: \"mutation\") Rails.event.tagged(graphql_tag) do Rails.event.notify(\"user.created\", { id: 123 }) end  # Emits event: #  { #    name: \"user.created\", #    payload: { id: 123 }, #    tags: { \"GraphqlTag\": #<GraphqlTag:0x111> }, #    context: {}, #    timestamp: 1738964843208679035, #    source_location: { filepath: \"path/to/file.rb\", lineno: 123, label: \"UserService#create\" } #  }",
    "label": "",
    "id": "2832"
  },
  {
    "raw_code": "def set_context(context)\n      context_store.set_context(context)\n    end",
    "comment": "Sets context data that will be included with all events emitted by the reporter. Context data should be scoped to the job or request, and is reset automatically before and after each request and job.  Rails.event.set_context(user_agent: \"TestAgent\") Rails.event.set_context(job_id: \"abc123\") Rails.event.tagged(\"graphql\") do Rails.event.notify(\"user_created\", { id: 123 }) end  # Emits event: #  { #    name: \"user_created\", #    payload: { id: 123 }, #    tags: { graphql: true }, #    context: { user_agent: \"TestAgent\", job_id: \"abc123\" }, #    timestamp: 1738964843208679035 #    source_location: { filepath: \"path/to/file.rb\", lineno: 123, label: \"UserService#create\" } #  }",
    "label": "",
    "id": "2833"
  },
  {
    "raw_code": "def clear_context\n      context_store.clear\n    end",
    "comment": "Clears all context data.",
    "label": "",
    "id": "2834"
  },
  {
    "raw_code": "def context\n      context_store.context\n    end",
    "comment": "Returns the current context data.",
    "label": "",
    "id": "2835"
  },
  {
    "raw_code": "def set(**options)\n        options.symbolize_keys!\n        keys = options.keys\n\n        store = record.store\n\n        previous_context = if block_given?\n          keys.zip(store.values_at(*keys)).to_h\n        end",
    "comment": "Updates the execution context. If a block is given, it resets the provided keys to their previous value once the block exits.",
    "label": "",
    "id": "2836"
  },
  {
    "raw_code": "def self.register_hook(hook, outer: false)\n      if outer\n        to_run RunHook.new(hook), prepend: true\n        to_complete :after, CompleteHook.new(hook)\n      else\n        to_run RunHook.new(hook)\n        to_complete CompleteHook.new(hook)\n      end",
    "comment": "Register an object to be invoked during both the +run+ and +complete+ steps.  +hook.complete+ will be passed the value returned from +hook.run+, and will only be invoked if +run+ has previously been called. (Mostly, this means it won't be invoked if an exception occurs in a preceding +to_run+ block; all ordinary +to_complete+ blocks are invoked in that situation.)",
    "label": "",
    "id": "2837"
  },
  {
    "raw_code": "def self.run!(reset: false)\n      if reset\n        lost_instance = IsolatedExecutionState.delete(active_key)\n        lost_instance&.complete!\n      else\n        return Null if active?\n      end",
    "comment": "Run this execution.  Returns an instance, whose +complete!+ method *must* be invoked after the work has been performed.  Where possible, prefer +wrap+.",
    "label": "",
    "id": "2838"
  },
  {
    "raw_code": "def self.wrap(source: \"application.active_support\")\n      return yield if active?\n\n      instance = run!\n      begin\n        yield\n      rescue Exception => error\n        error_reporter&.report(error, handled: false, source: source)\n        raise\n      ensure\n        instance.complete!\n      end",
    "comment": "Perform the work in the supplied block as an execution.",
    "label": "",
    "id": "2839"
  },
  {
    "raw_code": "def complete!\n      complete\n    ensure\n      IsolatedExecutionState.delete(self.class.active_key)\n    end",
    "comment": "Complete this in-flight execution. This method *must* be called exactly once on the result of any call to +run!+.  Where possible, prefer +wrap+.",
    "label": "",
    "id": "2840"
  },
  {
    "raw_code": "def initialize(files, dirs = {}, &block)\n      unless block\n        raise ArgumentError, \"A block is required to initialize a FileUpdateChecker\"\n      end",
    "comment": "It accepts two parameters on initialization. The first is an array of files and the second is an optional hash of directories. The hash must have directories as keys and the value is an array of extensions to be watched under that directory.  This method must also receive a block that will be called once a path changes. The array of files and list of directories cannot be changed after FileUpdateChecker has been initialized.",
    "label": "",
    "id": "2841"
  },
  {
    "raw_code": "def updated?\n      current_watched = watched\n      if @last_watched.size != current_watched.size\n        @watched = current_watched\n        true\n      else\n        current_updated_at = updated_at(current_watched)\n        if @last_update_at < current_updated_at\n          @watched    = current_watched\n          @updated_at = current_updated_at\n          true\n        else\n          false\n        end",
    "comment": "Check if any of the entries were updated. If so, the watched and/or updated_at values are cached until the block is executed via +execute+ or +execute_if_updated+.",
    "label": "",
    "id": "2842"
  },
  {
    "raw_code": "def execute\n      @last_watched   = watched\n      @last_update_at = updated_at(@last_watched)\n      @block.call\n    ensure\n      @watched = nil\n      @updated_at = nil\n    end",
    "comment": "Executes the given block and updates the latest watched files and timestamp.",
    "label": "",
    "id": "2843"
  },
  {
    "raw_code": "def execute_if_updated\n      if updated?\n        yield if block_given?\n        execute\n        true\n      else\n        false\n      end",
    "comment": "Execute the block given if updated.",
    "label": "",
    "id": "2844"
  },
  {
    "raw_code": "def max_mtime(paths)\n        time_now = Time.at(0, Process.clock_gettime(Process::CLOCK_REALTIME, :nanosecond), :nanosecond)\n        max_mtime = nil\n\n        # Time comparisons are performed with #compare_without_coercion because\n        # AS redefines these operators in a way that is much slower and does not\n        # bring any benefit in this particular code.\n        #\n        # Read t1.compare_without_coercion(t2) < 0 as t1 < t2.\n        paths.each do |path|\n          mtime = File.mtime(path)\n\n          next if time_now.compare_without_coercion(mtime) < 0\n\n          if max_mtime.nil? || max_mtime.compare_without_coercion(mtime) < 0\n            max_mtime = mtime\n          end",
    "comment": "This method returns the maximum mtime of the files in +paths+, or +nil+ if the array is empty.  Files with a mtime in the future are ignored. Such abnormal situation can happen for example if the user changes the clock by hand. It is healthy to consider this edge case because with mtimes in the future reloading is not triggered.",
    "label": "",
    "id": "2845"
  },
  {
    "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of Active Support as a +Gem::Version+.",
    "label": "",
    "id": "2846"
  },
  {
    "raw_code": "def self.decompress(source)\n      Zlib::GzipReader.wrap(StringIO.new(source), &:read)\n    end",
    "comment": "Decompresses a gzipped string.",
    "label": "",
    "id": "2847"
  },
  {
    "raw_code": "def self.compress(source, level = Zlib::DEFAULT_COMPRESSION, strategy = Zlib::DEFAULT_STRATEGY)\n      output = Stream.new\n      gz = Zlib::GzipWriter.new(output, level, strategy)\n      gz.mtime = 0\n      gz.write(source)\n      gz.close\n      output.string\n    end",
    "comment": "Compresses a string using gzip.",
    "label": "",
    "id": "2848"
  },
  {
    "raw_code": "def extractable_options?\n      true\n    end",
    "comment": "Returns +true+ so that <tt>Array#extract_options!</tt> finds members of this class.",
    "label": "",
    "id": "2849"
  },
  {
    "raw_code": "def []=(key, value)\n      regular_writer(convert_key(key), convert_value(value, conversion: :assignment))\n    end",
    "comment": "Assigns a new value to the hash:  hash = ActiveSupport::HashWithIndifferentAccess.new hash[:key] = 'value'  This value can be later fetched using either +:key+ or <tt>'key'</tt>.  If the value is a Hash or contains one or multiple Hashes, they will be converted to +HashWithIndifferentAccess+.",
    "label": "",
    "id": "2850"
  },
  {
    "raw_code": "def store(key, value, convert_value: true)\n      value = convert_value(value, conversion: :assignment) if convert_value\n      regular_writer(convert_key(key), value)\n    end",
    "comment": "Assigns a new value to the hash:  hash = ActiveSupport::HashWithIndifferentAccess.new hash[:key] = 'value'  This value can be later fetched using either +:key+ or <tt>'key'</tt>.  If the value is a Hash or contains one or multiple Hashes, they will be converted to +HashWithIndifferentAccess+. unless `convert_value: false` is set.",
    "label": "",
    "id": "2851"
  },
  {
    "raw_code": "def update(*other_hashes, &block)\n      if other_hashes.size == 1\n        update_with_single_argument(other_hashes.first, block)\n      else\n        other_hashes.each do |other_hash|\n          update_with_single_argument(other_hash, block)\n        end",
    "comment": "Updates the receiver in-place, merging in the hashes passed as arguments:  hash_1 = ActiveSupport::HashWithIndifferentAccess.new hash_1[:key] = 'value'  hash_2 = ActiveSupport::HashWithIndifferentAccess.new hash_2[:key] = 'New Value!'  hash_1.update(hash_2) # => {\"key\"=>\"New Value!\"}  hash = ActiveSupport::HashWithIndifferentAccess.new hash.update({ \"a\" => 1 }, { \"b\" => 2 }) # => { \"a\" => 1, \"b\" => 2 }  The arguments can be either an +ActiveSupport::HashWithIndifferentAccess+ or a regular +Hash+. In either case the merge respects the semantics of indifferent access.  If the argument is a regular hash with keys +:key+ and <tt>\"key\"</tt> only one of the values end up in the receiver, but which one is unspecified.  When given a block, the value for duplicated keys will be determined by the result of invoking the block with the duplicated key, the value in the receiver, and the value in +other_hash+. The rules for duplicated keys follow the semantics of indifferent access:  hash_1[:key] = 10 hash_2['key'] = 12 hash_1.update(hash_2) { |key, old, new| old + new } # => {\"key\"=>22}",
    "label": "",
    "id": "2852"
  },
  {
    "raw_code": "def key?(key)\n      super(convert_key(key))\n    end",
    "comment": "Checks the hash for a key matching the argument passed in:  hash = ActiveSupport::HashWithIndifferentAccess.new hash['key'] = 'value' hash.key?(:key)  # => true hash.key?('key') # => true",
    "label": "",
    "id": "2853"
  },
  {
    "raw_code": "def [](key)\n      super(convert_key(key))\n    end",
    "comment": "Same as <tt>Hash#[]</tt> where the key passed as argument can be either a string or a symbol:  counters = ActiveSupport::HashWithIndifferentAccess.new counters[:foo] = 1  counters['foo'] # => 1 counters[:foo]  # => 1 counters[:zoo]  # => nil",
    "label": "",
    "id": "2854"
  },
  {
    "raw_code": "def assoc(key)\n      super(convert_key(key))\n    end",
    "comment": "Same as <tt>Hash#assoc</tt> where the key passed as argument can be either a string or a symbol:  counters = ActiveSupport::HashWithIndifferentAccess.new counters[:foo] = 1  counters.assoc('foo') # => [\"foo\", 1] counters.assoc(:foo)  # => [\"foo\", 1] counters.assoc(:zoo)  # => nil",
    "label": "",
    "id": "2855"
  },
  {
    "raw_code": "def fetch(key, *extras)\n      super(convert_key(key), *extras)\n    end",
    "comment": "Same as <tt>Hash#fetch</tt> where the key passed as argument can be either a string or a symbol:  counters = ActiveSupport::HashWithIndifferentAccess.new counters[:foo] = 1  counters.fetch('foo')          # => 1 counters.fetch(:bar, 0)        # => 0 counters.fetch(:bar) { |key| 0 } # => 0 counters.fetch(:zoo)           # => KeyError: key not found: \"zoo\"",
    "label": "",
    "id": "2856"
  },
  {
    "raw_code": "def dig(*args)\n      args[0] = convert_key(args[0]) if args.size > 0\n      super(*args)\n    end",
    "comment": "Same as <tt>Hash#dig</tt> where the key passed as argument can be either a string or a symbol:  counters = ActiveSupport::HashWithIndifferentAccess.new counters[:foo] = { bar: 1 }  counters.dig('foo', 'bar')     # => 1 counters.dig(:foo, :bar)       # => 1 counters.dig(:zoo)             # => nil",
    "label": "",
    "id": "2857"
  },
  {
    "raw_code": "def default(key = (no_key = true))\n      if no_key\n        super()\n      else\n        super(convert_key(key))\n      end",
    "comment": "Same as <tt>Hash#default</tt> where the key passed as argument can be either a string or a symbol:  hash = ActiveSupport::HashWithIndifferentAccess.new(1) hash.default                   # => 1  hash = ActiveSupport::HashWithIndifferentAccess.new { |hash, key| key } hash.default                   # => nil hash.default('foo')            # => 'foo' hash.default(:foo)             # => 'foo'",
    "label": "",
    "id": "2858"
  },
  {
    "raw_code": "def values_at(*keys)\n      keys.map! { |key| convert_key(key) }\n      super\n    end",
    "comment": "Returns an array of the values at the specified indices:  hash = ActiveSupport::HashWithIndifferentAccess.new hash[:a] = 'x' hash[:b] = 'y' hash.values_at('a', 'b') # => [\"x\", \"y\"]",
    "label": "",
    "id": "2859"
  },
  {
    "raw_code": "def fetch_values(*indices, &block)\n      indices.map! { |key| convert_key(key) }\n      super\n    end",
    "comment": "Returns an array of the values at the specified indices, but also raises an exception when one of the keys can't be found.  hash = ActiveSupport::HashWithIndifferentAccess.new hash[:a] = 'x' hash[:b] = 'y' hash.fetch_values('a', 'b') # => [\"x\", \"y\"] hash.fetch_values('a', 'c') { |key| 'z' } # => [\"x\", \"z\"] hash.fetch_values('a', 'c') # => KeyError: key not found: \"c\"",
    "label": "",
    "id": "2860"
  },
  {
    "raw_code": "def dup\n      copy_defaults(self.class.new(self))\n    end",
    "comment": "Returns a shallow copy of the hash.  hash = ActiveSupport::HashWithIndifferentAccess.new({ a: { b: 'b' } }) dup  = hash.dup dup[:a][:c] = 'c'  hash[:a][:c] # => \"c\" dup[:a][:c]  # => \"c\"",
    "label": "",
    "id": "2861"
  },
  {
    "raw_code": "def merge(*hashes, &block)\n      dup.update(*hashes, &block)\n    end",
    "comment": "This method has the same semantics of +update+, except it does not modify the receiver but rather returns a new hash with indifferent access with the result of the merge.",
    "label": "",
    "id": "2862"
  },
  {
    "raw_code": "def reverse_merge(other_hash)\n      super(cast(other_hash))\n    end",
    "comment": "Like +merge+ but the other way around: Merges the receiver into the argument and returns a new hash with indifferent access as result:  hash = ActiveSupport::HashWithIndifferentAccess.new hash['a'] = nil hash.reverse_merge(a: 0, b: 1) # => {\"a\"=>nil, \"b\"=>1}",
    "label": "",
    "id": "2863"
  },
  {
    "raw_code": "def reverse_merge!(other_hash)\n      super(cast(other_hash))\n    end",
    "comment": "Same semantics as +reverse_merge+ but modifies the receiver in-place.",
    "label": "",
    "id": "2864"
  },
  {
    "raw_code": "def replace(other_hash)\n      super(cast(other_hash))\n    end",
    "comment": "Replaces the contents of this hash with other_hash.  h = { \"a\" => 100, \"b\" => 200 } h.replace({ \"c\" => 300, \"d\" => 400 }) # => {\"c\"=>300, \"d\"=>400}",
    "label": "",
    "id": "2865"
  },
  {
    "raw_code": "def delete(key)\n      super(convert_key(key))\n    end",
    "comment": "Removes the specified key from the hash.",
    "label": "",
    "id": "2866"
  },
  {
    "raw_code": "def except(*keys)\n      dup.except!(*keys)\n    end",
    "comment": "Returns a hash with indifferent access that includes everything except given keys. hash = { a: \"x\", b: \"y\", c: 10 }.with_indifferent_access hash.except(:a, \"b\") # => {c: 10}.with_indifferent_access hash                 # => { a: \"x\", b: \"y\", c: 10 }.with_indifferent_access",
    "label": "",
    "id": "2867"
  },
  {
    "raw_code": "def to_hash\n      copy = Hash[self]\n      copy.transform_values! { |v| convert_value_to_hash(v) }\n      copy_defaults(copy)\n    end",
    "comment": "Convert to a regular hash with string keys.",
    "label": "",
    "id": "2868"
  },
  {
    "raw_code": "def self.initialize_i18n(app)\n      return if @i18n_inited\n\n      fallbacks = app.config.i18n.delete(:fallbacks)\n\n      # Avoid issues with setting the default_locale by disabling available locales\n      # check while configuring.\n      enforce_available_locales = app.config.i18n.delete(:enforce_available_locales)\n      enforce_available_locales = I18n.enforce_available_locales if enforce_available_locales.nil?\n      I18n.enforce_available_locales = false\n\n      reloadable_paths = []\n      app.config.i18n.each do |setting, value|\n        case setting\n        when :railties_load_path\n          reloadable_paths = value\n          app.config.i18n.load_path.unshift(*value.flat_map(&:existent))\n        when :load_path\n          I18n.load_path += value\n        when :raise_on_missing_translations\n          strict = value == :strict\n          setup_raise_on_missing_translations_config(app, strict)\n        else\n          I18n.public_send(\"#{setting}=\", value)\n        end",
    "comment": "Setup i18n configuration.",
    "label": "",
    "id": "2869"
  },
  {
    "raw_code": "def generate_key(salt, key_size = 64)\n      OpenSSL::PKCS5.pbkdf2_hmac(@secret, salt, @iterations, key_size, @hash_digest_class.new)\n    end",
    "comment": "Returns a derived key suitable for use.  The default +key_size+ is chosen to be compatible with the default settings of ActiveSupport::MessageVerifier. i.e. <tt>OpenSSL::Digest::SHA1#block_length</tt>",
    "label": "",
    "id": "2870"
  },
  {
    "raw_code": "def generate_key(*args)\n      @cache_keys[args.join(\"|\")] ||= @key_generator.generate_key(*args)\n    end",
    "comment": "Returns a derived key suitable for use.",
    "label": "",
    "id": "2871"
  },
  {
    "raw_code": "def on_load(name, options = {}, &block)\n      @loaded[name].each do |base|\n        execute_hook(name, base, options, block)\n      end",
    "comment": "Declares a block that will be executed when a \\Rails component is fully loaded. If the component has already loaded, the block is executed immediately.  ==== Options  * <tt>:yield</tt> - Yields the object that run_load_hooks to +block+. * <tt>:run_once</tt> - Given +block+ will run only once.",
    "label": "",
    "id": "2872"
  },
  {
    "raw_code": "def run_load_hooks(name, base = Object)\n      @loaded[name] << base\n      @load_hooks[name].each do |hook, options|\n        execute_hook(name, base, options, hook)\n      end",
    "comment": "Executes all blocks registered to +name+ via on_load, using +base+ as the evaluation context.  ActiveSupport.run_load_hooks(:active_record, ActiveRecord::Base)  In the case of the above example, it will execute all hooks registered for +:active_record+ within the class +ActiveRecord::Base+.",
    "label": "",
    "id": "2873"
  },
  {
    "raw_code": "def self.logger_outputs_to?(logger, *sources)\n      loggers = if logger.is_a?(BroadcastLogger)\n        logger.broadcasts\n      else\n        [logger]\n      end",
    "comment": "Returns true if the logger destination matches one of the sources  logger = Logger.new(STDOUT) ActiveSupport::Logger.logger_outputs_to?(logger, STDOUT) # => true  logger = Logger.new('/var/log/rails.log') ActiveSupport::Logger.logger_outputs_to?(logger, '/var/log/rails.log') # => true",
    "label": "",
    "id": "2874"
  },
  {
    "raw_code": "def call(severity, timestamp, progname, msg)\n        \"#{String === msg ? msg : msg.inspect}\\n\"\n      end",
    "comment": "This method is invoked when a log event occurs",
    "label": "",
    "id": "2875"
  },
  {
    "raw_code": "def silence(severity = Logger::ERROR)\n      silencer ? log_at(severity) { yield self } : yield(self)\n    end",
    "comment": "Silences the logger for the duration of the block.",
    "label": "",
    "id": "2876"
  },
  {
    "raw_code": "def log_at(level)\n      old_local_level, self.local_level = local_level, level\n      yield\n    ensure\n      self.local_level = old_local_level\n    end",
    "comment": "Change the thread-local level for the duration of the given block.",
    "label": "",
    "id": "2877"
  },
  {
    "raw_code": "def flush_all!\n        logger.flush if logger.respond_to?(:flush)\n      end",
    "comment": "Flush all log_subscribers' logger.",
    "label": "",
    "id": "2878"
  },
  {
    "raw_code": "def color(text, color, mode_options = {}) # :doc:\n      return text unless colorize_logging\n      color = self.class.const_get(color.upcase) if color.is_a?(Symbol)\n      mode = mode_from(mode_options)\n      clear = \"\\e[#{MODES[:clear]}m\"\n      \"#{mode}#{color}#{text}#{clear}\"\n    end",
    "comment": "Set color by using a symbol or one of the defined constants. Set modes by specifying bold, italic, or underline options. Inspired by Highline, this method will automatically clear formatting at the end of the returned String.",
    "label": "",
    "id": "2879"
  },
  {
    "raw_code": "def initialize(secret, sign_secret = nil, **options)\n      super(**options)\n      @secret = secret\n      @cipher = options[:cipher] || self.class.default_cipher\n      @aead_mode = new_cipher.authenticated?\n      @verifier = if !@aead_mode\n        MessageVerifier.new(sign_secret || secret, **options, serializer: NullSerializer)\n      end",
    "comment": "Initialize a new MessageEncryptor. +secret+ must be at least as long as the cipher key size. For the default 'aes-256-gcm' cipher, this is 256 bits. If you are using a user-entered secret, you can generate a suitable key by using ActiveSupport::KeyGenerator or a similar key derivation function.  The first additional parameter is used as the signature key for MessageVerifier. This allows you to specify keys to encrypt and sign data. Ignored when using an AEAD cipher like 'aes-256-gcm'.  ActiveSupport::MessageEncryptor.new('secret', 'signature_secret')  ==== Options  [+:cipher+] Cipher to use. Can be any cipher returned by +OpenSSL::Cipher.ciphers+. Default is 'aes-256-gcm'.  [+:digest+] Digest used for signing. Ignored when using an AEAD cipher like 'aes-256-gcm'.  [+:serializer+] The serializer used to serialize message data. You can specify any object that responds to +dump+ and +load+, or you can choose from several preconfigured serializers: +:marshal+, +:json_allow_marshal+, +:json+, +:message_pack_allow_marshal+, +:message_pack+.  The preconfigured serializers include a fallback mechanism to support multiple deserialization formats. For example, the +:marshal+ serializer will serialize using +Marshal+, but can deserialize using +Marshal+, ActiveSupport::JSON, or ActiveSupport::MessagePack. This makes it easy to migrate between serializers.  The +:marshal+, +:json_allow_marshal+, and +:message_pack_allow_marshal+ serializers support deserializing using +Marshal+, but the others do not. Beware that +Marshal+ is a potential vector for deserialization attacks in cases where a message signing secret has been leaked. <em>If possible, choose a serializer that does not support +Marshal+.</em>  The +:message_pack+ and +:message_pack_allow_marshal+ serializers use ActiveSupport::MessagePack, which can roundtrip some Ruby types that are not supported by JSON, and may provide improved performance. However, these require the +msgpack+ gem.  When using \\Rails, the default depends on +config.active_support.message_serializer+. Otherwise, the default is +:marshal+.  [+:url_safe+] By default, MessageEncryptor generates RFC 4648 compliant strings which are not URL-safe. In other words, they can contain \"+\" and \"/\". If you want to generate URL-safe strings (in compliance with \"Base 64 Encoding with URL and Filename Safe Alphabet\" in RFC 4648), you can pass +true+.  [+:force_legacy_metadata_serializer+] Whether to use the legacy metadata serializer, which serializes the message first, then wraps it in an envelope which is also serialized. This was the default in \\Rails 7.0 and below.  If you don't pass a truthy value, the default is set using +config.active_support.use_message_serializer_for_metadata+.",
    "label": "",
    "id": "2880"
  },
  {
    "raw_code": "def encrypt_and_sign(value, **options)\n      create_message(value, **options)\n    end",
    "comment": "Encrypt and sign a message. We need to sign the message in order to avoid padding attacks. Reference: https://www.limited-entropy.com/padding-oracle-attacks/.  ==== Options  [+:expires_at+] The datetime at which the message expires. After this datetime, verification of the message will fail.  message = encryptor.encrypt_and_sign(\"hello\", expires_at: Time.now.tomorrow) encryptor.decrypt_and_verify(message) # => \"hello\" # 24 hours later... encryptor.decrypt_and_verify(message) # => nil  [+:expires_in+] The duration for which the message is valid. After this duration has elapsed, verification of the message will fail.  message = encryptor.encrypt_and_sign(\"hello\", expires_in: 24.hours) encryptor.decrypt_and_verify(message) # => \"hello\" # 24 hours later... encryptor.decrypt_and_verify(message) # => nil  [+:purpose+] The purpose of the message. If specified, the same purpose must be specified when verifying the message; otherwise, verification will fail. (See #decrypt_and_verify.)",
    "label": "",
    "id": "2881"
  },
  {
    "raw_code": "def decrypt_and_verify(message, **options)\n      catch_and_raise :invalid_message_format, as: InvalidMessage do\n        catch_and_raise :invalid_message_serialization, as: InvalidMessage do\n          catch_and_ignore :invalid_message_content do\n            read_message(message, **options)\n          end",
    "comment": "Decrypt and verify a message. We need to verify the message in order to avoid padding attacks. Reference: https://www.limited-entropy.com/padding-oracle-attacks/.  ==== Options  [+:purpose+] The purpose that the message was generated with. If the purpose does not match, +decrypt_and_verify+ will return +nil+.  message = encryptor.encrypt_and_sign(\"hello\", purpose: \"greeting\") encryptor.decrypt_and_verify(message, purpose: \"greeting\") # => \"hello\" encryptor.decrypt_and_verify(message)                      # => nil  message = encryptor.encrypt_and_sign(\"bye\") encryptor.decrypt_and_verify(message)                      # => \"bye\" encryptor.decrypt_and_verify(message, purpose: \"greeting\") # => nil ",
    "label": "",
    "id": "2882"
  },
  {
    "raw_code": "def self.key_len(cipher = default_cipher)\n      OpenSSL::Cipher.new(cipher).key_len\n    end",
    "comment": "Given a cipher, returns the key length of the cipher to help generate the key of desired size",
    "label": "",
    "id": "2883"
  },
  {
    "raw_code": "def initialize(secret, **options)\n      raise ArgumentError, \"Secret should not be nil.\" unless secret\n      super(**options)\n      @secret = secret\n      @digest = options[:digest]&.to_s || \"SHA1\"\n    end",
    "comment": "Initialize a new MessageVerifier with a secret for the signature.  ==== Options  [+:digest+] Digest used for signing. The default is <tt>\"SHA1\"</tt>. See +OpenSSL::Digest+ for alternatives.  [+:serializer+] The serializer used to serialize message data. You can specify any object that responds to +dump+ and +load+, or you can choose from several preconfigured serializers: +:marshal+, +:json_allow_marshal+, +:json+, +:message_pack_allow_marshal+, +:message_pack+.  The preconfigured serializers include a fallback mechanism to support multiple deserialization formats. For example, the +:marshal+ serializer will serialize using +Marshal+, but can deserialize using +Marshal+, ActiveSupport::JSON, or ActiveSupport::MessagePack. This makes it easy to migrate between serializers.  The +:marshal+, +:json_allow_marshal+, and +:message_pack_allow_marshal+ serializers support deserializing using +Marshal+, but the others do not. Beware that +Marshal+ is a potential vector for deserialization attacks in cases where a message signing secret has been leaked. <em>If possible, choose a serializer that does not support +Marshal+.</em>  The +:message_pack+ and +:message_pack_allow_marshal+ serializers use ActiveSupport::MessagePack, which can roundtrip some Ruby types that are not supported by JSON, and may provide improved performance. However, these require the +msgpack+ gem.  When using \\Rails, the default depends on +config.active_support.message_serializer+. Otherwise, the default is +:marshal+.  [+:url_safe+] By default, MessageVerifier generates RFC 4648 compliant strings which are not URL-safe. In other words, they can contain \"+\" and \"/\". If you want to generate URL-safe strings (in compliance with \"Base 64 Encoding with URL and Filename Safe Alphabet\" in RFC 4648), you can pass +true+. Note that MessageVerifier will always accept both URL-safe and URL-unsafe encoded messages, to allow a smooth transition between the two settings.  [+:force_legacy_metadata_serializer+] Whether to use the legacy metadata serializer, which serializes the message first, then wraps it in an envelope which is also serialized. This was the default in \\Rails 7.0 and below.  If you don't pass a truthy value, the default is set using +config.active_support.use_message_serializer_for_metadata+.",
    "label": "",
    "id": "2884"
  },
  {
    "raw_code": "def valid_message?(message)\n      !!catch_and_ignore(:invalid_message_format) { extract_encoded(message) }\n    end",
    "comment": "Checks if a signed message could have been generated by signing an object with the +MessageVerifier+'s secret.  verifier = ActiveSupport::MessageVerifier.new(\"secret\") signed_message = verifier.generate(\"signed message\") verifier.valid_message?(signed_message) # => true  tampered_message = signed_message.chop # editing the message invalidates the signature verifier.valid_message?(tampered_message) # => false",
    "label": "",
    "id": "2885"
  },
  {
    "raw_code": "def verified(message, **options)\n      catch_and_ignore :invalid_message_format do\n        catch_and_raise :invalid_message_serialization do\n          catch_and_ignore :invalid_message_content do\n            read_message(message, **options)\n          end",
    "comment": "Decodes the signed message using the +MessageVerifier+'s secret.  verifier = ActiveSupport::MessageVerifier.new(\"secret\")  signed_message = verifier.generate(\"signed message\") verifier.verified(signed_message) # => \"signed message\"  Returns +nil+ if the message was not signed with the same secret.  other_verifier = ActiveSupport::MessageVerifier.new(\"different_secret\") other_verifier.verified(signed_message) # => nil  Returns +nil+ if the message is not Base64-encoded.  invalid_message = \"f--46a0120593880c733a53b6dad75b42ddc1c8996d\" verifier.verified(invalid_message) # => nil  Raises any error raised while decoding the signed message.  incompatible_message = \"test--dad7b06c94abba8d46a15fafaef56c327665d5ff\" verifier.verified(incompatible_message) # => TypeError: incompatible marshal file format  ==== Options  [+:purpose+] The purpose that the message was generated with. If the purpose does not match, +verified+ will return +nil+.  message = verifier.generate(\"hello\", purpose: \"greeting\") verifier.verified(message, purpose: \"greeting\") # => \"hello\" verifier.verified(message, purpose: \"chatting\") # => nil verifier.verified(message)                      # => nil  message = verifier.generate(\"bye\") verifier.verified(message)                      # => \"bye\" verifier.verified(message, purpose: \"greeting\") # => nil ",
    "label": "",
    "id": "2886"
  },
  {
    "raw_code": "def verify(message, **options)\n      catch_and_raise :invalid_message_format, as: InvalidSignature do\n        catch_and_raise :invalid_message_serialization do\n          catch_and_raise :invalid_message_content, as: InvalidSignature do\n            read_message(message, **options)\n          end",
    "comment": "Decodes the signed message using the +MessageVerifier+'s secret.  verifier = ActiveSupport::MessageVerifier.new(\"secret\") signed_message = verifier.generate(\"signed message\")  verifier.verify(signed_message) # => \"signed message\"  Raises +InvalidSignature+ if the message was not signed with the same secret or was not Base64-encoded.  other_verifier = ActiveSupport::MessageVerifier.new(\"different_secret\") other_verifier.verify(signed_message) # => ActiveSupport::MessageVerifier::InvalidSignature  ==== Options  [+:purpose+] The purpose that the message was generated with. If the purpose does not match, +verify+ will raise ActiveSupport::MessageVerifier::InvalidSignature.  message = verifier.generate(\"hello\", purpose: \"greeting\") verifier.verify(message, purpose: \"greeting\") # => \"hello\" verifier.verify(message, purpose: \"chatting\") # => raises InvalidSignature verifier.verify(message)                      # => raises InvalidSignature  message = verifier.generate(\"bye\") verifier.verify(message)                      # => \"bye\" verifier.verify(message, purpose: \"greeting\") # => raises InvalidSignature ",
    "label": "",
    "id": "2887"
  },
  {
    "raw_code": "def generate(value, **options)\n      create_message(value, **options)\n    end",
    "comment": "Generates a signed message for the provided value.  The message is signed with the +MessageVerifier+'s secret. Returns Base64-encoded message joined with the generated signature.  verifier = ActiveSupport::MessageVerifier.new(\"secret\") verifier.generate(\"signed message\") # => \"BAhJIhNzaWduZWQgbWVzc2FnZQY6BkVU--f67d5f27c3ee0b8483cebf2103757455e947493b\"  ==== Options  [+:expires_at+] The datetime at which the message expires. After this datetime, verification of the message will fail.  message = verifier.generate(\"hello\", expires_at: Time.now.tomorrow) verifier.verified(message) # => \"hello\" # 24 hours later... verifier.verified(message) # => nil verifier.verify(message)   # => raises ActiveSupport::MessageVerifier::InvalidSignature  [+:expires_in+] The duration for which the message is valid. After this duration has elapsed, verification of the message will fail.  message = verifier.generate(\"hello\", expires_in: 24.hours) verifier.verified(message) # => \"hello\" # 24 hours later... verifier.verified(message) # => nil verifier.verify(message)   # => raises ActiveSupport::MessageVerifier::InvalidSignature  [+:purpose+] The purpose of the message. If specified, the same purpose must be specified when verifying the message; otherwise, verification will fail. (See #verified and #verify.)",
    "label": "",
    "id": "2888"
  },
  {
    "raw_code": "def self.proxy_class=(klass)\n      ActiveSupport.deprecator.warn(\n        \"ActiveSupport::Multibyte.proxy_class= is deprecated and will be removed in Rails 8.2. \" \\\n        \"Use normal string methods instead.\"\n      )\n      @proxy_class = klass\n    end",
    "comment": "The proxy class returned when calling mb_chars. You can use this accessor to configure your own proxy class so you can support other encodings. See the ActiveSupport::Multibyte::Chars implementation for an example how to do this.  ActiveSupport::Multibyte.proxy_class = CharsForUTF32",
    "label": "",
    "id": "2889"
  },
  {
    "raw_code": "def self.proxy_class\n      @proxy_class ||= ActiveSupport::Multibyte::Chars\n    end",
    "comment": "Returns the current proxy class.",
    "label": "",
    "id": "2890"
  },
  {
    "raw_code": "def subscribe(pattern = nil, callback = nil, &block)\n        notifier.subscribe(pattern, callback, monotonic: false, &block)\n      end",
    "comment": "Subscribe to a given event name with the passed +block+.  You can subscribe to events by passing a String to match exact event names, or by passing a Regexp to match all events that match a pattern.  If the block passed to the method only takes one argument, it will yield an +Event+ object to the block:  ActiveSupport::Notifications.subscribe(/render/) do |event| @event = event end  Otherwise the +block+ will receive five arguments with information about the event:  ActiveSupport::Notifications.subscribe('render') do |name, start, finish, id, payload| name    # => String, name of the event (such as 'render' from above) start   # => Time, when the instrumented block started execution finish  # => Time, when the instrumented block ended execution id      # => String, unique ID for the instrumenter that fired the event payload # => Hash, the payload end  Raises an error if invalid event name type is passed:  ActiveSupport::Notifications.subscribe(:render) {|event| ...} #=> ArgumentError (pattern must be specified as a String, Regexp or empty) ",
    "label": "",
    "id": "2891"
  },
  {
    "raw_code": "def monotonic_subscribe(pattern = nil, callback = nil, &block)\n        notifier.subscribe(pattern, callback, monotonic: true, &block)\n      end",
    "comment": "Performs the same functionality as #subscribe, but the +start+ and +finish+ block arguments are in monotonic time instead of wall-clock time. Monotonic time will not jump forward or backward (due to NTP or Daylights Savings). Use +monotonic_subscribe+ when accuracy of time duration is important. For example, computing elapsed time between two events.",
    "label": "",
    "id": "2892"
  },
  {
    "raw_code": "def number_to_phone(number, options = {})\n      NumberToPhoneConverter.convert(number, options)\n    end",
    "comment": "Formats +number+ into a phone number.  number_to_phone(5551234)    # => \"555-1234\" number_to_phone(\"5551234\")  # => \"555-1234\" number_to_phone(1235551234) # => \"123-555-1234\" number_to_phone(\"12x34\")    # => \"12x34\"  number_to_phone(1235551234, delimiter: \".\", country_code: 1, extension: 1343) # => \"+1.123.555.1234 x 1343\"  ==== Options  [+:area_code+] Whether to use parentheses for the area code. Defaults to false.  number_to_phone(1235551234, area_code: true) # => \"(123) 555-1234\"  [+:delimiter+] The digit group delimiter to use. Defaults to <tt>\"-\"</tt>.  number_to_phone(1235551234, delimiter: \" \") # => \"123 555 1234\"  [+:country_code+] A country code to prepend.  number_to_phone(1235551234, country_code: 1) # => \"+1-123-555-1234\"  [+:extension+] An extension to append.  number_to_phone(1235551234, extension: 555) # => \"123-555-1234 x 555\"  [+:pattern+] A regexp that specifies how the digits should be grouped. The first three captures from the regexp are treated as digit groups.  number_to_phone(13312345678, pattern: /(\\d{3})(\\d{4})(\\d{4})$/) # => \"133-1234-5678\" number_to_phone(75561234567, pattern: /(\\d{1,4})(\\d{4})(\\d{4})$/, area_code: true) # => \"(755) 6123-4567\" ",
    "label": "",
    "id": "2893"
  },
  {
    "raw_code": "def number_to_currency(number, options = {})\n      NumberToCurrencyConverter.convert(number, options)\n    end",
    "comment": "Formats a +number+ into a currency string.  number_to_currency(1234567890.50)  # => \"$1,234,567,890.50\" number_to_currency(1234567890.506) # => \"$1,234,567,890.51\" number_to_currency(\"12x34\")        # => \"$12x34\"  number_to_currency(1234567890.50, unit: \"&pound;\", separator: \",\", delimiter: \"\") # => \"&pound;1234567890,50\"  The currency unit and number formatting of the current locale will be used unless otherwise specified via options. No currency conversion is performed. If the user is given a way to change their locale, they will also be able to change the relative value of the currency displayed with this helper. If your application will ever support multiple locales, you may want to specify a constant +:locale+ option or consider using a library capable of currency conversion.  ==== Options  [+:locale+] The locale to use for formatting. Defaults to the current locale.  number_to_currency(1234567890.506, locale: :fr) # => \"1 234 567 890,51 €\"  [+:precision+] The level of precision. Defaults to 2.  number_to_currency(1234567890.123, precision: 3) # => \"$1,234,567,890.123\" number_to_currency(0.456789, precision: 0)       # => \"$0\"  [+:round_mode+] Specifies how rounding is performed. See +BigDecimal.mode+. Defaults to +:default+.  number_to_currency(1234567890.01, precision: 0, round_mode: :up) # => \"$1,234,567,891\"  [+:unit+] The denomination of the currency. Defaults to <tt>\"$\"</tt>.  [+:separator+] The decimal separator. Defaults to <tt>\".\"</tt>.  [+:delimiter+] The thousands delimiter. Defaults to <tt>\",\"</tt>.  [+:format+] The format for non-negative numbers. <tt>%u</tt> represents the currency, and <tt>%n</tt> represents the number. Defaults to <tt>\"%u%n\"</tt>.  number_to_currency(1234567890.50, format: \"%n %u\") # => \"1,234,567,890.50 $\"  [+:negative_format+] The format for negative numbers. <tt>%u</tt> and <tt>%n</tt> behave the same as in +:format+, but <tt>%n</tt> represents the absolute value of the number. Defaults to the value of +:format+ prepended with <tt>-</tt>.  number_to_currency(-1234567890.50, negative_format: \"(%u%n)\") # => \"($1,234,567,890.50)\"  [+:strip_insignificant_zeros+] Whether to remove insignificant zeros after the decimal separator. Defaults to false.  number_to_currency(1234567890.50, strip_insignificant_zeros: true) # => \"$1,234,567,890.5\" ",
    "label": "",
    "id": "2894"
  },
  {
    "raw_code": "def number_to_percentage(number, options = {})\n      NumberToPercentageConverter.convert(number, options)\n    end",
    "comment": "Formats +number+ as a percentage string.  number_to_percentage(100)   # => \"100.000%\" number_to_percentage(\"99\")  # => \"99.000%\" number_to_percentage(\"99x\") # => \"99x%\"  number_to_percentage(12345.6789, delimiter: \".\", separator: \",\", precision: 2) # => \"12.345,68%\"  ==== Options  [+:locale+] The locale to use for formatting. Defaults to the current locale.  number_to_percentage(1000, locale: :fr) # => \"1000,000%\"  [+:precision+] The level of precision, or +nil+ to preserve +number+'s precision. Defaults to 2.  number_to_percentage(12.3456789, precision: 4) # => \"12.3457%\" number_to_percentage(99.999, precision: 0)     # => \"100%\" number_to_percentage(99.999, precision: nil)   # => \"99.999%\"  [+:round_mode+] Specifies how rounding is performed. See +BigDecimal.mode+. Defaults to +:default+.  number_to_percentage(12.3456789, precision: 4, round_mode: :down) # => \"12.3456%\"  [+:significant+] Whether +:precision+ should be applied to significant digits instead of fractional digits. Defaults to false.  number_to_percentage(12345.6789)                                  # => \"12345.679%\" number_to_percentage(12345.6789, significant: true)               # => \"12300%\" number_to_percentage(12345.6789, precision: 2)                    # => \"12345.68%\" number_to_percentage(12345.6789, precision: 2, significant: true) # => \"12000%\"  [+:separator+] The decimal separator. Defaults to <tt>\".\"</tt>.  [+:delimiter+] The thousands delimiter. Defaults to <tt>\",\"</tt>.  [+:strip_insignificant_zeros+] Whether to remove insignificant zeros after the decimal separator. Defaults to false.  [+:format+] The format of the output. <tt>%n</tt> represents the number. Defaults to <tt>\"%n%\"</tt>.  number_to_percentage(100, format: \"%n  %\") # => \"100.000  %\" ",
    "label": "",
    "id": "2895"
  },
  {
    "raw_code": "def number_to_delimited(number, options = {})\n      NumberToDelimitedConverter.convert(number, options)\n    end",
    "comment": "Formats +number+ by grouping thousands with a delimiter.  number_to_delimited(12345678)      # => \"12,345,678\" number_to_delimited(\"123456\")      # => \"123,456\" number_to_delimited(12345678.9876) # => \"12,345,678.9876\" number_to_delimited(\"12x34\")       # => \"12x34\"  number_to_delimited(12345678.9876, delimiter: \".\", separator: \",\") # => \"12.345.678,9876\"  ==== Options  [+:locale+] The locale to use for formatting. Defaults to the current locale.  number_to_delimited(12345678.05, locale: :fr) # => \"12 345 678,05\"  [+:delimiter+] The thousands delimiter. Defaults to <tt>\",\"</tt>.  number_to_delimited(12345678, delimiter: \".\") # => \"12.345.678\"  [+:separator+] The decimal separator. Defaults to <tt>\".\"</tt>.  number_to_delimited(12345678.05, separator: \" \") # => \"12,345,678 05\"  [+:delimiter_pattern+] A regexp to determine the placement of delimiters. Helpful when using currency formats like INR.  number_to_delimited(\"123456.78\", delimiter_pattern: /(\\d+?)(?=(\\d\\d)+(\\d)(?!\\d))/) # => \"1,23,456.78\" ",
    "label": "",
    "id": "2896"
  },
  {
    "raw_code": "def number_to_rounded(number, options = {})\n      NumberToRoundedConverter.convert(number, options)\n    end",
    "comment": "Formats +number+ to a specific level of precision.  number_to_rounded(12345.6789)                # => \"12345.679\" number_to_rounded(12345.6789, precision: 2)  # => \"12345.68\" number_to_rounded(12345.6789, precision: 0)  # => \"12345\" number_to_rounded(12345, precision: 5)       # => \"12345.00000\"  ==== Options  [+:locale+] The locale to use for formatting. Defaults to the current locale.  number_to_rounded(111.234, locale: :fr) # => \"111,234\"  [+:precision+] The level of precision, or +nil+ to preserve +number+'s precision. Defaults to 3.  number_to_rounded(12345.6789, precision: nil) # => \"12345.6789\"  [+:round_mode+] Specifies how rounding is performed. See +BigDecimal.mode+. Defaults to +:default+.  number_to_rounded(12.34, precision: 0, round_mode: :up) # => \"13\"  [+:significant+] Whether +:precision+ should be applied to significant digits instead of fractional digits. Defaults to false.  number_to_rounded(12345.6789)                                  # => \"12345.679\" number_to_rounded(12345.6789, significant: true)               # => \"12300\" number_to_rounded(12345.6789, precision: 2)                    # => \"12345.68\" number_to_rounded(12345.6789, precision: 2, significant: true) # => \"12000\"  [+:separator+] The decimal separator. Defaults to <tt>\".\"</tt>.  [+:delimiter+] The thousands delimiter. Defaults to <tt>\",\"</tt>.  [+:strip_insignificant_zeros+] Whether to remove insignificant zeros after the decimal separator. Defaults to false.  number_to_rounded(12.34, strip_insignificant_zeros: false)  # => \"12.340\" number_to_rounded(12.34, strip_insignificant_zeros: true)   # => \"12.34\" number_to_rounded(12.3456, strip_insignificant_zeros: true) # => \"12.346\" ",
    "label": "",
    "id": "2897"
  },
  {
    "raw_code": "def number_to_human_size(number, options = {})\n      NumberToHumanSizeConverter.convert(number, options)\n    end",
    "comment": "Formats +number+ as bytes into a more human-friendly representation. Useful for reporting file sizes to users.  number_to_human_size(123)                 # => \"123 Bytes\" number_to_human_size(1234)                # => \"1.21 KB\" number_to_human_size(12345)               # => \"12.1 KB\" number_to_human_size(1234567)             # => \"1.18 MB\" number_to_human_size(1234567890)          # => \"1.15 GB\" number_to_human_size(1234567890123)       # => \"1.12 TB\" number_to_human_size(1234567890123456)    # => \"1.1 PB\" number_to_human_size(1234567890123456789) # => \"1.07 EB\"  See #number_to_human if you want to pretty-print a generic number.  ==== Options  [+:locale+] The locale to use for formatting. Defaults to the current locale.  [+:precision+] The level of precision. Defaults to 3.  number_to_human_size(123456, precision: 2)  # => \"120 KB\" number_to_human_size(1234567, precision: 2) # => \"1.2 MB\"  [+:round_mode+] Specifies how rounding is performed. See +BigDecimal.mode+. Defaults to +:default+.  number_to_human_size(123456, precision: 2, round_mode: :up) # => \"130 KB\"  [+:significant+] Whether +:precision+ should be applied to significant digits instead of fractional digits. Defaults to true.  [+:separator+] The decimal separator. Defaults to <tt>\".\"</tt>.  number_to_human_size(1234567, separator: \",\") # => \"1,18 MB\"  [+:delimiter+] The thousands delimiter. Defaults to <tt>\",\"</tt>.  [+:strip_insignificant_zeros+] Whether to remove insignificant zeros after the decimal separator. Defaults to true. ",
    "label": "",
    "id": "2898"
  },
  {
    "raw_code": "def number_to_human(number, options = {})\n      NumberToHumanConverter.convert(number, options)\n    end",
    "comment": "Formats +number+ into a more human-friendly representation. Useful for numbers that can become very large and too hard to read.  number_to_human(123)                 # => \"123\" number_to_human(1234)                # => \"1.23 Thousand\" number_to_human(12345)               # => \"12.3 Thousand\" number_to_human(1234567)             # => \"1.23 Million\" number_to_human(1234567890)          # => \"1.23 Billion\" number_to_human(1234567890123)       # => \"1.23 Trillion\" number_to_human(1234567890123456)    # => \"1.23 Quadrillion\" number_to_human(1234567890123456789) # => \"1230 Quadrillion\"  See #number_to_human_size if you want to pretty-print a file size.  ==== Options  [+:locale+] The locale to use for formatting. Defaults to the current locale.  [+:precision+] The level of precision. Defaults to 3.  number_to_human(123456, precision: 2) # => \"120 Thousand\" number_to_human(123456, precision: 4) # => \"123.5 Thousand\"  [+:round_mode+] Specifies how rounding is performed. See +BigDecimal.mode+. Defaults to +:default+.  number_to_human(123456, precision: 2, round_mode: :up) # => \"130 Thousand\"  [+:significant+] Whether +:precision+ should be applied to significant digits instead of fractional digits. Defaults to true.  [+:separator+] The decimal separator. Defaults to <tt>\".\"</tt>.  number_to_human(123456, precision: 4, separator: \",\") # => \"123,5 Thousand\"  [+:delimiter+] The thousands delimiter. Defaults to <tt>\",\"</tt>.  [+:strip_insignificant_zeros+] Whether to remove insignificant zeros after the decimal separator. Defaults to true.  number_to_human(1000000)                                   # => \"1 Million\" number_to_human(1000000, strip_insignificant_zeros: false) # => \"1.00 Million\" number_to_human(10.01)                                     # => \"10\" number_to_human(10.01, strip_insignificant_zeros: false)   # => \"10.0\"  [+:format+] The format of the output. <tt>%n</tt> represents the number, and <tt>%u</tt> represents the quantifier (e.g., \"Thousand\"). Defaults to <tt>\"%n %u\"</tt>.  [+:units+] A Hash of custom unit quantifier names.  number_to_human(1, units: { unit: \"m\", thousand: \"km\" })        # => \"1 m\" number_to_human(100, units: { unit: \"m\", thousand: \"km\" })      # => \"100 m\" number_to_human(1000, units: { unit: \"m\", thousand: \"km\" })     # => \"1 km\" number_to_human(100000, units: { unit: \"m\", thousand: \"km\" })   # => \"100 km\" number_to_human(10000000, units: { unit: \"m\", thousand: \"km\" }) # => \"10000 km\"  The following keys are supported for integer units: +:unit+, +:ten+, +:hundred+, +:thousand+, +:million+, +:billion+, +:trillion+, +:quadrillion+. Additionally, the following keys are supported for fractional units: +:deci+, +:centi+, +:mili+, +:micro+, +:nano+, +:pico+, +:femto+.  The Hash can also be defined as a scope in an I18n locale. For example:  en: distance: centi: one: \"centimeter\" other: \"centimeters\" unit: one: \"meter\" other: \"meters\" thousand: one: \"kilometer\" other: \"kilometers\"  Then it can be specified by name:  number_to_human(1, units: :distance)        # => \"1 meter\" number_to_human(100, units: :distance)      # => \"100 meters\" number_to_human(1000, units: :distance)     # => \"1 kilometer\" number_to_human(100000, units: :distance)   # => \"100 kilometers\" number_to_human(10000000, units: :distance) # => \"10000 kilometers\" number_to_human(0.1, units: :distance)      # => \"10 centimeters\" number_to_human(0.01, units: :distance)     # => \"1 centimeter\" ",
    "label": "",
    "id": "2899"
  },
  {
    "raw_code": "def extractable_options?\n      true\n    end",
    "comment": "Returns true to make sure that this hash is extractable via <tt>Array#extract_options!</tt>",
    "label": "",
    "id": "2900"
  },
  {
    "raw_code": "def self.precompile_filters(filters)\n      filters, patterns = filters.partition { |filter| filter.is_a?(Proc) }\n\n      patterns.map! do |pattern|\n        pattern.is_a?(Regexp) ? pattern : \"(?i:#{Regexp.escape pattern.to_s})\"\n      end",
    "comment": "Precompiles an array of filters that otherwise would be passed directly to #initialize. Depending on the quantity and types of filters, precompilation can improve filtering performance, especially in the case where the ParameterFilter instance itself cannot be retained (but the precompiled filters can be retained).  filters = [/foo/, :bar, \"nested.baz\", /nested\\.qux/]  precompiled = ActiveSupport::ParameterFilter.precompile_filters(filters) # => [/(?-mix:foo)|(?i:bar)/, /(?i:nested\\.baz)|(?-mix:nested\\.qux)/]  ActiveSupport::ParameterFilter.new(precompiled) ",
    "label": "",
    "id": "2901"
  },
  {
    "raw_code": "def initialize(filters = [], mask: FILTERED)\n      @mask = mask\n      compile_filters!(filters)\n    end",
    "comment": "Create instance with given filters. Supported type of filters are +String+, +Regexp+, and +Proc+. Other types of filters are treated as +String+ using +to_s+. For +Proc+ filters, key, value, and optional original hash is passed to block arguments.  ==== Options  * <tt>:mask</tt> - A replaced object when filtered. Defaults to <tt>\"[FILTERED]\"</tt>.",
    "label": "",
    "id": "2902"
  },
  {
    "raw_code": "def filter(params)\n      @no_filters ? params.dup : call(params)\n    end",
    "comment": "Mask value of +params+ if key matches one of filters.",
    "label": "",
    "id": "2903"
  },
  {
    "raw_code": "def filter_param(key, value)\n      @no_filters ? value : value_for_key(key, value)\n    end",
    "comment": "Returns filtered value for given key. For +Proc+ filters, third block argument is not populated.",
    "label": "",
    "id": "2904"
  },
  {
    "raw_code": "def self.to_prepare(*args, &block)\n      set_callback(:prepare, *args, &block)\n    end",
    "comment": "Registers a callback that will run once at application startup and every time the code is reloaded.",
    "label": "",
    "id": "2905"
  },
  {
    "raw_code": "def self.before_class_unload(*args, &block)\n      set_callback(:class_unload, *args, &block)\n    end",
    "comment": "Registers a callback that will run immediately before the classes are unloaded.",
    "label": "",
    "id": "2906"
  },
  {
    "raw_code": "def self.after_class_unload(*args, &block)\n      set_callback(:class_unload, :after, *args, &block)\n    end",
    "comment": "Registers a callback that will run immediately after the classes are unloaded.",
    "label": "",
    "id": "2907"
  },
  {
    "raw_code": "def self.reload!\n      executor.wrap do\n        new.tap do |instance|\n          instance.run!\n        ensure\n          instance.complete!\n        end",
    "comment": "Initiate a manual reload",
    "label": "",
    "id": "2908"
  },
  {
    "raw_code": "def self.wrap(**kwargs)\n      return yield if active?\n\n      executor.wrap(**kwargs) do\n        instance = run!\n        begin\n          yield\n        ensure\n          instance.complete!\n        end",
    "comment": "Run the supplied block as a work unit, reloading code as needed",
    "label": "",
    "id": "2909"
  },
  {
    "raw_code": "def require_unload_lock!\n      unless @locked\n        ActiveSupport::Dependencies.interlock.start_unloading\n        @locked = true\n      end",
    "comment": "Acquire the ActiveSupport::Dependencies::Interlock unload lock, ensuring it will be released automatically",
    "label": "",
    "id": "2910"
  },
  {
    "raw_code": "def release_unload_lock!\n      if @locked\n        @locked = false\n        ActiveSupport::Dependencies.interlock.done_unloading\n      end",
    "comment": "Release the unload lock if it has been previously obtained",
    "label": "",
    "id": "2911"
  },
  {
    "raw_code": "def rescue_from(*klasses, with: nil, &block)\n        unless with\n          if block_given?\n            with = block\n          else\n            raise ArgumentError, \"Need a handler. Pass the with: keyword argument or provide a block.\"\n          end",
    "comment": "Registers exception classes with a handler to be called by <tt>rescue_with_handler</tt>.  <tt>rescue_from</tt> receives a series of exception classes or class names, and an exception handler specified by a trailing <tt>:with</tt> option containing the name of a method or a Proc object. Alternatively, a block can be given as the handler.  Handlers that take one argument will be called with the exception, so that the exception can be inspected when dealing with it.  Handlers are inherited. They are searched from right to left, from bottom to top, and up the hierarchy. The handler of the first class for which <tt>exception.is_a?(klass)</tt> holds true is the one invoked, if any.  class ApplicationController < ActionController::Base rescue_from User::NotAuthorized, with: :deny_access rescue_from ActiveRecord::RecordInvalid, with: :show_record_errors  rescue_from \"MyApp::BaseError\" do |exception| redirect_to root_url, alert: exception.message end  private def deny_access head :forbidden end  def show_record_errors(exception) redirect_back_or_to root_url, alert: exception.record.errors.full_messages.to_sentence end end  Exceptions raised inside exception handlers are not propagated up.",
    "label": "",
    "id": "2912"
  },
  {
    "raw_code": "def rescue_with_handler(exception, object: self, visited_exceptions: [])\n        visited_exceptions << exception\n\n        if handler = handler_for_rescue(exception, object: object)\n          handler.call exception\n          exception\n        elsif exception\n          if visited_exceptions.include?(exception.cause)\n            nil\n          else\n            rescue_with_handler(exception.cause, object: object, visited_exceptions: visited_exceptions)\n          end",
    "comment": "Matches an exception to a handler based on the exception class.  If no handler matches the exception, check for a handler matching the (optional) +exception.cause+. If no handler matches the exception or its cause, this returns +nil+, so you can deal with unhandled exceptions. Be sure to re-raise unhandled exceptions if this is what you expect.  begin # ... rescue => exception rescue_with_handler(exception) || raise end  Returns the exception if it was handled and +nil+ if it was not.",
    "label": "",
    "id": "2913"
  },
  {
    "raw_code": "def rescue_with_handler(exception)\n      self.class.rescue_with_handler exception, object: self\n    end",
    "comment": "Delegates to the class method, but uses the instance as the subject for rescue_from handlers (method calls, +instance_exec+ blocks).",
    "label": "",
    "id": "2914"
  },
  {
    "raw_code": "def handler_for_rescue(exception) # :nodoc:\n      self.class.handler_for_rescue exception, object: self\n    end",
    "comment": "Internal handler lookup. Delegates to class method. Some libraries call this directly, so keeping it around for compatibility.",
    "label": "",
    "id": "2915"
  },
  {
    "raw_code": "def secure_compare(a, b)\n      a.bytesize == b.bytesize && fixed_length_secure_compare(a, b)\n    end",
    "comment": "Secure string comparison for strings of variable length.  While a timing attack would not be able to discern the content of a secret compared via secure_compare, it is possible to determine the secret length. This should be considered when using secure_compare to compare weak, short secrets to user input.",
    "label": "",
    "id": "2916"
  },
  {
    "raw_code": "def emit_event(name, payload = nil, caller_depth: 1, **kwargs)\n      ActiveSupport.event_reporter.notify(name, payload, caller_depth: caller_depth + 1, **kwargs)\n    rescue => e\n      handle_event_error(name, e)\n    end",
    "comment": "Emit a structured event via Rails.event.notify.  ==== Arguments  * +name+ - The event name as a string or symbol * +payload+ - The event payload as a hash or object * +caller_depth+ - Stack depth for source location (default: 1) * +kwargs+ - Additional payload data merged with the payload hash",
    "label": "",
    "id": "2917"
  },
  {
    "raw_code": "def emit_debug_event(name, payload = nil, caller_depth: 1, **kwargs)\n      ActiveSupport.event_reporter.debug(name, payload, caller_depth: caller_depth + 1, **kwargs)\n    rescue => e\n      handle_event_error(name, e)\n    end",
    "comment": "Like +emit_event+, but only emits when the event reporter is in debug mode",
    "label": "",
    "id": "2918"
  },
  {
    "raw_code": "def attach_to(namespace, subscriber = new, notifier = ActiveSupport::Notifications, inherit_all: false)\n        @namespace  = namespace\n        @subscriber = subscriber\n        @notifier   = notifier\n        @inherit_all = inherit_all\n\n        subscribers << subscriber\n\n        # Add event subscribers for all existing methods on the class.\n        fetch_public_methods(subscriber, inherit_all).each do |event|\n          add_event_subscriber(event)\n        end",
    "comment": "Attach the subscriber to a namespace.",
    "label": "",
    "id": "2919"
  },
  {
    "raw_code": "def detach_from(namespace, notifier = ActiveSupport::Notifications)\n        @namespace  = namespace\n        @subscriber = find_attached_subscriber\n        @notifier   = notifier\n\n        return unless subscriber\n\n        subscribers.delete(subscriber)\n\n        # Remove event subscribers of all existing methods on the class.\n        fetch_public_methods(subscriber, true).each do |event|\n          remove_event_subscriber(event)\n        end",
    "comment": "Detach the subscriber from a namespace.",
    "label": "",
    "id": "2920"
  },
  {
    "raw_code": "def method_added(event)\n        super\n        # Only public methods are added as subscribers, and only if a notifier\n        # has been set up. This means that subscribers will only be set up for\n        # classes that call #attach_to.\n        if public_method_defined?(event) && notifier\n          add_event_subscriber(event)\n        end",
    "comment": "Adds event subscribers for all new methods added to the class.",
    "label": "",
    "id": "2921"
  },
  {
    "raw_code": "def call(severity, timestamp, progname, msg)\n        super(severity, timestamp, progname, tag_stack.format_message(msg))\n      end",
    "comment": "This method is invoked when a log event occurs.",
    "label": "",
    "id": "2922"
  },
  {
    "raw_code": "def self.logger(*args, **kwargs)\n      new ActiveSupport::Logger.new(*args, **kwargs)\n    end",
    "comment": "Returns an `ActiveSupport::Logger` that has already been wrapped with tagged logging concern.",
    "label": "",
    "id": "2923"
  },
  {
    "raw_code": "def parallel_worker_id\n        @@parallel_worker_id\n      end",
    "comment": "Returns the current parallel worker ID if tests are running in parallel, nil otherwise.  ActiveSupport::TestCase.parallel_worker_id # => 2",
    "label": "",
    "id": "2924"
  },
  {
    "raw_code": "def test_order=(new_order)\n        ActiveSupport.test_order = new_order\n      end",
    "comment": "Sets the order in which test cases are run.  ActiveSupport::TestCase.test_order = :random # => :random  Valid values are: * +:random+   (to run tests in random order) * +:parallel+ (to run tests in parallel) * +:sorted+   (to run tests alphabetically by method name) * +:alpha+    (equivalent to +:sorted+)",
    "label": "",
    "id": "2925"
  },
  {
    "raw_code": "def test_order\n        ActiveSupport.test_order ||= :random\n      end",
    "comment": "Returns the order in which test cases are run.  ActiveSupport::TestCase.test_order # => :random  Possible values are +:random+, +:parallel+, +:alpha+, +:sorted+. Defaults to +:random+.",
    "label": "",
    "id": "2926"
  },
  {
    "raw_code": "def parallelize(workers: :number_of_processors, with: :processes, threshold: ActiveSupport.test_parallelization_threshold, parallelize_databases: ActiveSupport.parallelize_test_databases)\n        case\n        when ENV[\"PARALLEL_WORKERS\"]\n          workers = ENV[\"PARALLEL_WORKERS\"].to_i\n        when workers == :number_of_processors\n          workers = (Concurrent.available_processor_count || Concurrent.processor_count).floor\n        end",
    "comment": "Parallelizes the test suite.  Takes a +workers+ argument that controls how many times the process is forked. For each process a new database will be created suffixed with the worker number.  test-database_0 test-database_1  If <tt>ENV[\"PARALLEL_WORKERS\"]</tt> is set the workers argument will be ignored and the environment variable will be used instead. This is useful for CI environments, or other environments where you may need more workers than you do for local testing.  If the number of workers is set to +1+ or fewer, the tests will not be parallelized.  If +workers+ is set to +:number_of_processors+, the number of workers will be set to the actual core count on the machine you are on.  The default parallelization method is to fork processes. If you'd like to use threads instead you can pass <tt>with: :threads</tt> to the +parallelize+ method. Note the threaded parallelization does not create multiple databases and will not work with system tests.  parallelize(workers: :number_of_processors, with: :threads)  The threaded parallelization uses minitest's parallel executor directly. The processes parallelization uses a Ruby DRb server.  Because parallelization presents an overhead, it is only enabled when the number of tests to run is above the +threshold+ param. The default value is 50, and it's configurable via +config.active_support.test_parallelization_threshold+.  If you want to skip Rails default creation of one database per process in favor of writing your own implementation, you can set +parallelize_databases+, or configure it via +config.active_support.parallelize_test_databases+.  parallelize(workers: :number_of_processors, parallelize_databases: false)  Note that your test suite may deadlock if you attempt to use only one database with multiple processes.",
    "label": "",
    "id": "2927"
  },
  {
    "raw_code": "def parallelize_before_fork(&block)\n        ActiveSupport::Testing::Parallelization.before_fork_hook(&block)\n      end",
    "comment": "Before fork hook for parallel testing. This can be used to run anything before the processes are forked.  In your +test_helper.rb+ add the following:  class ActiveSupport::TestCase parallelize_before_fork do # run this before fork end end",
    "label": "",
    "id": "2928"
  },
  {
    "raw_code": "def parallelize_setup(&block)\n        ActiveSupport::Testing::Parallelization.after_fork_hook(&block)\n      end",
    "comment": "Setup hook for parallel testing. This can be used if you have multiple databases or any behavior that needs to be run after the process is forked but before the tests run.  Note: this feature is not available with the threaded parallelization.  In your +test_helper.rb+ add the following:  class ActiveSupport::TestCase parallelize_setup do # create databases end end",
    "label": "",
    "id": "2929"
  },
  {
    "raw_code": "def parallelize_teardown(&block)\n        ActiveSupport::Testing::Parallelization.run_cleanup_hook(&block)\n      end",
    "comment": "Clean up hook for parallel testing. This can be used to drop databases if your app uses multiple write/read databases or other clean up before the tests finish. This runs before the forked process is closed.  Note: this feature is not available with the threaded parallelization.  In your +test_helper.rb+ add the following:  class ActiveSupport::TestCase parallelize_teardown do # drop databases end end",
    "label": "",
    "id": "2930"
  },
  {
    "raw_code": "def parallel_worker_id\n      self.class.parallel_worker_id\n    end",
    "comment": "Returns the current parallel worker ID if tests are running in parallel",
    "label": "",
    "id": "2931"
  },
  {
    "raw_code": "def time\n      @time ||= incorporate_utc_offset(@utc, utc_offset)\n    end",
    "comment": "Returns a <tt>Time</tt> instance that represents the time in +time_zone+.",
    "label": "",
    "id": "2932"
  },
  {
    "raw_code": "def utc\n      @utc ||= incorporate_utc_offset(@time, -utc_offset)\n    end",
    "comment": "Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.",
    "label": "",
    "id": "2933"
  },
  {
    "raw_code": "def period\n      @period ||= time_zone.period_for_utc(@utc)\n    end",
    "comment": "Returns the underlying +TZInfo::TimezonePeriod+.",
    "label": "",
    "id": "2934"
  },
  {
    "raw_code": "def in_time_zone(new_zone = ::Time.zone)\n      return self if time_zone == new_zone\n      utc.in_time_zone(new_zone)\n    end",
    "comment": "Returns the simultaneous time in <tt>Time.zone</tt>, or the specified zone.",
    "label": "",
    "id": "2935"
  },
  {
    "raw_code": "def localtime(utc_offset = nil)\n      utc.getlocal(utc_offset)\n    end",
    "comment": "Returns a <tt>Time</tt> instance of the simultaneous time in the system timezone.",
    "label": "",
    "id": "2936"
  },
  {
    "raw_code": "def dst?\n      period.dst?\n    end",
    "comment": "Returns true if the current time is within Daylight Savings \\Time for the specified time zone.  Time.zone = 'Eastern Time (US & Canada)'    # => 'Eastern Time (US & Canada)' Time.zone.parse(\"2012-5-30\").dst?           # => true Time.zone.parse(\"2012-11-30\").dst?          # => false",
    "label": "",
    "id": "2937"
  },
  {
    "raw_code": "def utc?\n      @is_utc\n    end",
    "comment": "Returns true if the current time zone is set to UTC.  Time.zone = 'UTC'                           # => 'UTC' Time.zone.now.utc?                          # => true Time.zone = 'Eastern Time (US & Canada)'    # => 'Eastern Time (US & Canada)' Time.zone.now.utc?                          # => false",
    "label": "",
    "id": "2938"
  },
  {
    "raw_code": "def utc_offset\n      period.observed_utc_offset\n    end",
    "comment": "Returns the offset from current time to UTC time in seconds.",
    "label": "",
    "id": "2939"
  },
  {
    "raw_code": "def formatted_offset(colon = true, alternate_utc_string = nil)\n      utc? && alternate_utc_string || TimeZone.seconds_to_utc_offset(utc_offset, colon)\n    end",
    "comment": "Returns a formatted string of the offset from UTC, or an alternative string if the time zone is already UTC.  Time.zone = 'Eastern Time (US & Canada)'   # => \"Eastern Time (US & Canada)\" Time.zone.now.formatted_offset(true)       # => \"-05:00\" Time.zone.now.formatted_offset(false)      # => \"-0500\" Time.zone = 'UTC'                          # => \"UTC\" Time.zone.now.formatted_offset(true, \"0\")  # => \"0\"",
    "label": "",
    "id": "2940"
  },
  {
    "raw_code": "def zone\n      period.abbreviation\n    end",
    "comment": "Returns the time zone abbreviation.  Time.zone = 'Eastern Time (US & Canada)'   # => \"Eastern Time (US & Canada)\" Time.zone.now.zone # => \"EST\"",
    "label": "",
    "id": "2941"
  },
  {
    "raw_code": "def inspect\n      \"#{time.strftime('%F %H:%M:%S.%9N')} #{zone} #{formatted_offset}\"\n    end",
    "comment": "Returns a string of the object's date, time, zone, and offset from UTC.  Time.zone.now.inspect # => \"2024-11-13 07:00:10.528054960 UTC +00:00\"",
    "label": "",
    "id": "2942"
  },
  {
    "raw_code": "def xmlschema(fraction_digits = 0)\n      if @is_utc\n        utc.iso8601(fraction_digits || 0)\n      else\n        str = time.iso8601(fraction_digits || 0)\n        str[-1] = formatted_offset(true, \"Z\")\n        str\n      end",
    "comment": "Returns a string of the object's date and time in the ISO 8601 standard format.  Time.zone.now.xmlschema  # => \"2014-12-04T11:02:37-05:00\"",
    "label": "",
    "id": "2943"
  },
  {
    "raw_code": "def as_json(options = nil)\n      if ActiveSupport::JSON::Encoding.use_standard_json_time_format\n        xmlschema(ActiveSupport::JSON::Encoding.time_precision)\n      else\n        %(#{time.strftime(\"%Y/%m/%d %H:%M:%S\")} #{formatted_offset(false)})\n      end",
    "comment": "Coerces time to a string for JSON encoding. The default format is ISO 8601. You can get %Y/%m/%d %H:%M:%S +offset style by setting <tt>ActiveSupport::JSON::Encoding.use_standard_json_time_format</tt> to +false+.  # With ActiveSupport::JSON::Encoding.use_standard_json_time_format = true Time.utc(2005,2,1,15,15,10).in_time_zone(\"Hawaii\").as_json # => \"2005-02-01T05:15:10.000-10:00\"  # With ActiveSupport::JSON::Encoding.use_standard_json_time_format = false Time.utc(2005,2,1,15,15,10).in_time_zone(\"Hawaii\").as_json # => \"2005/02/01 05:15:10 -1000\"",
    "label": "",
    "id": "2944"
  },
  {
    "raw_code": "def httpdate\n      utc.httpdate\n    end",
    "comment": "Returns a string of the object's date and time in the format used by HTTP requests.  Time.zone.now.httpdate  # => \"Tue, 01 Jan 2013 04:39:43 GMT\"",
    "label": "",
    "id": "2945"
  },
  {
    "raw_code": "def rfc2822\n      to_fs(:rfc822)\n    end",
    "comment": "Returns a string of the object's date and time in the RFC 2822 standard format.  Time.zone.now.rfc2822  # => \"Tue, 01 Jan 2013 04:51:39 +0000\"",
    "label": "",
    "id": "2946"
  },
  {
    "raw_code": "def to_s\n      \"#{time.strftime(\"%Y-%m-%d %H:%M:%S\")} #{formatted_offset(false, 'UTC')}\" # mimicking Ruby Time#to_s format\n    end",
    "comment": "Returns a string of the object's date and time.",
    "label": "",
    "id": "2947"
  },
  {
    "raw_code": "def to_fs(format = :default)\n      if format == :db\n        utc.to_fs(format)\n      elsif formatter = ::Time::DATE_FORMATS[format]\n        formatter.respond_to?(:call) ? formatter.call(self).to_s : strftime(formatter)\n      else\n        to_s\n      end",
    "comment": "Returns a string of the object's date and time.  This method is aliased to <tt>to_formatted_s</tt>.  Accepts an optional <tt>format</tt>: * <tt>:default</tt> - default value, mimics Ruby Time#to_s format. * <tt>:db</tt> - format outputs time in UTC :db time. See Time#to_fs(:db). * Any key in +Time::DATE_FORMATS+ can be used. See active_support/core_ext/time/conversions.rb.",
    "label": "",
    "id": "2948"
  },
  {
    "raw_code": "def strftime(format)\n      format = format.gsub(/((?:\\A|[^%])(?:%%)*)%Z/, \"\\\\1#{zone}\")\n      getlocal(utc_offset).strftime(format)\n    end",
    "comment": "Replaces <tt>%Z</tt> directive with +zone before passing to Time#strftime, so that zone information is correct.",
    "label": "",
    "id": "2949"
  },
  {
    "raw_code": "def <=>(other)\n      utc <=> other\n    end",
    "comment": "Use the time in UTC for comparisons.",
    "label": "",
    "id": "2950"
  },
  {
    "raw_code": "def between?(min, max)\n      utc.between?(min, max)\n    end",
    "comment": "Returns true if the current object's time is within the specified +min+ and +max+ time.",
    "label": "",
    "id": "2951"
  },
  {
    "raw_code": "def past?\n      utc.past?\n    end",
    "comment": "Returns true if the current object's time is in the past.",
    "label": "",
    "id": "2952"
  },
  {
    "raw_code": "def today?\n      time.today?\n    end",
    "comment": "Returns true if the current object's time falls within the current day.",
    "label": "",
    "id": "2953"
  },
  {
    "raw_code": "def tomorrow?\n      time.tomorrow?\n    end",
    "comment": "Returns true if the current object's time falls within the next day (tomorrow).",
    "label": "",
    "id": "2954"
  },
  {
    "raw_code": "def yesterday?\n      time.yesterday?\n    end",
    "comment": "Returns true if the current object's time falls within the previous day (yesterday).",
    "label": "",
    "id": "2955"
  },
  {
    "raw_code": "def future?\n      utc.future?\n    end",
    "comment": "Returns true if the current object's time is in the future.",
    "label": "",
    "id": "2956"
  },
  {
    "raw_code": "def eql?(other)\n      other.eql?(utc)\n    end",
    "comment": "Returns +true+ if +other+ is equal to current object.",
    "label": "",
    "id": "2957"
  },
  {
    "raw_code": "def +(other)\n      if duration_of_variable_length?(other)\n        method_missing(:+, other)\n      else\n        begin\n          result = utc + other\n        rescue TypeError\n          result = utc.to_datetime.since(other)\n          ActiveSupport.deprecator.warn(\n            \"Adding an instance of #{other.class} to an instance of #{self.class} is deprecated. This behavior will raise \" \\\n            \"a `TypeError` in Rails 8.1.\"\n          )\n          result.in_time_zone(time_zone)\n        end",
    "comment": "Adds an interval of time to the current object's time and returns that value as a new TimeWithZone object.  Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)' now = Time.zone.now # => Sun, 02 Nov 2014 01:26:28.725182881 EDT -04:00 now + 1000          # => Sun, 02 Nov 2014 01:43:08.725182881 EDT -04:00  If we're adding a Duration of variable length (i.e., years, months, days), move forward from #time, otherwise move forward from #utc, for accuracy when moving across DST boundaries.  For instance, a time + 24.hours will advance exactly 24 hours, while a time + 1.day will advance 23-25 hours, depending on the day.  now + 24.hours      # => Mon, 03 Nov 2014 00:26:28.725182881 EST -05:00 now + 1.day         # => Mon, 03 Nov 2014 01:26:28.725182881 EST -05:00",
    "label": "",
    "id": "2958"
  },
  {
    "raw_code": "def -(other)\n      if other.acts_like?(:time)\n        getutc - other.getutc\n      elsif duration_of_variable_length?(other)\n        method_missing(:-, other)\n      else\n        result = utc - other\n        result.in_time_zone(time_zone)\n      end",
    "comment": "Subtracts an interval of time and returns a new TimeWithZone object unless the other value +acts_like?+ time. In which case, it will subtract the other time and return the difference in seconds as a Float.  Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)' now = Time.zone.now # => Mon, 03 Nov 2014 00:26:28.725182881 EST -05:00 now - 1000          # => Mon, 03 Nov 2014 00:09:48.725182881 EST -05:00  If subtracting a Duration of variable length (i.e., years, months, days), move backward from #time, otherwise move backward from #utc, for accuracy when moving across DST boundaries.  For instance, a time - 24.hours will go subtract exactly 24 hours, while a time - 1.day will subtract 23-25 hours, depending on the day.  now - 24.hours      # => Sun, 02 Nov 2014 01:26:28.725182881 EDT -04:00 now - 1.day         # => Sun, 02 Nov 2014 00:26:28.725182881 EDT -04:00  If both the TimeWithZone object and the other value act like Time, a Float will be returned.  Time.zone.now - 1.day.ago # => 86399.999967 ",
    "label": "",
    "id": "2959"
  },
  {
    "raw_code": "def ago(other)\n      since(-other)\n    end",
    "comment": "Subtracts an interval of time from the current object's time and returns the result as a new TimeWithZone object.  Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)' now = Time.zone.now # => Mon, 03 Nov 2014 00:26:28.725182881 EST -05:00 now.ago(1000)       # => Mon, 03 Nov 2014 00:09:48.725182881 EST -05:00  If we're subtracting a Duration of variable length (i.e., years, months, days), move backward from #time, otherwise move backward from #utc, for accuracy when moving across DST boundaries.  For instance, <tt>time.ago(24.hours)</tt> will move back exactly 24 hours, while <tt>time.ago(1.day)</tt> will move back 23-25 hours, depending on the day.  now.ago(24.hours)   # => Sun, 02 Nov 2014 01:26:28.725182881 EDT -04:00 now.ago(1.day)      # => Sun, 02 Nov 2014 00:26:28.725182881 EDT -04:00",
    "label": "",
    "id": "2960"
  },
  {
    "raw_code": "def change(options)\n      if options[:zone] && options[:offset]\n        raise ArgumentError, \"Can't change both :offset and :zone at the same time: #{options.inspect}\"\n      end",
    "comment": "Returns a new +ActiveSupport::TimeWithZone+ where one or more of the elements have been changed according to the +options+ parameter. The time options (<tt>:hour</tt>, <tt>:min</tt>, <tt>:sec</tt>, <tt>:usec</tt>, <tt>:nsec</tt>) reset cascadingly, so if only the hour is passed, then minute, sec, usec, and nsec is set to 0. If the hour and minute is passed, then sec, usec, and nsec is set to 0. The +options+ parameter takes a hash with any of these keys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>, <tt>:hour</tt>, <tt>:min</tt>, <tt>:sec</tt>, <tt>:usec</tt>, <tt>:nsec</tt>, <tt>:offset</tt>, <tt>:zone</tt>. Pass either <tt>:usec</tt> or <tt>:nsec</tt>, not both. Similarly, pass either <tt>:zone</tt> or <tt>:offset</tt>, not both.  t = Time.zone.now          # => Fri, 14 Apr 2017 11:45:15.116992711 EST -05:00 t.change(year: 2020)       # => Tue, 14 Apr 2020 11:45:15.116992711 EST -05:00 t.change(hour: 12)         # => Fri, 14 Apr 2017 12:00:00.000000000 EST -05:00 t.change(min: 30)          # => Fri, 14 Apr 2017 11:30:00.000000000 EST -05:00 t.change(offset: \"-10:00\") # => Fri, 14 Apr 2017 11:45:15.116992711 HST -10:00 t.change(zone: \"Hawaii\")   # => Fri, 14 Apr 2017 11:45:15.116992711 HST -10:00",
    "label": "",
    "id": "2961"
  },
  {
    "raw_code": "def advance(options)\n      # If we're advancing a value of variable length (i.e., years, weeks, months, days), advance from #time,\n      # otherwise advance from #utc, for accuracy when moving across DST boundaries\n      if options.values_at(:years, :weeks, :months, :days).any?\n        method_missing(:advance, options)\n      else\n        utc.advance(options).in_time_zone(time_zone)\n      end",
    "comment": "Uses Date to provide precise Time calculations for years, months, and days according to the proleptic Gregorian calendar. The result is returned as a new TimeWithZone object.  The +options+ parameter takes a hash with any of these keys: <tt>:years</tt>, <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>, <tt>:hours</tt>, <tt>:minutes</tt>, <tt>:seconds</tt>.  If advancing by a value of variable length (i.e., years, weeks, months, days), move forward from #time, otherwise move forward from #utc, for accuracy when moving across DST boundaries.  Time.zone = 'Eastern Time (US & Canada)' # => 'Eastern Time (US & Canada)' now = Time.zone.now # => Sun, 02 Nov 2014 01:26:28.558049687 EDT -04:00 now.advance(seconds: 1) # => Sun, 02 Nov 2014 01:26:29.558049687 EDT -04:00 now.advance(minutes: 1) # => Sun, 02 Nov 2014 01:27:28.558049687 EDT -04:00 now.advance(hours: 1)   # => Sun, 02 Nov 2014 01:26:28.558049687 EST -05:00 now.advance(days: 1)    # => Mon, 03 Nov 2014 01:26:28.558049687 EST -05:00 now.advance(weeks: 1)   # => Sun, 09 Nov 2014 01:26:28.558049687 EST -05:00 now.advance(months: 1)  # => Tue, 02 Dec 2014 01:26:28.558049687 EST -05:00 now.advance(years: 1)   # => Mon, 02 Nov 2015 01:26:28.558049687 EST -05:00",
    "label": "",
    "id": "2962"
  },
  {
    "raw_code": "def to_a\n      [time.sec, time.min, time.hour, time.day, time.mon, time.year, time.wday, time.yday, dst?, zone]\n    end",
    "comment": "Returns Array of parts of Time in sequence of [seconds, minutes, hours, day, month, year, weekday, yearday, dst?, zone].  now = Time.zone.now     # => Tue, 18 Aug 2015 02:29:27.485278555 UTC +00:00 now.to_a                # => [27, 29, 2, 18, 8, 2015, 2, 230, false, \"UTC\"]",
    "label": "",
    "id": "2963"
  },
  {
    "raw_code": "def to_f\n      utc.to_f\n    end",
    "comment": "Returns the object's date and time as a floating-point number of seconds since the Epoch (January 1, 1970 00:00 UTC).  Time.zone.now.to_f # => 1417709320.285418",
    "label": "",
    "id": "2964"
  },
  {
    "raw_code": "def to_i\n      utc.to_i\n    end",
    "comment": "Returns the object's date and time as an integer number of seconds since the Epoch (January 1, 1970 00:00 UTC).  Time.zone.now.to_i # => 1417709320",
    "label": "",
    "id": "2965"
  },
  {
    "raw_code": "def to_r\n      utc.to_r\n    end",
    "comment": "Returns the object's date and time as a rational number of seconds since the Epoch (January 1, 1970 00:00 UTC).  Time.zone.now.to_r # => (708854548642709/500000)",
    "label": "",
    "id": "2966"
  },
  {
    "raw_code": "def to_datetime\n      @to_datetime ||= utc.to_datetime.new_offset(Rational(utc_offset, 86_400))\n    end",
    "comment": "Returns an instance of DateTime with the timezone's UTC offset  Time.zone.now.to_datetime                         # => Tue, 18 Aug 2015 02:32:20 +0000 Time.current.in_time_zone('Hawaii').to_datetime   # => Mon, 17 Aug 2015 16:32:20 -1000",
    "label": "",
    "id": "2967"
  },
  {
    "raw_code": "def to_time\n      if preserve_timezone == :zone\n        @to_time_with_timezone ||= getlocal(time_zone)\n      elsif preserve_timezone\n        @to_time_with_instance_offset ||= getlocal(utc_offset)\n      else\n        @to_time_with_system_offset ||= getlocal\n      end",
    "comment": "Returns an instance of +Time+, either with the same timezone as +self+, with the same UTC offset as +self+ or in the local system timezone depending on the setting of +ActiveSupport.to_time_preserves_timezone+.",
    "label": "",
    "id": "2968"
  },
  {
    "raw_code": "def acts_like_time?\n      true\n    end",
    "comment": "So that +self+ <tt>acts_like?(:time)</tt>.",
    "label": "",
    "id": "2969"
  },
  {
    "raw_code": "def is_a?(klass)\n      klass == ::Time || super\n    end",
    "comment": "Say we're a Time to thwart type checking.",
    "label": "",
    "id": "2970"
  },
  {
    "raw_code": "def blank?\n      false\n    end",
    "comment": "An instance of ActiveSupport::TimeWithZone is never blank",
    "label": "",
    "id": "2971"
  },
  {
    "raw_code": "def respond_to?(sym, include_priv = false)\n      # ensure that we're not going to throw and rescue from NoMethodError in method_missing which is slow\n      return false if sym.to_sym == :to_str\n      super\n    end",
    "comment": "respond_to_missing? is not called in some cases, such as when type conversion is performed with Kernel#String",
    "label": "",
    "id": "2972"
  },
  {
    "raw_code": "def respond_to_missing?(sym, include_priv)\n      time.respond_to?(sym, include_priv)\n    end",
    "comment": "Ensure proxy class responds to all methods that underlying time instance responds to.",
    "label": "",
    "id": "2973"
  },
  {
    "raw_code": "def method_missing(...)\n      wrap_with_time_zone time.__send__(...)\n    rescue NoMethodError => e\n      raise e, e.message.sub(time.inspect, inspect).sub(\"Time\", \"ActiveSupport::TimeWithZone\"), e.backtrace\n    end",
    "comment": "Send the missing method to +time+ instance, and wrap result in a new TimeWithZone with the existing +time_zone+.",
    "label": "",
    "id": "2974"
  },
  {
    "raw_code": "def self.version\n    gem_version\n  end",
    "comment": "Returns the currently loaded version of Active Support as a +Gem::Version+.",
    "label": "",
    "id": "2975"
  },
  {
    "raw_code": "def initialize(value, compressed: false, version: nil, expires_in: nil, expires_at: nil, **)\n        @value      = value\n        @version    = version\n        @created_at = 0.0\n        @expires_in = expires_at&.to_f || expires_in && (expires_in.to_f + Time.now.to_f)\n        @compressed = true if compressed\n      end",
    "comment": "Creates a new cache entry for the specified value. Options supported are +:compressed+, +:version+, +:expires_at+ and +:expires_in+.",
    "label": "",
    "id": "2976"
  },
  {
    "raw_code": "def expired?\n        @expires_in && @created_at + @expires_in <= Time.now.to_f\n      end",
    "comment": "Checks if the entry is expired. The +expires_in+ parameter can override the value set when the entry was created.",
    "label": "",
    "id": "2977"
  },
  {
    "raw_code": "def bytesize\n        case value\n        when NilClass\n          0\n        when String\n          @value.bytesize\n        else\n          @s ||= Marshal.dump(@value).bytesize\n        end",
    "comment": "Returns the size of the cached value. This could be less than <tt>value.bytesize</tt> if the data is compressed.",
    "label": "",
    "id": "2978"
  },
  {
    "raw_code": "def dup_value!\n        if @value && !compressed? && !(@value.is_a?(Numeric) || @value == true || @value == false)\n          if @value.is_a?(String)\n            @value = @value.dup\n          else\n            @value = Marshal.load(Marshal.dump(@value))\n          end",
    "comment": "Duplicates the value in a class. This is used by cache implementations that don't natively serialize entries to protect against accidental cache modifications.",
    "label": "",
    "id": "2979"
  },
  {
    "raw_code": "def self.supports_cache_versioning?\n        true\n      end",
    "comment": "Advertise cache versioning support.",
    "label": "",
    "id": "2980"
  },
  {
    "raw_code": "def clear(options = nil)\n        root_dirs = (Dir.children(cache_path) - GITKEEP_FILES)\n        FileUtils.rm_r(root_dirs.collect { |f| File.join(cache_path, f) })\n      rescue Errno::ENOENT, Errno::ENOTEMPTY\n      end",
    "comment": "Deletes all items from the cache. In this case it deletes all the entries in the specified file store directory except for .keep or .gitkeep. Be careful which directory is specified in your config file when using +FileStore+ because everything in that directory will be deleted.",
    "label": "",
    "id": "2981"
  },
  {
    "raw_code": "def cleanup(options = nil)\n        options = merged_options(options)\n        search_dir(cache_path) do |fname|\n          entry = read_entry(fname, **options)\n          delete_entry(fname, **options) if entry && entry.expired?\n        end",
    "comment": "Preemptively iterates through all stored keys and removes the ones which have expired.",
    "label": "",
    "id": "2982"
  },
  {
    "raw_code": "def increment(name, amount = 1, **options)\n        options = merged_options(options)\n        key = normalize_key(name, options)\n\n        instrument(:increment, key, amount: amount) do\n          modify_value(name, amount, options)\n        end",
    "comment": "Increment a cached integer value. Returns the updated value.  If the key is unset, it starts from +0+:  cache.increment(\"foo\") # => 1 cache.increment(\"bar\", 100) # => 100  To set a specific value, call #write:  cache.write(\"baz\", 5) cache.increment(\"baz\") # => 6 ",
    "label": "",
    "id": "2983"
  },
  {
    "raw_code": "def decrement(name, amount = 1, **options)\n        options = merged_options(options)\n        key = normalize_key(name, options)\n\n        instrument(:decrement, key, amount: amount) do\n          modify_value(name, -amount, options)\n        end",
    "comment": "Decrement a cached integer value. Returns the updated value.  If the key is unset, it will be set to +-amount+.  cache.decrement(\"foo\") # => -1  To set a specific value, call #write:  cache.write(\"baz\", 5) cache.decrement(\"baz\") # => 4 ",
    "label": "",
    "id": "2984"
  },
  {
    "raw_code": "def lock_file(file_name, &block)\n          if File.exist?(file_name)\n            File.open(file_name, \"r+\") do |f|\n              f.flock File::LOCK_EX\n              yield\n            ensure\n              f.flock File::LOCK_UN\n            end",
    "comment": "Lock a file for a block so only one process can modify it at a time.",
    "label": "",
    "id": "2985"
  },
  {
    "raw_code": "def normalize_key(key, options)\n          key = super\n          fname = URI.encode_www_form_component(key)\n\n          if fname.size > FILEPATH_MAX_SIZE\n            fname = ActiveSupport::Digest.hexdigest(key)\n          end",
    "comment": "Translate a key into a file path.",
    "label": "",
    "id": "2986"
  },
  {
    "raw_code": "def file_path_key(path)\n          fname = path[cache_path.to_s.size..-1].split(File::SEPARATOR, 4).last.delete(File::SEPARATOR)\n          URI.decode_www_form_component(fname, Encoding::UTF_8)\n        end",
    "comment": "Translate a file path into a key.",
    "label": "",
    "id": "2987"
  },
  {
    "raw_code": "def delete_empty_directories(dir)\n          return if File.realpath(dir) == File.realpath(cache_path)\n          if Dir.children(dir).empty?\n            Dir.delete(dir) rescue nil\n            delete_empty_directories(File.dirname(dir))\n          end",
    "comment": "Delete empty directories in the cache.",
    "label": "",
    "id": "2988"
  },
  {
    "raw_code": "def ensure_cache_path(path)\n          FileUtils.makedirs(path) unless File.exist?(path)\n        end",
    "comment": "Make sure a file path's directories exist.",
    "label": "",
    "id": "2989"
  },
  {
    "raw_code": "def modify_value(name, amount, options)\n          options = merged_options(options)\n          key = normalize_key(name, options)\n          version = normalize_version(name, options)\n          amount = Integer(amount)\n\n          lock_file(key) do\n            entry = read_entry(key, **options)\n\n            if !entry || entry.expired? || entry.mismatched?(version)\n              write(name, amount, options)\n              amount\n            else\n              num = entry.value.to_i + amount\n              entry = Entry.new(num, expires_at: entry.expires_at, version: entry.version)\n              write_entry(key, entry)\n              num\n            end",
    "comment": "Modifies the amount of an integer value that is stored in the cache. If the key is not found it is created and set to +amount+.",
    "label": "",
    "id": "2990"
  },
  {
    "raw_code": "def self.supports_cache_versioning?\n        true\n      end",
    "comment": "Advertise cache versioning support.",
    "label": "",
    "id": "2991"
  },
  {
    "raw_code": "def clear(options = nil)\n        synchronize do\n          @data.clear\n          @cache_size = 0\n        end",
    "comment": "Delete all data stored in a given cache store.",
    "label": "",
    "id": "2992"
  },
  {
    "raw_code": "def cleanup(options = nil)\n        options = merged_options(options)\n        _instrument(:cleanup, size: @data.size) do\n          keys = synchronize { @data.keys }\n          keys.each do |key|\n            entry = @data[key]\n            delete_entry(key, **options) if entry && entry.expired?\n          end",
    "comment": "Preemptively iterates through all stored keys and removes the ones which have expired.",
    "label": "",
    "id": "2993"
  },
  {
    "raw_code": "def prune(target_size, max_time = nil)\n        return if pruning?\n        @pruning = true\n        begin\n          start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n          cleanup\n          instrument(:prune, target_size, from: @cache_size) do\n            keys = synchronize { @data.keys }\n            keys.each do |key|\n              delete_entry(key, **options)\n              return if @cache_size <= target_size || (max_time && Process.clock_gettime(Process::CLOCK_MONOTONIC) - start_time > max_time)\n            end",
    "comment": "To ensure entries fit within the specified memory prune the cache by removing the least recently accessed entries.",
    "label": "",
    "id": "2994"
  },
  {
    "raw_code": "def pruning?\n        @pruning\n      end",
    "comment": "Returns true if the cache is currently being pruned.",
    "label": "",
    "id": "2995"
  },
  {
    "raw_code": "def increment(name, amount = 1, **options)\n        instrument(:increment, name, amount: amount) do\n          modify_value(name, amount, **options)\n        end",
    "comment": "Increment a cached integer value. Returns the updated value.  If the key is unset, it will be set to +amount+:  cache.increment(\"foo\") # => 1 cache.increment(\"bar\", 100) # => 100  To set a specific value, call #write:  cache.write(\"baz\", 5) cache.increment(\"baz\") # => 6 ",
    "label": "",
    "id": "2996"
  },
  {
    "raw_code": "def decrement(name, amount = 1, **options)\n        instrument(:decrement, name, amount: amount) do\n          modify_value(name, -amount, **options)\n        end",
    "comment": "Decrement a cached integer value. Returns the updated value.  If the key is unset or has expired, it will be set to +-amount+.  cache.decrement(\"foo\") # => -1  To set a specific value, call #write:  cache.write(\"baz\", 5) cache.decrement(\"baz\") # => 4 ",
    "label": "",
    "id": "2997"
  },
  {
    "raw_code": "def delete_matched(matcher, options = nil)\n        options = merged_options(options)\n        matcher = key_matcher(matcher, options)\n\n        instrument(:delete_matched, matcher.inspect) do\n          keys = synchronize { @data.keys }\n          keys.each do |key|\n            delete_entry(key, **options) if key.match(matcher)\n          end",
    "comment": "Deletes cache entries if the cache key matches a given pattern.",
    "label": "",
    "id": "2998"
  },
  {
    "raw_code": "def synchronize(&block) # :nodoc:\n        @monitor.synchronize(&block)\n      end",
    "comment": "Synchronize calls to the cache. This should be called wherever the underlying cache implementation is not thread safe.",
    "label": "",
    "id": "2999"
  },
  {
    "raw_code": "def modify_value(name, amount, **options)\n          options = merged_options(options)\n          key     = normalize_key(name, options)\n          version = normalize_version(name, options)\n\n          synchronize do\n            entry = read_entry(key, **options)\n\n            if !entry || entry.expired? || entry.mismatched?(version)\n              write(name, Integer(amount), options)\n              amount\n            else\n              num = entry.value.to_i + amount\n              entry = Entry.new(num, expires_at: entry.expires_at, version: entry.version)\n              write_entry(key, entry)\n              num\n            end",
    "comment": "Modifies the amount of an integer value that is stored in the cache. If the key is not found it is created and set to +amount+.",
    "label": "",
    "id": "3000"
  },
  {
    "raw_code": "def self.supports_cache_versioning?\n        true\n      end",
    "comment": "Advertise cache versioning support.",
    "label": "",
    "id": "3001"
  },
  {
    "raw_code": "def self.build_mem_cache(*addresses) # :nodoc:\n        addresses = addresses.flatten\n        options = addresses.extract_options!\n        addresses = nil if addresses.compact.empty?\n        pool_options = retrieve_pool_options(options)\n\n        if pool_options\n          ConnectionPool.new(pool_options) { Dalli::Client.new(addresses, options.merge(threadsafe: false)) }\n        else\n          Dalli::Client.new(addresses, options)\n        end",
    "comment": "Creates a new Dalli::Client instance with specified addresses and options. If no addresses are provided, we give nil to Dalli::Client, so it uses its fallbacks: - ENV[\"MEMCACHE_SERVERS\"] (if defined) - \"127.0.0.1:11211\"        (otherwise)  ActiveSupport::Cache::MemCacheStore.build_mem_cache # => #<Dalli::Client:0x007f98a47d2028 @servers=[\"127.0.0.1:11211\"], @options={}, @ring=nil> ActiveSupport::Cache::MemCacheStore.build_mem_cache('localhost:10290') # => #<Dalli::Client:0x007f98a47b3a60 @servers=[\"localhost:10290\"], @options={}, @ring=nil>",
    "label": "",
    "id": "3002"
  },
  {
    "raw_code": "def initialize(*addresses)\n        addresses = addresses.flatten\n        options = addresses.extract_options!\n        if options.key?(:cache_nils)\n          options[:skip_nil] = !options.delete(:cache_nils)\n        end",
    "comment": "Creates a new +MemCacheStore+ object, with the given memcached server addresses. Each address is either a host name, or a host-with-port string in the form of \"host_name:port\". For example:  ActiveSupport::Cache::MemCacheStore.new(\"localhost\", \"server-downstairs.localnetwork:8229\")  If no addresses are provided, but <tt>ENV['MEMCACHE_SERVERS']</tt> is defined, it will be used instead. Otherwise, +MemCacheStore+ will connect to localhost:11211 (the default memcached port).",
    "label": "",
    "id": "3003"
  },
  {
    "raw_code": "def increment(name, amount = 1, options = nil)\n        options = merged_options(options)\n        key = normalize_key(name, options)\n\n        instrument(:increment, key, amount: amount) do\n          rescue_error_with nil do\n            @data.with { |c| c.incr(key, amount, options[:expires_in], amount) }\n          end",
    "comment": " :method: write :call-seq: write(name, value, options = nil)  Behaves the same as ActiveSupport::Cache::Store#write, but supports additional options specific to memcached.  ==== Additional Options  * <tt>raw: true</tt> - Sends the value directly to the server as raw bytes. The value must be a string or number. You can use memcached direct operations like +increment+ and +decrement+ only on raw values. Increment a cached integer value using the memcached incr atomic operator. Returns the updated value.  If the key is unset or has expired, it will be set to +amount+:  cache.increment(\"foo\") # => 1 cache.increment(\"bar\", 100) # => 100  To set a specific value, call #write passing <tt>raw: true</tt>:  cache.write(\"baz\", 5, raw: true) cache.increment(\"baz\") # => 6  Incrementing a non-numeric value, or a value written without <tt>raw: true</tt>, will fail and return +nil+.  To read the value later, call #read_counter:  cache.increment(\"baz\") # => 7 cache.read_counter(\"baz\") # 7",
    "label": "",
    "id": "3004"
  },
  {
    "raw_code": "def decrement(name, amount = 1, options = nil)\n        options = merged_options(options)\n        key = normalize_key(name, options)\n\n        instrument(:decrement, key, amount: amount) do\n          rescue_error_with nil do\n            @data.with { |c| c.decr(key, amount, options[:expires_in], 0) }\n          end",
    "comment": "Decrement a cached integer value using the memcached decr atomic operator. Returns the updated value.  If the key is unset or has expired, it will be set to 0. Memcached does not support negative counters.  cache.decrement(\"foo\") # => 0  To set a specific value, call #write passing <tt>raw: true</tt>:  cache.write(\"baz\", 5, raw: true) cache.decrement(\"baz\") # => 4  Decrementing a non-numeric value, or a value written without <tt>raw: true</tt>, will fail and return +nil+.  To read the value later, call #read_counter:  cache.decrement(\"baz\") # => 3 cache.read_counter(\"baz\") # 3",
    "label": "",
    "id": "3005"
  },
  {
    "raw_code": "def clear(options = nil)\n        rescue_error_with(nil) { @data.with { |c| c.flush_all } }\n      end",
    "comment": "Clear the entire cache on all memcached servers. This method should be used with care when shared cache is being used.",
    "label": "",
    "id": "3006"
  },
  {
    "raw_code": "def stats\n        @data.with { |c| c.stats }\n      end",
    "comment": "Get the statistics from the memcached servers.",
    "label": "",
    "id": "3007"
  },
  {
    "raw_code": "def read_entry(key, **options)\n          deserialize_entry(read_serialized_entry(key, **options), **options)\n        end",
    "comment": "Read an entry from the cache.",
    "label": "",
    "id": "3008"
  },
  {
    "raw_code": "def write_entry(key, entry, **options)\n          write_serialized_entry(key, serialize_entry(entry, **options), **options)\n        end",
    "comment": "Write an entry to the cache.",
    "label": "",
    "id": "3009"
  },
  {
    "raw_code": "def read_multi_entries(names, **options)\n          keys_to_names = names.index_by { |name| normalize_key(name, options) }\n\n          rescue_error_with({}) do\n            raw_values = @data.with { |c| c.get_multi(keys_to_names.keys) }\n\n            values = {}\n\n            raw_values.each do |key, value|\n              entry = deserialize_entry(value, raw: options[:raw])\n\n              unless entry.nil? || entry.expired? || entry.mismatched?(normalize_version(keys_to_names[key], options))\n                begin\n                  values[keys_to_names[key]] = entry.value\n                rescue DeserializationError\n                end",
    "comment": "Reads multiple entries from the cache implementation.",
    "label": "",
    "id": "3010"
  },
  {
    "raw_code": "def delete_entry(key, **options)\n          rescue_error_with(false) { @data.with { |c| c.delete(key) } }\n        end",
    "comment": "Delete an entry from the cache.",
    "label": "",
    "id": "3011"
  },
  {
    "raw_code": "def normalize_key(key, options)\n          key = expand_and_namespace_key(key, options)\n          if key\n            key = key.dup.force_encoding(Encoding::ASCII_8BIT)\n            key = key.gsub(ESCAPE_KEY_CHARS) { |match| \"%#{match.getbyte(0).to_s(16).upcase}\" }\n          end",
    "comment": "Memcache keys are binaries. So we need to force their encoding to binary before applying the regular expression to ensure we are escaping all characters properly.",
    "label": "",
    "id": "3012"
  },
  {
    "raw_code": "def self.supports_cache_versioning?\n        true\n      end",
    "comment": "Advertise cache versioning support.",
    "label": "",
    "id": "3013"
  },
  {
    "raw_code": "def self.supports_cache_versioning?\n        true\n      end",
    "comment": "Advertise cache versioning support.",
    "label": "",
    "id": "3014"
  },
  {
    "raw_code": "def build_redis(redis: nil, url: nil, **redis_options) # :nodoc:\n          urls = Array(url)\n\n          if redis.is_a?(Proc)\n            redis.call\n          elsif redis\n            redis\n          elsif urls.size > 1\n            build_redis_distributed_client(urls: urls, **redis_options)\n          elsif urls.empty?\n            build_redis_client(**redis_options)\n          else\n            build_redis_client(url: urls.first, **redis_options)\n          end",
    "comment": "Factory method to create a new Redis instance.  Handles four options: :redis block, :redis instance, single :url string, and multiple :url strings.  Option  Class       Result :redis  Proc    ->  options[:redis].call :redis  Object  ->  options[:redis] :url    String  ->  Redis.new(url: …) :url    Array   ->  Redis::Distributed.new([{ url: … }, { url: … }, …]) ",
    "label": "",
    "id": "3015"
  },
  {
    "raw_code": "def initialize(error_handler: DEFAULT_ERROR_HANDLER, **redis_options)\n        universal_options = redis_options.extract!(*UNIVERSAL_OPTIONS)\n        redis = redis_options[:redis]\n\n        already_pool = redis.instance_of?(::ConnectionPool) ||\n                       (redis.respond_to?(:wrapped_pool) && redis.wrapped_pool.instance_of?(::ConnectionPool))\n\n        if !already_pool && pool_options = self.class.send(:retrieve_pool_options, redis_options)\n          @redis = ::ConnectionPool.new(pool_options) { self.class.build_redis(**redis_options) }\n        else\n          @redis = self.class.build_redis(**redis_options)\n        end",
    "comment": "Creates a new Redis cache store.  There are a few ways to provide the Redis client used by the cache:  1. The +:redis+ param can be: - A Redis instance. - A +ConnectionPool+ instance wrapping a Redis instance. - A block that returns a Redis instance.  2. The +:url+ param can be: - A string used to create a Redis instance. - An array of strings used to create a +Redis::Distributed+ instance.  If the final Redis instance is not already a +ConnectionPool+, it will be wrapped in one using +ActiveSupport::Cache::Store::DEFAULT_POOL_OPTIONS+. These options can be overridden with the +:pool+ param, or the pool can be disabled with +:pool: false+.  Option  Class       Result :redis  Object  ->  options[:redis] :redis  Proc    ->  options[:redis].call :url    String  ->  Redis.new(url: …) :url    Array   ->  Redis::Distributed.new([{ url: … }, { url: … }, …])  No namespace is set by default. Provide one if the Redis cache server is shared with other apps: <tt>namespace: 'myapp-cache'</tt>.  Compression is enabled by default with a 1kB threshold, so cached values larger than 1kB are automatically compressed. Disable by passing <tt>compress: false</tt> or change the threshold by passing <tt>compress_threshold: 4.kilobytes</tt>.  No expiry is set on cache entries by default. Redis is expected to be configured with an eviction policy that automatically deletes least-recently or -frequently used keys when it reaches max memory. See https://redis.io/topics/lru-cache for cache server setup.  Race condition TTL is not set by default. This can be used to avoid \"thundering herd\" cache writes when hot cache entries are expired. See ActiveSupport::Cache::Store#fetch for more.  Setting <tt>skip_nil: true</tt> will not cache nil results:  cache.fetch('foo') { nil } cache.fetch('bar', skip_nil: true) { nil } cache.exist?('foo') # => true cache.exist?('bar') # => false",
    "label": "",
    "id": "3016"
  },
  {
    "raw_code": "def read_multi(*names)\n        return {} if names.empty?\n\n        options = names.extract_options!\n        options = merged_options(options)\n        keys    = names.map { |name| normalize_key(name, options) }\n\n        instrument_multi(:read_multi, keys, options) do |payload|\n          read_multi_entries(names, **options).tap do |results|\n            payload[:hits] = results.keys.map { |name| normalize_key(name, options) }\n          end",
    "comment": "Cache Store API implementation.  Read multiple values at once. Returns a hash of requested keys -> fetched values.",
    "label": "",
    "id": "3017"
  },
  {
    "raw_code": "def delete_matched(matcher, options = nil)\n        unless String === matcher\n          raise ArgumentError, \"Only Redis glob strings are supported: #{matcher.inspect}\"\n        end",
    "comment": "Cache Store API implementation.  Supports Redis KEYS glob patterns:  h?llo matches hello, hallo and hxllo h*llo matches hllo and heeeello h[ae]llo matches hello and hallo, but not hillo h[^e]llo matches hallo, hbllo, ... but not hello h[a-b]llo matches hallo and hbllo  Use \\ to escape special characters if you want to match them verbatim.  See https://redis.io/commands/KEYS for more.  Failsafe: Raises errors.",
    "label": "",
    "id": "3018"
  },
  {
    "raw_code": "def increment(name, amount = 1, options = nil)\n        options = merged_options(options)\n        key = normalize_key(name, options)\n\n        instrument :increment, key, amount: amount do\n          failsafe :increment do\n            change_counter(key, amount, options)\n          end",
    "comment": "Increment a cached integer value using the Redis incrby atomic operator. Returns the updated value.  If the key is unset or has expired, it will be set to +amount+:  cache.increment(\"foo\") # => 1 cache.increment(\"bar\", 100) # => 100  To set a specific value, call #write passing <tt>raw: true</tt>:  cache.write(\"baz\", 5, raw: true) cache.increment(\"baz\") # => 6  Incrementing a non-numeric value, or a value written without <tt>raw: true</tt>, will fail and return +nil+.  To read the value later, call #read_counter:  cache.increment(\"baz\") # => 7 cache.read_counter(\"baz\") # 7  Failsafe: Raises errors.",
    "label": "",
    "id": "3019"
  },
  {
    "raw_code": "def decrement(name, amount = 1, options = nil)\n        options = merged_options(options)\n        key = normalize_key(name, options)\n\n        instrument :decrement, key, amount: amount do\n          failsafe :decrement do\n            change_counter(key, -amount, options)\n          end",
    "comment": "Decrement a cached integer value using the Redis decrby atomic operator. Returns the updated value.  If the key is unset or has expired, it will be set to +-amount+:  cache.decrement(\"foo\") # => -1  To set a specific value, call #write passing <tt>raw: true</tt>:  cache.write(\"baz\", 5, raw: true) cache.decrement(\"baz\") # => 4  Decrementing a non-numeric value, or a value written without <tt>raw: true</tt>, will fail and return +nil+.  To read the value later, call #read_counter:  cache.decrement(\"baz\") # => 3 cache.read_counter(\"baz\") # 3  Failsafe: Raises errors.",
    "label": "",
    "id": "3020"
  },
  {
    "raw_code": "def cleanup(options = nil)\n        super\n      end",
    "comment": "Cache Store API implementation.  Removes expired entries. Handled natively by Redis least-recently-/ least-frequently-used expiry, so manual cleanup is not supported.",
    "label": "",
    "id": "3021"
  },
  {
    "raw_code": "def clear(options = nil)\n        failsafe :clear do\n          if namespace = merged_options(options)[:namespace]\n            delete_matched \"*\", namespace: namespace\n          else\n            redis.then { |c| c.flushdb }\n          end",
    "comment": "Clear the entire cache on all Redis servers. Safe to use on shared servers if the cache is namespaced.  Failsafe: Raises errors.",
    "label": "",
    "id": "3022"
  },
  {
    "raw_code": "def stats\n        redis.then { |c| c.info }\n      end",
    "comment": "Get info from redis servers.",
    "label": "",
    "id": "3023"
  },
  {
    "raw_code": "def read_entry(key, **options)\n          deserialize_entry(read_serialized_entry(key, **options), **options)\n        end",
    "comment": "Store provider interface: Read an entry from the cache.",
    "label": "",
    "id": "3024"
  },
  {
    "raw_code": "def write_entry(key, entry, raw: false, **options)\n          write_serialized_entry(key, serialize_entry(entry, raw: raw, **options), raw: raw, **options)\n        end",
    "comment": "Write an entry to the cache.  Requires Redis 2.6.12+ for extended SET options.",
    "label": "",
    "id": "3025"
  },
  {
    "raw_code": "def delete_entry(key, **options)\n          failsafe :delete_entry, returning: false do\n            redis.then { |c| c.unlink(key) == 1 }\n          end",
    "comment": "Delete an entry from the cache.",
    "label": "",
    "id": "3026"
  },
  {
    "raw_code": "def delete_multi_entries(entries, **_options)\n          return 0 if entries.empty?\n\n          failsafe :delete_multi_entries, returning: 0 do\n            redis.then { |c| c.unlink(*entries) }\n          end",
    "comment": "Deletes multiple entries in the cache. Returns the number of entries deleted.",
    "label": "",
    "id": "3027"
  },
  {
    "raw_code": "def write_multi_entries(entries, **options)\n          return if entries.empty?\n\n          failsafe :write_multi_entries do\n            pipeline_entries(entries) do |pipeline, sharded_entries|\n              options = options.dup\n              options[:pipeline] = pipeline\n              sharded_entries.each do |key, entry|\n                write_entry key, entry, **options\n              end",
    "comment": "Nonstandard store provider API to write multiple values at once.",
    "label": "",
    "id": "3028"
  },
  {
    "raw_code": "def with_local_cache(&block)\n          use_temporary_local_cache(LocalStore.new, &block)\n        end",
    "comment": "Use a local cache for the duration of block.",
    "label": "",
    "id": "3029"
  },
  {
    "raw_code": "def new_local_cache\n          LocalCacheRegistry.set_cache_for(local_cache_key, LocalStore.new)\n        end",
    "comment": "Set a new local cache.",
    "label": "",
    "id": "3030"
  },
  {
    "raw_code": "def unset_local_cache\n          LocalCacheRegistry.set_cache_for(local_cache_key, nil)\n        end",
    "comment": "Unset the current local cache.",
    "label": "",
    "id": "3031"
  },
  {
    "raw_code": "def local_cache\n          LocalCacheRegistry.cache_for(local_cache_key)\n        end",
    "comment": "The current local cache.",
    "label": "",
    "id": "3032"
  },
  {
    "raw_code": "def middleware\n          @middleware ||= Middleware.new(\"ActiveSupport::Cache::Strategy::LocalCache\", self)\n        end",
    "comment": "Middleware class can be inserted as a Rack handler to be local cache for the duration of request.",
    "label": "",
    "id": "3033"
  },
  {
    "raw_code": "def raw_state # :nodoc:\n        synchronize do\n          threads = @sleeping.keys | @sharing.keys | @waiting.keys\n          threads |= [@exclusive_thread] if @exclusive_thread\n\n          data = {}\n\n          threads.each do |thread|\n            purpose, compatible = @waiting[thread]\n\n            data[thread] = {\n              thread: thread,\n              sharing: @sharing[thread],\n              exclusive: @exclusive_thread == thread,\n              purpose: purpose,\n              compatible: compatible,\n              waiting: !!@waiting[thread],\n              sleeper: @sleeping[thread],\n            }\n          end",
    "comment": "We track Thread objects, instead of just using counters, because we need exclusive locks to be reentrant, and we need to be able to upgrade share locks to exclusive.",
    "label": "",
    "id": "3034"
  },
  {
    "raw_code": "def start_exclusive(purpose: nil, compatible: [], no_wait: false)\n        synchronize do\n          unless @exclusive_thread == Thread.current\n            if busy_for_exclusive?(purpose)\n              return false if no_wait\n\n              yield_shares(purpose: purpose, compatible: compatible, block_share: true) do\n                wait_for(:start_exclusive) { busy_for_exclusive?(purpose) }\n              end",
    "comment": "Returns false if +no_wait+ is set and the lock is not immediately available. Otherwise, returns true after the lock has been acquired.  +purpose+ and +compatible+ work together; while this thread is waiting for the exclusive lock, it will yield its share (if any) to any other attempt whose +purpose+ appears in this attempt's +compatible+ list. This allows a \"loose\" upgrade, which, being less strict, prevents some classes of deadlocks.  For many resources, loose upgrades are sufficient: if a thread is awaiting a lock, it is not running any other code. With +purpose+ matching, it is possible to yield only to other threads whose activity will not interfere.",
    "label": "",
    "id": "3035"
  },
  {
    "raw_code": "def stop_exclusive(compatible: [])\n        synchronize do\n          raise \"invalid unlock\" if @exclusive_thread != Thread.current\n\n          @exclusive_depth -= 1\n          if @exclusive_depth == 0\n            @exclusive_thread = nil\n\n            if eligible_waiters?(compatible)\n              yield_shares(compatible: compatible, block_share: true) do\n                wait_for(:stop_exclusive) { @exclusive_thread || eligible_waiters?(compatible) }\n              end",
    "comment": "Relinquish the exclusive lock. Must only be called by the thread that called start_exclusive (and currently holds the lock).",
    "label": "",
    "id": "3036"
  },
  {
    "raw_code": "def exclusive(purpose: nil, compatible: [], after_compatible: [], no_wait: false)\n        if start_exclusive(purpose: purpose, compatible: compatible, no_wait: no_wait)\n          begin\n            yield\n          ensure\n            stop_exclusive(compatible: after_compatible)\n          end",
    "comment": "Execute the supplied block while holding the Exclusive lock. If +no_wait+ is set and the lock is not immediately available, returns +nil+ without yielding. Otherwise, returns the result of the block.  See +start_exclusive+ for other options.",
    "label": "",
    "id": "3037"
  },
  {
    "raw_code": "def sharing\n        start_sharing\n        begin\n          yield\n        ensure\n          stop_sharing\n        end",
    "comment": "Execute the supplied block while holding the Share lock.",
    "label": "",
    "id": "3038"
  },
  {
    "raw_code": "def yield_shares(purpose: nil, compatible: [], block_share: false)\n        loose_shares = previous_wait = nil\n        synchronize do\n          if loose_shares = @sharing.delete(Thread.current)\n            if previous_wait = @waiting[Thread.current]\n              purpose = nil unless purpose == previous_wait[0]\n              compatible &= previous_wait[1]\n            end",
    "comment": "Temporarily give up all held Share locks while executing the supplied block, allowing any +compatible+ exclusive lock request to proceed.",
    "label": "",
    "id": "3039"
  },
  {
    "raw_code": "def busy_for_exclusive?(purpose)\n          busy_for_sharing?(purpose) ||\n            @sharing.size > (@sharing[Thread.current] > 0 ? 1 : 0)\n        end",
    "comment": "Must be called within synchronize",
    "label": "",
    "id": "3040"
  },
  {
    "raw_code": "def minimum(key)\n    map(&key).min\n  end",
    "comment": "Calculates the minimum from the extracted elements.  payments = [Payment.new(5), Payment.new(15), Payment.new(10)] payments.minimum(:price) # => 5",
    "label": "",
    "id": "3041"
  },
  {
    "raw_code": "def maximum(key)\n    map(&key).max\n  end",
    "comment": "Calculates the maximum from the extracted elements.  payments = [Payment.new(5), Payment.new(15), Payment.new(10)] payments.maximum(:price) # => 15",
    "label": "",
    "id": "3042"
  },
  {
    "raw_code": "def index_by\n    if block_given?\n      result = {}\n      each { |elem| result[yield(elem)] = elem }\n      result\n    else\n      to_enum(:index_by) { size if respond_to?(:size) }\n    end",
    "comment": "Convert an enumerable to a hash, using the block result as the key and the element as the value.  people.index_by(&:login) # => { \"nextangle\" => <Person ...>, \"chade-\" => <Person ...>, ...}  people.index_by { |person| \"#{person.first_name} #{person.last_name}\" } # => { \"Chade- Fowlersburg-e\" => <Person ...>, \"David Heinemeier Hansson\" => <Person ...>, ...}",
    "label": "",
    "id": "3043"
  },
  {
    "raw_code": "def index_with(default = (no_default = true))\n    if block_given?\n      result = {}\n      each { |elem| result[elem] = yield(elem) }\n      result\n    elsif no_default\n      to_enum(:index_with) { size if respond_to?(:size) }\n    else\n      result = {}\n      each { |elem| result[elem] = default }\n      result\n    end",
    "comment": "Convert an enumerable to a hash, using the element as the key and the block result as the value.  post = Post.new(title: \"hey there\", body: \"what's up?\")  %i( title body ).index_with { |attr_name| post.public_send(attr_name) } # => { title: \"hey there\", body: \"what's up?\" }  If an argument is passed instead of a block, it will be used as the value for all elements:  %i( created_at updated_at ).index_with(Time.now) # => { created_at: 2020-03-09 22:31:47, updated_at: 2020-03-09 22:31:47 }",
    "label": "",
    "id": "3044"
  },
  {
    "raw_code": "def many?\n    cnt = 0\n    if block_given?\n      any? do |*args|\n        cnt += 1 if yield(*args)\n        cnt > 1\n      end",
    "comment": "Returns +true+ if the enumerable has more than 1 element. Functionally equivalent to <tt>enum.to_a.size > 1</tt>. Can be called with a block too, much like any?, so <tt>people.many? { |p| p.age > 26 }</tt> returns +true+ if more than one person is over 26.",
    "label": "",
    "id": "3045"
  },
  {
    "raw_code": "def including(*elements)\n    to_a.including(*elements)\n  end",
    "comment": "Returns a new array that includes the passed elements.  [ 1, 2, 3 ].including(4, 5) # => [ 1, 2, 3, 4, 5 ]  [\"David\", \"Rafael\"].including %w[ Aaron Todd ] # => [\"David\", \"Rafael\", \"Aaron\", \"Todd\"]",
    "label": "",
    "id": "3046"
  },
  {
    "raw_code": "def exclude?(object)\n    !include?(object)\n  end",
    "comment": "The negative of the <tt>Enumerable#include?</tt>. Returns +true+ if the collection does not include the object.",
    "label": "",
    "id": "3047"
  },
  {
    "raw_code": "def excluding(*elements)\n    elements.flatten!(1)\n    reject { |element| elements.include?(element) }\n  end",
    "comment": "Returns a copy of the enumerable excluding the specified elements.  [\"David\", \"Rafael\", \"Aaron\", \"Todd\"].excluding \"Aaron\", \"Todd\" # => [\"David\", \"Rafael\"]  [\"David\", \"Rafael\", \"Aaron\", \"Todd\"].excluding %w[ Aaron Todd ] # => [\"David\", \"Rafael\"]  {foo: 1, bar: 2, baz: 3}.excluding :bar # => {foo: 1, baz: 3}",
    "label": "",
    "id": "3048"
  },
  {
    "raw_code": "def pluck(*keys)\n    if keys.many?\n      map { |element| keys.map { |key| element[key] } }\n    else\n      key = keys.first\n      map { |element| element[key] }\n    end",
    "comment": "Extract the given key from each element in the enumerable.  [{ name: \"David\" }, { name: \"Rafael\" }, { name: \"Aaron\" }].pluck(:name) # => [\"David\", \"Rafael\", \"Aaron\"]  [{ id: 1, name: \"David\" }, { id: 2, name: \"Rafael\" }].pluck(:id, :name) # => [[1, \"David\"], [2, \"Rafael\"]]",
    "label": "",
    "id": "3049"
  },
  {
    "raw_code": "def pick(*keys)\n    return if none?\n\n    if keys.many?\n      keys.map { |key| first[key] }\n    else\n      first[keys.first]\n    end",
    "comment": "Extract the given key from the first element in the enumerable.  [{ name: \"David\" }, { name: \"Rafael\" }, { name: \"Aaron\" }].pick(:name) # => \"David\"  [{ id: 1, name: \"David\" }, { id: 2, name: \"Rafael\" }].pick(:id, :name) # => [1, \"David\"]",
    "label": "",
    "id": "3050"
  },
  {
    "raw_code": "def compact_blank\n    reject(&:blank?)\n  end",
    "comment": "Returns a new +Array+ without the blank items. Uses Object#blank? for determining if an item is blank.  [1, \"\", nil, 2, \" \", [], {}, false, true].compact_blank # =>  [1, 2, true]  Set.new([nil, \"\", 1, false]).compact_blank # => [1]  When called on a +Hash+, returns a new +Hash+ without the blank values.  { a: \"\", b: 1, c: nil, d: [], e: false, f: true }.compact_blank # => { b: 1, f: true }",
    "label": "",
    "id": "3051"
  },
  {
    "raw_code": "def in_order_of(key, series, filter: true)\n    if filter\n      group_by(&key).values_at(*series).flatten(1).compact\n    else\n      sort_by { |v| series.index(v.public_send(key)) || series.size }.compact\n    end",
    "comment": "Returns a new +Array+ where the order has been set to that provided in the +series+, based on the +key+ of the objects in the original enumerable.  [ Person.find(5), Person.find(3), Person.find(1) ].in_order_of(:id, [ 1, 5, 3 ]) # => [ Person.find(1), Person.find(5), Person.find(3) ]  If the +series+ include keys that have no corresponding element in the Enumerable, these are ignored. If the Enumerable has additional elements that aren't named in the +series+, these are not included in the result, unless the +filter+ option is set to +false+.",
    "label": "",
    "id": "3052"
  },
  {
    "raw_code": "def sole\n    result = nil\n    found = false\n\n    each do |*element|\n      if found\n        raise SoleItemExpectedError, \"multiple items found\"\n      end",
    "comment": "Returns the sole item in the enumerable. If there are no items, or more than one item, raises Enumerable::SoleItemExpectedError.  [\"x\"].sole          # => \"x\" Set.new.sole        # => Enumerable::SoleItemExpectedError: no item found { a: 1, b: 2 }.sole # => Enumerable::SoleItemExpectedError: multiple items found",
    "label": "",
    "id": "3053"
  },
  {
    "raw_code": "def compact_blank # :nodoc:\n    reject { |_k, v| v.blank? }\n  end",
    "comment": "Hash#reject has its own definition, so this needs one too.",
    "label": "",
    "id": "3054"
  },
  {
    "raw_code": "def compact_blank!\n    # use delete_if rather than reject! because it always returns self even if nothing changed\n    delete_if { |_k, v| v.blank? }\n  end",
    "comment": "Removes all blank values from the +Hash+ in place and returns self. Uses Object#blank? for determining if a value is blank.  h = { a: \"\", b: 1, c: nil, d: [], e: false, f: true } h.compact_blank! # => { b: 1, f: true }",
    "label": "",
    "id": "3055"
  },
  {
    "raw_code": "def sum(initial_value = 0)\n    if block_given? || !(first.is_a?(Integer) && last.is_a?(Integer))\n      super\n    else\n      actual_last = exclude_end? ? (last - 1) : last\n      if actual_last >= first\n        sum = initial_value || 0\n        sum + (actual_last - first + 1) * (actual_last + first) / 2\n      else\n        initial_value || 0\n      end",
    "comment": "Optimize range sum to use arithmetic progression if a block is not given and we have a range of numeric values.",
    "label": "",
    "id": "3056"
  },
  {
    "raw_code": "def compact_blank!\n    # use delete_if rather than reject! because it always returns self even if nothing changed\n    delete_if(&:blank?)\n  end",
    "comment": "Removes all blank elements from the +Array+ in place and returns self. Uses Object#blank? for determining if an item is blank.  a = [1, \"\", nil, 2, \" \", [], {}, false, true] a.compact_blank! # =>  [1, 2, true]",
    "label": "",
    "id": "3057"
  },
  {
    "raw_code": "def is_missing?(location)\n    location.delete_suffix(\".rb\") == path.to_s.delete_suffix(\".rb\")\n  end",
    "comment": "Returns true if the given path name (except perhaps for the \".rb\" extension) is the missing file which caused the exception to be raised.",
    "label": "",
    "id": "3058"
  },
  {
    "raw_code": "def missing_name\n    # Since ruby v2.3.0 `did_you_mean` gem is loaded by default.\n    # It extends NameError#message with spell corrections which are SLOW.\n    # We should use original_message message instead.\n    message = respond_to?(:original_message) ? original_message : self.message\n    return unless message.start_with?(\"uninitialized constant \")\n\n    receiver = begin\n      self.receiver\n    rescue ArgumentError\n      nil\n    end",
    "comment": "Extract the name of the missing constant from the exception message.  begin HelloWorld rescue NameError => e e.missing_name end # => \"HelloWorld\"",
    "label": "",
    "id": "3059"
  },
  {
    "raw_code": "def missing_name?(name)\n    if name.is_a? Symbol\n      self.name == name\n    else\n      missing_name == name.to_s\n    end",
    "comment": "Was this exception raised because the given name was missing?  begin HelloWorld rescue NameError => e e.missing_name?(\"HelloWorld\") end # => true",
    "label": "",
    "id": "3060"
  },
  {
    "raw_code": "def multiline?\n    options & MULTILINE == MULTILINE\n  end",
    "comment": "Returns +true+ if the regexp has the multiline flag set.  (/./).multiline?  # => false (/./m).multiline? # => true  Regexp.new(\".\").multiline?                    # => false Regexp.new(\".\", Regexp::MULTILINE).multiline? # => true",
    "label": "",
    "id": "3061"
  },
  {
    "raw_code": "def from(position)\n    self[position, length] || []\n  end",
    "comment": "Returns the tail of the array from +position+.  %w( a b c d ).from(0)  # => [\"a\", \"b\", \"c\", \"d\"] %w( a b c d ).from(2)  # => [\"c\", \"d\"] %w( a b c d ).from(10) # => [] %w().from(0)           # => [] %w( a b c d ).from(-2) # => [\"c\", \"d\"] %w( a b c ).from(-10)  # => []",
    "label": "",
    "id": "3062"
  },
  {
    "raw_code": "def to(position)\n    if position >= 0\n      take position + 1\n    else\n      self[0..position]\n    end",
    "comment": "Returns the beginning of the array up to +position+.  %w( a b c d ).to(0)  # => [\"a\"] %w( a b c d ).to(2)  # => [\"a\", \"b\", \"c\"] %w( a b c d ).to(10) # => [\"a\", \"b\", \"c\", \"d\"] %w().to(0)           # => [] %w( a b c d ).to(-2) # => [\"a\", \"b\", \"c\"] %w( a b c ).to(-10)  # => []",
    "label": "",
    "id": "3063"
  },
  {
    "raw_code": "def including(*elements)\n    self + elements.flatten(1)\n  end",
    "comment": "Returns a new array that includes the passed elements.  [ 1, 2, 3 ].including(4, 5) # => [ 1, 2, 3, 4, 5 ] [ [ 0, 1 ] ].including([ [ 1, 0 ] ]) # => [ [ 0, 1 ], [ 1, 0 ] ]",
    "label": "",
    "id": "3064"
  },
  {
    "raw_code": "def excluding(*elements)\n    self - elements.flatten(1)\n  end",
    "comment": "Returns a copy of the Array excluding the specified elements.  [\"David\", \"Rafael\", \"Aaron\", \"Todd\"].excluding(\"Aaron\", \"Todd\") # => [\"David\", \"Rafael\"] [ [ 0, 1 ], [ 1, 0 ] ].excluding([ [ 1, 0 ] ]) # => [ [ 0, 1 ] ]  Note: This is an optimization of <tt>Enumerable#excluding</tt> that uses <tt>Array#-</tt> instead of <tt>Array#reject</tt> for performance reasons.",
    "label": "",
    "id": "3065"
  },
  {
    "raw_code": "def second\n    self[1]\n  end",
    "comment": "Equal to <tt>self[1]</tt>.  %w( a b c d e ).second # => \"b\"",
    "label": "",
    "id": "3066"
  },
  {
    "raw_code": "def third\n    self[2]\n  end",
    "comment": "Equal to <tt>self[2]</tt>.  %w( a b c d e ).third # => \"c\"",
    "label": "",
    "id": "3067"
  },
  {
    "raw_code": "def fourth\n    self[3]\n  end",
    "comment": "Equal to <tt>self[3]</tt>.  %w( a b c d e ).fourth # => \"d\"",
    "label": "",
    "id": "3068"
  },
  {
    "raw_code": "def fifth\n    self[4]\n  end",
    "comment": "Equal to <tt>self[4]</tt>.  %w( a b c d e ).fifth # => \"e\"",
    "label": "",
    "id": "3069"
  },
  {
    "raw_code": "def forty_two\n    self[41]\n  end",
    "comment": "Equal to <tt>self[41]</tt>. Also known as accessing \"the reddit\".  (1..42).to_a.forty_two # => 42",
    "label": "",
    "id": "3070"
  },
  {
    "raw_code": "def third_to_last\n    self[-3]\n  end",
    "comment": "Equal to <tt>self[-3]</tt>.  %w( a b c d e ).third_to_last # => \"c\"",
    "label": "",
    "id": "3071"
  },
  {
    "raw_code": "def second_to_last\n    self[-2]\n  end",
    "comment": "Equal to <tt>self[-2]</tt>.  %w( a b c d e ).second_to_last # => \"d\"",
    "label": "",
    "id": "3072"
  },
  {
    "raw_code": "def to_sentence(options = {})\n    options.assert_valid_keys(:words_connector, :two_words_connector, :last_word_connector, :locale)\n\n    default_connectors = {\n      words_connector: \", \",\n      two_words_connector: \" and \",\n      last_word_connector: \", and \"\n    }\n    if options[:locale] != false && defined?(I18n)\n      i18n_connectors = I18n.translate(:'support.array', locale: options[:locale], default: {})\n      default_connectors.merge!(i18n_connectors)\n    end",
    "comment": "Converts the array to a comma-separated sentence where the last element is joined by the connector word.  You can pass the following options to change the default behavior. If you pass an option key that doesn't exist in the list below, it will raise an <tt>ArgumentError</tt>.  ==== Options  * <tt>:words_connector</tt> - The sign or word used to join all but the last element in arrays with three or more elements (default: <tt>\", \"</tt>). * <tt>:last_word_connector</tt> - The sign or word used to join the last element in arrays with three or more elements (default: <tt>\", and \"</tt>). * <tt>:two_words_connector</tt> - The sign or word used to join the elements in arrays with two elements (default: <tt>\" and \"</tt>). * <tt>:locale</tt> - If +i18n+ is available, you can set a locale and use the connector options defined on the 'support.array' namespace in the corresponding dictionary file.  ==== Examples  [].to_sentence                      # => \"\" ['one'].to_sentence                 # => \"one\" ['one', 'two'].to_sentence          # => \"one and two\" ['one', 'two', 'three'].to_sentence # => \"one, two, and three\"  ['one', 'two'].to_sentence(passing: 'invalid option') # => ArgumentError: Unknown key: :passing. Valid keys are: :words_connector, :two_words_connector, :last_word_connector, :locale  ['one', 'two'].to_sentence(two_words_connector: '-') # => \"one-two\"  ['one', 'two', 'three'].to_sentence(words_connector: ' or ', last_word_connector: ' or at least ') # => \"one or two or at least three\"  Using <tt>:locale</tt> option:  # Given this locale dictionary: # #   es: #     support: #       array: #         words_connector: \" o \" #         two_words_connector: \" y \" #         last_word_connector: \" o al menos \"  ['uno', 'dos'].to_sentence(locale: :es) # => \"uno y dos\"  ['uno', 'dos', 'tres'].to_sentence(locale: :es) # => \"uno o dos o al menos tres\"",
    "label": "",
    "id": "3073"
  },
  {
    "raw_code": "def to_fs(format = :default)\n    case format\n    when :db\n      if empty?\n        \"null\"\n      else\n        collect(&:id).join(\",\")\n      end",
    "comment": "Extends <tt>Array#to_s</tt> to convert a collection of elements into a comma separated id list if <tt>:db</tt> argument is given as the format.  This method is aliased to <tt>to_formatted_s</tt>.  Blog.all.to_fs(:db)  # => \"1,2,3\" Blog.none.to_fs(:db) # => \"null\" [1,2].to_fs          # => \"[1, 2]\"",
    "label": "",
    "id": "3074"
  },
  {
    "raw_code": "def to_xml(options = {})\n    require \"active_support/builder\" unless defined?(Builder::XmlMarkup)\n\n    options = options.dup\n    options[:indent]  ||= 2\n    options[:builder] ||= Builder::XmlMarkup.new(indent: options[:indent])\n    options[:root]    ||= \\\n      if first.class != Hash && all?(first.class)\n        underscored = ActiveSupport::Inflector.underscore(first.class.name)\n        ActiveSupport::Inflector.pluralize(underscored).tr(\"/\", \"_\")\n      else\n        \"objects\"\n      end",
    "comment": "Returns a string that represents the array in XML by invoking +to_xml+ on each element. Active Record collections delegate their representation in XML to this method.  All elements are expected to respond to +to_xml+, if any of them does not then an exception is raised.  The root node reflects the class name of the first element in plural if all elements belong to the same type and that's not Hash:  customer.projects.to_xml  <?xml version=\"1.0\" encoding=\"UTF-8\"?> <projects type=\"array\"> <project> <amount type=\"decimal\">20000.0</amount> <customer-id type=\"integer\">1567</customer-id> <deal-date type=\"date\">2008-04-09</deal-date> ... </project> <project> <amount type=\"decimal\">57230.0</amount> <customer-id type=\"integer\">1567</customer-id> <deal-date type=\"date\">2008-04-15</deal-date> ... </project> </projects>  Otherwise the root element is \"objects\":  [{ foo: 1, bar: 2}, { baz: 3}].to_xml  <?xml version=\"1.0\" encoding=\"UTF-8\"?> <objects type=\"array\"> <object> <bar type=\"integer\">2</bar> <foo type=\"integer\">1</foo> </object> <object> <baz type=\"integer\">3</baz> </object> </objects>  If the collection is empty the root element is \"nil-classes\" by default:  [].to_xml  <?xml version=\"1.0\" encoding=\"UTF-8\"?> <nil-classes type=\"array\"/>  To ensure a meaningful root element use the <tt>:root</tt> option:  customer_with_no_projects.projects.to_xml(root: 'projects')  <?xml version=\"1.0\" encoding=\"UTF-8\"?> <projects type=\"array\"/>  By default name of the node for the children of root is <tt>root.singularize</tt>. You can change it with the <tt>:children</tt> option.  The +options+ hash is passed downwards:  Message.all.to_xml(skip_types: true)  <?xml version=\"1.0\" encoding=\"UTF-8\"?> <messages> <message> <created-at>2008-03-07T09:58:18+01:00</created-at> <id>1</id> <name>1</name> <updated-at>2008-03-07T09:58:18+01:00</updated-at> <user-id>1</user-id> </message> </messages> ",
    "label": "",
    "id": "3075"
  },
  {
    "raw_code": "def extract!\n    return to_enum(:extract!) { size } unless block_given?\n\n    extracted_elements = []\n\n    reject! do |element|\n      extracted_elements << element if yield(element)\n    end",
    "comment": "Removes and returns the elements for which the block returns a true value. If no block is given, an Enumerator is returned instead.  numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] odd_numbers = numbers.extract! { |number| number.odd? } # => [1, 3, 5, 7, 9] numbers # => [0, 2, 4, 6, 8]",
    "label": "",
    "id": "3076"
  },
  {
    "raw_code": "def extractable_options?\n    instance_of?(Hash)\n  end",
    "comment": "By default, only instances of Hash itself are extractable. Subclasses of Hash may implement this method and return true to declare themselves as extractable. If a Hash is extractable, Array#extract_options! pops it from the Array when it is the last element of the Array.",
    "label": "",
    "id": "3077"
  },
  {
    "raw_code": "def extract_options!\n    if last.is_a?(Hash) && last.extractable_options?\n      pop\n    else\n      {}\n    end",
    "comment": "Extracts options from a set of arguments. Removes and returns the last element in the array if it's a hash, otherwise returns a blank hash.  def options(*args) args.extract_options! end  options(1, 2)        # => {} options(1, 2, a: :b) # => {:a=>:b}",
    "label": "",
    "id": "3078"
  },
  {
    "raw_code": "def in_groups_of(number, fill_with = nil, &block)\n    if number.to_i <= 0\n      raise ArgumentError,\n        \"Group size must be a positive integer, was #{number.inspect}\"\n    end",
    "comment": "Splits or iterates over the array in groups of size +number+, padding any remaining slots with +fill_with+ unless it is +false+.  %w(1 2 3 4 5 6 7 8 9 10).in_groups_of(3) {|group| p group} [\"1\", \"2\", \"3\"] [\"4\", \"5\", \"6\"] [\"7\", \"8\", \"9\"] [\"10\", nil, nil]  %w(1 2 3 4 5).in_groups_of(2, '&nbsp;') {|group| p group} [\"1\", \"2\"] [\"3\", \"4\"] [\"5\", \"&nbsp;\"]  %w(1 2 3 4 5).in_groups_of(2, false) {|group| p group} [\"1\", \"2\"] [\"3\", \"4\"] [\"5\"]",
    "label": "",
    "id": "3079"
  },
  {
    "raw_code": "def in_groups(number, fill_with = nil, &block)\n    # size.div number gives minor group size;\n    # size % number gives how many objects need extra accommodation;\n    # each group hold either division or division + 1 items.\n    division = size.div number\n    modulo = size % number\n\n    # create a new array avoiding dup\n    groups = []\n    start = 0\n\n    number.times do |index|\n      length = division + (modulo > 0 && modulo > index ? 1 : 0)\n      groups << last_group = slice(start, length)\n      last_group << fill_with if fill_with != false &&\n        modulo > 0 && length == division\n      start += length\n    end",
    "comment": "Splits or iterates over the array in +number+ of groups, padding any remaining slots with +fill_with+ unless it is +false+.  %w(1 2 3 4 5 6 7 8 9 10).in_groups(3) {|group| p group} [\"1\", \"2\", \"3\", \"4\"] [\"5\", \"6\", \"7\", nil] [\"8\", \"9\", \"10\", nil]  %w(1 2 3 4 5 6 7 8 9 10).in_groups(3, '&nbsp;') {|group| p group} [\"1\", \"2\", \"3\", \"4\"] [\"5\", \"6\", \"7\", \"&nbsp;\"] [\"8\", \"9\", \"10\", \"&nbsp;\"]  %w(1 2 3 4 5 6 7).in_groups(3, false) {|group| p group} [\"1\", \"2\", \"3\"] [\"4\", \"5\"] [\"6\", \"7\"]",
    "label": "",
    "id": "3080"
  },
  {
    "raw_code": "def split(value = nil, &block)\n    arr = dup\n    result = []\n    if block_given?\n      while (idx = arr.index(&block))\n        result << arr.shift(idx)\n        arr.shift\n      end",
    "comment": "Divides the array into one or more subarrays based on a delimiting +value+ or the result of an optional block.  [1, 2, 3, 4, 5].split(3)              # => [[1, 2], [4, 5]] (1..10).to_a.split { |i| i % 3 == 0 } # => [[1, 2], [4, 5], [7, 8], [10]]",
    "label": "",
    "id": "3081"
  },
  {
    "raw_code": "def inquiry\n    ActiveSupport::ArrayInquirer.new(self)\n  end",
    "comment": "Wraps the array in an ActiveSupport::ArrayInquirer object, which gives a friendlier way to check its string-like contents.  pets = [:cat, :dog].inquiry  pets.cat?     # => true pets.ferret?  # => false  pets.any?(:cat, :ferret)  # => true pets.any?(:ferret, :alligator)  # => false",
    "label": "",
    "id": "3082"
  },
  {
    "raw_code": "def self.wrap(object)\n    if object.nil?\n      []\n    elsif object.respond_to?(:to_ary)\n      object.to_ary || [object]\n    else\n      [object]\n    end",
    "comment": "Wraps its argument in an array unless it is already an array (or array-like).  Specifically:  * If the argument is +nil+ an empty array is returned. * Otherwise, if the argument responds to +to_ary+ it is invoked, and its result returned. * Otherwise, returns an array with the argument as its single element.  Array.wrap(nil)       # => [] Array.wrap([1, 2, 3]) # => [1, 2, 3] Array.wrap(0)         # => [0]  This method is similar in purpose to <tt>Kernel#Array</tt>, but there are some differences:  * If the argument responds to +to_ary+ the method is invoked. <tt>Kernel#Array</tt> moves on to try +to_a+ if the returned value is +nil+, but <tt>Array.wrap</tt> returns an array with the argument as its single element right away. * If the returned value from +to_ary+ is neither +nil+ nor an +Array+ object, <tt>Kernel#Array</tt> raises an exception, while <tt>Array.wrap</tt> does not, it just returns the value. * It does not call +to_a+ on the argument, if the argument does not respond to +to_ary+ it returns an array with the argument as its single element.  The last point is easily explained with some enumerables:  Array(foo: :bar)      # => [[:foo, :bar]] Array.wrap(foo: :bar) # => [{:foo=>:bar}]  There's also a related idiom that uses the splat operator:  [*object]  which returns <tt>[]</tt> for +nil+, but calls to <tt>Array(object)</tt> otherwise.  The differences with <tt>Kernel#Array</tt> explained above apply to the rest of <tt>object</tt>s.",
    "label": "",
    "id": "3083"
  },
  {
    "raw_code": "def class_attribute(*attrs, instance_accessor: true,\n    instance_reader: instance_accessor, instance_writer: instance_accessor, instance_predicate: true, default: nil\n  )\n    class_methods, methods = [], []\n    attrs.each do |name|\n      unless name.is_a?(Symbol) || name.is_a?(String)\n        raise TypeError, \"#{name.inspect} is not a symbol nor a string\"\n      end",
    "comment": "Declare a class-level attribute whose value is inheritable by subclasses. Subclasses can change their own value and it will not impact parent class.  ==== Options  * <tt>:instance_reader</tt> - Sets the instance reader method (defaults to true). * <tt>:instance_writer</tt> - Sets the instance writer method (defaults to true). * <tt>:instance_accessor</tt> - Sets both instance methods (defaults to true). * <tt>:instance_predicate</tt> - Sets a predicate method (defaults to true). * <tt>:default</tt> - Sets a default value for the attribute (defaults to nil).  ==== Examples  class Base class_attribute :setting end  class Subclass < Base end  Base.setting = true Subclass.setting            # => true Subclass.setting = false Subclass.setting            # => false Base.setting                # => true  In the above case as long as Subclass does not assign a value to setting by performing <tt>Subclass.setting = _something_</tt>, <tt>Subclass.setting</tt> would read value assigned to parent class. Once Subclass assigns a value then the value assigned by Subclass would be returned.  This matches normal Ruby method inheritance: think of writing an attribute on a subclass as overriding the reader method. However, you need to be aware when using +class_attribute+ with mutable structures as +Array+ or +Hash+. In such cases, you don't want to do changes in place. Instead use setters:  Base.setting = [] Base.setting                # => [] Subclass.setting            # => []  # Appending in child changes both parent and child because it is the same object: Subclass.setting << :foo Base.setting               # => [:foo] Subclass.setting           # => [:foo]  # Use setters to not propagate changes: Base.setting = [] Subclass.setting += [:foo] Base.setting               # => [] Subclass.setting           # => [:foo]  For convenience, an instance predicate method is defined as well. To skip it, pass <tt>instance_predicate: false</tt>.  Subclass.setting?       # => false  Instances may overwrite the class value in the same way:  Base.setting = true object = Base.new object.setting          # => true object.setting = false object.setting          # => false Base.setting            # => true  To opt out of the instance reader method, pass <tt>instance_reader: false</tt>.  object.setting          # => NoMethodError object.setting?         # => NoMethodError  To opt out of the instance writer method, pass <tt>instance_writer: false</tt>.  object.setting = false  # => NoMethodError  To opt out of both instance methods, pass <tt>instance_accessor: false</tt>.  To set a default value for the attribute, pass <tt>default:</tt>, like so:  class_attribute :settings, default: {}",
    "label": "",
    "id": "3084"
  },
  {
    "raw_code": "def descendants\n    subclasses.concat(subclasses.flat_map(&:descendants))\n  end",
    "comment": "Returns an array with all classes that are < than its receiver.  class C; end C.descendants # => []  class B < C; end C.descendants # => [B]  class A < B; end C.descendants # => [B, A]  class D < C; end C.descendants # => [B, A, D]",
    "label": "",
    "id": "3085"
  },
  {
    "raw_code": "def acts_like_date?\n    true\n  end",
    "comment": "Duck-types as a Date-like class. See Object#acts_like?.",
    "label": "",
    "id": "3086"
  },
  {
    "raw_code": "def blank?\n    false\n  end",
    "comment": "No Date is blank:  Date.today.blank? # => false  @return [false]",
    "label": "",
    "id": "3087"
  },
  {
    "raw_code": "def beginning_of_week\n      ::ActiveSupport::IsolatedExecutionState[:beginning_of_week] || beginning_of_week_default || :monday\n    end",
    "comment": "Returns the week start (e.g. +:monday+) for the current request, if this has been set (via Date.beginning_of_week=). If <tt>Date.beginning_of_week</tt> has not been set for the current request, returns the week start specified in <tt>config.beginning_of_week</tt>. If no +config.beginning_of_week+ was specified, returns +:monday+.",
    "label": "",
    "id": "3088"
  },
  {
    "raw_code": "def beginning_of_week=(week_start)\n      ::ActiveSupport::IsolatedExecutionState[:beginning_of_week] = find_beginning_of_week!(week_start)\n    end",
    "comment": "Sets <tt>Date.beginning_of_week</tt> to a week start (e.g. +:monday+) for current request/thread.  This method accepts any of the following day symbols: +:monday+, +:tuesday+, +:wednesday+, +:thursday+, +:friday+, +:saturday+, +:sunday+",
    "label": "",
    "id": "3089"
  },
  {
    "raw_code": "def find_beginning_of_week!(week_start)\n      raise ArgumentError, \"Invalid beginning of week: #{week_start}\" unless ::Date::DAYS_INTO_WEEK.key?(week_start)\n      week_start\n    end",
    "comment": "Returns week start day symbol (e.g. +:monday+), or raises an +ArgumentError+ for invalid day symbol.",
    "label": "",
    "id": "3090"
  },
  {
    "raw_code": "def yesterday\n      ::Date.current.yesterday\n    end",
    "comment": "Returns a new Date representing the date 1 day ago (i.e. yesterday's date).",
    "label": "",
    "id": "3091"
  },
  {
    "raw_code": "def tomorrow\n      ::Date.current.tomorrow\n    end",
    "comment": "Returns a new Date representing the date 1 day after today (i.e. tomorrow's date).",
    "label": "",
    "id": "3092"
  },
  {
    "raw_code": "def current\n      ::Time.zone ? ::Time.zone.today : ::Date.today\n    end",
    "comment": "Returns Time.zone.today when <tt>Time.zone</tt> or <tt>config.time_zone</tt> are set, otherwise just returns Date.today.",
    "label": "",
    "id": "3093"
  },
  {
    "raw_code": "def ago(seconds)\n    in_time_zone.since(-seconds)\n  end",
    "comment": "Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00) and then subtracts the specified number of seconds.",
    "label": "",
    "id": "3094"
  },
  {
    "raw_code": "def since(seconds)\n    in_time_zone.since(seconds)\n  end",
    "comment": "Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00) and then adds the specified number of seconds",
    "label": "",
    "id": "3095"
  },
  {
    "raw_code": "def beginning_of_day\n    in_time_zone\n  end",
    "comment": "Converts Date to a Time (or DateTime if necessary) with the time portion set to the beginning of the day (0:00)",
    "label": "",
    "id": "3096"
  },
  {
    "raw_code": "def middle_of_day\n    in_time_zone.middle_of_day\n  end",
    "comment": "Converts Date to a Time (or DateTime if necessary) with the time portion set to the middle of the day (12:00)",
    "label": "",
    "id": "3097"
  },
  {
    "raw_code": "def end_of_day\n    in_time_zone.end_of_day\n  end",
    "comment": "Converts Date to a Time (or DateTime if necessary) with the time portion set to the end of the day (23:59:59)",
    "label": "",
    "id": "3098"
  },
  {
    "raw_code": "def advance(options)\n    d = self\n\n    d = d >> options[:years] * 12 if options[:years]\n    d = d >> options[:months] if options[:months]\n    d = d + options[:weeks] * 7 if options[:weeks]\n    d = d + options[:days] if options[:days]\n\n    d\n  end",
    "comment": "Provides precise Date calculations for years, months, and days. The +options+ parameter takes a hash with any of these keys: <tt>:years</tt>, <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>.  The increments are applied in order of time units from largest to smallest. In other words, the date is incremented first by +:years+, then by +:months+, then by +:weeks+, then by +:days+. This order can affect the result around the end of a month. For example, incrementing first by months then by days:  Date.new(2004, 9, 30).advance(months: 1, days: 1) # => Sun, 31 Oct 2004  Whereas incrementing first by days then by months yields a different result:  Date.new(2004, 9, 30).advance(days: 1).advance(months: 1) # => Mon, 01 Nov 2004 ",
    "label": "",
    "id": "3099"
  },
  {
    "raw_code": "def change(options)\n    ::Date.new(\n      options.fetch(:year, year),\n      options.fetch(:month, month),\n      options.fetch(:day, day)\n    )\n  end",
    "comment": "Returns a new Date where one or more of the elements have been changed according to the +options+ parameter. The +options+ parameter is a hash with a combination of these keys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>.  Date.new(2007, 5, 12).change(day: 1)               # => Date.new(2007, 5, 1) Date.new(2007, 5, 12).change(year: 2005, month: 1) # => Date.new(2005, 1, 12)",
    "label": "",
    "id": "3100"
  },
  {
    "raw_code": "def compare_with_coercion(other)\n    if other.is_a?(Time)\n      to_datetime <=> other\n    else\n      compare_without_coercion(other)\n    end",
    "comment": "Allow Date to be compared with Time by converting to DateTime and relying on the <=> from there.",
    "label": "",
    "id": "3101"
  },
  {
    "raw_code": "def to_fs(format = :default)\n    if formatter = DATE_FORMATS[format]\n      if formatter.respond_to?(:call)\n        formatter.call(self).to_s\n      else\n        strftime(formatter)\n      end",
    "comment": "Convert to a formatted string. See DATE_FORMATS for predefined formats.  This method is aliased to <tt>to_formatted_s</tt>.  date = Date.new(2007, 11, 10)       # => Sat, 10 Nov 2007  date.to_fs(:db)                     # => \"2007-11-10\" date.to_formatted_s(:db)            # => \"2007-11-10\"  date.to_fs(:short)         # => \"10 Nov\" date.to_fs(:number)        # => \"20071110\" date.to_fs(:long)          # => \"November 10, 2007\" date.to_fs(:long_ordinal)  # => \"November 10th, 2007\" date.to_fs(:rfc822)        # => \"10 Nov 2007\" date.to_fs(:rfc2822)       # => \"10 Nov 2007\" date.to_fs(:iso8601)       # => \"2007-11-10\"  == Adding your own date formats to to_fs You can add your own formats to the Date::DATE_FORMATS hash. Use the format name as the hash key and either a strftime string or Proc instance that takes a date argument as the value.  # config/initializers/date_formats.rb Date::DATE_FORMATS[:month_and_year] = '%B %Y' Date::DATE_FORMATS[:short_ordinal] = ->(date) { date.strftime(\"%B #{date.day.ordinalize}\") }",
    "label": "",
    "id": "3102"
  },
  {
    "raw_code": "def readable_inspect\n    strftime(\"%a, %d %b %Y\")\n  end",
    "comment": "Overrides the default inspect method with a human readable one, e.g., \"Mon, 21 Feb 2005\"",
    "label": "",
    "id": "3103"
  },
  {
    "raw_code": "def to_time(form = :local)\n    raise ArgumentError, \"Expected :local or :utc, got #{form.inspect}.\" unless [:local, :utc].include?(form)\n    ::Time.public_send(form, year, month, day)\n  end",
    "comment": "Converts a Date instance to a Time, where the time is set to the beginning of the day. The timezone can be either +:local+ or +:utc+ (default +:local+).  date = Date.new(2007, 11, 10)  # => Sat, 10 Nov 2007  date.to_time                   # => 2007-11-10 00:00:00 0800 date.to_time(:local)           # => 2007-11-10 00:00:00 0800  date.to_time(:utc)             # => 2007-11-10 00:00:00 UTC  NOTE: The +:local+ timezone is Ruby's *process* timezone, i.e. <tt>ENV['TZ']</tt>. If the <b>application's</b> timezone is needed, then use +in_time_zone+ instead.",
    "label": "",
    "id": "3104"
  },
  {
    "raw_code": "def xmlschema\n    in_time_zone.xmlschema\n  end",
    "comment": "Returns a string which represents the time in used time zone as DateTime defined by XML Schema:  date = Date.new(2015, 05, 23)  # => Sat, 23 May 2015 date.xmlschema                 # => \"2015-05-23T00:00:00+04:00\"",
    "label": "",
    "id": "3105"
  },
  {
    "raw_code": "def yesterday\n      advance(days: -1)\n    end",
    "comment": "Returns a new date/time representing yesterday.",
    "label": "",
    "id": "3106"
  },
  {
    "raw_code": "def tomorrow\n      advance(days: 1)\n    end",
    "comment": "Returns a new date/time representing tomorrow.",
    "label": "",
    "id": "3107"
  },
  {
    "raw_code": "def today?\n      to_date == ::Date.current\n    end",
    "comment": "Returns true if the date/time is today.",
    "label": "",
    "id": "3108"
  },
  {
    "raw_code": "def tomorrow?\n      to_date == ::Date.current.tomorrow\n    end",
    "comment": "Returns true if the date/time is tomorrow.",
    "label": "",
    "id": "3109"
  },
  {
    "raw_code": "def yesterday?\n      to_date == ::Date.current.yesterday\n    end",
    "comment": "Returns true if the date/time is yesterday.",
    "label": "",
    "id": "3110"
  },
  {
    "raw_code": "def past?\n      self < self.class.current\n    end",
    "comment": "Returns true if the date/time is in the past.",
    "label": "",
    "id": "3111"
  },
  {
    "raw_code": "def future?\n      self > self.class.current\n    end",
    "comment": "Returns true if the date/time is in the future.",
    "label": "",
    "id": "3112"
  },
  {
    "raw_code": "def on_weekend?\n      WEEKEND_DAYS.include?(wday)\n    end",
    "comment": "Returns true if the date/time falls on a Saturday or Sunday.",
    "label": "",
    "id": "3113"
  },
  {
    "raw_code": "def on_weekday?\n      !WEEKEND_DAYS.include?(wday)\n    end",
    "comment": "Returns true if the date/time does not fall on a Saturday or Sunday.",
    "label": "",
    "id": "3114"
  },
  {
    "raw_code": "def before?(date_or_time)\n      self < date_or_time\n    end",
    "comment": "Returns true if the date/time falls before <tt>date_or_time</tt>.",
    "label": "",
    "id": "3115"
  },
  {
    "raw_code": "def after?(date_or_time)\n      self > date_or_time\n    end",
    "comment": "Returns true if the date/time falls after <tt>date_or_time</tt>.",
    "label": "",
    "id": "3116"
  },
  {
    "raw_code": "def days_ago(days)\n      advance(days: -days)\n    end",
    "comment": "Returns a new date/time the specified number of days ago.",
    "label": "",
    "id": "3117"
  },
  {
    "raw_code": "def days_since(days)\n      advance(days: days)\n    end",
    "comment": "Returns a new date/time the specified number of days in the future.",
    "label": "",
    "id": "3118"
  },
  {
    "raw_code": "def weeks_ago(weeks)\n      advance(weeks: -weeks)\n    end",
    "comment": "Returns a new date/time the specified number of weeks ago.",
    "label": "",
    "id": "3119"
  },
  {
    "raw_code": "def weeks_since(weeks)\n      advance(weeks: weeks)\n    end",
    "comment": "Returns a new date/time the specified number of weeks in the future.",
    "label": "",
    "id": "3120"
  },
  {
    "raw_code": "def months_ago(months)\n      advance(months: -months)\n    end",
    "comment": "Returns a new date/time the specified number of months ago.",
    "label": "",
    "id": "3121"
  },
  {
    "raw_code": "def months_since(months)\n      advance(months: months)\n    end",
    "comment": "Returns a new date/time the specified number of months in the future.",
    "label": "",
    "id": "3122"
  },
  {
    "raw_code": "def years_ago(years)\n      advance(years: -years)\n    end",
    "comment": "Returns a new date/time the specified number of years ago.",
    "label": "",
    "id": "3123"
  },
  {
    "raw_code": "def years_since(years)\n      advance(years: years)\n    end",
    "comment": "Returns a new date/time the specified number of years in the future.",
    "label": "",
    "id": "3124"
  },
  {
    "raw_code": "def beginning_of_month\n      first_hour(change(day: 1))\n    end",
    "comment": "Returns a new date/time at the start of the month.  today = Date.today # => Thu, 18 Jun 2015 today.beginning_of_month # => Mon, 01 Jun 2015  +DateTime+ objects will have a time set to 0:00.  now = DateTime.current # => Thu, 18 Jun 2015 15:23:13 +0000 now.beginning_of_month # => Mon, 01 Jun 2015 00:00:00 +0000",
    "label": "",
    "id": "3125"
  },
  {
    "raw_code": "def beginning_of_quarter\n      first_quarter_month = month - (2 + month) % 3\n      beginning_of_month.change(month: first_quarter_month)\n    end",
    "comment": "Returns a new date/time at the start of the quarter.  today = Date.today # => Fri, 10 Jul 2015 today.beginning_of_quarter # => Wed, 01 Jul 2015  +DateTime+ objects will have a time set to 0:00.  now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000 now.beginning_of_quarter # => Wed, 01 Jul 2015 00:00:00 +0000",
    "label": "",
    "id": "3126"
  },
  {
    "raw_code": "def end_of_quarter\n      last_quarter_month = month + (12 - month) % 3\n      beginning_of_month.change(month: last_quarter_month).end_of_month\n    end",
    "comment": "Returns a new date/time at the end of the quarter.  today = Date.today # => Fri, 10 Jul 2015 today.end_of_quarter # => Wed, 30 Sep 2015  +DateTime+ objects will have a time set to 23:59:59.  now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000 now.end_of_quarter # => Wed, 30 Sep 2015 23:59:59 +0000",
    "label": "",
    "id": "3127"
  },
  {
    "raw_code": "def quarter\n      (month / 3.0).ceil\n    end",
    "comment": "Returns the quarter for a date/time.  Date.new(2010, 1, 31).quarter  # => 1 Date.new(2010, 4, 12).quarter  # => 2 Date.new(2010, 9, 15).quarter  # => 3 Date.new(2010, 12, 25).quarter # => 4",
    "label": "",
    "id": "3128"
  },
  {
    "raw_code": "def beginning_of_year\n      change(month: 1).beginning_of_month\n    end",
    "comment": "Returns a new date/time at the beginning of the year.  today = Date.today # => Fri, 10 Jul 2015 today.beginning_of_year # => Thu, 01 Jan 2015  +DateTime+ objects will have a time set to 0:00.  now = DateTime.current # => Fri, 10 Jul 2015 18:41:29 +0000 now.beginning_of_year # => Thu, 01 Jan 2015 00:00:00 +0000",
    "label": "",
    "id": "3129"
  },
  {
    "raw_code": "def next_week(given_day_in_next_week = Date.beginning_of_week, same_time: false)\n      result = first_hour(weeks_since(1).beginning_of_week.days_since(days_span(given_day_in_next_week)))\n      same_time ? copy_time_to(result) : result\n    end",
    "comment": "Returns a new date/time representing the given day in the next week.  today = Date.today # => Thu, 07 May 2015 today.next_week    # => Mon, 11 May 2015  The +given_day_in_next_week+ defaults to the beginning of the week which is determined by +Date.beginning_of_week+ or +config.beginning_of_week+ when set.  today = Date.today       # => Thu, 07 May 2015 today.next_week(:friday) # => Fri, 15 May 2015  +DateTime+ objects have their time set to 0:00 unless +same_time+ is true.  now = DateTime.current # => Thu, 07 May 2015 13:31:16 +0000 now.next_week      # => Mon, 11 May 2015 00:00:00 +0000",
    "label": "",
    "id": "3130"
  },
  {
    "raw_code": "def next_weekday\n      if next_day.on_weekend?\n        next_week(:monday, same_time: true)\n      else\n        next_day\n      end",
    "comment": "Returns a new date/time representing the next weekday.",
    "label": "",
    "id": "3131"
  },
  {
    "raw_code": "def next_quarter\n      months_since(3)\n    end",
    "comment": "Short-hand for <tt>months_since(3)</tt>.",
    "label": "",
    "id": "3132"
  },
  {
    "raw_code": "def prev_week(start_day = Date.beginning_of_week, same_time: false)\n      result = first_hour(weeks_ago(1).beginning_of_week.days_since(days_span(start_day)))\n      same_time ? copy_time_to(result) : result\n    end",
    "comment": "Returns a new date/time representing the given day in the previous week. Week is assumed to start on +start_day+, default is +Date.beginning_of_week+ or +config.beginning_of_week+ when set. DateTime objects have their time set to 0:00 unless +same_time+ is true.",
    "label": "",
    "id": "3133"
  },
  {
    "raw_code": "def prev_weekday\n      if prev_day.on_weekend?\n        copy_time_to(beginning_of_week(:friday))\n      else\n        prev_day\n      end",
    "comment": "Returns a new date/time representing the previous weekday.",
    "label": "",
    "id": "3134"
  },
  {
    "raw_code": "def last_month\n      months_ago(1)\n    end",
    "comment": "Short-hand for <tt>months_ago(1)</tt>.",
    "label": "",
    "id": "3135"
  },
  {
    "raw_code": "def prev_quarter\n      months_ago(3)\n    end",
    "comment": "Short-hand for <tt>months_ago(3)</tt>.",
    "label": "",
    "id": "3136"
  },
  {
    "raw_code": "def last_year\n      years_ago(1)\n    end",
    "comment": "Short-hand for <tt>years_ago(1)</tt>.",
    "label": "",
    "id": "3137"
  },
  {
    "raw_code": "def days_to_week_start(start_day = Date.beginning_of_week)\n      start_day_number = DAYS_INTO_WEEK.fetch(start_day)\n      (wday - start_day_number) % 7\n    end",
    "comment": "Returns the number of days to the start of the week on the given day. Week is assumed to start on +start_day+, default is +Date.beginning_of_week+ or +config.beginning_of_week+ when set.",
    "label": "",
    "id": "3138"
  },
  {
    "raw_code": "def beginning_of_week(start_day = Date.beginning_of_week)\n      result = days_ago(days_to_week_start(start_day))\n      acts_like?(:time) ? result.midnight : result\n    end",
    "comment": "Returns a new date/time representing the start of this week on the given day. Week is assumed to start on +start_day+, default is +Date.beginning_of_week+ or +config.beginning_of_week+ when set. +DateTime+ objects have their time set to 0:00.",
    "label": "",
    "id": "3139"
  },
  {
    "raw_code": "def monday\n      beginning_of_week(:monday)\n    end",
    "comment": "Returns Monday of this week assuming that week starts on Monday. +DateTime+ objects have their time set to 0:00.",
    "label": "",
    "id": "3140"
  },
  {
    "raw_code": "def end_of_week(start_day = Date.beginning_of_week)\n      last_hour(days_since(6 - days_to_week_start(start_day)))\n    end",
    "comment": "Returns a new date/time representing the end of this week on the given day. Week is assumed to start on +start_day+, default is +Date.beginning_of_week+ or +config.beginning_of_week+ when set. DateTime objects have their time set to 23:59:59.",
    "label": "",
    "id": "3141"
  },
  {
    "raw_code": "def sunday\n      end_of_week(:monday)\n    end",
    "comment": "Returns Sunday of this week assuming that week starts on Monday. +DateTime+ objects have their time set to 23:59:59.",
    "label": "",
    "id": "3142"
  },
  {
    "raw_code": "def end_of_month\n      last_day = ::Time.days_in_month(month, year)\n      last_hour(days_since(last_day - day))\n    end",
    "comment": "Returns a new date/time representing the end of the month. DateTime objects will have a time set to 23:59:59.",
    "label": "",
    "id": "3143"
  },
  {
    "raw_code": "def end_of_year\n      change(month: 12).end_of_month\n    end",
    "comment": "Returns a new date/time representing the end of the year. DateTime objects will have a time set to 23:59:59.",
    "label": "",
    "id": "3144"
  },
  {
    "raw_code": "def all_day\n      beginning_of_day..end_of_day\n    end",
    "comment": "Returns a Range representing the whole day of the current date/time.",
    "label": "",
    "id": "3145"
  },
  {
    "raw_code": "def all_week(start_day = Date.beginning_of_week)\n      beginning_of_week(start_day)..end_of_week(start_day)\n    end",
    "comment": "Returns a Range representing the whole week of the current date/time. Week starts on start_day, default is <tt>Date.beginning_of_week</tt> or <tt>config.beginning_of_week</tt> when set.",
    "label": "",
    "id": "3146"
  },
  {
    "raw_code": "def all_month\n      beginning_of_month..end_of_month\n    end",
    "comment": "Returns a Range representing the whole month of the current date/time.",
    "label": "",
    "id": "3147"
  },
  {
    "raw_code": "def all_quarter\n      beginning_of_quarter..end_of_quarter\n    end",
    "comment": "Returns a Range representing the whole quarter of the current date/time.",
    "label": "",
    "id": "3148"
  },
  {
    "raw_code": "def all_year\n      beginning_of_year..end_of_year\n    end",
    "comment": "Returns a Range representing the whole year of the current date/time.",
    "label": "",
    "id": "3149"
  },
  {
    "raw_code": "def next_occurring(day_of_week)\n      from_now = DAYS_INTO_WEEK.fetch(day_of_week) - wday\n      from_now += 7 unless from_now > 0\n      advance(days: from_now)\n    end",
    "comment": "Returns a new date/time representing the next occurrence of the specified day of week.  today = Date.today               # => Thu, 14 Dec 2017 today.next_occurring(:monday)    # => Mon, 18 Dec 2017 today.next_occurring(:thursday)  # => Thu, 21 Dec 2017",
    "label": "",
    "id": "3150"
  },
  {
    "raw_code": "def prev_occurring(day_of_week)\n      ago = wday - DAYS_INTO_WEEK.fetch(day_of_week)\n      ago += 7 unless ago > 0\n      advance(days: -ago)\n    end",
    "comment": "Returns a new date/time representing the previous occurrence of the specified day of week.  today = Date.today               # => Thu, 14 Dec 2017 today.prev_occurring(:monday)    # => Mon, 11 Dec 2017 today.prev_occurring(:thursday)  # => Thu, 07 Dec 2017",
    "label": "",
    "id": "3151"
  },
  {
    "raw_code": "def self.preserve_timezone # :nodoc:\n      if @@preserve_timezone.nil?\n        # Only warn once, the first time the value is used (which should\n        # be the first time #to_time is called).\n        ActiveSupport.deprecator.warn(\n          \"`to_time` will always preserve the receiver timezone rather than system local time in Rails 8.1.\" \\\n          \"To opt in to the new behavior, set `config.active_support.to_time_preserves_timezone = :zone`.\"\n        )\n\n        @@preserve_timezone = false\n      end",
    "comment": "-- This re-implements the behavior of the mattr_reader, instead of prepending on to it, to avoid overcomplicating a module that is in turn included in several places. This will all go away in Rails 8.0 anyway.",
    "label": "",
    "id": "3152"
  },
  {
    "raw_code": "def in_time_zone(zone = ::Time.zone)\n      time_zone = ::Time.find_zone! zone\n      time = acts_like?(:time) ? self : nil\n\n      if time_zone\n        time_with_zone(time, time_zone)\n      else\n        time || to_time\n      end",
    "comment": "Returns the simultaneous time in <tt>Time.zone</tt> if a zone is given or if Time.zone_default is set. Otherwise, it returns the current time.  Time.zone = 'Hawaii'        # => 'Hawaii' Time.utc(2000).in_time_zone # => Fri, 31 Dec 1999 14:00:00 HST -10:00 Date.new(2000).in_time_zone # => Sat, 01 Jan 2000 00:00:00 HST -10:00  This method is similar to Time#localtime, except that it uses <tt>Time.zone</tt> as the local zone instead of the operating system's time zone.  You can also pass in a TimeZone instance or string that identifies a TimeZone as an argument, and the conversion will be based on that zone instead of <tt>Time.zone</tt>.  Time.utc(2000).in_time_zone('Alaska') # => Fri, 31 Dec 1999 15:00:00 AKST -09:00 Date.new(2000).in_time_zone('Alaska') # => Sat, 01 Jan 2000 00:00:00 AKST -09:00",
    "label": "",
    "id": "3153"
  },
  {
    "raw_code": "def acts_like_date?\n    true\n  end",
    "comment": "Duck-types as a Date-like class. See Object#acts_like?.",
    "label": "",
    "id": "3154"
  },
  {
    "raw_code": "def acts_like_time?\n    true\n  end",
    "comment": "Duck-types as a Time-like class. See Object#acts_like?.",
    "label": "",
    "id": "3155"
  },
  {
    "raw_code": "def blank?\n    false\n  end",
    "comment": "No DateTime is ever blank:  DateTime.now.blank? # => false  @return [false]",
    "label": "",
    "id": "3156"
  },
  {
    "raw_code": "def current\n      ::Time.zone ? ::Time.zone.now.to_datetime : ::Time.now.to_datetime\n    end",
    "comment": "Returns <tt>Time.zone.now.to_datetime</tt> when <tt>Time.zone</tt> or <tt>config.time_zone</tt> are set, otherwise returns <tt>Time.now.to_datetime</tt>.",
    "label": "",
    "id": "3157"
  },
  {
    "raw_code": "def seconds_since_midnight\n    sec + (min * 60) + (hour * 3600)\n  end",
    "comment": "Returns the number of seconds since 00:00:00.  DateTime.new(2012, 8, 29,  0,  0,  0).seconds_since_midnight # => 0 DateTime.new(2012, 8, 29, 12, 34, 56).seconds_since_midnight # => 45296 DateTime.new(2012, 8, 29, 23, 59, 59).seconds_since_midnight # => 86399",
    "label": "",
    "id": "3158"
  },
  {
    "raw_code": "def seconds_until_end_of_day\n    end_of_day.to_i - to_i\n  end",
    "comment": "Returns the number of seconds until 23:59:59.  DateTime.new(2012, 8, 29,  0,  0,  0).seconds_until_end_of_day # => 86399 DateTime.new(2012, 8, 29, 12, 34, 56).seconds_until_end_of_day # => 41103 DateTime.new(2012, 8, 29, 23, 59, 59).seconds_until_end_of_day # => 0",
    "label": "",
    "id": "3159"
  },
  {
    "raw_code": "def subsec\n    sec_fraction\n  end",
    "comment": "Returns the fraction of a second as a +Rational+  DateTime.new(2012, 8, 29, 0, 0, 0.5).subsec # => (1/2)",
    "label": "",
    "id": "3160"
  },
  {
    "raw_code": "def change(options)\n    if new_nsec = options[:nsec]\n      raise ArgumentError, \"Can't change both :nsec and :usec at the same time: #{options.inspect}\" if options[:usec]\n      new_fraction = Rational(new_nsec, 1000000000)\n    else\n      new_usec = options.fetch(:usec, (options[:hour] || options[:min] || options[:sec]) ? 0 : Rational(nsec, 1000))\n      new_fraction = Rational(new_usec, 1000000)\n    end",
    "comment": "Returns a new DateTime where one or more of the elements have been changed according to the +options+ parameter. The time options (<tt>:hour</tt>, <tt>:min</tt>, <tt>:sec</tt>) reset cascadingly, so if only the hour is passed, then minute and sec is set to 0. If the hour and minute is passed, then sec is set to 0. The +options+ parameter takes a hash with any of these keys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>, <tt>:hour</tt>, <tt>:min</tt>, <tt>:sec</tt>, <tt>:offset</tt>, <tt>:start</tt>.  DateTime.new(2012, 8, 29, 22, 35, 0).change(day: 1)              # => DateTime.new(2012, 8, 1, 22, 35, 0) DateTime.new(2012, 8, 29, 22, 35, 0).change(year: 1981, day: 1)  # => DateTime.new(1981, 8, 1, 22, 35, 0) DateTime.new(2012, 8, 29, 22, 35, 0).change(year: 1981, hour: 0) # => DateTime.new(1981, 8, 29, 0, 0, 0)",
    "label": "",
    "id": "3161"
  },
  {
    "raw_code": "def advance(options)\n    unless options[:weeks].nil?\n      options[:weeks], partial_weeks = options[:weeks].divmod(1)\n      options[:days] = options.fetch(:days, 0) + 7 * partial_weeks\n    end",
    "comment": "Uses Date to provide precise Time calculations for years, months, and days. The +options+ parameter takes a hash with any of these keys: <tt>:years</tt>, <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>, <tt>:hours</tt>, <tt>:minutes</tt>, <tt>:seconds</tt>.  Just like Date#advance, increments are applied in order of time units from largest to smallest. This order can affect the result around the end of a month.",
    "label": "",
    "id": "3162"
  },
  {
    "raw_code": "def ago(seconds)\n    since(-seconds)\n  end",
    "comment": "Returns a new DateTime representing the time a number of seconds ago. Do not use this method in combination with x.months, use months_ago instead!",
    "label": "",
    "id": "3163"
  },
  {
    "raw_code": "def since(seconds)\n    self + Rational(seconds, 86400)\n  end",
    "comment": "Returns a new DateTime representing the time a number of seconds since the instance time. Do not use this method in combination with x.months, use months_since instead!",
    "label": "",
    "id": "3164"
  },
  {
    "raw_code": "def beginning_of_day\n    change(hour: 0)\n  end",
    "comment": "Returns a new DateTime representing the start of the day (0:00).",
    "label": "",
    "id": "3165"
  },
  {
    "raw_code": "def middle_of_day\n    change(hour: 12)\n  end",
    "comment": "Returns a new DateTime representing the middle of the day (12:00)",
    "label": "",
    "id": "3166"
  },
  {
    "raw_code": "def end_of_day\n    change(hour: 23, min: 59, sec: 59, usec: Rational(999999999, 1000))\n  end",
    "comment": "Returns a new DateTime representing the end of the day (23:59:59).",
    "label": "",
    "id": "3167"
  },
  {
    "raw_code": "def beginning_of_hour\n    change(min: 0)\n  end",
    "comment": "Returns a new DateTime representing the start of the hour (hh:00:00).",
    "label": "",
    "id": "3168"
  },
  {
    "raw_code": "def end_of_hour\n    change(min: 59, sec: 59, usec: Rational(999999999, 1000))\n  end",
    "comment": "Returns a new DateTime representing the end of the hour (hh:59:59).",
    "label": "",
    "id": "3169"
  },
  {
    "raw_code": "def beginning_of_minute\n    change(sec: 0)\n  end",
    "comment": "Returns a new DateTime representing the start of the minute (hh:mm:00).",
    "label": "",
    "id": "3170"
  },
  {
    "raw_code": "def end_of_minute\n    change(sec: 59, usec: Rational(999999999, 1000))\n  end",
    "comment": "Returns a new DateTime representing the end of the minute (hh:mm:59).",
    "label": "",
    "id": "3171"
  },
  {
    "raw_code": "def localtime(utc_offset = nil)\n    utc = new_offset(0)\n\n    Time.utc(\n      utc.year, utc.month, utc.day,\n      utc.hour, utc.min, utc.sec + utc.sec_fraction\n    ).getlocal(utc_offset)\n  end",
    "comment": "Returns a <tt>Time</tt> instance of the simultaneous time in the system timezone.",
    "label": "",
    "id": "3172"
  },
  {
    "raw_code": "def utc\n    utc = new_offset(0)\n\n    Time.utc(\n      utc.year, utc.month, utc.day,\n      utc.hour, utc.min, utc.sec + utc.sec_fraction\n    )\n  end",
    "comment": "Returns a <tt>Time</tt> instance of the simultaneous time in the UTC timezone.  DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24))     # => Mon, 21 Feb 2005 10:11:12 -0600 DateTime.civil(2005, 2, 21, 10, 11, 12, Rational(-6, 24)).utc # => Mon, 21 Feb 2005 16:11:12 UTC",
    "label": "",
    "id": "3173"
  },
  {
    "raw_code": "def utc?\n    offset == 0\n  end",
    "comment": "Returns +true+ if <tt>offset == 0</tt>.",
    "label": "",
    "id": "3174"
  },
  {
    "raw_code": "def utc_offset\n    (offset * 86400).to_i\n  end",
    "comment": "Returns the offset value in seconds.",
    "label": "",
    "id": "3175"
  },
  {
    "raw_code": "def <=>(other)\n    if other.respond_to? :to_datetime\n      super other.to_datetime rescue nil\n    else\n      super\n    end",
    "comment": "Layers additional behavior on DateTime#<=> so that Time and ActiveSupport::TimeWithZone instances can be compared with a DateTime.",
    "label": "",
    "id": "3176"
  },
  {
    "raw_code": "def to_time\n    preserve_timezone ? getlocal(utc_offset) : getlocal\n  end",
    "comment": "Either return an instance of +Time+ with the same UTC offset as +self+ or an instance of +Time+ representing the same time in the local system timezone depending on the setting of on the setting of +ActiveSupport.to_time_preserves_timezone+.",
    "label": "",
    "id": "3177"
  },
  {
    "raw_code": "def to_fs(format = :default)\n    if formatter = ::Time::DATE_FORMATS[format]\n      formatter.respond_to?(:call) ? formatter.call(self).to_s : strftime(formatter)\n    else\n      to_s\n    end",
    "comment": "Convert to a formatted string. See Time::DATE_FORMATS for predefined formats.  This method is aliased to <tt>to_formatted_s</tt>.  ==== Examples  datetime = DateTime.civil(2007, 12, 4, 0, 0, 0, 0)   # => Tue, 04 Dec 2007 00:00:00 +0000  datetime.to_fs(:db)            # => \"2007-12-04 00:00:00\" datetime.to_formatted_s(:db)   # => \"2007-12-04 00:00:00\" datetime.to_fs(:number)        # => \"20071204000000\" datetime.to_fs(:short)         # => \"04 Dec 00:00\" datetime.to_fs(:long)          # => \"December 04, 2007 00:00\" datetime.to_fs(:long_ordinal)  # => \"December 4th, 2007 00:00\" datetime.to_fs(:rfc822)        # => \"Tue, 04 Dec 2007 00:00:00 +0000\" datetime.to_fs(:iso8601)       # => \"2007-12-04T00:00:00+00:00\"  ==== Adding your own datetime formats to +to_fs+  DateTime formats are shared with Time. You can add your own to the Time::DATE_FORMATS hash. Use the format name as the hash key and either a strftime string or Proc instance that takes a time or datetime argument as the value.  # config/initializers/time_formats.rb Time::DATE_FORMATS[:month_and_year] = '%B %Y' Time::DATE_FORMATS[:short_ordinal] = lambda { |time| time.strftime(\"%B #{time.day.ordinalize}\") }",
    "label": "",
    "id": "3178"
  },
  {
    "raw_code": "def formatted_offset(colon = true, alternate_utc_string = nil)\n    utc? && alternate_utc_string || ActiveSupport::TimeZone.seconds_to_utc_offset(utc_offset, colon)\n  end",
    "comment": "Returns a formatted string of the offset from UTC, or an alternative string if the time zone is already UTC.  datetime = DateTime.civil(2000, 1, 1, 0, 0, 0, Rational(-6, 24)) datetime.formatted_offset         # => \"-06:00\" datetime.formatted_offset(false)  # => \"-0600\"",
    "label": "",
    "id": "3179"
  },
  {
    "raw_code": "def readable_inspect\n    to_fs(:rfc822)\n  end",
    "comment": "Overrides the default inspect method with a human readable one, e.g., \"Mon, 21 Feb 2005 14:30:00 +0000\".",
    "label": "",
    "id": "3180"
  },
  {
    "raw_code": "def self.civil_from_format(utc_or_local, year, month = 1, day = 1, hour = 0, min = 0, sec = 0)\n    if utc_or_local.to_sym == :local\n      offset = ::Time.local(year, month, day).utc_offset.to_r / 86400\n    else\n      offset = 0\n    end",
    "comment": "Returns DateTime with local offset for given year if format is local else offset is zero.  DateTime.civil_from_format :local, 2012 # => Sun, 01 Jan 2012 00:00:00 +0300 DateTime.civil_from_format :local, 2012, 12, 17 # => Mon, 17 Dec 2012 00:00:00 +0000",
    "label": "",
    "id": "3181"
  },
  {
    "raw_code": "def to_f\n    seconds_since_unix_epoch.to_f + sec_fraction\n  end",
    "comment": "Converts +self+ to a floating-point number of seconds, including fractional microseconds, since the Unix epoch.",
    "label": "",
    "id": "3182"
  },
  {
    "raw_code": "def to_i\n    seconds_since_unix_epoch.to_i\n  end",
    "comment": "Converts +self+ to an integer number of seconds since the Unix epoch.",
    "label": "",
    "id": "3183"
  },
  {
    "raw_code": "def usec\n    (sec_fraction * 1_000_000).to_i\n  end",
    "comment": "Returns the fraction of a second as microseconds",
    "label": "",
    "id": "3184"
  },
  {
    "raw_code": "def nsec\n    (sec_fraction * 1_000_000_000).to_i\n  end",
    "comment": "Returns the fraction of a second as nanoseconds",
    "label": "",
    "id": "3185"
  },
  {
    "raw_code": "def self.uuid_from_hash(hash_class, namespace, name)\n      if hash_class == Digest::MD5 || hash_class == OpenSSL::Digest::MD5\n        version = 3\n      elsif hash_class == Digest::SHA1 || hash_class == OpenSSL::Digest::SHA1\n        version = 5\n      else\n        raise ArgumentError, \"Expected OpenSSL::Digest::SHA1 or OpenSSL::Digest::MD5, got #{hash_class.name}.\"\n      end",
    "comment": "Generates a v5 non-random UUID (Universally Unique IDentifier).  Using OpenSSL::Digest::MD5 generates version 3 UUIDs; OpenSSL::Digest::SHA1 generates version 5 UUIDs. uuid_from_hash always generates the same UUID for a given name and namespace combination.  See RFC 4122 for details of UUID at: https://www.ietf.org/rfc/rfc4122.txt",
    "label": "",
    "id": "3186"
  },
  {
    "raw_code": "def self.uuid_v3(uuid_namespace, name)\n      uuid_from_hash(OpenSSL::Digest::MD5, uuid_namespace, name)\n    end",
    "comment": "Convenience method for uuid_from_hash using OpenSSL::Digest::MD5.",
    "label": "",
    "id": "3187"
  },
  {
    "raw_code": "def self.uuid_v5(uuid_namespace, name)\n      uuid_from_hash(OpenSSL::Digest::SHA1, uuid_namespace, name)\n    end",
    "comment": "Convenience method for uuid_from_hash using OpenSSL::Digest::SHA1.",
    "label": "",
    "id": "3188"
  },
  {
    "raw_code": "def self.uuid_v4\n      SecureRandom.uuid\n    end",
    "comment": "Convenience method for SecureRandom.uuid.",
    "label": "",
    "id": "3189"
  },
  {
    "raw_code": "def self.nil_uuid\n      \"00000000-0000-0000-0000-000000000000\"\n    end",
    "comment": "Returns the nil UUID. This is a special form of UUID that is specified to have all 128 bits set to zero.",
    "label": "",
    "id": "3190"
  },
  {
    "raw_code": "def html_escape(s) # :nodoc:\n        s = s.to_s\n        if s.html_safe?\n          s\n        else\n          super(s)\n        end",
    "comment": "HTML escapes strings but doesn't wrap them with an ActiveSupport::SafeBuffer. This method is not for public consumption! Seriously!",
    "label": "",
    "id": "3191"
  },
  {
    "raw_code": "def html_escape(s) # rubocop:disable Lint/DuplicateMethods\n        unwrapped_html_escape(s).html_safe\n      end",
    "comment": "A utility method for escaping HTML tag characters. This method is also aliased as <tt>h</tt>.  puts html_escape('is a > 0 & a < 10?') # => is a &gt; 0 &amp; a &lt; 10?",
    "label": "",
    "id": "3192"
  },
  {
    "raw_code": "def html_escape_once(s)\n      s.to_s.gsub(HTML_ESCAPE_ONCE_REGEXP, HTML_ESCAPE).html_safe\n    end",
    "comment": "A utility method for escaping HTML without affecting existing escaped entities.  html_escape_once('1 < 2 &amp; 3') # => \"1 &lt; 2 &amp; 3\"  html_escape_once('&lt;&lt; Accept & Checkout') # => \"&lt;&lt; Accept &amp; Checkout\"",
    "label": "",
    "id": "3193"
  },
  {
    "raw_code": "def json_escape(s)\n      result = s.to_s.dup\n      result.gsub!(\">\", '\\u003e')\n      result.gsub!(\"<\", '\\u003c')\n      result.gsub!(\"&\", '\\u0026')\n      result.gsub!(\"\\u2028\", '\\u2028')\n      result.gsub!(\"\\u2029\", '\\u2029')\n      s.html_safe? ? result.html_safe : result\n    end",
    "comment": "A utility method for escaping HTML entities in JSON strings. Specifically, the &, > and < characters are replaced with their equivalent unicode escaped form - \\u0026, \\u003e, and \\u003c. The Unicode sequences \\u2028 and \\u2029 are also escaped as they are treated as newline characters in some JavaScript engines. These sequences have identical meaning as the original characters inside the context of a JSON string, so assuming the input is a valid and well-formed JSON value, the output will have equivalent meaning when parsed:  json = JSON.generate({ name: \"</script><script>alert('PWNED!!!')</script>\"}) # => \"{\\\"name\\\":\\\"</script><script>alert('PWNED!!!')</script>\\\"}\"  json_escape(json) # => \"{\\\"name\\\":\\\"\\\\u003C/script\\\\u003E\\\\u003Cscript\\\\u003Ealert('PWNED!!!')\\\\u003C/script\\\\u003E\\\"}\"  JSON.parse(json) == JSON.parse(json_escape(json)) # => true  The intended use case for this method is to escape JSON strings before including them inside a script tag to avoid XSS vulnerability:  <script> var currentUser = <%= raw json_escape(current_user.to_json) %>; </script>  It is necessary to +raw+ the result of +json_escape+, so that quotation marks don't get converted to <tt>&quot;</tt> entities. +json_escape+ doesn't automatically flag the result as HTML safe, since the raw value is unsafe to use inside HTML attributes.  If your JSON is being used downstream for insertion into the DOM, be aware of whether or not it is being inserted via <tt>html()</tt>. Most jQuery plugins do this. If that is the case, be sure to +html_escape+ or +sanitize+ any user-generated content returned by your JSON.  If you need to output JSON elsewhere in your HTML, you can just do something like this, as any unsafe characters (including quotation marks) will be automatically escaped for you:  <div data-user-info=\"<%= current_user.to_json %>\">...</div>  WARNING: this helper only works with valid JSON. Using this on non-JSON values will open up serious XSS vulnerabilities. For example, if you replace the +current_user.to_json+ in the example above with user input instead, the browser will happily <tt>eval()</tt> that string as JavaScript.  The escaping performed in this method is identical to those performed in the Active Support JSON encoder when +ActiveSupport.escape_html_entities_in_json+ is set to true. Because this transformation is idempotent, this helper can be applied even if +ActiveSupport.escape_html_entities_in_json+ is already true.  Therefore, when you are unsure if +ActiveSupport.escape_html_entities_in_json+ is enabled, or if you are unsure where your JSON string originated from, it is recommended that you always apply this helper (other libraries, such as the JSON gem, do not provide this kind of protection by default; also some gems might override +to_json+ to bypass Active Support's encoder).",
    "label": "",
    "id": "3194"
  },
  {
    "raw_code": "def xml_name_escape(name)\n      name = name.to_s\n      return \"\" if name.blank?\n      return name if name.match?(SAFE_XML_TAG_NAME_REGEXP)\n\n      starting_char = name[0]\n      starting_char.gsub!(INVALID_TAG_NAME_START_REGEXP, TAG_NAME_REPLACEMENT_CHAR)\n\n      return starting_char if name.size == 1\n\n      following_chars = name[1..-1]\n      following_chars.gsub!(INVALID_TAG_NAME_FOLLOWING_REGEXP, TAG_NAME_REPLACEMENT_CHAR)\n\n      starting_char << following_chars\n    end",
    "comment": "A utility method for escaping XML names of tags and names of attributes.  xml_name_escape('1 < 2 & 3') # => \"1___2___3\"  It follows the requirements of the specification: https://www.w3.org/TR/REC-xml/#NT-Name",
    "label": "",
    "id": "3195"
  },
  {
    "raw_code": "def self.tokenize(source) # :nodoc:\n      require \"strscan\"\n      source = StringScanner.new(source.chomp)\n      tokens = []\n\n      start_re = /<%(?:={1,2}|-|\\#|%)?/m\n      finish_re = /(?:[-=])?%>/m\n\n      while !source.eos?\n        pos = source.pos\n        source.scan_until(/(?:#{start_re}|#{finish_re})/)\n        return [[:PLAIN, source.string]] unless source.matched?\n        len = source.pos - source.matched.bytesize - pos\n\n        case source.matched\n        when start_re\n          tokens << [:TEXT, source.string.byteslice(pos, len)] if len > 0\n          tokens << [:OPEN, source.matched]\n          if source.scan(/(.*?)(?=#{finish_re}|\\z)/m)\n            tokens << [:CODE, source.matched] unless source.matched.empty?\n            tokens << [:CLOSE, source.scan(finish_re)] unless source.eos?\n          else\n            raise NotImplementedError\n          end",
    "comment": "Tokenizes a line of ERB.  This is really just for error reporting and nobody should use it.",
    "label": "",
    "id": "3196"
  },
  {
    "raw_code": "def self.atomic_write(file_name, temp_dir = dirname(file_name))\n    require \"tempfile\" unless defined?(Tempfile)\n\n    Tempfile.open(\".#{basename(file_name)}\", temp_dir) do |temp_file|\n      temp_file.binmode\n      return_val = yield temp_file\n      temp_file.close\n\n      old_stat = if exist?(file_name)\n        # Get original file permissions\n        stat(file_name)\n      else\n        # If not possible, probe which are the default permissions in the\n        # destination directory.\n        probe_stat_in(dirname(file_name))\n      end",
    "comment": "Write to a file atomically. Useful for situations where you don't want other processes or threads to see half-written files.  File.atomic_write('important.file') do |file| file.write('hello') end  This method needs to create a temporary file. By default it will create it in the same directory as the destination file. If you don't like this behavior you can provide a different directory but it must be on the same physical filesystem as the file you're trying to write.  File.atomic_write('/data/something.important', '/data/tmp') do |file| file.write('hello') end",
    "label": "",
    "id": "3197"
  },
  {
    "raw_code": "def self.probe_stat_in(dir) # :nodoc:\n    basename = [\n      \".permissions_check\",\n      Thread.current.object_id,\n      Process.pid,\n      rand(1000000)\n    ].join(\".\")\n\n    file_name = join(dir, basename)\n    FileUtils.touch(file_name)\n    stat(file_name)\n  rescue Errno::ENOENT\n    file_name = nil\n  ensure\n    FileUtils.rm_f(file_name) if file_name\n  end",
    "comment": "Private utility method.",
    "label": "",
    "id": "3198"
  },
  {
    "raw_code": "def to_xml(options = {})\n    require \"active_support/builder\" unless defined?(Builder::XmlMarkup)\n\n    options = options.dup\n    options[:indent]  ||= 2\n    options[:root]    ||= \"hash\"\n    options[:builder] ||= Builder::XmlMarkup.new(indent: options[:indent])\n\n    builder = options[:builder]\n    builder.instruct! unless options.delete(:skip_instruct)\n\n    root = ActiveSupport::XmlMini.rename_key(options[:root].to_s, options)\n\n    builder.tag!(root) do\n      each { |key, value| ActiveSupport::XmlMini.to_tag(key, value, options) }\n      yield builder if block_given?\n    end",
    "comment": "Returns a string containing an XML representation of its receiver:  { foo: 1, bar: 2 }.to_xml # => # <?xml version=\"1.0\" encoding=\"UTF-8\"?> # <hash> #   <foo type=\"integer\">1</foo> #   <bar type=\"integer\">2</bar> # </hash>  To do so, the method loops over the pairs and builds nodes that depend on the _values_. Given a pair +key+, +value+:  * If +value+ is a hash there's a recursive call with +key+ as <tt>:root</tt>.  * If +value+ is an array there's a recursive call with +key+ as <tt>:root</tt>, and +key+ singularized as <tt>:children</tt>.  * If +value+ is a callable object it must expect one or two arguments. Depending on the arity, the callable is invoked with the +options+ hash as first argument with +key+ as <tt>:root</tt>, and +key+ singularized as second argument. The callable can add nodes by using <tt>options[:builder]</tt>.  {foo: lambda { |options, key| options[:builder].b(key) }}.to_xml # => \"<b>foo</b>\"  * If +value+ responds to +to_xml+ the method is invoked with +key+ as <tt>:root</tt>.  class Foo def to_xml(options) options[:builder].bar 'fooing!' end end  { foo: Foo.new }.to_xml(skip_instruct: true) # => # <hash> #   <bar>fooing!</bar> # </hash>  * Otherwise, a node with +key+ as tag is created with a string representation of +value+ as text node. If +value+ is +nil+ an attribute \"nil\" set to \"true\" is added. Unless the option <tt>:skip_types</tt> exists and is true, an attribute \"type\" is added as well according to the following mapping:  XML_TYPE_NAMES = { \"Symbol\"     => \"symbol\", \"Integer\"    => \"integer\", \"BigDecimal\" => \"decimal\", \"Float\"      => \"float\", \"TrueClass\"  => \"boolean\", \"FalseClass\" => \"boolean\", \"Date\"       => \"date\", \"DateTime\"   => \"dateTime\", \"Time\"       => \"dateTime\" }  By default the root node is \"hash\", but that's configurable via the <tt>:root</tt> option.  The default XML builder is a fresh instance of +Builder::XmlMarkup+. You can configure your own builder with the <tt>:builder</tt> option. The method also accepts options like <tt>:dasherize</tt> and friends, they are forwarded to the builder.",
    "label": "",
    "id": "3199"
  },
  {
    "raw_code": "def from_xml(xml, disallowed_types = nil)\n      ActiveSupport::XMLConverter.new(xml, disallowed_types).to_h\n    end",
    "comment": "Returns a Hash containing a collection of pairs when the key is the node name and the value is its content  xml = <<-XML <?xml version=\"1.0\" encoding=\"UTF-8\"?> <hash> <foo type=\"integer\">1</foo> <bar type=\"integer\">2</bar> </hash> XML  hash = Hash.from_xml(xml) # => {\"hash\"=>{\"foo\"=>1, \"bar\"=>2}}  +DisallowedType+ is raised if the XML contains attributes with <tt>type=\"yaml\"</tt> or <tt>type=\"symbol\"</tt>. Use <tt>Hash.from_trusted_xml</tt> to parse this XML.  Custom +disallowed_types+ can also be passed in the form of an array.  xml = <<-XML <?xml version=\"1.0\" encoding=\"UTF-8\"?> <hash> <foo type=\"integer\">1</foo> <bar type=\"string\">\"David\"</bar> </hash> XML  hash = Hash.from_xml(xml, ['integer']) # => ActiveSupport::XMLConverter::DisallowedType: Disallowed type attribute: \"integer\"  Note that passing custom disallowed types will override the default types, which are Symbol and YAML.",
    "label": "",
    "id": "3200"
  },
  {
    "raw_code": "def from_trusted_xml(xml)\n      from_xml xml, []\n    end",
    "comment": "Builds a Hash from XML just like <tt>Hash.from_xml</tt>, but also allows Symbol and YAML.",
    "label": "",
    "id": "3201"
  },
  {
    "raw_code": "def deep_merge?(other) # :nodoc:\n    other.is_a?(Hash)\n  end",
    "comment": " :method: deep_merge :call-seq: deep_merge(other_hash, &block)  Returns a new hash with +self+ and +other_hash+ merged recursively.  h1 = { a: true, b: { c: [1, 2, 3] } } h2 = { a: false, b: { x: [3, 4, 5] } }  h1.deep_merge(h2) # => { a: false, b: { c: [1, 2, 3], x: [3, 4, 5] } }  Like with Hash#merge in the standard library, a block can be provided to merge values:  h1 = { a: 100, b: 200, c: { c1: 100 } } h2 = { b: 250, c: { c1: 200 } } h1.deep_merge(h2) { |key, this_val, other_val| this_val + other_val } # => { a: 100, b: 450, c: { c1: 300 } }  -- Implemented by ActiveSupport::DeepMergeable#deep_merge.  :method: deep_merge! :call-seq: deep_merge!(other_hash, &block)  Same as #deep_merge, but modifies +self+.  -- Implemented by ActiveSupport::DeepMergeable#deep_merge!. ",
    "label": "",
    "id": "3202"
  },
  {
    "raw_code": "def deep_transform_values(&block)\n    _deep_transform_values_in_object(self, &block)\n  end",
    "comment": "Returns a new hash with all values converted by the block operation. This includes the values from the root hash and from all nested hashes and arrays.  hash = { person: { name: 'Rob', age: '28' } }  hash.deep_transform_values{ |value| value.to_s.upcase } # => {person: {name: \"ROB\", age: \"28\"}}",
    "label": "",
    "id": "3203"
  },
  {
    "raw_code": "def deep_transform_values!(&block)\n    _deep_transform_values_in_object!(self, &block)\n  end",
    "comment": "Destructively converts all values by using the block operation. This includes the values from the root hash and from all nested hashes and arrays.",
    "label": "",
    "id": "3204"
  },
  {
    "raw_code": "def _deep_transform_values_in_object(object, &block)\n      case object\n      when Hash\n        object.transform_values { |value| _deep_transform_values_in_object(value, &block) }\n      when Array\n        object.map { |e| _deep_transform_values_in_object(e, &block) }\n      else\n        yield(object)\n      end",
    "comment": "Support methods for deep transforming nested hashes and arrays.",
    "label": "",
    "id": "3205"
  },
  {
    "raw_code": "def except!(*keys)\n    keys.each { |key| delete(key) }\n    self\n  end",
    "comment": "Removes the given keys from hash and returns it. hash = { a: true, b: false, c: nil } hash.except!(:c) # => { a: true, b: false } hash             # => { a: true, b: false }",
    "label": "",
    "id": "3206"
  },
  {
    "raw_code": "def with_indifferent_access\n    ActiveSupport::HashWithIndifferentAccess.new(self)\n  end",
    "comment": "Returns an ActiveSupport::HashWithIndifferentAccess out of its receiver:  { a: 1 }.with_indifferent_access['a'] # => 1",
    "label": "",
    "id": "3207"
  },
  {
    "raw_code": "def stringify_keys\n    transform_keys { |k| Symbol === k ? k.name : k.to_s }\n  end",
    "comment": "Returns a new hash with all keys converted to strings.  hash = { name: 'Rob', age: '28' }  hash.stringify_keys # => {\"name\"=>\"Rob\", \"age\"=>\"28\"}",
    "label": "",
    "id": "3208"
  },
  {
    "raw_code": "def stringify_keys!\n    transform_keys! { |k| Symbol === k ? k.name : k.to_s }\n  end",
    "comment": "Destructively converts all keys to strings. Same as +stringify_keys+, but modifies +self+.",
    "label": "",
    "id": "3209"
  },
  {
    "raw_code": "def symbolize_keys\n    transform_keys { |key| key.to_sym rescue key }\n  end",
    "comment": "Returns a new hash with all keys converted to symbols, as long as they respond to +to_sym+.  hash = { 'name' => 'Rob', 'age' => '28' }  hash.symbolize_keys # => {:name=>\"Rob\", :age=>\"28\"}",
    "label": "",
    "id": "3210"
  },
  {
    "raw_code": "def symbolize_keys!\n    transform_keys! { |key| key.to_sym rescue key }\n  end",
    "comment": "Destructively converts all keys to symbols, as long as they respond to +to_sym+. Same as +symbolize_keys+, but modifies +self+.",
    "label": "",
    "id": "3211"
  },
  {
    "raw_code": "def assert_valid_keys(*valid_keys)\n    valid_keys.flatten!\n    each_key do |k|\n      unless valid_keys.include?(k)\n        raise ArgumentError.new(\"Unknown key: #{k.inspect}. Valid keys are: #{valid_keys.map(&:inspect).join(', ')}\")\n      end",
    "comment": "Validates all keys in a hash match <tt>*valid_keys</tt>, raising +ArgumentError+ on a mismatch.  Note that keys are treated differently than HashWithIndifferentAccess, meaning that string and symbol keys will not match.  { name: 'Rob', years: '28' }.assert_valid_keys(:name, :age) # => raises \"ArgumentError: Unknown key: :years. Valid keys are: :name, :age\" { name: 'Rob', age: '28' }.assert_valid_keys('name', 'age') # => raises \"ArgumentError: Unknown key: :name. Valid keys are: 'name', 'age'\" { name: 'Rob', age: '28' }.assert_valid_keys(:name, :age)   # => passes, raises nothing",
    "label": "",
    "id": "3212"
  },
  {
    "raw_code": "def deep_transform_keys(&block)\n    _deep_transform_keys_in_object(self, &block)\n  end",
    "comment": "Returns a new hash with all keys converted by the block operation. This includes the keys from the root hash and from all nested hashes and arrays.  hash = { person: { name: 'Rob', age: '28' } }  hash.deep_transform_keys{ |key| key.to_s.upcase } # => {\"PERSON\"=>{\"NAME\"=>\"Rob\", \"AGE\"=>\"28\"}}",
    "label": "",
    "id": "3213"
  },
  {
    "raw_code": "def deep_transform_keys!(&block)\n    _deep_transform_keys_in_object!(self, &block)\n  end",
    "comment": "Destructively converts all keys by using the block operation. This includes the keys from the root hash and from all nested hashes and arrays.",
    "label": "",
    "id": "3214"
  },
  {
    "raw_code": "def deep_stringify_keys\n    deep_transform_keys { |k| Symbol === k ? k.name : k.to_s }\n  end",
    "comment": "Returns a new hash with all keys converted to strings. This includes the keys from the root hash and from all nested hashes and arrays.  hash = { person: { name: 'Rob', age: '28' } }  hash.deep_stringify_keys # => {\"person\"=>{\"name\"=>\"Rob\", \"age\"=>\"28\"}}",
    "label": "",
    "id": "3215"
  },
  {
    "raw_code": "def deep_stringify_keys!\n    deep_transform_keys! { |k| Symbol === k ? k.name : k.to_s }\n  end",
    "comment": "Destructively converts all keys to strings. This includes the keys from the root hash and from all nested hashes and arrays.",
    "label": "",
    "id": "3216"
  },
  {
    "raw_code": "def deep_symbolize_keys\n    deep_transform_keys { |key| key.to_sym rescue key }\n  end",
    "comment": "Returns a new hash with all keys converted to symbols, as long as they respond to +to_sym+. This includes the keys from the root hash and from all nested hashes and arrays.  hash = { 'person' => { 'name' => 'Rob', 'age' => '28' } }  hash.deep_symbolize_keys # => {:person=>{:name=>\"Rob\", :age=>\"28\"}}",
    "label": "",
    "id": "3217"
  },
  {
    "raw_code": "def deep_symbolize_keys!\n    deep_transform_keys! { |key| key.to_sym rescue key }\n  end",
    "comment": "Destructively converts all keys to symbols, as long as they respond to +to_sym+. This includes the keys from the root hash and from all nested hashes and arrays.",
    "label": "",
    "id": "3218"
  },
  {
    "raw_code": "def _deep_transform_keys_in_object(object, &block)\n      case object\n      when Hash\n        object.each_with_object(self.class.new) do |(key, value), result|\n          result[yield(key)] = _deep_transform_keys_in_object(value, &block)\n        end",
    "comment": "Support methods for deep transforming nested hashes and arrays.",
    "label": "",
    "id": "3219"
  },
  {
    "raw_code": "def reverse_merge(other_hash)\n    other_hash.merge(self)\n  end",
    "comment": "Merges the caller into +other_hash+. For example,  options = options.reverse_merge(size: 25, velocity: 10)  is equivalent to  options = { size: 25, velocity: 10 }.merge(options)  This is particularly useful for initializing an options hash with default values.",
    "label": "",
    "id": "3220"
  },
  {
    "raw_code": "def reverse_merge!(other_hash)\n    replace(reverse_merge(other_hash))\n  end",
    "comment": "Destructive +reverse_merge+.",
    "label": "",
    "id": "3221"
  },
  {
    "raw_code": "def slice!(*keys)\n    omit = slice(*self.keys - keys)\n    hash = slice(*keys)\n    hash.default      = default\n    hash.default_proc = default_proc if default_proc\n    replace(hash)\n    omit\n  end",
    "comment": "Replaces the hash with only the given keys. Returns a hash containing the removed key/value pairs.  hash = { a: 1, b: 2, c: 3, d: 4 } hash.slice!(:a, :b)  # => {:c=>3, :d=>4} hash                 # => {:a=>1, :b=>2}",
    "label": "",
    "id": "3222"
  },
  {
    "raw_code": "def extract!(*keys)\n    keys.each_with_object(self.class.new) { |key, result| result[key] = delete(key) if has_key?(key) }\n  end",
    "comment": "Removes and returns the key/value pairs matching the given keys.  hash = { a: 1, b: 2, c: 3, d: 4 } hash.extract!(:a, :b) # => {:a=>1, :b=>2} hash                  # => {:c=>3, :d=>4}",
    "label": "",
    "id": "3223"
  },
  {
    "raw_code": "def ordinalize\n    ActiveSupport::Inflector.ordinalize(self)\n  end",
    "comment": "Ordinalize turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.  1.ordinalize     # => \"1st\" 2.ordinalize     # => \"2nd\" 1002.ordinalize  # => \"1002nd\" 1003.ordinalize  # => \"1003rd\" -11.ordinalize   # => \"-11th\" -1001.ordinalize # => \"-1001st\"",
    "label": "",
    "id": "3224"
  },
  {
    "raw_code": "def ordinal\n    ActiveSupport::Inflector.ordinal(self)\n  end",
    "comment": "Ordinal returns the suffix used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.  1.ordinal     # => \"st\" 2.ordinal     # => \"nd\" 1002.ordinal  # => \"nd\" 1003.ordinal  # => \"rd\" -11.ordinal   # => \"th\" -1001.ordinal # => \"st\"",
    "label": "",
    "id": "3225"
  },
  {
    "raw_code": "def multiple_of?(number)\n    number == 0 ? self == 0 : self % number == 0\n  end",
    "comment": "Check whether the integer is evenly divisible by the argument.  0.multiple_of?(0)  # => true 6.multiple_of?(5)  # => false 10.multiple_of?(2) # => true",
    "label": "",
    "id": "3226"
  },
  {
    "raw_code": "def months\n    ActiveSupport::Duration.months(self)\n  end",
    "comment": "Returns a Duration instance matching the number of months provided.  2.months # => 2 months",
    "label": "",
    "id": "3227"
  },
  {
    "raw_code": "def years\n    ActiveSupport::Duration.years(self)\n  end",
    "comment": "Returns a Duration instance matching the number of years provided.  2.years # => 2 years",
    "label": "",
    "id": "3228"
  },
  {
    "raw_code": "def concern(topic, &module_definition)\n    Object.concern topic, &module_definition\n  end",
    "comment": "A shortcut to define a toplevel concern, not within a module.  See Module::Concerning for more.",
    "label": "",
    "id": "3229"
  },
  {
    "raw_code": "def silence_warnings(&block)\n    with_warnings(nil, &block)\n  end",
    "comment": "Sets $VERBOSE to +nil+ for the duration of the block and back to its original value afterwards.  silence_warnings do value = noisy_call # no warning voiced end  noisy_call # warning voiced",
    "label": "",
    "id": "3230"
  },
  {
    "raw_code": "def enable_warnings(&block)\n    with_warnings(true, &block)\n  end",
    "comment": "Sets $VERBOSE to +true+ for the duration of the block and back to its original value afterwards.",
    "label": "",
    "id": "3231"
  },
  {
    "raw_code": "def with_warnings(flag)\n    old_verbose, $VERBOSE = $VERBOSE, flag\n    yield\n  ensure\n    $VERBOSE = old_verbose\n  end",
    "comment": "Sets $VERBOSE for the duration of the block and back to its original value afterwards.",
    "label": "",
    "id": "3232"
  },
  {
    "raw_code": "def suppress(*exception_classes)\n    yield\n  rescue *exception_classes\n  end",
    "comment": "Blocks and ignores any exception passed as argument if raised within the block.  suppress(ZeroDivisionError) do 1/0 puts 'This code is NOT reached' end  puts 'This code gets executed and nothing related to ZeroDivisionError was seen'",
    "label": "",
    "id": "3233"
  },
  {
    "raw_code": "def class_eval(*args, &block)\n    singleton_class.class_eval(*args, &block)\n  end",
    "comment": "class_eval on an object acts like +singleton_class.class_eval+.",
    "label": "",
    "id": "3234"
  },
  {
    "raw_code": "def alias_attribute(new_name, old_name)\n    # The following reader methods use an explicit `self` receiver in order to\n    # support aliases that start with an uppercase letter. Otherwise, they would\n    # be resolved as constants instead.\n    module_eval <<-STR, __FILE__, __LINE__ + 1\n      def #{new_name}; self.#{old_name}; end          # def subject; self.title; end\n      def #{new_name}?; self.#{old_name}?; end        # def subject?; self.title?; end\n      def #{new_name}=(v); self.#{old_name} = v; end  # def subject=(v); self.title = v; end\n    STR\n  end\nend",
    "comment": "Allows you to make aliases for attributes, which includes getter, setter, and a predicate.  class Content < ActiveRecord::Base # has a title attribute end  class Email < Content alias_attribute :subject, :title end  e = Email.find(1) e.title    # => \"Superstars\" e.subject  # => \"Superstars\" e.subject? # => true e.subject = \"Megastars\" e.title    # => \"Megastars\"",
    "label": "",
    "id": "3235"
  },
  {
    "raw_code": "def anonymous?\n    name.nil?\n  end",
    "comment": "A module may or may not have a name.  module M; end M.name # => \"M\"  m = Module.new m.name # => nil  +anonymous?+ method returns true if module does not have a name, false otherwise:  Module.new.anonymous? # => true  module M; end M.anonymous?          # => false  A module gets a name when it is first assigned to a constant. Either via the +module+ or +class+ keyword or by an explicit assignment:  m = Module.new # creates an anonymous module m.anonymous?   # => true M = m          # m gets a name here as a side-effect m.name         # => \"M\" m.anonymous?   # => false",
    "label": "",
    "id": "3236"
  },
  {
    "raw_code": "def mattr_reader(*syms, instance_reader: true, instance_accessor: true, default: nil, location: nil)\n    raise TypeError, \"module attributes should be defined directly on class, not singleton\" if singleton_class?\n    location ||= caller_locations(1, 1).first\n\n    definition = []\n    syms.each do |sym|\n      raise NameError.new(\"invalid attribute name: #{sym}\") unless /\\A[_A-Za-z]\\w*\\z/.match?(sym)\n\n      definition << \"def self.#{sym}; @@#{sym}; end\"\n\n      if instance_reader && instance_accessor\n        definition << \"def #{sym}; @@#{sym}; end\"\n      end",
    "comment": "Defines a class attribute and creates a class and instance reader methods. The underlying class variable is set to +nil+, if it is not previously defined. All class and instance methods created will be public, even if this method is called with a private or protected access modifier.  module HairColors mattr_reader :hair_colors end  HairColors.hair_colors # => nil HairColors.class_variable_set(\"@@hair_colors\", [:brown, :black]) HairColors.hair_colors # => [:brown, :black]  The attribute name must be a valid method name in Ruby.  module Foo mattr_reader :\"1_Badname\" end # => NameError: invalid attribute name: 1_Badname  To omit the instance reader method, pass <tt>instance_reader: false</tt> or <tt>instance_accessor: false</tt>.  module HairColors mattr_reader :hair_colors, instance_reader: false end  class Person include HairColors end  Person.new.hair_colors # => NoMethodError  You can set a default value for the attribute.  module HairColors mattr_reader :hair_colors, default: [:brown, :black, :blonde, :red] mattr_reader(:hair_styles) { [:long, :short] } end  class Person include HairColors end  Person.new.hair_colors # => [:brown, :black, :blonde, :red] Person.new.hair_styles # => [:long, :short]",
    "label": "",
    "id": "3237"
  },
  {
    "raw_code": "def mattr_writer(*syms, instance_writer: true, instance_accessor: true, default: nil, location: nil)\n    raise TypeError, \"module attributes should be defined directly on class, not singleton\" if singleton_class?\n    location ||= caller_locations(1, 1).first\n\n    definition = []\n    syms.each do |sym|\n      raise NameError.new(\"invalid attribute name: #{sym}\") unless /\\A[_A-Za-z]\\w*\\z/.match?(sym)\n      definition << \"def self.#{sym}=(val); @@#{sym} = val; end\"\n\n      if instance_writer && instance_accessor\n        definition << \"def #{sym}=(val); @@#{sym} = val; end\"\n      end",
    "comment": "Defines a class attribute and creates a class and instance writer methods to allow assignment to the attribute. All class and instance methods created will be public, even if this method is called with a private or protected access modifier.  module HairColors mattr_writer :hair_colors end  class Person include HairColors end  HairColors.hair_colors = [:brown, :black] Person.class_variable_get(\"@@hair_colors\") # => [:brown, :black] Person.new.hair_colors = [:blonde, :red] HairColors.class_variable_get(\"@@hair_colors\") # => [:blonde, :red]  To omit the instance writer method, pass <tt>instance_writer: false</tt> or <tt>instance_accessor: false</tt>.  module HairColors mattr_writer :hair_colors, instance_writer: false end  class Person include HairColors end  Person.new.hair_colors = [:blonde, :red] # => NoMethodError  You can set a default value for the attribute.  module HairColors mattr_writer :hair_colors, default: [:brown, :black, :blonde, :red] mattr_writer(:hair_styles) { [:long, :short] } end  class Person include HairColors end  Person.class_variable_get(\"@@hair_colors\") # => [:brown, :black, :blonde, :red] Person.class_variable_get(\"@@hair_styles\") # => [:long, :short]",
    "label": "",
    "id": "3238"
  },
  {
    "raw_code": "def mattr_accessor(*syms, instance_reader: true, instance_writer: true, instance_accessor: true, default: nil, &blk)\n    location = caller_locations(1, 1).first\n    mattr_reader(*syms, instance_reader: instance_reader, instance_accessor: instance_accessor, default: default, location: location, &blk)\n    mattr_writer(*syms, instance_writer: instance_writer, instance_accessor: instance_accessor, default: default, location: location)\n  end",
    "comment": "Defines both class and instance accessors for class attributes. All class and instance methods created will be public, even if this method is called with a private or protected access modifier.  module HairColors mattr_accessor :hair_colors end  class Person include HairColors end  HairColors.hair_colors = [:brown, :black, :blonde, :red] HairColors.hair_colors # => [:brown, :black, :blonde, :red] Person.new.hair_colors # => [:brown, :black, :blonde, :red]  If a subclass changes the value then that would also change the value for parent class. Similarly if parent class changes the value then that would change the value of subclasses too.  class Citizen < Person end  Citizen.new.hair_colors << :blue Person.new.hair_colors # => [:brown, :black, :blonde, :red, :blue]  To omit the instance writer method, pass <tt>instance_writer: false</tt>. To omit the instance reader method, pass <tt>instance_reader: false</tt>.  module HairColors mattr_accessor :hair_colors, instance_writer: false, instance_reader: false end  class Person include HairColors end  Person.new.hair_colors = [:brown]  # => NoMethodError Person.new.hair_colors             # => NoMethodError  Or pass <tt>instance_accessor: false</tt>, to omit both instance methods.  module HairColors mattr_accessor :hair_colors, instance_accessor: false end  class Person include HairColors end  Person.new.hair_colors = [:brown]  # => NoMethodError Person.new.hair_colors             # => NoMethodError  You can set a default value for the attribute.  module HairColors mattr_accessor :hair_colors, default: [:brown, :black, :blonde, :red] mattr_accessor(:hair_styles) { [:long, :short] } end  class Person include HairColors end  Person.class_variable_get(\"@@hair_colors\") # => [:brown, :black, :blonde, :red] Person.class_variable_get(\"@@hair_styles\") # => [:long, :short]",
    "label": "",
    "id": "3239"
  },
  {
    "raw_code": "def thread_mattr_reader(*syms, instance_reader: true, instance_accessor: true, default: nil) # :nodoc:\n    syms.each do |sym|\n      raise NameError.new(\"invalid attribute name: #{sym}\") unless /^[_A-Za-z]\\w*$/.match?(sym)\n\n      # The following generated method concatenates `object_id` because we want\n      # subclasses to maintain independent values.\n      if default.nil?\n        class_eval(<<-EOS, __FILE__, __LINE__ + 1)\n          def self.#{sym}\n            @__thread_mattr_#{sym} ||= \"attr_#{sym}_\\#{object_id}\"\n            ::ActiveSupport::IsolatedExecutionState[@__thread_mattr_#{sym}]\n          end\n        EOS\n      else\n        default = default.dup.freeze unless default.frozen?\n        singleton_class.define_method(\"#{sym}_default_value\") { default }\n\n        class_eval(<<-EOS, __FILE__, __LINE__ + 1)\n          def self.#{sym}\n            @__thread_mattr_#{sym} ||= \"attr_#{sym}_\\#{object_id}\"\n            value = ::ActiveSupport::IsolatedExecutionState[@__thread_mattr_#{sym}]\n\n            if value.nil? && !::ActiveSupport::IsolatedExecutionState.key?(@__thread_mattr_#{sym})\n              ::ActiveSupport::IsolatedExecutionState[@__thread_mattr_#{sym}] = #{sym}_default_value\n            else\n              value\n            end\n          end",
    "comment": "Defines a per-thread class attribute and creates class and instance reader methods. The underlying per-thread class variable is set to +nil+, if it is not previously defined.  module Current thread_mattr_reader :user end  Current.user = \"DHH\" Current.user # => \"DHH\" Thread.new { Current.user }.value # => nil  The attribute name must be a valid method name in Ruby.  module Foo thread_mattr_reader :\"1_Badname\" end # => NameError: invalid attribute name: 1_Badname  To omit the instance reader method, pass <tt>instance_reader: false</tt> or <tt>instance_accessor: false</tt>.  class Current thread_mattr_reader :user, instance_reader: false end  Current.new.user # => NoMethodError",
    "label": "",
    "id": "3240"
  },
  {
    "raw_code": "def thread_mattr_writer(*syms, instance_writer: true, instance_accessor: true) # :nodoc:\n    syms.each do |sym|\n      raise NameError.new(\"invalid attribute name: #{sym}\") unless /^[_A-Za-z]\\w*$/.match?(sym)\n\n      # The following generated method concatenates `object_id` because we want\n      # subclasses to maintain independent values.\n      class_eval(<<-EOS, __FILE__, __LINE__ + 1)\n        def self.#{sym}=(obj)\n          @__thread_mattr_#{sym} ||= \"attr_#{sym}_\\#{object_id}\"\n          ::ActiveSupport::IsolatedExecutionState[@__thread_mattr_#{sym}] = obj\n        end\n      EOS\n\n      if instance_writer && instance_accessor\n        class_eval(<<-EOS, __FILE__, __LINE__ + 1)\n          def #{sym}=(obj)\n            self.class.#{sym} = obj\n          end\n        EOS\n      end",
    "comment": "Defines a per-thread class attribute and creates a class and instance writer methods to allow assignment to the attribute.  module Current thread_mattr_writer :user end  Current.user = \"DHH\" Thread.current[:attr_Current_user] # => \"DHH\"  To omit the instance writer method, pass <tt>instance_writer: false</tt> or <tt>instance_accessor: false</tt>.  class Current thread_mattr_writer :user, instance_writer: false end  Current.new.user = \"DHH\" # => NoMethodError",
    "label": "",
    "id": "3241"
  },
  {
    "raw_code": "def thread_mattr_accessor(*syms, instance_reader: true, instance_writer: true, instance_accessor: true, default: nil)\n    thread_mattr_reader(*syms, instance_reader: instance_reader, instance_accessor: instance_accessor, default: default)\n    thread_mattr_writer(*syms, instance_writer: instance_writer, instance_accessor: instance_accessor)\n  end",
    "comment": "Defines both class and instance accessors for class attributes.  class Account thread_mattr_accessor :user end  Account.user = \"DHH\" Account.user     # => \"DHH\" Account.new.user # => \"DHH\"  Unlike +mattr_accessor+, values are *not* shared with subclasses or parent classes. If a subclass changes the value, the parent class' value is not changed. If the parent class changes the value, the value of subclasses is not changed.  class Customer < Account end  Account.user   # => \"DHH\" Customer.user  # => nil Customer.user  = \"Rafael\" Customer.user  # => \"Rafael\" Account.user   # => \"DHH\"  To omit the instance writer method, pass <tt>instance_writer: false</tt>. To omit the instance reader method, pass <tt>instance_reader: false</tt>.  class Current thread_mattr_accessor :user, instance_writer: false, instance_reader: false end  Current.new.user = \"DHH\"  # => NoMethodError Current.new.user          # => NoMethodError  Or pass <tt>instance_accessor: false</tt>, to omit both instance methods.  class Current thread_mattr_accessor :user, instance_accessor: false end  Current.new.user = \"DHH\"  # => NoMethodError Current.new.user          # => NoMethodError  A default value may be specified using the +:default+ option. Because multiple threads can access the default value, non-frozen default values will be <tt>dup</tt>ed and frozen.",
    "label": "",
    "id": "3242"
  },
  {
    "raw_code": "def attr_internal_reader(*attrs)\n    attrs.each { |attr_name| attr_internal_define(attr_name, :reader) }\n  end",
    "comment": "Declares an attribute reader backed by an internally-named instance variable.",
    "label": "",
    "id": "3243"
  },
  {
    "raw_code": "def attr_internal_writer(*attrs)\n    attrs.each { |attr_name| attr_internal_define(attr_name, :writer) }\n  end",
    "comment": "Declares an attribute writer backed by an internally-named instance variable.",
    "label": "",
    "id": "3244"
  },
  {
    "raw_code": "def attr_internal_accessor(*attrs)\n    attr_internal_reader(*attrs)\n    attr_internal_writer(*attrs)\n  end",
    "comment": "Declares an attribute reader and writer backed by an internally-named instance variable.",
    "label": "",
    "id": "3245"
  },
  {
    "raw_code": "def concerning(topic, prepend: false, &block)\n      method = prepend ? :prepend : :include\n      __send__(method, concern(topic, &block))\n    end",
    "comment": "Define a new concern and mix it in.",
    "label": "",
    "id": "3246"
  },
  {
    "raw_code": "def concern(topic, &module_definition)\n      const_set topic, Module.new {\n        extend ::ActiveSupport::Concern\n        module_eval(&module_definition)\n      }\n    end",
    "comment": "A low-cruft shortcut to define a concern.  concern :EventTracking do ... end  is equivalent to  module EventTracking extend ActiveSupport::Concern  ... end",
    "label": "",
    "id": "3247"
  },
  {
    "raw_code": "def delegate(*methods, to: nil, prefix: nil, allow_nil: nil, private: nil)\n    ::ActiveSupport::Delegation.generate(\n      self,\n      methods,\n      location: caller_locations(1, 1).first,\n      to: to,\n      prefix: prefix,\n      allow_nil: allow_nil,\n      private: private,\n    )\n  end",
    "comment": "Provides a +delegate+ class method to easily expose contained objects' public methods as your own.  ==== Options * <tt>:to</tt> - Specifies the target object name as a symbol or string * <tt>:prefix</tt> - Prefixes the new method with the target name or a custom prefix * <tt>:allow_nil</tt> - If set to true, prevents a +ActiveSupport::DelegationError+ from being raised * <tt>:private</tt> - If set to true, changes method visibility to private  The macro receives one or more method names (specified as symbols or strings) and the name of the target object via the <tt>:to</tt> option (also a symbol or string).  Delegation is particularly useful with Active Record associations:  class Greeter < ActiveRecord::Base def hello 'hello' end  def goodbye 'goodbye' end end  class Foo < ActiveRecord::Base belongs_to :greeter delegate :hello, to: :greeter end  Foo.new.hello   # => \"hello\" Foo.new.goodbye # => NoMethodError: undefined method `goodbye' for #<Foo:0x1af30c>  Multiple delegates to the same target are allowed:  class Foo < ActiveRecord::Base belongs_to :greeter delegate :hello, :goodbye, to: :greeter end  Foo.new.goodbye # => \"goodbye\"  Methods can be delegated to instance variables, class variables, or constants by providing them as a symbols:  class Foo CONSTANT_ARRAY = [0,1,2,3] @@class_array  = [4,5,6,7]  def initialize @instance_array = [8,9,10,11] end delegate :sum, to: :CONSTANT_ARRAY delegate :min, to: :@@class_array delegate :max, to: :@instance_array end  Foo.new.sum # => 6 Foo.new.min # => 4 Foo.new.max # => 11  It's also possible to delegate a method to the class by using +:class+:  class Foo def self.hello \"world\" end  delegate :hello, to: :class end  Foo.new.hello # => \"world\"  Delegates can optionally be prefixed using the <tt>:prefix</tt> option. If the value is <tt>true</tt>, the delegate methods are prefixed with the name of the object being delegated to.  Person = Struct.new(:name, :address)  class Invoice < Struct.new(:client) delegate :name, :address, to: :client, prefix: true end  john_doe = Person.new('John Doe', 'Vimmersvej 13') invoice = Invoice.new(john_doe) invoice.client_name    # => \"John Doe\" invoice.client_address # => \"Vimmersvej 13\"  It is also possible to supply a custom prefix.  class Invoice < Struct.new(:client) delegate :name, :address, to: :client, prefix: :customer end  invoice = Invoice.new(john_doe) invoice.customer_name    # => 'John Doe' invoice.customer_address # => 'Vimmersvej 13'  The delegated methods are public by default. Pass <tt>private: true</tt> to change that.  class User < ActiveRecord::Base has_one :profile delegate :first_name, to: :profile delegate :date_of_birth, to: :profile, private: true  def age Date.today.year - date_of_birth.year end end  User.new.first_name # => \"Tomas\" User.new.date_of_birth # => NoMethodError: private method `date_of_birth' called for #<User:0x00000008221340> User.new.age # => 2  If the target is +nil+ and does not respond to the delegated method a +ActiveSupport::DelegationError+ is raised. If you wish to instead return +nil+, use the <tt>:allow_nil</tt> option.  class User < ActiveRecord::Base has_one :profile delegate :age, to: :profile end  User.new.age # => ActiveSupport::DelegationError: User#age delegated to profile.age, but profile is nil  But if not having a profile yet is fine and should not be an error condition:  class User < ActiveRecord::Base has_one :profile delegate :age, to: :profile, allow_nil: true end  User.new.age # nil  Note that if the target is not +nil+ then the call is attempted regardless of the <tt>:allow_nil</tt> option, and thus an exception is still raised if said object does not respond to the method:  class Foo def initialize(bar) @bar = bar end  delegate :name, to: :@bar, allow_nil: true end  Foo.new(\"Bar\").name # raises NoMethodError: undefined method `name'  The target method must be public, otherwise it will raise +NoMethodError+.",
    "label": "",
    "id": "3248"
  },
  {
    "raw_code": "def delegate_missing_to(target, allow_nil: nil)\n    ::ActiveSupport::Delegation.generate_method_missing(\n      self,\n      target,\n      allow_nil: allow_nil,\n    )\n  end",
    "comment": "When building decorators, a common pattern may emerge:  class Partition def initialize(event) @event = event end  def person detail.person || creator end  private def respond_to_missing?(name, include_private = false) @event.respond_to?(name, include_private) end  def method_missing(method, *args, &block) @event.send(method, *args, &block) end end  With <tt>Module#delegate_missing_to</tt>, the above is condensed to:  class Partition delegate_missing_to :@event  def initialize(event) @event = event end  def person detail.person || creator end end  The target can be anything callable within the object, e.g. instance variables, methods, constants, etc.  The delegated method must be public on the target, otherwise it will raise +ActiveSupport::DelegationError+. If you wish to instead return +nil+, use the <tt>:allow_nil</tt> option.  The <tt>marshal_dump</tt> and <tt>_dump</tt> methods are exempt from delegation due to possible interference when calling <tt>Marshal.dump(object)</tt>, should the delegation target method of <tt>object</tt> add or remove instance variables.",
    "label": "",
    "id": "3249"
  },
  {
    "raw_code": "def deprecate(*method_names, deprecator:, **options)\n    if deprecator.is_a?(ActiveSupport::Deprecation)\n      deprecator.deprecate_methods(self, *method_names, **options)\n    elsif deprecator\n      # we just need any instance to call deprecate_methods, but the deprecation will be emitted by deprecator\n      ActiveSupport.deprecator.deprecate_methods(self, *method_names, **options, deprecator: deprecator)\n    end",
    "comment": "deprecate :foo, deprecator: MyLib.deprecator deprecate :foo, bar: \"warning!\", deprecator: MyLib.deprecator  A deprecator is typically an instance of ActiveSupport::Deprecation, but you can also pass any object that responds to <tt>deprecation_warning(deprecated_method_name, message, caller_backtrace)</tt> where you can implement your custom warning behavior.  class MyLib::Deprecator def deprecation_warning(deprecated_method_name, message, caller_backtrace = nil) message = \"#{deprecated_method_name} is deprecated and will be removed from MyLibrary | #{message}\" Kernel.warn message end end",
    "label": "",
    "id": "3250"
  },
  {
    "raw_code": "def module_parent_name\n    if defined?(@parent_name)\n      @parent_name\n    else\n      name = self.name\n      return if name.nil?\n\n      parent_name = name =~ /::[^:]+\\z/ ? -$` : nil\n      @parent_name = parent_name unless frozen?\n      parent_name\n    end",
    "comment": "Returns the name of the module containing this one.  M::N.module_parent_name # => \"M\"",
    "label": "",
    "id": "3251"
  },
  {
    "raw_code": "def module_parent\n    module_parent_name ? ActiveSupport::Inflector.constantize(module_parent_name) : Object\n  end",
    "comment": "Returns the module which contains this one according to its name.  module M module N end end X = M::N  M::N.module_parent # => M X.module_parent    # => M  The parent of top-level and anonymous modules is Object.  M.module_parent          # => Object Module.new.module_parent # => Object",
    "label": "",
    "id": "3252"
  },
  {
    "raw_code": "def module_parents\n    parents = []\n    if module_parent_name\n      parts = module_parent_name.split(\"::\")\n      until parts.empty?\n        parents << ActiveSupport::Inflector.constantize(parts * \"::\")\n        parts.pop\n      end",
    "comment": "Returns all the parents of this module according to its name, ordered from nested outwards. The receiver is not contained within the result.  module M module N end end X = M::N  M.module_parents    # => [Object] M::N.module_parents # => [M, Object] X.module_parents    # => [M, Object]",
    "label": "",
    "id": "3253"
  },
  {
    "raw_code": "def silence_redefinition_of_method(method)\n    if method_defined?(method) || private_method_defined?(method)\n      # This suppresses the \"method redefined\" warning; the self-alias\n      # looks odd, but means we don't need to generate a unique name\n      alias_method method, method\n    end",
    "comment": "Marks the named method as intended to be redefined, if it exists. Suppresses the Ruby method redefinition warning. Prefer #redefine_method where possible.",
    "label": "",
    "id": "3254"
  },
  {
    "raw_code": "def redefine_method(method, &block)\n    visibility = method_visibility(method)\n    silence_redefinition_of_method(method)\n    define_method(method, &block)\n    send(visibility, method)\n  end",
    "comment": "Replaces the existing method definition, if there is one, with the passed block as its body.",
    "label": "",
    "id": "3255"
  },
  {
    "raw_code": "def redefine_singleton_method(method, &block)\n    singleton_class.redefine_method(method, &block)\n  end",
    "comment": "Replaces the existing singleton method definition, if there is one, with the passed block as its body.",
    "label": "",
    "id": "3256"
  },
  {
    "raw_code": "def remove_possible_method(method)\n    if method_defined?(method) || private_method_defined?(method)\n      undef_method(method)\n    end",
    "comment": "Removes the named method, if it exists.",
    "label": "",
    "id": "3257"
  },
  {
    "raw_code": "def remove_possible_singleton_method(method)\n    singleton_class.remove_possible_method(method)\n  end",
    "comment": "Removes the named singleton method, if it exists.",
    "label": "",
    "id": "3258"
  },
  {
    "raw_code": "def bytes\n    self\n  end",
    "comment": "Enables the use of byte calculations and declarations, like 45.bytes + 2.6.megabytes  2.bytes # => 2",
    "label": "",
    "id": "3259"
  },
  {
    "raw_code": "def kilobytes\n    self * KILOBYTE\n  end",
    "comment": "Returns the number of bytes equivalent to the kilobytes provided.  2.kilobytes # => 2048",
    "label": "",
    "id": "3260"
  },
  {
    "raw_code": "def megabytes\n    self * MEGABYTE\n  end",
    "comment": "Returns the number of bytes equivalent to the megabytes provided.  2.megabytes # => 2_097_152",
    "label": "",
    "id": "3261"
  },
  {
    "raw_code": "def gigabytes\n    self * GIGABYTE\n  end",
    "comment": "Returns the number of bytes equivalent to the gigabytes provided.  2.gigabytes # => 2_147_483_648",
    "label": "",
    "id": "3262"
  },
  {
    "raw_code": "def terabytes\n    self * TERABYTE\n  end",
    "comment": "Returns the number of bytes equivalent to the terabytes provided.  2.terabytes # => 2_199_023_255_552",
    "label": "",
    "id": "3263"
  },
  {
    "raw_code": "def petabytes\n    self * PETABYTE\n  end",
    "comment": "Returns the number of bytes equivalent to the petabytes provided.  2.petabytes # => 2_251_799_813_685_248",
    "label": "",
    "id": "3264"
  },
  {
    "raw_code": "def exabytes\n    self * EXABYTE\n  end",
    "comment": "Returns the number of bytes equivalent to the exabytes provided.  2.exabytes # => 2_305_843_009_213_693_952",
    "label": "",
    "id": "3265"
  },
  {
    "raw_code": "def zettabytes\n    self * ZETTABYTE\n  end",
    "comment": "Returns the number of bytes equivalent to the zettabytes provided.  2.zettabytes # => 2_361_183_241_434_822_606_848",
    "label": "",
    "id": "3266"
  },
  {
    "raw_code": "def to_fs(format = nil, options = nil)\n      return to_s if format.nil?\n\n      case format\n      when Integer, String\n        to_s(format)\n      when :phone\n        ActiveSupport::NumberHelper.number_to_phone(self, options || {})\n      when :currency\n        ActiveSupport::NumberHelper.number_to_currency(self, options || {})\n      when :percentage\n        ActiveSupport::NumberHelper.number_to_percentage(self, options || {})\n      when :delimited\n        ActiveSupport::NumberHelper.number_to_delimited(self, options || {})\n      when :rounded\n        ActiveSupport::NumberHelper.number_to_rounded(self, options || {})\n      when :human\n        ActiveSupport::NumberHelper.number_to_human(self, options || {})\n      when :human_size\n        ActiveSupport::NumberHelper.number_to_human_size(self, options || {})\n      when Symbol\n        to_s\n      else\n        to_s(format)\n      end",
    "comment": "\\Numeric With Format  Provides options for converting numbers into formatted strings. Options are provided for phone numbers, currency, percentage, precision, positional notation, file size, and pretty printing.  This method is aliased to <tt>to_formatted_s</tt>.  ==== Options  For details on which formats use which options, see ActiveSupport::NumberHelper  ==== Examples  Phone Numbers: 5551234.to_fs(:phone)                                     # => \"555-1234\" 1235551234.to_fs(:phone)                                  # => \"123-555-1234\" 1235551234.to_fs(:phone, area_code: true)                 # => \"(123) 555-1234\" 1235551234.to_fs(:phone, delimiter: ' ')                  # => \"123 555 1234\" 1235551234.to_fs(:phone, area_code: true, extension: 555) # => \"(123) 555-1234 x 555\" 1235551234.to_fs(:phone, country_code: 1)                 # => \"+1-123-555-1234\" 1235551234.to_fs(:phone, country_code: 1, extension: 1343, delimiter: '.') # => \"+1.123.555.1234 x 1343\"  Currency: 1234567890.50.to_fs(:currency)                     # => \"$1,234,567,890.50\" 1234567890.506.to_fs(:currency)                    # => \"$1,234,567,890.51\" 1234567890.506.to_fs(:currency, precision: 3)      # => \"$1,234,567,890.506\" 1234567890.506.to_fs(:currency, round_mode: :down) # => \"$1,234,567,890.50\" 1234567890.506.to_fs(:currency, locale: :fr)       # => \"1 234 567 890,51 €\" -1234567890.50.to_fs(:currency, negative_format: '(%u%n)') # => \"($1,234,567,890.50)\" 1234567890.50.to_fs(:currency, unit: '&pound;', separator: ',', delimiter: '') # => \"&pound;1234567890,50\" 1234567890.50.to_fs(:currency, unit: '&pound;', separator: ',', delimiter: '', format: '%n %u') # => \"1234567890,50 &pound;\"  Percentage: 100.to_fs(:percentage)                                  # => \"100.000%\" 100.to_fs(:percentage, precision: 0)                    # => \"100%\" 1000.to_fs(:percentage, delimiter: '.', separator: ',') # => \"1.000,000%\" 302.24398923423.to_fs(:percentage, precision: 5)        # => \"302.24399%\" 302.24398923423.to_fs(:percentage, round_mode: :down)   # => \"302.243%\" 1000.to_fs(:percentage, locale: :fr)                    # => \"1 000,000%\" 100.to_fs(:percentage, format: '%n  %')                 # => \"100.000  %\"  Delimited: 12345678.to_fs(:delimited)                     # => \"12,345,678\" 12345678.05.to_fs(:delimited)                  # => \"12,345,678.05\" 12345678.to_fs(:delimited, delimiter: '.')     # => \"12.345.678\" 12345678.to_fs(:delimited, delimiter: ',')     # => \"12,345,678\" 12345678.05.to_fs(:delimited, separator: ' ')  # => \"12,345,678 05\" 12345678.05.to_fs(:delimited, locale: :fr)     # => \"12 345 678,05\" 98765432.98.to_fs(:delimited, delimiter: ' ', separator: ',') # => \"98 765 432,98\"  Rounded: 111.2345.to_fs(:rounded)                                      # => \"111.235\" 111.2345.to_fs(:rounded, precision: 2)                        # => \"111.23\" 111.2345.to_fs(:rounded, precision: 2, round_mode: :up)       # => \"111.24\" 13.to_fs(:rounded, precision: 5)                              # => \"13.00000\" 389.32314.to_fs(:rounded, precision: 0)                       # => \"389\" 111.2345.to_fs(:rounded, significant: true)                   # => \"111\" 111.2345.to_fs(:rounded, precision: 1, significant: true)     # => \"100\" 13.to_fs(:rounded, precision: 5, significant: true)           # => \"13.000\" 111.234.to_fs(:rounded, locale: :fr)                          # => \"111,234\" 13.to_fs(:rounded, precision: 5, significant: true, strip_insignificant_zeros: true) # => \"13\" 389.32314.to_fs(:rounded, precision: 4, significant: true)    # => \"389.3\" 1111.2345.to_fs(:rounded, precision: 2, separator: ',', delimiter: '.') # => \"1.111,23\"  Human-friendly size in Bytes: 123.to_fs(:human_size)                                    # => \"123 Bytes\" 1234.to_fs(:human_size)                                   # => \"1.21 KB\" 12345.to_fs(:human_size)                                  # => \"12.1 KB\" 1234567.to_fs(:human_size)                                # => \"1.18 MB\" 1234567890.to_fs(:human_size)                             # => \"1.15 GB\" 1234567890123.to_fs(:human_size)                          # => \"1.12 TB\" 1234567890123456.to_fs(:human_size)                       # => \"1.1 PB\" 1234567890123456789.to_fs(:human_size)                    # => \"1.07 EB\" 1234567.to_fs(:human_size, precision: 2)                  # => \"1.2 MB\" 1234567.to_fs(:human_size, precision: 2, round_mode: :up) # => \"1.3 MB\" 483989.to_fs(:human_size, precision: 2)                   # => \"470 KB\" 1234567.to_fs(:human_size, precision: 2, separator: ',')  # => \"1,2 MB\" 1234567890123.to_fs(:human_size, precision: 5)            # => \"1.1228 TB\" 524288000.to_fs(:human_size, precision: 5)                # => \"500 MB\"  Human-friendly format: 123.to_fs(:human)                                       # => \"123\" 1234.to_fs(:human)                                      # => \"1.23 Thousand\" 12345.to_fs(:human)                                     # => \"12.3 Thousand\" 1234567.to_fs(:human)                                   # => \"1.23 Million\" 1234567890.to_fs(:human)                                # => \"1.23 Billion\" 1234567890123.to_fs(:human)                             # => \"1.23 Trillion\" 1234567890123456.to_fs(:human)                          # => \"1.23 Quadrillion\" 1234567890123456789.to_fs(:human)                       # => \"1230 Quadrillion\" 489939.to_fs(:human, precision: 2)                      # => \"490 Thousand\" 489939.to_fs(:human, precision: 2, round_mode: :down)   # => \"480 Thousand\" 489939.to_fs(:human, precision: 4)                      # => \"489.9 Thousand\" 1234567.to_fs(:human, precision: 4, significant: false)                             # => \"1.2346 Million\" 1234567.to_fs(:human, precision: 1, separator: ',', significant: false)                             # => \"1,2 Million\"",
    "label": "",
    "id": "3267"
  },
  {
    "raw_code": "def seconds\n    ActiveSupport::Duration.seconds(self)\n  end",
    "comment": "Returns a Duration instance matching the number of seconds provided.  2.seconds # => 2 seconds",
    "label": "",
    "id": "3268"
  },
  {
    "raw_code": "def minutes\n    ActiveSupport::Duration.minutes(self)\n  end",
    "comment": "Returns a Duration instance matching the number of minutes provided.  2.minutes # => 2 minutes",
    "label": "",
    "id": "3269"
  },
  {
    "raw_code": "def hours\n    ActiveSupport::Duration.hours(self)\n  end",
    "comment": "Returns a Duration instance matching the number of hours provided.  2.hours # => 2 hours",
    "label": "",
    "id": "3270"
  },
  {
    "raw_code": "def days\n    ActiveSupport::Duration.days(self)\n  end",
    "comment": "Returns a Duration instance matching the number of days provided.  2.days # => 2 days",
    "label": "",
    "id": "3271"
  },
  {
    "raw_code": "def weeks\n    ActiveSupport::Duration.weeks(self)\n  end",
    "comment": "Returns a Duration instance matching the number of weeks provided.  2.weeks # => 2 weeks",
    "label": "",
    "id": "3272"
  },
  {
    "raw_code": "def fortnights\n    ActiveSupport::Duration.weeks(self * 2)\n  end",
    "comment": "Returns a Duration instance matching the number of fortnights provided.  2.fortnights # => 4 weeks",
    "label": "",
    "id": "3273"
  },
  {
    "raw_code": "def in_milliseconds\n    self * 1000\n  end",
    "comment": "Returns the number of milliseconds equivalent to the seconds provided. Used with the standard time durations.  2.in_milliseconds # => 2000 1.hour.in_milliseconds # => 3600000",
    "label": "",
    "id": "3274"
  },
  {
    "raw_code": "def acts_like?(duck)\n    case duck\n    when :time\n      respond_to? :acts_like_time?\n    when :date\n      respond_to? :acts_like_date?\n    when :string\n      respond_to? :acts_like_string?\n    else\n      respond_to? :\"acts_like_#{duck}?\"\n    end",
    "comment": "Provides a way to check whether some class acts like some other class based on the existence of an appropriately-named marker method.  A class that provides the same interface as <tt>SomeClass</tt> may define a marker method named <tt>acts_like_some_class?</tt> to signal its compatibility to callers of <tt>acts_like?(:some_class)</tt>.  For example, Active Support extends <tt>Date</tt> to define an <tt>acts_like_date?</tt> method, and extends <tt>Time</tt> to define <tt>acts_like_time?</tt>. As a result, developers can call <tt>x.acts_like?(:time)</tt> and <tt>x.acts_like?(:date)</tt> to test duck-type compatibility, and classes that are able to act like <tt>Time</tt> can also define an <tt>acts_like_time?</tt> method to interoperate.  Note that the marker method is only expected to exist. It isn't called, so its body or return value are irrelevant.  ==== Example: A class that provides the same interface as <tt>String</tt>  This class may define:  class Stringish def acts_like_string? end end  Then client code can query for duck-type-safeness this way:  Stringish.new.acts_like?(:string) # => true ",
    "label": "",
    "id": "3275"
  },
  {
    "raw_code": "def blank?\n    respond_to?(:empty?) ? !!empty? : false\n  end",
    "comment": "An object is blank if it's false, empty, or a whitespace string. For example, +nil+, '', '   ', [], {}, and +false+ are all blank.  This simplifies  !address || address.empty?  to  address.blank?  @return [true, false]",
    "label": "",
    "id": "3276"
  },
  {
    "raw_code": "def present?\n    !blank?\n  end",
    "comment": "An object is present if it's not blank.  @return [true, false]",
    "label": "",
    "id": "3277"
  },
  {
    "raw_code": "def presence\n    self if present?\n  end",
    "comment": "Returns the receiver if it's present otherwise returns +nil+. <tt>object.presence</tt> is equivalent to  object.present? ? object : nil  For example, something like  state   = params[:state]   if params[:state].present? country = params[:country] if params[:country].present? region  = state || country || 'US'  becomes  region = params[:state].presence || params[:country].presence || 'US'  @return [Object]",
    "label": "",
    "id": "3278"
  },
  {
    "raw_code": "def blank?\n    true\n  end",
    "comment": "+nil+ is blank:  nil.blank? # => true  @return [true]",
    "label": "",
    "id": "3279"
  },
  {
    "raw_code": "def blank?\n    true\n  end",
    "comment": "+false+ is blank:  false.blank? # => true  @return [true]",
    "label": "",
    "id": "3280"
  },
  {
    "raw_code": "def blank?\n    false\n  end",
    "comment": "+true+ is not blank:  true.blank? # => false  @return [false]",
    "label": "",
    "id": "3281"
  },
  {
    "raw_code": "def blank?\n    # The regexp that matches blank strings is expensive. For the case of empty\n    # strings we can speed up this method (~3.5x) with an empty? call. The\n    # penalty for the rest of strings is marginal.\n    empty? ||\n      begin\n        BLANK_RE.match?(self)\n      rescue Encoding::CompatibilityError\n        ENCODED_BLANKS[self.encoding].match?(self)\n      end",
    "comment": "A string is blank if it's empty or contains whitespaces only:  ''.blank?       # => true '   '.blank?    # => true \"\\t\\n\\r\".blank? # => true ' blah '.blank? # => false  Unicode whitespace is supported:  \"\\u00a0\".blank? # => true  @return [true, false]",
    "label": "",
    "id": "3282"
  },
  {
    "raw_code": "def blank?\n    false\n  end",
    "comment": "No number is blank:  1.blank? # => false 0.blank? # => false  @return [false]",
    "label": "",
    "id": "3283"
  },
  {
    "raw_code": "def blank?\n    false\n  end",
    "comment": "No Time is blank:  Time.now.blank? # => false  @return [false]",
    "label": "",
    "id": "3284"
  },
  {
    "raw_code": "def deep_dup\n    duplicable? ? dup : self\n  end",
    "comment": "Returns a deep copy of object if it's duplicable. If it's not duplicable, returns +self+.  object = Object.new dup    = object.deep_dup dup.instance_variable_set(:@a, 1)  object.instance_variable_defined?(:@a) # => false dup.instance_variable_defined?(:@a)    # => true",
    "label": "",
    "id": "3285"
  },
  {
    "raw_code": "def deep_dup\n    map(&:deep_dup)\n  end",
    "comment": "Returns a deep copy of array.  array = [1, [2, 3]] dup   = array.deep_dup dup[1][2] = 4  array[1][2] # => nil dup[1][2]   # => 4",
    "label": "",
    "id": "3286"
  },
  {
    "raw_code": "def deep_dup\n    hash = dup\n    each_pair do |key, value|\n      if ::String === key || ::Symbol === key\n        hash[key] = value.deep_dup\n      else\n        hash.delete(key)\n        hash[key.deep_dup] = value.deep_dup\n      end",
    "comment": "Returns a deep copy of hash.  hash = { a: { b: 'b' } } dup  = hash.deep_dup dup[:a][:c] = 'c'  hash[:a][:c] # => nil dup[:a][:c]  # => \"c\"",
    "label": "",
    "id": "3287"
  },
  {
    "raw_code": "def deep_dup\n    if name.nil?\n      super\n    else\n      self\n    end",
    "comment": "Returns a copy of module or class if it's anonymous. If it's named, returns +self+.  Object.deep_dup == Object # => true klass = Class.new klass.deep_dup == klass # => false",
    "label": "",
    "id": "3288"
  },
  {
    "raw_code": "def duplicable?\n    true\n  end",
    "comment": "Can you safely dup this object?  False for method objects; true otherwise.",
    "label": "",
    "id": "3289"
  },
  {
    "raw_code": "def duplicable?\n      false\n    end",
    "comment": "Methods are not duplicable:  method(:puts).duplicable? # => false method(:puts).dup         # => TypeError: allocator undefined for Method",
    "label": "",
    "id": "3290"
  },
  {
    "raw_code": "def duplicable?\n      false\n    end",
    "comment": "Unbound methods are not duplicable:  method(:puts).unbind.duplicable? # => false method(:puts).unbind.dup         # => TypeError: allocator undefined for UnboundMethod",
    "label": "",
    "id": "3291"
  },
  {
    "raw_code": "def duplicable?\n    false\n  end",
    "comment": "Singleton instances are not duplicable:  Class.new.include(Singleton).instance.dup # TypeError (can't dup instance of singleton",
    "label": "",
    "id": "3292"
  },
  {
    "raw_code": "def in?(another_object)\n    case another_object\n    when Range\n      another_object.cover?(self)\n    else\n      another_object.include?(self)\n    end",
    "comment": "Returns true if this object is included in the argument.  When argument is a +Range+, +#cover?+ is used to properly handle inclusion check within open ranges. Otherwise, argument must be any object which responds to +#include?+. Usage:  characters = [\"Konata\", \"Kagami\", \"Tsukasa\"] \"Konata\".in?(characters) # => true  For non +Range+ arguments, this will throw an +ArgumentError+ if the argument doesn't respond to +#include?+.",
    "label": "",
    "id": "3293"
  },
  {
    "raw_code": "def presence_in(another_object)\n    in?(another_object) ? self : nil\n  end",
    "comment": "Returns the receiver if it's included in the argument otherwise returns +nil+. Argument must be any object which responds to +#include?+. Usage:  params[:bucket_type].presence_in %w( project calendar )  This will throw an +ArgumentError+ if the argument doesn't respond to +#include?+.  @return [Object]",
    "label": "",
    "id": "3294"
  },
  {
    "raw_code": "def instance_values\n    instance_variables.to_h do |ivar|\n      [ivar[1..-1].freeze, instance_variable_get(ivar)]\n    end",
    "comment": "Returns a hash with string keys that maps instance variable names without \"@\" to their corresponding values.  class C def initialize(x, y) @x, @y = x, y end end  C.new(0, 1).instance_values # => {\"x\" => 0, \"y\" => 1}",
    "label": "",
    "id": "3295"
  },
  {
    "raw_code": "def instance_variable_names\n    instance_variables.map(&:name)\n  end",
    "comment": "Returns an array of instance variable names as strings including \"@\".  class C def initialize(x, y) @x, @y = x, y end end  C.new(0, 1).instance_variable_names # => [\"@y\", \"@x\"]",
    "label": "",
    "id": "3296"
  },
  {
    "raw_code": "def as_json(options = nil) # :nodoc:\n    finite? ? self : nil\n  end",
    "comment": "Encoding Infinity or NaN to JSON should return \"null\". The default returns \"Infinity\" or \"NaN\" which are not valid JSON.",
    "label": "",
    "id": "3297"
  },
  {
    "raw_code": "def as_json(options = nil) # :nodoc:\n    finite? ? to_s : nil\n  end",
    "comment": "A BigDecimal would be naturally represented as a JSON number. Most libraries, however, parse non-integer JSON numbers directly as floats. Clients using those libraries would get in general a wrong number and no way to recover other than manually inspecting the string with the JSON code itself.  That's why a JSON string is returned. The JSON literal is not numeric, but if the other end knows by contract that the data is supposed to be a BigDecimal, it still has the chance to post-process the string and get the real value.",
    "label": "",
    "id": "3298"
  },
  {
    "raw_code": "def to_param\n    to_s\n  end",
    "comment": "Alias of <tt>to_s</tt>.",
    "label": "",
    "id": "3299"
  },
  {
    "raw_code": "def to_query(key)\n    \"#{CGI.escape(key.to_param)}=#{CGI.escape(to_param.to_s)}\"\n  end",
    "comment": "Converts an object into a string suitable for use as a URL query string, using the given <tt>key</tt> as the param name.",
    "label": "",
    "id": "3300"
  },
  {
    "raw_code": "def to_query(key)\n    CGI.escape(key.to_param)\n  end",
    "comment": "Returns a CGI-escaped +key+.",
    "label": "",
    "id": "3301"
  },
  {
    "raw_code": "def to_param\n    self\n  end",
    "comment": "Returns +self+.",
    "label": "",
    "id": "3302"
  },
  {
    "raw_code": "def to_param\n    self\n  end",
    "comment": "Returns +self+.",
    "label": "",
    "id": "3303"
  },
  {
    "raw_code": "def to_param\n    self\n  end",
    "comment": "Returns +self+.",
    "label": "",
    "id": "3304"
  },
  {
    "raw_code": "def to_param\n    collect(&:to_param).join \"/\"\n  end",
    "comment": "Calls <tt>to_param</tt> on all its elements and joins the result with slashes. This is used by <tt>url_for</tt> in Action Pack.",
    "label": "",
    "id": "3305"
  },
  {
    "raw_code": "def to_query(key)\n    prefix = \"#{key}[]\"\n\n    if empty?\n      nil.to_query(prefix)\n    else\n      collect { |value| value.to_query(prefix) }.join \"&\"\n    end",
    "comment": "Converts an array into a string suitable for use as a URL query string, using the given +key+ as the param name.  ['Rails', 'coding'].to_query('hobbies') # => \"hobbies%5B%5D=Rails&hobbies%5B%5D=coding\"",
    "label": "",
    "id": "3306"
  },
  {
    "raw_code": "def to_query(namespace = nil)\n    query = filter_map do |key, value|\n      unless (value.is_a?(Hash) || value.is_a?(Array)) && value.empty?\n        value.to_query(namespace ? \"#{namespace}[#{key}]\" : key)\n      end",
    "comment": "Returns a string representation of the receiver suitable for use as a URL query string:  {name: 'David', nationality: 'Danish'}.to_query # => \"name=David&nationality=Danish\"  An optional namespace can be passed to enclose key names:  {name: 'David', nationality: 'Danish'}.to_query('user') # => \"user%5Bname%5D=David&user%5Bnationality%5D=Danish\"  The string pairs \"key=value\" that conform the query string are sorted lexicographically in ascending order.",
    "label": "",
    "id": "3307"
  },
  {
    "raw_code": "def try(*, &)\n    nil\n  end",
    "comment": "Calling +try+ on +nil+ always returns +nil+. It becomes especially helpful when navigating through associations that may return +nil+.  nil.try(:name) # => nil  Without +try+ @person && @person.children.any? && @person.children.first.name  With +try+ @person.try(:children).try(:first).try(:name)",
    "label": "",
    "id": "3308"
  },
  {
    "raw_code": "def try!(*, &)\n    nil\n  end",
    "comment": "Calling +try!+ on +nil+ always returns +nil+.  nil.try!(:name) # => nil",
    "label": "",
    "id": "3309"
  },
  {
    "raw_code": "def with(**attributes)\n    old_values = {}\n    begin\n      attributes.each do |key, value|\n        old_values[key] = public_send(key)\n        public_send(\"#{key}=\", value)\n      end",
    "comment": "Set and restore public attributes around a block.  client.timeout # => 5 client.with(timeout: 1) do |c| c.timeout # => 1 end client.timeout # => 5  The receiver is yielded to the provided block.  This method is a shorthand for the common begin/ensure pattern:  old_value = object.attribute begin object.attribute = new_value # do things ensure object.attribute = old_value end  It can be used on any object as long as both the reader and writer methods are public.",
    "label": "",
    "id": "3310"
  },
  {
    "raw_code": "def with_options(options, &block)\n    option_merger = ActiveSupport::OptionMerger.new(self, options)\n\n    if block\n      block.arity.zero? ? option_merger.instance_eval(&block) : block.call(option_merger)\n    else\n      option_merger\n    end",
    "comment": "An elegant way to factor duplication out of options passed to a series of method calls. Each method called in the block, with the block variable as the receiver, will have its options merged with the default +options+ <tt>Hash</tt> or <tt>Hash</tt>-like object provided. Each method called on the block variable must take an options hash as its final argument.  Without <tt>with_options</tt>, this code contains duplication:  class Account < ActiveRecord::Base has_many :customers, dependent: :destroy has_many :products,  dependent: :destroy has_many :invoices,  dependent: :destroy has_many :expenses,  dependent: :destroy end  Using <tt>with_options</tt>, we can remove the duplication:  class Account < ActiveRecord::Base with_options dependent: :destroy do |assoc| assoc.has_many :customers assoc.has_many :products assoc.has_many :invoices assoc.has_many :expenses end end  It can also be used with an explicit receiver:  I18n.with_options locale: user.locale, scope: 'newsletter' do |i18n| subject i18n.t :subject body    i18n.t :body, user_name: user.name end  When you don't pass an explicit receiver, it executes the whole block in merging options context:  class Account < ActiveRecord::Base with_options dependent: :destroy do has_many :customers has_many :products has_many :invoices has_many :expenses end end  <tt>with_options</tt> can also be nested since the call is forwarded to its receiver.  NOTE: Each nesting level will merge inherited defaults in addition to their own.  class Post < ActiveRecord::Base with_options if: :persisted?, length: { minimum: 50 } do validates :content, if: -> { content.present? } end end  The code is equivalent to:  validates :content, length: { minimum: 50 }, if: -> { content.present? }  Hence the inherited default for +if+ key is ignored.  NOTE: You cannot call class methods implicitly inside of +with_options+. You can access these methods using the class name instead:  class Phone < ActiveRecord::Base enum :phone_number_type, { home: 0, office: 1, mobile: 2 }  with_options presence: true do validates :phone_number_type, inclusion: { in: Phone.phone_number_types.keys } end end  When the block argument is omitted, the decorated Object instance is returned:  module MyStyledHelpers def styled with_options style: \"color: red;\" end end  styled.link_to \"I'm red\", \"/\" # => <a href=\"/\" style=\"color: red;\">I'm red</a>  styled.button_tag \"I'm red too!\" # => <button style=\"color: red;\">I'm red too!</button> ",
    "label": "",
    "id": "3311"
  },
  {
    "raw_code": "def blank?\n    to_s.empty?\n  end",
    "comment": "An Pathname is blank if it's empty:  Pathname.new(\"\").blank?      # => true Pathname.new(\" \").blank?     # => false Pathname.new(\"test\").blank?  # => false  @return [true, false]",
    "label": "",
    "id": "3312"
  },
  {
    "raw_code": "def existence\n    self if exist?\n  end",
    "comment": "Returns the receiver if the named file exists otherwise returns +nil+. <tt>pathname.existence</tt> is equivalent to  pathname.exist? ? pathname : nil  For example, something like  content = pathname.read if pathname.exist?  becomes  content = pathname.existence&.read  @return [Pathname]",
    "label": "",
    "id": "3313"
  },
  {
    "raw_code": "def ===(value)\n      if value.is_a?(::Range)\n        is_backwards_op = value.exclude_end? ? :>= : :>\n        return false if value.begin && value.end && value.begin.public_send(is_backwards_op, value.end)\n        # 1...10 includes 1..9 but it does not include 1..10.\n        # 1..10 includes 1...11 but it does not include 1...12.\n        operator = exclude_end? && !value.exclude_end? ? :< : :<=\n        value_max = !exclude_end? && value.exclude_end? ? value.max : value.last\n        super(value.first) && (self.end.nil? || value_max.public_send(operator, last))\n      else\n        super\n      end",
    "comment": "Extends the default Range#=== to support range comparisons. (1..5) === (1..5)  # => true (1..5) === (2..3)  # => true (1..5) === (1...6) # => true (1..5) === (2..6)  # => false  The native Range#=== behavior is untouched. ('a'..'f') === ('c') # => true (5..9) === (11) # => false  The given range must be fully bounded, with both start and end.",
    "label": "",
    "id": "3314"
  },
  {
    "raw_code": "def include?(value)\n      if value.is_a?(::Range)\n        is_backwards_op = value.exclude_end? ? :>= : :>\n        return false if value.begin && value.end && value.begin.public_send(is_backwards_op, value.end)\n        # 1...10 includes 1..9 but it does not include 1..10.\n        # 1..10 includes 1...11 but it does not include 1...12.\n        operator = exclude_end? && !value.exclude_end? ? :< : :<=\n        value_max = !exclude_end? && value.exclude_end? ? value.max : value.last\n        super(value.first) && (self.end.nil? || value_max.public_send(operator, last))\n      else\n        super\n      end",
    "comment": "Extends the default Range#include? to support range comparisons. (1..5).include?(1..5)  # => true (1..5).include?(2..3)  # => true (1..5).include?(1...6) # => true (1..5).include?(2..6)  # => false  The native Range#include? behavior is untouched. ('a'..'f').include?('c') # => true (5..9).include?(11) # => false  The given range must be fully bounded, with both start and end.",
    "label": "",
    "id": "3315"
  },
  {
    "raw_code": "def to_fs(format = :default)\n      if formatter = RANGE_FORMATS[format]\n        formatter.call(self.begin, self.end)\n      else\n        to_s\n      end",
    "comment": "Convert range to a formatted string. See RANGE_FORMATS for predefined formats.  This method is aliased to <tt>to_formatted_s</tt>.  range = (1..100)           # => 1..100  range.to_s                 # => \"1..100\" range.to_fs(:db)           # => \"BETWEEN '1' AND '100'\"  range = (1..)              # => 1.. range.to_fs(:db)           # => \">= '1'\"  range = (..100)            # => ..100 range.to_fs(:db)           # => \"<= '100'\"  == Adding your own range formats to to_fs You can add your own formats to the Range::RANGE_FORMATS hash. Use the format name as the hash key and a Proc instance.  # config/initializers/range_formats.rb Range::RANGE_FORMATS[:short] = ->(start, stop) { \"Between #{start.to_fs(:db)} and #{stop.to_fs(:db)}\" }",
    "label": "",
    "id": "3316"
  },
  {
    "raw_code": "def overlap?(other)\n      raise TypeError unless other.is_a? Range\n\n      self_begin = self.begin\n      other_end = other.end\n      other_excl = other.exclude_end?\n\n      return false if _empty_range?(self_begin, other_end, other_excl)\n\n      other_begin = other.begin\n      self_end = self.end\n      self_excl = self.exclude_end?\n\n      return false if _empty_range?(other_begin, self_end, self_excl)\n      return true if self_begin == other_begin\n\n      return false if _empty_range?(self_begin, self_end, self_excl)\n      return false if _empty_range?(other_begin, other_end, other_excl)\n\n      true\n    end",
    "comment": "Compare two ranges and see if they overlap each other (1..5).overlap?(4..6) # => true (1..5).overlap?(7..9) # => false",
    "label": "",
    "id": "3317"
  },
  {
    "raw_code": "def sole\n    if self.begin.nil? || self.end.nil?\n      raise ActiveSupport::EnumerableCoreExt::SoleItemExpectedError, \"infinite range '#{inspect}' cannot represent a sole item\"\n    end",
    "comment": "Returns the sole item in the range. If there are no items, or more than one item, raises Enumerable::SoleItemExpectedError.  (1..1).sole   # => 1 (2..1).sole   # => Enumerable::SoleItemExpectedError: no item found (..1).sole    # => Enumerable::SoleItemExpectedError: infinite range cannot represent a sole item",
    "label": "",
    "id": "3318"
  },
  {
    "raw_code": "def at(position)\n    self[position]\n  end",
    "comment": "If you pass a single integer, returns a substring of one character at that position. The first character of the string is at position 0, the next at position 1, and so on. If a range is supplied, a substring containing characters at offsets given by the range is returned. In both cases, if an offset is negative, it is counted from the end of the string. Returns +nil+ if the initial offset falls outside the string. Returns an empty string if the beginning of the range is greater than the end of the string.  str = \"hello\" str.at(0)      # => \"h\" str.at(1..3)   # => \"ell\" str.at(-2)     # => \"l\" str.at(-2..-1) # => \"lo\" str.at(5)      # => nil str.at(5..-1)  # => \"\"  If a Regexp is given, the matching portion of the string is returned. If a String is given, that given string is returned if it occurs in the string. In both cases, +nil+ is returned if there is no match.  str = \"hello\" str.at(/lo/) # => \"lo\" str.at(/ol/) # => nil str.at(\"lo\") # => \"lo\" str.at(\"ol\") # => nil",
    "label": "",
    "id": "3319"
  },
  {
    "raw_code": "def from(position)\n    self[position, length]\n  end",
    "comment": "Returns a substring from the given position to the end of the string. If the position is negative, it is counted from the end of the string.  str = \"hello\" str.from(0)  # => \"hello\" str.from(3)  # => \"lo\" str.from(-2) # => \"lo\"  You can mix it with +to+ method and do fun things like:  str = \"hello\" str.from(0).to(-1) # => \"hello\" str.from(1).to(-2) # => \"ell\"",
    "label": "",
    "id": "3320"
  },
  {
    "raw_code": "def to(position)\n    position += size if position < 0\n    self[0, position + 1] || +\"\"\n  end",
    "comment": "Returns a substring from the beginning of the string to the given position. If the position is negative, it is counted from the end of the string.  str = \"hello\" str.to(0)  # => \"h\" str.to(3)  # => \"hell\" str.to(-2) # => \"hell\"  You can mix it with +from+ method and do fun things like:  str = \"hello\" str.from(0).to(-1) # => \"hello\" str.from(1).to(-2) # => \"ell\"",
    "label": "",
    "id": "3321"
  },
  {
    "raw_code": "def first(limit = 1)\n    self[0, limit] || raise(ArgumentError, \"negative limit\")\n  end",
    "comment": "Returns the first character. If a limit is supplied, returns a substring from the beginning of the string until it reaches the limit value. If the given limit is greater than or equal to the string length, returns a copy of self.  str = \"hello\" str.first    # => \"h\" str.first(1) # => \"h\" str.first(2) # => \"he\" str.first(0) # => \"\" str.first(6) # => \"hello\"",
    "label": "",
    "id": "3322"
  },
  {
    "raw_code": "def last(limit = 1)\n    self[[length - limit, 0].max, limit] || raise(ArgumentError, \"negative limit\")\n  end",
    "comment": "Returns the last character of the string. If a limit is supplied, returns a substring from the end of the string until it reaches the limit value (counting backwards). If the given limit is greater than or equal to the string length, returns a copy of self.  str = \"hello\" str.last    # => \"o\" str.last(1) # => \"o\" str.last(2) # => \"lo\" str.last(0) # => \"\" str.last(6) # => \"hello\"",
    "label": "",
    "id": "3323"
  },
  {
    "raw_code": "def acts_like_string?\n    true\n  end",
    "comment": "Enables more predictable duck-typing on String-like classes. See <tt>Object#acts_like?</tt>.",
    "label": "",
    "id": "3324"
  },
  {
    "raw_code": "def to_time(form = :local)\n    parts = Date._parse(self, false)\n    used_keys = %i(year mon mday hour min sec sec_fraction offset)\n    return if !parts.keys.intersect?(used_keys)\n\n    now = Time.now\n    time = Time.new(\n      parts.fetch(:year, now.year),\n      parts.fetch(:mon, now.month),\n      parts.fetch(:mday, now.day),\n      parts.fetch(:hour, 0),\n      parts.fetch(:min, 0),\n      parts.fetch(:sec, 0) + parts.fetch(:sec_fraction, 0),\n      parts.fetch(:offset, form == :utc ? 0 : nil)\n    )\n\n    form == :utc ? time.utc : time.to_time\n  end",
    "comment": "Converts a string to a Time value. The +form+ can be either +:utc+ or +:local+ (default +:local+).  The time is parsed using Time.parse method. If +form+ is +:local+, then the time is in the system timezone. If the date part is missing then the current date is used and if the time part is missing then it is assumed to be 00:00:00.  \"13-12-2012\".to_time               # => 2012-12-13 00:00:00 +0100 \"06:12\".to_time                    # => 2012-12-13 06:12:00 +0100 \"2012-12-13 06:12\".to_time         # => 2012-12-13 06:12:00 +0100 \"2012-12-13T06:12\".to_time         # => 2012-12-13 06:12:00 +0100 \"2012-12-13T06:12\".to_time(:utc)   # => 2012-12-13 06:12:00 UTC \"12/13/2012\".to_time               # => ArgumentError: argument out of range \"1604326192\".to_time               # => ArgumentError: argument out of range",
    "label": "",
    "id": "3325"
  },
  {
    "raw_code": "def to_date\n    ::Date.parse(self, false) unless blank?\n  end",
    "comment": "Converts a string to a Date value.  \"1-1-2012\".to_date   # => Sun, 01 Jan 2012 \"01/01/2012\".to_date # => Sun, 01 Jan 2012 \"2012-12-13\".to_date # => Thu, 13 Dec 2012 \"12/13/2012\".to_date # => ArgumentError: invalid date",
    "label": "",
    "id": "3326"
  },
  {
    "raw_code": "def to_datetime\n    ::DateTime.parse(self, false) unless blank?\n  end",
    "comment": "Converts a string to a DateTime value.  \"1-1-2012\".to_datetime            # => Sun, 01 Jan 2012 00:00:00 +0000 \"01/01/2012 23:59:59\".to_datetime # => Sun, 01 Jan 2012 23:59:59 +0000 \"2012-12-13 12:50\".to_datetime    # => Thu, 13 Dec 2012 12:50:00 +0000 \"12/13/2012\".to_datetime          # => ArgumentError: invalid date",
    "label": "",
    "id": "3327"
  },
  {
    "raw_code": "def exclude?(string)\n    !include?(string)\n  end",
    "comment": "The inverse of <tt>String#include?</tt>. Returns true if the string does not include the other string.  \"hello\".exclude? \"lo\" # => false \"hello\".exclude? \"ol\" # => true \"hello\".exclude? ?h   # => false",
    "label": "",
    "id": "3328"
  },
  {
    "raw_code": "def squish\n    dup.squish!\n  end",
    "comment": "Returns the string, first removing all whitespace on both ends of the string, and then changing remaining consecutive whitespace groups into one space each.  Note that it handles both ASCII and Unicode whitespace.  %{ Multi-line string }.squish                   # => \"Multi-line string\" \" foo   bar    \\n   \\t   boo\".squish # => \"foo bar boo\"",
    "label": "",
    "id": "3329"
  },
  {
    "raw_code": "def squish!\n    gsub!(/[[:space:]]+/, \" \")\n    strip!\n    self\n  end",
    "comment": "Performs a destructive squish. See String#squish. str = \" foo   bar    \\n   \\t   boo\" str.squish!                         # => \"foo bar boo\" str                                 # => \"foo bar boo\"",
    "label": "",
    "id": "3330"
  },
  {
    "raw_code": "def remove(*patterns)\n    dup.remove!(*patterns)\n  end",
    "comment": "Returns a new string with all occurrences of the patterns removed. str = \"foo bar test\" str.remove(\" test\")                 # => \"foo bar\" str.remove(\" test\", /bar/)          # => \"foo \" str                                 # => \"foo bar test\"",
    "label": "",
    "id": "3331"
  },
  {
    "raw_code": "def remove!(*patterns)\n    patterns.each do |pattern|\n      gsub! pattern, \"\"\n    end",
    "comment": "Alters the string by removing all occurrences of the patterns. str = \"foo bar test\" str.remove!(\" test\", /bar/)         # => \"foo \" str                                 # => \"foo \"",
    "label": "",
    "id": "3332"
  },
  {
    "raw_code": "def truncate(truncate_to, options = {})\n    return dup unless length > truncate_to\n\n    omission = options[:omission] || \"...\"\n    length_with_room_for_omission = truncate_to - omission.length\n    stop = \\\n      if options[:separator]\n        rindex(options[:separator], length_with_room_for_omission) || length_with_room_for_omission\n      else\n        length_with_room_for_omission\n      end",
    "comment": "Truncates a given +text+ to length <tt>truncate_to</tt> if +text+ is longer than <tt>truncate_to</tt>:  'Once upon a time in a world far far away'.truncate(27) # => \"Once upon a time in a wo...\"  Pass a string or regexp <tt>:separator</tt> to truncate +text+ at a natural break:  'Once upon a time in a world far far away'.truncate(27, separator: ' ') # => \"Once upon a time in a...\"  'Once upon a time in a world far far away'.truncate(27, separator: /\\s/) # => \"Once upon a time in a...\"  The last characters will be replaced with the <tt>:omission</tt> string (defaults to \"...\"). The total length will not exceed <tt>truncate_to</tt> unless both +text+ and <tt>:omission</tt> are longer than <tt>truncate_to</tt>:  'And they found that many people were sleeping better.'.truncate(25, omission: '... (continued)') # => \"And they f... (continued)\"  'And they found that many people were sleeping better.'.truncate(4, omission: '... (continued)') # => \"... (continued)\"",
    "label": "",
    "id": "3333"
  },
  {
    "raw_code": "def truncate_bytes(truncate_to, omission: \"…\")\n    omission ||= \"\"\n\n    case\n    when bytesize <= truncate_to\n      dup\n    when omission.bytesize > truncate_to\n      raise ArgumentError, \"Omission #{omission.inspect} is #{omission.bytesize}, larger than the truncation length of #{truncate_to} bytes\"\n    when omission.bytesize == truncate_to\n      omission.dup\n    else\n      self.class.new.force_encoding(encoding).tap do |cut|\n        cut_at = truncate_to - omission.bytesize\n\n        each_grapheme_cluster do |grapheme|\n          if cut.bytesize + grapheme.bytesize <= cut_at\n            cut << grapheme\n          else\n            break\n          end",
    "comment": "Truncates +text+ to at most <tt>truncate_to</tt> bytes in length without breaking string encoding by splitting multibyte characters or breaking grapheme clusters (\"perceptual characters\") by truncating at combining characters.  >> \"🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪\".size # => 20 >> \"🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪\".bytesize # => 80 >> \"🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪🔪\".truncate_bytes(20) # => \"🔪🔪🔪🔪…\"  The truncated text ends with the <tt>:omission</tt> string, defaulting to \"…\", for a total length not exceeding <tt>truncate_to</tt>.  Raises +ArgumentError+ when the bytesize of <tt>:omission</tt> exceeds <tt>truncate_to</tt>.",
    "label": "",
    "id": "3334"
  },
  {
    "raw_code": "def truncate_words(words_count, options = {})\n    sep = options[:separator] || /\\s+/\n    sep = Regexp.escape(sep.to_s) unless Regexp === sep\n    if self =~ /\\A((?>.+?#{sep}){#{words_count - 1}}.+?)#{sep}.*/m\n      $1 + (options[:omission] || \"...\")\n    else\n      dup\n    end",
    "comment": "Truncates a given +text+ after a given number of words (<tt>words_count</tt>):  'Once upon a time in a world far far away'.truncate_words(4) # => \"Once upon a time...\"  Pass a string or regexp <tt>:separator</tt> to specify a different separator of words:  'Once<br>upon<br>a<br>time<br>in<br>a<br>world'.truncate_words(5, separator: '<br>') # => \"Once<br>upon<br>a<br>time<br>in...\"  The last characters will be replaced with the <tt>:omission</tt> string (defaults to \"...\"):  'And they found that many people were sleeping better.'.truncate_words(5, omission: '... (continued)') # => \"And they found that many... (continued)\"",
    "label": "",
    "id": "3335"
  },
  {
    "raw_code": "def indent!(amount, indent_string = nil, indent_empty_lines = false)\n    indent_string = indent_string || self[/^[ \\t]/] || \" \"\n    re = indent_empty_lines ? /^/ : /^(?!$)/\n    gsub!(re, indent_string * amount)\n  end",
    "comment": "Same as +indent+, except it indents the receiver in-place.  Returns the indented string, or +nil+ if there was nothing to indent.",
    "label": "",
    "id": "3336"
  },
  {
    "raw_code": "def indent(amount, indent_string = nil, indent_empty_lines = false)\n    dup.tap { |_| _.indent!(amount, indent_string, indent_empty_lines) }\n  end",
    "comment": "Indents the lines in the receiver:  <<EOS.indent(2) def some_method some_code end EOS # => def some_method some_code end  The second argument, +indent_string+, specifies which indent string to use. The default is +nil+, which tells the method to make a guess by peeking at the first indented line, and fall back to a space if there is none.  \"  foo\".indent(2)        # => \"    foo\" \"foo\\n\\t\\tbar\".indent(2) # => \"\\t\\tfoo\\n\\t\\t\\t\\tbar\" \"foo\".indent(2, \"\\t\")    # => \"\\t\\tfoo\"  While +indent_string+ is typically one space or tab, it may be any string.  The third argument, +indent_empty_lines+, is a flag that says whether empty lines should be indented. Default is false.  \"foo\\n\\nbar\".indent(2)            # => \"  foo\\n\\n  bar\" \"foo\\n\\nbar\".indent(2, nil, true) # => \"  foo\\n  \\n  bar\" ",
    "label": "",
    "id": "3337"
  },
  {
    "raw_code": "def pluralize(count = nil, locale = :en)\n    locale = count if count.is_a?(Symbol)\n    if count == 1\n      dup\n    else\n      ActiveSupport::Inflector.pluralize(self, locale)\n    end",
    "comment": "Returns the plural form of the word in the string.  If the optional parameter +count+ is specified, the singular form will be returned if <tt>count == 1</tt>. For any other value of +count+ the plural will be returned.  If the optional parameter +locale+ is specified, the word will be pluralized as a word of that language. By default, this parameter is set to <tt>:en</tt>. You must define your own inflection rules for languages other than English.  'post'.pluralize             # => \"posts\" 'octopus'.pluralize          # => \"octopi\" 'sheep'.pluralize            # => \"sheep\" 'words'.pluralize            # => \"words\" 'the blue mailman'.pluralize # => \"the blue mailmen\" 'CamelOctopus'.pluralize     # => \"CamelOctopi\" 'apple'.pluralize(1)         # => \"apple\" 'apple'.pluralize(2)         # => \"apples\" 'ley'.pluralize(:es)         # => \"leyes\" 'ley'.pluralize(1, :es)      # => \"ley\"  See ActiveSupport::Inflector.pluralize.",
    "label": "",
    "id": "3338"
  },
  {
    "raw_code": "def singularize(locale = :en)\n    ActiveSupport::Inflector.singularize(self, locale)\n  end",
    "comment": "The reverse of +pluralize+, returns the singular form of a word in a string.  If the optional parameter +locale+ is specified, the word will be singularized as a word of that language. By default, this parameter is set to <tt>:en</tt>. You must define your own inflection rules for languages other than English.  'posts'.singularize            # => \"post\" 'octopi'.singularize           # => \"octopus\" 'sheep'.singularize            # => \"sheep\" 'word'.singularize             # => \"word\" 'the blue mailmen'.singularize # => \"the blue mailman\" 'CamelOctopi'.singularize      # => \"CamelOctopus\" 'leyes'.singularize(:es)       # => \"ley\"  See ActiveSupport::Inflector.singularize.",
    "label": "",
    "id": "3339"
  },
  {
    "raw_code": "def constantize\n    ActiveSupport::Inflector.constantize(self)\n  end",
    "comment": "+constantize+ tries to find a declared constant with the name specified in the string. It raises a NameError when the name is not in CamelCase or is not initialized.  'Module'.constantize  # => Module 'Class'.constantize   # => Class 'blargle'.constantize # => NameError: wrong constant name blargle  See ActiveSupport::Inflector.constantize.",
    "label": "",
    "id": "3340"
  },
  {
    "raw_code": "def safe_constantize\n    ActiveSupport::Inflector.safe_constantize(self)\n  end",
    "comment": "+safe_constantize+ tries to find a declared constant with the name specified in the string. It returns +nil+ when the name is not in CamelCase or is not initialized.  'Module'.safe_constantize  # => Module 'Class'.safe_constantize   # => Class 'blargle'.safe_constantize # => nil  See ActiveSupport::Inflector.safe_constantize.",
    "label": "",
    "id": "3341"
  },
  {
    "raw_code": "def camelize(first_letter = :upper)\n    case first_letter\n    when :upper\n      ActiveSupport::Inflector.camelize(self, true)\n    when :lower\n      ActiveSupport::Inflector.camelize(self, false)\n    else\n      raise ArgumentError, \"Invalid option, use either :upper or :lower.\"\n    end",
    "comment": "By default, +camelize+ converts strings to UpperCamelCase. If the argument to camelize is set to <tt>:lower</tt> then camelize produces lowerCamelCase.  +camelize+ will also convert '/' to '::' which is useful for converting paths to namespaces.  'active_record'.camelize                # => \"ActiveRecord\" 'active_record'.camelize(:lower)        # => \"activeRecord\" 'active_record/errors'.camelize         # => \"ActiveRecord::Errors\" 'active_record/errors'.camelize(:lower) # => \"activeRecord::Errors\"  See ActiveSupport::Inflector.camelize.",
    "label": "",
    "id": "3342"
  },
  {
    "raw_code": "def titleize(keep_id_suffix: false)\n    ActiveSupport::Inflector.titleize(self, keep_id_suffix: keep_id_suffix)\n  end",
    "comment": "Capitalizes all the words and replaces some characters in the string to create a nicer looking title. +titleize+ is meant for creating pretty output. It is not used in the \\Rails internals.  The trailing '_id','Id'.. can be kept and capitalized by setting the optional parameter +keep_id_suffix+ to true. By default, this parameter is false.  'man from the boondocks'.titleize                       # => \"Man From The Boondocks\" 'x-men: the last stand'.titleize                        # => \"X Men: The Last Stand\" 'string_ending_with_id'.titleize(keep_id_suffix: true)  # => \"String Ending With Id\"  See ActiveSupport::Inflector.titleize.",
    "label": "",
    "id": "3343"
  },
  {
    "raw_code": "def underscore\n    ActiveSupport::Inflector.underscore(self)\n  end",
    "comment": "The reverse of +camelize+. Makes an underscored, lowercase form from the expression in the string.  +underscore+ will also change '::' to '/' to convert namespaces to paths.  'ActiveModel'.underscore         # => \"active_model\" 'ActiveModel::Errors'.underscore # => \"active_model/errors\"  See ActiveSupport::Inflector.underscore.",
    "label": "",
    "id": "3344"
  },
  {
    "raw_code": "def dasherize\n    ActiveSupport::Inflector.dasherize(self)\n  end",
    "comment": "Replaces underscores with dashes in the string.  'puni_puni'.dasherize # => \"puni-puni\"  See ActiveSupport::Inflector.dasherize.",
    "label": "",
    "id": "3345"
  },
  {
    "raw_code": "def demodulize\n    ActiveSupport::Inflector.demodulize(self)\n  end",
    "comment": "Removes the module part from the constant expression in the string.  'ActiveSupport::Inflector::Inflections'.demodulize # => \"Inflections\" 'Inflections'.demodulize                           # => \"Inflections\" '::Inflections'.demodulize                         # => \"Inflections\" ''.demodulize                                      # => ''  See ActiveSupport::Inflector.demodulize.  See also +deconstantize+.",
    "label": "",
    "id": "3346"
  },
  {
    "raw_code": "def deconstantize\n    ActiveSupport::Inflector.deconstantize(self)\n  end",
    "comment": "Removes the rightmost segment from the constant expression in the string.  'Net::HTTP'.deconstantize   # => \"Net\" '::Net::HTTP'.deconstantize # => \"::Net\" 'String'.deconstantize      # => \"\" '::String'.deconstantize    # => \"\" ''.deconstantize            # => \"\"  See ActiveSupport::Inflector.deconstantize.  See also +demodulize+.",
    "label": "",
    "id": "3347"
  },
  {
    "raw_code": "def parameterize(separator: \"-\", preserve_case: false, locale: nil)\n    ActiveSupport::Inflector.parameterize(self, separator: separator, preserve_case: preserve_case, locale: locale)\n  end",
    "comment": "Replaces special characters in a string so that it may be used as part of a 'pretty' URL.  If the optional parameter +locale+ is specified, the word will be parameterized as a word of that language. By default, this parameter is set to <tt>nil</tt> and it will use the configured <tt>I18n.locale</tt>.  class Person def to_param \"#{id}-#{name.parameterize}\" end end  @person = Person.find(1) # => #<Person id: 1, name: \"Donald E. Knuth\">  <%= link_to(@person.name, person_path) %> # => <a href=\"/person/1-donald-e-knuth\">Donald E. Knuth</a>  To preserve the case of the characters in a string, use the +preserve_case+ argument.  class Person def to_param \"#{id}-#{name.parameterize(preserve_case: true)}\" end end  @person = Person.find(1) # => #<Person id: 1, name: \"Donald E. Knuth\">  <%= link_to(@person.name, person_path) %> # => <a href=\"/person/1-Donald-E-Knuth\">Donald E. Knuth</a>  See ActiveSupport::Inflector.parameterize.",
    "label": "",
    "id": "3348"
  },
  {
    "raw_code": "def tableize\n    ActiveSupport::Inflector.tableize(self)\n  end",
    "comment": "Creates the name of a table like \\Rails does for models to table names. This method uses the +pluralize+ method on the last word in the string.  'RawScaledScorer'.tableize # => \"raw_scaled_scorers\" 'ham_and_egg'.tableize     # => \"ham_and_eggs\" 'fancyCategory'.tableize   # => \"fancy_categories\"  See ActiveSupport::Inflector.tableize.",
    "label": "",
    "id": "3349"
  },
  {
    "raw_code": "def classify\n    ActiveSupport::Inflector.classify(self)\n  end",
    "comment": "Creates a class name from a plural table name like \\Rails does for table names to models. Note that this returns a string and not a class. (To convert to an actual class follow +classify+ with +constantize+.)  'ham_and_eggs'.classify # => \"HamAndEgg\" 'posts'.classify        # => \"Post\"  See ActiveSupport::Inflector.classify.",
    "label": "",
    "id": "3350"
  },
  {
    "raw_code": "def humanize(capitalize: true, keep_id_suffix: false)\n    ActiveSupport::Inflector.humanize(self, capitalize: capitalize, keep_id_suffix: keep_id_suffix)\n  end",
    "comment": "Capitalizes the first word, turns underscores into spaces, and (by default) strips a trailing '_id' if present. Like +titleize+, this is meant for creating pretty output.  The capitalization of the first word can be turned off by setting the optional parameter +capitalize+ to false. By default, this parameter is true.  The trailing '_id' can be kept and capitalized by setting the optional parameter +keep_id_suffix+ to true. By default, this parameter is false.  'employee_salary'.humanize                    # => \"Employee salary\" 'author_id'.humanize                          # => \"Author\" 'author_id'.humanize(capitalize: false)       # => \"author\" '_id'.humanize                                # => \"Id\" 'author_id'.humanize(keep_id_suffix: true)    # => \"Author id\"  See ActiveSupport::Inflector.humanize.",
    "label": "",
    "id": "3351"
  },
  {
    "raw_code": "def upcase_first\n    ActiveSupport::Inflector.upcase_first(self)\n  end",
    "comment": "Converts the first character to uppercase.  'what a Lovely Day'.upcase_first # => \"What a Lovely Day\" 'w'.upcase_first                 # => \"W\" ''.upcase_first                  # => \"\"  See ActiveSupport::Inflector.upcase_first.",
    "label": "",
    "id": "3352"
  },
  {
    "raw_code": "def downcase_first\n    ActiveSupport::Inflector.downcase_first(self)\n  end",
    "comment": "Converts the first character to lowercase.  'If they enjoyed The Matrix'.downcase_first # => \"if they enjoyed The Matrix\" 'I'.downcase_first                          # => \"i\" ''.downcase_first                           # => \"\"  See ActiveSupport::Inflector.downcase_first.",
    "label": "",
    "id": "3353"
  },
  {
    "raw_code": "def foreign_key(separate_class_name_and_id_with_underscore = true)\n    ActiveSupport::Inflector.foreign_key(self, separate_class_name_and_id_with_underscore)\n  end",
    "comment": "Creates a foreign key name from a class name. +separate_class_name_and_id_with_underscore+ sets whether the method should put '_' between the name and 'id'.  'Message'.foreign_key        # => \"message_id\" 'Message'.foreign_key(false) # => \"messageid\" 'Admin::Post'.foreign_key    # => \"post_id\"  See ActiveSupport::Inflector.foreign_key.",
    "label": "",
    "id": "3354"
  },
  {
    "raw_code": "def inquiry\n    ActiveSupport::StringInquirer.new(self)\n  end",
    "comment": "Wraps the current string in the ActiveSupport::StringInquirer class, which gives you a prettier way to test for equality.  env = 'production'.inquiry env.production?  # => true env.development? # => false",
    "label": "",
    "id": "3355"
  },
  {
    "raw_code": "def mb_chars\n    ActiveSupport.deprecator.warn(\n      \"String#mb_chars is deprecated and will be removed in Rails 8.2. \" \\\n      \"Use normal string methods instead.\"\n    )\n\n    if ActiveSupport::Multibyte.proxy_class == ActiveSupport::Multibyte::Chars\n      ActiveSupport::Multibyte::Chars.new(self, deprecation: false)\n    else\n      ActiveSupport::Multibyte.proxy_class.new(self)\n    end",
    "comment": "== Multibyte proxy  +mb_chars+ is a multibyte safe proxy for string methods.  It creates and returns an instance of the ActiveSupport::Multibyte::Chars class which encapsulates the original string. A Unicode safe version of all the String methods are defined on this proxy class. If the proxy class doesn't respond to a certain method, it's forwarded to the encapsulated string.  >> \"ǉ\".mb_chars.upcase.to_s # => \"Ǉ\"  NOTE: Ruby 2.4 and later support native Unicode case mappings:  >> \"ǉ\".upcase # => \"Ǉ\"  == \\Method chaining  All the methods on the Chars proxy which normally return a string will return a Chars object. This allows method chaining on the result of any of these methods.  name.mb_chars.reverse.length # => 12  == Interoperability and configuration  The Chars object tries to be as interchangeable with String objects as possible: sorting and comparing between String and Char work like expected. The bang! methods change the internal string representation in the Chars object. Interoperability problems can be resolved easily with a +to_s+ call.  For more information about the methods defined on the Chars proxy see ActiveSupport::Multibyte::Chars. For information about how to change the default Multibyte behavior see ActiveSupport::Multibyte.",
    "label": "",
    "id": "3356"
  },
  {
    "raw_code": "def is_utf8?\n    case encoding\n    when Encoding::UTF_8, Encoding::US_ASCII\n      valid_encoding?\n    when Encoding::ASCII_8BIT\n      dup.force_encoding(Encoding::UTF_8).valid_encoding?\n    else\n      false\n    end",
    "comment": "Returns +true+ if string has utf_8 encoding.  utf_8_str = \"some string\".encode \"UTF-8\" iso_str = \"some string\".encode \"ISO-8859-1\"  utf_8_str.is_utf8? # => true iso_str.is_utf8?   # => false",
    "label": "",
    "id": "3357"
  },
  {
    "raw_code": "def html_safe\n    ActiveSupport::SafeBuffer.new(self)\n  end",
    "comment": "Marks a string as trusted safe. It will be inserted into HTML with no additional escaping performed. It is your responsibility to ensure that the string contains no malicious content. This method is equivalent to the +raw+ helper in views. It is recommended that you use +sanitize+ instead of this method. It should never be called on user input.",
    "label": "",
    "id": "3358"
  },
  {
    "raw_code": "def strip_heredoc\n    gsub(/^#{scan(/^[ \\t]*(?=\\S)/).min}/, \"\").tap do |stripped|\n      stripped.freeze if frozen?\n    end",
    "comment": "Strips indentation in heredocs.  For example in  if options[:usage] puts <<-USAGE.strip_heredoc This command does such and such.  Supported options are: -h         This message ... USAGE end  the user would see the usage message aligned against the left margin.  Technically, it looks for the least indented non-empty line in the whole string, and removes that amount of leading whitespace.",
    "label": "",
    "id": "3359"
  },
  {
    "raw_code": "def in_time_zone(zone = ::Time.zone)\n    if zone\n      ::Time.find_zone!(zone).parse(self)\n    else\n      to_time\n    end",
    "comment": "Converts String to a TimeWithZone in the current zone if Time.zone or Time.zone_default is set, otherwise converts String to a Time via String#to_time",
    "label": "",
    "id": "3360"
  },
  {
    "raw_code": "def acts_like_time?\n    true\n  end",
    "comment": "Duck-types as a Time-like class. See Object#acts_like?.",
    "label": "",
    "id": "3361"
  },
  {
    "raw_code": "def ===(other)\n      super || (self == Time && other.is_a?(ActiveSupport::TimeWithZone))\n    end",
    "comment": "Overriding case equality method so that it returns true for ActiveSupport::TimeWithZone instances",
    "label": "",
    "id": "3362"
  },
  {
    "raw_code": "def days_in_month(month, year = current.year)\n      if month == 2 && ::Date.gregorian_leap?(year)\n        29\n      else\n        COMMON_YEAR_DAYS_IN_MONTH[month]\n      end",
    "comment": "Returns the number of days in the given month. If no year is specified, it will use the current year.",
    "label": "",
    "id": "3363"
  },
  {
    "raw_code": "def days_in_year(year = current.year)\n      days_in_month(2, year) + 337\n    end",
    "comment": "Returns the number of days in the given year. If no year is specified, it will use the current year.",
    "label": "",
    "id": "3364"
  },
  {
    "raw_code": "def current\n      ::Time.zone ? ::Time.zone.now : ::Time.now\n    end",
    "comment": "Returns <tt>Time.zone.now</tt> when <tt>Time.zone</tt> or <tt>config.time_zone</tt> are set, otherwise just returns <tt>Time.now</tt>.",
    "label": "",
    "id": "3365"
  },
  {
    "raw_code": "def at_with_coercion(time_or_number, *args)\n      if args.empty?\n        if time_or_number.is_a?(ActiveSupport::TimeWithZone)\n          at_without_coercion(time_or_number.to_r).getlocal\n        elsif time_or_number.is_a?(DateTime)\n          at_without_coercion(time_or_number.to_f).getlocal\n        else\n          at_without_coercion(time_or_number)\n        end",
    "comment": "Layers additional behavior on Time.at so that ActiveSupport::TimeWithZone and DateTime instances can be used when called with a single argument",
    "label": "",
    "id": "3366"
  },
  {
    "raw_code": "def rfc3339(str)\n      parts = Date._rfc3339(str)\n\n      raise ArgumentError, \"invalid date\" if parts.empty?\n\n      Time.new(\n        parts.fetch(:year),\n        parts.fetch(:mon),\n        parts.fetch(:mday),\n        parts.fetch(:hour),\n        parts.fetch(:min),\n        parts.fetch(:sec) + parts.fetch(:sec_fraction, 0),\n        parts.fetch(:offset)\n      )\n    end",
    "comment": "Creates a +Time+ instance from an RFC 3339 string.  Time.rfc3339('1999-12-31T14:00:00-10:00') # => 2000-01-01 00:00:00 -1000  If the time or offset components are missing then an +ArgumentError+ will be raised.  Time.rfc3339('1999-12-31') # => ArgumentError: invalid date",
    "label": "",
    "id": "3367"
  },
  {
    "raw_code": "def seconds_since_midnight\n    to_i - change(hour: 0).to_i + (usec / 1.0e+6)\n  end",
    "comment": "Returns the number of seconds since 00:00:00.  Time.new(2012, 8, 29,  0,  0,  0).seconds_since_midnight # => 0.0 Time.new(2012, 8, 29, 12, 34, 56).seconds_since_midnight # => 45296.0 Time.new(2012, 8, 29, 23, 59, 59).seconds_since_midnight # => 86399.0",
    "label": "",
    "id": "3368"
  },
  {
    "raw_code": "def seconds_until_end_of_day\n    end_of_day.to_i - to_i\n  end",
    "comment": "Returns the number of seconds until 23:59:59.  Time.new(2012, 8, 29,  0,  0,  0).seconds_until_end_of_day # => 86399 Time.new(2012, 8, 29, 12, 34, 56).seconds_until_end_of_day # => 41103 Time.new(2012, 8, 29, 23, 59, 59).seconds_until_end_of_day # => 0",
    "label": "",
    "id": "3369"
  },
  {
    "raw_code": "def sec_fraction\n    subsec\n  end",
    "comment": "Returns the fraction of a second as a +Rational+  Time.new(2012, 8, 29, 0, 0, 0.5).sec_fraction # => (1/2)",
    "label": "",
    "id": "3370"
  },
  {
    "raw_code": "def change(options)\n    new_year   = options.fetch(:year, year)\n    new_month  = options.fetch(:month, month)\n    new_day    = options.fetch(:day, day)\n    new_hour   = options.fetch(:hour, hour)\n    new_min    = options.fetch(:min, options[:hour] ? 0 : min)\n    new_sec    = options.fetch(:sec, (options[:hour] || options[:min]) ? 0 : sec)\n    new_offset = options.fetch(:offset, nil)\n\n    if new_nsec = options[:nsec]\n      raise ArgumentError, \"Can't change both :nsec and :usec at the same time: #{options.inspect}\" if options[:usec]\n      new_usec = Rational(new_nsec, 1000)\n    else\n      new_usec = options.fetch(:usec, (options[:hour] || options[:min] || options[:sec]) ? 0 : Rational(nsec, 1000))\n    end",
    "comment": "Returns a new Time where one or more of the elements have been changed according to the +options+ parameter. The time options (<tt>:hour</tt>, <tt>:min</tt>, <tt>:sec</tt>, <tt>:usec</tt>, <tt>:nsec</tt>) reset cascadingly, so if only the hour is passed, then minute, sec, usec, and nsec is set to 0. If the hour and minute is passed, then sec, usec, and nsec is set to 0. The +options+ parameter takes a hash with any of these keys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>, <tt>:hour</tt>, <tt>:min</tt>, <tt>:sec</tt>, <tt>:usec</tt>, <tt>:nsec</tt>, <tt>:offset</tt>. Pass either <tt>:usec</tt> or <tt>:nsec</tt>, not both.  Time.new(2012, 8, 29, 22, 35, 0).change(day: 1)              # => Time.new(2012, 8, 1, 22, 35, 0) Time.new(2012, 8, 29, 22, 35, 0).change(year: 1981, day: 1)  # => Time.new(1981, 8, 1, 22, 35, 0) Time.new(2012, 8, 29, 22, 35, 0).change(year: 1981, hour: 0) # => Time.new(1981, 8, 29, 0, 0, 0)",
    "label": "",
    "id": "3371"
  },
  {
    "raw_code": "def advance(options)\n    unless options[:weeks].nil?\n      options[:weeks], partial_weeks = options[:weeks].divmod(1)\n      options[:days] = options.fetch(:days, 0) + 7 * partial_weeks\n    end",
    "comment": "Uses Date to provide precise Time calculations for years, months, and days according to the proleptic Gregorian calendar. The +options+ parameter takes a hash with any of these keys: <tt>:years</tt>, <tt>:months</tt>, <tt>:weeks</tt>, <tt>:days</tt>, <tt>:hours</tt>, <tt>:minutes</tt>, <tt>:seconds</tt>.  Time.new(2015, 8, 1, 14, 35, 0).advance(seconds: 1) # => 2015-08-01 14:35:01 -0700 Time.new(2015, 8, 1, 14, 35, 0).advance(minutes: 1) # => 2015-08-01 14:36:00 -0700 Time.new(2015, 8, 1, 14, 35, 0).advance(hours: 1)   # => 2015-08-01 15:35:00 -0700 Time.new(2015, 8, 1, 14, 35, 0).advance(days: 1)    # => 2015-08-02 14:35:00 -0700 Time.new(2015, 8, 1, 14, 35, 0).advance(weeks: 1)   # => 2015-08-08 14:35:00 -0700  Just like Date#advance, increments are applied in order of time units from largest to smallest. This order can affect the result around the end of a month.",
    "label": "",
    "id": "3372"
  },
  {
    "raw_code": "def ago(seconds)\n    since(-seconds)\n  end",
    "comment": "Returns a new Time representing the time a number of seconds ago, this is basically a wrapper around the Numeric extension",
    "label": "",
    "id": "3373"
  },
  {
    "raw_code": "def since(seconds)\n    self + seconds\n  rescue TypeError\n    result = to_datetime.since(seconds)\n    ActiveSupport.deprecator.warn(\n      \"Passing an instance of #{seconds.class} to #{self.class}#since is deprecated. This behavior will raise \" \\\n      \"a `TypeError` in Rails 8.1.\"\n    )\n    result\n  end",
    "comment": "Returns a new Time representing the time a number of seconds since the instance time",
    "label": "",
    "id": "3374"
  },
  {
    "raw_code": "def beginning_of_day\n    change(hour: 0)\n  end",
    "comment": "Returns a new Time representing the start of the day (0:00)",
    "label": "",
    "id": "3375"
  },
  {
    "raw_code": "def middle_of_day\n    change(hour: 12)\n  end",
    "comment": "Returns a new Time representing the middle of the day (12:00)",
    "label": "",
    "id": "3376"
  },
  {
    "raw_code": "def end_of_day\n    change(\n      hour: 23,\n      min: 59,\n      sec: 59,\n      usec: Rational(999999999, 1000)\n    )\n  end",
    "comment": "Returns a new Time representing the end of the day, 23:59:59.999999",
    "label": "",
    "id": "3377"
  },
  {
    "raw_code": "def beginning_of_hour\n    change(min: 0)\n  end",
    "comment": "Returns a new Time representing the start of the hour (x:00)",
    "label": "",
    "id": "3378"
  },
  {
    "raw_code": "def end_of_hour\n    change(\n      min: 59,\n      sec: 59,\n      usec: Rational(999999999, 1000)\n    )\n  end",
    "comment": "Returns a new Time representing the end of the hour, x:59:59.999999",
    "label": "",
    "id": "3379"
  },
  {
    "raw_code": "def beginning_of_minute\n    change(sec: 0)\n  end",
    "comment": "Returns a new Time representing the start of the minute (x:xx:00)",
    "label": "",
    "id": "3380"
  },
  {
    "raw_code": "def end_of_minute\n    change(\n      sec: 59,\n      usec: Rational(999999999, 1000)\n    )\n  end",
    "comment": "Returns a new Time representing the end of the minute, x:xx:59.999999",
    "label": "",
    "id": "3381"
  },
  {
    "raw_code": "def minus_with_coercion(other)\n    other = other.comparable_time if other.respond_to?(:comparable_time)\n    other.is_a?(DateTime) ? to_f - other.to_f : minus_without_coercion(other)\n  end",
    "comment": "Time#- can also be used to determine the number of seconds between two Time instances. We're layering on additional behavior so that ActiveSupport::TimeWithZone instances are coerced into values that Time#- will recognize",
    "label": "",
    "id": "3382"
  },
  {
    "raw_code": "def compare_with_coercion(other)\n    # we're avoiding Time#to_datetime and Time#to_time because they're expensive\n    if other.class == Time\n      compare_without_coercion(other)\n    elsif other.is_a?(Time)\n      # also avoid ActiveSupport::TimeWithZone#to_time before Rails 8.0\n      if other.respond_to?(:comparable_time)\n        compare_without_coercion(other.comparable_time)\n      else\n        compare_without_coercion(other.to_time)\n      end",
    "comment": "Layers additional behavior on Time#<=> so that DateTime and ActiveSupport::TimeWithZone instances can be chronologically compared with a Time",
    "label": "",
    "id": "3383"
  },
  {
    "raw_code": "def eql_with_coercion(other)\n    # if other is an ActiveSupport::TimeWithZone, coerce a Time instance from it so we can do eql? comparison\n    other = other.comparable_time if other.respond_to?(:comparable_time)\n    eql_without_coercion(other)\n  end",
    "comment": "Layers additional behavior on Time#eql? so that ActiveSupport::TimeWithZone instances can be eql? to an equivalent Time",
    "label": "",
    "id": "3384"
  },
  {
    "raw_code": "def prev_day(days = 1)\n    advance(days: -days)\n  end",
    "comment": "Returns a new time the specified number of days ago.",
    "label": "",
    "id": "3385"
  },
  {
    "raw_code": "def next_day(days = 1)\n    advance(days: days)\n  end",
    "comment": "Returns a new time the specified number of days in the future.",
    "label": "",
    "id": "3386"
  },
  {
    "raw_code": "def prev_month(months = 1)\n    advance(months: -months)\n  end",
    "comment": "Returns a new time the specified number of months ago.",
    "label": "",
    "id": "3387"
  },
  {
    "raw_code": "def next_month(months = 1)\n    advance(months: months)\n  end",
    "comment": "Returns a new time the specified number of months in the future.",
    "label": "",
    "id": "3388"
  },
  {
    "raw_code": "def prev_year(years = 1)\n    advance(years: -years)\n  end",
    "comment": "Returns a new time the specified number of years ago.",
    "label": "",
    "id": "3389"
  },
  {
    "raw_code": "def next_year(years = 1)\n    advance(years: years)\n  end",
    "comment": "Returns a new time the specified number of years in the future.",
    "label": "",
    "id": "3390"
  },
  {
    "raw_code": "def to_time\n    preserve_timezone ? self : getlocal\n  end",
    "comment": "Either return +self+ or the time in the local system timezone depending on the setting of +ActiveSupport.to_time_preserves_timezone+.",
    "label": "",
    "id": "3391"
  },
  {
    "raw_code": "def to_fs(format = :default)\n    if formatter = DATE_FORMATS[format]\n      formatter.respond_to?(:call) ? formatter.call(self).to_s : strftime(formatter)\n    else\n      to_s\n    end",
    "comment": "Converts to a formatted string. See DATE_FORMATS for built-in formats.  This method is aliased to <tt>to_formatted_s</tt>.  time = Time.now                    # => 2007-01-18 06:10:17 -06:00  time.to_fs(:time)                  # => \"06:10\" time.to_formatted_s(:time)         # => \"06:10\"  time.to_fs(:db)           # => \"2007-01-18 06:10:17\" time.to_fs(:number)       # => \"20070118061017\" time.to_fs(:short)        # => \"18 Jan 06:10\" time.to_fs(:long)         # => \"January 18, 2007 06:10\" time.to_fs(:long_ordinal) # => \"January 18th, 2007 06:10\" time.to_fs(:rfc822)       # => \"Thu, 18 Jan 2007 06:10:17 -0600\" time.to_fs(:rfc2822)       # => \"Thu, 18 Jan 2007 06:10:17 -0600\" time.to_fs(:iso8601)      # => \"2007-01-18T06:10:17-06:00\"  == Adding your own time formats to +to_fs+ You can add your own formats to the Time::DATE_FORMATS hash. Use the format name as the hash key and either a strftime string or Proc instance that takes a time argument as the value.  # config/initializers/time_formats.rb Time::DATE_FORMATS[:month_and_year] = '%B %Y' Time::DATE_FORMATS[:short_ordinal]  = ->(time) { time.strftime(\"%B #{time.day.ordinalize}\") }",
    "label": "",
    "id": "3392"
  },
  {
    "raw_code": "def formatted_offset(colon = true, alternate_utc_string = nil)\n    utc? && alternate_utc_string || ActiveSupport::TimeZone.seconds_to_utc_offset(utc_offset, colon)\n  end",
    "comment": "Returns a formatted string of the offset from UTC, or an alternative string if the time zone is already UTC.  Time.local(2000).formatted_offset        # => \"-06:00\" Time.local(2000).formatted_offset(false) # => \"-0600\"",
    "label": "",
    "id": "3393"
  },
  {
    "raw_code": "def zone\n      ::ActiveSupport::IsolatedExecutionState[:time_zone] || zone_default\n    end",
    "comment": "Returns the TimeZone for the current request, if this has been set (via Time.zone=). If <tt>Time.zone</tt> has not been set for the current request, returns the TimeZone specified in <tt>config.time_zone</tt>.",
    "label": "",
    "id": "3394"
  },
  {
    "raw_code": "def zone=(time_zone)\n      ::ActiveSupport::IsolatedExecutionState[:time_zone] = find_zone!(time_zone)\n    end",
    "comment": "Sets <tt>Time.zone</tt> to a TimeZone object for the current request/thread.  This method accepts any of the following:  * A \\Rails TimeZone object. * An identifier for a \\Rails TimeZone object (e.g., \"Eastern \\Time (US & Canada)\", <tt>-5.hours</tt>). * A +TZInfo::Timezone+ object. * An identifier for a +TZInfo::Timezone+ object (e.g., \"America/New_York\").  Here's an example of how you might set <tt>Time.zone</tt> on a per request basis and reset it when the request is done. <tt>current_user.time_zone</tt> just needs to return a string identifying the user's preferred time zone:  class ApplicationController < ActionController::Base around_action :set_time_zone  def set_time_zone if logged_in? Time.use_zone(current_user.time_zone) { yield } else yield end end end",
    "label": "",
    "id": "3395"
  },
  {
    "raw_code": "def use_zone(time_zone)\n      new_zone = find_zone!(time_zone)\n      begin\n        old_zone, ::Time.zone = ::Time.zone, new_zone\n        yield\n      ensure\n        ::Time.zone = old_zone\n      end",
    "comment": "Allows override of <tt>Time.zone</tt> locally inside supplied block; resets <tt>Time.zone</tt> to existing value when done.  class ApplicationController < ActionController::Base around_action :set_time_zone  private def set_time_zone Time.use_zone(current_user.timezone) { yield } end end  NOTE: This won't affect any ActiveSupport::TimeWithZone objects that have already been created, e.g. any model timestamp attributes that have been read before the block will remain in the application's default timezone.",
    "label": "",
    "id": "3396"
  },
  {
    "raw_code": "def find_zone!(time_zone)\n      return time_zone unless time_zone\n\n      ActiveSupport::TimeZone[time_zone] || raise(ArgumentError, \"Invalid Timezone: #{time_zone}\")\n    end",
    "comment": "Returns a TimeZone instance matching the time zone provided. Accepts the time zone in any format supported by <tt>Time.zone=</tt>. Raises an +ArgumentError+ for invalid time zones.  Time.find_zone! \"America/New_York\" # => #<ActiveSupport::TimeZone @name=\"America/New_York\" ...> Time.find_zone! \"EST\"              # => #<ActiveSupport::TimeZone @name=\"EST\" ...> Time.find_zone! -5.hours           # => #<ActiveSupport::TimeZone @name=\"Bogota\" ...> Time.find_zone! nil                # => nil Time.find_zone! false              # => false Time.find_zone! \"NOT-A-TIMEZONE\"   # => ArgumentError: Invalid Timezone: NOT-A-TIMEZONE",
    "label": "",
    "id": "3397"
  },
  {
    "raw_code": "def find_zone(time_zone)\n      find_zone!(time_zone) rescue nil\n    end",
    "comment": "Returns a TimeZone instance matching the time zone provided. Accepts the time zone in any format supported by <tt>Time.zone=</tt>. Returns +nil+ for invalid time zones.  Time.find_zone \"America/New_York\" # => #<ActiveSupport::TimeZone @name=\"America/New_York\" ...> Time.find_zone \"NOT-A-TIMEZONE\"   # => nil",
    "label": "",
    "id": "3398"
  },
  {
    "raw_code": "def require_dependency(filename)\n    filename = filename.to_path if filename.respond_to?(:to_path)\n\n    unless filename.is_a?(String)\n      raise ArgumentError, \"the file name must be either a String or implement #to_path -- you passed #{filename.inspect}\"\n    end",
    "comment": "<b>Warning:</b> This method is obsolete. The semantics of the autoloader match Ruby's and you do not need to be defensive with load order anymore. Just refer to classes and modules normally.  Engines that do not control the mode in which their parent application runs should call +require_dependency+ where needed in case the runtime mode is +:classic+.",
    "label": "",
    "id": "3399"
  },
  {
    "raw_code": "def behavior\n        @behavior ||= [DEFAULT_BEHAVIORS[:stderr]]\n      end",
    "comment": "Returns the current behavior or if one isn't set, defaults to +:stderr+.",
    "label": "",
    "id": "3400"
  },
  {
    "raw_code": "def disallowed_behavior\n        @disallowed_behavior ||= [DEFAULT_BEHAVIORS[:raise]]\n      end",
    "comment": "Returns the current behavior for disallowed deprecations or if one isn't set, defaults to +:raise+.",
    "label": "",
    "id": "3401"
  },
  {
    "raw_code": "def behavior=(behavior)\n        @behavior = Array(behavior).map { |b| DEFAULT_BEHAVIORS[b] || arity_coerce(b) }\n      end",
    "comment": "Sets the behavior to the specified value. Can be a single value, array, or an object that responds to +call+.  Available behaviors:  [+:raise+]   Raise ActiveSupport::DeprecationException. [+:stderr+]  Log all deprecation warnings to <tt>$stderr</tt>. [+:log+]     Log all deprecation warnings to +Rails.logger+. [+:notify+]  Use ActiveSupport::Notifications to notify +deprecation.rails+. [+:report+]  Use ActiveSupport::ErrorReporter to report deprecations. [+:silence+] Do nothing.  Setting behaviors only affects deprecations that happen after boot time. Deprecation warnings raised by gems are not affected by this setting because they happen before \\Rails boots up.  deprecator = ActiveSupport::Deprecation.new deprecator.behavior = :stderr deprecator.behavior = [:stderr, :log] deprecator.behavior = MyCustomHandler deprecator.behavior = ->(message, callstack, deprecation_horizon, gem_name) { # custom stuff }  If you are using \\Rails, you can set <tt>config.active_support.report_deprecations = false</tt> to disable all deprecation behaviors. This is similar to the +:silence+ option but more performant.",
    "label": "",
    "id": "3402"
  },
  {
    "raw_code": "def disallowed_behavior=(behavior)\n        @disallowed_behavior = Array(behavior).map { |b| DEFAULT_BEHAVIORS[b] || arity_coerce(b) }\n      end",
    "comment": "Sets the behavior for disallowed deprecations (those configured by ActiveSupport::Deprecation#disallowed_warnings=) to the specified value. As with #behavior=, this can be a single value, array, or an object that responds to +call+.",
    "label": "",
    "id": "3403"
  },
  {
    "raw_code": "def deprecate_constant(old_constant_name, new_constant_path, deprecator:, message: nil)\n            class_variable_set(:@@_deprecated_constants, {}) unless class_variable_defined?(:@@_deprecated_constants)\n            class_variable_get(:@@_deprecated_constants)[old_constant_name.to_s] = { new: new_constant_path, message: message, deprecator: deprecator }\n          end",
    "comment": "Provides a way to rename constants with a deprecation cycle in which both the old and new names work, but using the old one prints a deprecation message.  In order to rename <tt>A::B</tt> to <tt>C::D</tt>, you need to delete the definition of <tt>A::B</tt> and declare the deprecation in +A+:  require \"active_support/deprecation\"  module A include ActiveSupport::Deprecation::DeprecatedConstantAccessor  deprecate_constant \"B\", \"C::D\", deprecator: ActiveSupport::Deprecation.new end  The first argument is a constant name (no colons). It is the name of the constant you want to deprecate in the enclosing class or module.  The second argument is the constant path of the replacement. That has to be a full path even if the replacement is defined in the same namespace as the deprecated one was.  In both cases, strings and symbols are supported.  The +deprecator+ keyword argument is the object that will print the deprecation message, an instance of ActiveSupport::Deprecation.  With that in place, references to <tt>A::B</tt> still work, they evaluate to <tt>C::D</tt> now, and trigger a deprecation warning:  DEPRECATION WARNING: A::B is deprecated! Use C::D instead. (called from ...)  The message can be customized with the optional +message+ keyword argument.  For this to work, a +const_missing+ hook is installed. When client code references the deprecated constant, the callback prints the message and constantizes the replacement.  Caveat: If the deprecated constant name is reachable in a different namespace and Ruby constant lookup finds it, the hook won't be called and the deprecation won't work as intended. This may happen, for example, if an ancestor of the enclosing namespace has a constant with the same name. This is an unsupported edge case.",
    "label": "",
    "id": "3404"
  },
  {
    "raw_code": "def [](name)\n        @deprecators[name]\n      end",
    "comment": "Returns a deprecator added to this collection via #[]=.",
    "label": "",
    "id": "3405"
  },
  {
    "raw_code": "def []=(name, deprecator)\n        apply_options(deprecator)\n        @deprecators[name] = deprecator\n      end",
    "comment": "Adds a given +deprecator+ to this collection. The deprecator will be immediately configured with any options previously set on this collection.  deprecators = ActiveSupport::Deprecation::Deprecators.new deprecators.debug = true  foo_deprecator = ActiveSupport::Deprecation.new(\"2.0\", \"Foo\") foo_deprecator.debug    # => false  deprecators[:foo] = foo_deprecator deprecators[:foo].debug # => true foo_deprecator.debug    # => true ",
    "label": "",
    "id": "3406"
  },
  {
    "raw_code": "def each(&block)\n        return to_enum(__method__) unless block\n        @deprecators.each_value(&block)\n      end",
    "comment": "Iterates over all deprecators in this collection. If no block is given, returns an +Enumerator+.",
    "label": "",
    "id": "3407"
  },
  {
    "raw_code": "def silenced=(silenced)\n        set_option(:silenced, silenced)\n      end",
    "comment": "Sets the silenced flag for all deprecators in this collection.",
    "label": "",
    "id": "3408"
  },
  {
    "raw_code": "def debug=(debug)\n        set_option(:debug, debug)\n      end",
    "comment": "Sets the debug flag for all deprecators in this collection.",
    "label": "",
    "id": "3409"
  },
  {
    "raw_code": "def behavior=(behavior)\n        set_option(:behavior, behavior)\n      end",
    "comment": "Sets the deprecation warning behavior for all deprecators in this collection.  See ActiveSupport::Deprecation#behavior=.",
    "label": "",
    "id": "3410"
  },
  {
    "raw_code": "def disallowed_behavior=(disallowed_behavior)\n        set_option(:disallowed_behavior, disallowed_behavior)\n      end",
    "comment": "Sets the disallowed deprecation warning behavior for all deprecators in this collection.  See ActiveSupport::Deprecation#disallowed_behavior=.",
    "label": "",
    "id": "3411"
  },
  {
    "raw_code": "def disallowed_warnings=(disallowed_warnings)\n        set_option(:disallowed_warnings, disallowed_warnings)\n      end",
    "comment": "Sets the disallowed deprecation warnings for all deprecators in this collection.  See ActiveSupport::Deprecation#disallowed_warnings=.",
    "label": "",
    "id": "3412"
  },
  {
    "raw_code": "def silence(&block)\n        each { |deprecator| deprecator.begin_silence }\n        block.call\n      ensure\n        each { |deprecator| deprecator.end_silence }\n      end",
    "comment": "Silences all deprecators in this collection for the duration of the given block.  See ActiveSupport::Deprecation#silence.",
    "label": "",
    "id": "3413"
  },
  {
    "raw_code": "def disallowed_warnings\n        @disallowed_warnings ||= []\n      end",
    "comment": "Returns the configured criteria used to identify deprecation messages which should be treated as disallowed.",
    "label": "",
    "id": "3414"
  },
  {
    "raw_code": "def deprecate_methods(target_module, *method_names)\n        options = method_names.extract_options!\n        deprecator = options.delete(:deprecator) || self\n        method_names += options.keys\n        mod = nil\n\n        method_names.each do |method_name|\n          message = options[method_name]\n          if target_module.method_defined?(method_name) || target_module.private_method_defined?(method_name)\n            method = target_module.instance_method(method_name)\n            target_module.module_eval do\n              redefine_method(method_name) do |*args, &block|\n                deprecator.deprecation_warning(method_name, message)\n                method.bind_call(self, *args, &block)\n              end",
    "comment": "Declare that a method has been deprecated.  class Fred def aaa; end def bbb; end def ccc; end def ddd; end def eee; end end  deprecator = ActiveSupport::Deprecation.new('next-release', 'MyGem')  deprecator.deprecate_methods(Fred, :aaa, bbb: :zzz, ccc: 'use Bar#ccc instead') # => Fred  Fred.new.aaa # DEPRECATION WARNING: aaa is deprecated and will be removed from MyGem next-release. (called from irb_binding at (irb):10) # => nil  Fred.new.bbb # DEPRECATION WARNING: bbb is deprecated and will be removed from MyGem next-release (use zzz instead). (called from irb_binding at (irb):11) # => nil  Fred.new.ccc # DEPRECATION WARNING: ccc is deprecated and will be removed from MyGem next-release (use Bar#ccc instead). (called from irb_binding at (irb):12) # => nil",
    "label": "",
    "id": "3415"
  },
  {
    "raw_code": "def inspect\n        target.inspect\n      end",
    "comment": "Don't give a deprecation warning on inspect since test/unit and error logs rely on it for diagnostics.",
    "label": "",
    "id": "3416"
  },
  {
    "raw_code": "def inspect\n        target.inspect\n      end",
    "comment": "Don't give a deprecation warning on inspect since test/unit and error logs rely on it for diagnostics.",
    "label": "",
    "id": "3417"
  },
  {
    "raw_code": "def class\n        target.class\n      end",
    "comment": "Returns the class of the new constant.  PLANETS_POST_2006 = %w(mercury venus earth mars jupiter saturn uranus neptune) PLANETS = ActiveSupport::Deprecation::DeprecatedConstantProxy.new('PLANETS', 'PLANETS_POST_2006') PLANETS.class # => Array",
    "label": "",
    "id": "3418"
  },
  {
    "raw_code": "def warn(message = nil, callstack = nil)\n        return if silenced\n\n        callstack ||= caller_locations(2)\n        deprecation_message(callstack, message).tap do |full_message|\n          if deprecation_disallowed?(message)\n            disallowed_behavior.each { |b| b.call(full_message, callstack, self) }\n          else\n            behavior.each { |b| b.call(full_message, callstack, self) }\n          end",
    "comment": "Outputs a deprecation warning to the output configured by ActiveSupport::Deprecation#behavior.  ActiveSupport::Deprecation.new.warn('something broke!') # => \"DEPRECATION WARNING: something broke! (called from your_code.rb:1)\"",
    "label": "",
    "id": "3419"
  },
  {
    "raw_code": "def silence(&block)\n        begin_silence\n        block.call\n      ensure\n        end_silence\n      end",
    "comment": "Silence deprecation warnings within the block.  deprecator = ActiveSupport::Deprecation.new deprecator.warn('something broke!') # => \"DEPRECATION WARNING: something broke! (called from your_code.rb:1)\"  deprecator.silence do deprecator.warn('something broke!') end # => nil",
    "label": "",
    "id": "3420"
  },
  {
    "raw_code": "def allow(allowed_warnings = :all, if: true, &block)\n        conditional = binding.local_variable_get(:if)\n        conditional = conditional.call if conditional.respond_to?(:call)\n        if conditional\n          @explicitly_allowed_warnings.bind(allowed_warnings, &block)\n        else\n          yield\n        end",
    "comment": "Allow previously disallowed deprecation warnings within the block. <tt>allowed_warnings</tt> can be an array containing strings, symbols, or regular expressions. (Symbols are treated as strings). These are compared against the text of deprecation warning messages generated within the block. Matching warnings will be exempt from the rules set by ActiveSupport::Deprecation#disallowed_warnings.  The optional <tt>if:</tt> argument accepts a truthy/falsy value or an object that responds to <tt>.call</tt>. If truthy, then matching warnings will be allowed. If falsey then the method yields to the block without allowing the warning.  deprecator = ActiveSupport::Deprecation.new deprecator.disallowed_behavior = :raise deprecator.disallowed_warnings = [ \"something broke\" ]  deprecator.warn('something broke!') # => ActiveSupport::DeprecationException  deprecator.allow ['something broke'] do deprecator.warn('something broke!') end # => nil  deprecator.allow ['something broke'], if: Rails.env.production? do deprecator.warn('something broke!') end # => ActiveSupport::DeprecationException for dev/test, nil for production",
    "label": "",
    "id": "3421"
  },
  {
    "raw_code": "def deprecated_method_warning(method_name, message = nil)\n          warning = \"#{method_name} is deprecated and will be removed from #{gem_name} #{deprecation_horizon}\"\n          case message\n          when Symbol then \"#{warning} (use #{message} instead)\"\n          when String then \"#{warning} (#{message})\"\n          else warning\n          end",
    "comment": "Outputs a deprecation warning message  deprecated_method_warning(:method_name) # => \"method_name is deprecated and will be removed from Rails #{deprecation_horizon}\" deprecated_method_warning(:method_name, :another_method) # => \"method_name is deprecated and will be removed from Rails #{deprecation_horizon} (use another_method instead)\" deprecated_method_warning(:method_name, \"Optional message\") # => \"method_name is deprecated and will be removed from Rails #{deprecation_horizon} (Optional message)\"",
    "label": "",
    "id": "3422"
  },
  {
    "raw_code": "def number\n          PERIOD_OR_COMMA.match?(scanner[1]) ? scanner[1].tr(COMMA, PERIOD).to_f : scanner[1].to_i\n        end",
    "comment": "Parses number which can be a float with either comma or period.",
    "label": "",
    "id": "3423"
  },
  {
    "raw_code": "def validate!\n          raise_parsing_error(\"is empty duration\") if parts.empty?\n\n          # Mixing any of Y, M, D with W is invalid.\n          if parts.key?(:weeks) && parts.keys.intersect?(DATE_COMPONENTS)\n            raise_parsing_error(\"mixing weeks with other date parts not allowed\")\n          end",
    "comment": "Checks for various semantic errors as stated in ISO 8601 standard.",
    "label": "",
    "id": "3424"
  },
  {
    "raw_code": "def serialize\n        parts = normalize\n        return \"PT0S\" if parts.empty?\n\n        output = +\"P\"\n        output << \"#{parts[:years]}Y\"   if parts.key?(:years)\n        output << \"#{parts[:months]}M\"  if parts.key?(:months)\n        output << \"#{parts[:days]}D\"    if parts.key?(:days)\n        output << \"#{parts[:weeks]}W\"   if parts.key?(:weeks)\n        time = +\"\"\n        time << \"#{parts[:hours]}H\"     if parts.key?(:hours)\n        time << \"#{parts[:minutes]}M\"   if parts.key?(:minutes)\n        if parts.key?(:seconds)\n          time << \"#{format_seconds(parts[:seconds])}S\"\n        end",
    "comment": "Builds and returns output string.",
    "label": "",
    "id": "3425"
  },
  {
    "raw_code": "def normalize\n          parts = @duration.parts.each_with_object(Hash.new(0)) do |(k, v), p|\n            p[k] += v  unless v.zero?\n          end",
    "comment": "Return pair of duration's parts and whole duration sign. Parts are summarized (as they can become repetitive due to addition, etc). Zero parts are removed as not significant.",
    "label": "",
    "id": "3426"
  },
  {
    "raw_code": "def initialize_dup(orig) # :nodoc:\n        %w(plurals singulars uncountables humans acronyms).each do |scope|\n          instance_variable_set(\"@#{scope}\", orig.public_send(scope).dup)\n        end",
    "comment": "Private, for the test suite.",
    "label": "",
    "id": "3427"
  },
  {
    "raw_code": "def acronym(word)\n        @acronyms[word.downcase] = word\n        define_acronym_regex_patterns\n      end",
    "comment": "Specifies a new acronym. An acronym must be specified as it will appear in a camelized string. An underscore string that contains the acronym will retain the acronym when passed to +camelize+, +humanize+, or +titleize+. A camelized string that contains the acronym will maintain the acronym when titleized or humanized, and will convert the acronym into a non-delimited single lowercase word when passed to +underscore+.  acronym 'HTML' titleize 'html'     # => 'HTML' camelize 'html'     # => 'HTML' underscore 'MyHTML' # => 'my_html'  The acronym, however, must occur as a delimited unit and not be part of another word for conversions to recognize it:  acronym 'HTTP' camelize 'my_http_delimited' # => 'MyHTTPDelimited' camelize 'https'             # => 'Https', not 'HTTPs' underscore 'HTTPS'           # => 'http_s', not 'https'  acronym 'HTTPS' camelize 'https'   # => 'HTTPS' underscore 'HTTPS' # => 'https'  Note: Acronyms that are passed to +pluralize+ will no longer be recognized, since the acronym will not occur as a delimited unit in the pluralized result. To work around this, you must specify the pluralized form as an acronym as well:  acronym 'API' camelize(pluralize('api')) # => 'Apis'  acronym 'APIs' camelize(pluralize('api')) # => 'APIs'  +acronym+ may be used to specify any word that contains an acronym or otherwise needs to maintain a non-standard capitalization. The only restriction is that the word must begin with a capital letter.  acronym 'RESTful' underscore 'RESTful'           # => 'restful' underscore 'RESTfulController' # => 'restful_controller' titleize 'RESTfulController'   # => 'RESTful Controller' camelize 'restful'             # => 'RESTful' camelize 'restful_controller'  # => 'RESTfulController'  acronym 'McDonald' underscore 'McDonald' # => 'mcdonald' camelize 'mcdonald'   # => 'McDonald'",
    "label": "",
    "id": "3428"
  },
  {
    "raw_code": "def plural(rule, replacement)\n        @uncountables.delete(rule) if rule.is_a?(String)\n        @uncountables.delete(replacement)\n        @plurals.prepend([rule, replacement])\n      end",
    "comment": "Specifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression. The replacement should always be a string that may include references to the matched data from the rule.",
    "label": "",
    "id": "3429"
  },
  {
    "raw_code": "def singular(rule, replacement)\n        @uncountables.delete(rule) if rule.is_a?(String)\n        @uncountables.delete(replacement)\n        @singulars.prepend([rule, replacement])\n      end",
    "comment": "Specifies a new singularization rule and its replacement. The rule can either be a string or a regular expression. The replacement should always be a string that may include references to the matched data from the rule.",
    "label": "",
    "id": "3430"
  },
  {
    "raw_code": "def irregular(singular, plural)\n        @uncountables.delete(singular)\n        @uncountables.delete(plural)\n\n        s0 = singular[0]\n        srest = singular[1..-1]\n\n        p0 = plural[0]\n        prest = plural[1..-1]\n\n        if s0.upcase == p0.upcase\n          plural(/(#{s0})#{srest}$/i, '\\1' + prest)\n          plural(/(#{p0})#{prest}$/i, '\\1' + prest)\n\n          singular(/(#{s0})#{srest}$/i, '\\1' + srest)\n          singular(/(#{p0})#{prest}$/i, '\\1' + srest)\n        else\n          plural(/#{s0.upcase}(?i)#{srest}$/,   p0.upcase   + prest)\n          plural(/#{s0.downcase}(?i)#{srest}$/, p0.downcase + prest)\n          plural(/#{p0.upcase}(?i)#{prest}$/,   p0.upcase   + prest)\n          plural(/#{p0.downcase}(?i)#{prest}$/, p0.downcase + prest)\n\n          singular(/#{s0.upcase}(?i)#{srest}$/,   s0.upcase   + srest)\n          singular(/#{s0.downcase}(?i)#{srest}$/, s0.downcase + srest)\n          singular(/#{p0.upcase}(?i)#{prest}$/,   s0.upcase   + srest)\n          singular(/#{p0.downcase}(?i)#{prest}$/, s0.downcase + srest)\n        end",
    "comment": "Specifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used for strings, not regular expressions. You simply pass the irregular in singular and plural form.  irregular 'cactus', 'cacti' irregular 'person', 'people'",
    "label": "",
    "id": "3431"
  },
  {
    "raw_code": "def uncountable(*words)\n        @uncountables.add(words)\n      end",
    "comment": "Specifies words that are uncountable and should not be inflected.  uncountable 'money' uncountable 'money', 'information' uncountable %w( money information rice )",
    "label": "",
    "id": "3432"
  },
  {
    "raw_code": "def human(rule, replacement)\n        @humans.prepend([rule, replacement])\n      end",
    "comment": "Specifies a humanized form of a string by a regular expression rule or by a string mapping. When using a regular expression based replacement, the normal humanize formatting is called after the replacement. When a string is used, the human form should be specified as desired (example: 'The name', not 'the_name').  human /_cnt$/i, '\\1_count' human 'legacy_col_person_name', 'Name'",
    "label": "",
    "id": "3433"
  },
  {
    "raw_code": "def clear(scope = :all)\n        case scope\n        when :all\n          clear(:acronyms)\n          clear(:plurals)\n          clear(:singulars)\n          clear(:uncountables)\n          clear(:humans)\n        when :acronyms\n          @acronyms = {}\n          define_acronym_regex_patterns\n        when :uncountables\n          @uncountables = Uncountables.new\n        when :plurals, :singulars, :humans\n          instance_variable_set \"@#{scope}\", []\n        end",
    "comment": "Clears the loaded inflections within a given scope (default is <tt>:all</tt>). Give the scope as a symbol of the inflection type, the options are: <tt>:plurals</tt>, <tt>:singulars</tt>, <tt>:uncountables</tt>, <tt>:humans</tt>, <tt>:acronyms</tt>.  clear :all clear :plurals",
    "label": "",
    "id": "3434"
  },
  {
    "raw_code": "def inflections(locale = :en)\n      if block_given?\n        yield Inflections.instance(locale)\n      else\n        Inflections.instance_or_fallback(locale)\n      end",
    "comment": "Yields a singleton instance of Inflector::Inflections so you can specify additional inflector rules. If passed an optional locale, rules for other languages can be specified. If not specified, defaults to <tt>:en</tt>. Only rules for English are provided.  ActiveSupport::Inflector.inflections(:en) do |inflect| inflect.uncountable 'rails' end",
    "label": "",
    "id": "3435"
  },
  {
    "raw_code": "def pluralize(word, locale = :en)\n      apply_inflections(word, inflections(locale).plurals, locale)\n    end",
    "comment": "Returns the plural form of the word in the string.  If passed an optional +locale+ parameter, the word will be pluralized using rules defined for that language. By default, this parameter is set to <tt>:en</tt>.  pluralize('post')             # => \"posts\" pluralize('octopus')          # => \"octopi\" pluralize('sheep')            # => \"sheep\" pluralize('words')            # => \"words\" pluralize('CamelOctopus')     # => \"CamelOctopi\" pluralize('ley', :es)         # => \"leyes\"",
    "label": "",
    "id": "3436"
  },
  {
    "raw_code": "def singularize(word, locale = :en)\n      apply_inflections(word, inflections(locale).singulars, locale)\n    end",
    "comment": "The reverse of #pluralize, returns the singular form of a word in a string.  If passed an optional +locale+ parameter, the word will be singularized using rules defined for that language. By default, this parameter is set to <tt>:en</tt>.  singularize('posts')            # => \"post\" singularize('octopi')           # => \"octopus\" singularize('sheep')            # => \"sheep\" singularize('word')             # => \"word\" singularize('CamelOctopi')      # => \"CamelOctopus\" singularize('leyes', :es)       # => \"ley\"",
    "label": "",
    "id": "3437"
  },
  {
    "raw_code": "def camelize(term, uppercase_first_letter = true)\n      string = term.to_s\n      # String#camelize takes a symbol (:upper or :lower), so here we also support :lower to keep the methods consistent.\n      if !uppercase_first_letter || uppercase_first_letter == :lower\n        string = string.sub(inflections.acronyms_camelize_regex) { |match| match.downcase! || match }\n      elsif string.match?(/\\A[a-z\\d]*\\z/)\n        return inflections.acronyms[string]&.dup || string.capitalize\n      else\n        string = string.sub(/^[a-z\\d]*/) { |match| inflections.acronyms[match] || match.capitalize! || match }\n      end",
    "comment": "Converts strings to UpperCamelCase. If the +uppercase_first_letter+ parameter is set to false, then produces lowerCamelCase.  Also converts '/' to '::' which is useful for converting paths to namespaces.  camelize('active_model')                # => \"ActiveModel\" camelize('active_model', false)         # => \"activeModel\" camelize('active_model/errors')         # => \"ActiveModel::Errors\" camelize('active_model/errors', false)  # => \"activeModel::Errors\"  As a rule of thumb you can think of +camelize+ as the inverse of #underscore, though there are cases where that does not hold:  camelize(underscore('SSLError'))        # => \"SslError\"",
    "label": "",
    "id": "3438"
  },
  {
    "raw_code": "def underscore(camel_cased_word)\n      return camel_cased_word.to_s.dup unless /[A-Z-]|::/.match?(camel_cased_word)\n      word = camel_cased_word.to_s.gsub(\"::\", \"/\")\n      word.gsub!(inflections.acronyms_underscore_regex) { \"#{$1 && '_' }#{$2.downcase}\" }\n      word.gsub!(/(?<=[A-Z])(?=[A-Z][a-z])|(?<=[a-z\\d])(?=[A-Z])/, \"_\")\n      word.tr!(\"-\", \"_\")\n      word.downcase!\n      word\n    end",
    "comment": "Makes an underscored, lowercase form from the expression in the string.  Changes '::' to '/' to convert namespaces to paths.  underscore('ActiveModel')         # => \"active_model\" underscore('ActiveModel::Errors') # => \"active_model/errors\"  As a rule of thumb you can think of +underscore+ as the inverse of #camelize, though there are cases where that does not hold:  camelize(underscore('SSLError'))  # => \"SslError\"",
    "label": "",
    "id": "3439"
  },
  {
    "raw_code": "def humanize(lower_case_and_underscored_word, capitalize: true, keep_id_suffix: false)\n      result = lower_case_and_underscored_word.to_s.dup\n\n      inflections.humans.each { |(rule, replacement)| break if result.sub!(rule, replacement) }\n\n      result.tr!(\"_\", \" \")\n      result.lstrip!\n      if !keep_id_suffix && lower_case_and_underscored_word&.end_with?(\"_id\")\n        result.delete_suffix!(\" id\")\n      end",
    "comment": "Tweaks an attribute name for display to end users.  Specifically, performs these transformations:  * Applies human inflection rules to the argument. * Deletes leading underscores, if any. * Removes an \"_id\" suffix if present. * Replaces underscores with spaces, if any. * Downcases all words except acronyms. * Capitalizes the first word. The capitalization of the first word can be turned off by setting the +:capitalize+ option to false (default is true).  The trailing '_id' can be kept and capitalized by setting the optional parameter +keep_id_suffix+ to true (default is false).  humanize('employee_salary')                  # => \"Employee salary\" humanize('author_id')                        # => \"Author\" humanize('author_id', capitalize: false)     # => \"author\" humanize('_id')                              # => \"Id\" humanize('author_id', keep_id_suffix: true)  # => \"Author id\"  If \"SSL\" was defined to be an acronym:  humanize('ssl_error') # => \"SSL error\" ",
    "label": "",
    "id": "3440"
  },
  {
    "raw_code": "def upcase_first(string)\n      string.length > 0 ? string[0].upcase.concat(string[1..-1]) : +\"\"\n    end",
    "comment": "Converts the first character in the string to uppercase.  upcase_first('what a Lovely Day') # => \"What a Lovely Day\" upcase_first('w')                 # => \"W\" upcase_first('')                  # => \"\"",
    "label": "",
    "id": "3441"
  },
  {
    "raw_code": "def downcase_first(string)\n      string.length > 0 ? string[0].downcase.concat(string[1..-1]) : +\"\"\n    end",
    "comment": "Converts the first character in the string to lowercase.  downcase_first('If they enjoyed The Matrix') # => \"if they enjoyed The Matrix\" downcase_first('I')                          # => \"i\" downcase_first('')                           # => \"\"",
    "label": "",
    "id": "3442"
  },
  {
    "raw_code": "def titleize(word, keep_id_suffix: false)\n      humanize(underscore(word), keep_id_suffix: keep_id_suffix).gsub(/\\b(?<!\\w['’`()])[a-z]/) do |match|\n        match.capitalize\n      end",
    "comment": "Capitalizes all the words and replaces some characters in the string to create a nicer looking title. +titleize+ is meant for creating pretty output. It is not used in the \\Rails internals.  The trailing '_id','Id'.. can be kept and capitalized by setting the optional parameter +keep_id_suffix+ to true. By default, this parameter is false.  titleize('man from the boondocks')                       # => \"Man From The Boondocks\" titleize('x-men: the last stand')                        # => \"X Men: The Last Stand\" titleize('TheManWithoutAPast')                           # => \"The Man Without A Past\" titleize('raiders_of_the_lost_ark')                      # => \"Raiders Of The Lost Ark\" titleize('string_ending_with_id', keep_id_suffix: true)  # => \"String Ending With Id\"",
    "label": "",
    "id": "3443"
  },
  {
    "raw_code": "def tableize(class_name)\n      pluralize(underscore(class_name))\n    end",
    "comment": "Creates the name of a table like \\Rails does for models to table names. This method uses the #pluralize method on the last word in the string.  tableize('RawScaledScorer') # => \"raw_scaled_scorers\" tableize('ham_and_egg')     # => \"ham_and_eggs\" tableize('fancyCategory')   # => \"fancy_categories\"",
    "label": "",
    "id": "3444"
  },
  {
    "raw_code": "def classify(table_name)\n      # strip out any leading schema name\n      camelize(singularize(table_name.to_s.sub(/.*\\./, \"\")))\n    end",
    "comment": "Creates a class name from a plural table name like \\Rails does for table names to models. Note that this returns a string and not a Class. (To convert to an actual class follow +classify+ with #constantize.)  classify('ham_and_eggs') # => \"HamAndEgg\" classify('posts')        # => \"Post\"  Singular names are not handled correctly:  classify('calculus')     # => \"Calculu\"",
    "label": "",
    "id": "3445"
  },
  {
    "raw_code": "def dasherize(underscored_word)\n      underscored_word.tr(\"_\", \"-\")\n    end",
    "comment": "Replaces underscores with dashes in the string.  dasherize('puni_puni') # => \"puni-puni\"",
    "label": "",
    "id": "3446"
  },
  {
    "raw_code": "def demodulize(path)\n      path = path.to_s\n      if i = path.rindex(\"::\")\n        path[(i + 2), path.length]\n      else\n        path\n      end",
    "comment": "Removes the module part from the expression in the string.  demodulize('ActiveSupport::Inflector::Inflections') # => \"Inflections\" demodulize('Inflections')                           # => \"Inflections\" demodulize('::Inflections')                         # => \"Inflections\" demodulize('')                                      # => \"\"  See also #deconstantize.",
    "label": "",
    "id": "3447"
  },
  {
    "raw_code": "def deconstantize(path)\n      path.to_s[0, path.rindex(\"::\") || 0] # implementation based on the one in facets' Module#spacename\n    end",
    "comment": "Removes the rightmost segment from the constant expression in the string.  deconstantize('Net::HTTP')   # => \"Net\" deconstantize('::Net::HTTP') # => \"::Net\" deconstantize('String')      # => \"\" deconstantize('::String')    # => \"\" deconstantize('')            # => \"\"  See also #demodulize.",
    "label": "",
    "id": "3448"
  },
  {
    "raw_code": "def foreign_key(class_name, separate_class_name_and_id_with_underscore = true)\n      underscore(demodulize(class_name)) + (separate_class_name_and_id_with_underscore ? \"_id\" : \"id\")\n    end",
    "comment": "Creates a foreign key name from a class name. +separate_class_name_and_id_with_underscore+ sets whether the method should put '_' between the name and 'id'.  foreign_key('Message')        # => \"message_id\" foreign_key('Message', false) # => \"messageid\" foreign_key('Admin::Post')    # => \"post_id\"",
    "label": "",
    "id": "3449"
  },
  {
    "raw_code": "def constantize(camel_cased_word)\n      Object.const_get(camel_cased_word)\n    end",
    "comment": "Tries to find a constant with the name specified in the argument string.  constantize('Module')   # => Module constantize('Foo::Bar') # => Foo::Bar  The name is assumed to be the one of a top-level constant, no matter whether it starts with \"::\" or not. No lexical context is taken into account:  C = 'outside' module M C = 'inside' C                # => 'inside' constantize('C') # => 'outside', same as ::C end  NameError is raised when the name is not in CamelCase or the constant is unknown.",
    "label": "",
    "id": "3450"
  },
  {
    "raw_code": "def safe_constantize(camel_cased_word)\n      constantize(camel_cased_word)\n    rescue NameError => e\n      raise if e.name && !(camel_cased_word.to_s.split(\"::\").include?(e.name.to_s) ||\n        e.name.to_s == camel_cased_word.to_s)\n    rescue LoadError => e\n      message = e.respond_to?(:original_message) ? e.original_message : e.message\n      raise unless /Unable to autoload constant #{const_regexp(camel_cased_word)}/.match?(message)\n    end",
    "comment": "Tries to find a constant with the name specified in the argument string.  safe_constantize('Module')   # => Module safe_constantize('Foo::Bar') # => Foo::Bar  The name is assumed to be the one of a top-level constant, no matter whether it starts with \"::\" or not. No lexical context is taken into account:  C = 'outside' module M C = 'inside' C                     # => 'inside' safe_constantize('C') # => 'outside', same as ::C end  +nil+ is returned when the name is not in CamelCase or the constant (or part of it) is unknown.  safe_constantize('blargle')                  # => nil safe_constantize('UnknownModule')            # => nil safe_constantize('UnknownModule::Foo::Bar')  # => nil",
    "label": "",
    "id": "3451"
  },
  {
    "raw_code": "def ordinal(number)\n      I18n.translate(\"number.nth.ordinals\", number: number)\n    end",
    "comment": "Returns the suffix that should be added to a number to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.  ordinal(1)     # => \"st\" ordinal(2)     # => \"nd\" ordinal(1002)  # => \"nd\" ordinal(1003)  # => \"rd\" ordinal(-11)   # => \"th\" ordinal(-1021) # => \"st\"",
    "label": "",
    "id": "3452"
  },
  {
    "raw_code": "def ordinalize(number)\n      I18n.translate(\"number.nth.ordinalized\", number: number)\n    end",
    "comment": "Turns a number into an ordinal string used to denote the position in an ordered sequence such as 1st, 2nd, 3rd, 4th.  ordinalize(1)     # => \"1st\" ordinalize(2)     # => \"2nd\" ordinalize(1002)  # => \"1002nd\" ordinalize(1003)  # => \"1003rd\" ordinalize(-11)   # => \"-11th\" ordinalize(-1021) # => \"-1021st\"",
    "label": "",
    "id": "3453"
  },
  {
    "raw_code": "def const_regexp(camel_cased_word)\n        parts = camel_cased_word.split(\"::\")\n\n        return Regexp.escape(camel_cased_word) if parts.empty?\n\n        last = parts.pop\n\n        parts.reverse!.inject(last) do |acc, part|\n          part.empty? ? acc : \"#{part}(::#{acc})?\"\n        end",
    "comment": "Mounts a regular expression, returned as a string to ease interpolation, that will match part by part the given constant.  const_regexp(\"Foo::Bar::Baz\") # => \"Foo(::Bar(::Baz)?)?\" const_regexp(\"::\")            # => \"::\"",
    "label": "",
    "id": "3454"
  },
  {
    "raw_code": "def apply_inflections(word, rules, locale = :en)\n        result = word.to_s.dup\n\n        if word.empty? || inflections(locale).uncountables.uncountable?(result)\n          result\n        else\n          rules.each { |(rule, replacement)| break if result.sub!(rule, replacement) }\n          result\n        end",
    "comment": "Applies inflection rules for +singularize+ and +pluralize+.  If passed an optional +locale+ parameter, the uncountables will be found for that locale.  apply_inflections('post', inflections.plurals, :en)    # => \"posts\" apply_inflections('posts', inflections.singulars, :en) # => \"post\"",
    "label": "",
    "id": "3455"
  },
  {
    "raw_code": "def transliterate(string, replacement = \"?\", locale: nil)\n      raise ArgumentError, \"Can only transliterate strings. Received #{string.class.name}\" unless string.is_a?(String)\n      raise ArgumentError, \"Cannot transliterate strings with #{string.encoding} encoding\" unless ALLOWED_ENCODINGS_FOR_TRANSLITERATE.include?(string.encoding)\n\n      return string.dup if string.ascii_only?\n      string = string.dup if string.frozen?\n\n      input_encoding = string.encoding\n\n      # US-ASCII is a subset of UTF-8 so we'll force encoding as UTF-8 if\n      # US-ASCII is given. This way we can let tidy_bytes handle the string\n      # in the same way as we do for UTF-8\n      string.force_encoding(Encoding::UTF_8) if string.encoding == Encoding::US_ASCII\n\n      # GB18030 is Unicode compatible but is not a direct mapping so needs to be\n      # transcoded. Using invalid/undef :replace will result in loss of data in\n      # the event of invalid characters, but since tidy_bytes will replace\n      # invalid/undef with a \"?\" we're safe to do the same beforehand\n      string.encode!(Encoding::UTF_8, invalid: :replace, undef: :replace) if string.encoding == Encoding::GB18030\n\n      transliterated = I18n.transliterate(\n        ActiveSupport::Multibyte::Unicode.tidy_bytes(string).unicode_normalize(:nfc),\n        replacement: replacement,\n        locale: locale\n      )\n\n      # Restore the string encoding of the input if it was not UTF-8.\n      # Apply invalid/undef :replace as tidy_bytes does\n      transliterated.encode!(input_encoding, invalid: :replace, undef: :replace) if input_encoding != transliterated.encoding\n\n      transliterated\n    end",
    "comment": "Replaces non-ASCII characters with an ASCII approximation, or if none exists, a replacement character which defaults to \"?\".  transliterate('Ærøskøbing') # => \"AEroskobing\"  Default approximations are provided for Western/Latin characters, e.g, \"ø\", \"ñ\", \"é\", \"ß\", etc.  This method is I18n aware, so you can set up custom approximations for a locale. This can be useful, for example, to transliterate German's \"ü\" and \"ö\" to \"ue\" and \"oe\", or to add support for transliterating Russian to ASCII.  In order to make your custom transliterations available, you must set them as the <tt>i18n.transliterate.rule</tt> i18n key:  # Store the transliterations in locales/de.yml i18n: transliterate: rule: ü: \"ue\" ö: \"oe\"  # Or set them using Ruby I18n.backend.store_translations(:de, i18n: { transliterate: { rule: { 'ü' => 'ue', 'ö' => 'oe' } } })  The value for <tt>i18n.transliterate.rule</tt> can be a simple Hash that maps characters to ASCII approximations as shown above, or, for more complex requirements, a Proc:  I18n.backend.store_translations(:de, i18n: { transliterate: { rule: ->(string) { MyTransliterator.transliterate(string) } } })  Now you can have different transliterations for each locale:  transliterate('Jürgen', locale: :en) # => \"Jurgen\"  transliterate('Jürgen', locale: :de) # => \"Juergen\"  Transliteration is restricted to UTF-8, US-ASCII, and GB18030 strings. Other encodings will raise an ArgumentError.",
    "label": "",
    "id": "3456"
  },
  {
    "raw_code": "def parameterize(string, separator: \"-\", preserve_case: false, locale: nil)\n      # Replace accented chars with their ASCII equivalents.\n      parameterized_string = transliterate(string, locale: locale)\n\n      # Turn unwanted chars into the separator.\n      parameterized_string.gsub!(/[^a-z0-9\\-_]+/i, separator)\n\n      unless separator.nil? || separator.empty?\n        # No more than one of the separator in a row.\n        if separator.length == 1\n          parameterized_string.squeeze!(separator)\n        else\n          re_sep = Regexp.escape(separator)\n          parameterized_string.gsub!(/#{re_sep}{2,}/, separator)\n        end",
    "comment": "Replaces special characters in a string so that it may be used as part of a 'pretty' URL.  parameterize(\"Donald E. Knuth\") # => \"donald-e-knuth\" parameterize(\"^très|Jolie-- \")  # => \"tres-jolie\"  To use a custom separator, override the +separator+ argument.  parameterize(\"Donald E. Knuth\", separator: '_') # => \"donald_e_knuth\" parameterize(\"^très|Jolie__ \", separator: '_')  # => \"tres_jolie\"  To preserve the case of the characters in a string, use the +preserve_case+ argument.  parameterize(\"Donald E. Knuth\", preserve_case: true) # => \"Donald-E-Knuth\" parameterize(\"^très|Jolie-- \", preserve_case: true) # => \"tres-Jolie\"  It preserves dashes and underscores unless they are used as separators:  parameterize(\"^très|Jolie__ \")                 # => \"tres-jolie__\" parameterize(\"^très|Jolie-- \", separator: \"_\") # => \"tres_jolie--\" parameterize(\"^très_Jolie-- \", separator: \".\") # => \"tres_jolie--\"  If the optional parameter +locale+ is specified, the word will be parameterized as a word of that language. By default, this parameter is set to <tt>nil</tt> and it will use the configured <tt>I18n.locale</tt>.",
    "label": "",
    "id": "3457"
  },
  {
    "raw_code": "def decode(json, options = {})\n        data = ::JSON.parse(json, options)\n\n        if ActiveSupport.parse_json_times\n          convert_dates_from(data)\n        else\n          data\n        end",
    "comment": "Parses a JSON string (JavaScript Object Notation) into a Ruby object. See http://www.json.org for more info.  ActiveSupport::JSON.decode(\"{\\\"team\\\":\\\"rails\\\",\\\"players\\\":\\\"36\\\"}\") # => {\"team\" => \"rails\", \"players\" => \"36\"} ActiveSupport::JSON.decode(\"2.39\") # => 2.39",
    "label": "",
    "id": "3458"
  },
  {
    "raw_code": "def parse_error\n        ::JSON::ParserError\n      end",
    "comment": "Returns the class of the error that will be raised when there is an error in decoding JSON. Using this method means you won't directly depend on the ActiveSupport's JSON implementation, in case it changes in the future.  begin obj = ActiveSupport::JSON.decode(some_string) rescue ActiveSupport::JSON.parse_error Rails.logger.warn(\"Attempted to decode invalid JSON: #{some_string}\") end",
    "label": "",
    "id": "3459"
  },
  {
    "raw_code": "def encode(value, options = nil)\n        if options.nil? || options.empty?\n          Encoding.encode_without_options(value)\n        elsif options == { escape: false }.freeze\n          Encoding.encode_without_escape(value)\n        else\n          Encoding.json_encoder.new(options).encode(value)\n        end",
    "comment": "Dumps objects in JSON (JavaScript Object Notation). See http://www.json.org for more info.  ActiveSupport::JSON.encode({ team: 'rails', players: '36' }) # => \"{\\\"team\\\":\\\"rails\\\",\\\"players\\\":\\\"36\\\"}\"  By default, it generates JSON that is safe to include in JavaScript, as it escapes U+2028 (Line Separator) and U+2029 (Paragraph Separator):  ActiveSupport::JSON.encode({ key: \"\\u2028\" }) # => \"{\\\"key\\\":\\\"\\\\u2028\\\"}\"  By default, it also generates JSON that is safe to include in HTML, as it escapes <tt><</tt>, <tt>></tt>, and <tt>&</tt>:  ActiveSupport::JSON.encode({ key: \"<>&\" }) # => \"{\\\"key\\\":\\\"\\\\u003c\\\\u003e\\\\u0026\\\"}\"  This behavior can be changed with the +escape_html_entities+ option, or the global escape_html_entities_in_json configuration option.  ActiveSupport::JSON.encode({ key: \"<>&\" }, escape_html_entities: false) # => \"{\\\"key\\\":\\\"<>&\\\"}\"  For performance reasons, you can set the +escape+ option to false, which will skip all escaping:  ActiveSupport::JSON.encode({ key: \"\\u2028<>&\" }, escape: false) # => \"{\\\"key\\\":\\\"\\u2028<>&\\\"}\"",
    "label": "",
    "id": "3460"
  },
  {
    "raw_code": "def encode(value)\n          unless options.empty?\n            value = value.as_json(options.dup.freeze)\n          end",
    "comment": "Encode the given object into a JSON string",
    "label": "",
    "id": "3461"
  },
  {
    "raw_code": "def jsonify(value)\n            case value\n            when String, Integer, Symbol, nil, true, false\n              value\n            when Numeric\n              value.as_json\n            when Hash\n              result = {}\n              value.each do |k, v|\n                k = k.to_s unless Symbol === k || String === k\n                result[k] = jsonify(v)\n              end",
    "comment": "Convert an object into a \"JSON-ready\" representation composed of primitives like Hash, Array, String, Symbol, Numeric, and +true+/+false+/+nil+. Recursively calls #as_json to the object to recursively build a fully JSON-ready object.  This allows developers to implement #as_json without having to worry about what base types of objects they are allowed to return or having to remember to call #as_json recursively.  Note: the +options+ hash passed to +object.to_json+ is only passed to +object.as_json+, not any of this method's recursive +#as_json+ calls.",
    "label": "",
    "id": "3462"
  },
  {
    "raw_code": "def stringify(jsonified)\n            ::JSON.generate(jsonified)\n          end",
    "comment": "Encode a \"jsonified\" Ruby data structure using the JSON gem",
    "label": "",
    "id": "3463"
  },
  {
    "raw_code": "def encode(value)\n            value = value.as_json(@options) unless @options.empty?\n\n            json = CODER.dump(value)\n\n            return json unless @escape\n\n            json.force_encoding(::Encoding::BINARY)\n            if @options.fetch(:escape_html_entities, Encoding.escape_html_entities_in_json)\n              if Encoding.escape_js_separators_in_json\n                json.gsub!(FULL_ESCAPE_REGEX, ESCAPED_CHARS)\n              else\n                json.gsub!(HTML_ENTITIES_REGEX, ESCAPED_CHARS)\n              end",
    "comment": "Encode the given object into a JSON string",
    "label": "",
    "id": "3464"
  },
  {
    "raw_code": "def wait\n        @notifier.wait\n      end",
    "comment": "Wait notifications to be published.",
    "label": "",
    "id": "3465"
  },
  {
    "raw_code": "def set_logger(logger)\n        ActiveSupport::LogSubscriber.logger = logger\n      end",
    "comment": "Overwrite if you use another logger in your log subscriber.  def logger ActiveRecord::Base.logger = @logger end",
    "label": "",
    "id": "3466"
  },
  {
    "raw_code": "def initialize(string, deprecation: true)\n        if deprecation\n          ActiveSupport.deprecator.warn(\n            \"ActiveSupport::Multibyte::Chars is deprecated and will be removed in Rails 8.2. \" \\\n            \"Use normal string methods instead.\"\n          )\n        end",
    "comment": "Creates a new Chars instance by wrapping _string_.",
    "label": "",
    "id": "3467"
  },
  {
    "raw_code": "def method_missing(method, ...)\n        result = @wrapped_string.__send__(method, ...)\n        if method.end_with?(\"!\")\n          self if result\n        else\n          result.kind_of?(String) ? chars(result) : result\n        end",
    "comment": "Forward all undefined methods to the wrapped string.",
    "label": "",
    "id": "3468"
  },
  {
    "raw_code": "def respond_to_missing?(method, include_private)\n        @wrapped_string.respond_to?(method, include_private)\n      end",
    "comment": "Returns +true+ if _obj_ responds to the given method. Private methods are included in the search only if the optional second parameter evaluates to +true+.",
    "label": "",
    "id": "3469"
  },
  {
    "raw_code": "def split(*args)\n        @wrapped_string.split(*args).map { |i| self.class.new(i) }\n      end",
    "comment": "Works just like <tt>String#split</tt>, with the exception that the items in the resulting list are Chars instances instead of String. This makes chaining methods easier.  'Café périferôl'.mb_chars.split(/é/).map { |part| part.upcase.to_s } # => [\"CAF\", \" P\", \"RIFERÔL\"]",
    "label": "",
    "id": "3470"
  },
  {
    "raw_code": "def slice!(*args)\n        string_sliced = @wrapped_string.slice!(*args)\n        if string_sliced\n          chars(string_sliced)\n        end",
    "comment": "Works like <tt>String#slice!</tt>, but returns an instance of Chars, or +nil+ if the string was not modified. The string will not be modified if the range given is out of bounds  string = 'Welcome' string.mb_chars.slice!(3)    # => #<ActiveSupport::Multibyte::Chars:0x000000038109b8 @wrapped_string=\"c\"> string # => 'Welome' string.mb_chars.slice!(0..3) # => #<ActiveSupport::Multibyte::Chars:0x00000002eb80a0 @wrapped_string=\"Welo\"> string # => 'me'",
    "label": "",
    "id": "3471"
  },
  {
    "raw_code": "def reverse\n        chars(@wrapped_string.grapheme_clusters.reverse.join)\n      end",
    "comment": "Reverses all characters in the string.  'Café'.mb_chars.reverse.to_s # => 'éfaC'",
    "label": "",
    "id": "3472"
  },
  {
    "raw_code": "def limit(limit)\n        chars(@wrapped_string.truncate_bytes(limit, omission: nil))\n      end",
    "comment": "Limits the byte size of the string to a number of bytes without breaking characters. Usable when the storage for a string is limited for some reason.  'こんにちは'.mb_chars.limit(7).to_s # => \"こん\"",
    "label": "",
    "id": "3473"
  },
  {
    "raw_code": "def titleize\n        chars(downcase.to_s.gsub(/\\b('?\\S)/u) { $1.upcase })\n      end",
    "comment": "Capitalizes the first letter of every word, when possible.  \"ÉL QUE SE ENTERÓ\".mb_chars.titleize.to_s    # => \"Él Que Se Enteró\" \"日本語\".mb_chars.titleize.to_s               # => \"日本語\"",
    "label": "",
    "id": "3474"
  },
  {
    "raw_code": "def decompose\n        chars(Unicode.decompose(:canonical, @wrapped_string.codepoints.to_a).pack(\"U*\"))\n      end",
    "comment": "Performs canonical decomposition on all the characters.  'é'.length                         # => 1 'é'.mb_chars.decompose.to_s.length # => 2",
    "label": "",
    "id": "3475"
  },
  {
    "raw_code": "def compose\n        chars(Unicode.compose(@wrapped_string.codepoints.to_a).pack(\"U*\"))\n      end",
    "comment": "Performs composition on all the characters.  'é'.length                       # => 1 'é'.mb_chars.compose.to_s.length # => 1",
    "label": "",
    "id": "3476"
  },
  {
    "raw_code": "def grapheme_length\n        @wrapped_string.grapheme_clusters.length\n      end",
    "comment": "Returns the number of grapheme clusters in the string.  'क्षि'.mb_chars.length   # => 4 'क्षि'.mb_chars.grapheme_length # => 2",
    "label": "",
    "id": "3477"
  },
  {
    "raw_code": "def tidy_bytes(force = false)\n        chars(Unicode.tidy_bytes(@wrapped_string, force))\n      end",
    "comment": "Replaces all ISO-8859-1 or CP1252 characters by their UTF-8 equivalent resulting in a valid UTF-8 string.  Passing +true+ will forcibly tidy all bytes, assuming that the string's encoding is entirely CP1252 or ISO-8859-1.",
    "label": "",
    "id": "3478"
  },
  {
    "raw_code": "def decompose(type, codepoints)\n        if type == :compatibility\n          codepoints.pack(\"U*\").unicode_normalize(:nfkd).codepoints\n        else\n          codepoints.pack(\"U*\").unicode_normalize(:nfd).codepoints\n        end",
    "comment": "Decompose composed characters to the decomposed form.",
    "label": "",
    "id": "3479"
  },
  {
    "raw_code": "def compose(codepoints)\n        codepoints.pack(\"U*\").unicode_normalize(:nfc).codepoints\n      end",
    "comment": "Compose decomposed characters to the composed form.",
    "label": "",
    "id": "3480"
  },
  {
    "raw_code": "def tidy_bytes(string, force = false)\n        return string if string.empty? || string.ascii_only?\n        return recode_windows1252_chars(string) if force\n        string.scrub { |bad| recode_windows1252_chars(bad) }\n      end",
    "comment": "Replaces all ISO-8859-1 or CP1252 characters by their UTF-8 equivalent resulting in a valid UTF-8 string.  Passing +true+ will forcibly tidy all bytes, assuming that the string's encoding is entirely CP1252 or ISO-8859-1.",
    "label": "",
    "id": "3481"
  },
  {
    "raw_code": "def wait\n      end",
    "comment": "This is a sync queue, so there is no waiting.",
    "label": "",
    "id": "3482"
  },
  {
    "raw_code": "def instrument(name, payload = {})\n        handle = build_handle(name, payload)\n        handle.start\n        begin\n          yield payload if block_given?\n        rescue Exception => e\n          payload[:exception] = [e.class.name, e.message]\n          payload[:exception_object] = e\n          raise e\n        ensure\n          handle.finish\n        end",
    "comment": "Given a block, instrument it by measuring the time taken to execute and publish it. Without a block, simply send a message via the notifier. Notice that events get sent even if an error occurs in the passed-in block.",
    "label": "",
    "id": "3483"
  },
  {
    "raw_code": "def build_handle(name, payload)\n        @notifier.build_handle(name, @id, payload)\n      end",
    "comment": "Returns a \"handle\" for an event with the given +name+ and +payload+.  #start and #finish must each be called exactly once on the returned object.  Where possible, it's best to use #instrument, which will record the start and finish of the event and correctly handle any exceptions. +build_handle+ is a low-level API intended for cases where using +instrument+ isn't possible.  See ActiveSupport::Notifications::Fanout::Handle.",
    "label": "",
    "id": "3484"
  },
  {
    "raw_code": "def start(name, payload)\n        @notifier.start name, @id, payload\n      end",
    "comment": "Send a start notification with +name+ and +payload+.",
    "label": "",
    "id": "3485"
  },
  {
    "raw_code": "def finish(name, payload)\n        @notifier.finish name, @id, payload\n      end",
    "comment": "Send a finish notification with +name+ and +payload+.",
    "label": "",
    "id": "3486"
  },
  {
    "raw_code": "def start!\n        @time = now\n        @cpu_time_start = now_cpu\n        @gc_time_start = now_gc\n        @allocation_count_start = now_allocations\n      end",
    "comment": "Record information at the time this event starts",
    "label": "",
    "id": "3487"
  },
  {
    "raw_code": "def finish!\n        @cpu_time_finish = now_cpu\n        @gc_time_finish = now_gc\n        @end = now\n        @allocation_count_finish = now_allocations\n      end",
    "comment": "Record information at the time this event finishes",
    "label": "",
    "id": "3488"
  },
  {
    "raw_code": "def cpu_time\n        @cpu_time_finish - @cpu_time_start\n      end",
    "comment": "Returns the CPU time (in milliseconds) passed between the call to #start! and the call to #finish!.",
    "label": "",
    "id": "3489"
  },
  {
    "raw_code": "def idle_time\n        diff = duration - cpu_time\n        diff > 0.0 ? diff : 0.0\n      end",
    "comment": "Returns the idle time time (in milliseconds) passed between the call to #start! and the call to #finish!.",
    "label": "",
    "id": "3490"
  },
  {
    "raw_code": "def allocations\n        @allocation_count_finish - @allocation_count_start\n      end",
    "comment": "Returns the number of allocations made between the call to #start! and the call to #finish!.",
    "label": "",
    "id": "3491"
  },
  {
    "raw_code": "def gc_time\n        (@gc_time_finish - @gc_time_start) / 1_000_000.0\n      end",
    "comment": "Returns the time spent in GC (in milliseconds) between the call to #start! and the call to #finish!",
    "label": "",
    "id": "3492"
  },
  {
    "raw_code": "def duration\n        @end - @time\n      end",
    "comment": "Returns the difference in milliseconds between when the execution of the event started and when it ended.  ActiveSupport::Notifications.subscribe('wait') do |event| @event = event end  ActiveSupport::Notifications.instrument('wait') do sleep 1 end  @event.duration # => 1000.138",
    "label": "",
    "id": "3493"
  },
  {
    "raw_code": "def assert_not(object, message = nil)\n        message ||= -> { \"Expected #{mu_pp(object)} to be nil or false\" }\n        assert !object, message\n      end",
    "comment": "Asserts that an expression is not truthy. Passes if +object+ is +nil+ or +false+. \"Truthy\" means \"considered true in a conditional\" like <tt>if foo</tt>.  assert_not nil    # => true assert_not false  # => true assert_not 'foo'  # => Expected \"foo\" to be nil or false  An error message can be specified.  assert_not foo, 'foo should be false'",
    "label": "",
    "id": "3494"
  },
  {
    "raw_code": "def assert_raises(*exp, match: nil, &block)\n        error = super(*exp, &block)\n        assert_match(match, error.message) if match\n        error\n      end",
    "comment": "Asserts that a block raises one of +exp+. This is an enhancement of the standard Minitest assertion method with the ability to test error messages.  assert_raises(ArgumentError, match: /incorrect param/i) do perform_service(param: 'exception') end ",
    "label": "",
    "id": "3495"
  },
  {
    "raw_code": "def assert_nothing_raised\n        yield.tap { assert(true) }\n      rescue => error\n        raise Minitest::UnexpectedError.new(error)\n      end",
    "comment": "Assertion that the block should not raise an exception.  Passes if evaluated code in the yielded block raises no exception.  assert_nothing_raised do perform_service(param: 'no_exception') end",
    "label": "",
    "id": "3496"
  },
  {
    "raw_code": "def assert_difference(expression, *args, &block)\n        expressions =\n          if expression.is_a?(Hash)\n            message = args[0]\n            expression\n          else\n            difference = args[0] || 1\n            message = args[1]\n            Array(expression).index_with(difference)\n          end",
    "comment": "Test numeric difference between the return value of an expression as a result of what is evaluated in the yielded block.  assert_difference 'Article.count' do post :create, params: { article: {...} } end  An arbitrary expression is passed in and evaluated.  assert_difference 'Article.last.comments(:reload).size' do post :create, params: { comment: {...} } end  An arbitrary positive or negative difference can be specified. The default is +1+.  assert_difference 'Article.count', -1 do post :delete, params: { id: ... } end  An array of expressions can be passed in and evaluated.  assert_difference [ 'Article.count', 'Post.count' ], 2 do post :create, params: { article: {...} } end  A hash of expressions/numeric differences can be passed in and evaluated.  assert_difference({ 'Article.count' => 1, 'Notification.count' => 2 }) do post :create, params: { article: {...} } end  A lambda, a list of lambdas or a hash of lambdas/numeric differences can be passed in and evaluated:  assert_difference ->{ Article.count }, 2 do post :create, params: { article: {...} } end  assert_difference [->{ Article.count }, ->{ Post.count }], 2 do post :create, params: { article: {...} } end  assert_difference ->{ Article.count } => 1, ->{ Notification.count } => 2 do post :create, params: { article: {...} } end  An error message can be specified.  assert_difference 'Article.count', -1, 'An Article should be destroyed' do post :delete, params: { id: ... } end",
    "label": "",
    "id": "3497"
  },
  {
    "raw_code": "def assert_no_difference(expression, message = nil, &block)\n        assert_difference expression, 0, message, &block\n      end",
    "comment": "Assertion that the numeric result of evaluating an expression is not changed before and after invoking the passed in block.  assert_no_difference 'Article.count' do post :create, params: { article: invalid_attributes } end  A lambda can be passed in and evaluated.  assert_no_difference -> { Article.count } do post :create, params: { article: invalid_attributes } end  An error message can be specified.  assert_no_difference 'Article.count', 'An Article should not be created' do post :create, params: { article: invalid_attributes } end  An array of expressions can also be passed in and evaluated.  assert_no_difference [ 'Article.count', -> { Post.count } ] do post :create, params: { article: invalid_attributes } end",
    "label": "",
    "id": "3498"
  },
  {
    "raw_code": "def assert_changes(expression, message = nil, from: UNTRACKED, to: UNTRACKED, &block)\n        exp = expression.respond_to?(:call) ? expression : -> { eval(expression.to_s, block.binding) }\n\n        before = exp.call\n        retval = _assert_nothing_raised_or_warn(\"assert_changes\", &block)\n\n        unless from == UNTRACKED\n          rich_message = -> do\n            error = \"Expected change from #{from.inspect}, got #{before.inspect}\"\n            error = \"#{message}.\\n#{error}\" if message\n            error\n          end",
    "comment": "Assertion that the result of evaluating an expression is changed before and after invoking the passed in block.  assert_changes 'Status.all_good?' do post :create, params: { status: { ok: false } } end  You can pass the block as a string to be evaluated in the context of the block. A lambda can be passed for the block as well.  assert_changes -> { Status.all_good? } do post :create, params: { status: { ok: false } } end  The assertion is useful to test side effects. The passed block can be anything that can be converted to string with #to_s.  assert_changes :@object do @object = 42 end  The keyword arguments +:from+ and +:to+ can be given to specify the expected initial value and the expected value after the block was executed. The comparison is done using case equality (===), which means you can specify patterns or classes:  # Exact value match assert_changes :@object, from: nil, to: :foo do @object = :foo end  # Case equality assert_changes -> { user.token }, to: /\\w{32}/ do user.generate_token end  # Type check assert_changes -> { current_error }, from: nil, to: RuntimeError do raise \"Oops\" end  An error message can be specified.  assert_changes -> { Status.all_good? }, 'Expected the status to be bad' do post :create, params: { status: { incident: true } } end",
    "label": "",
    "id": "3499"
  },
  {
    "raw_code": "def assert_no_changes(expression, message = nil, from: UNTRACKED, &block)\n        exp = expression.respond_to?(:call) ? expression : -> { eval(expression.to_s, block.binding) }\n\n        before = exp.call\n        retval = _assert_nothing_raised_or_warn(\"assert_no_changes\", &block)\n\n        unless from == UNTRACKED\n          rich_message = -> do\n            error = \"Expected initial value of #{from.inspect}, got #{before.inspect}\"\n            error = \"#{message}.\\n#{error}\" if message\n            error\n          end",
    "comment": "Assertion that the result of evaluating an expression is not changed before and after invoking the passed in block.  assert_no_changes 'Status.all_good?' do post :create, params: { status: { ok: true } } end  Provide the optional keyword argument +:from+ to specify the expected initial value. The comparison is done using case equality (===), which means you can specify patterns or classes:  # Exact value match assert_no_changes -> { Status.all_good? }, from: true do post :create, params: { status: { ok: true } } end  # Case equality assert_no_changes -> { user.token }, from: /\\w{32}/ do user.touch end  # Type check assert_no_changes -> { current_error }, from: RuntimeError do retry_operation end  An error message can be specified.  assert_no_changes -> { Status.all_good? }, 'Expected the status to be good' do post :create, params: { status: { ok: false } } end",
    "label": "",
    "id": "3500"
  },
  {
    "raw_code": "def stub_const(mod, constant, new_value, exists: true)\n        if exists\n          begin\n            old_value = mod.const_get(constant, false)\n            mod.send(:remove_const, constant)\n            mod.const_set(constant, new_value)\n            yield\n          ensure\n            mod.send(:remove_const, constant)\n            mod.const_set(constant, old_value)\n          end",
    "comment": "Changes the value of a constant for the duration of a block. Example:  # World::List::Import::LARGE_IMPORT_THRESHOLD = 5000 stub_const(World::List::Import, :LARGE_IMPORT_THRESHOLD, 1) do assert_equal 1, World::List::Import::LARGE_IMPORT_THRESHOLD end  assert_equal 5000, World::List::Import::LARGE_IMPORT_THRESHOLD  Using this method rather than forcing <tt>World::List::Import::LARGE_IMPORT_THRESHOLD = 5000</tt> prevents warnings from being thrown, and ensures that the old value is returned after the test has completed.  If the constant doesn't already exists, but you need it set for the duration of the block you can do so by passing `exists: false`.  stub_const(object, :SOME_CONST, 1, exists: false) do assert_equal 1, SOME_CONST end  Note: Stubbing a const will stub it across all threads. So if you have concurrent threads (like separate test suites running in parallel) that all depend on the same constant, it's possible divergent stubbing will trample on each other.",
    "label": "",
    "id": "3501"
  },
  {
    "raw_code": "def test(name, &block)\n          test_name = \"test_#{name.gsub(/\\s+/, '_')}\".to_sym\n          defined = method_defined? test_name\n          raise \"#{test_name} is already defined in #{self}\" if defined\n          if block_given?\n            define_method(test_name, &block)\n          else\n            define_method(test_name) do\n              flunk \"No implementation provided for #{name}\"\n            end",
    "comment": "Helper to define a test method using a String. Under the hood, it replaces spaces with underscores and defines the test method.  test \"verify something\" do ... end",
    "label": "",
    "id": "3502"
  },
  {
    "raw_code": "def assert_deprecated(match = nil, deprecator = nil, &block)\n        match, deprecator = nil, match if match.is_a?(ActiveSupport::Deprecation)\n\n        unless deprecator\n          raise ArgumentError, \"No deprecator given\"\n        end",
    "comment": " :call-seq: assert_deprecated(deprecator, &block) assert_deprecated(match, deprecator, &block)  Asserts that a matching deprecation warning was emitted by the given deprecator during the execution of the yielded block.  assert_deprecated(/foo/, CustomDeprecator) do CustomDeprecator.warn \"foo should no longer be used\" end  The +match+ object may be a +Regexp+, or +String+ appearing in the message.  assert_deprecated('foo', CustomDeprecator) do CustomDeprecator.warn \"foo should no longer be used\" end  If the +match+ is omitted (or explicitly +nil+), any deprecation warning will match.  assert_deprecated(CustomDeprecator) do CustomDeprecator.warn \"foo should no longer be used\" end",
    "label": "",
    "id": "3503"
  },
  {
    "raw_code": "def assert_not_deprecated(deprecator, &block)\n        result, deprecations = collect_deprecations(deprecator, &block)\n        assert deprecations.empty?, \"Expected no deprecation warning within the block but received #{deprecations.size}: \\n  #{deprecations * \"\\n  \"}\"\n        result\n      end",
    "comment": "Asserts that no deprecation warnings are emitted by the given deprecator during the execution of the yielded block.  assert_not_deprecated(CustomDeprecator) do CustomDeprecator.warn \"message\" # fails assertion end  assert_not_deprecated(ActiveSupport::Deprecation.new) do CustomDeprecator.warn \"message\" # passes assertion, different deprecator end",
    "label": "",
    "id": "3504"
  },
  {
    "raw_code": "def collect_deprecations(deprecator)\n        old_behavior = deprecator.behavior\n        deprecations = []\n        deprecator.behavior = Proc.new do |message, callstack|\n          deprecations << message\n        end",
    "comment": "Returns the return value of the block and an array of all the deprecation warnings emitted by the given +deprecator+ during the execution of the yielded block.  collect_deprecations(CustomDeprecator) do CustomDeprecator.warn \"message\" ActiveSupport::Deprecation.new.warn \"other message\" :result end # => [:result, [\"message\"]]",
    "label": "",
    "id": "3505"
  },
  {
    "raw_code": "def assert_no_error_reported(&block)\n        reports = ErrorCollector.record do\n          _assert_nothing_raised_or_warn(\"assert_no_error_reported\", &block)\n        end",
    "comment": "Assertion that the block should not cause an exception to be reported to +Rails.error+.  Passes if evaluated code in the yielded block reports no exception.  assert_no_error_reported do perform_service(param: 'no_exception') end",
    "label": "",
    "id": "3506"
  },
  {
    "raw_code": "def assert_error_reported(error_class = StandardError, &block)\n        reports = ErrorCollector.record do\n          _assert_nothing_raised_or_warn(\"assert_error_reported\", &block)\n        end",
    "comment": "Assertion that the block should cause at least one exception to be reported to +Rails.error+.  Passes if the evaluated code in the yielded block reports a matching exception.  assert_error_reported(IOError) do Rails.error.report(IOError.new(\"Oops\")) end  To test further details about the reported exception, you can use the return value.  report = assert_error_reported(IOError) do # ... end assert_equal \"Oops\", report.error.message assert_equal \"admin\", report.context[:section] assert_equal :warning, report.severity assert_predicate report, :handled?",
    "label": "",
    "id": "3507"
  },
  {
    "raw_code": "def capture_error_reports(error_class = StandardError, &block)\n        reports = ErrorCollector.record(&block)\n        reports.select { |r| error_class === r.error }\n      end",
    "comment": "Captures reported errors from within the block that match the given error class.  reports = capture_error_reports(IOError) do Rails.error.report(IOError.new(\"Oops\")) Rails.error.report(IOError.new(\"Oh no\")) Rails.error.report(StandardError.new) end  assert_equal 2, reports.size assert_equal \"Oops\", reports.first.error.message assert_equal \"Oh no\", reports.last.error.message",
    "label": "",
    "id": "3508"
  },
  {
    "raw_code": "def assert_no_event_reported(name = nil, payload: {}, tags: {}, &block)\n        events = EventCollector.record(&block)\n\n        if name.nil?\n          assert_predicate(events, :empty?)\n        else\n          matching_event = events.find { |event| event.matches?(name, payload, tags) }\n          if matching_event\n            message = \"Expected no '#{name}' event to be reported, but found:\\n  \" \\\n              \"#{matching_event.inspect}\"\n            flunk(message)\n          end",
    "comment": "Asserts that the block does not cause an event to be reported to +Rails.event+.  If no name is provided, passes if evaluated code in the yielded block reports no events.  assert_no_event_reported do service_that_does_not_report_events.perform end  If a name is provided, passes if evaluated code in the yielded block reports no events with that name.  assert_no_event_reported(\"user.created\") do service_that_does_not_report_events.perform end",
    "label": "",
    "id": "3509"
  },
  {
    "raw_code": "def assert_event_reported(name, payload: nil, tags: {}, &block)\n        events = EventCollector.record(&block)\n\n        if events.empty?\n          flunk(\"Expected an event to be reported, but there were no events reported.\")\n        elsif (event = events.find { |event| event.matches?(name, payload, tags) })\n          assert(true)\n          event.event_data\n        else\n          message = \"Expected an event to be reported matching:\\n  \" \\\n            \"name: #{name}\\n  \" \\\n            \"payload: #{payload.inspect}\\n  \" \\\n            \"tags: #{tags.inspect}\\n\" \\\n            \"but none of the #{events.size} reported events matched:\\n  \" \\\n            \"#{events.map(&:inspect).join(\"\\n  \")}\"\n          flunk(message)\n        end",
    "comment": "Asserts that the block causes an event with the given name to be reported to +Rails.event+.  Passes if the evaluated code in the yielded block reports a matching event.  assert_event_reported(\"user.created\") do Rails.event.notify(\"user.created\", { id: 123 }) end  To test further details about the reported event, you can specify payload and tag matchers.  assert_event_reported(\"user.created\", payload: { id: 123, name: \"John Doe\" }, tags: { request_id: /[0-9]+/ } ) do Rails.event.tagged(request_id: \"123\") do Rails.event.notify(\"user.created\", { id: 123, name: \"John Doe\" }) end end  The matchers support partial matching - only the specified keys need to match.  assert_event_reported(\"user.created\", payload: { id: 123 }) do Rails.event.notify(\"user.created\", { id: 123, name: \"John Doe\" }) end",
    "label": "",
    "id": "3510"
  },
  {
    "raw_code": "def assert_events_reported(expected_events, &block)\n        events = EventCollector.record(&block)\n\n        if events.empty? && expected_events.size > 0\n          flunk(\"Expected #{expected_events.size} events to be reported, but there were no events reported.\")\n        end",
    "comment": "Asserts that the provided events were reported, regardless of order.  assert_events_reported([ { name: \"user.created\", payload: { id: 123 } }, { name: \"email.sent\", payload: { to: \"user@example.com\" } } ]) do create_user_and_send_welcome_email end  Supports the same payload and tag matching as +assert_event_reported+.  assert_events_reported([ { name: \"process.started\", payload: { id: 123 }, tags: { request_id: /[0-9]+/ } }, { name: \"process.completed\" } ]) do Rails.event.tagged(request_id: \"456\") do start_and_complete_process(123) end end",
    "label": "",
    "id": "3511"
  },
  {
    "raw_code": "def with_debug_event_reporting(&block)\n        ActiveSupport.event_reporter.with_debug(&block)\n      end",
    "comment": "Allows debug events to be reported to +Rails.event+ for the duration of a given block.  with_debug_event_reporting do service_that_reports_debug_events.perform end ",
    "label": "",
    "id": "3512"
  },
  {
    "raw_code": "def file_fixture(fixture_name)\n        path = Pathname.new(File.join(file_fixture_path, fixture_name))\n\n        if path.exist?\n          path\n        else\n          msg = \"the directory '%s' does not contain a file named '%s'\"\n          raise ArgumentError, msg % [file_fixture_path, fixture_name]\n        end",
    "comment": "Returns a +Pathname+ to the fixture file named +fixture_name+.  Raises +ArgumentError+ if +fixture_name+ can't be found.",
    "label": "",
    "id": "3513"
  },
  {
    "raw_code": "def run_in_isolation(&blk)\n          require \"tempfile\"\n\n          if ENV[\"ISOLATION_TEST\"]\n            yield\n            test_result = defined?(Minitest::Result) ? Minitest::Result.from(self) : dup\n            File.open(ENV[\"ISOLATION_OUTPUT\"], \"w\") do |file|\n              file.puts [Marshal.dump(test_result)].pack(\"m\")\n            end",
    "comment": "Complicated H4X to get this working in Windows / JRuby with no forking.",
    "label": "",
    "id": "3514"
  },
  {
    "raw_code": "def assert_notification(pattern, payload = nil, &block)\n        notifications = capture_notifications(pattern, &block)\n        assert_not_empty(notifications, \"No #{pattern} notifications were found\")\n\n        return notifications.first if payload.nil?\n\n        notification = notifications.find { |notification| notification.payload.slice(*payload.keys) == payload }\n        assert_not_nil(notification, \"No #{pattern} notification with payload #{payload} was found\")\n\n        notification\n      end",
    "comment": "Assert a notification was emitted with a given +pattern+ and optional +payload+.  You can assert that a notification was emitted by passing a pattern, which accepts either a string or regexp, an optional payload, and a block. While the block is executed, if a matching notification is emitted, the assertion will pass and the notification will be returned.  Note that the payload is matched as a subset, meaning that the notification must contain at least the specified keys and values, but may contain additional ones.  assert_notification(\"post.submitted\", title: \"Cool Post\") do post.submit(title: \"Cool Post\", body: \"Cool Body\") # => emits matching notification end  Using the returned notification, you can make more customized assertions.  notification = assert_notification(\"post.submitted\", title: \"Cool Post\") do ActiveSupport::Notifications.instrument(\"post.submitted\", title: \"Cool Post\", body: Body.new(\"Cool Body\")) end  assert_instance_of(Body, notification.payload[:body]) ",
    "label": "",
    "id": "3515"
  },
  {
    "raw_code": "def assert_notifications_count(pattern, count, &block)\n        actual_count = capture_notifications(pattern, &block).count\n        assert_equal(count, actual_count, \"Expected #{count} instead of #{actual_count} notifications for #{pattern}\")\n      end",
    "comment": "Assert the number of notifications emitted with a given +pattern+.  You can assert the number of notifications emitted by passing a pattern, which accepts either a string or regexp, a count, and a block. While the block is executed, the number of matching notifications emitted will be counted. After the block's execution completes, the assertion will pass if the count matches.  assert_notifications_count(\"post.submitted\", 1) do post.submit(title: \"Cool Post\") # => emits matching notification end ",
    "label": "",
    "id": "3516"
  },
  {
    "raw_code": "def assert_no_notifications(pattern = nil, &block)\n        notifications = capture_notifications(pattern, &block)\n        error_message = if pattern\n          \"Expected no notifications for #{pattern} but found #{notifications.size}\"\n        else\n          \"Expected no notifications but found #{notifications.size}\"\n        end",
    "comment": "Assert no notifications were emitted for a given +pattern+.  You can assert no notifications were emitted by passing a pattern, which accepts either a string or regexp, and a block. While the block is executed, if no matching notifications are emitted, the assertion will pass.  assert_no_notifications(\"post.submitted\") do post.destroy # => emits non-matching notification end ",
    "label": "",
    "id": "3517"
  },
  {
    "raw_code": "def capture_notifications(pattern = nil, &block)\n        notifications = []\n        ActiveSupport::Notifications.subscribed(->(n) { notifications << n }, pattern, &block)\n        notifications\n      end",
    "comment": "Capture emitted notifications, optionally filtered by a +pattern+.  You can capture emitted notifications, optionally filtered by a pattern, which accepts either a string or regexp, and a block.  notifications = capture_notifications(\"post.submitted\") do post.submit(title: \"Cool Post\") # => emits matching notification end ",
    "label": "",
    "id": "3518"
  },
  {
    "raw_code": "def setup(*args, &block)\n          set_callback(:setup, :before, *args, &block)\n        end",
    "comment": "Add a callback, which runs before <tt>TestCase#setup</tt>.",
    "label": "",
    "id": "3519"
  },
  {
    "raw_code": "def teardown(*args, &block)\n          set_callback(:teardown, :after, *args, &block)\n        end",
    "comment": "Add a callback, which runs after <tt>TestCase#teardown</tt>.",
    "label": "",
    "id": "3520"
  },
  {
    "raw_code": "def stub_object(object, method_name, &block)\n        if stub = stubbing(object, method_name)\n          unstub_object(stub)\n        end",
    "comment": "Stubs object.method_name with the given block If the method is already stubbed, remove that stub so that removing this stub will restore the original implementation. Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00 target = Time.zone.local(2004, 11, 24, 1, 4, 44) simple_stubs.stub_object(Time, :now) { at(target.to_i) } Time.current # => Wed, 24 Nov 2004 01:04:44 EST -05:00",
    "label": "",
    "id": "3521"
  },
  {
    "raw_code": "def unstub_all!\n        @stubs.each_value do |object_stubs|\n          object_stubs.each_value do |stub|\n            unstub_object(stub)\n          end",
    "comment": "Remove all object-method stubs held by this instance",
    "label": "",
    "id": "3522"
  },
  {
    "raw_code": "def stubbing(object, method_name)\n        @stubs[object.object_id][method_name]\n      end",
    "comment": "Returns the Stub for object#method_name (nil if it is not stubbed)",
    "label": "",
    "id": "3523"
  },
  {
    "raw_code": "def stubbed?\n        !@stubs.empty?\n      end",
    "comment": "Returns true if any stubs are set, false if there are none",
    "label": "",
    "id": "3524"
  },
  {
    "raw_code": "def unstub_object(stub)\n          singleton_class = stub.object.singleton_class\n          singleton_class.silence_redefinition_of_method stub.method_name\n          singleton_class.alias_method stub.method_name, stub.original_method\n          singleton_class.undef_method stub.original_method\n        end",
    "comment": "Restores the original object.method described by the Stub",
    "label": "",
    "id": "3525"
  },
  {
    "raw_code": "def travel(duration, with_usec: false, &block)\n        travel_to Time.now + duration, with_usec: with_usec, &block\n      end",
    "comment": "Changes current time to the time in the future or in the past by a given time difference by stubbing +Time.now+, +Date.today+, and +DateTime.now+. The stubs are automatically removed at the end of the test.  Note that the usec for the resulting time will be set to 0 to prevent rounding errors with external services, like MySQL (which will round instead of floor, leading to off-by-one-second errors), unless the <tt>with_usec</tt> argument is set to <tt>true</tt>.  Time.current     # => Sat, 09 Nov 2013 15:34:49 EST -05:00 travel 1.day Time.current     # => Sun, 10 Nov 2013 15:34:49 EST -05:00 Date.current     # => Sun, 10 Nov 2013 DateTime.current # => Sun, 10 Nov 2013 15:34:49 -0500  This method also accepts a block, which will return the current time back to its original state at the end of the block:  Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00 travel 1.day do User.create.created_at # => Sun, 10 Nov 2013 15:34:49 EST -05:00 end Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00",
    "label": "",
    "id": "3526"
  },
  {
    "raw_code": "def travel_to(date_or_time, with_usec: false)\n        if block_given? && in_block\n          travel_to_nested_block_call = <<~MSG\n\n      Calling `travel_to` with a block, when we have previously already made a call to `travel_to`, can lead to confusing time stubbing.\n\n      Instead of:\n\n         travel_to 2.days.from_now do\n           # 2 days from today\n           travel_to 3.days.from_now do\n             # 5 days from today\n           end",
    "comment": "Changes current time to the given time by stubbing +Time.now+, +Time.new+, +Date.today+, and +DateTime.now+ to return the time or date passed into this method. The stubs are automatically removed at the end of the test.  Time.current     # => Sat, 09 Nov 2013 15:34:49 EST -05:00 travel_to Time.zone.local(2004, 11, 24, 1, 4, 44) Time.current     # => Wed, 24 Nov 2004 01:04:44 EST -05:00 Date.current     # => Wed, 24 Nov 2004 DateTime.current # => Wed, 24 Nov 2004 01:04:44 -0500  Dates are taken as their timestamp at the beginning of the day in the application time zone. <tt>Time.current</tt> returns said timestamp, and <tt>Time.now</tt> its equivalent in the system time zone. Similarly, <tt>Date.current</tt> returns a date equal to the argument, and <tt>Date.today</tt> the date according to <tt>Time.now</tt>, which may be different. (Note that you rarely want to deal with <tt>Time.now</tt>, or <tt>Date.today</tt>, in order to honor the application time zone please always use <tt>Time.current</tt> and <tt>Date.current</tt>.)  Note that the usec for the time passed will be set to 0 to prevent rounding errors with external services, like MySQL (which will round instead of floor, leading to off-by-one-second errors), unless the <tt>with_usec</tt> argument is set to <tt>true</tt>.  This method also accepts a block, which will return the current time back to its original state at the end of the block:  Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00 travel_to Time.zone.local(2004, 11, 24, 1, 4, 44) do Time.current # => Wed, 24 Nov 2004 01:04:44 EST -05:00 end Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00",
    "label": "",
    "id": "3527"
  },
  {
    "raw_code": "def travel_back\n        stubbed_time = Time.current if block_given? && simple_stubs.stubbed?\n\n        simple_stubs.unstub_all!\n        yield if block_given?\n      ensure\n        travel_to stubbed_time if stubbed_time\n      end",
    "comment": "Returns the current time back to its original state, by removing the stubs added by +travel+, +travel_to+, and +freeze_time+.  Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00  travel_to Time.zone.local(2004, 11, 24, 1, 4, 44) Time.current # => Wed, 24 Nov 2004 01:04:44 EST -05:00  travel_back Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00  This method also accepts a block, which brings the stubs back at the end of the block:  Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00  travel_to Time.zone.local(2004, 11, 24, 1, 4, 44) Time.current # => Wed, 24 Nov 2004 01:04:44 EST -05:00  travel_back do Time.current # => Sat, 09 Nov 2013 15:34:49 EST -05:00 end  Time.current # => Wed, 24 Nov 2004 01:04:44 EST -05:00",
    "label": "",
    "id": "3528"
  },
  {
    "raw_code": "def freeze_time(date_or_time = Time.now, with_usec: false, &block)\n        travel_to date_or_time, with_usec: with_usec, &block\n      end",
    "comment": "Calls +travel_to+ with +date_or_time+, which defaults to +Time.now+. Forwards optional <tt>with_usec</tt> argument.  Time.current # => Sun, 09 Jul 2017 15:34:49 EST -05:00 freeze_time sleep(1) Time.current # => Sun, 09 Jul 2017 15:34:49 EST -05:00 freeze_time Time.current + 1.day sleep(1) Time.current # => Mon, 10 Jul 2017 15:34:49 EST -05:00  This method also accepts a block, which will return the current time back to its original state at the end of the block:  Time.current # => Sun, 09 Jul 2017 15:34:49 EST -05:00 freeze_time do sleep(1) User.create.created_at # => Sun, 09 Jul 2017 15:34:49 EST -05:00 end Time.current # => Sun, 09 Jul 2017 15:34:50 EST -05:00",
    "label": "",
    "id": "3529"
  },
  {
    "raw_code": "def seconds_to_utc_offset(seconds, colon = true)\n        format = colon ? UTC_OFFSET_WITH_COLON : UTC_OFFSET_WITHOUT_COLON\n        sign = (seconds < 0 ? \"-\" : \"+\")\n        hours = seconds.abs / 3600\n        minutes = (seconds.abs % 3600) / 60\n        format % [sign, hours, minutes]\n      end",
    "comment": "Assumes self represents an offset from UTC in seconds (as returned from Time#utc_offset) and turns this into an +HH:MM formatted string.  ActiveSupport::TimeZone.seconds_to_utc_offset(-21_600) # => \"-06:00\"",
    "label": "",
    "id": "3530"
  },
  {
    "raw_code": "def new(name)\n        self[name]\n      end",
    "comment": "Returns a TimeZone instance with the given name, or +nil+ if no such TimeZone instance exists. (This exists to support the use of this class with the +composed_of+ macro.)",
    "label": "",
    "id": "3531"
  },
  {
    "raw_code": "def all\n        @zones ||= zones_map.values.sort\n      end",
    "comment": "Returns an array of all TimeZone objects. There are multiple TimeZone objects per time zone, in many cases, to make it easier for users to find their own time zone.",
    "label": "",
    "id": "3532"
  },
  {
    "raw_code": "def [](arg)\n        case arg\n        when self\n          arg\n        when String\n          begin\n            @lazy_zones_map[arg] ||= create(arg)\n          rescue TZInfo::InvalidTimezoneIdentifier\n            nil\n          end",
    "comment": "Locate a specific time zone object. If the argument is a string, it is interpreted to mean the name of the timezone to locate. If it is a numeric value it is either the hour offset, or the second offset, of the timezone to find. (The first one with that offset will be returned.) Returns +nil+ if no such time zone is known to the system.",
    "label": "",
    "id": "3533"
  },
  {
    "raw_code": "def us_zones\n        country_zones(:us)\n      end",
    "comment": "A convenience method for returning a collection of TimeZone objects for time zones in the USA.",
    "label": "",
    "id": "3534"
  },
  {
    "raw_code": "def country_zones(country_code)\n        code = country_code.to_s.upcase\n        @country_zones[code] ||= load_country_zones(code)\n      end",
    "comment": "A convenience method for returning a collection of TimeZone objects for time zones in the country specified by its ISO 3166-1 Alpha2 code.",
    "label": "",
    "id": "3535"
  },
  {
    "raw_code": "def initialize(name, utc_offset = nil, tzinfo = nil)\n      @name = name\n      @utc_offset = utc_offset\n      @tzinfo = tzinfo || TimeZone.find_tzinfo(name)\n    end",
    "comment": " :singleton-method: create :call-seq: create(name, utc_offset = nil, tzinfo = nil)  Create a new TimeZone object with the given name and offset. The offset is the number of seconds that this time zone is offset from UTC (GMT). Seconds were chosen as the offset unit because that is the unit that Ruby uses to represent time zone offsets (see Time#utc_offset). :stopdoc:",
    "label": "",
    "id": "3536"
  },
  {
    "raw_code": "def standard_name\n      MAPPING[name] || name\n    end",
    "comment": ":startdoc: Returns a standard time zone name defined by IANA https://www.iana.org/time-zones",
    "label": "",
    "id": "3537"
  },
  {
    "raw_code": "def utc_offset\n      @utc_offset || tzinfo&.current_period&.base_utc_offset\n    end",
    "comment": "Returns the offset of this time zone from UTC in seconds.",
    "label": "",
    "id": "3538"
  },
  {
    "raw_code": "def formatted_offset(colon = true, alternate_utc_string = nil)\n      utc_offset == 0 && alternate_utc_string || self.class.seconds_to_utc_offset(utc_offset, colon)\n    end",
    "comment": "Returns a formatted string of the offset from UTC, or an alternative string if the time zone is already UTC.  zone = ActiveSupport::TimeZone['Central Time (US & Canada)'] zone.formatted_offset        # => \"-06:00\" zone.formatted_offset(false) # => \"-0600\"",
    "label": "",
    "id": "3539"
  },
  {
    "raw_code": "def <=>(zone)\n      return unless zone.respond_to? :utc_offset\n      result = (utc_offset <=> zone.utc_offset)\n      result = (name <=> zone.name) if result == 0\n      result\n    end",
    "comment": "Compare this time zone to the parameter. The two are compared first on their offsets, and then by name.",
    "label": "",
    "id": "3540"
  },
  {
    "raw_code": "def =~(re)\n      re === name || re === MAPPING[name]\n    end",
    "comment": "Compare #name and TZInfo identifier to a supplied regexp, returning +true+ if a match is found.",
    "label": "",
    "id": "3541"
  },
  {
    "raw_code": "def match?(re)\n      (re == name) || (re == MAPPING[name]) ||\n        ((Regexp === re) && (re.match?(name) || re.match?(MAPPING[name])))\n    end",
    "comment": "Compare #name and TZInfo identifier to a supplied regexp, returning +true+ if a match is found.",
    "label": "",
    "id": "3542"
  },
  {
    "raw_code": "def to_s\n      \"(GMT#{formatted_offset}) #{name}\"\n    end",
    "comment": "Returns a textual representation of this time zone.",
    "label": "",
    "id": "3543"
  },
  {
    "raw_code": "def local(*args)\n      time = Time.utc(*args)\n      ActiveSupport::TimeWithZone.new(nil, self, time)\n    end",
    "comment": "\\Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from given values.  Time.zone = 'Hawaii'                    # => \"Hawaii\" Time.zone.local(2007, 2, 1, 15, 30, 45) # => Thu, 01 Feb 2007 15:30:45 HST -10:00",
    "label": "",
    "id": "3544"
  },
  {
    "raw_code": "def at(*args)\n      Time.at(*args).utc.in_time_zone(self)\n    end",
    "comment": "\\Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from number of seconds since the Unix epoch.  Time.zone = 'Hawaii'        # => \"Hawaii\" Time.utc(2000).to_f         # => 946684800.0 Time.zone.at(946684800.0)   # => Fri, 31 Dec 1999 14:00:00 HST -10:00  A second argument can be supplied to specify sub-second precision.  Time.zone = 'Hawaii'                # => \"Hawaii\" Time.at(946684800, 123456.789).nsec # => 123456789",
    "label": "",
    "id": "3545"
  },
  {
    "raw_code": "def iso8601(str)\n      # Historically `Date._iso8601(nil)` returns `{}`, but in the `date` gem versions `3.2.1`, `3.1.2`, `3.0.2`,\n      # and `2.0.1`, `Date._iso8601(nil)` raises `TypeError` https://github.com/ruby/date/issues/39\n      # Future `date` releases are expected to revert back to the original behavior.\n      raise ArgumentError, \"invalid date\" if str.nil?\n\n      parts = Date._iso8601(str)\n\n      year = parts.fetch(:year)\n\n      if parts.key?(:yday)\n        ordinal_date = Date.ordinal(year, parts.fetch(:yday))\n        month = ordinal_date.month\n        day = ordinal_date.day\n      else\n        month = parts.fetch(:mon)\n        day = parts.fetch(:mday)\n      end",
    "comment": "\\Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from an ISO 8601 string.  Time.zone = 'Hawaii'                     # => \"Hawaii\" Time.zone.iso8601('1999-12-31T14:00:00') # => Fri, 31 Dec 1999 14:00:00 HST -10:00  If the time components are missing then they will be set to zero.  Time.zone = 'Hawaii'            # => \"Hawaii\" Time.zone.iso8601('1999-12-31') # => Fri, 31 Dec 1999 00:00:00 HST -10:00  If the string is invalid then an +ArgumentError+ will be raised unlike +parse+ which usually returns +nil+ when given an invalid date string.",
    "label": "",
    "id": "3546"
  },
  {
    "raw_code": "def parse(str, now = now())\n      parts_to_time(Date._parse(str, false), now)\n    end",
    "comment": "\\Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from parsed string.  Time.zone = 'Hawaii'                   # => \"Hawaii\" Time.zone.parse('1999-12-31 14:00:00') # => Fri, 31 Dec 1999 14:00:00 HST -10:00  If upper components are missing from the string, they are supplied from TimeZone#now:  Time.zone.now               # => Fri, 31 Dec 1999 14:00:00 HST -10:00 Time.zone.parse('22:30:00') # => Fri, 31 Dec 1999 22:30:00 HST -10:00  However, if the date component is not provided, but any other upper components are supplied, then the day of the month defaults to 1:  Time.zone.parse('Mar 2000') # => Wed, 01 Mar 2000 00:00:00 HST -10:00  If the string is invalid then an +ArgumentError+ could be raised.",
    "label": "",
    "id": "3547"
  },
  {
    "raw_code": "def rfc3339(str)\n      parts = Date._rfc3339(str)\n\n      raise ArgumentError, \"invalid date\" if parts.empty?\n\n      time = Time.new(\n        parts.fetch(:year),\n        parts.fetch(:mon),\n        parts.fetch(:mday),\n        parts.fetch(:hour),\n        parts.fetch(:min),\n        parts.fetch(:sec) + parts.fetch(:sec_fraction, 0),\n        parts.fetch(:offset)\n      )\n\n      TimeWithZone.new(time.utc, self)\n    end",
    "comment": "\\Method for creating new ActiveSupport::TimeWithZone instance in time zone of +self+ from an RFC 3339 string.  Time.zone = 'Hawaii'                     # => \"Hawaii\" Time.zone.rfc3339('2000-01-01T00:00:00Z') # => Fri, 31 Dec 1999 14:00:00 HST -10:00  If the time or zone components are missing then an +ArgumentError+ will be raised. This is much stricter than either +parse+ or +iso8601+ which allow for missing components.  Time.zone = 'Hawaii'            # => \"Hawaii\" Time.zone.rfc3339('1999-12-31') # => ArgumentError: invalid date",
    "label": "",
    "id": "3548"
  },
  {
    "raw_code": "def strptime(str, format, now = now())\n      parts_to_time(DateTime._strptime(str, format), now)\n    end",
    "comment": "Parses +str+ according to +format+ and returns an ActiveSupport::TimeWithZone.  Assumes that +str+ is a time in the time zone +self+, unless +format+ includes an explicit time zone. (This is the same behavior as +parse+.) In either case, the returned TimeWithZone has the timezone of +self+.  Time.zone = 'Hawaii'                   # => \"Hawaii\" Time.zone.strptime('1999-12-31 14:00:00', '%Y-%m-%d %H:%M:%S') # => Fri, 31 Dec 1999 14:00:00 HST -10:00  If upper components are missing from the string, they are supplied from TimeZone#now:  Time.zone.now                              # => Fri, 31 Dec 1999 14:00:00 HST -10:00 Time.zone.strptime('22:30:00', '%H:%M:%S') # => Fri, 31 Dec 1999 22:30:00 HST -10:00  However, if the date component is not provided, but any other upper components are supplied, then the day of the month defaults to 1:  Time.zone.strptime('Mar 2000', '%b %Y') # => Wed, 01 Mar 2000 00:00:00 HST -10:00",
    "label": "",
    "id": "3549"
  },
  {
    "raw_code": "def now\n      time_now.utc.in_time_zone(self)\n    end",
    "comment": "Returns an ActiveSupport::TimeWithZone instance representing the current time in the time zone represented by +self+.  Time.zone = 'Hawaii'  # => \"Hawaii\" Time.zone.now         # => Wed, 23 Jan 2008 20:24:27 HST -10:00",
    "label": "",
    "id": "3550"
  },
  {
    "raw_code": "def today\n      tzinfo.now.to_date\n    end",
    "comment": "Returns the current date in this time zone.",
    "label": "",
    "id": "3551"
  },
  {
    "raw_code": "def tomorrow\n      today + 1\n    end",
    "comment": "Returns the next date in this time zone.",
    "label": "",
    "id": "3552"
  },
  {
    "raw_code": "def yesterday\n      today - 1\n    end",
    "comment": "Returns the previous date in this time zone.",
    "label": "",
    "id": "3553"
  },
  {
    "raw_code": "def utc_to_local(time)\n      tzinfo.utc_to_local(time).yield_self do |t|\n        ActiveSupport.utc_to_local_returns_utc_offset_times ?\n          t : Time.utc(t.year, t.month, t.day, t.hour, t.min, t.sec, t.sec_fraction * 1_000_000)\n      end",
    "comment": "Adjust the given time to the simultaneous time in the time zone represented by +self+. Returns a local time with the appropriate offset -- if you want an ActiveSupport::TimeWithZone instance, use Time#in_time_zone() instead.  As of tzinfo 2, utc_to_local returns a Time with a non-zero utc_offset. See the +utc_to_local_returns_utc_offset_times+ config for more info.",
    "label": "",
    "id": "3554"
  },
  {
    "raw_code": "def local_to_utc(time, dst = true)\n      tzinfo.local_to_utc(time, dst)\n    end",
    "comment": "Adjust the given time to the simultaneous time in UTC. Returns a Time.utc() instance.",
    "label": "",
    "id": "3555"
  },
  {
    "raw_code": "def parse(data)\n      if data.respond_to?(:read)\n        data = data.read\n      end",
    "comment": "Parse an XML Document string or IO into a simple hash using Java's jdom. data:: XML Document string or IO to parse",
    "label": "",
    "id": "3556"
  },
  {
    "raw_code": "def merge_element!(hash, element, depth)\n        raise \"Document too deep!\" if depth == 0\n        delete_empty(hash)\n        merge!(hash, element.tag_name, collapse(element, depth))\n      end",
    "comment": "Convert an XML element and merge into the hash  hash:: Hash to merge the converted element into. element:: XML element to merge into hash",
    "label": "",
    "id": "3557"
  },
  {
    "raw_code": "def collapse(element, depth)\n        hash = get_attributes(element)\n\n        child_nodes = element.child_nodes\n        if child_nodes.length > 0\n          (0...child_nodes.length).each do |i|\n            child = child_nodes.item(i)\n            merge_element!(hash, child, depth - 1) unless child.node_type == Node::TEXT_NODE\n          end",
    "comment": "Actually converts an XML document element into a data structure.  element:: The document element to be collapsed.",
    "label": "",
    "id": "3558"
  },
  {
    "raw_code": "def merge_texts!(hash, element)\n        delete_empty(hash)\n        text_children = texts(element)\n        if text_children.join.empty?\n          hash\n        else\n          # must use value to prevent double-escaping\n          merge!(hash, CONTENT_KEY, text_children.join)\n        end",
    "comment": "Merge all the texts of an element into the hash  hash:: Hash to add the converted element to. element:: XML element whose texts are to me merged into the hash",
    "label": "",
    "id": "3559"
  },
  {
    "raw_code": "def merge!(hash, key, value)\n        if hash.has_key?(key)\n          if hash[key].instance_of?(Array)\n            hash[key] << value\n          else\n            hash[key] = [hash[key], value]\n          end",
    "comment": "Adds a new key/value pair to an existing Hash. If the key to be added already exists and the existing value associated with key is not an Array, it will be wrapped in an Array. Then the new value is appended to that Array.  hash:: Hash to add key/value pair to. key:: Key to be added. value:: Value to be associated with key.",
    "label": "",
    "id": "3560"
  },
  {
    "raw_code": "def get_attributes(element)\n        attribute_hash = {}\n        attributes = element.attributes\n        (0...attributes.length).each do |i|\n          attribute_hash[CONTENT_KEY] ||= \"\"\n          attribute_hash[attributes.item(i).name] = attributes.item(i).value\n        end",
    "comment": "Converts the attributes array of an XML element into a hash. Returns an empty Hash if node has no attributes.  element:: XML element to extract attributes from.",
    "label": "",
    "id": "3561"
  },
  {
    "raw_code": "def texts(element)\n        texts = []\n        child_nodes = element.child_nodes\n        (0...child_nodes.length).each do |i|\n          item = child_nodes.item(i)\n          if item.node_type == Node::TEXT_NODE\n            texts << item.get_data\n          end",
    "comment": "Determines if a document element has text content  element:: XML element to be checked.",
    "label": "",
    "id": "3562"
  },
  {
    "raw_code": "def empty_content?(element)\n        text = +\"\"\n        child_nodes = element.child_nodes\n        (0...child_nodes.length).each do |i|\n          item = child_nodes.item(i)\n          if item.node_type == Node::TEXT_NODE\n            text << item.get_data.strip\n          end",
    "comment": "Determines if a document element has text content  element:: XML element to be checked.",
    "label": "",
    "id": "3563"
  },
  {
    "raw_code": "def parse(data)\n      if !data.respond_to?(:read)\n        data = StringIO.new(data || \"\")\n      end",
    "comment": "Parse an XML Document string or IO into a simple hash using libxml. data:: XML Document string or IO to parse",
    "label": "",
    "id": "3564"
  },
  {
    "raw_code": "def to_hash(hash = {})\n        node_hash = {}\n\n        # Insert node hash into parent hash correctly.\n        case hash[name]\n        when Array then hash[name] << node_hash\n        when Hash  then hash[name] = [hash[name], node_hash]\n        when nil   then hash[name] = node_hash\n        end",
    "comment": "Convert XML document to hash.  hash:: Hash to merge the converted element into.",
    "label": "",
    "id": "3565"
  },
  {
    "raw_code": "def parse(data)\n      if !data.respond_to?(:read)\n        data = StringIO.new(data || \"\")\n      end",
    "comment": "Parse an XML Document string or IO into a simple hash using libxml / nokogiri. data:: XML Document string or IO to parse",
    "label": "",
    "id": "3566"
  },
  {
    "raw_code": "def to_hash(hash = {})\n          node_hash = {}\n\n          # Insert node hash into parent hash correctly.\n          case hash[name]\n          when Array then hash[name] << node_hash\n          when Hash  then hash[name] = [hash[name], node_hash]\n          when nil   then hash[name] = node_hash\n          end",
    "comment": "Convert XML document to hash.  hash:: Hash to merge the converted element into.",
    "label": "",
    "id": "3567"
  },
  {
    "raw_code": "def parse(data)\n      if !data.respond_to?(:read)\n        data = StringIO.new(data || \"\")\n      end",
    "comment": "Parse an XML Document string or IO into a simple hash.  Same as XmlSimple::xml_in but doesn't shoot itself in the foot, and uses the defaults from Active Support.  data:: XML Document string or IO to parse",
    "label": "",
    "id": "3568"
  },
  {
    "raw_code": "def merge_element!(hash, element, depth)\n        raise REXML::ParseException, \"The document is too deep\" if depth == 0\n        merge!(hash, element.name, collapse(element, depth))\n      end",
    "comment": "Convert an XML element and merge into the hash  hash:: Hash to merge the converted element into. element:: XML element to merge into hash",
    "label": "",
    "id": "3569"
  },
  {
    "raw_code": "def collapse(element, depth)\n        hash = get_attributes(element)\n\n        if element.has_elements?\n          element.each_element { |child| merge_element!(hash, child, depth - 1) }\n          merge_texts!(hash, element) unless empty_content?(element)\n          hash\n        else\n          merge_texts!(hash, element)\n        end",
    "comment": "Actually converts an XML document element into a data structure.  element:: The document element to be collapsed.",
    "label": "",
    "id": "3570"
  },
  {
    "raw_code": "def merge_texts!(hash, element)\n        unless element.has_text?\n          hash\n        else\n          # must use value to prevent double-escaping\n          texts = +\"\"\n          element.texts.each { |t| texts << t.value }\n          merge!(hash, CONTENT_KEY, texts)\n        end",
    "comment": "Merge all the texts of an element into the hash  hash:: Hash to add the converted element to. element:: XML element whose texts are to me merged into the hash",
    "label": "",
    "id": "3571"
  },
  {
    "raw_code": "def merge!(hash, key, value)\n        if hash.has_key?(key)\n          if hash[key].instance_of?(Array)\n            hash[key] << value\n          else\n            hash[key] = [hash[key], value]\n          end",
    "comment": "Adds a new key/value pair to an existing Hash. If the key to be added already exists and the existing value associated with key is not an Array, it will be wrapped in an Array. Then the new value is appended to that Array.  hash:: Hash to add key/value pair to. key:: Key to be added. value:: Value to be associated with key.",
    "label": "",
    "id": "3572"
  },
  {
    "raw_code": "def get_attributes(element)\n        attributes = {}\n        element.attributes.each { |n, v| attributes[n] = v }\n        attributes\n      end",
    "comment": "Converts the attributes array of an XML element into a hash. Returns an empty Hash if node has no attributes.  element:: XML element to extract attributes from.",
    "label": "",
    "id": "3573"
  },
  {
    "raw_code": "def empty_content?(element)\n        element.texts.join.blank?\n      end",
    "comment": "Determines if a document element has text content  element:: XML element to be checked.",
    "label": "",
    "id": "3574"
  },
  {
    "raw_code": "def indirect_caller_locations\n    caller_locations\n  end",
    "comment": "Adds a frame from this file to the call stack.",
    "label": "",
    "id": "3575"
  },
  {
    "raw_code": "def before_setup\n    @original_time_zone = Time.zone\n    super\n  end",
    "comment": "Use library specific minitest hook to catch Time.zone before reset is called via TestHelper",
    "label": "",
    "id": "3576"
  },
  {
    "raw_code": "def after_teardown\n    super\n    Time.zone = @original_time_zone\n  end",
    "comment": "Use library specific minitest hook to set Time.zone after reset is called via TestHelper",
    "label": "",
    "id": "3577"
  },
  {
    "raw_code": "def collect_disallowed(deprecator)\n      deprecator ||= ActiveSupport::Deprecation\n      original_disallowed_behavior = deprecator.disallowed_behavior\n      disallowed = []\n      deprecator.disallowed_behavior = proc { |message| disallowed << message }\n      result = yield\n      [result, disallowed]\n    ensure\n      deprecator.disallowed_behavior = original_disallowed_behavior\n    end",
    "comment": "a la collect_deprecations",
    "label": "",
    "id": "3578"
  },
  {
    "raw_code": "def assert_disallowed(match = nil, deprecator = nil, &block)\n      match, deprecator = nil, match if match.is_a?(ActiveSupport::Deprecation)\n      result, disallowed = collect_disallowed(deprecator, &block)\n      assert_not_empty disallowed, \"Expected a disallowed deprecation within the block but received none\"\n      if match\n        match = Regexp.new(Regexp.escape(match)) unless match.is_a?(Regexp)\n        assert disallowed.any?(match), \"No disallowed deprecations matched #{match}: #{disallowed.inspect}\"\n      end",
    "comment": "a la assert_deprecated",
    "label": "",
    "id": "3579"
  },
  {
    "raw_code": "def test_option_merger_class_method\n    assert_equal ActiveSupport::OptionMerger, ActiveSupport::OptionMerger.new(\"\", \"\").class\n  end",
    "comment": "Needed when counting objects with the ObjectSpace",
    "label": "",
    "id": "3580"
  },
  {
    "raw_code": "def test_filename_max_size\n    key = \"#{'A' * ActiveSupport::Cache::FileStore::FILENAME_MAX_SIZE}\"\n    path = @cache.send(:normalize_key, key, {})\n    basename = File.basename(path)\n    dirname = File.dirname(path)\n    Dir::Tmpname.create(basename, Dir.tmpdir + dirname) do |tmpname, n, opts|\n      assert File.basename(tmpname + \".lock\").length <= 255, \"Temp filename too long: #{File.basename(tmpname + '.lock').length}\"\n    end",
    "comment": "Test that generated cache keys are short enough to have Tempfile stuff added to them and remain valid",
    "label": "",
    "id": "3581"
  },
  {
    "raw_code": "def test_key_transformation_max_filename_size\n    key = \"#{'A' * ActiveSupport::Cache::FileStore::FILENAME_MAX_SIZE}B\"\n    path = @cache.send(:normalize_key, key, {})\n    assert path.split(\"/\").all? { |dir_name| dir_name.size <= ActiveSupport::Cache::FileStore::FILENAME_MAX_SIZE }\n    assert_equal \"B\", File.basename(path)\n  end",
    "comment": "Because file systems have a maximum filename size, filenames > max size should be split in to directories If filename is 'AAAAB', where max size is 4, the returned path should be AAAA/B",
    "label": "",
    "id": "3582"
  },
  {
    "raw_code": "def test_delete_matched_when_cache_directory_does_not_exist\n    assert_nothing_raised do\n      ActiveSupport::Cache::FileStore.new(\"/test/cache/directory\").delete_matched(/does_not_exist/)\n    end",
    "comment": "If nothing has been stored in the cache, there is a chance the cache directory does not yet exist Ensure delete_matched gracefully handles this case",
    "label": "",
    "id": "3583"
  },
  {
    "raw_code": "def test_clear_also_clears_local_cache\n    key = SecureRandom.uuid\n    cache = lookup_store(raw: true)\n    stub_called = false\n\n    client(cache).stub(:flush_all, -> { stub_called = true; client.delete(\"#{@namespace}:#{key}\") }) do\n      cache.with_local_cache do\n        cache.write(key, SecureRandom.alphanumeric)\n        cache.clear\n        assert_nil cache.read(key)\n      end",
    "comment": "Overrides test from LocalCacheBehavior in order to stub out the cache clear and replace it with a delete.",
    "label": "",
    "id": "3584"
  },
  {
    "raw_code": "def test_iso8601_parsing_wrong_patterns_with_raise\n    invalid_patterns = [\"\", \"P\", \"PT\", \"P1YT\", \"T\", \"PW\", \"P1Y1W\", \"~P1Y\", \".P1Y\", \"P1.5Y0.5M\", \"P1.5Y1M\", \"P1.5MT10.5S\"]\n    invalid_patterns.each do |pattern|\n      assert_raise ActiveSupport::Duration::ISO8601Parser::ParsingError, pattern.inspect do\n        ActiveSupport::Duration.parse(pattern)\n      end",
    "comment": "ISO8601 string examples are taken from ISO8601 gem at https://github.com/arnau/ISO8601/blob/b93d466840/spec/iso8601/duration_spec.rb published under the conditions of MIT license at https://github.com/arnau/ISO8601/blob/b93d466840/LICENSE  Copyright (c) 2012-2014 Arnau Siches  MIT License  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
    "label": "",
    "id": "3585"
  },
  {
    "raw_code": "def test_plain_without_tags\n      source = \" @post.title\\n\"\n      actual_tokens = tokenize source\n      assert_equal [[:PLAIN, \" @post.title\"]], actual_tokens\n    end",
    "comment": "This happens when a template is multiline and no ERB tags are used on the current line.",
    "label": "",
    "id": "3586"
  },
  {
    "raw_code": "def test_kernel_method_names_to_xml\n    hash     = { throw: { ball: \"red\" } }\n    expected = \"<person><throw><ball>red</ball></throw></person>\"\n\n    assert_nothing_raised do\n      assert_equal expected, hash.to_xml(@xml_options)\n    end",
    "comment": "The XML builder seems to fail miserably when trying to tag something with the same name as a Kernel method (throw, test, loop, select ...)",
    "label": "",
    "id": "3587"
  },
  {
    "raw_code": "def test_delegation_with_allow_nil_and_false_value\n    project = Project.new(false, false)\n    assert_raise(NoMethodError) { project.name }\n  end",
    "comment": "Ensures with check for nil, not for a falsy target.",
    "label": "",
    "id": "3588"
  },
  {
    "raw_code": "def test_include_returns_false_for_empty_exclusive_end\n    assert_not((1..5).include?(3...3))\n  end",
    "comment": "Match quirky plain-Ruby behavior",
    "label": "",
    "id": "3589"
  },
  {
    "raw_code": "def test_compare_returns_false_for_empty_exclusive_end\n    assert_not((1..5) === (3...3))\n  end",
    "comment": "Match quirky plain-Ruby behavior",
    "label": "",
    "id": "3590"
  },
  {
    "raw_code": "def test_fp_inaccuracy_ticket_1836\n    midnight = Time.local(2005, 2, 21, 0, 0, 0)\n    assert_equal midnight.midnight, (midnight + 1.hour + 0.000001).midnight\n  end",
    "comment": "NOTE: this test seems to fail (changeset 1958) only on certain platforms, like OSX, and FreeBSD 5.4.",
    "label": "",
    "id": "3591"
  },
  {
    "raw_code": "def split_language_highlights(language)\n          return [nil, []] unless language\n\n          language, lines = language.split(\"#\", 2)\n          lines = lines.to_s.split(\",\").flat_map { parse_range(_1) }\n\n          [language, lines]\n        end",
    "comment": "Parses \"ruby#3,5-6,10\" into [\"ruby\", [3,5,6,10]] for highlighting line numbers in code blocks",
    "label": "",
    "id": "3592"
  },
  {
    "raw_code": "def configuration\n      application.config\n    end",
    "comment": "The Configuration instance used to configure the \\Rails environment",
    "label": "",
    "id": "3593"
  },
  {
    "raw_code": "def root\n      application && application.config.root\n    end",
    "comment": "Returns a Pathname object of the current \\Rails project, otherwise it returns +nil+ if there is no project:  Rails.root # => #<Pathname:/Users/someuser/some/path/project>",
    "label": "",
    "id": "3594"
  },
  {
    "raw_code": "def env\n      @_env ||= ActiveSupport::EnvironmentInquirer.new(ENV[\"RAILS_ENV\"].presence || ENV[\"RACK_ENV\"].presence || \"development\")\n    end",
    "comment": "Returns the current \\Rails environment.  Rails.env # => \"development\" Rails.env.development? # => true Rails.env.production? # => false Rails.env.local? # => true              true for \"development\" and \"test\", false for anything else",
    "label": "",
    "id": "3595"
  },
  {
    "raw_code": "def env=(environment)\n      @_env = ActiveSupport::EnvironmentInquirer.new(environment)\n    end",
    "comment": "Sets the \\Rails environment.  Rails.env = \"staging\" # => \"staging\"",
    "label": "",
    "id": "3596"
  },
  {
    "raw_code": "def error\n      ActiveSupport.error_reporter\n    end",
    "comment": "Returns the ActiveSupport::ErrorReporter of the current \\Rails project, otherwise it returns +nil+ if there is no project.  Rails.error.handle(IOError) do # ... end Rails.error.report(error)",
    "label": "",
    "id": "3597"
  },
  {
    "raw_code": "def event\n      ActiveSupport.event_reporter\n    end",
    "comment": "Returns the ActiveSupport::EventReporter of the current \\Rails project, otherwise it returns +nil+ if there is no project.  Rails.event.notify(\"my_event\", { message: \"Hello, world!\" })",
    "label": "",
    "id": "3598"
  },
  {
    "raw_code": "def groups(*groups)\n      hash = groups.extract_options!\n      env = Rails.env\n      groups.unshift(:default, env)\n      groups.concat ENV[\"RAILS_GROUPS\"].to_s.split(\",\")\n      groups.concat hash.map { |k, v| k if v.map(&:to_s).include?(env) }\n      groups.compact!\n      groups.uniq!\n      groups\n    end",
    "comment": "Returns all \\Rails groups for loading based on:  * The \\Rails environment; * The environment variable RAILS_GROUPS; * The optional envs given as argument and the hash with group dependencies;  Rails.groups assets: [:development, :test] # => [:default, \"development\", :assets] for Rails.env == \"development\" # => [:default, \"production\"]           for Rails.env == \"production\"",
    "label": "",
    "id": "3599"
  },
  {
    "raw_code": "def public_path\n      application && Pathname.new(application.paths[\"public\"].first)\n    end",
    "comment": "Returns a Pathname object of the public folder of the current \\Rails project, otherwise it returns +nil+ if there is no project:  Rails.public_path # => #<Pathname:/Users/someuser/some/path/project/public>",
    "label": "",
    "id": "3600"
  },
  {
    "raw_code": "def aggregated_results(*)\n      super unless options[:output_inline]\n    end",
    "comment": "Disable extra failure output after a run if output is inline.",
    "label": "",
    "id": "3601"
  },
  {
    "raw_code": "def self.plugin_rails_init(options)\n    # Don't mess with Minitest unless RAILS_ENV is set\n    return unless ENV[\"RAILS_ENV\"] || ENV[\"RAILS_MINITEST_PLUGIN\"]\n\n    unless options[:full_backtrace]\n      # Plugin can run without Rails loaded, check before filtering.\n      if ::Rails.respond_to?(:backtrace_cleaner)\n        Minitest.backtrace_filter = BacktraceFilterWithFallback.new(::Rails.backtrace_cleaner, Minitest.backtrace_filter)\n      end",
    "comment": "Owes great inspiration to test runner trailblazers like RSpec, minitest-reporters, maxitest, and others.",
    "label": "",
    "id": "3602"
  },
  {
    "raw_code": "def initialized?\n      @initialized\n    end",
    "comment": "Returns true if the application is initialized.",
    "label": "",
    "id": "3603"
  },
  {
    "raw_code": "def name\n      self.class.name.underscore.dasherize.delete_suffix(\"/application\")\n    end",
    "comment": "Returns the dasherized application name.  MyApp::Application.new.name => \"my-app\"",
    "label": "",
    "id": "3604"
  },
  {
    "raw_code": "def reload_routes!\n      if routes_reloader.execute_unless_loaded\n        routes_reloader.loaded = false\n      else\n        routes_reloader.reload!\n      end",
    "comment": "Reload application routes regardless if they changed or not.",
    "label": "",
    "id": "3605"
  },
  {
    "raw_code": "def key_generator(secret_key_base = self.secret_key_base)\n      # number of iterations selected based on consultation with the google security\n      # team. Details at https://github.com/rails/rails/pull/6952#issuecomment-7661220\n      @key_generators[secret_key_base] ||= ActiveSupport::CachingKeyGenerator.new(\n        ActiveSupport::KeyGenerator.new(secret_key_base, iterations: 1000)\n      )\n    end",
    "comment": "Returns a key generator (ActiveSupport::CachingKeyGenerator) for a specified +secret_key_base+. The return value is memoized, so additional calls with the same +secret_key_base+ will return the same key generator instance.",
    "label": "",
    "id": "3606"
  },
  {
    "raw_code": "def message_verifiers\n      @message_verifiers ||=\n        ActiveSupport::MessageVerifiers.new do |salt, secret_key_base: self.secret_key_base|\n          key_generator(secret_key_base).generate_key(salt)\n        end.rotate_defaults\n    end",
    "comment": "Returns a message verifier factory (ActiveSupport::MessageVerifiers). This factory can be used as a central point to configure and create message verifiers (ActiveSupport::MessageVerifier) for your application.  By default, message verifiers created by this factory will generate messages using the default ActiveSupport::MessageVerifier options. You can override these options with a combination of ActiveSupport::MessageVerifiers#clear_rotations and ActiveSupport::MessageVerifiers#rotate. However, this must be done prior to building any message verifier instances. For example, in a +before_initialize+ block:  # Use `url_safe: true` when generating messages config.before_initialize do |app| app.message_verifiers.clear_rotations app.message_verifiers.rotate(url_safe: true) end  Message verifiers created by this factory will always use a secret derived from #secret_key_base when generating messages. +clear_rotations+ will not affect this behavior. However, older +secret_key_base+ values can be rotated for verifying messages:  # Fall back to old `secret_key_base` when verifying messages config.before_initialize do |app| app.message_verifiers.rotate(secret_key_base: \"old secret_key_base\") end ",
    "label": "",
    "id": "3607"
  },
  {
    "raw_code": "def message_verifier(verifier_name)\n      message_verifiers[verifier_name]\n    end",
    "comment": "Returns a message verifier object.  This verifier can be used to generate and verify signed messages in the application.  It is recommended not to use the same verifier for different things, so you can get different verifiers passing the +verifier_name+ argument.  For instance, +ActiveStorage::Blob.signed_id_verifier+ is implemented using this feature, which assures that the IDs strings haven't been tampered with and are safe to use in a finder.  See the ActiveSupport::MessageVerifier documentation for more information.  ==== Parameters  * +verifier_name+ - the name of the message verifier.  ==== Examples  message = Rails.application.message_verifier('my_purpose').generate('data to sign against tampering') Rails.application.message_verifier('my_purpose').verify(message) # => 'data to sign against tampering'",
    "label": "",
    "id": "3608"
  },
  {
    "raw_code": "def deprecators\n      @deprecators ||= ActiveSupport::Deprecation::Deprecators.new.tap do |deprecators|\n        deprecators[:railties] = Rails.deprecator\n      end",
    "comment": "A managed collection of deprecators (ActiveSupport::Deprecation::Deprecators). The collection's configuration methods affect all deprecators in the collection. Additionally, the collection's +silence+ method silences all deprecators in the collection for the duration of a given block.",
    "label": "",
    "id": "3609"
  },
  {
    "raw_code": "def config_for(name, env: Rails.env)\n      yaml = name.is_a?(Pathname) ? name : Pathname.new(\"#{paths[\"config\"].existent.first}/#{name}.yml\")\n\n      if yaml.exist?\n        require \"erb\"\n        all_configs    = ActiveSupport::ConfigurationFile.parse(yaml).deep_symbolize_keys\n        config, shared = all_configs[env.to_sym], all_configs[:shared]\n\n        if shared\n          config = {} if config.nil? && shared.is_a?(Hash)\n          if config.is_a?(Hash) && shared.is_a?(Hash)\n            config = shared.deep_merge(config)\n          elsif config.nil?\n            config = shared\n          end",
    "comment": "Convenience for loading config/foo.yml for the current \\Rails env. Example:  # config/exception_notification.yml: production: url: http://127.0.0.1:8080 namespace: my_app_production  development: url: http://localhost:3001 namespace: my_app_development  <code></code>  # config/environments/production.rb Rails.application.configure do config.middleware.use ExceptionNotifier, config_for(:exception_notification) end  You can also store configurations in a shared section which will be merged with the environment configuration  # config/example.yml shared: foo: bar: baz: 1  development: foo: bar: qux: 2  <code></code>  # development environment Rails.application.config_for(:example)[:foo][:bar] # => { baz: 1, qux: 2 }",
    "label": "",
    "id": "3610"
  },
  {
    "raw_code": "def env_config\n      @app_env_config ||= super.merge(\n          \"action_dispatch.parameter_filter\" => filter_parameters,\n          \"action_dispatch.redirect_filter\" => config.filter_redirect,\n          \"action_dispatch.secret_key_base\" => secret_key_base,\n          \"action_dispatch.show_exceptions\" => config.action_dispatch.show_exceptions,\n          \"action_dispatch.show_detailed_exceptions\" => config.consider_all_requests_local,\n          \"action_dispatch.log_rescued_responses\" => config.action_dispatch.log_rescued_responses,\n          \"action_dispatch.debug_exception_log_level\" => ActiveSupport::Logger.const_get(config.action_dispatch.debug_exception_log_level.to_s.upcase),\n          \"action_dispatch.logger\" => Rails.logger,\n          \"action_dispatch.backtrace_cleaner\" => Rails.backtrace_cleaner,\n          \"action_dispatch.key_generator\" => key_generator,\n          \"action_dispatch.http_auth_salt\" => config.action_dispatch.http_auth_salt,\n          \"action_dispatch.signed_cookie_salt\" => config.action_dispatch.signed_cookie_salt,\n          \"action_dispatch.encrypted_cookie_salt\" => config.action_dispatch.encrypted_cookie_salt,\n          \"action_dispatch.encrypted_signed_cookie_salt\" => config.action_dispatch.encrypted_signed_cookie_salt,\n          \"action_dispatch.authenticated_encrypted_cookie_salt\" => config.action_dispatch.authenticated_encrypted_cookie_salt,\n          \"action_dispatch.use_authenticated_cookie_encryption\" => config.action_dispatch.use_authenticated_cookie_encryption,\n          \"action_dispatch.encrypted_cookie_cipher\" => config.action_dispatch.encrypted_cookie_cipher,\n          \"action_dispatch.signed_cookie_digest\" => config.action_dispatch.signed_cookie_digest,\n          \"action_dispatch.cookies_serializer\" => config.action_dispatch.cookies_serializer,\n          \"action_dispatch.cookies_digest\" => config.action_dispatch.cookies_digest,\n          \"action_dispatch.cookies_rotations\" => config.action_dispatch.cookies_rotations,\n          \"action_dispatch.cookies_same_site_protection\" => coerce_same_site_protection(config.action_dispatch.cookies_same_site_protection),\n          \"action_dispatch.use_cookies_with_metadata\" => config.action_dispatch.use_cookies_with_metadata,\n          \"action_dispatch.content_security_policy\" => config.content_security_policy,\n          \"action_dispatch.content_security_policy_report_only\" => config.content_security_policy_report_only,\n          \"action_dispatch.content_security_policy_nonce_generator\" => config.content_security_policy_nonce_generator,\n          \"action_dispatch.content_security_policy_nonce_directives\" => config.content_security_policy_nonce_directives,\n          \"action_dispatch.permissions_policy\" => config.permissions_policy,\n        )\n    end",
    "comment": "Stores some of the \\Rails initial environment parameters which will be used by middlewares and engines to configure themselves.",
    "label": "",
    "id": "3611"
  },
  {
    "raw_code": "def rake_tasks(&block)\n      self.class.rake_tasks(&block)\n    end",
    "comment": "If you try to define a set of Rake tasks on the instance, these will get passed up to the Rake tasks defined on the application's class.",
    "label": "",
    "id": "3612"
  },
  {
    "raw_code": "def initializer(name, opts = {}, &block)\n      self.class.initializer(name, opts, &block)\n    end",
    "comment": "Sends the initializers to the +initializer+ method defined in the Rails::Initializable module. Each Rails::Application class has its own set of initializers, as defined by the Initializable module.",
    "label": "",
    "id": "3613"
  },
  {
    "raw_code": "def runner(&blk)\n      self.class.runner(&blk)\n    end",
    "comment": "Sends any runner called in the instance of a new application up to the +runner+ method defined in Rails::Railtie.",
    "label": "",
    "id": "3614"
  },
  {
    "raw_code": "def console(&blk)\n      self.class.console(&blk)\n    end",
    "comment": "Sends any console called in the instance of a new application up to the +console+ method defined in Rails::Railtie.",
    "label": "",
    "id": "3615"
  },
  {
    "raw_code": "def generators(&blk)\n      self.class.generators(&blk)\n    end",
    "comment": "Sends any generators called in the instance of a new application up to the +generators+ method defined in Rails::Railtie.",
    "label": "",
    "id": "3616"
  },
  {
    "raw_code": "def server(&blk)\n      self.class.server(&blk)\n    end",
    "comment": "Sends any server called in the instance of a new application up to the +server+ method defined in Rails::Railtie.",
    "label": "",
    "id": "3617"
  },
  {
    "raw_code": "def isolate_namespace(mod)\n      self.class.isolate_namespace(mod)\n    end",
    "comment": "Sends the +isolate_namespace+ method up to the class method.",
    "label": "",
    "id": "3618"
  },
  {
    "raw_code": "def self.add_lib_to_load_path!(root) # :nodoc:\n      path = File.join(root, \"lib\")\n      if File.exist?(path) && !$LOAD_PATH.include?(path)\n        $LOAD_PATH.unshift(path)\n      end",
    "comment": "Rails internal API This method is called just after an application inherits from Rails::Application, allowing the developer to load classes in lib and use them during application configuration.  class MyApplication < Rails::Application require \"my_backend\" # in lib/my_backend config.i18n.backend = MyBackend end  Notice this method takes into consideration the default root path. So if you are changing config.root inside your application definition or having a custom Rails application, you will need to add lib to $LOAD_PATH on your own in case you need to load files in lib/ during the application configuration as well.",
    "label": "",
    "id": "3619"
  },
  {
    "raw_code": "def watchable_args # :nodoc:\n      files, dirs = config.watchable_files.dup, config.watchable_dirs.dup\n\n      Rails.autoloaders.main.dirs.each do |path|\n        dirs[path] = [:rb]\n      end",
    "comment": "Returns an array of file paths appended with a hash of directories-extensions suitable for ActiveSupport::FileUpdateChecker API.",
    "label": "",
    "id": "3620"
  },
  {
    "raw_code": "def initialize!(group = :default) # :nodoc:\n      raise \"Application has been already initialized.\" if @initialized\n      run_initializers(group, self)\n      @initialized = true\n      self\n    end",
    "comment": "Initialize the application passing the given group. By default, the group is :default",
    "label": "",
    "id": "3621"
  },
  {
    "raw_code": "def secret_key_base\n      config.secret_key_base\n    end",
    "comment": "The secret_key_base is used as the input secret to the application's key generator, which in turn is used to create all ActiveSupport::MessageVerifier and ActiveSupport::MessageEncryptor instances, including the ones that sign and encrypt cookies.  We look for it first in <tt>ENV[\"SECRET_KEY_BASE\"]</tt>, then in +credentials.secret_key_base+. For most applications, the correct place to store it is in the encrypted credentials file.  In development and test, if the secret_key_base is still empty, it is randomly generated and stored in a temporary file in <tt>tmp/local_secret.txt</tt>.  Generating a random secret_key_base and storing it in <tt>tmp/local_secret.txt</tt> can also be triggered by setting <tt>ENV[\"SECRET_KEY_BASE_DUMMY\"]</tt>. This is useful when precompiling assets for production as part of a build step that otherwise does not need access to the production secrets.  Dockerfile example: <tt>RUN SECRET_KEY_BASE_DUMMY=1 bundle exec rails assets:precompile</tt>.",
    "label": "",
    "id": "3622"
  },
  {
    "raw_code": "def credentials\n      @credentials ||= encrypted(config.credentials.content_path, key_path: config.credentials.key_path)\n    end",
    "comment": "Returns an ActiveSupport::EncryptedConfiguration instance for the credentials file specified by +config.credentials.content_path+.  By default, +config.credentials.content_path+ will point to either <tt>config/credentials/#{environment}.yml.enc</tt> for the current environment (for example, +config/credentials/production.yml.enc+ for the +production+ environment), or +config/credentials.yml.enc+ if that file does not exist.  The encryption key is taken from either <tt>ENV[\"RAILS_MASTER_KEY\"]</tt>, or from the file specified by +config.credentials.key_path+. By default, +config.credentials.key_path+ will point to either <tt>config/credentials/#{environment}.key</tt> for the current environment, or +config/master.key+ if that file does not exist.",
    "label": "",
    "id": "3623"
  },
  {
    "raw_code": "def encrypted(path, key_path: \"config/master.key\", env_key: \"RAILS_MASTER_KEY\")\n      ActiveSupport::EncryptedConfiguration.new(\n        config_path: Rails.root.join(path),\n        key_path: Rails.root.join(key_path),\n        env_key: env_key,\n        raise_if_missing_key: config.require_master_key\n      )\n    end",
    "comment": "Returns an ActiveSupport::EncryptedConfiguration instance for an encrypted file. By default, the encryption key is taken from either <tt>ENV[\"RAILS_MASTER_KEY\"]</tt>, or from the +config/master.key+ file.  my_config = Rails.application.encrypted(\"config/my_config.enc\")  my_config.read # => \"foo:\\n  bar: 123\\n\"  my_config.foo.bar # => 123  Encrypted files can be edited with the <tt>bin/rails encrypted:edit</tt> command. (See the output of <tt>bin/rails encrypted:edit --help</tt> for more information.)",
    "label": "",
    "id": "3624"
  },
  {
    "raw_code": "def migration_railties # :nodoc:\n      ordered_railties.flatten - [self]\n    end",
    "comment": "Return an array of railties respecting the order they're loaded and the order specified by the +railties_order+ config.  While running initializers we need engines in reverse order here when copying migrations from railties ; we need them in the order given by +railties_order+.",
    "label": "",
    "id": "3625"
  },
  {
    "raw_code": "def eager_load!\n      Rails.autoloaders.each(&:eager_load)\n    end",
    "comment": "Eager loads the application code.",
    "label": "",
    "id": "3626"
  },
  {
    "raw_code": "def ordered_railties # :nodoc:\n      @ordered_railties ||= begin\n        order = config.railties_order.map do |railtie|\n          if railtie == :main_app\n            self\n          elsif railtie.respond_to?(:instance)\n            railtie.instance\n          else\n            railtie\n          end",
    "comment": "Returns the ordered railties for this application considering railties_order.",
    "label": "",
    "id": "3627"
  },
  {
    "raw_code": "def self.register_directory(label, path, test_directory: false)\n      self.directories << [label, path]\n      self.test_types << label if test_directory\n    end",
    "comment": "Add directories to the output of the <tt>bin/rails stats</tt> command.  Rails::CodeStatistics.register_directory(\"My Directory\", \"path/to/dir\")  For directories that contain test code, set the <tt>test_directory</tt> argument to true.  Rails::CodeStatistics.register_directory(\"Model specs\", \"spec/models\", test_directory: true)",
    "label": "",
    "id": "3628"
  },
  {
    "raw_code": "def invoke(full_namespace, args = [], **config)\n        args = [\"--help\"] if rails_new_with_no_path?(args)\n\n        full_namespace = full_namespace.to_s\n        namespace, command_name = split_namespace(full_namespace)\n        command = find_by_namespace(namespace, command_name)\n\n        with_argv(args) do\n          if command && command.all_commands[command_name]\n            command.perform(command_name, args, config)\n          else\n            invoke_rake(full_namespace, args, config)\n          end",
    "comment": "Receives a namespace, arguments, and the behavior to invoke the command.",
    "label": "",
    "id": "3629"
  },
  {
    "raw_code": "def find_by_namespace(namespace, command_name = nil) # :nodoc:\n        lookups = [ namespace ]\n        lookups << \"#{namespace}:#{command_name}\" if command_name\n        lookups.concat lookups.map { |lookup| \"rails:#{lookup}\" }\n\n        lookup(lookups)\n\n        namespaces = subclasses.index_by(&:namespace)\n        namespaces[(lookups & namespaces.keys).first]\n      end",
    "comment": "Rails finds namespaces similar to Thor, it only adds one rule:  Command names must end with \"_command.rb\". This is required because Rails looks in load paths and loads the command just before it's going to be used.  find_by_namespace :webrat, :integration  Will search for the following commands:  \"webrat\", \"webrat:integration\", \"rails:webrat\", \"rails:webrat:integration\" ",
    "label": "",
    "id": "3630"
  },
  {
    "raw_code": "def root\n        if defined?(ENGINE_ROOT)\n          Pathname.new(ENGINE_ROOT)\n        else\n          application_root\n        end",
    "comment": "Returns the root of the \\Rails engine or app running the command.",
    "label": "",
    "id": "3631"
  },
  {
    "raw_code": "def find(path)\n        expanded_path = File.expand_path path\n        Rails::Engine.subclasses.each do |klass|\n          engine = klass.instance\n          return engine if File.expand_path(engine.root) == expanded_path\n        end",
    "comment": "Finds engine with given path.",
    "label": "",
    "id": "3632"
  },
  {
    "raw_code": "def load_console(app = self)\n      run_console_blocks(app)\n      self\n    end",
    "comment": "Load console and invoke the registered hooks. Check Rails::Railtie.console for more info.",
    "label": "",
    "id": "3633"
  },
  {
    "raw_code": "def load_runner(app = self)\n      run_runner_blocks(app)\n      self\n    end",
    "comment": "Load \\Rails runner and invoke the registered hooks. Check Rails::Railtie.runner for more info.",
    "label": "",
    "id": "3634"
  },
  {
    "raw_code": "def load_tasks(app = self)\n      require \"rake\"\n      run_tasks_blocks(app)\n      self\n    end",
    "comment": "Load Rake and railties tasks, and invoke the registered hooks. Check Rails::Railtie.rake_tasks for more info.",
    "label": "",
    "id": "3635"
  },
  {
    "raw_code": "def load_generators(app = self)\n      require \"rails/generators\"\n      run_generators_blocks(app)\n      Rails::Generators.configure!(app.config.generators)\n      self\n    end",
    "comment": "Load \\Rails generators and invoke the registered hooks. Check Rails::Railtie.generators for more info.",
    "label": "",
    "id": "3636"
  },
  {
    "raw_code": "def load_server(app = self)\n      run_server_blocks(app)\n      self\n    end",
    "comment": "Invoke the server registered hooks. Check Rails::Railtie.server for more info.",
    "label": "",
    "id": "3637"
  },
  {
    "raw_code": "def helpers\n      @helpers ||= begin\n        helpers = Module.new\n        AbstractController::Helpers.helper_modules_from_paths(helpers_paths).each do |mod|\n          helpers.include(mod)\n        end",
    "comment": "Returns a module with all the helpers defined for the engine.",
    "label": "",
    "id": "3638"
  },
  {
    "raw_code": "def helpers_paths\n      paths[\"app/helpers\"].existent\n    end",
    "comment": "Returns all registered helpers paths.",
    "label": "",
    "id": "3639"
  },
  {
    "raw_code": "def app\n      @app || @app_build_lock.synchronize {\n        @app ||= begin\n          stack = default_middleware_stack\n          config.middleware = build_middleware.merge_into(stack)\n          config.middleware.build(endpoint)\n        end",
    "comment": "Returns the underlying Rack application for this engine.",
    "label": "",
    "id": "3640"
  },
  {
    "raw_code": "def endpoint\n      self.class.endpoint || routes\n    end",
    "comment": "Returns the endpoint for this engine. If none is registered, defaults to an ActionDispatch::Routing::RouteSet.",
    "label": "",
    "id": "3641"
  },
  {
    "raw_code": "def call(env)\n      req = build_request env\n      app.call req.env\n    end",
    "comment": "Define the Rack API for this engine.",
    "label": "",
    "id": "3642"
  },
  {
    "raw_code": "def env_config\n      @env_config ||= {}\n    end",
    "comment": "Defines additional Rack env configuration that is added on each call.",
    "label": "",
    "id": "3643"
  },
  {
    "raw_code": "def routes(&block)\n      @routes ||= config.route_set_class.new_with_config(config)\n      @routes.append(&block) if block_given?\n      @routes\n    end",
    "comment": "Defines the routes for this engine. If a block is given to routes, it is appended to the engine.",
    "label": "",
    "id": "3644"
  },
  {
    "raw_code": "def config\n      @config ||= Engine::Configuration.new(self.class.find_root(self.class.called_from))\n    end",
    "comment": "Define the configuration object for the engine.",
    "label": "",
    "id": "3645"
  },
  {
    "raw_code": "def load_seed\n      seed_file = paths[\"db/seeds.rb\"].existent.first\n      run_callbacks(:load_seed) { load(seed_file) } if seed_file\n    end",
    "comment": "Load data from db/seeds.rb file. It can be used in to load engines' seeds, e.g.:  Blog::Engine.load_seed",
    "label": "",
    "id": "3646"
  },
  {
    "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of \\Rails as a +Gem::Version+.",
    "label": "",
    "id": "3647"
  },
  {
    "raw_code": "def fallbacks\n        @fallbacks ||= {}\n      end",
    "comment": "Hold configured generators fallbacks. If a plugin developer wants a generator group to fall back to another group in case of missing generators, they can add a fallback.  For example, shoulda is considered a +test_framework+ and is an extension of +test_unit+. However, most part of shoulda generators are similar to +test_unit+ ones.  Shoulda then can tell generators to search for +test_unit+ generators when some of them are not available by adding a fallback:  Rails::Generators.fallbacks[:shoulda] = :test_unit",
    "label": "",
    "id": "3648"
  },
  {
    "raw_code": "def api_only!\n        hide_namespaces \"assets\", \"helper\", \"css\", \"js\"\n\n        options[:rails].merge!(\n          api: true,\n          assets: false,\n          helper: false,\n          template_engine: nil\n        )\n\n        options[:mailer] ||= {}\n        options[:mailer][:template_engine] ||= :erb\n      end",
    "comment": "Configure generators for API only applications. It basically hides everything that is usually browser related, such as assets and session migration generators, and completely disable helpers and assets so generators such as scaffold won't create them.",
    "label": "",
    "id": "3649"
  },
  {
    "raw_code": "def hidden_namespaces\n        @hidden_namespaces ||= begin\n          orm      = options[:rails][:orm]\n          test     = options[:rails][:test_framework]\n          template = options[:rails][:template_engine]\n\n          [\n            \"rails\",\n            \"resource_route\",\n            \"#{orm}:migration\",\n            \"#{orm}:model\",\n            \"#{test}:controller\",\n            \"#{test}:helper\",\n            \"#{test}:integration\",\n            \"#{test}:system\",\n            \"#{test}:mailer\",\n            \"#{test}:model\",\n            \"#{test}:scaffold\",\n            \"#{test}:view\",\n            \"#{test}:job\",\n            \"#{template}:controller\",\n            \"#{template}:scaffold\",\n            \"#{template}:mailer\",\n            \"action_text:install\",\n            \"action_mailbox:install\",\n            \"devcontainer\"\n          ].tap do |h|\n            h << \"test_unit\" if test.to_s != \"test_unit\"\n          end",
    "comment": "Returns an array of generator namespaces that are hidden. Generator namespaces may be hidden for a variety of reasons. Some are aliased such as \"rails:migration\" and can be invoked with the shorter \"migration\".",
    "label": "",
    "id": "3650"
  },
  {
    "raw_code": "def help(command = \"generate\")\n        puts \"Usage:\"\n        puts \"  bin/rails #{command} GENERATOR [args] [options]\"\n        puts\n        puts \"General options:\"\n        puts \"  -h, [--help]     # Print generator's options and usage\"\n        puts \"  -p, [--pretend]  # Run but do not make any changes\"\n        puts \"  -f, [--force]    # Overwrite files that already exist\"\n        puts \"  -s, [--skip]     # Skip files that already exist\"\n        puts \"  -q, [--quiet]    # Suppress status output\"\n        puts\n        puts \"Please choose a generator below.\"\n        puts\n\n        print_generators\n      end",
    "comment": "Show help message with available generators.",
    "label": "",
    "id": "3651"
  },
  {
    "raw_code": "def find_by_namespace(name, base = nil, context = nil) # :nodoc:\n        lookups = []\n        lookups << \"#{base}:#{name}\"    if base\n        lookups << \"#{name}:#{context}\" if context\n\n        unless base || context\n          unless name.to_s.include?(?:)\n            lookups << \"#{name}:#{name}\"\n            lookups << \"rails:#{name}\"\n          end",
    "comment": "Rails finds namespaces similar to Thor, it only adds one rule:  Generators names must end with \"_generator.rb\". This is required because Rails looks in load paths and loads the generator just before it's going to be used.  find_by_namespace :webrat, :rails, :integration  Will search for the following generators:  \"rails:webrat\", \"webrat:integration\", \"webrat\"  Notice that \"rails:generators:webrat\" could be loaded as well, what Rails looks for is the first and last parts of the namespace.",
    "label": "",
    "id": "3652"
  },
  {
    "raw_code": "def invoke(namespace, args = ARGV, config = {})\n        names = namespace.to_s.split(\":\")\n        if klass = find_by_namespace(names.pop, names.any? && names.join(\":\"))\n          args << \"--help\" if args.empty? && klass.arguments.any?(&:required?)\n          klass.start(args, config)\n          run_after_generate_callback if config[:behavior] == :invoke\n        else\n          options = sorted_groups.flat_map(&:last)\n          error = Command::CorrectableNameError.new(\"Could not find generator '#{namespace}'.\", namespace, options)\n\n          puts <<~MSG\n            #{error.detailed_message}\n            Run `bin/rails generate --help` for more options.\n          MSG\n          exit 1\n        end",
    "comment": "Receives a namespace, arguments, and the behavior to invoke the generator. It's used as the default entry point for generate, destroy, and update commands.",
    "label": "",
    "id": "3653"
  },
  {
    "raw_code": "def invoke_fallbacks_for(name, base)\n          return nil unless base && fallbacks[base.to_sym]\n          invoked_fallbacks = []\n\n          Array(fallbacks[base.to_sym]).each do |fallback|\n            next if invoked_fallbacks.include?(fallback)\n            invoked_fallbacks << fallback\n\n            klass = find_by_namespace(name, fallback)\n            return klass if klass\n          end",
    "comment": "Try fallbacks for the given base.",
    "label": "",
    "id": "3654"
  },
  {
    "raw_code": "def existent\n        expanded.select do |f|\n          does_exist = File.exist?(f)\n\n          if !does_exist && File.symlink?(f)\n            raise \"File #{f.inspect} is a symlink that does not point to a valid file\"\n          end",
    "comment": "Returns all expanded paths but only if they exist in the filesystem.",
    "label": "",
    "id": "3655"
  },
  {
    "raw_code": "def instance\n        @instance ||= new\n      end",
    "comment": "Since Rails::Railtie cannot be instantiated, any methods that call +instance+ are intended to be called only on subclasses of a Railtie.",
    "label": "",
    "id": "3656"
  },
  {
    "raw_code": "def configure(&block)\n        instance.configure(&block)\n      end",
    "comment": "Allows you to configure the railtie. This is the same method seen in Railtie::Configurable, but this module is no longer required for all subclasses of Railtie so we provide the class method here.",
    "label": "",
    "id": "3657"
  },
  {
    "raw_code": "def method_missing(name, ...)\n          if !abstract_railtie? && instance.respond_to?(name)\n            instance.public_send(name, ...)\n          else\n            super\n          end",
    "comment": "If the class method does not have a method, then send the method call to the Railtie instance.",
    "label": "",
    "id": "3658"
  },
  {
    "raw_code": "def register_block_for(type, &blk)\n          var_name = \"@#{type}\"\n          blocks = instance_variable_defined?(var_name) ? instance_variable_get(var_name) : instance_variable_set(var_name, [])\n          blocks << blk if blk\n          blocks\n        end",
    "comment": "receives an instance variable identifier, set the variable value if is blank and append given block to value, which will be used later in `#each_registered_block(type, &block)`",
    "label": "",
    "id": "3659"
  },
  {
    "raw_code": "def config\n      @config ||= Railtie::Configuration.new\n    end",
    "comment": "This is used to create the <tt>config</tt> object on Railties, an instance of Railtie::Configuration, that is used by Railties and Application to store related configuration.",
    "label": "",
    "id": "3660"
  },
  {
    "raw_code": "def each_registered_block(type, &block)\n        klass = self.class\n        while klass.respond_to?(type)\n          klass.public_send(type).each(&block)\n          klass = klass.superclass\n        end",
    "comment": "run `&block` in every registered block in `#register_block_for`",
    "label": "",
    "id": "3661"
  },
  {
    "raw_code": "def self.register_directories(*dirs)\n        directories.push(*dirs)\n      end",
    "comment": "Registers additional directories to be included Rails::SourceAnnotationExtractor::Annotation.register_directories(\"spec\", \"another\")",
    "label": "",
    "id": "3662"
  },
  {
    "raw_code": "def self.register_tags(*additional_tags)\n        tags.push(*additional_tags)\n      end",
    "comment": "Registers additional tags Rails::SourceAnnotationExtractor::Annotation.register_tags(\"TESTME\", \"DEPRECATEME\")",
    "label": "",
    "id": "3663"
  },
  {
    "raw_code": "def self.register_extensions(*exts, &block)\n        extensions[/\\.(#{exts.join(\"|\")})$/] = block\n      end",
    "comment": "Registers new Annotations File Extensions Rails::SourceAnnotationExtractor::Annotation.register_extensions(\"css\", \"scss\", \"sass\", \"less\", \"js\") { |tag| /\\/\\/\\s*(#{tag}):?\\s*(.*)$/ }",
    "label": "",
    "id": "3664"
  },
  {
    "raw_code": "def to_s(options = {})\n        s = +\"[#{line.to_s.rjust(options[:indent])}] \"\n        s << \"[#{tag}] \" if options[:tag]\n        s << text\n      end",
    "comment": "Returns a representation of the annotation that looks like this:  [126] [TODO] This algorithm is simple and clearly correct, make it faster.  If +options+ has a flag <tt>:tag</tt> the tag is shown as in the example above. Otherwise the string contains just line and text.",
    "label": "",
    "id": "3665"
  },
  {
    "raw_code": "def self.enumerate(tag = nil, options = {})\n      tag ||= Annotation.tags.join(\"|\")\n      extractor = new(tag)\n      dirs = options.delete(:dirs) || Annotation.directories\n      extractor.display(extractor.find(dirs), options)\n    end",
    "comment": "Prints all annotations with tag +tag+ under the root directories +app+, +config+, +db+, +lib+, and +test+ (recursively).  If +tag+ is <tt>nil</tt>, annotations with either default or registered tags are printed.  Specific directories can be explicitly set using the <tt>:dirs</tt> key in +options+.  Rails::SourceAnnotationExtractor.enumerate 'TODO|FIXME', dirs: %w(app lib), tag: true  If +options+ has a <tt>:tag</tt> flag, it will be passed to each annotation's +to_s+.  See SourceAnnotationExtractor#find_in for a list of file extensions that will be taken into account.  This class method is the single entry point for the <tt>rails notes</tt> command.",
    "label": "",
    "id": "3666"
  },
  {
    "raw_code": "def find(dirs)\n      dirs.inject({}) { |h, dir| h.update(find_in(dir)) }\n    end",
    "comment": "Returns a hash that maps filenames under +dirs+ (recursively) to arrays with their annotations.",
    "label": "",
    "id": "3667"
  },
  {
    "raw_code": "def find_in(dir)\n      results = {}\n\n      Dir.glob(\"#{dir}/*\") do |item|\n        next if File.basename(item).start_with?(\".\")\n\n        if File.directory?(item)\n          results.update(find_in(item))\n        else\n          extension = Annotation.extensions.detect do |regexp, _block|\n            regexp.match(item)\n          end",
    "comment": "Returns a hash that maps filenames under +dir+ (recursively) to arrays with their annotations. Files with extensions registered in <tt>Rails::SourceAnnotationExtractor::Annotation.extensions</tt> are taken into account. Only files with annotations are included.",
    "label": "",
    "id": "3668"
  },
  {
    "raw_code": "def display(results, options = {})\n      options[:indent] = results.flat_map { |f, a| a.map(&:line) }.max.to_s.size\n      results.keys.sort.each do |file|\n        puts \"#{file}:\"\n        results[file].each do |note|\n          puts \"  * #{note.to_s(options)}\"\n        end",
    "comment": "Prints the mapping from filenames to annotations in +results+ ordered by filename. The +options+ hash is passed to each annotation's +to_s+.",
    "label": "",
    "id": "3669"
  },
  {
    "raw_code": "def self.version\n    VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of \\Rails as a string.",
    "label": "",
    "id": "3670"
  },
  {
    "raw_code": "def desc(description)\n        # no-op\n      end",
    "comment": "Hack, ignore the desc calls performed by the original initializer.",
    "label": "",
    "id": "3671"
  },
  {
    "raw_code": "def setup_horo_variables # :nodoc:\n        ENV[\"HORO_PROJECT_NAME\"]    = \"Ruby on Rails\"\n        ENV[\"HORO_PROJECT_VERSION\"] = rails_version\n        ENV[\"HORO_BADGE_VERSION\"]   = badge_version\n        ENV[\"HORO_CANONICAL_URL\"]   = canonical_url\n      end",
    "comment": "These variables are used by the sdoc template",
    "label": "",
    "id": "3672"
  },
  {
    "raw_code": "def load_defaults(target_version)\n        # To introduce a change in behavior, follow these steps:\n        # 1. Add an accessor on the target object (e.g. the ActiveJob class for\n        #    global Active Job config).\n        # 2. Set a default value there preserving existing behavior for existing\n        #    applications.\n        # 3. Implement the behavior change based on the config value.\n        # 4. In the section below corresponding to the next release of Rails,\n        #    configure the default value.\n        # 5. Add a commented out section in the `new_framework_defaults` to\n        #    configure the default value again.\n        # 6. Update the guide in `configuring.md`.\n\n        # To remove configurable deprecated behavior, follow these steps:\n        # 1. Update or remove the entry in the guides.\n        # 2. Remove the references below.\n        # 3. Remove the legacy code paths and config check.\n        # 4. Remove the config accessor.\n\n        case target_version.to_s\n        when \"5.0\"\n          if respond_to?(:action_controller)\n            action_controller.per_form_csrf_tokens = true\n            action_controller.forgery_protection_origin_check = true\n          end",
    "comment": "Loads default configuration values for a target version. This includes defaults for versions prior to the target version. See the {configuration guide}[https://guides.rubyonrails.org/configuring.html#versioned-default-values] for the default values associated with a particular version.",
    "label": "",
    "id": "3673"
  },
  {
    "raw_code": "def load_database_yaml # :nodoc:\n        if path = paths[\"config/database\"].existent.first\n          require \"rails/application/dummy_config\"\n          original_rails_config = Rails.application.config\n\n          begin\n            Rails.application.config = DummyConfig.new(original_rails_config)\n            ActiveSupport::ConfigurationFile.parse(Pathname.new(path))\n          ensure\n            Rails.application.config = original_rails_config\n          end",
    "comment": "Load the <tt>config/database.yml</tt> to create the Rake tasks for multiple databases without loading the environment and filling in the environment specific configuration values.  Do not use this method, use #database_configuration instead.",
    "label": "",
    "id": "3674"
  },
  {
    "raw_code": "def database_configuration\n        path = paths[\"config/database\"].existent.first\n        yaml = Pathname.new(path) if path\n\n        config = if yaml&.exist?\n          loaded_yaml = ActiveSupport::ConfigurationFile.parse(yaml)\n          if (shared = loaded_yaml.delete(\"shared\"))\n            loaded_yaml.each do |env, config|\n              if config.is_a?(Hash) && config.values.all?(Hash)\n                if shared.is_a?(Hash) && shared.values.all?(Hash)\n                  config.map do |name, sub_config|\n                    sub_config.reverse_merge!(shared[name])\n                  end",
    "comment": "Loads and returns the entire raw configuration of database from values stored in <tt>config/database.yml</tt>.",
    "label": "",
    "id": "3675"
  },
  {
    "raw_code": "def session_store(new_session_store = nil, **options)\n        if new_session_store\n          @session_store = new_session_store\n          @session_options = options || {}\n        else\n          case @session_store\n          when :disabled\n            nil\n          when Symbol\n            ActionDispatch::Session.resolve_store(@session_store)\n          else\n            @session_store\n          end",
    "comment": "Specifies what class to use to store the session. Possible values are +:cache_store+, +:cookie_store+, +:mem_cache_store+, a custom store, or +:disabled+. +:disabled+ tells \\Rails not to deal with sessions.  Additional options will be set as +session_options+:  config.session_store :cookie_store, key: \"_your_app_session\" config.session_options # => {key: \"_your_app_session\"}  If a custom store is specified as a symbol, it will be resolved to the +ActionDispatch::Session+ namespace:  # use ActionDispatch::Session::MyCustomStore as the session store config.session_store :my_custom_store",
    "label": "",
    "id": "3676"
  },
  {
    "raw_code": "def content_security_policy(&block)\n        if block_given?\n          @content_security_policy = ActionDispatch::ContentSecurityPolicy.new(&block)\n        else\n          @content_security_policy\n        end",
    "comment": "Configures the ActionDispatch::ContentSecurityPolicy.",
    "label": "",
    "id": "3677"
  },
  {
    "raw_code": "def permissions_policy(&block)\n        if block_given?\n          @permissions_policy = ActionDispatch::PermissionsPolicy.new(&block)\n        else\n          @permissions_policy\n        end",
    "comment": "Configures the ActionDispatch::PermissionsPolicy.",
    "label": "",
    "id": "3678"
  },
  {
    "raw_code": "def set_application_directory!\n        Dir.chdir(File.expand_path(\"../..\", APP_PATH)) unless File.exist?(File.expand_path(\"config.ru\"))\n      end",
    "comment": "Change to the application's path if there is no <tt>config.ru</tt> file in current directory. This allows us to run <tt>rails server</tt> from other directories, but still get the main <tt>config.ru</tt> and properly set the <tt>tmp</tt> directory.",
    "label": "",
    "id": "3679"
  },
  {
    "raw_code": "def engine?\n          defined?(ENGINE_ROOT)\n        end",
    "comment": "Returns true when the app is a \\Rails engine.",
    "label": "",
    "id": "3680"
  },
  {
    "raw_code": "def desc(usage = nil, description = nil, options = {})\n          if usage\n            super\n          else\n            class_usage\n          end",
    "comment": "Tries to get the description from a USAGE file one folder above the command root.",
    "label": "",
    "id": "3681"
  },
  {
    "raw_code": "def namespace(name = nil)\n          if name\n            super\n          else\n            @namespace ||= super.chomp(\"_command\").sub(/:command:/, \":\")\n          end",
    "comment": "Convenience method to get the namespace from the class name. It's the same as Thor default except that the Command at the end of the class is removed.",
    "label": "",
    "id": "3682"
  },
  {
    "raw_code": "def hide_command!\n          Rails::Command.hidden_commands << self\n        end",
    "comment": "Convenience method to hide this command from the available ones when running rails command.",
    "label": "",
    "id": "3683"
  },
  {
    "raw_code": "def help(shell, *) # :nodoc:\n          super\n          shell.say class_usage if class_usage\n        end",
    "comment": "Override Thor's class-level help to also show the USAGE.",
    "label": "",
    "id": "3684"
  },
  {
    "raw_code": "def base_name\n          @base_name ||= if base = name.to_s.split(\"::\").first\n            base.underscore\n          end",
    "comment": "Sets the base_name taking into account the current class namespace.  Rails::Command::TestCommand.base_name # => 'rails'",
    "label": "",
    "id": "3685"
  },
  {
    "raw_code": "def command_name\n          @command_name ||= if command = name.to_s.split(\"::\").last\n            command.chomp!(\"Command\")\n            command.underscore\n          end",
    "comment": "Return command name without namespaces.  Rails::Command::TestCommand.command_name # => 'test'",
    "label": "",
    "id": "3686"
  },
  {
    "raw_code": "def usage_path\n          @usage_path = resolve_path(\"USAGE\") unless defined?(@usage_path)\n          @usage_path\n        end",
    "comment": "Path to lookup a USAGE description in a file.",
    "label": "",
    "id": "3687"
  },
  {
    "raw_code": "def default_command_root\n          @default_command_root = resolve_path(\".\") unless defined?(@default_command_root)\n          @default_command_root\n        end",
    "comment": "Default file root to place extra files a command might need, placed one folder above the command file.  For a Rails::Command::TestCommand placed in <tt>rails/command/test_command.rb</tt> would return <tt>rails/test</tt>.",
    "label": "",
    "id": "3688"
  },
  {
    "raw_code": "def create_command(meth)\n            if meth == \"perform\"\n              alias_method command_name, meth\n            else\n              # Prevent exception about command without usage.\n              # Some commands define their documentation differently.\n              @usage ||= meth\n              @desc  ||= \"\"\n\n              super\n            end",
    "comment": "Allow the command method to be called perform.",
    "label": "",
    "id": "3689"
  },
  {
    "raw_code": "def no_color!\n          Thor::Base.shell = Thor::Shell::Basic\n        end",
    "comment": "Remove the color from output.",
    "label": "",
    "id": "3690"
  },
  {
    "raw_code": "def subclasses\n          @subclasses ||= []\n        end",
    "comment": "Track all command subclasses.",
    "label": "",
    "id": "3691"
  },
  {
    "raw_code": "def print_list(base, namespaces)\n            return if namespaces.empty?\n            puts \"#{base.camelize}:\"\n\n            namespaces.each do |namespace|\n              puts(\"  #{namespace}\")\n            end",
    "comment": "Prints a list of generators.",
    "label": "",
    "id": "3692"
  },
  {
    "raw_code": "def lookup(namespaces)\n            paths = namespaces_to_paths(namespaces)\n\n            paths.each do |raw_path|\n              lookup_paths.each do |base|\n                path = \"#{base}/#{raw_path}_#{command_type}\"\n\n                begin\n                  require path\n                  return\n                rescue LoadError => e\n                  raise unless /#{Regexp.escape(path)}$/.match?(e.message)\n                rescue Exception => e\n                  warn \"[WARNING] Could not load #{command_type} #{path.inspect}. Error: #{e.message}.\\n#{e.backtrace.join(\"\\n\")}\"\n                end",
    "comment": "Receives namespaces in an array and tries to find matching generators in the load path.",
    "label": "",
    "id": "3693"
  },
  {
    "raw_code": "def lookup!\n            $LOAD_PATH.each do |base|\n              Dir[File.join(base, *file_lookup_paths)].each do |path|\n                path = path.delete_prefix(\"#{base}/\")\n                require path\n              rescue Exception\n                # No problem\n              end",
    "comment": "This will try to load any command in the load path to show in help.",
    "label": "",
    "id": "3694"
  },
  {
    "raw_code": "def namespaces_to_paths(namespaces)\n            paths = []\n            namespaces.each do |namespace|\n              pieces = namespace.split(\":\")\n              path = pieces.join(\"/\")\n              paths << \"#{path}/#{pieces.last}\"\n              paths << path\n            end",
    "comment": "Convert namespaces to paths by replacing \":\" for \"/\" and adding an extra lookup. For example, \"rails:model\" should be searched in both: \"rails/model/model_generator\" and \"rails/model_generator\".",
    "label": "",
    "id": "3695"
  },
  {
    "raw_code": "def self.exit_on_failure?\n        true\n      end",
    "comment": "We want to exit on failure to be kind to other libraries This is only when accessing via CLI",
    "label": "",
    "id": "3696"
  },
  {
    "raw_code": "def execute\n        ApplicationController.helpers\n      end",
    "comment": "This method assumes an +ApplicationController+ exists, and that it extends ActionController::Base.",
    "label": "",
    "id": "3697"
  },
  {
    "raw_code": "def execute\n        @controller ||= ApplicationController.new\n      end",
    "comment": "This method assumes an +ApplicationController+ exists, and that it extends ActionController::Base.",
    "label": "",
    "id": "3698"
  },
  {
    "raw_code": "def generators\n        @generators ||= Rails::Configuration::Generators.new\n        yield(@generators) if block_given?\n        @generators\n      end",
    "comment": "Holds generators configuration:  config.generators do |g| g.orm             :data_mapper, migration: true g.template_engine :haml g.test_framework  :rspec end  If you want to disable color in console, do:  config.generators.colorize_logging = false ",
    "label": "",
    "id": "3699"
  },
  {
    "raw_code": "def all_autoload_paths # :nodoc:\n        autoload_paths + paths.autoload_paths\n      end",
    "comment": "Private method that adds custom autoload paths to the ones defined by +paths+.",
    "label": "",
    "id": "3700"
  },
  {
    "raw_code": "def all_autoload_once_paths # :nodoc:\n        autoload_once_paths + paths.autoload_once\n      end",
    "comment": "Private method that adds custom autoload once paths to the ones defined by +paths+.",
    "label": "",
    "id": "3701"
  },
  {
    "raw_code": "def all_eager_load_paths # :nodoc:\n        eager_load_paths + paths.eager_load\n      end",
    "comment": "Private method that adds custom eager load paths to the ones defined by +paths+.",
    "label": "",
    "id": "3702"
  },
  {
    "raw_code": "def gem(*args)\n        options = args.extract_options!\n        name, *versions = args\n\n        # Set the message to be shown in logs. Uses the git repo if one is given,\n        # otherwise use name (version).\n        parts, message = [ quote(name) ], name.dup\n\n        # Output a comment above the gem declaration.\n        comment = options.delete(:comment)\n\n        if versions = versions.any? ? versions : options.delete(:version)\n          _versions = Array(versions)\n          _versions.each do |version|\n            parts << quote(version)\n          end",
    "comment": "Adds a +gem+ declaration to the +Gemfile+ for the specified gem.  gem \"rspec\", group: :test gem \"technoweenie-restful-authentication\", lib: \"restful-authentication\", source: \"http://gems.github.com/\" gem \"rails\", \"3.0\", git: \"https://github.com/rails/rails\" gem \"RedCloth\", \">= 4.1.0\", \"< 4.2.0\" gem \"rspec\", comment: \"Put this comment above the gem declaration\"  Note that this method only adds the gem to the +Gemfile+; it does not install the gem.  ==== Options  [+:version+] The version constraints for the gem, specified as a string or an array of strings:  gem \"my_gem\", version: \"~> 1.1\" gem \"my_gem\", version: [\">= 1.1\", \"< 2.0\"]  Alternatively, can be specified as one or more arguments following the gem name:  gem \"my_gem\", \">= 1.1\", \"< 2.0\"  [+:comment+] Outputs a comment above the +gem+ declaration in the +Gemfile+.  gem \"my_gem\", comment: \"First line.\\nSecond line.\"  Outputs:  # First line. # Second line. gem \"my_gem\"  [+:group+] The gem group in the +Gemfile+ that the gem belongs to.  [+:git+] The URL of the git repository for the gem.  Any additional options passed to this method will be appended to the +gem+ declaration in the +Gemfile+. For example:  gem \"my_gem\", comment: \"Edge my_gem\", git: \"https://example.com/my_gem.git\", branch: \"master\"  Outputs:  # Edge my_gem gem \"my_gem\", git: \"https://example.com/my_gem.git\", branch: \"master\" ",
    "label": "",
    "id": "3703"
  },
  {
    "raw_code": "def gem_group(*names, &block)\n        options = names.extract_options!\n        str = names.map(&:inspect)\n        str << quote(options) unless options.empty?\n        str = str.join(\", \")\n        log :gemfile, \"group #{str}\"\n\n        in_root do\n          append_file_with_newline \"Gemfile\", \"\\ngroup #{str} do\", force: true\n          with_indentation(&block)\n          append_file_with_newline \"Gemfile\", \"end\", force: true\n        end",
    "comment": "Wraps gem entries inside a group.  gem_group :development, :test do gem \"rspec-rails\" end",
    "label": "",
    "id": "3704"
  },
  {
    "raw_code": "def add_source(source, options = {}, &block)\n        log :source, source\n\n        in_root do\n          if block\n            append_file_with_newline \"Gemfile\", \"\\nsource #{quote(source)} do\", force: true\n            with_indentation(&block)\n            append_file_with_newline \"Gemfile\", \"end\", force: true\n          else\n            prepend_file \"Gemfile\", \"source #{quote(source)}\\n\", verbose: false\n          end",
    "comment": "Add the given source to +Gemfile+  If block is given, gem entries in block are wrapped into the source group.  add_source \"http://gems.github.com/\"  add_source \"http://gems.github.com/\" do gem \"rspec-rails\" end",
    "label": "",
    "id": "3705"
  },
  {
    "raw_code": "def environment(data = nil, options = {})\n        sentinel = \"class Application < Rails::Application\\n\"\n        env_file_sentinel = \"Rails.application.configure do\\n\"\n        data ||= yield if block_given?\n\n        in_root do\n          if options[:env].nil?\n            inject_into_file \"config/application.rb\", optimize_indentation(data, 4), after: sentinel, verbose: false\n          else\n            Array(options[:env]).each do |env|\n              inject_into_file \"config/environments/#{env}.rb\", optimize_indentation(data, 2), after: env_file_sentinel, verbose: false\n            end",
    "comment": "Adds configuration code to a \\Rails runtime environment.  By default, adds code inside the +Application+ class in +config/application.rb+ so that it applies to all environments.  environment %(config.asset_host = \"cdn.provider.com\")  Results in:  # config/application.rb class Application < Rails::Application config.asset_host = \"cdn.provider.com\" # ... end  If the +:env+ option is specified, the code will be added to the corresponding file in +config/environments+ instead.  environment %(config.asset_host = \"localhost:3000\"), env: \"development\"  Results in:  # config/environments/development.rb Rails.application.configure do config.asset_host = \"localhost:3000\" # ... end  +:env+ can also be an array. In which case, the code is added to each corresponding file in +config/environments+.  The code can also be specified as the return value of the block:  environment do %(config.asset_host = \"cdn.provider.com\") end  environment(nil, env: \"development\") do %(config.asset_host = \"localhost:3000\") end ",
    "label": "",
    "id": "3706"
  },
  {
    "raw_code": "def git(commands = {})\n        if commands.is_a?(Symbol)\n          run \"git #{commands}\"\n        else\n          commands.each do |cmd, options|\n            run \"git #{cmd} #{options}\"\n          end",
    "comment": "Runs one or more git commands.  git :init # => runs `git init`  git add: \"this.file that.rb\" # => runs `git add this.file that.rb`  git commit: \"-m 'First commit'\" # => runs `git commit -m 'First commit'`  git add: \"good.rb\", rm: \"bad.cxx\" # => runs `git add good.rb; git rm bad.cxx` ",
    "label": "",
    "id": "3707"
  },
  {
    "raw_code": "def vendor(filename, data = nil)\n        log :vendor, filename\n        data ||= yield if block_given?\n        create_file(\"vendor/#{filename}\", optimize_indentation(data), verbose: false)\n      end",
    "comment": "Creates a file in +vendor/+. The contents can be specified as an argument or as the return value of the block.  vendor \"foreign.rb\", <<~RUBY # Foreign code is fun RUBY  vendor \"foreign.rb\" do \"# Foreign code is fun\" end ",
    "label": "",
    "id": "3708"
  },
  {
    "raw_code": "def lib(filename, data = nil)\n        log :lib, filename\n        data ||= yield if block_given?\n        create_file(\"lib/#{filename}\", optimize_indentation(data), verbose: false)\n      end",
    "comment": "Creates a file in +lib/+. The contents can be specified as an argument or as the return value of the block.  lib \"foreign.rb\", <<~RUBY # Foreign code is fun RUBY  lib \"foreign.rb\" do \"# Foreign code is fun\" end ",
    "label": "",
    "id": "3709"
  },
  {
    "raw_code": "def rakefile(filename, data = nil)\n        log :rakefile, filename\n        data ||= yield if block_given?\n        create_file(\"lib/tasks/#{filename}\", optimize_indentation(data), verbose: false)\n      end",
    "comment": "Creates a Rake tasks file in +lib/tasks/+. The code can be specified as an argument or as the return value of the block.  rakefile \"bootstrap.rake\", <<~RUBY task :bootstrap do puts \"Boots! Boots! Boots!\" end RUBY  rakefile \"bootstrap.rake\" do project = ask(\"What is the UNIX name of your project?\")  <<~RUBY namespace :#{project} do task :bootstrap do puts \"Boots! Boots! Boots!\" end end RUBY end ",
    "label": "",
    "id": "3710"
  },
  {
    "raw_code": "def initializer(filename, data = nil)\n        log :initializer, filename\n        data ||= yield if block_given?\n        create_file(\"config/initializers/#{filename}\", optimize_indentation(data), verbose: false)\n      end",
    "comment": "Creates an initializer file in +config/initializers/+. The code can be specified as an argument or as the return value of the block.  initializer \"api.rb\", <<~RUBY API_KEY = \"123456\" RUBY  initializer \"api.rb\" do %(API_KEY = \"123456\") end ",
    "label": "",
    "id": "3711"
  },
  {
    "raw_code": "def generate(what, *args)\n        log :generate, what\n\n        options = args.extract_options!\n        options[:abort_on_failure] = !options[:inline]\n\n        rails_command \"generate #{what} #{args.join(\" \")}\", options\n      end",
    "comment": "Runs another generator.  generate \"scaffold\", \"Post title:string body:text\" generate \"scaffold\", \"Post\", \"title:string\", \"body:text\"  The first argument is the generator name, and the remaining arguments are joined together and passed to the generator.",
    "label": "",
    "id": "3712"
  },
  {
    "raw_code": "def rake(command, options = {})\n        execute_command :rake, command, options\n      end",
    "comment": "Runs the specified Rake task.  rake \"db:migrate\" rake \"db:migrate\", env: \"production\" rake \"db:migrate\", abort_on_failure: true rake \"stats\", capture: true rake \"gems:install\", sudo: true  ==== Options  [+:env+] The \\Rails environment in which to run the task. Defaults to <tt>ENV[\"RAILS_ENV\"] || \"development\"</tt>.  [+:abort_on_failure+] Whether to halt the generator if the task exits with a non-success exit status.  [+:capture+] Whether to capture and return the output of the task.  [+:sudo+] Whether to run the task using +sudo+.",
    "label": "",
    "id": "3713"
  },
  {
    "raw_code": "def rails_command(command, options = {})\n        if options[:inline]\n          log :rails, command\n          command, *args = Shellwords.split(command)\n          in_root do\n            silence_warnings do\n              ::Rails::Command.invoke(command, args, **options)\n            end",
    "comment": "Runs the specified \\Rails command.  rails_command \"db:migrate\" rails_command \"db:migrate\", env: \"production\" rails_command \"db:migrate\", abort_on_failure: true rails_command \"stats\", capture: true rails_command \"gems:install\", sudo: true  ==== Options  [+:env+] The \\Rails environment in which to run the command. Defaults to <tt>ENV[\"RAILS_ENV\"] || \"development\"</tt>.  [+:abort_on_failure+] Whether to halt the generator if the command exits with a non-success exit status.  [+:capture+] Whether to capture and return the output of the command.  [+:sudo+] Whether to run the command using +sudo+.",
    "label": "",
    "id": "3714"
  },
  {
    "raw_code": "def route(routing_code, namespace: nil)\n        namespace = Array(namespace)\n        namespace_pattern = route_namespace_pattern(namespace)\n        routing_code = namespace.reverse.reduce(routing_code) do |code, name|\n          \"namespace :#{name} do\\n#{rebase_indentation(code, 2)}end\"\n        end",
    "comment": "Make an entry in \\Rails routing file <tt>config/routes.rb</tt>  route \"root 'welcome#index'\" route \"root 'admin#index'\", namespace: :admin",
    "label": "",
    "id": "3715"
  },
  {
    "raw_code": "def readme(path)\n        log File.read(find_in_source_paths(path))\n      end",
    "comment": "Reads the given file at the source root and prints it in the console.  readme \"README\"",
    "label": "",
    "id": "3716"
  },
  {
    "raw_code": "def log(*args) # :doc:\n          if args.size == 1\n            say args.first.to_s\n          else\n            args << (behavior == :invoke ? :green : :red)\n            say_status(*args)\n          end",
    "comment": "Define log for backwards compatibility. If just one argument is sent, invoke +say+, otherwise invoke +say_status+.",
    "label": "",
    "id": "3717"
  },
  {
    "raw_code": "def execute_command(executor, command, options = {}) # :doc:\n          log executor, command\n          sudo = options[:sudo] && !Gem.win_platform? ? \"sudo \" : \"\"\n          config = {\n            env: { \"RAILS_ENV\" => (options[:env] || ENV[\"RAILS_ENV\"] || \"development\") },\n            verbose: false,\n            capture: options[:capture],\n            abort_on_failure: options[:abort_on_failure],\n          }\n\n          in_root { run(\"#{sudo}#{Shellwords.escape Gem.ruby} bin/#{executor} #{command}\", config) }\n        end",
    "comment": "Runs the supplied command using either +rake+ or +rails+ based on the executor parameter provided.",
    "label": "",
    "id": "3718"
  },
  {
    "raw_code": "def quote(value) # :doc:\n          if value.respond_to? :each_pair\n            return value.map do |k, v|\n              \"#{k}: #{quote(v)}\"\n            end.join(\", \")\n          end",
    "comment": "Always returns value in double quotes.",
    "label": "",
    "id": "3719"
  },
  {
    "raw_code": "def optimize_indentation(value, amount = 0) # :doc:\n          return \"#{value}\\n\" unless value.is_a?(String)\n          \"#{value.strip_heredoc.indent(amount).chomp}\\n\"\n        end",
    "comment": "Returns optimized string with indentation",
    "label": "",
    "id": "3720"
  },
  {
    "raw_code": "def indentation # :doc:\n          \"  \" * @indentation\n        end",
    "comment": "Returns a string corresponding to the current indentation level (i.e. 2 * <code>@indentation</code> spaces). See also #with_indentation, which can be used to manage the indentation level.",
    "label": "",
    "id": "3721"
  },
  {
    "raw_code": "def with_indentation(&block) # :doc:\n          @indentation += 1\n          instance_eval(&block)\n        ensure\n          @indentation -= 1\n        end",
    "comment": "Increases the current indentation indentation level for the duration of the given block, and decreases it after the block ends. Call #indentation to get an indentation string.",
    "label": "",
    "id": "3722"
  },
  {
    "raw_code": "def append_file_with_newline(path, str, options = {})\n          gsub_file path, /\\n?\\z/, options do |match|\n            match.end_with?(\"\\n\") ? \"\" : \"\\n#{str}\\n\"\n          end",
    "comment": "Append string to a file with a newline if necessary",
    "label": "",
    "id": "3723"
  },
  {
    "raw_code": "def self.all(klass)\n        \"#{klass}.all\"\n      end",
    "comment": "Used for:  * GET +index+",
    "label": "",
    "id": "3724"
  },
  {
    "raw_code": "def self.find(klass, params = nil)\n        \"#{klass}.find(#{params})\"\n      end",
    "comment": "Used for:  * GET +show+ * GET +edit+ * PATCH / PUT +update+ * DELETE +destroy+",
    "label": "",
    "id": "3725"
  },
  {
    "raw_code": "def self.build(klass, params = nil)\n        if params\n          \"#{klass}.new(#{params})\"\n        else\n          \"#{klass}.new\"\n        end",
    "comment": "Used for:  * GET +new+ * POST +create+",
    "label": "",
    "id": "3726"
  },
  {
    "raw_code": "def save\n        \"#{name}.save\"\n      end",
    "comment": "Used for:  * POST +create+",
    "label": "",
    "id": "3727"
  },
  {
    "raw_code": "def update(params = nil)\n        \"#{name}.update(#{params})\"\n      end",
    "comment": "Used for:  * PATCH / PUT +update+",
    "label": "",
    "id": "3728"
  },
  {
    "raw_code": "def errors\n        \"#{name}.errors\"\n      end",
    "comment": "Used for:  * POST +create+ * PATCH / PUT +update+",
    "label": "",
    "id": "3729"
  },
  {
    "raw_code": "def destroy\n        \"#{name}.destroy!\"\n      end",
    "comment": "Used for:  * DELETE +destroy+",
    "label": "",
    "id": "3730"
  },
  {
    "raw_code": "def imply_options(option_implications = OPTION_IMPLICATIONS, meta_options: [])\n        option_reasons = {}\n        option_implications.each do |reason, implications|\n          implications.each do |implication|\n            (option_reasons[implication.to_s] ||= []) << reason.to_s\n          end",
    "comment": "==== Options  [+:meta_options+] A list of generator options which only serve to trigger other options. These options should have no other effects, and will be treated transparently when revoking other options.  For example: --minimal implies both --skip-active-job and --skip-active-storage. Also, --skip-active-job by itself implies --skip-active-storage. If --skip-active-job is explicitly specified, --no-skip-active-storage should raise an error. But, if only --minimal is specified, --no-skip-active-storage should \"undo\" the implied --skip-active-job. This can be accomplished by passing <tt>meta_options: [:minimal]</tt>.  In contrast, --api is not a meta option because it does other things besides implying options such as --skip-asset-pipeline. (And so --api with --no-skip-asset-pipeline should raise an error.)",
    "label": "",
    "id": "3731"
  },
  {
    "raw_code": "def self.source_root(path = nil)\n        @_source_root = path if path\n        @_source_root ||= default_source_root\n      end",
    "comment": "Returns the source root for this generator using default_source_root as default.",
    "label": "",
    "id": "3732"
  },
  {
    "raw_code": "def self.desc(description = nil)\n        return super if description\n\n        @desc ||= if usage_path\n          ERB.new(File.read(usage_path)).result(binding)\n        else\n          \"Description:\\n    Create #{base_name.humanize.downcase} files for #{generator_name} generator.\"\n        end",
    "comment": "Tries to get the description from a USAGE file one folder above the source root otherwise uses a default description.",
    "label": "",
    "id": "3733"
  },
  {
    "raw_code": "def self.namespace(name = nil)\n        return super if name\n        @namespace ||= super.delete_suffix(\"_generator\").sub(/:generators:/, \":\")\n      end",
    "comment": "Convenience method to get the namespace from the class name. It's the same as Thor default except that the Generator at the end of the class is removed.",
    "label": "",
    "id": "3734"
  },
  {
    "raw_code": "def self.hide!\n        Rails::Generators.hide_namespace(namespace)\n      end",
    "comment": "Convenience method to hide this generator from the available ones when running rails generator command.",
    "label": "",
    "id": "3735"
  },
  {
    "raw_code": "def self.hook_for(*names, &block)\n        options = names.extract_options!\n        in_base = options.delete(:in) || base_name\n        as_hook = options.delete(:as) || generator_name\n\n        names.each do |name|\n          unless class_options.key?(name)\n            defaults = if options[:type] == :boolean\n              {}\n            elsif [true, false].include?(default_value_for_option(name, options))\n              { banner: \"\" }\n            else\n              { desc: \"#{name.to_s.humanize} to be invoked\", banner: \"NAME\" }\n            end",
    "comment": "Invoke a generator based on the value supplied by the user to the given option named \"name\". A class option is created when this method is invoked and you can set a hash to customize it.  ==== Examples  module Rails::Generators class ControllerGenerator < Base hook_for :test_framework, aliases: \"-t\" end end  The example above will create a test framework option and will invoke a generator based on the user supplied value.  For example, if the user invoke the controller generator as:  $ bin/rails generate controller Account --test-framework=test_unit  The controller generator will then try to invoke the following generators:  \"rails:test_unit\", \"test_unit:controller\", \"test_unit\"  Notice that \"rails:generators:test_unit\" could be loaded as well, what \\Rails looks for is the first and last parts of the namespace. This is what allows any test framework to hook into \\Rails as long as it provides any of the hooks above.  ==== Options  The first and last part used to find the generator to be invoked are guessed based on class invokes hook_for, as noticed in the example above. This can be customized with two options: +:in+ and +:as+.  Let's suppose you are creating a generator that needs to invoke the controller generator from test unit. Your first attempt is:  class AwesomeGenerator < Rails::Generators::Base hook_for :test_framework end  The lookup in this case for test_unit as input is:  \"test_unit:awesome\", \"test_unit\"  Which is not the desired lookup. You can change it by providing the +:as+ option:  class AwesomeGenerator < Rails::Generators::Base hook_for :test_framework, as: :controller end  And now it will look up at:  \"test_unit:controller\", \"test_unit\"  Similarly, if you want it to also look up in the rails namespace, you just need to provide the +:in+ value:  class AwesomeGenerator < Rails::Generators::Base hook_for :test_framework, in: :rails, as: :controller end  And the lookup is exactly the same as previously:  \"rails:test_unit\", \"test_unit:controller\", \"test_unit\"  ==== Switches  All hooks come with switches for user interface. If you do not want to use any test framework, you can do:  $ bin/rails generate controller Account --skip-test-framework  Or similarly:  $ bin/rails generate controller Account --no-test-framework  ==== Boolean hooks  In some cases, you may want to provide a boolean hook. For example, webrat developers might want to have webrat available on controller generator. This can be achieved as:  Rails::Generators::ControllerGenerator.hook_for :webrat, type: :boolean  Then, if you want webrat to be invoked, just supply:  $ bin/rails generate controller Account --webrat  The hooks lookup is similar as above:  \"rails:generators:webrat\", \"webrat:generators:controller\", \"webrat\"  ==== Custom invocations  You can also supply a block to hook_for to customize how the hook is going to be invoked. The block receives two arguments, an instance of the current class and the class to be invoked.  For example, in the resource generator, the controller should be invoked with a pluralized class name. But by default it is invoked with the same name as the resource generator, which is singular. To change this, we can give a block to customize how the controller can be invoked.  hook_for :resource_controller do |instance, controller| instance.invoke controller, [ instance.name.pluralize ] end ",
    "label": "",
    "id": "3736"
  },
  {
    "raw_code": "def self.remove_hook_for(*names)\n        remove_invocation(*names)\n\n        names.each do |name|\n          singleton_class.undef_method(\"#{name}_generator\")\n          hooks.delete(name)\n        end",
    "comment": "Remove a previously added hook.  remove_hook_for :orm",
    "label": "",
    "id": "3737"
  },
  {
    "raw_code": "def self.class_option(name, options = {}) # :nodoc:\n        options[:desc]    = \"Indicates when to generate #{name.to_s.humanize.downcase}\" unless options.key?(:desc)\n        options[:aliases] = default_aliases_for_option(name, options)\n        options[:default] = default_value_for_option(name, options)\n        super(name, options)\n      end",
    "comment": "Make class option aware of Rails::Generators.options and Rails::Generators.aliases.",
    "label": "",
    "id": "3738"
  },
  {
    "raw_code": "def self.default_source_root\n        return unless base_name && generator_name\n        return unless default_generator_root\n        path = File.join(default_generator_root, \"templates\")\n        path if File.exist?(path)\n      end",
    "comment": "Returns the default source root for a given generator. This is used internally by Rails to set its generators source root. If you want to customize your source root, you should use source_root.",
    "label": "",
    "id": "3739"
  },
  {
    "raw_code": "def self.base_root\n        __dir__\n      end",
    "comment": "Returns the base root for a common set of generators. This is used to dynamically guess the default source root.",
    "label": "",
    "id": "3740"
  },
  {
    "raw_code": "def self.inherited(base) # :nodoc:\n        super\n\n        # Invoke source_root so the default_source_root is set.\n        base.source_root\n\n        if base.name && !base.name.end_with?(\"Base\")\n          Rails::Generators.subclasses << base\n\n          Rails::Generators.templates_path.each do |path|\n            if base.name.include?(\"::\")\n              base.source_paths << File.join(path, base.base_name, base.generator_name)\n            else\n              base.source_paths << File.join(path, base.generator_name)\n            end",
    "comment": "Cache source root and add lib/generators/base/generator/templates to source paths.",
    "label": "",
    "id": "3741"
  },
  {
    "raw_code": "def class_collisions(*class_names)\n          return unless behavior == :invoke\n          return if options.skip_collision_check?\n          return if options.force?\n\n          class_names.flatten.each do |class_name|\n            class_name = class_name.to_s\n            next if class_name.strip.empty?\n\n            # Split the class from its module nesting\n            nesting = class_name.split(\"::\")\n            last_name = nesting.pop\n            last = extract_last_module(nesting)\n\n            if last && last.const_defined?(last_name.camelize, false)\n              raise Error, \"The name '#{class_name}' is either already used in your application \" \\\n                           \"or reserved by Ruby on Rails. Please choose an alternative or use --skip-collision-check \"  \\\n                           \"or --force to skip this check and run this generator again.\"\n            end",
    "comment": "Check whether the given class names are already taken by user application or Ruby on Rails.",
    "label": "",
    "id": "3742"
  },
  {
    "raw_code": "def extract_last_module(nesting) # :doc:\n          nesting.inject(Object) do |last_module, nest|\n            break unless last_module.const_defined?(nest, false)\n            last_module.const_get(nest)\n          end",
    "comment": "Takes in an array of nested modules and extracts the last module",
    "label": "",
    "id": "3743"
  },
  {
    "raw_code": "def module_namespacing(&block) # :doc:\n          content = capture(&block)\n          content = wrap_with_namespace(content) if namespaced?\n          concat(content)\n        end",
    "comment": "Wrap block with namespace of current application if namespace exists and is not skipped",
    "label": "",
    "id": "3744"
  },
  {
    "raw_code": "def self.banner # :doc:\n          \"bin/rails generate #{namespace.delete_prefix(\"rails:\")} #{arguments.map(&:usage).join(' ')} [options]\".gsub(/\\s+/, \" \")\n        end",
    "comment": "Use \\Rails default banner.",
    "label": "",
    "id": "3745"
  },
  {
    "raw_code": "def self.base_name # :doc:\n          @base_name ||= if base = name.to_s.split(\"::\").first\n            base.underscore\n          end",
    "comment": "Sets the base_name taking into account the current class namespace.",
    "label": "",
    "id": "3746"
  },
  {
    "raw_code": "def self.generator_name # :doc:\n          @generator_name ||= if generator = name.to_s.split(\"::\").last\n            generator.delete_suffix!(\"Generator\")\n            generator.underscore\n          end",
    "comment": "Removes the namespaces and get the generator name. For example, Rails::Generators::ModelGenerator will return \"model\" as generator name.",
    "label": "",
    "id": "3747"
  },
  {
    "raw_code": "def self.default_value_for_option(name, options) # :doc:\n          default_for_option(Rails::Generators.options, name, options, options[:default])\n        end",
    "comment": "Returns the default value for the option name given doing a lookup in Rails::Generators.options.",
    "label": "",
    "id": "3748"
  },
  {
    "raw_code": "def self.default_aliases_for_option(name, options) # :doc:\n          default_for_option(Rails::Generators.aliases, name, options, options[:aliases])\n        end",
    "comment": "Returns default aliases for the option name given doing a lookup in Rails::Generators.aliases.",
    "label": "",
    "id": "3749"
  },
  {
    "raw_code": "def self.default_for_option(config, name, options, default) # :doc:\n          if generator_name && (c = config[generator_name.to_sym]) && c.key?(name)\n            c[name]\n          elsif base_name && (c = config[base_name.to_sym]) && c.key?(name)\n            c[name]\n          elsif config[:rails].key?(name)\n            config[:rails][name]\n          else\n            default\n          end",
    "comment": "Returns default for the option name given doing a lookup in config.",
    "label": "",
    "id": "3750"
  },
  {
    "raw_code": "def self.hooks # :nodoc:\n          @hooks ||= from_superclass(:hooks, {})\n        end",
    "comment": "Keep hooks configuration that are used on prepare_for_invocation.",
    "label": "",
    "id": "3751"
  },
  {
    "raw_code": "def self.prepare_for_invocation(name, value) # :nodoc:\n          return super unless value.is_a?(String) || value.is_a?(Symbol)\n\n          if value && constants = hooks[name]\n            value = name if TrueClass === value\n            Rails::Generators.find_by_namespace(value, *constants)\n          elsif klass = Rails::Generators.find_by_namespace(value)\n            klass\n          else\n            super\n          end",
    "comment": "Prepare class invocation to search on Rails namespace if a previous added hook is being used.",
    "label": "",
    "id": "3752"
  },
  {
    "raw_code": "def self.add_shebang_option! # :doc:\n          class_option :ruby, type: :string, aliases: \"-r\", default: Thor::Util.ruby_command,\n                              desc: \"Path to the Ruby binary of your choice\", banner: \"PATH\"\n\n          no_tasks {\n            define_method :shebang do\n              @shebang ||= begin\n                command = if options[:ruby] == Thor::Util.ruby_command\n                  \"/usr/bin/env #{File.basename(Thor::Util.ruby_command)}\"\n                else\n                  options[:ruby]\n                end",
    "comment": "Small macro to add ruby as an option to the generator with proper default value plus an instance helper method called shebang.",
    "label": "",
    "id": "3753"
  },
  {
    "raw_code": "def parse_type_and_options(type)\n            case type\n            when /(text|binary)\\{([a-z]+)\\}/\n              parsed_type, parsed_options = $1, { size: $2.to_sym }\n            when /(string|text|binary|integer)\\{(\\d+)\\}/\n              parsed_type, parsed_options = $1, { limit: $2.to_i }\n            when /decimal\\{(\\d+)[,.-](\\d+)\\}/\n              parsed_type, parsed_options = :decimal, { precision: $1.to_i, scale: $2.to_i }\n            when /(references|belongs_to)\\{(.+)\\}/\n              parsed_type = $1\n              provided_options = $2.split(/[,.-]/)\n              parsed_options = Hash[provided_options.map { |opt| [opt.to_sym, true] }]\n            else\n              parsed_type, parsed_options = type&.remove(\"!\"), {}\n            end",
    "comment": "parse possible attribute options like :limit for string/text/binary/integer, :precision/:scale for decimals or :polymorphic for references/belongs_to when declaring options curly brackets should be used",
    "label": "",
    "id": "3754"
  },
  {
    "raw_code": "def migration_template(source, destination, config = {})\n        source = File.expand_path(find_in_source_paths(source.to_s))\n\n        set_migration_assigns!(destination)\n\n        dir, base = File.split(destination)\n        numbered_destination = File.join(dir, [\"%migration_number%\", base].join(\"_\"))\n\n        file = create_migration numbered_destination, nil, config do\n          ERB.new(::File.binread(source), trim_mode: \"-\", eoutvar: \"@output_buffer\").result(binding)\n        end",
    "comment": "Creates a migration template at the given destination. The difference to the default template method is that the migration number is prepended to the destination file name.  The migration number, migration file name, migration class name are available as instance variables in the template to be rendered.  migration_template \"migration.rb\", \"db/migrate/add_foo_to_bar.rb\"",
    "label": "",
    "id": "3755"
  },
  {
    "raw_code": "def singular_name # :doc:\n          file_name\n        end",
    "comment": "FIXME: We are avoiding to use alias because a bug on thor that make this method public and add it to the task list.",
    "label": "",
    "id": "3756"
  },
  {
    "raw_code": "def application_name # :doc:\n          if defined?(Rails) && Rails.application\n            Rails.application.class.name.split(\"::\").first.underscore\n          else\n            \"application\"\n          end",
    "comment": "Tries to retrieve the application name or simply return application.",
    "label": "",
    "id": "3757"
  },
  {
    "raw_code": "def parse_attributes!\n          self.attributes = (attributes || []).map do |attr|\n            Rails::Generators::GeneratedAttribute.parse(attr)\n          end",
    "comment": "Convert attributes array into GeneratedAttribute objects.",
    "label": "",
    "id": "3758"
  },
  {
    "raw_code": "def self.check_class_collision(options = {}) # :doc:\n          define_method :check_class_collision do\n            name = if respond_to?(:controller_class_name, true) # for ResourceHelpers\n              controller_class_name\n            else\n              class_name\n            end",
    "comment": "Add a class collisions name to be checked on class initialization. You can supply a hash with a +:prefix+ or +:suffix+ to be tested.  ==== Examples  check_class_collision suffix: \"Decorator\"  If the generator is invoked with class name Admin, it will check for the presence of \"AdminDecorator\". ",
    "label": "",
    "id": "3759"
  },
  {
    "raw_code": "def initialize(*args) # :nodoc:\n        super\n        controller_name = name\n        if options[:model_name]\n          self.name = options[:model_name]\n          assign_names!(name)\n        end",
    "comment": "Set controller variables on initialization.",
    "label": "",
    "id": "3760"
  },
  {
    "raw_code": "def orm_class\n          @orm_class ||= begin\n            # Raise an error if the class_option :orm was not defined.\n            unless self.class.class_options[:orm]\n              raise \"You need to have :orm as class option to invoke orm_class and orm_instance\"\n            end",
    "comment": "Loads the ORM::Generators::ActiveModel class. This class is responsible to tell scaffold entities how to generate a specific method for the ORM. Check Rails::Generators::ActiveModel for more information.",
    "label": "",
    "id": "3761"
  },
  {
    "raw_code": "def orm_instance(name = singular_table_name)\n          @orm_instance ||= orm_class.new(name)\n        end",
    "comment": "Initialize ORM::Generators::ActiveModel to access instance methods.",
    "label": "",
    "id": "3762"
  },
  {
    "raw_code": "def file(*args, &block)\n        create_file(*args, &block)\n      end",
    "comment": "Define file as an alias to create_file for backwards compatibility.",
    "label": "",
    "id": "3763"
  },
  {
    "raw_code": "def after_bundle(&block) # :doc:\n        @after_bundle_callbacks << block\n      end",
    "comment": "Registers a callback to be executed after bundle binstubs have run.  after_bundle do git add: '.' end",
    "label": "",
    "id": "3764"
  },
  {
    "raw_code": "def add_resource_route\n        return if options[:actions].present?\n        route \"resources :#{file_name.pluralize}\", namespace: regular_class_path\n      end",
    "comment": "Properly nests namespaces passed into a generator  $ bin/rails generate resource admin/users/products  should give you  namespace :admin do namespace :users do resources :products end end",
    "label": "",
    "id": "3765"
  },
  {
    "raw_code": "def assert_file(relative, *contents)\n          absolute = File.expand_path(relative, destination_root)\n          assert File.exist?(absolute), \"Expected file #{relative.inspect} to exist, but does not\"\n\n          read = File.read(absolute) if block_given? || !contents.empty?\n          assert_nothing_raised { yield read } if block_given?\n\n          contents.each do |content|\n            case content\n            when String\n              assert_equal content, read\n            when Regexp\n              assert_match content, read\n            end",
    "comment": "Asserts a given file exists. You need to supply an absolute path or a path relative to the configured destination:  assert_file \"config/environment.rb\"  You can also give extra arguments. If the argument is a regexp, it will check if the regular expression matches the given file content. If it's a string, it compares the file with the given string:  assert_file \"config/environment.rb\", /initialize/  Finally, when a block is given, it yields the file content:  assert_file \"app/controllers/products_controller.rb\" do |controller| assert_instance_method :index, controller do |index| assert_match(/Product\\.all/, index) end end",
    "label": "",
    "id": "3766"
  },
  {
    "raw_code": "def assert_no_file(relative)\n          absolute = File.expand_path(relative, destination_root)\n          assert !File.exist?(absolute), \"Expected file #{relative.inspect} to not exist, but does\"\n        end",
    "comment": "Asserts a given file does not exist. You need to supply an absolute path or a path relative to the configured destination:  assert_no_file \"config/random.rb\"",
    "label": "",
    "id": "3767"
  },
  {
    "raw_code": "def assert_migration(relative, *contents, &block)\n          file_name = migration_file_name(relative)\n          assert file_name, \"Expected migration #{relative} to exist, but was not found\"\n          assert_file file_name, *contents, &block\n        end",
    "comment": "Asserts a given migration exists. You need to supply an absolute path or a path relative to the configured destination:  assert_migration \"db/migrate/create_products.rb\"  This method manipulates the given path and tries to find any migration which matches the migration name. For example, the call above is converted to:  assert_file \"db/migrate/003_create_products.rb\"  Consequently, assert_migration accepts the same arguments has assert_file.",
    "label": "",
    "id": "3768"
  },
  {
    "raw_code": "def assert_no_migration(relative)\n          file_name = migration_file_name(relative)\n          assert_nil file_name, \"Expected migration #{relative} to not exist, but found #{file_name}\"\n        end",
    "comment": "Asserts a given migration does not exist. You need to supply an absolute path or a path relative to the configured destination:  assert_no_migration \"db/migrate/create_products.rb\"",
    "label": "",
    "id": "3769"
  },
  {
    "raw_code": "def assert_class_method(method, content, &block)\n          assert_instance_method \"self.#{method}\", content, &block\n        end",
    "comment": "Asserts the given class method exists in the given content. This method does not detect class methods inside (class << self), only class methods which starts with \"self.\". When a block is given, it yields the content of the method.  assert_migration \"db/migrate/create_products.rb\" do |migration| assert_class_method :up, migration do |up| assert_match(/create_table/, up) end end",
    "label": "",
    "id": "3770"
  },
  {
    "raw_code": "def assert_instance_method(method, content)\n          assert content =~ /(\\s+)def #{method}(\\(.+\\))?(.*?)\\n\\1end/m, \"Expected to have method #{method}\"\n          assert_nothing_raised { yield $3.strip } if block_given?\n        end",
    "comment": "Asserts the given method exists in the given content. When a block is given, it yields the content of the method.  assert_file \"app/controllers/products_controller.rb\" do |controller| assert_instance_method :index, controller do |index| assert_match(/Product\\.all/, index) end end",
    "label": "",
    "id": "3771"
  },
  {
    "raw_code": "def assert_field_type(attribute_type, field_type)\n          assert_equal(field_type, create_generated_attribute(attribute_type).field_type)\n        end",
    "comment": "Asserts the given attribute type gets translated to a field type properly:  assert_field_type :date, :date_select",
    "label": "",
    "id": "3772"
  },
  {
    "raw_code": "def assert_field_default_value(attribute_type, value)\n          if value.nil?\n            assert_nil(create_generated_attribute(attribute_type).default)\n          else\n            assert_equal(value, create_generated_attribute(attribute_type).default)\n          end",
    "comment": "Asserts the given attribute type gets a proper default value:  assert_field_default_value :string, \"MyString\"",
    "label": "",
    "id": "3773"
  },
  {
    "raw_code": "def assert_initializer(name, *contents, &block)\n          assert_file(\"config/initializers/#{name}\", *contents, &block)\n        end",
    "comment": "Asserts a given initializer exists. You need to supply a path relative to the `config/initializers/` directory.  assert_initializer \"mail_interceptors.rb\"  You can also give extra arguments. If the argument is a regexp, it will check if the regular expression matches the given file content. If it's a string, it compares the file with the given string:  assert_initializer \"mail_interceptors.rb\", /SandboxEmailInterceptor/  Finally, when a block is given, it yields the file content:  assert_initializer \"mail_interceptors.rb\" do |initializer| assert_match(/SandboxEmailInterceptor/, initializer) end",
    "label": "",
    "id": "3774"
  },
  {
    "raw_code": "def tests(klass)\n            self.generator_class = klass\n          end",
    "comment": "Sets which generator should be tested:  tests AppGenerator",
    "label": "",
    "id": "3775"
  },
  {
    "raw_code": "def arguments(array)\n            self.default_arguments = array\n          end",
    "comment": "Sets default arguments on generator invocation. This can be overwritten when invoking it.  arguments %w(app_name --skip-active-record)",
    "label": "",
    "id": "3776"
  },
  {
    "raw_code": "def destination(path)\n            self.destination_root = path\n          end",
    "comment": "Sets the destination of generator files:  destination File.expand_path(\"../tmp\", __dir__)",
    "label": "",
    "id": "3777"
  },
  {
    "raw_code": "def run_generator(args = default_arguments, config = {})\n          args += [\"--skip-bundle\"] unless args.include?(\"--no-skip-bundle\") || args.include?(\"--dev\")\n          args += [\"--skip-bootsnap\"] unless args.include?(\"--no-skip-bootsnap\") || args.include?(\"--skip-bootsnap\")\n\n          if ENV[\"RAILS_LOG_TO_STDOUT\"] == \"true\"\n            generator_class.start(args, config.reverse_merge(destination_root: destination_root))\n          else\n            capture(:stdout) do\n              generator_class.start(args, config.reverse_merge(destination_root: destination_root))\n            end",
    "comment": "Runs the generator configured for this class. The first argument is an array like command line arguments:  class AppGeneratorTest < Rails::Generators::TestCase tests AppGenerator destination File.expand_path(\"../tmp\", __dir__) setup :prepare_destination  test \"database.yml is not created when skipping Active Record\" do run_generator %w(myapp --skip-active-record) assert_no_file \"config/database.yml\" end end  You can provide a configuration hash as second argument. This method returns the output printed by the generator.",
    "label": "",
    "id": "3778"
  },
  {
    "raw_code": "def generator(args = default_arguments, options = {}, config = {})\n          @generator ||= generator_class.new(args, options, config.reverse_merge(destination_root: destination_root))\n        end",
    "comment": "Instantiate the generator.",
    "label": "",
    "id": "3779"
  },
  {
    "raw_code": "def create_generated_attribute(attribute_type, name = \"test\", index = nil)\n          Rails::Generators::GeneratedAttribute.parse([name, attribute_type, index].compact.join(\":\"))\n        end",
    "comment": "Create a Rails::Generators::GeneratedAttribute by supplying the attribute type and, optionally, the attribute name:  create_generated_attribute(:string, \"name\")",
    "label": "",
    "id": "3780"
  },
  {
    "raw_code": "def prepare_destination # :doc:\n            rm_rf(destination_root)\n            mkdir_p(destination_root)\n          end",
    "comment": "Clears all files and directories in destination.",
    "label": "",
    "id": "3781"
  },
  {
    "raw_code": "def started_request_message(request) # :doc:\n          sprintf('Started %s \"%s\" for %s at %s',\n            request.raw_request_method,\n            request.filtered_path,\n            request.remote_ip,\n            Time.now)\n        end",
    "comment": "Started GET \"/session/new\" for 127.0.0.1 at 2012-09-26 14:51:42 -0700",
    "label": "",
    "id": "3782"
  },
  {
    "raw_code": "def self.eager_load_namespaces # :nodoc:\n        @@eager_load_namespaces ||= []\n      end",
    "comment": "Expose the eager_load_namespaces at \"module\" level for convenience.",
    "label": "",
    "id": "3783"
  },
  {
    "raw_code": "def eager_load_namespaces\n        @@eager_load_namespaces ||= []\n      end",
    "comment": "All namespaces that are eager loaded",
    "label": "",
    "id": "3784"
  },
  {
    "raw_code": "def watchable_files\n        @@watchable_files ||= []\n      end",
    "comment": "Add files that should be watched for change.",
    "label": "",
    "id": "3785"
  },
  {
    "raw_code": "def watchable_dirs\n        @@watchable_dirs ||= {}\n      end",
    "comment": "Add directories that should be watched for change. The key of the hashes should be directories and the values should be an array of extensions to match in each directory.",
    "label": "",
    "id": "3786"
  },
  {
    "raw_code": "def app_middleware\n        @@app_middleware ||= Rails::Configuration::MiddlewareStackProxy.new\n      end",
    "comment": "This allows you to modify the application's middlewares from Engines.  All operations you run on the app_middleware will be replayed on the application once it is defined and the default_middlewares are created",
    "label": "",
    "id": "3787"
  },
  {
    "raw_code": "def app_generators\n        @@app_generators ||= Rails::Configuration::Generators.new\n        yield(@@app_generators) if block_given?\n        @@app_generators\n      end",
    "comment": "This allows you to modify application's generators from Railties.  Values set on app_generators will become defaults for application, unless application overwrites them.",
    "label": "",
    "id": "3788"
  },
  {
    "raw_code": "def before_configuration(&block)\n        ActiveSupport.on_load(:before_configuration, yield: true, &block)\n      end",
    "comment": "First configurable block to run. Called before any initializers are run.",
    "label": "",
    "id": "3789"
  },
  {
    "raw_code": "def before_eager_load(&block)\n        ActiveSupport.on_load(:before_eager_load, yield: true, &block)\n      end",
    "comment": "Third configurable block to run. Does not run if +config.eager_load+ set to false.",
    "label": "",
    "id": "3790"
  },
  {
    "raw_code": "def before_initialize(&block)\n        ActiveSupport.on_load(:before_initialize, yield: true, &block)\n      end",
    "comment": "Second configurable block to run. Called before frameworks initialize.",
    "label": "",
    "id": "3791"
  },
  {
    "raw_code": "def after_initialize(&block)\n        ActiveSupport.on_load(:after_initialize, yield: true, &block)\n      end",
    "comment": "Last configurable block to run. Called after frameworks initialize.",
    "label": "",
    "id": "3792"
  },
  {
    "raw_code": "def after_routes_loaded(&block)\n        ActiveSupport.on_load(:after_routes_loaded, yield: true, &block)\n      end",
    "comment": "Called after application routes have been loaded.",
    "label": "",
    "id": "3793"
  },
  {
    "raw_code": "def to_prepare_blocks\n        @@to_prepare_blocks ||= []\n      end",
    "comment": "Array of callbacks defined by #to_prepare.",
    "label": "",
    "id": "3794"
  },
  {
    "raw_code": "def to_prepare(&blk)\n        to_prepare_blocks << blk if blk\n      end",
    "comment": "Defines generic callbacks to run before #after_initialize. Useful for Rails::Railtie subclasses.",
    "label": "",
    "id": "3795"
  },
  {
    "raw_code": "def ===(method)\n        @filters.any? { |filter| filter === method }\n      end",
    "comment": "minitest uses === to find matching filters.",
    "label": "",
    "id": "3796"
  },
  {
    "raw_code": "def self.definition_for(method)\n          filepath, start_line = method.source_location\n          @begins_to_ends[filepath] ||= ranges(filepath)\n          return unless end_line = @begins_to_ends[filepath][start_line]\n          [filepath, start_line..end_line]\n        end",
    "comment": "Helper to translate a method object into the path and line range where the method was defined.",
    "label": "",
    "id": "3797"
  },
  {
    "raw_code": "def self.definition_for(method_obj)\n        path, begin_line = method_obj.source_location\n        begins_to_ends = new(File.read(path), path).parse\n        return unless end_line = begins_to_ends[begin_line]\n        [path, (begin_line..end_line)]\n      end",
    "comment": "Helper to translate a method object into the path and line range where the method was defined.",
    "label": "",
    "id": "3798"
  },
  {
    "raw_code": "def on_def(begin_line, *)\n        @begins_to_ends[begin_line] = lineno\n      end",
    "comment": "method test e.g. `def test_some_description` This event's first argument gets the `ident` node containing the method name, which we have overridden to return the line number of the ident instead.",
    "label": "",
    "id": "3799"
  },
  {
    "raw_code": "def on_method_add_block(begin_line, end_line)\n        if begin_line && end_line\n          @begins_to_ends[begin_line] = end_line\n        end",
    "comment": "Everything past this point is to support declarative tests, which require more work to get right because of the many different ways methods can be invoked in ruby, all of which are parsed differently.  The approach is just to store the current line number when the \"test\" method is called and pass it up the tree so it's available at the point when we also know the line where the associated block ends.",
    "label": "",
    "id": "3800"
  },
  {
    "raw_code": "def build_app(options = {})\n      @prev_rails_app_class = Rails.app_class\n      @prev_rails_application = Rails.application\n      Rails.app_class = Rails.application = nil\n\n      @prev_rails_env = ENV[\"RAILS_ENV\"]\n      ENV[\"RAILS_ENV\"] = \"development\"\n\n      FileUtils.rm_rf(app_path)\n      FileUtils.cp_r(app_template_path, app_path)\n\n      # Delete the initializers unless requested\n      unless options[:initializers]\n        Dir[\"#{app_path}/config/initializers/**/*.rb\"].each do |initializer|\n          File.delete(initializer)\n        end",
    "comment": "Build an application by invoking the generator and going through the whole stack.",
    "label": "",
    "id": "3801"
  },
  {
    "raw_code": "def make_basic_app\n      require \"rails\"\n      require \"action_controller/railtie\"\n      require \"action_view/railtie\"\n\n      @app = Class.new(Rails::Application) do\n        def self.name; \"RailtiesTestApp\"; end\n      end\n      @app.config.hosts << proc { true }\n      @app.config.eager_load = false\n      @app.config.session_store :cookie_store, key: \"_myapp_session\"\n      @app.config.active_support.deprecation = :log\n      @app.config.log_level = :error\n      @app.config.secret_key_base = \"b3c631c314c0bbca50c1b2843150fe33\"\n      @app.config.active_support.to_time_preserves_timezone = :zone\n\n      yield @app if block_given?\n      @app.initialize!\n\n      @app.routes.draw do\n        get \"/\" => \"omg#index\"\n      end",
    "comment": "Make a very basic app, without creating the whole directory structure. This is faster and simpler than the method above.",
    "label": "",
    "id": "3802"
  },
  {
    "raw_code": "def rails(*args, allow_failure: false, stderr: false)\n      args = args.flatten\n      fork = true\n\n      command = \"bin/rails #{Shellwords.join args}#{' 2>&1' unless stderr}\"\n\n      # Don't fork if the environment has disabled it\n      fork = false if ENV[\"NO_FORK\"]\n\n      # Don't fork if the runtime isn't able to\n      fork = false if !Process.respond_to?(:fork)\n\n      # Don't fork if we're re-invoking minitest\n      fork = false if args.first == \"t\" || args.grep(/\\Atest(:|\\z)/).any?\n\n      if fork\n        out_read, out_write = IO.pipe\n        if stderr\n          err_read, err_write = IO.pipe\n        else\n          err_write = out_write\n        end",
    "comment": "Invoke a bin/rails command inside the app  allow_failure:: true to return normally if the command exits with a non-zero status. By default, this method will raise. stderr:: true to pass STDERR output straight to the \"real\" STDERR. By default, the STDERR and STDOUT of the process will be combined in the returned string.",
    "label": "",
    "id": "3803"
  },
  {
    "raw_code": "def restrict_frameworks\n      remove_from_config('require \"rails/all\"')\n      remove_from_config('require_relative \"boot\"')\n      remove_from_env_config(\"development\", \"config.active_storage.*\")\n      frameworks = <<~RUBY\n        require \"rails\"\n        require \"active_model/railtie\"\n        require \"active_job/railtie\"\n        require \"active_record/railtie\"\n        require \"action_controller/railtie\"\n        require \"action_mailer/railtie\"\n        require \"action_view/railtie\"\n        require \"rails/test_unit/railtie\"\n      RUBY\n      environment = File.read(\"#{app_path}/config/application.rb\")\n      File.open(\"#{app_path}/config/application.rb\", \"w\") { |f| f.puts frameworks + \"\\n\" + environment }\n    end",
    "comment": "Restrict frameworks to load in order to avoid engine frameworks affect tests.",
    "label": "",
    "id": "3804"
  },
  {
    "raw_code": "def self.my_testing_alias(test_name, &)\n    define_method(:\"test_#{test_name}\", &)\n  end",
    "comment": "Check that extensions can provide aliases for testing methods",
    "label": "",
    "id": "3805"
  },
  {
    "raw_code": "def initialize(checker, defaults, file_content)\n          @checker = checker\n          @defaults = defaults\n          @file_content = file_content\n        end",
    "comment": "Defaults are strings like: self.yjit action_controller.escape_json_responses",
    "label": "",
    "id": "3806"
  },
  {
    "raw_code": "def npm_version\n    @npm_version ||= begin\n      if pre_release?\n        pre_release = pre.tr(\".\", \"-\")\n        npm_pre = 0\n      else\n        npm_pre = pre.to_i\n        pre_release = nil\n      end",
    "comment": "This \"npm-ifies\" the current version number With npm, versions such as \"5.0.0.rc1\" or \"5.0.0.beta1.1\" are not compliant with its versioning system, so they must be transformed to \"5.0.0-rc1\" and \"5.0.0-beta1-1\" respectively. \"5.0.0\"     --> \"5.0.0\" \"5.0.1\"     --> \"5.0.100\" \"5.0.0.1\"   --> \"5.0.1\" \"5.0.1.1\"   --> \"5.0.101\" \"5.0.0.rc1\" --> \"5.0.0-rc1\" \"5.0.0.beta1.1\" --> \"5.0.0-beta1-1\"",
    "label": "",
    "id": "3807"
  },
  {
    "raw_code": "def self.gem_version\n    Gem::Version.new VERSION::STRING\n  end",
    "comment": "Returns the currently loaded version of \\Rails as a +Gem::Version+.",
    "label": "",
    "id": "3808"
  }
]