[
  {
    "raw_code": "def load_rules # rubocop:disable Metrics/AbcSize\n      rules = LOAD_RULES_CACHE[self.class.rules_cache_key] ||=\n        self.class.files.each_with_object({}) do |filename, hash|\n          hash.merge!(YAML.safe_load(File.read(filename)) || {}) do |_key, first, second|\n            case first\n            when Hash\n              first.merge(second)\n            when Array\n              first.concat(second)\n            end",
    "comment": "Default rules for obsoletions are in config/obsoletion.yml Additional rules files can be added with `RuboCop::ConfigObsoletion.files << filename`",
    "label": "",
    "id": "1"
  },
  {
    "raw_code": "def load_cop_rules(rules)\n      rules.flat_map do |rule_type, data|\n        data.filter_map do |cop_name, configuration|\n          next unless configuration # allow configurations to be disabled with `CopName: ~`\n\n          COP_RULE_CLASSES[rule_type].new(@config, cop_name, configuration)\n        end",
    "comment": "Cop rules are keyed by the name of the original cop",
    "label": "",
    "id": "2"
  },
  {
    "raw_code": "def load_parameter_rules(rules)\n      rules.flat_map do |rule_type, data|\n        data.flat_map do |configuration|\n          cops = Array(configuration['cops'])\n          parameters = Array(configuration['parameters'])\n\n          cops.product(parameters).map do |cop, parameter|\n            PARAMETER_RULE_CLASSES[rule_type].new(@config, cop, parameter, configuration)\n          end",
    "comment": "Parameter rules may apply to multiple cops and multiple parameters and are given as an array. Each combination is turned into a separate rule object.",
    "label": "How-to-use",
    "id": "3"
  },
  {
    "raw_code": "def enabled?\n      @enabled ||= false\n    end",
    "comment": "Returns true when LSP is enabled, false when disabled.  @return [Boolean]",
    "label": "",
    "id": "4"
  },
  {
    "raw_code": "def enable\n      @enabled = true\n    end",
    "comment": "Enable LSP.  @return [void]",
    "label": "",
    "id": "5"
  },
  {
    "raw_code": "def disable(&block)\n      if block\n        original = @enabled\n        @enabled = false\n        yield\n        @enabled = original\n      else\n        @enabled = false\n      end",
    "comment": "Disable LSP.  @return [void]",
    "label": "",
    "id": "6"
  },
  {
    "raw_code": "def for(file_or_dir)\n      dir = if File.directory?(file_or_dir)\n              file_or_dir\n            else\n              File.dirname(file_or_dir)\n            end",
    "comment": "If type (file/dir) is known beforehand, prefer using #for_file or #for_dir for improved performance",
    "label": "",
    "id": "7"
  },
  {
    "raw_code": "def validate_after_resolution\n      check_target_ruby\n    end",
    "comment": "Validations that should only be run after all config resolving has taken place: * The target ruby version is only checked once the entire inheritance chain has been loaded so that only the final value is validated, and any obsolete but overridden values are ignored.",
    "label": "",
    "id": "8"
  },
  {
    "raw_code": "def param_error_message(parent, key, value, supposed_values)\n      \"#{Rainbow('').reset}\" \\\n        \"Property #{Rainbow(key).yellow} of #{Rainbow(parent).yellow} cop \" \\\n        \"is supposed to be #{supposed_values} and #{Rainbow(value).yellow} is not.\"\n    end",
    "comment": "FIXME: Handling colors in exception messages like this is ugly.",
    "label": "",
    "id": "9"
  },
  {
    "raw_code": "def ruby_extractors\n        @ruby_extractors ||= [default_ruby_extractor]\n      end",
    "comment": "@return [Array<#call>]",
    "label": "",
    "id": "10"
  },
  {
    "raw_code": "def default_ruby_extractor\n        lambda do |processed_source|\n          [\n            {\n              offset: 0,\n              processed_source: processed_source\n            }\n          ]\n        end",
    "comment": "@return [#call]",
    "label": "",
    "id": "11"
  },
  {
    "raw_code": "def warm_cache(target_files)\n      saved_options = @options.dup\n      if target_files.length <= 1\n        puts 'Skipping parallel inspection: only a single file needs inspection' if @options[:debug]\n        return\n      end",
    "comment": "Warms up the RuboCop cache by forking a suitable number of RuboCop instances that each inspects its allotted group of files.",
    "label": "",
    "id": "12"
  },
  {
    "raw_code": "def check_for_infinite_loop(processed_source, offenses_by_iteration)\n      checksum = processed_source.checksum\n\n      if (loop_start_index = @processed_sources.index(checksum))\n        raise InfiniteCorrectionLoop.new(\n          processed_source.path,\n          offenses_by_iteration,\n          loop_start: loop_start_index\n        )\n      end",
    "comment": "Check whether a run created source identical to a previous run, which means that we definitely have an infinite loop.",
    "label": "",
    "id": "13"
  },
  {
    "raw_code": "def get_processed_source(file, prism_result)\n      config = @config_store.for_file(file)\n      ruby_version = config.target_ruby_version\n      parser_engine = config.parser_engine\n\n      processed_source = if @options[:stdin]\n                           ProcessedSource.new(\n                             @options[:stdin],\n                             ruby_version,\n                             file,\n                             parser_engine: parser_engine,\n                             prism_result: prism_result\n                           )\n                         else\n                           begin\n                             ProcessedSource.from_file(\n                               file, ruby_version, parser_engine: parser_engine\n                             )\n                           rescue Errno::ENOENT\n                             raise RuboCop::Error, \"No such file or directory: #{file}\"\n                           end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "14"
  },
  {
    "raw_code": "def standby_team(config)\n      @team_by_config ||= {}.compare_by_identity\n      @team_by_config[config] ||=\n        Cop::Team.mobilize(mobilized_cop_classes(config), config, @options)\n    end",
    "comment": "rubocop:enable Metrics/MethodLength A Cop::Team instance is stateful and may change when inspecting. The \"standby\" team for a given config is an initialized but otherwise dormant team that can be used for config- and option- level caching in ResultCache.",
    "label": "",
    "id": "15"
  },
  {
    "raw_code": "def run(args = ARGV)\n      time_start = Process.clock_gettime(Process::CLOCK_MONOTONIC)\n\n      @options, paths = Options.new.parse(args)\n      @env = Environment.new(@options, @config_store, paths)\n\n      profile_if_needed do\n        if @options[:init]\n          run_command(:init)\n        else\n          act_on_options\n          validate_options_vs_config\n          parallel_by_default!\n          apply_default_formatter\n          report_pending_cops\n          execute_runners\n        end",
    "comment": "@api public  Entry point for the application logic. Here we do the command line arguments processing and inspect the target files.  @param args [Array<String>] command line arguments @return [Integer] UNIX exit code  rubocop:disable Metrics/MethodLength, Metrics/AbcSize",
    "label": "",
    "id": "16"
  },
  {
    "raw_code": "def profile_if_needed\n      return yield unless @options[:profile]\n\n      return STATUS_ERROR unless require_gem('stackprof')\n\n      with_memory = @options[:memory]\n      if with_memory\n        return STATUS_ERROR unless require_gem('memory_profiler')\n\n        MemoryProfiler.start\n      end",
    "comment": "rubocop:disable Metrics/MethodLength, Metrics/AbcSize",
    "label": "",
    "id": "17"
  },
  {
    "raw_code": "def require_gem(name)\n      require name\n      true\n    rescue LoadError\n      warn(\"You don't have #{name} installed. Add it to your Gemfile and run `bundle install`\")\n      false\n    end",
    "comment": "rubocop:enable Metrics/MethodLength, Metrics/AbcSize",
    "label": "",
    "id": "18"
  },
  {
    "raw_code": "def handle_exiting_options\n      return unless Options::EXITING_OPTIONS.any? { |o| @options.key? o }\n\n      run_command(:version) if @options[:version] || @options[:verbose_version]\n      run_command(:show_cops) if @options[:show_cops]\n      run_command(:show_docs_url) if @options[:show_docs_url]\n      run_command(:lsp) if @options[:lsp]\n      raise Finished\n    end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "19"
  },
  {
    "raw_code": "def apply_default_formatter\n      # This must be done after the options have already been processed,\n      # because they can affect how ConfigStore behaves\n      @options[:formatters] ||= begin\n        if @options[:auto_gen_config]\n          formatter = 'autogenconf'\n        else\n          cfg = @config_store.for_pwd.for_all_cops\n          formatter = cfg['DefaultFormatter'] || 'progress'\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "20"
  },
  {
    "raw_code": "def self.cleanup(config_store, verbose, cache_root_override = nil)\n      return if inhibit_cleanup # OPTIMIZE: For faster testing\n\n      rubocop_cache_dir = cache_root(config_store, cache_root_override)\n      return unless File.exist?(rubocop_cache_dir)\n\n      files, dirs = Find.find(rubocop_cache_dir).partition { |path| File.file?(path) }\n      return unless requires_file_removal?(files.length, config_store)\n\n      remove_oldest_files(files, dirs, rubocop_cache_dir, verbose)\n    end",
    "comment": "Remove old files so that the cache doesn't grow too big. When the threshold MaxFilesInCache has been exceeded, the oldest 50% of all the files in the cache are removed. The reason for removing so much is that cleaning should be done relatively seldom, since there is a slight risk that some other RuboCop process was just about to read the file, when there's parallel execution and the cache is shared.",
    "label": "",
    "id": "21"
  },
  {
    "raw_code": "def rubocop_checksum\n      ResultCache.source_checksum ||=\n        begin\n          digest = Digest::SHA1.new\n          rubocop_extra_features\n            .select { |path| File.file?(path) }\n            .sort!\n            .each do |path|\n              digest << digest(path)\n            end",
    "comment": "The checksum of the RuboCop program running the inspection.",
    "label": "",
    "id": "22"
  },
  {
    "raw_code": "def relevant_options_digest(options)\n      options = options.reject { |key, _| NON_CHANGING.include?(key) }\n      options.to_s.gsub(/[^a-z]+/i, '_')\n    end",
    "comment": "Return a hash of the options given at invocation, minus the ones that have no effect on which offenses and disabled line ranges are found, and thus don't affect caching.",
    "label": "",
    "id": "23"
  },
  {
    "raw_code": "def context_checksum(team, options)\n      keys = [team.external_dependency_checksum, relevant_options_digest(options)]\n      Digest::SHA1.hexdigest(keys.join)\n    end",
    "comment": "We combine team and options into a single \"context\" checksum to avoid making file names that are too long for some filesystems to handle. This context is for anything that's not (1) the RuboCop executable checksum or (2) the inspected file checksum.",
    "label": "",
    "id": "24"
  },
  {
    "raw_code": "def load_file(file, check: true)\n        path = file_path(file)\n\n        hash = load_yaml_configuration(path)\n\n        rubocop_config = Config.create(hash, path, check: false)\n        plugins = hash.delete('plugins')\n        loaded_plugins = resolver.resolve_plugins(rubocop_config, plugins)\n        add_loaded_plugins(loaded_plugins)\n\n        loaded_features = resolver.resolve_requires(path, hash)\n        add_loaded_features(loaded_features)\n\n        resolver.resolve_inheritance_from_gems(hash)\n        resolver.resolve_inheritance(path, hash, file, debug?)\n        hash.delete('inherit_from')\n\n        # Adding missing namespaces only after resolving requires & inheritance,\n        # since both can introduce new cops that need to be considered here.\n        add_missing_namespaces(path, hash)\n\n        Config.create(hash, path, check: check)\n      end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "25"
  },
  {
    "raw_code": "def load_yaml_configuration(absolute_path)\n        file_contents = read_file(absolute_path)\n        yaml_code = Dir.chdir(File.dirname(absolute_path)) { ERB.new(file_contents).result }\n        yaml_tree = check_duplication(yaml_code, absolute_path)\n        hash = yaml_tree_to_hash(yaml_tree) || {}\n\n        puts \"configuration from #{absolute_path}\" if debug?\n\n        unless hash.is_a?(Hash)\n          raise(ValidationError, \"Malformed configuration in #{absolute_path}\")\n        end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "26"
  },
  {
    "raw_code": "def merge(base_hash, derived_hash)\n        resolver.merge(base_hash, derived_hash)\n      end",
    "comment": "Return a recursive merge of two hashes. That is, a normal hash merge, with the addition that any value that is a hash, and occurs in both arguments, will also be merged. And so on.",
    "label": "",
    "id": "27"
  },
  {
    "raw_code": "def configuration_file_for(target_dir)\n        ConfigFinder.find_config_path(target_dir)\n      end",
    "comment": "Returns the path of .rubocop.yml searching upwards in the directory structure starting at the given directory where the inspected file is. If no .rubocop.yml is found there, the user's home directory is checked. If there's no .rubocop.yml there either, the path to the default file is returned.",
    "label": "",
    "id": "28"
  },
  {
    "raw_code": "def inject_defaults!(config_yml_path)\n        if Pathname(config_yml_path).directory?\n          # TODO: Since the warning noise is expected to be high until some time after the release,\n          # warnings will only be issued when `RUBYOPT=-w` is specified.\n          # To proceed step by step, the next step is to remove `$VERBOSE` and always issue warning.\n          # Eventually, `project_root` will no longer be accepted.\n          if $VERBOSE\n            warn Rainbow(<<~MESSAGE).yellow, uplevel: 1\n              Use config YAML file path instead of project root directory.\n              e.g., `path/to/config/default.yml`\n            MESSAGE\n          end",
    "comment": "This API is primarily intended for testing and documenting plugins. When testing a plugin using `rubocop/rspec/support`, the plugin is loaded automatically, so this API is usually not needed. It is intended to be used only when implementing tests that do not use `rubocop/rspec/support`. rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "29"
  },
  {
    "raw_code": "def project_root\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `RuboCop::ConfigLoader.project_root` is deprecated and will be removed in RuboCop 2.0. \\\n          Use `RuboCop::ConfigFinder.project_root` instead.\n        WARNING\n\n        ConfigFinder.project_root\n      end",
    "comment": "rubocop:enable Metrics/MethodLength Returns the path RuboCop inferred as the root of the project. No file searches will go past this directory. @deprecated Use `RuboCop::ConfigFinder.project_root` instead.",
    "label": "",
    "id": "30"
  },
  {
    "raw_code": "def merge_with_default(config, config_file, unset_nil: true)\n        resolver.merge_with_default(config, config_file, unset_nil: unset_nil)\n      end",
    "comment": "Merges the given configuration with the default one.",
    "label": "",
    "id": "31"
  },
  {
    "raw_code": "def add_loaded_plugins(loaded_plugins)\n        @loaded_plugins.merge(Array(loaded_plugins))\n      end",
    "comment": "@api private Used to add plugins that were required inside a config or from the CLI using `--plugin`.",
    "label": "",
    "id": "32"
  },
  {
    "raw_code": "def add_loaded_features(loaded_features)\n        @loaded_features.merge(Array(loaded_features))\n      end",
    "comment": "@api private Used to add features that were required inside a config or from the CLI using `--require`.",
    "label": "",
    "id": "33"
  },
  {
    "raw_code": "def read_file(absolute_path)\n        File.read(absolute_path, encoding: Encoding::UTF_8)\n      rescue Errno::ENOENT\n        raise ConfigNotFoundError, \"Configuration file not found: #{absolute_path}\"\n      end",
    "comment": "Read the specified file, or exit with a friendly, concise message on stderr. Care is taken to use the standard OS exit code for a \"file not found\" error.",
    "label": "",
    "id": "34"
  },
  {
    "raw_code": "def options\n      # If there's no existing TODO file, generate one\n      return DEFAULT_OPTIONS unless todo_exists?\n\n      match = generation_command.match(COMMAND_REGEX)\n      return DEFAULT_OPTIONS unless match\n\n      options = match[1].split\n      Options.new.parse(options).first\n    end",
    "comment": "Get options from the comment in the TODO file, and parse them as options",
    "label": "",
    "id": "35"
  },
  {
    "raw_code": "def deserialize_offenses(offenses)\n      offenses.map! do |o|\n        location = location_from_source_buffer(o)\n        Cop::Offense.new(o['severity'], location, o['message'], o['cop_name'], o['status'].to_sym)\n      end",
    "comment": "Restore an offense object loaded from a JSON file.",
    "label": "",
    "id": "36"
  },
  {
    "raw_code": "def source_buffer\n      @source_buffer ||= begin\n        source = File.read(@filename, encoding: Encoding::UTF_8)\n        Parser::Source::Buffer.new(@filename, source: source)\n      end",
    "comment": "Delay creation until needed. Some type of offenses will have no buffer associated with them and be global only. For these, trying to create the buffer will likely fail, for example because of unknown encoding comments.",
    "label": "",
    "id": "37"
  },
  {
    "raw_code": "def self.version(debug: false, env: nil)\n      if debug\n        target_ruby_version = target_ruby_version(env)\n        verbose_version = format(MSG, version: STRING,\n                                      parser_version: parser_version(target_ruby_version),\n                                      rubocop_ast_version: RuboCop::AST::Version::STRING,\n                                      target_ruby_version: target_ruby_version,\n                                      ruby_engine: RUBY_ENGINE, ruby_version: RUBY_VERSION,\n                                      server_mode: server_mode,\n                                      ruby_platform: RUBY_PLATFORM)\n        return verbose_version unless env\n\n        extension_versions = extension_versions(env)\n        return verbose_version if extension_versions.empty?\n\n        <<~VERSIONS\n          #{verbose_version}\n          #{extension_versions.join(\"\\n\")}\n        VERSIONS\n      else\n        STRING\n      end",
    "comment": "NOTE: Marked as private but used by gems like standard. @api private rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "38"
  },
  {
    "raw_code": "def self.verbose(env: nil)\n      version(debug: true, env: env)\n    end",
    "comment": "rubocop:enable Metrics/MethodLength @api private",
    "label": "",
    "id": "39"
  },
  {
    "raw_code": "def self.parser_version(target_ruby_version)\n      config_path = ConfigFinder.find_config_path(Dir.pwd)\n      yaml = Util.silence_warnings do\n        ConfigLoader.load_yaml_configuration(config_path)\n      end",
    "comment": "@api private",
    "label": "",
    "id": "40"
  },
  {
    "raw_code": "def self.extension_versions(env)\n      plugins = config_for_pwd(env).loaded_plugins\n      plugin_versions = plugins.filter_map do |plugin|\n        next if Plugin::BUILTIN_INTERNAL_PLUGINS.key?(plugin.about.name)\n        next unless (plugin_name = plugin.about.name)\n\n        \"  - #{plugin_name} #{plugin.about.version}\"\n      end",
    "comment": "@api private rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength, Metrics/PerceivedComplexity",
    "label": "",
    "id": "41"
  },
  {
    "raw_code": "def self.target_ruby_version(env)\n      if env\n        config_for_pwd(env).target_ruby_version\n      else\n        TargetRuby.new(Config.new).version\n      end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength, Metrics/PerceivedComplexity @api private",
    "label": "",
    "id": "42"
  },
  {
    "raw_code": "def self.config_for_pwd(env)\n      Util.silence_warnings do\n        # Suppress any config issues when loading the config (ie. deprecations,\n        # pending cops, etc.).\n        env.config_store.unvalidated.for_pwd\n      end",
    "comment": "@api private",
    "label": "",
    "id": "43"
  },
  {
    "raw_code": "def self.feature_version(feature)\n      capitalized_feature = feature.capitalize\n      extension_name = CANONICAL_FEATURE_NAMES.fetch(capitalized_feature, capitalized_feature)\n\n      # Find by RuboCop core version style (e.g. rubocop-performance, rubocop-rspec)\n      RuboCop.const_get(extension_name)::Version::STRING\n    rescue NameError\n      begin\n        # Find by `bundle gem` version style (e.g. rubocop-rake, rubocop-packaging)\n        RuboCop.const_get(extension_name)::VERSION\n      rescue NameError\n        # noop\n      end",
    "comment": "Returns feature version in one of two ways:  * Find by RuboCop core version style (e.g. rubocop-performance, rubocop-rspec) * Find by `bundle gem` version style (e.g. rubocop-rake)  @api private",
    "label": "",
    "id": "44"
  },
  {
    "raw_code": "def self.document_version\n      STRING.match('\\d+\\.\\d+').to_s\n    end",
    "comment": "@api private",
    "label": "",
    "id": "45"
  },
  {
    "raw_code": "def self.server_mode\n      RuboCop.const_defined?(:Server) && Server.running? ? ' +server' : ''\n    end",
    "comment": "@api private",
    "label": "",
    "id": "46"
  },
  {
    "raw_code": "def initialize(lockfile_path = nil)\n      lockfile_path ||= begin\n        ::Bundler.default_lockfile if use_bundler_lock_parser?\n      rescue ::Bundler::GemfileNotFound\n        nil # We might not be a folder with a Gemfile, but that's okay.\n      end",
    "comment": "@param [String, Pathname, nil] lockfile_path",
    "label": "",
    "id": "47"
  },
  {
    "raw_code": "def dependencies\n      return [] unless parser\n\n      parser.dependencies.values\n    end",
    "comment": "Gems that the bundle directly depends on. @return [Array<Bundler::Dependency>, nil]",
    "label": "",
    "id": "48"
  },
  {
    "raw_code": "def gems\n      return [] unless parser\n\n      # `Bundler::LockfileParser` returns `Bundler::LazySpecification` objects\n      # which are not resolved, so extract the dependencies from them\n      parser.dependencies.values.concat(parser.specs.flat_map(&:dependencies))\n    end",
    "comment": "All activated gems, including transitive dependencies. @return [Array<Bundler::Dependency>, nil]",
    "label": "",
    "id": "49"
  },
  {
    "raw_code": "def gem_versions(include_transitive_dependencies: true)\n      return {} unless parser\n\n      all_gem_versions = parser.specs.to_h { |spec| [spec.name, spec.version] }\n\n      if include_transitive_dependencies\n        all_gem_versions\n      else\n        direct_dep_names = parser.dependencies.keys\n        all_gem_versions.slice(*direct_dep_names)\n      end",
    "comment": "Returns the locked versions of gems from this lockfile. @param [Boolean] include_transitive_dependencies: When false, only direct dependencies are returned, i.e. those listed explicitly in the `Gemfile`. @returns [Hash{String => Gem::Version}] The locked gem versions, keyed by the gems' names.",
    "label": "",
    "id": "50"
  },
  {
    "raw_code": "def includes_gem?(name)\n      gems.any? { |gem| gem.name == name }\n    end",
    "comment": "Whether this lockfile includes the named gem, directly or indirectly. @param [String] name @return [Boolean]",
    "label": "",
    "id": "51"
  },
  {
    "raw_code": "def parser\n      return @parser if defined?(@parser)\n\n      @parser = if @lockfile_path && File.exist?(@lockfile_path) && use_bundler_lock_parser?\n                  begin\n                    lockfile = ::Bundler.read_file(@lockfile_path)\n                    ::Bundler::LockfileParser.new(lockfile) if lockfile\n                  rescue ::Bundler::BundlerError\n                    nil\n                  end",
    "comment": "@return [Bundler::LockfileParser, nil]",
    "label": "",
    "id": "52"
  },
  {
    "raw_code": "def start_with_marker?\n      comment.text.start_with?(DIRECTIVE_MARKER_REGEXP)\n    end",
    "comment": "Checks if the comment starts with `# rubocop:` marker",
    "label": "",
    "id": "53"
  },
  {
    "raw_code": "def malformed?\n      return true if !start_with_marker? || @match_data.nil?\n\n      tail = @match_data.post_match.lstrip\n      !(tail.empty? || tail.start_with?(TRAILING_COMMENT_MARKER))\n    end",
    "comment": "Checks if the comment is malformed as a `# rubocop:` directive",
    "label": "",
    "id": "54"
  },
  {
    "raw_code": "def missing_cop_name?\n      MALFORMED_DIRECTIVE_WITHOUT_COP_NAME_REGEXP.match?(comment.text)\n    end",
    "comment": "Checks if the directive comment is missing a cop name",
    "label": "",
    "id": "55"
  },
  {
    "raw_code": "def single_line?\n      !comment.text.start_with?(DIRECTIVE_COMMENT_REGEXP)\n    end",
    "comment": "Checks if this directive relates to single line",
    "label": "",
    "id": "56"
  },
  {
    "raw_code": "def match?(cop_names)\n      parsed_cop_names.uniq.sort == cop_names.uniq.sort\n    end",
    "comment": "Checks if this directive contains all the given cop names",
    "label": "",
    "id": "57"
  },
  {
    "raw_code": "def match_captures\n      @match_captures ||= @match_data&.captures\n    end",
    "comment": "Returns match captures to directive comment pattern",
    "label": "",
    "id": "58"
  },
  {
    "raw_code": "def disabled?\n      %w[disable todo].include?(mode)\n    end",
    "comment": "Checks if this directive disables cops",
    "label": "",
    "id": "59"
  },
  {
    "raw_code": "def enabled?\n      mode == 'enable'\n    end",
    "comment": "Checks if this directive enables cops",
    "label": "",
    "id": "60"
  },
  {
    "raw_code": "def enabled_all?\n      !disabled? && all_cops?\n    end",
    "comment": "Checks if this directive enables all cops",
    "label": "",
    "id": "61"
  },
  {
    "raw_code": "def disabled_all?\n      disabled? && all_cops?\n    end",
    "comment": "Checks if this directive disables all cops",
    "label": "",
    "id": "62"
  },
  {
    "raw_code": "def all_cops?\n      cops == 'all'\n    end",
    "comment": "Checks if all cops specified in this directive",
    "label": "",
    "id": "63"
  },
  {
    "raw_code": "def cop_names\n      @cop_names ||= all_cops? ? all_cop_names : parsed_cop_names\n    end",
    "comment": "Returns array of specified in this directive cop names",
    "label": "",
    "id": "64"
  },
  {
    "raw_code": "def raw_cop_names\n      @raw_cop_names ||= (cops || '').split(/,\\s*/)\n    end",
    "comment": "Returns an array of cops for this directive comment, without resolving departments",
    "label": "",
    "id": "65"
  },
  {
    "raw_code": "def department_names\n      raw_cop_names.select { |cop| department?(cop) }\n    end",
    "comment": "Returns array of specified in this directive department names when all department disabled",
    "label": "",
    "id": "66"
  },
  {
    "raw_code": "def in_directive_department?(cop)\n      department_names.any? { |department| cop.start_with?(department) }\n    end",
    "comment": "Checks if directive departments include cop",
    "label": "",
    "id": "67"
  },
  {
    "raw_code": "def overridden_by_department?(cop)\n      in_directive_department?(cop) && raw_cop_names.include?(cop)\n    end",
    "comment": "Checks if cop department has already used in directive comment",
    "label": "",
    "id": "68"
  },
  {
    "raw_code": "def line_number\n      comment.source_range.line\n    end",
    "comment": "Returns line number for directive",
    "label": "",
    "id": "69"
  },
  {
    "raw_code": "def load(config_directory_path:, feature:)\n        new(config_directory_path: config_directory_path, feature: feature).load\n      end",
    "comment": "@param [String] config_directory_path @param [String] feature",
    "label": "",
    "id": "70"
  },
  {
    "raw_code": "def initialize(config_directory_path:, feature:)\n      @config_directory_path = config_directory_path\n      @feature = feature\n    end",
    "comment": "@param [String] config_directory_path @param [String] feature",
    "label": "",
    "id": "71"
  },
  {
    "raw_code": "def namespaced_feature\n      @feature.tr('-', '/')\n    end",
    "comment": "@return [String]",
    "label": "",
    "id": "72"
  },
  {
    "raw_code": "def namespaced_target\n      if relative?\n        relative(namespaced_feature)\n      else\n        namespaced_feature\n      end",
    "comment": "@return [String]",
    "label": "",
    "id": "73"
  },
  {
    "raw_code": "def relative(feature)\n      ::File.join(@config_directory_path, feature)\n    end",
    "comment": "@param [String] @return [String]",
    "label": "",
    "id": "74"
  },
  {
    "raw_code": "def relative?\n      @feature.start_with?('.')\n    end",
    "comment": "@return [Boolean]",
    "label": "",
    "id": "75"
  },
  {
    "raw_code": "def seems_cannot_load_such_file_error?(error)\n      error.path == target\n    end",
    "comment": "@param [LoadError] error @return [Boolean]",
    "label": "",
    "id": "76"
  },
  {
    "raw_code": "def target\n      if relative?\n        relative(@feature)\n      else\n        @feature\n      end",
    "comment": "@return [String]",
    "label": "",
    "id": "77"
  },
  {
    "raw_code": "def match_path?(pattern, path)\n      case pattern\n      when String\n        matches =\n          if pattern == path\n            true\n          elsif glob?(pattern)\n            # File name matching doesn't really work with relative patterns that start with \"..\". We\n            # get around that problem by converting the pattern to an absolute path.\n            pattern = File.expand_path(pattern) if pattern.start_with?('..')\n\n            File.fnmatch?(pattern, path, File::FNM_PATHNAME | File::FNM_EXTGLOB)\n          end",
    "comment": "rubocop:disable Metrics/MethodLength, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "78"
  },
  {
    "raw_code": "def absolute?(path)\n      %r{\\A([A-Z]:)?/}i.match?(path)\n    end",
    "comment": "rubocop:enable Metrics/MethodLength, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity Returns true for an absolute Unix or Windows path.",
    "label": "",
    "id": "79"
  },
  {
    "raw_code": "def glob?(path)\n      path.match?(/[*{\\[?]/)\n    end",
    "comment": "Returns true for a glob",
    "label": "",
    "id": "80"
  },
  {
    "raw_code": "def maybe_hidden_file?(path)\n      return false unless path.include?(HIDDEN_FILE_PATTERN)\n\n      separator_index = path.rindex(File::SEPARATOR)\n      return false unless separator_index\n\n      dot_index = path.index('.', separator_index + 1)\n      dot_index == separator_index + 1\n    end",
    "comment": "Loose check to reduce memory allocations",
    "label": "",
    "id": "81"
  },
  {
    "raw_code": "def define_options\n      OptionParser.new do |opts|\n        opts.banner = rainbow.wrap('Usage: rubocop [options] [file1, file2, ...]').bright\n\n        add_check_options(opts)\n        add_cache_options(opts)\n        add_lsp_option(opts)\n        add_server_options(opts)\n        add_output_options(opts)\n        add_autocorrection_options(opts)\n        add_config_generation_options(opts)\n        add_additional_modes(opts)\n        add_general_options(opts)\n\n        # `stackprof` is not supported on JRuby and Windows.\n        add_profile_options(opts) if RUBY_ENGINE == 'ruby' && !Platform.windows?\n      end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "82"
  },
  {
    "raw_code": "def add_check_options(opts) # rubocop:disable Metrics/AbcSize, Metrics/MethodLength\n      section(opts, 'Basic Options') do # rubocop:disable Metrics/BlockLength\n        option(opts, '-l', '--lint') do\n          @options[:only] ||= []\n          @options[:only] << 'Lint'\n        end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "83"
  },
  {
    "raw_code": "def add_autocorrection_options(opts) # rubocop:disable Metrics/MethodLength\n      section(opts, 'Autocorrection') do\n        option(opts, '-a', '--autocorrect') { @options[:safe_autocorrect] = true }\n        option(opts, '--auto-correct') do\n          handle_deprecated_option('--auto-correct', '--autocorrect')\n          @options[:safe_autocorrect] = true\n        end",
    "comment": "rubocop:todo Naming/InclusiveLanguage the autocorrect command-line arguments map to the autocorrect @options values like so: :fix_layout  :autocorrect  :safe_autocorrect  :autocorrect_all -x, --fix-layout           true         true          -                  - -a, --auto-correct         -            true          true               - --safe-auto-correct    -            true          true               - -A, --auto-correct-all     -            true          -                  true",
    "label": "",
    "id": "84"
  },
  {
    "raw_code": "def add_config_generation_options(opts)\n      section(opts, 'Config Generation') do\n        option(opts, '--auto-gen-config')\n\n        option(opts, '--regenerate-todo') do\n          @options.replace(ConfigRegeneration.new.options.merge(@options))\n        end",
    "comment": "rubocop:enable Naming/InclusiveLanguage",
    "label": "",
    "id": "85"
  },
  {
    "raw_code": "def section(opts, heading, &_block)\n      heading = rainbow.wrap(heading).bright\n      opts.separator(\"\\n#{heading}:\\n\")\n      yield\n    end",
    "comment": "Creates a section of options in order to separate them visually when using `--help`.",
    "label": "",
    "id": "86"
  },
  {
    "raw_code": "def option(opts, *args)\n      long_opt_symbol = long_opt_symbol(args)\n      args += Array(OptionsHelp::TEXT[long_opt_symbol])\n      opts.on(*args) do |arg|\n        @options[long_opt_symbol] = arg\n        yield arg if block_given?\n      end",
    "comment": "Sets a value in the @options hash, based on the given long option and its value, in addition to calling the block if a block is given.",
    "label": "",
    "id": "87"
  },
  {
    "raw_code": "def long_opt_symbol(args)\n      long_opt = args.find { |arg| arg.start_with?('--') }\n      long_opt[2..].sub('[no-]', '').sub(/ .*/, '').tr('-', '_').gsub(/[\\[\\]]/, '').to_sym\n    end",
    "comment": "Finds the option in `args` starting with -- and converts it to a symbol, e.g. [..., '--autocorrect', ...] to :autocorrect.",
    "label": "",
    "id": "88"
  },
  {
    "raw_code": "def validate_cop_list(names)\n        return unless names\n\n        cop_names = Cop::Registry.global.names\n        departments = Cop::Registry.global.departments.map(&:to_s)\n\n        names.each do |name|\n          next if cop_names.include?(name)\n          next if departments.include?(name)\n          next if SYNTAX_DEPARTMENTS.include?(name)\n\n          raise IncorrectCopNameError, format_message_from(name, cop_names)\n        end",
    "comment": "Cop name validation must be done later than option parsing, so it's not called from within Options.",
    "label": "",
    "id": "89"
  },
  {
    "raw_code": "def validate_compatibility # rubocop:disable Metrics/MethodLength\n      if only_includes_redundant_disable?\n        raise OptionArgumentError, 'Lint/RedundantCopDisableDirective cannot be used with --only.'\n      end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "90"
  },
  {
    "raw_code": "def validate_auto_gen_config\n      return if @options.key?(:auto_gen_config)\n\n      message = '--%<flag>s can only be used together with --auto-gen-config.'\n\n      %i[exclude_limit offense_counts auto_gen_timestamp\n         auto_gen_only_exclude].each do |option|\n        if @options.key?(option)\n          raise OptionArgumentError, format(message, flag: option.to_s.tr('_', '-'))\n        end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "91"
  },
  {
    "raw_code": "def handle_switch(directive, names, extras)\n      directive.cop_names.each do |name|\n        if directive.disabled?\n          names[name] += 1\n        elsif names[name].positive?\n          names[name] -= 1\n        else\n          extras[directive.comment] << name\n        end",
    "comment": "Collect cops that have been disabled or enabled by name in a directive comment so that `Lint/RedundantCopEnableDirective` can register offenses correctly.",
    "label": "",
    "id": "92"
  },
  {
    "raw_code": "def fix_include_paths(base_config_path, hash, path, key, value)\n      return unless File.basename(base_config_path).start_with?('.rubocop')\n\n      base_dir = File.dirname(base_config_path)\n      derived_dir = File.dirname(path)\n      hash[key]['Include'] = value['Include'].map do |include_path|\n        PathUtil.relative_path(File.join(base_dir, include_path), derived_dir)\n      end",
    "comment": "When one .rubocop.yml file inherits from another .rubocop.yml file, the Include paths in the base configuration are relative to the directory where the base configuration file is. For the derived configuration, we need to make those paths relative to where the derived configuration file is.",
    "label": "",
    "id": "93"
  },
  {
    "raw_code": "def merge_with_default(config, config_file, unset_nil:)\n      default_configuration = ConfigLoader.default_configuration\n\n      disabled_by_default = config.for_all_cops['DisabledByDefault']\n      enabled_by_default = config.for_all_cops['EnabledByDefault']\n\n      if disabled_by_default || enabled_by_default\n        default_configuration = transform(default_configuration) do |params|\n          params.merge('Enabled' => !disabled_by_default)\n        end",
    "comment": "Merges the given configuration with the default one. If AllCops:DisabledByDefault is true, it changes the Enabled params so that only cops from user configuration are enabled. If AllCops:EnabledByDefault is true, it changes the Enabled params so that only cops explicitly disabled in user configuration are disabled.",
    "label": "",
    "id": "94"
  },
  {
    "raw_code": "def merge(base_hash, derived_hash, **opts)\n      result = base_hash.merge(derived_hash)\n      keys_appearing_in_both = base_hash.keys & derived_hash.keys\n      keys_appearing_in_both.each do |key|\n        if opts[:unset_nil] && derived_hash[key].nil?\n          result.delete(key)\n        elsif merge_hashes?(base_hash, derived_hash, key)\n          result[key] = merge(base_hash[key], derived_hash[key], **opts)\n        elsif should_union?(derived_hash, base_hash, opts[:inherit_mode], key)\n          result[key] = Array(base_hash[key]) | Array(derived_hash[key])\n        elsif opts[:debug]\n          warn_on_duplicate_setting(base_hash, derived_hash, key, **opts)\n        end",
    "comment": "Return a recursive merge of two hashes. That is, a normal hash merge, with the addition that any value that is a hash, and occurs in both arguments, will also be merged. And so on.  rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "95"
  },
  {
    "raw_code": "def override_department_setting_for_cops(base_hash, derived_hash)\n      derived_hash.each_key do |key|\n        next unless key =~ %r{(.*)/.*}\n\n        department = Regexp.last_match(1)\n        next unless disabled?(derived_hash, department) || disabled?(base_hash, department)\n\n        # The `override_department` setting for the `Enabled` parameter is an\n        # internal setting that's not documented in the manual. It will cause a\n        # cop to be enabled later, when logic surrounding enabled/disabled it\n        # run, even though its department is disabled.\n        derived_hash[key]['Enabled'] = 'override_department' if derived_hash[key]['Enabled']\n      end",
    "comment": "rubocop:enable Metrics/AbcSize An `Enabled: true` setting in user configuration for a cop overrides an `Enabled: false` setting for its department.",
    "label": "",
    "id": "96"
  },
  {
    "raw_code": "def override_enabled_for_disabled_departments(base_hash, derived_hash)\n      cops_to_disable = derived_hash.each_key.with_object([]) do |key, cops|\n        next unless disabled?(derived_hash, key)\n\n        cops.concat(base_hash.keys.grep(Regexp.new(\"^#{key}/\")))\n      end",
    "comment": "If a cop was previously explicitly enabled, but then superseded by the department being disabled, disable it.",
    "label": "",
    "id": "97"
  },
  {
    "raw_code": "def project_root\n        @project_root ||= find_project_root\n      end",
    "comment": "Returns the path RuboCop inferred as the root of the project. No file searches will go past this directory.",
    "label": "",
    "id": "98"
  },
  {
    "raw_code": "def initialize(departments: [], extra_info: {}, base_dir: Dir.pwd, plugin_name: nil)\n    @departments = departments.map(&:to_sym).sort!\n    @extra_info = extra_info\n    @cops = RuboCop::Cop::Registry.global\n    @config = RuboCop::ConfigLoader.default_configuration\n    # NOTE: For example, this prevents excessive plugin loading before another task executes,\n    # in cases where plugins are already loaded by `internal_investigation`.\n    if plugin_name && @config.loaded_plugins.none? { |plugin| plugin.about.name == plugin_name }\n      RuboCop::Plugin.integrate_plugins(RuboCop::Config.new, [plugin_name])\n    end",
    "comment": "This class will only generate documentation for cops that belong to one of the departments given in the `departments` array. E.g. if we only wanted documentation for Lint cops:  CopsDocumentationGenerator.new(departments: ['Lint']).call  For plugin extensions, specify `:plugin_name` keyword as follows:  CopsDocumentationGenerator.new( departments: ['Performance'], plugin_name: 'rubocop-performance' ).call  You can append additional information:  callback = ->(data) { required_rails_version(data.cop) } CopsDocumentationGenerator.new(extra_info: { ruby_version: callback }).call  This will insert the string returned from the lambda _after_ the section from RuboCop itself. See `CopsDocumentationGenerator::STRUCTURE` for available sections. ",
    "label": "",
    "id": "99"
  },
  {
    "raw_code": "def properties(cop)\n    header = [\n      'Enabled by default', 'Safe', 'Supports autocorrection', 'Version Added',\n      'Version Changed'\n    ]\n    autocorrect = if cop.support_autocorrect?\n                    context = cop.new.always_autocorrect? ? 'Always' : 'Command-line only'\n\n                    \"#{context}#{' (Unsafe)' unless cop.new(config).safe_autocorrect?}\"\n                  else\n                    'No'\n                  end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "100"
  },
  {
    "raw_code": "def cop_header(cop)\n    content = +\"\\n\"\n    content << \"[##{to_anchor(cop.cop_name)}]\\n\"\n    content << \"== #{cop.cop_name}\\n\"\n    content << \"\\n\"\n    content\n  end",
    "comment": "rubocop:enable Metrics/MethodLength",
    "label": "",
    "id": "101"
  },
  {
    "raw_code": "def configurable_values(cop_config, name)\n    case name\n    when /^Enforced/\n      supported_style_name = RuboCop::Cop::Util.to_supported_styles(name)\n      format_table_value(cop_config[supported_style_name])\n    when 'IndentationWidth'\n      'Integer'\n    when 'Database'\n      format_table_value(cop_config['SupportedDatabases'])\n    else\n      case cop_config[name]\n      when String\n        'String'\n      when Integer\n        'Integer'\n      when Float\n        'Float'\n      when true, false\n        'Boolean'\n      when Array\n        'Array'\n      else\n        ''\n      end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity,Metrics/MethodLength",
    "label": "",
    "id": "102"
  },
  {
    "raw_code": "def to_table(header, content)\n    table = ['|===', \"| #{header.join(' | ')}\\n\\n\"].join(\"\\n\")\n    marked_contents = content.map do |plain_content|\n      # Escape `|` with backslash to prevent the regexp `|` is not used as a table separator.\n      plain_content.map { |c| \"| #{c.gsub('|', '\\|')}\" }.join(\"\\n\")\n    end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity,Metrics/MethodLength",
    "label": "",
    "id": "103"
  },
  {
    "raw_code": "def print_cops_of_department(department)\n    selected_cops = cops_of_department(department)\n    content = +<<~HEADER\n      ////\n        Do NOT edit this file by hand directly, as it is automatically generated.\n\n        Please make any necessary changes to the cop documentation within the source files themselves.\n      ////\n\n      = #{department}\n    HEADER\n    selected_cops.each { |cop| content << print_cop_with_doc(cop) }\n    content << footer_for_department(department)\n    file_name = \"#{docs_path}/pages/#{department_to_basename(department)}.adoc\"\n    File.open(file_name, 'w') do |file|\n      puts \"* generated #{file_name}\"\n      file.write(\"#{content.strip}\\n\")\n    end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "104"
  },
  {
    "raw_code": "def print_cop_with_doc(cop) # rubocop:todo Metrics/AbcSize, Metrics/MethodLength\n    cop_config = config.for_cop(cop)\n    non_display_keys = %w[\n      Enabled\n      Description\n      StyleGuide\n      Reference References\n      Safe SafeAutoCorrect AutoCorrect\n      VersionAdded VersionChanged\n    ]\n    parameters = cop_config.reject { |k| non_display_keys.include? k }\n    description = 'No documentation'\n    example_objects = safety_objects = see_objects = []\n    cop_code(cop) do |code_object|\n      description = code_object.docstring unless code_object.docstring.blank?\n      example_objects = code_object.tags('example')\n      safety_objects = code_object.tags('safety')\n      see_objects = code_object.tags('see')\n    end",
    "comment": "rubocop:enable Metrics/MethodLength",
    "label": "",
    "id": "105"
  },
  {
    "raw_code": "def to_anchor(title)\n    title.delete('/').tr(' ', '-').gsub(/[^a-zA-Z0-9-]/, '_').downcase\n  end",
    "comment": "HTML anchor are somewhat limited in what characters they can contain, just accept a known-good subset. As long as it's consistent it doesn't matter.  Style/AccessModifierDeclarations => styleaccessmodifierdeclarations OnlyFor: [] (default) => onlyfor_-__-_default_",
    "label": "",
    "id": "106"
  },
  {
    "raw_code": "def find(args, mode)\n      return target_files_in_dir if args.empty?\n\n      files = []\n\n      args.uniq.each do |arg|\n        files += if File.directory?(arg)\n                   target_files_in_dir(arg.chomp(File::SEPARATOR))\n                 else\n                   process_explicit_path(arg, mode)\n                 end",
    "comment": "Generate a list of target files by expanding globbing patterns (if any). If args is empty, recursively find all Ruby source files under the current directory @return [Array] array of file paths",
    "label": "",
    "id": "107"
  },
  {
    "raw_code": "def target_files_in_dir(base_dir = Dir.pwd)\n      # Support Windows: Backslashes from command-line -> forward slashes\n      base_dir = base_dir.gsub(File::ALT_SEPARATOR, File::SEPARATOR) if File::ALT_SEPARATOR\n      all_files = find_files(base_dir, File::FNM_DOTMATCH)\n      base_dir_config = @config_store.for(base_dir)\n\n      target_files = if hidden_path?(base_dir)\n                       all_files.select { |file| ruby_file?(file) }\n                     else\n                       all_files.select { |file| to_inspect?(file, base_dir_config) }\n                     end",
    "comment": "Finds all Ruby source files under the current or other supplied directory. A Ruby source file is defined as a file with the `.rb` extension or a file with no extension that has a ruby shebang line as its first line. It is possible to specify includes and excludes using the config file, so you can include other Ruby files like Rakefiles and gemspecs. @param base_dir Root directory under which to search for ruby source files @return [Array] Array of filenames",
    "label": "",
    "id": "108"
  },
  {
    "raw_code": "def find_files(base_dir, flags)\n      # get all wanted directories first to improve speed of finding all files\n      exclude_pattern = combined_exclude_glob_patterns(base_dir)\n      dir_flags = flags | File::FNM_PATHNAME | File::FNM_EXTGLOB\n      patterns = wanted_dir_patterns(base_dir, exclude_pattern, dir_flags)\n      patterns.map! { |dir| File.join(dir, '*') }\n      # We need this special case to avoid creating the pattern\n      # /**/* which searches the entire file system.\n      patterns = [File.join(base_dir, '**/*')] if patterns.empty?\n\n      Dir.glob(patterns, flags).select { |path| FileTest.file?(path) }\n    end",
    "comment": "Search for files recursively starting at the given base directory using the given flags that determine how the match is made. Excluded files will be removed later by the caller, but as an optimization find_files removes the top level directories that are excluded in configuration in the normal way (dir/**/*).",
    "label": "",
    "id": "109"
  },
  {
    "raw_code": "def self.parse(comment)\n      case comment\n      when EmacsComment::REGEXP then EmacsComment.new(comment)\n      when VimComment::REGEXP   then VimComment.new(comment)\n      else\n        SimpleComment.new(comment)\n      end",
    "comment": "Detect magic comment format and pass it to the appropriate wrapper.  @param comment [String]  @return [RuboCop::MagicComment]",
    "label": "",
    "id": "110"
  },
  {
    "raw_code": "def frozen_string_literal?\n      frozen_string_literal == true\n    end",
    "comment": "Does the magic comment enable the frozen string literal feature.  Test whether the frozen string literal value is `true`. Cannot just return `frozen_string_literal` since an invalid magic comment like `# frozen_string_literal: yes` is possible and the truthy value `'yes'` does not actually enable the feature  @return [Boolean]",
    "label": "",
    "id": "111"
  },
  {
    "raw_code": "def frozen_string_literal_specified?\n      specified?(frozen_string_literal)\n    end",
    "comment": "Was a magic comment for the frozen string literal found?  @return [Boolean]",
    "label": "",
    "id": "112"
  },
  {
    "raw_code": "def shareable_constant_value_specified?\n      specified?(shareable_constant_value)\n    end",
    "comment": "Was a shareable_constant_value specified?  @return [Boolean]",
    "label": "",
    "id": "113"
  },
  {
    "raw_code": "def frozen_string_literal\n      return unless (setting = extract_frozen_string_literal)\n\n      case setting.downcase\n      when 'true'  then true\n      when 'false' then false\n      else\n        setting\n      end",
    "comment": "Expose the `frozen_string_literal` value coerced to a boolean if possible.  @return [Boolean] if value is `true` or `false` in any case @return [nil] if frozen_string_literal comment isn't found @return [String] if comment is found but isn't true or false",
    "label": "",
    "id": "114"
  },
  {
    "raw_code": "def shareable_constant_value\n      extract_shareable_constant_value\n    end",
    "comment": "Expose the `shareable_constant_value` value coerced to a boolean if possible.  @return [String] for shareable_constant_value config",
    "label": "",
    "id": "115"
  },
  {
    "raw_code": "def typed_specified?\n      specified?(extract_typed)\n    end",
    "comment": "Was the Sorbet `typed` sigil specified?  @return [Boolean]",
    "label": "",
    "id": "116"
  },
  {
    "raw_code": "def extract(pattern)\n      @comment[pattern, :token]\n    end",
    "comment": "Match the entire comment string with a pattern and take the first capture.  @param pattern [Regexp]  @return [String] if pattern matched @return [nil] otherwise",
    "label": "",
    "id": "117"
  },
  {
    "raw_code": "def without(type)\n        remaining = tokens.grep_v(/\\A#{self.class::KEYWORDS[type.to_sym]}/)\n        return '' if remaining.empty?\n\n        self.class::FORMAT % remaining.join(self.class::SEPARATOR)\n      end",
    "comment": "Rewrite the comment without a given token type",
    "label": "",
    "id": "118"
  },
  {
    "raw_code": "def match(keyword)\n        pattern = /\\A#{keyword}\\s*#{self.class::OPERATOR}\\s*#{TOKEN}\\z/\n\n        tokens.each do |token|\n          next unless (value = token[pattern, :token])\n\n          return value.downcase\n        end",
    "comment": "Find a token starting with the provided keyword and extract its value.  @param keyword [String]  @return [String] extracted value if it is found @return [nil] otherwise",
    "label": "",
    "id": "119"
  },
  {
    "raw_code": "def tokens\n        extract(self.class::REGEXP).split(self.class::SEPARATOR).map(&:strip)\n      end",
    "comment": "Individual tokens composing an editor specific comment string.  @return [Array<String>]",
    "label": "",
    "id": "120"
  },
  {
    "raw_code": "def extract_typed; end\n    end",
    "comment": "Emacs comments cannot specify Sorbet typechecking behavior.",
    "label": "",
    "id": "121"
  },
  {
    "raw_code": "def encoding\n        super if tokens.size > 1\n      end",
    "comment": "For some reason the fileencoding keyword only works if there is at least one other token included in the string. For example  # works # vim: foo=bar, fileencoding=ascii-8bit  # does nothing # vim: foo=bar, fileencoding=ascii-8bit ",
    "label": "",
    "id": "122"
  },
  {
    "raw_code": "def frozen_string_literal; end\n\n      # Vim comments cannot specify shareable constant values behavior.\n      def shareable_constant_value; end\n\n      # Vim comments cannot specify Sorbet typechecking behavior.\n      def extract_typed; end\n    end\n\n    # Wrapper for regular magic comments not bound to an editor.\n    #\n    # Simple comments can only specify one setting per comment.\n    #\n    # @example frozen string literal comments\n    #   comment1 = RuboCop::MagicComment.parse('# frozen_string_literal: true')\n    #   comment1.frozen_string_literal # => true\n    #   comment1.encoding              # => nil\n    #\n    # @example encoding comments\n    #   comment2 = RuboCop::MagicComment.parse('# encoding: utf-8')\n    #   comment2.frozen_string_literal # => nil\n    #   comment2.encoding              # => 'utf-8'\n    class SimpleComment < MagicComment\n      FSTRING_LITERAL_COMMENT = 'frozen_string_literal:\\s*(true|false)'\n\n      # Match `encoding` or `coding`\n      def encoding\n        extract(/\\A\\s*\\#\\s*(#{FSTRING_LITERAL_COMMENT})?\\s*#{KEYWORDS[:encoding]}: (#{TOKEN})/io)\n      end\n\n      # Rewrite the comment without a given token type\n      def without(type)\n        if @comment.match?(/\\A#\\s*#{self.class::KEYWORDS[type.to_sym]}/io)\n          ''\n        else\n          @comment\n        end\n      end\n\n      def new_frozen_string_literal(value)\n        \"# frozen_string_literal: #{value}\"\n      end\n\n      private\n\n      # Extract `frozen_string_literal`.\n      #\n      # The `frozen_string_literal` magic comment only works if it\n      # is the only text in the comment.\n      #\n      # Case-insensitive and dashes/underscores are acceptable.\n      # @see https://github.com/ruby/ruby/blob/78b95b49f8/parse.y#L7134-L7138\n      def extract_frozen_string_literal\n        extract(/\\A\\s*#\\s*#{KEYWORDS[:frozen_string_literal]}:\\s*#{TOKEN}\\s*\\z/io)\n      end\n\n      def extract_shareable_constant_value\n        extract(/\\A\\s*#\\s*#{KEYWORDS[:shareable_constant_value]}:\\s*#{TOKEN}\\s*\\z/io)\n      end\n\n      def extract_typed\n        extract(/\\A\\s*#\\s*#{KEYWORDS[:typed]}:\\s*#{TOKEN}\\s*\\z/io)\n      end\n    end",
    "comment": "Vim comments cannot specify frozen string literal behavior.",
    "label": "",
    "id": "123"
  },
  {
    "raw_code": "def initialize(hash = RuboCop::ConfigLoader.default_configuration, loaded_path = nil)\n      @loaded_path = loaded_path\n      @for_cop = Hash.new do |h, cop|\n        cop_name = cop.respond_to?(:cop_name) ? cop.cop_name : cop\n\n        if ConfigObsoletion.deprecated_cop_name?(cop)\n          # Since a deprecated cop will no longer have a qualified name (as the badge is no\n          # longer valid), and since we do not want to automatically enable the cop, we just\n          # set the configuration to an empty hash if it is unset.\n          # This is necessary to allow a renamed cop have its old configuration merged in\n          # before being used (which is necessary to allow it to be disabled via config).\n          cop_options = self[cop_name].dup || {}\n        else\n          qualified_cop_name = Cop::Registry.qualified_cop_name(cop_name, loaded_path, warn: false)\n          cop_options = self[qualified_cop_name].dup || {}\n          cop_options['Enabled'] = enable_cop?(qualified_cop_name, cop_options)\n\n          # If the cop has deprecated names (ie. it has been renamed), it is possible that\n          # users will still have old configuration for the cop's old name. In this case,\n          # if `ConfigObsoletion` is configured to warn rather than error (and therefore\n          # RuboCop runs), we want to respect the old configuration, so merge it in.\n          #\n          # NOTE: If there is configuration for both the cop and a deprecated names, the old\n          # configuration will be merged on top of the new configuration!\n          ConfigObsoletion.deprecated_names_for(cop).each do |deprecated_cop_name|\n            deprecated_config = @for_cop[deprecated_cop_name]\n            next if deprecated_config.empty?\n\n            warn Rainbow(<<~WARNING).yellow\n              Warning: Using `#{deprecated_cop_name}` configuration in #{loaded_path} for `#{cop}`.\n            WARNING\n\n            cop_options.merge!(@for_cop[deprecated_cop_name])\n          end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/MethodLength",
    "label": "",
    "id": "124"
  },
  {
    "raw_code": "def loaded_plugins\n      @loaded_plugins ||= ConfigLoader.loaded_plugins\n    end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/MethodLength",
    "label": "",
    "id": "125"
  },
  {
    "raw_code": "def internal?\n      base_config_path = File.expand_path(File.join(ConfigLoader::RUBOCOP_HOME, 'config'))\n      File.expand_path(loaded_path).start_with?(base_config_path)\n    end",
    "comment": "True if this is a config file that is shipped with RuboCop",
    "label": "",
    "id": "126"
  },
  {
    "raw_code": "def for_cop(cop)\n      @for_cop[cop]\n    end",
    "comment": "@return [Config] for the given cop / cop name. Note: the 'Enabled' attribute is calculated according to the department's and 'AllCops' configuration; other attributes are not inherited.",
    "label": "",
    "id": "127"
  },
  {
    "raw_code": "def for_enabled_cop(cop)\n      cop_enabled?(cop) ? for_cop(cop) : EMPTY_CONFIG\n    end",
    "comment": "@return [Config, Hash] for the given cop / cop name. If the given cop is enabled, returns its configuration hash. Otherwise, returns an empty hash.",
    "label": "",
    "id": "128"
  },
  {
    "raw_code": "def for_badge(badge)\n      @badge_config_cache[badge] ||= begin\n        department_config = self[badge.department_name]\n        cop_config = for_cop(badge.to_s)\n        if department_config\n          department_config.merge(cop_config)\n        else\n          cop_config\n        end",
    "comment": "@return [Config] for the given cop merged with that of its department (if any) Note: the 'Enabled' attribute is same as that returned by `for_cop`",
    "label": "",
    "id": "129"
  },
  {
    "raw_code": "def clusivity_config_for_badge?(badge)\n      exists = @clusivity_config_exists_cache[badge.to_s]\n      return exists unless exists.nil?\n\n      cop_config = for_badge(badge)\n      @clusivity_config_exists_cache[badge.to_s] = cop_config['Include'] || cop_config['Exclude']\n    end",
    "comment": "@return [Boolean] whether config for this badge has 'Include' or 'Exclude' keys @api private",
    "label": "",
    "id": "130"
  },
  {
    "raw_code": "def for_department(department_name)\n      @for_department ||= Hash.new { |h, dept| h[dept] = self[dept] || {} }\n      @for_department[department_name.to_s]\n    end",
    "comment": "@return [Config] for the given department name. Note: the 'Enabled' attribute will be present only if specified at the department's level",
    "label": "",
    "id": "131"
  },
  {
    "raw_code": "def possibly_include_hidden?\n      return @possibly_include_hidden if defined?(@possibly_include_hidden)\n\n      @possibly_include_hidden = patterns_to_include.any? do |s|\n        s.is_a?(Regexp) || s.start_with?('.') || s.include?('/.')\n      end",
    "comment": "Returns true if there's a chance that an Include pattern matches hidden files, false if that's definitely not possible.",
    "label": "",
    "id": "132"
  },
  {
    "raw_code": "def base_dir_for_path_parameters\n      @base_dir_for_path_parameters ||=\n        if loaded_path && File.basename(loaded_path).start_with?('.rubocop') &&\n           loaded_path != File.join(Dir.home, ConfigLoader::DOTFILE)\n          File.expand_path(File.dirname(loaded_path))\n        else\n          Dir.pwd\n        end",
    "comment": "Paths specified in configuration files starting with .rubocop are relative to the directory where that file is. Paths in other config files are relative to the current directory. This is so that paths in config/default.yml, for example, are not relative to RuboCop's config directory since that wouldn't work.",
    "label": "",
    "id": "133"
  },
  {
    "raw_code": "def bundler_lock_file_path\n      return nil unless loaded_path\n\n      base_path = base_dir_for_path_parameters\n      ['Gemfile.lock', 'gems.locked'].each do |file_name|\n        path = find_file_upwards(file_name, base_path)\n        return path if path\n      end",
    "comment": "@return [String, nil]",
    "label": "",
    "id": "134"
  },
  {
    "raw_code": "def gem_versions_in_target\n      @gem_versions_in_target ||= read_gem_versions_from_target_lockfile\n    end",
    "comment": "Returns target's locked gem versions (i.e. from Gemfile.lock or gems.locked) @returns [Hash{String => Gem::Version}] The locked gem versions, keyed by the gems' names.",
    "label": "",
    "id": "135"
  },
  {
    "raw_code": "def target_rails_version_from_bundler_lock_file\n      @target_rails_version_from_bundler_lock_file ||= read_rails_version_from_bundler_lock_file\n    end",
    "comment": "@return [Float, nil] The Rails version as a `major.minor` Float.",
    "label": "",
    "id": "136"
  },
  {
    "raw_code": "def read_rails_version_from_bundler_lock_file\n      return nil unless gem_versions_in_target\n\n      # Look for `railties` instead of `rails`, to support apps that only use a subset of `rails`\n      # See https://github.com/rubocop/rubocop/pull/11289\n      rails_version_in_target = gem_versions_in_target['railties']\n      return nil unless rails_version_in_target\n\n      gem_version_to_major_minor_float(rails_version_in_target)\n    end",
    "comment": "@return [Float, nil] The Rails version as a `major.minor` Float.",
    "label": "",
    "id": "137"
  },
  {
    "raw_code": "def gem_version_to_major_minor_float(gem_version)\n      segments = gem_version.segments\n      Float(\"#{segments[0]}.#{segments[1]}\")\n    end",
    "comment": "@param [Gem::Version] gem_version an object like `Gem::Version.new(\"7.1.2.3\")` @return [Float] The major and minor version, like `7.1`",
    "label": "",
    "id": "138"
  },
  {
    "raw_code": "def read_gem_versions_from_target_lockfile\n      lockfile_path = bundler_lock_file_path\n      return nil unless lockfile_path\n\n      Lockfile.new(lockfile_path).gem_versions\n    end",
    "comment": "@returns [Hash{String => Gem::Version}] The locked gem versions, keyed by the gems' names.",
    "label": "",
    "id": "139"
  },
  {
    "raw_code": "def report_summary(offense_counts)\n        per_file_counts = ordered_offense_counts(offense_counts)\n        total_count = total_offense_count(offense_counts)\n        file_count = per_file_counts.size\n\n        output.puts\n\n        column_width = total_count.to_s.length + 2\n        per_file_counts.each do |file_name, count|\n          output.puts \"#{count.to_s.ljust(column_width)}#{file_name}\\n\"\n        end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "140"
  },
  {
    "raw_code": "def ordered_offense_counts(offense_counts)\n        offense_counts.sort_by { |k, v| [-v, k] }.to_h\n      end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "141"
  },
  {
    "raw_code": "def binding\n          super\n        end",
    "comment": "Make Kernel#binding public. rubocop:disable Lint/UselessMethodDefinition",
    "label": "",
    "id": "142"
  },
  {
    "raw_code": "def decorated_message(offense)\n          offense.message.gsub(/`(.+?)`/) { \"<code>#{escape(Regexp.last_match(1))}</code>\" }\n        end",
    "comment": "rubocop:enable Lint/UselessMethodDefinition",
    "label": "",
    "id": "143"
  },
  {
    "raw_code": "def binding\n          super\n        end",
    "comment": "Make Kernel#binding public. rubocop:disable Lint/UselessMethodDefinition",
    "label": "",
    "id": "144"
  },
  {
    "raw_code": "def include_or_match?(arr, elm)\n        arr.include?(elm) || arr.any? { |x| x.is_a?(Regexp) && x.match?(elm) }\n      end",
    "comment": "Returns true if the given arr include the given elm or if any of the given arr is a regexp that matches the given elm.",
    "label": "",
    "id": "145"
  },
  {
    "raw_code": "def hash_for_location(offense)\n        {\n          start_line:   offense.line,\n          start_column: offense.real_column,\n          last_line:    offense.last_line,\n          last_column:  offense.last_column.zero? ? 1 : offense.last_column,\n          length:       offense.location.length,\n          # `line` and `column` exist for compatibility.\n          # Use `start_line` and `start_column` instead.\n          line:         offense.line,\n          column:       offense.real_column\n        }\n      end",
    "comment": "TODO: Consider better solution for Offense#real_column. The minimum value of `start_column: real_column` is 1. So, the minimum value of `last_column` should be 1. And non-zero value of `last_column` should be used as is.",
    "label": "",
    "id": "146"
  },
  {
    "raw_code": "def report_summary(offense_counts, offending_files_count)\n        per_cop_counts = ordered_offense_counts(offense_counts)\n        total_count = total_offense_count(offense_counts)\n\n        output.puts\n\n        column_width = total_count.to_s.length + 2\n        per_cop_counts.each do |cop_name, count|\n          output.puts \"#{count.to_s.ljust(column_width)}#{cop_information(cop_name)}\"\n        end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "147"
  },
  {
    "raw_code": "def ordered_offense_counts(offense_counts)\n        offense_counts.sort_by { |k, v| [-v, k] }.to_h\n      end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "148"
  },
  {
    "raw_code": "def initialize(output, options = {})\n        @output = output\n        @options = options\n      end",
    "comment": "@api public  @param output [IO] `$stdout` or opened file",
    "label": "",
    "id": "149"
  },
  {
    "raw_code": "def started(target_files); end\n\n      # @api public\n      #\n      # Invoked at the beginning of inspecting each files.\n      #\n      # @param file [String]\n      #   the file path\n      #\n      # @param options [Hash]\n      #   file specific information, currently this is always empty.\n      #\n      # @return [void]\n      def file_started(file, options); end\n\n      # @api public\n      #\n      # Invoked at the end of inspecting each files.\n      #\n      # @param file [String]\n      #   the file path\n      #\n      # @param offenses [Array(RuboCop::Cop::Offense)]\n      #   all detected offenses for the file\n      #\n      # @return [void]\n      #\n      # @see RuboCop::Cop::Offense\n      def file_finished(file, offenses); end\n\n      # @api public\n      #\n      # Invoked after all files are inspected or interrupted by user.\n      #\n      # @param inspected_files [Array(String)]\n      #   the inspected file paths.\n      #   This would be same as `target_files` passed to `#started`\n      #   unless RuboCop is interrupted by user.\n      #\n      # @return [void]\n      def finished(inspected_files); end\n    end\n  end\nend",
    "comment": "@api public  Invoked once before any files are inspected.  @param target_files [Array(String)] all target file paths to be inspected  @return [void]",
    "label": "",
    "id": "150"
  },
  {
    "raw_code": "def finished(_inspected_files)\n        output.puts %(<?xml version='1.0'?>)\n        output.puts %(<testsuites>)\n        output.puts %(  <testsuite name='rubocop' tests='#{@inspected_file_count}' failures='#{@offense_count}'>)\n\n        @test_case_elements.each do |test_case_element|\n          if test_case_element.failures.empty?\n            output.puts %(    <testcase classname='#{xml_escape test_case_element.classname}' name='#{test_case_element.name}'/>)\n          else\n            output.puts %(    <testcase classname='#{xml_escape test_case_element.classname}' name='#{test_case_element.name}'>)\n            test_case_element.failures.each do |failure_element|\n              output.puts %(      <failure type='#{failure_element.type}' message='#{xml_escape failure_element.message}'>)\n              output.puts %(        #{xml_escape failure_element.text})\n              output.puts %(      </failure>)\n            end",
    "comment": "rubocop:disable Layout/LineLength,Metrics/AbcSize,Metrics/MethodLength",
    "label": "",
    "id": "151"
  },
  {
    "raw_code": "def initialize(\n          file_count, offense_count, correction_count, correctable_count, rainbow,\n          safe_autocorrect: false\n        )\n          @file_count = file_count\n          @offense_count = offense_count\n          @correction_count = correction_count\n          @correctable_count = correctable_count\n          @rainbow = rainbow\n          @safe_autocorrect = safe_autocorrect\n        end",
    "comment": "rubocop:disable Metrics/ParameterLists",
    "label": "",
    "id": "152"
  },
  {
    "raw_code": "def summary\n          if @correction_count.positive?\n            if @correctable_count.positive?\n              \"#{files} inspected, #{offenses} detected, #{corrections} corrected, \" \\\n                \"#{correctable}\"\n            else\n              \"#{files} inspected, #{offenses} detected, #{corrections} corrected\"\n            end",
    "comment": "rubocop:enable Metrics/ParameterLists",
    "label": "",
    "id": "153"
  },
  {
    "raw_code": "def normalize(plugin_configs)\n          plugin_configs.to_h do |plugin_config|\n            if plugin_config == Plugin::OBSOLETE_INTERNAL_AFFAIRS_PLUGIN_NAME\n              warn Rainbow(<<~MESSAGE).yellow\n                Specify `rubocop-internal_affairs` instead of `rubocop/cop/internal_affairs` in your configuration.\n              MESSAGE\n              plugin_config = Plugin::INTERNAL_AFFAIRS_PLUGIN_NAME\n            end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "154"
  },
  {
    "raw_code": "def constantize(plugin_name, plugin_config)\n          require_plugin(plugin_config['require_path'])\n\n          if (constant_name = plugin_config['plugin_class_name'])\n            begin\n              Kernel.const_get(constant_name)\n            rescue StandardError\n              raise <<~MESSAGE\n                Failed while configuring plugin `#{plugin_name}': no constant with name `#{constant_name}' was found.\n              MESSAGE\n            end",
    "comment": "rubocop:enable Metrics/MethodLength",
    "label": "",
    "id": "155"
  },
  {
    "raw_code": "def load_plugin_rubocop_config(plugin, runner_context)\n          rules = plugin.rules(runner_context)\n\n          case rules.type\n          when :path\n            [ConfigLoader.load_file(rules.value, check: false), rules.value]\n          when :object\n            path = plugin.method(:rules).source_location[0]\n            [Config.create(rules.value, path, check: true), path]\n          when :error\n            plugin_name = plugin.about&.name || plugin.inspect\n            error_message = rules.value.respond_to?(:message) ? rules.value.message : rules.value\n\n            raise \"Plugin `#{plugin_name}' failed to load with error: #{error_message}\"\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "156"
  },
  {
    "raw_code": "def merge_all_cop_settings(existing_all_cops, new_all_cops, already_configured_keys)\n          return [existing_all_cops, already_configured_keys] unless new_all_cops.is_a?(Hash)\n\n          combined_all_cops = existing_all_cops.dup\n          combined_configured_keys = already_configured_keys.dup\n\n          new_all_cops.each do |key, value|\n            if combined_all_cops[key].is_a?(Array) && value.is_a?(Array)\n              combined_all_cops[key] |= value\n              combined_configured_keys |= [key]\n            elsif !combined_configured_keys.include?(key)\n              combined_all_cops[key] = value\n              combined_configured_keys << key\n            end",
    "comment": "rubocop:enable Metrics/AbcSize This is how we ensure \"first-in wins\": plugins can override AllCops settings that are set by RuboCop's default configuration, but once a plugin sets an AllCop setting, they have exclusive first-in-wins rights to that setting.  The one exception to this are array fields, because we don't want to overwrite the AllCops defaults but rather munge the arrays (`existing | new`) to allow plugins to add to the array, for example Include and Exclude paths and patterns.",
    "label": "",
    "id": "157"
  },
  {
    "raw_code": "def to_lsp_diagnostic(config)\n        highlighted = @offense.highlighted_area\n\n        LanguageServer::Protocol::Interface::Diagnostic.new(\n          message: message,\n          source: 'RuboCop',\n          code: @offense.cop_name,\n          code_description: code_description(config),\n          severity: severity,\n          range: LanguageServer::Protocol::Interface::Range.new(\n            start: LanguageServer::Protocol::Interface::Position.new(\n              line: @offense.line - 1,\n              character: to_position_character(highlighted.begin_pos)\n            ),\n            end: LanguageServer::Protocol::Interface::Position.new(\n              line: @offense.line - 1,\n              character: to_position_character(highlighted.end_pos)\n            )\n          ),\n          data: {\n            correctable: correctable?,\n            code_actions: to_lsp_code_actions\n          }\n        )\n      end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/MethodLength",
    "label": "",
    "id": "158"
  },
  {
    "raw_code": "def autocorrect_action\n        LanguageServer::Protocol::Interface::CodeAction.new(\n          title: \"Autocorrect #{@offense.cop_name}\",\n          kind: LanguageServer::Protocol::Constant::CodeActionKind::QUICK_FIX,\n          edit: LanguageServer::Protocol::Interface::WorkspaceEdit.new(\n            document_changes: [\n              LanguageServer::Protocol::Interface::TextDocumentEdit.new(\n                text_document: LanguageServer::Protocol::Interface::OptionalVersionedTextDocumentIdentifier.new(\n                  uri: ensure_uri_scheme(@uri.to_s).to_s,\n                  version: nil\n                ),\n                edits: correctable? ? offense_replacements : []\n              )\n            ]\n          ),\n          is_preferred: true\n        )\n      end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "159"
  },
  {
    "raw_code": "def offense_replacements\n        @offense.corrector.as_replacements.map do |range, replacement|\n          LanguageServer::Protocol::Interface::TextEdit.new(\n            range: LanguageServer::Protocol::Interface::Range.new(\n              start: LanguageServer::Protocol::Interface::Position.new(\n                line: range.line - 1,\n                character: to_position_character(range.column)\n              ),\n              end: LanguageServer::Protocol::Interface::Position.new(\n                line: range.last_line - 1,\n                character: to_position_character(range.last_column)\n              )\n            ),\n            new_text: replacement\n          )\n        end",
    "comment": "rubocop:enable Metrics/MethodLength rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "160"
  },
  {
    "raw_code": "def disable_line_action\n        LanguageServer::Protocol::Interface::CodeAction.new(\n          title: \"Disable #{@offense.cop_name} for this line\",\n          kind: LanguageServer::Protocol::Constant::CodeActionKind::QUICK_FIX,\n          edit: LanguageServer::Protocol::Interface::WorkspaceEdit.new(\n            document_changes: [\n              LanguageServer::Protocol::Interface::TextDocumentEdit.new(\n                text_document: LanguageServer::Protocol::Interface::OptionalVersionedTextDocumentIdentifier.new(\n                  uri: ensure_uri_scheme(@uri.to_s).to_s,\n                  version: nil\n                ),\n                edits: line_disable_comment\n              )\n            ]\n          )\n        )\n      end",
    "comment": "rubocop:enable Metrics/MethodLength rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "161"
  },
  {
    "raw_code": "def line_disable_comment\n        new_text = if @offense.source_line.include?(' # rubocop:disable ')\n                     \",#{@offense.cop_name}\"\n                   else\n                     \" # rubocop:disable #{@offense.cop_name}\"\n                   end",
    "comment": "rubocop:enable Metrics/MethodLength",
    "label": "",
    "id": "162"
  },
  {
    "raw_code": "def range_by_lines(range)\n        begin_of_first_line = range.begin_pos - range.column\n\n        last_line = range.source_buffer.source_line(range.last_line)\n        last_line_offset = last_line.length - range.last_column\n        end_of_last_line = range.end_pos + last_line_offset\n\n        Parser::Source::Range.new(range.source_buffer, begin_of_first_line, end_of_last_line)\n      end",
    "comment": "Expand the given range to include all of any lines it covers. Does not include newline at end of the last line.",
    "label": "",
    "id": "163"
  },
  {
    "raw_code": "def self.with_temporary_global(temp_global = global.dup)\n        previous = @global\n        @global = temp_global\n        yield\n      ensure\n        @global = previous\n      end",
    "comment": "Changes momentarily the global registry Intended for testing purposes",
    "label": "",
    "id": "164"
  },
  {
    "raw_code": "def departments\n        clear_enrollment_queue\n        @departments.keys\n      end",
    "comment": "@return [Array<Symbol>] list of departments for current cops.",
    "label": "",
    "id": "165"
  },
  {
    "raw_code": "def with_department(department)\n        clear_enrollment_queue\n        with(@departments.fetch(department, []))\n      end",
    "comment": "@return [Registry] Cops for that specific department.",
    "label": "",
    "id": "166"
  },
  {
    "raw_code": "def without_department(department)\n        clear_enrollment_queue\n        without_department = @departments.dup\n        without_department.delete(department)\n\n        with(without_department.values.flatten)\n      end",
    "comment": "@return [Registry] Cops not for a specific department.",
    "label": "",
    "id": "167"
  },
  {
    "raw_code": "def department?(name)\n        departments.include?(name.to_sym)\n      end",
    "comment": "@return [Boolean] Checks if given name is department",
    "label": "",
    "id": "168"
  },
  {
    "raw_code": "def qualified_cop_name(name, path, warn: true)\n        badge = Badge.parse(name)\n        print_warning(name, path) if warn && department_missing?(badge, name)\n        return name if registered?(badge)\n\n        potential_badges = qualify_badge(badge)\n\n        case potential_badges.size\n        when 0 then name # No namespace found. Deal with it later in caller.\n        when 1 then resolve_badge(badge, potential_badges.first, path, warn: warn)\n        else raise AmbiguousCopName.new(badge, path, potential_badges)\n        end",
    "comment": "Convert a user provided cop name into a properly namespaced name  @example gives back a correctly qualified cop name  registry = RuboCop::Cop::Registry registry.qualified_cop_name('Layout/EndOfLine', '') # => 'Layout/EndOfLine'  @example fixes incorrect namespaces  registry = RuboCop::Cop::Registry registry.qualified_cop_name('Lint/EndOfLine', '') # => 'Layout/EndOfLine'  @example namespaces bare cop identifiers  registry = RuboCop::Cop::Registry registry.qualified_cop_name('EndOfLine', '') # => 'Layout/EndOfLine'  @example passes back unrecognized cop names  registry = RuboCop::Cop::Registry registry.qualified_cop_name('NotACop', '') # => 'NotACop'  @param name [String] Cop name extracted from config @param path [String, nil] Path of file that `name` was extracted from @param warn [Boolean] Print a warning if no department given for `name`  @raise [AmbiguousCopName] if a bare identifier with two possible namespaces is provided  @note Emits a warning if the provided name has an incorrect namespace  @return [String] Qualified cop name",
    "label": "",
    "id": "169"
  },
  {
    "raw_code": "def to_h\n        clear_enrollment_queue\n        @cops_by_cop_name\n      end",
    "comment": "@return [Hash{String => Array<Class>}]",
    "label": "",
    "id": "170"
  },
  {
    "raw_code": "def find_by_cop_name(cop_name)\n        to_h[cop_name].first\n      end",
    "comment": "@param [String] cop_name @return [Class, nil]",
    "label": "",
    "id": "171"
  },
  {
    "raw_code": "def find_cops_by_directive(directive)\n        cop = find_by_cop_name(directive)\n        cop ? [cop] : cops_for_department(directive)\n      end",
    "comment": "When a cop name is given returns a single-element array with the cop class. When a department name is given returns an array with all the cop classes for that department.",
    "label": "",
    "id": "172"
  },
  {
    "raw_code": "def self.registry\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `Cop.registry` is deprecated. Use `Registry.global` instead.\n        WARNING\n\n        Registry.global\n      end",
    "comment": "Deprecated registry access @deprecated Use Registry.global",
    "label": "",
    "id": "173"
  },
  {
    "raw_code": "def self.all\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `Cop.all` is deprecated. Use `Registry.all` instead.\n        WARNING\n\n        Registry.all\n      end",
    "comment": "@deprecated Use Registry.all",
    "label": "",
    "id": "174"
  },
  {
    "raw_code": "def self.qualified_cop_name(name, origin)\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `Cop.qualified_cop_name` is deprecated. Use `Registry.qualified_cop_name` instead.\n        WARNING\n\n        Registry.qualified_cop_name(name, origin)\n      end",
    "comment": "@deprecated Use Registry.qualified_cop_name",
    "label": "",
    "id": "175"
  },
  {
    "raw_code": "def support_autocorrect?\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `support_autocorrect?` is deprecated. Use `cop.class.support_autocorrect?`.\n        WARNING\n\n        self.class.support_autocorrect?\n      end",
    "comment": "@deprecated Use class method",
    "label": "",
    "id": "176"
  },
  {
    "raw_code": "def corrections\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `Cop#corrections` is deprecated.\n        WARNING\n\n        return [] unless @last_corrector\n\n        Legacy::CorrectionsProxy.new(@last_corrector)\n      end",
    "comment": "@deprecated",
    "label": "",
    "id": "177"
  },
  {
    "raw_code": "def on_new_investigation\n        investigate(processed_source) if respond_to?(:investigate)\n        super\n      end",
    "comment": "Called before all on_... have been called",
    "label": "",
    "id": "178"
  },
  {
    "raw_code": "def on_investigation_end\n        investigate_post_walk(processed_source) if respond_to?(:investigate_post_walk)\n        super\n      end",
    "comment": "Called after all on_... have been called",
    "label": "",
    "id": "179"
  },
  {
    "raw_code": "def begin_investigation(processed_source, offset: 0, original: processed_source)\n        super\n        @offenses = current_offenses\n        @last_corrector = @current_corrector\n\n        # We need to keep track of the original source and offset,\n        # because `processed_source` here may be an embedded code in it.\n        @current_offset = offset\n        @current_original = original\n      end",
    "comment": "Called before any investigation @api private",
    "label": "",
    "id": "180"
  },
  {
    "raw_code": "def callback_argument(_range)\n        @v0_argument\n      end",
    "comment": "Override Base",
    "label": "",
    "id": "181"
  },
  {
    "raw_code": "def emulate_v0_callsequence(corrector)\n        lambda = correction_lambda\n        yield corrector if block_given?\n        unless corrector.empty?\n          raise 'Your cop must inherit from Cop::Base and extend AutoCorrector'\n        end",
    "comment": "Just for legacy",
    "label": "",
    "id": "182"
  },
  {
    "raw_code": "def initialize(config, cop_name, cop_config, options)\n        @config = config\n        @cop_name = cop_name\n        @cop_config = cop_config || {}\n        @options = options\n      end",
    "comment": "@param config [RuboCop::Config] Check configs for all cops @note Message Annotator specifically checks the following config options for_all_cops :StyleGuideBaseURL [String] URL for styleguide :DisplayStyleGuide [Boolean] Include styleguide and reference URLs :ExtraDetails [Boolean] Include cop details :DisplayCopNames [Boolean] Include cop name  @param [String] cop_name for specific cop name @param [Hash] cop_config configs for specific cop, from config#for_cop @option cop_config [String] :StyleGuide Extension of base styleguide URL @option cop_config [String] :References Full reference URLs @option cop_config [String] :Details  @param [Hash, nil] options optional @option options [Boolean] :display_style_guide Include style guide and reference URLs @option options [Boolean] :extra_details Include cop specific details @option options [Boolean] :debug Include debug output @option options [Boolean] :display_cop_names Include cop name",
    "label": "",
    "id": "183"
  },
  {
    "raw_code": "def annotate(message)\n        message = \"#{cop_name}: #{message}\" if display_cop_names?\n        message += \" #{details}\" if extra_details? && details\n        if display_style_guide?\n          links = urls.join(', ')\n          message = \"#{message} (#{links})\"\n        end",
    "comment": "Returns the annotated message, based on params passed into initializer  @return [String] annotated message",
    "label": "",
    "id": "184"
  },
  {
    "raw_code": "def style_guide_base_url\n        department_name = cop_name.split('/')[0..-2].join('/')\n\n        config.for_department(department_name)['StyleGuideBaseURL'] ||\n          config.for_all_cops['StyleGuideBaseURL']\n      end",
    "comment": "Returns the base style guide URL from AllCops or the specific department  @return [String] style guide URL",
    "label": "",
    "id": "185"
  },
  {
    "raw_code": "def on_send(node)\n                  return unless bad_method?(node)\n\n                  add_offense(node)\n                end",
    "comment": "Called on every `send` node (method call) while walking the AST. TODO: remove this method if inspecting `send` nodes is unneeded for your cop. By default, this is aliased to `on_csend` as well to handle method calls with safe navigation, remove the alias if this is unnecessary. If kept, ensure your tests cover safe navigation as well!",
    "label": "",
    "id": "186"
  },
  {
    "raw_code": "def initialize(severity, location, message, cop_name, # rubocop:disable Metrics/ParameterLists\n                     status = :uncorrected, corrector = nil)\n        @severity = RuboCop::Cop::Severity.new(severity)\n        @location = location\n        @message = message.freeze\n        @cop_name = cop_name.freeze\n        @status = status\n        @corrector = corrector\n        freeze\n      end",
    "comment": "@api private",
    "label": "",
    "id": "187"
  },
  {
    "raw_code": "def correctable?\n        @status != :unsupported\n      end",
    "comment": "@api public  @!attribute [r] correctable?  @return [Boolean] whether this offense can be automatically corrected via autocorrect. This includes todo comments, for example when requested with `--disable-uncorrectable`.",
    "label": "",
    "id": "188"
  },
  {
    "raw_code": "def corrected?\n        @status == :corrected || @status == :corrected_with_todo\n      end",
    "comment": "@api public  @!attribute [r] corrected?  @return [Boolean] whether this offense is automatically corrected via autocorrect or a todo.",
    "label": "",
    "id": "189"
  },
  {
    "raw_code": "def corrected_with_todo?\n        @status == :corrected_with_todo\n      end",
    "comment": "@api public  @!attribute [r] corrected_with_todo?  @return [Boolean] whether this offense is automatically disabled via a todo.",
    "label": "",
    "id": "190"
  },
  {
    "raw_code": "def disabled?\n        @status == :disabled || @status == :todo\n      end",
    "comment": "@api public  @!attribute [r] disabled?  @return [Boolean] whether this offense was locally disabled with a disable or todo where it occurred.",
    "label": "",
    "id": "191"
  },
  {
    "raw_code": "def highlighted_area\n        Parser::Source::Range.new(source_line, column, column + column_length)\n      end",
    "comment": "@api public  @return [Parser::Source::Range] the range of the code that is highlighted",
    "label": "",
    "id": "192"
  },
  {
    "raw_code": "def to_s\n        format('%<severity>s:%3<line>d:%3<column>d: %<message>s',\n               severity: severity.code, line: line,\n               column: real_column, message: message)\n      end",
    "comment": "@api private This is just for debugging purpose.",
    "label": "",
    "id": "193"
  },
  {
    "raw_code": "def line\n        location.line\n      end",
    "comment": "@api private",
    "label": "",
    "id": "194"
  },
  {
    "raw_code": "def column\n        location.column\n      end",
    "comment": "@api private",
    "label": "",
    "id": "195"
  },
  {
    "raw_code": "def source_line\n        location.source_line\n      end",
    "comment": "@api private",
    "label": "",
    "id": "196"
  },
  {
    "raw_code": "def column_length\n        if first_line == last_line\n          column_range.count\n        else\n          source_line.length - column\n        end",
    "comment": "@api private",
    "label": "",
    "id": "197"
  },
  {
    "raw_code": "def first_line\n        location.first_line\n      end",
    "comment": "@api private",
    "label": "",
    "id": "198"
  },
  {
    "raw_code": "def last_line\n        location.last_line\n      end",
    "comment": "@api private",
    "label": "",
    "id": "199"
  },
  {
    "raw_code": "def last_column\n        location.last_column\n      end",
    "comment": "@api private",
    "label": "",
    "id": "200"
  },
  {
    "raw_code": "def column_range\n        location.column_range\n      end",
    "comment": "@api private",
    "label": "",
    "id": "201"
  },
  {
    "raw_code": "def real_column\n        column + 1\n      end",
    "comment": "@api private  Internally we use column number that start at 0, but when outputting column numbers, we want them to start at 1. One reason is that editors, such as Emacs, expect this.",
    "label": "",
    "id": "202"
  },
  {
    "raw_code": "def ==(other)\n        COMPARISON_ATTRIBUTES.all? do |attribute|\n          public_send(attribute) == other.public_send(attribute)\n        end",
    "comment": "@api public  @return [Boolean] returns `true` if two offenses contain same attributes",
    "label": "",
    "id": "203"
  },
  {
    "raw_code": "def <=>(other)\n        COMPARISON_ATTRIBUTES.each do |attribute|\n          result = public_send(attribute) <=> other.public_send(attribute)\n          return result unless result.zero?\n        end",
    "comment": "@api public  Returns `-1`, `0`, or `+1` if this offense is less than, equal to, or greater than `other`.  @return [Integer] comparison result",
    "label": "",
    "id": "204"
  },
  {
    "raw_code": "def self.autocorrect_incompatible_with\n        []\n      end",
    "comment": "List of cops that should not try to autocorrect at the same time as this cop  @return [Array<RuboCop::Cop::Base>]  @api public",
    "label": "",
    "id": "205"
  },
  {
    "raw_code": "def self.documentation_url(config = nil)\n        Documentation.url_for(self, config)\n      end",
    "comment": "Returns a url to view this cops documentation online. Requires 'DocumentationBaseURL' to be set for your department. Will follow the convention of RuboCops own documentation structure, overwrite this method to accommodate your custom layout. @return [String, nil]  @api public",
    "label": "",
    "id": "206"
  },
  {
    "raw_code": "def self.exclude_from_registry\n        Registry.global.dismiss(self)\n      end",
    "comment": "Call for abstract Cop classes",
    "label": "",
    "id": "207"
  },
  {
    "raw_code": "def self.support_autocorrect?\n        false\n      end",
    "comment": "Returns if class supports autocorrect. It is recommended to extend AutoCorrector instead of overriding",
    "label": "",
    "id": "208"
  },
  {
    "raw_code": "def self.badge\n        @badge ||= Badge.for(name)\n      end",
    "comment": "Naming",
    "label": "",
    "id": "209"
  },
  {
    "raw_code": "def self.match?(given_names)\n        return false unless given_names\n\n        given_names.include?(cop_name) || given_names.include?(badge.department_name)\n      end",
    "comment": "Returns true if the cop name or the cop namespace matches any of the given names.",
    "label": "",
    "id": "210"
  },
  {
    "raw_code": "def self.joining_forces; end\n\n      ### Persistence\n\n      # Override if your cop should be called repeatedly for multiple investigations\n      # Between calls to `on_new_investigation` and `on_investigation_end`,\n      # the result of `processed_source` will remain constant.\n      # You should invalidate any caches that depend on the current `processed_source`\n      # in the `on_new_investigation` callback.\n      # If your cop does autocorrections, be aware that your instance may be called\n      # multiple times with the same `processed_source.path` but different content.\n      def self.support_multiple_source?\n        false\n      end\n\n      ## Gem requirements\n\n      @gem_requirements = {}\n\n      class << self\n        attr_reader :gem_requirements\n\n        # Register a version requirement for the given gem name.\n        # This cop will be skipped unless the target satisfies *all* requirements.\n        # @param [String] gem_name\n        # @param [Array<String>] version_requirements The version requirements,\n        #   using the same syntax as a Gemfile, e.g. \">= 1.2.3\"\n        #\n        #   If omitted, any version of the gem will be accepted.\n        #\n        #   https://guides.rubygems.org/patterns/#declaring-dependencies\n        #\n        # @api public\n        def requires_gem(gem_name, *version_requirements)\n          @gem_requirements[gem_name] = Gem::Requirement.new(version_requirements)\n        end\n      end",
    "comment": "Override and return the Force class(es) you need to join",
    "label": "",
    "id": "211"
  },
  {
    "raw_code": "def on_new_investigation\n        # Typically do nothing here\n      end",
    "comment": "Called before all on_... have been called When refining this method, always call `super`",
    "label": "",
    "id": "212"
  },
  {
    "raw_code": "def on_investigation_end\n        # Typically do nothing here\n      end",
    "comment": "Called after all on_... have been called When refining this method, always call `super`",
    "label": "",
    "id": "213"
  },
  {
    "raw_code": "def on_other_file\n        # Typically do nothing here\n      end",
    "comment": "Called instead of all on_... callbacks for unrecognized files / syntax errors When refining this method, always call `super`",
    "label": "",
    "id": "214"
  },
  {
    "raw_code": "def message(_range = nil)\n        self.class::MSG\n      end",
    "comment": "Gets called if no message is specified when calling `add_offense` or `add_global_offense` Cops are discouraged to override this; instead pass your message directly",
    "label": "",
    "id": "215"
  },
  {
    "raw_code": "def add_global_offense(message = nil, severity: nil)\n        severity = find_severity(nil, severity)\n        message = find_message(nil, message)\n        range = Offense::NO_LOCATION\n        status = enabled_line?(range.line) ? :unsupported : :disabled\n        current_offenses << Offense.new(severity, range, message, name, status)\n      end",
    "comment": "Adds an offense that has no particular location. No correction can be applied to global offenses",
    "label": "",
    "id": "216"
  },
  {
    "raw_code": "def add_offense(node_or_range, message: nil, severity: nil, &block)\n        range = range_from_node_or_range(node_or_range)\n        return unless current_offense_locations.add?(range)\n\n        range_to_pass = callback_argument(range)\n\n        severity = find_severity(range_to_pass, severity)\n        message = find_message(range_to_pass, message)\n\n        status, corrector = enabled_line?(range.line) ? correct(range, &block) : :disabled\n\n        # Since this range may be generated from Ruby code embedded in some\n        # template file, we convert it to location info in the original file.\n        range = range_for_original(range)\n\n        current_offenses << Offense.new(severity, range, message, name, status, corrector)\n      end",
    "comment": "Adds an offense on the specified range (or node with an expression) Unless that offense is disabled for this range, a corrector will be yielded to provide the cop the opportunity to autocorrect the offense. If message is not specified, the method `message` will be called.",
    "label": "",
    "id": "217"
  },
  {
    "raw_code": "def external_dependency_checksum\n        nil\n      end",
    "comment": "This method should be overridden when a cop's behavior depends on state that lives outside of these locations:  (1) the file under inspection (2) the cop's source code (3) the config (eg a .rubocop.yml file)  For example, some cops may want to look at other parts of the codebase being inspected to find violations. A cop may use the presence or absence of file `foo.rb` to determine whether a certain violation exists in `bar.rb`.  Overriding this method allows the cop to indicate to RuboCop's ResultCache system when those external dependencies change, ie when the ResultCache should be invalidated.",
    "label": "",
    "id": "218"
  },
  {
    "raw_code": "def cop_config\n        # Use department configuration as basis, but let individual cop\n        # configuration override.\n        @cop_config ||= @config.for_badge(self.class.badge)\n      end",
    "comment": "Configuration Helpers",
    "label": "",
    "id": "219"
  },
  {
    "raw_code": "def target_gem_version(gem_name)\n        @config.gem_versions_in_target && @config.gem_versions_in_target[gem_name]\n      end",
    "comment": "Returns a gems locked versions (i.e. from Gemfile.lock or gems.locked) @returns [Gem::Version | nil] The locked gem version, or nil if the gem is not present.",
    "label": "",
    "id": "220"
  },
  {
    "raw_code": "def parse(source, path = nil)\n        ProcessedSource.new(source, target_ruby_version, path, parser_engine: parser_engine)\n      end",
    "comment": "There should be very limited reasons for a Cop to do it's own parsing",
    "label": "",
    "id": "221"
  },
  {
    "raw_code": "def ready\n        return self if self.class.support_multiple_source?\n\n        self.class.new(@config, @options)\n      end",
    "comment": "@api private Called between investigations",
    "label": "",
    "id": "222"
  },
  {
    "raw_code": "def offenses\n        raise 'The offenses are not directly available; ' \\\n              'they are returned as the result of the investigation'\n      end",
    "comment": "Reserved for Cop::Cop @deprecated Make potential errors with previous API more obvious",
    "label": "",
    "id": "223"
  },
  {
    "raw_code": "def callbacks_needed\n        self.class.callbacks_needed\n      end",
    "comment": "Reserved for Commissioner rubocop:disable Layout/ClassStructure @api private",
    "label": "",
    "id": "224"
  },
  {
    "raw_code": "def self.callbacks_needed\n        @callbacks_needed ||= public_instance_methods.select do |m|\n          # OPTIMIZE: Check method existence first to make fewer `start_with?` calls.\n          # At the time of writing this comment, this excludes 98 of ~104 methods.\n          # `start_with?` with two string arguments instead of a regex is faster\n          # in this specific case as well.\n          !Base.method_defined?(m) && # exclude standard \"callbacks\" like 'on_begin_investigation'\n            m.start_with?('on_', 'after_')\n        end",
    "comment": "@api private",
    "label": "",
    "id": "225"
  },
  {
    "raw_code": "def begin_investigation(processed_source, offset: 0, original: processed_source)\n        @current_offenses = nil\n        @current_offense_locations = nil\n        @currently_disabled_lines = nil\n        @processed_source = processed_source\n        @current_corrector = nil\n\n        # We need to keep track of the original source and offset,\n        # because `processed_source` here may be an embedded code in it.\n        @current_offset = offset\n        @current_original = original\n      end",
    "comment": "rubocop:enable Layout/ClassStructure Called before any investigation @api private",
    "label": "",
    "id": "226"
  },
  {
    "raw_code": "def always_autocorrect?\n        # `true` is the same as `'always'` for backward compatibility.\n        ['always', true].include?(cop_config.fetch('AutoCorrect', 'always'))\n      end",
    "comment": "@api private",
    "label": "",
    "id": "227"
  },
  {
    "raw_code": "def contextual_autocorrect?\n        cop_config.fetch('AutoCorrect', 'always') == 'contextual'\n      end",
    "comment": "@api private",
    "label": "",
    "id": "228"
  },
  {
    "raw_code": "def callback_argument(range)\n        range\n      end",
    "comment": "Reserved for Cop::Cop",
    "label": "",
    "id": "229"
  },
  {
    "raw_code": "def current_offense_locations\n        @current_offense_locations ||= Set.new\n      end",
    "comment": "Reserved for Commissioner:",
    "label": "",
    "id": "230"
  },
  {
    "raw_code": "def complete_investigation\n        InvestigationReport.new(\n          self, processed_source, @current_offenses || EMPTY_OFFENSES, @current_corrector\n        )\n      ensure\n        reset_investigation\n      end",
    "comment": "Called to complete an investigation",
    "label": "",
    "id": "231"
  },
  {
    "raw_code": "def reset_investigation\n        @currently_disabled_lines = @current_offenses = @processed_source = @current_corrector = nil\n      end",
    "comment": "Actually private methods",
    "label": "",
    "id": "232"
  },
  {
    "raw_code": "def correct(range)\n        if block_given?\n          corrector = Corrector.new(self)\n          yield corrector\n          if corrector.empty?\n            corrector = nil\n          elsif !self.class.support_autocorrect?\n            raise \"The Cop #{name} must `extend AutoCorrector` to be able to autocorrect\"\n          end",
    "comment": "@return [Symbol, Corrector] offense status",
    "label": "",
    "id": "233"
  },
  {
    "raw_code": "def use_corrector(range, corrector)\n        if autocorrect?\n          attempt_correction(range, corrector)\n        elsif corrector && (always_autocorrect? || (contextual_autocorrect? && !LSP.enabled?))\n          :uncorrected\n        else\n          :unsupported\n        end",
    "comment": "@return [Symbol] offense status",
    "label": "",
    "id": "234"
  },
  {
    "raw_code": "def attempt_correction(range, corrector)\n        if corrector\n          status = :corrected\n        elsif disable_uncorrectable?\n          corrector = disable_uncorrectable(range)\n          status = :corrected_with_todo\n        else\n          return :unsupported\n        end",
    "comment": "@return [Symbol] offense status",
    "label": "",
    "id": "235"
  },
  {
    "raw_code": "def self.source_buffer(source)\n        source = source.processed_source if source.respond_to?(:processed_source)\n        source = source.buffer if source.respond_to?(:buffer)\n        source = source.source_buffer if source.respond_to?(:source_buffer)\n\n        unless source.is_a? ::Parser::Source::Buffer\n          raise TypeError, 'Expected argument to lead to a Parser::Source::Buffer ' \\\n                           \"but got #{source.inspect}\"\n        end",
    "comment": "Duck typing for get to a ::Parser::Source::Buffer",
    "label": "",
    "id": "236"
  },
  {
    "raw_code": "def initialize(source)\n        source = self.class.source_buffer(source)\n        super(\n          source,\n          different_replacements: :raise,\n          swallowed_insertions: :raise,\n          crossing_deletions: :accept\n        )\n\n        # Don't print warnings to stderr if corrections conflict with each other\n        diagnostics.consumer = NOOP_CONSUMER\n      end",
    "comment": "@param source [Parser::Source::Buffer, or anything leading to one via `(processed_source.)buffer`]  corrector = Corrector.new(cop)",
    "label": "",
    "id": "237"
  },
  {
    "raw_code": "def remove_preceding(node_or_range, size)\n        range = to_range(node_or_range)\n        to_remove = range.with(begin_pos: range.begin_pos - size, end_pos: range.begin_pos)\n        remove(to_remove)\n      end",
    "comment": "Removes `size` characters prior to the source range.  @param [Parser::Source::Range, RuboCop::AST::Node] range or node @param [Integer] size",
    "label": "",
    "id": "238"
  },
  {
    "raw_code": "def remove_leading(node_or_range, size)\n        range = to_range(node_or_range)\n        to_remove = range.with(end_pos: range.begin_pos + size)\n        remove(to_remove)\n      end",
    "comment": "Removes `size` characters from the beginning of the given range. If `size` is greater than the size of `range`, the removed region can overrun the end of `range`.  @param [Parser::Source::Range, RuboCop::AST::Node] range or node @param [Integer] size",
    "label": "",
    "id": "239"
  },
  {
    "raw_code": "def remove_trailing(node_or_range, size)\n        range = to_range(node_or_range)\n        to_remove = range.with(begin_pos: range.end_pos - size)\n        remove(to_remove)\n      end",
    "comment": "Removes `size` characters from the end of the given range. If `size` is greater than the size of `range`, the removed region can overrun the beginning of `range`.  @param [Parser::Source::Range, RuboCop::AST::Node] range or node @param [Integer] size",
    "label": "",
    "id": "240"
  },
  {
    "raw_code": "def swap(node_or_range1, node_or_range2)\n        range1 = to_range(node_or_range1)\n        range2 = to_range(node_or_range2)\n\n        if range1.end_pos == range2.begin_pos\n          insert_before(range1, range2.source)\n          remove(range2)\n        elsif range2.end_pos == range1.begin_pos\n          insert_before(range2, range1.source)\n          remove(range1)\n        else\n          replace(range1, range2.source)\n          replace(range2, range1.source)\n        end",
    "comment": "Swaps sources at the given ranges.  @param [Parser::Source::Range, RuboCop::AST::Node] node_or_range1 @param [Parser::Source::Range, RuboCop::AST::Node] node_or_range2",
    "label": "",
    "id": "241"
  },
  {
    "raw_code": "def to_range(node_or_range)\n        range = case node_or_range\n                when ::RuboCop::AST::Node, ::Parser::Source::Comment\n                  node_or_range.source_range\n                when ::Parser::Source::Range\n                  node_or_range\n                else\n                  raise TypeError,\n                        'Expected a Parser::Source::Range, Comment or ' \\\n                        \"RuboCop::AST::Node, got #{node_or_range.class}\"\n                end",
    "comment": ":nodoc:",
    "label": "",
    "id": "242"
  },
  {
    "raw_code": "def investigate(processed_source)\n        root_node = processed_source.ast\n        return unless root_node\n\n        variable_table.push_scope(root_node)\n        process_node(root_node)\n        variable_table.pop_scope\n      end",
    "comment": "Starting point.",
    "label": "",
    "id": "243"
  },
  {
    "raw_code": "def inspect_variables_in_scope(scope_node)\n        variable_table.push_scope(scope_node)\n        process_children(scope_node)\n        variable_table.pop_scope\n      end",
    "comment": "This is called for each scope recursively.",
    "label": "",
    "id": "244"
  },
  {
    "raw_code": "def mark_assignments_as_referenced_in_loop(node)\n        referenced_variable_names_in_loop, assignment_nodes_in_loop = find_variables_in_loop(node)\n\n        referenced_variable_names_in_loop.each do |name|\n          variable = variable_table.find_variable(name)\n          # Non related references which are caught in the above scan\n          # would be skipped here.\n          next unless variable\n\n          loop_assignments = variable.assignments.select do |assignment|\n            assignment_nodes_in_loop.include?(assignment.node)\n          end",
    "comment": "Mark last assignments which are referenced in the same loop as referenced by ignoring AST order since they would be referenced in next iteration.",
    "label": "",
    "id": "245"
  },
  {
    "raw_code": "def department_to_basename(department)\n        \"cops_#{department.to_s.downcase.tr('/', '_')}\"\n      end",
    "comment": "@api private",
    "label": "",
    "id": "246"
  },
  {
    "raw_code": "def url_for(cop_class, config = nil)\n        base = department_to_basename(cop_class.department)\n        fragment = cop_class.cop_name.downcase.gsub(/[^a-z]/, '')\n        base_url = base_url_for(cop_class, config)\n        extension = extension_for(cop_class, config)\n\n        \"#{base_url}/#{base}#{extension}##{fragment}\" if base_url\n      end",
    "comment": "@api private",
    "label": "",
    "id": "247"
  },
  {
    "raw_code": "def base_url_for(cop_class, config)\n        if config\n          department_name = cop_class.department.to_s\n          url = config.for_department(department_name)['DocumentationBaseURL']\n          return url if url\n        end",
    "comment": "@api private",
    "label": "",
    "id": "248"
  },
  {
    "raw_code": "def extension_for(cop_class, config)\n        if config\n          department_name = cop_class.department\n          extension = config.for_department(department_name)['DocumentationExtension']\n          return extension if extension\n        end",
    "comment": "@api private",
    "label": "",
    "id": "249"
  },
  {
    "raw_code": "def default_base_url\n        'https://docs.rubocop.org/rubocop'\n      end",
    "comment": "@api private",
    "label": "",
    "id": "250"
  },
  {
    "raw_code": "def default_extension\n        '.html'\n      end",
    "comment": "@api private",
    "label": "",
    "id": "251"
  },
  {
    "raw_code": "def builtin?(cop_class)\n        # any custom method will do\n        return false unless (m = cop_class.instance_methods(false).first)\n\n        path, _line = cop_class.instance_method(m).source_location\n        path.start_with?(__dir__)\n      end",
    "comment": "@api private",
    "label": "",
    "id": "252"
  },
  {
    "raw_code": "def self.new(cop_or_classes, config, options = {})\n        # Support v0 api:\n        if cop_or_classes.first.is_a?(Class)\n          warn Rainbow(<<~WARNING).yellow, uplevel: 1\n            `Team.new` with cop classes is deprecated. Use `Team.mobilize` instead.\n          WARNING\n          return mobilize(cop_or_classes, config, options)\n        end",
    "comment": "@return [Team]",
    "label": "",
    "id": "253"
  },
  {
    "raw_code": "def self.mobilize(cop_classes, config, options = {})\n        cops = mobilize_cops(cop_classes, config, options)\n        new(cops, config, options)\n      end",
    "comment": "@return [Team] with cops assembled from the given `cop_classes`",
    "label": "",
    "id": "254"
  },
  {
    "raw_code": "def self.mobilize_cops(cop_classes, config, options = {})\n        cop_classes = Registry.new(cop_classes.to_a, options) unless cop_classes.is_a?(Registry)\n\n        cop_classes.map do |cop_class|\n          cop_class.new(config, options)\n        end",
    "comment": "@return [Array<Cop::Base>]",
    "label": "",
    "id": "255"
  },
  {
    "raw_code": "def self.forces_for(cops)\n        needed = Hash.new { |h, k| h[k] = [] }\n        cops.each do |cop|\n          forces = cop.class.joining_forces\n          if forces.is_a?(Array)\n            forces.each { |force| needed[force] << cop }\n          elsif forces\n            needed[forces] << cop\n          end",
    "comment": "@return [Array<Force>] needed for the given cops",
    "label": "",
    "id": "256"
  },
  {
    "raw_code": "def inspect_file(processed_source)\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `inspect_file` is deprecated. Use `investigate` instead.\n        WARNING\n\n        investigate(processed_source).offenses\n      end",
    "comment": "@deprecated. Use investigate @return Array<offenses>",
    "label": "",
    "id": "257"
  },
  {
    "raw_code": "def investigate(processed_source, offset: 0, original: processed_source)\n        be_ready\n\n        # The autocorrection process may have to be repeated multiple times\n        # until there are no corrections left to perform\n        # To speed things up, run autocorrecting cops by themselves, and only\n        # run the other cops when no corrections are left\n        on_duty = roundup_relevant_cops(processed_source)\n\n        autocorrect_cops, other_cops = on_duty.partition(&:autocorrect?)\n        report = investigate_partial(autocorrect_cops, processed_source,\n                                     offset: offset, original: original)\n\n        unless autocorrect(processed_source, report, offset: offset, original: original)\n          # If we corrected some errors, another round of inspection will be\n          # done, and any other offenses will be caught then, so only need\n          # to check other_cops if no correction was done\n          report = report.merge(investigate_partial(other_cops, processed_source,\n                                                    offset: offset, original: original))\n        end",
    "comment": "@return [Commissioner::InvestigationReport]",
    "label": "",
    "id": "258"
  },
  {
    "raw_code": "def forces\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `forces` is deprecated.\n        WARNING\n\n        @forces ||= self.class.forces_for(cops)\n      end",
    "comment": "@deprecated",
    "label": "",
    "id": "259"
  },
  {
    "raw_code": "def investigate_partial(cops, processed_source, offset:, original:)\n        commissioner = Commissioner.new(cops, self.class.forces_for(cops), @options)\n        commissioner.investigate(processed_source, offset: offset, original: original)\n      end",
    "comment": "@return [Commissioner::InvestigationReport]",
    "label": "",
    "id": "260"
  },
  {
    "raw_code": "def roundup_relevant_cops(processed_source)\n        cops.select do |cop|\n          next true if processed_source.comment_config.cop_opted_in?(cop)\n          next false if cop.excluded_file?(processed_source.file_path)\n          next false unless @registry.enabled?(cop, @config)\n\n          support_target_ruby_version?(cop) && support_target_rails_version?(cop)\n        end",
    "comment": "@return [Array<cop>]",
    "label": "",
    "id": "261"
  },
  {
    "raw_code": "def investigate(processed_source, offset: 0, original: processed_source)\n        reset\n\n        begin_investigation(processed_source, offset: offset, original: original)\n        if processed_source.valid_syntax?\n          invoke(:on_new_investigation, @cops)\n          invoke_with_argument(:investigate, @forces, processed_source)\n\n          walk(processed_source.ast) unless @cops.empty?\n          invoke(:on_investigation_end, @cops)\n        else\n          invoke(:on_other_file, @cops)\n        end",
    "comment": "@return [InvestigationReport]",
    "label": "",
    "id": "262"
  },
  {
    "raw_code": "def restricted_map(callbacks)\n        map = {}\n        callbacks&.select! do |cop|\n          restrictions = cop.class.send :restrict_on_send\n          restrictions.each { |name| (map[name] ||= []) << cop }\n          restrictions.empty?\n        end",
    "comment": "NOTE: mutates `callbacks` in place",
    "label": "",
    "id": "263"
  },
  {
    "raw_code": "def with_cop_error_handling(cop, node = nil)\n        yield\n      rescue StandardError => e\n        raise e if @options[:raise_error] # For internal testing\n\n        err = ErrorWithAnalyzedFileLocation.new(cause: e, node: node, cop: cop)\n        raise err if @options[:raise_cop_error] # From user-input option\n\n        @errors << err\n      end",
    "comment": "Allow blind rescues here, since we're absorbing and packaging or re-raising exceptions that can be raised from within the individual cops' `#investigate` methods.",
    "label": "",
    "id": "264"
  },
  {
    "raw_code": "def exclude_limit(parameter_name, method_name: transform(parameter_name))\n      define_method(:\"#{method_name}=\") do |value|\n        cfg = config_to_allow_offenses\n        cfg[:exclude_limit] ||= {}\n        current_max = cfg[:exclude_limit][parameter_name]\n        value = [current_max, value].max if current_max\n        cfg[:exclude_limit][parameter_name] = value\n      end",
    "comment": "Sets up a configuration option to have an exclude limit tracked. The parameter name given is transformed into a method name (eg. `Max` becomes `self.max=` and `MinDigits` becomes `self.min_digits=`).",
    "label": "",
    "id": "265"
  },
  {
    "raw_code": "def comment_line?(line_source)\n        /^\\s*#/.match?(line_source)\n      end",
    "comment": "This is a bad API",
    "label": "",
    "id": "266"
  },
  {
    "raw_code": "def comment_lines?(node)\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `comment_lines?` is deprecated. Use `ProcessedSource#line_with_comment?`, `contains_comment?` or similar instead.\n        WARNING\n\n        processed_source[line_range(node)].any? { |line| comment_line?(line) }\n      end",
    "comment": "@deprecated Use `ProcessedSource#line_with_comment?`, `contains_comment?` or similar",
    "label": "",
    "id": "267"
  },
  {
    "raw_code": "def add_parentheses(node, corrector)\n        if node.args_type?\n          arguments_range = node.source_range\n          args_with_space = range_with_surrounding_space(arguments_range, side: :left)\n          leading_space = range_between(args_with_space.begin_pos, arguments_range.begin_pos)\n          corrector.replace(leading_space, '(')\n          corrector.insert_after(arguments_range, ')')\n        elsif !node.respond_to?(:arguments)\n          corrector.wrap(node, '(', ')')\n        elsif node.arguments.empty?\n          corrector.insert_after(node, '()')\n        else\n          args_begin = args_begin(node)\n\n          corrector.remove(args_begin)\n          corrector.insert_before(args_begin, '(')\n          corrector.insert_after(args_end(node), ')')\n        end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/MethodLength",
    "label": "",
    "id": "268"
  },
  {
    "raw_code": "def any_descendant?(node, *types)\n        if block_given?\n          node.each_descendant(*types) do |descendant|\n            return true if yield(descendant)\n          end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/MethodLength",
    "label": "",
    "id": "269"
  },
  {
    "raw_code": "def first_part_of_call_chain(node)\n        while node\n          case node.type\n          when :send\n            node = node.receiver\n          when :block\n            node = node.send_node\n          else\n            break\n          end",
    "comment": "Returns, for example, a bare `if` node if the given node is an `if` with calls chained to the end of it.",
    "label": "",
    "id": "270"
  },
  {
    "raw_code": "def double_quotes_required?(string)\n        # Double quotes are required for strings which either:\n        # - Contain single quotes\n        # - Contain non-printable characters, which must use an escape\n\n        # Regex matches IF there is a ' or there is a \\\\ in the string that is\n        # not preceded/followed by another \\\\ (e.g. \"\\\\x34\") but not \"\\\\\\\\\".\n        /'|(?<! \\\\) \\\\{2}* \\\\ (?![\\\\\"])/x.match?(string)\n      end",
    "comment": "If converting a string to Ruby string literal source code, must double quotes be used?",
    "label": "",
    "id": "271"
  },
  {
    "raw_code": "def initialize(name_or_code)\n        name = Severity.name_from_code(name_or_code)\n        raise ArgumentError, \"Unknown severity: #{name}\" unless NAMES.include?(name)\n\n        @name = name.freeze\n        freeze\n      end",
    "comment": "@api private",
    "label": "",
    "id": "272"
  },
  {
    "raw_code": "def formatted_message(offense_type, directive, actual_name, method_name)\n          case offense_type\n          when :wrong_name\n            # Add the receiver to the name when showing an offense\n            current_name = if directive[:receiver]\n                             directive[:receiver] + directive[:method_name]\n                           else\n                             directive[:method_name]\n                           end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "273"
  },
  {
    "raw_code": "def remove_receiver(current)\n          current.delete_prefix('self.')\n        end",
    "comment": "rubocop:enable Metrics/MethodLength",
    "label": "",
    "id": "274"
  },
  {
    "raw_code": "def on_send(node)\n          pattern_node = node.arguments[1]\n          return unless acceptable_heredoc?(pattern_node) || pattern_node.str_type?\n\n          process_pattern(pattern_node)\n          return if node_groups.nil?\n\n          apply_range_offsets(pattern_node)\n\n          node_groups.each_with_index do |group, index|\n            register_offense(group, index)\n          end",
    "comment": "When a Node Pattern matcher is defined, investigate the pattern string to search for node types that can be replaced with a node group (ie. `{send csend}` can be replaced with `call`).  In order to deal with node patterns in an efficient and non-brittle way, we will parse the Node Pattern string given to this `send` node using `RuboCop::AST::NodePattern::Parser::WithMeta`. `WithMeta` is important! We need location information so that we can calculate the exact locations within the pattern to report and correct.  The resulting AST is processed by `NodePatternGroups::ASTProccessor` which rewrites the AST slightly to handle node sequences (ie. `(send _ :foo ...)`). See the documentation of that class for more details.  Then the processed AST is walked, and metadata is collected for node types that can be replaced with a node group.  Finally, the metadata is used to register offenses and make corrections, using the location data captured earlier. The ranges captured while parsing the Node Pattern are offset using the string argument to this `send` node to ensure that offenses are registered at the correct location. ",
    "label": "",
    "id": "275"
  },
  {
    "raw_code": "def register_offense(group, index)\n          replacement = replacement(group)\n          message = format(\n            MSG,\n            names: group.node_types.map { |node| node.source_range.source }.join('`, `'),\n            replacement: replacement\n          )\n\n          add_offense(group.offense_range, message: message) do |corrector|\n            # Only correct one group at a time to avoid clobbering.\n            # Other offenses will be corrected in the subsequent iterations of the\n            # correction loop.\n            next if index.positive?\n\n            if group.other_elements?\n              replace_types_with_node_group(corrector, group, replacement)\n            else\n              replace_union(corrector, group, replacement)\n            end",
    "comment": "rubocop:disable InternalAffairs/RedundantSourceRange -- `node` here is a NodePatternNode",
    "label": "",
    "id": "276"
  },
  {
    "raw_code": "def replace_types_with_node_group(corrector, group, replacement)\n          ranges = group.ranges.map.with_index do |range, index|\n            # Collect whitespace and pipes preceding each element\n            range_for_full_union_element(range, index, group.pipe)\n          end",
    "comment": "rubocop:enable InternalAffairs/RedundantSourceRange When there are other elements in the union, remove the node types that can be replaced.",
    "label": "",
    "id": "277"
  },
  {
    "raw_code": "def range_for_full_union_element(range, index, pipe)\n          if index.positive?\n            range = if pipe\n                      range_with_preceding_pipe(range)\n                    else\n                      range_with_surrounding_space(range: range, side: :left, newlines: true)\n                    end",
    "comment": "If the union contains pipes, remove the pipe character as well. Unfortunately we don't get the location of the pipe in `loc` object, so we have to find it.",
    "label": "",
    "id": "278"
  },
  {
    "raw_code": "def range_with_preceding_pipe(range)\n          pos = range.begin_pos - 1\n\n          while pos\n            unless processed_source.buffer.source[pos].match?(/[\\s|]/)\n              return range.with(begin_pos: pos + 1)\n            end",
    "comment": "Collect a preceding pipe and any whitespace left of the pipe",
    "label": "",
    "id": "279"
  },
  {
    "raw_code": "def replace_union(corrector, group, replacement)\n          corrector.replace(group.ranges.first, replacement)\n        end",
    "comment": "When there are no other elements, the entire union can be replaced",
    "label": "",
    "id": "280"
  },
  {
    "raw_code": "def apply_range_offsets(pattern_node)\n          range, offset = range_with_offset(pattern_node)\n\n          node_groups.each do |node_group|\n            node_group.ranges ||= []\n            node_group.offense_range = pattern_range(range, node_group.union, offset)\n\n            if node_group.other_elements?\n              node_group.node_types.each do |node_type|\n                node_group.ranges << pattern_range(range, node_type, offset)\n              end",
    "comment": "rubocop:disable Metrics/AbcSize Calculate the ranges for each node within the pattern string that will be replaced or removed. Takes the offset of the string node into account.",
    "label": "",
    "id": "281"
  },
  {
    "raw_code": "def pattern_range(range, node, offset)\n          begin_pos = node.source_range.begin_pos\n          end_pos = node.source_range.end_pos\n          size = end_pos - begin_pos\n\n          range.adjust(begin_pos: begin_pos + offset).resize(size)\n        end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "282"
  },
  {
    "raw_code": "def acceptable_heredoc?(node)\n          node.any_str_type? && node.heredoc? && node.each_child_node(:begin).none?\n        end",
    "comment": "A heredoc can be a `dstr` without interpolation, but if there is interpolation there'll be a `begin` node, in which case, we cannot evaluate the pattern.",
    "label": "",
    "id": "283"
  },
  {
    "raw_code": "def on_send(node)\n          heredoc_node = heredoc_node_from(node)\n          return unless heredoc_node\n          return if expected_heredoc_delimiter?(heredoc_node)\n          return if expected_heredoc_delimiter_in_body?(heredoc_node)\n\n          add_offense(heredoc_node) do |corrector|\n            autocorrect(corrector, heredoc_node)\n          end",
    "comment": "@param node [RuboCop::AST::SendNode] @return [void]",
    "label": "",
    "id": "284"
  },
  {
    "raw_code": "def autocorrect(corrector, node)\n          [\n            heredoc_opening_delimiter_range_from(node),\n            heredoc_closing_delimiter_range_from(node)\n          ].each do |range|\n            corrector.replace(range, EXPECTED_HEREDOC_DELIMITER)\n          end",
    "comment": "@param corrector [RuboCop::Cop::Corrector] @param node [RuboCop::AST::StrNode] @return [void]",
    "label": "",
    "id": "285"
  },
  {
    "raw_code": "def expected_heredoc_delimiter_in_body?(node)\n          node.location.heredoc_body.source.lines.any? do |line|\n            line.strip == EXPECTED_HEREDOC_DELIMITER\n          end",
    "comment": "@param node [RuboCop::AST::StrNode] @return [Boolean]",
    "label": "",
    "id": "286"
  },
  {
    "raw_code": "def expected_heredoc_delimiter?(node)\n          heredoc_delimiter_string_from(node) == EXPECTED_HEREDOC_DELIMITER\n        end",
    "comment": "@param node [RuboCop::AST::StrNode] @return [Boolean]",
    "label": "",
    "id": "287"
  },
  {
    "raw_code": "def heredoc_node_from(node)\n          return unless node.first_argument.respond_to?(:heredoc?)\n          return unless node.first_argument.heredoc?\n\n          node.first_argument\n        end",
    "comment": "@param node [RuboCop::AST::SendNode] @return [RuboCop::AST::StrNode, nil]",
    "label": "",
    "id": "288"
  },
  {
    "raw_code": "def heredoc_delimiter_string_from(node)\n          node.source[Heredoc::OPENING_DELIMITER, 2]\n        end",
    "comment": "@param node [RuboCop::AST::StrNode] @return [String]",
    "label": "",
    "id": "289"
  },
  {
    "raw_code": "def heredoc_opening_delimiter_range_from(node)\n          match_data = node.source.match(Heredoc::OPENING_DELIMITER)\n          node.source_range.begin.adjust(\n            begin_pos: match_data.begin(2),\n            end_pos: match_data.end(2)\n          )\n        end",
    "comment": "@param node [RuboCop::AST::StrNode] @return [Parser::Source::Range]",
    "label": "",
    "id": "290"
  },
  {
    "raw_code": "def heredoc_closing_delimiter_range_from(node)\n          node.location.heredoc_end.end.adjust(\n            begin_pos: -heredoc_delimiter_string_from(node).length\n          )\n        end",
    "comment": "@param node [RuboCop::AST::StrNode] @return [Parser::Source::Range]",
    "label": "",
    "id": "291"
  },
  {
    "raw_code": "def on_sequence(node)\n            first_child = node.child\n\n            if first_child.type == :node_type\n              children = [first_child.child, *process_children(node, 1..)]\n\n              # The `node_sequence` node contains the `node_type` symbol as its first child,\n              # followed by all the other nodes contained in the `sequence` node.\n              # The location is copied from the sequence, so that the entire sequence can\n              # eventually be corrected in the cop.\n              n(:node_sequence, children, location: node.location)\n            else\n              node.updated(nil, process_children(node))\n            end",
    "comment": "Look for `sequence` and `subsequence` nodes that contain a `node_type` node as their first child. These are rewritten as `node_sequence` nodes so that it is possible to compare nodes while looking for replacement candidates for node groups. This is necessary so that extended patterns can be matched and replaced. ie. `{(send _ :foo ...) (csend _ :foo ...)}` can become `(call _ :foo ...)`",
    "label": "",
    "id": "292"
  },
  {
    "raw_code": "def walk(node)\n            return if node.nil?\n\n            on_union(node) if node.type == :union\n\n            node.child_nodes.each do |child|\n              walk(child)\n            end",
    "comment": "Recursively walk the AST in a depth-first manner. Only `union` nodes are handled further.",
    "label": "",
    "id": "293"
  },
  {
    "raw_code": "def on_union(node)\n            all_node_types = each_child_node(node, :node_type, :node_sequence).to_a\n\n            each_node_group(all_node_types) do |group_name, node_types|\n              next unless sequences_match?(node_types)\n\n              node_groups << node_group_data(\n                group_name, node, node_types,\n                all_node_types.index(node_types.first),\n                (node.children - node_types).any?\n              )\n            end",
    "comment": "Search `union` nodes for `node_type` and `node_sequence` nodes that can be collapsed into a node group. * `node_type` nodes are nodes with no further configuration (ie. `send`) * `node_sequence` nodes are nodes with further configuration (ie. `(send ...)`)  Each group of types that can be collapsed will have a `NodeGroup` record added to `node_groups`, which is then used by the cop.",
    "label": "",
    "id": "294"
  },
  {
    "raw_code": "def wayward_predicate?(name)\n          wayward_predicates.include?(name.to_s)\n        end",
    "comment": "If a method ending in `?` is known to not return a boolean value, (for example, `Numeric#nonzero?`) it should be treated as a non-boolean value, despite the method naming.",
    "label": "",
    "id": "295"
  },
  {
    "raw_code": "def invalidates_syntax?(block_pass_node)\n          target_ruby_version <= 3.3 && block_pass_node.each_ancestor(:any_block).any?\n        end",
    "comment": "Ruby 3.3.0 had a bug where accessing an anonymous block argument inside of a block was a syntax error in unambiguous cases: https://bugs.ruby-lang.org/issues/20090 We disallow this also for earlier Ruby versions so that code is forwards compatible.",
    "label": "",
    "id": "296"
  },
  {
    "raw_code": "def on_gvasgn(node)\n          return unless (name = node.name)\n          return unless forbidden_name?(name)\n\n          register_forbidden_name(node)\n        end",
    "comment": "Only forbidden names are checked for global variable assignment",
    "label": "",
    "id": "297"
  },
  {
    "raw_code": "def register_forbidden_name(node)\n          if node.any_def_type?\n            name_node = node.loc.name\n            method_name = node.method_name\n          elsif node.literal?\n            name_node = node\n            method_name = node.value\n          elsif (attrs = node.attribute_accessor?)\n            name_node = attrs.last.last\n            method_name = attr_name(name_node)\n          else\n            name_node = node.first_argument\n            method_name = node.first_argument.value\n          end",
    "comment": "rubocop:disable Metrics/MethodLength, Metrics/AbcSize",
    "label": "",
    "id": "298"
  },
  {
    "raw_code": "def attr_name(name_item)\n          sym_name(name_item) || str_name(name_item)\n        end",
    "comment": "rubocop:enable Metrics/MethodLength, Metrics/AbcSize",
    "label": "",
    "id": "299"
  },
  {
    "raw_code": "def correct_node(corrector, node, offending_name, preferred_name)\n          return unless node\n\n          node.each_node(:lvar, :lvasgn, :masgn) do |child_node|\n            next unless variable_name_matches?(child_node, offending_name)\n\n            if child_node.lvar_type?\n              parent_node = child_node.parent\n              if parent_node.respond_to?(:value_omission?) && parent_node.value_omission?\n                corrector.insert_after(parent_node.loc.operator, \" #{preferred_name}\")\n              else\n                corrector.replace(child_node, preferred_name)\n              end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "300"
  },
  {
    "raw_code": "def correct_reassignment(corrector, node, offending_name, preferred_name)\n          correct_node(corrector, node.rhs, offending_name, preferred_name)\n        end",
    "comment": "rubocop:enable Metrics/MethodLength If the exception variable is reassigned, that assignment needs to be corrected. Further `lvar` nodes will not be corrected though since they now refer to a different variable.",
    "label": "",
    "id": "301"
  },
  {
    "raw_code": "def on_or_asgn(node)\n          lhs = node.lhs\n          return unless lhs.ivasgn_type?\n\n          method_node, method_name = find_definition(node)\n          return unless method_node\n\n          body = method_node.body\n          return unless body == node || body.children.last == node\n\n          return if matches?(method_name, lhs)\n\n          suggested_var = suggested_var(method_name)\n          msg = format(\n            message(lhs.name),\n            var: lhs.name,\n            suggested_var: suggested_var,\n            method: method_name\n          )\n          add_offense(lhs, message: msg) do |corrector|\n            corrector.replace(lhs.loc.name, \"@#{suggested_var}\")\n          end",
    "comment": "rubocop:disable Metrics/AbcSize rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "302"
  },
  {
    "raw_code": "def on_defined?(node)\n          arg = node.first_argument\n          return false unless arg.ivar_type?\n\n          method_node, method_name = find_definition(node)\n          return false unless method_node\n\n          defined_memoized?(method_node.body, arg.name) do |defined_ivar, return_ivar, ivar_assign|\n            return false if matches?(method_name, ivar_assign)\n\n            suggested_var = suggested_var(method_name)\n            msg = format(\n              message(arg.name),\n              var: arg.name,\n              suggested_var: suggested_var,\n              method: method_name\n            )\n            add_offense(defined_ivar, message: msg) do |corrector|\n              corrector.replace(defined_ivar, \"@#{suggested_var}\")\n            end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/MethodLength",
    "label": "",
    "id": "303"
  },
  {
    "raw_code": "def arity\n            @source.scan('*').count + 1\n          end",
    "comment": "Number of arguments required for the format sequence",
    "label": "",
    "id": "304"
  },
  {
    "raw_code": "def precede?(node1, node2)\n          node2.loc.line - node1.loc.line <= 1\n        end",
    "comment": "The args node1 & node2 may represent a RuboCop::AST::Node or a Parser::Source::Comment. Both respond to #loc.",
    "label": "",
    "id": "305"
  },
  {
    "raw_code": "def version_specified_gem?(node)\n          # arguments[0] is the gem name\n          node.arguments[1]&.str_type?\n        end",
    "comment": "Besides the gem name, all other *positional* arguments to `gem` are version specifiers, as long as it has one we know there's at least one version specifier.",
    "label": "",
    "id": "306"
  },
  {
    "raw_code": "def restrictive_version_specified_gem?(node)\n          return false unless version_specified_gem?(node)\n\n          node.arguments[1..]\n              .any? { |arg| arg&.str_type? && RESTRICTIVE_VERSION_PATTERN.match?(arg.value) }\n        end",
    "comment": "Version specifications that restrict all updates going forward. This excludes versions like \">= 1.0\" or \"!= 2.0.3\".",
    "label": "",
    "id": "307"
  },
  {
    "raw_code": "def unimportant_missing_cr?(index, last_line, line)\n          style == :crlf && index == last_line - 1 && !line.end_with?(\"\\n\")\n        end",
    "comment": "If there is no LF on the last line, we don't care if there's no CR.",
    "label": "",
    "id": "308"
  },
  {
    "raw_code": "def base_description(indent_base_type)\n          case indent_base_type\n          when :left_brace_or_bracket\n            'the position of the opening bracket'\n          when :first_column_after_left_parenthesis\n            'the first position after the preceding left parenthesis'\n          when :parent_hash_key\n            'the parent hash key'\n          else\n            'the start of the line where the left square bracket is'\n          end",
    "comment": "Returns the description of what the correct indentation is based on.",
    "label": "",
    "id": "309"
  },
  {
    "raw_code": "def bare_access_modifier?(node)\n          node.send_type? && node.bare_access_modifier?\n        end",
    "comment": "Not all nodes define `bare_access_modifier?` (for example, `RuboCop::AST::DefNode` does not), so we must check `send_type?` first to avoid a NoMethodError.",
    "label": "",
    "id": "310"
  },
  {
    "raw_code": "def base_column_for_normal_style(node)\n          first_child = node.children.first\n          return unless first_child && bare_access_modifier?(first_child)\n\n          # If, as is most common, the access modifier is indented deeper than\n          # the module (`access_modifier_indent > module_indent`) then the\n          # indentation of the access modifier determines the correct\n          # indentation.\n          #\n          # Otherwise, in the rare event that the access modifier is outdented\n          # to the level of the module (see `AccessModifierIndentation` cop) we\n          # return nil so that `check_alignment` will derive the correct\n          # indentation from the first child that is not an access modifier.\n          access_modifier_indent = display_column(first_child.source_range)\n          return access_modifier_indent unless node.parent\n\n          module_indent = display_column(node.parent.source_range)\n          access_modifier_indent if access_modifier_indent > module_indent\n        end",
    "comment": "Returns an integer representing the correct indentation, or nil to indicate that the correct indentation is that of the first child that is not an access modifier.",
    "label": "",
    "id": "311"
  },
  {
    "raw_code": "def ignored_ranges(ast)\n          return [] unless ast\n\n          @ignored_ranges ||= begin\n            ranges = []\n            on_node(:pair, ast) do |pair|\n              next if pair.parent.single_line?\n\n              key, value = *pair\n              ranges << (key.source_range.end_pos...value.source_range.begin_pos)\n            end",
    "comment": "Returns an array of ranges that should not be reported. It's the extra spaces between the keys and values in a multiline hash, since those are handled by the Layout/HashAlignment cop.",
    "label": "",
    "id": "312"
  },
  {
    "raw_code": "def on_match_pattern(node)\n          return if target_ruby_version >= 3.0\n\n          check(node, [:operator].freeze)\n        end",
    "comment": "Handle one-line pattern matching syntax (`in`) with `Parser::Ruby27`.",
    "label": "",
    "id": "313"
  },
  {
    "raw_code": "def on_match_pattern_p(node)\n          check(node, [:operator].freeze)\n        end",
    "comment": "Handle one-line pattern matching syntax (`in`) with `Parser::Ruby30`.",
    "label": "",
    "id": "314"
  },
  {
    "raw_code": "def autocorrect(corrector, node)\n          fix_closing_parenthesis(node, corrector)\n\n          remove_internal_trailing_comma(node, corrector) if internal_trailing_comma?(node)\n\n          fix_external_trailing_comma(node, corrector) if external_trailing_comma?(node)\n        end",
    "comment": "Autocorrection note:  Commas are a bit tricky to handle when the method call is embedded in another expression. Here's an example:  [ first_array_value, foo(<<-SQL, 123, 456, SELECT * FROM db SQL ), third_array_value, ]  The \"internal\" trailing comma is after `456`. The \"external\" trailing comma is after `)`.  To autocorrect, we remove the latter, and move the former up:  [ first_array_value, foo(<<-SQL, 123, 456), SELECT * FROM db SQL third_array_value, ]",
    "label": "",
    "id": "315"
  },
  {
    "raw_code": "def end_keyword_before_closing_parenthesis?(parenthesized_send_node)\n          parenthesized_send_node.ancestors.any? do |ancestor|\n            ancestor.loc_is?(:end, 'end')\n          end",
    "comment": "Closing parenthesis helpers.",
    "label": "",
    "id": "316"
  },
  {
    "raw_code": "def remove_internal_trailing_comma(node, corrector)\n          offset = internal_trailing_comma_offset_from_last_arg(node)\n          last_arg_end_pos = node.children.last.source_range.end_pos\n          corrector.remove(range_between(last_arg_end_pos, last_arg_end_pos + offset))\n        end",
    "comment": "Internal trailing comma helpers.",
    "label": "",
    "id": "317"
  },
  {
    "raw_code": "def internal_trailing_comma_offset_from_last_arg(node)\n          source_after_last_arg = range_between(\n            node.children.last.source_range.end_pos,\n            node.loc.end.begin_pos\n          ).source\n\n          first_comma_offset = source_after_last_arg.index(',')\n          first_new_line_offset = source_after_last_arg.index(\"\\n\")\n          return if first_comma_offset.nil?\n          return if first_new_line_offset.nil?\n          return if first_comma_offset > first_new_line_offset\n\n          first_comma_offset + 1\n        end",
    "comment": "Returns nil if no trailing internal comma.",
    "label": "",
    "id": "318"
  },
  {
    "raw_code": "def fix_external_trailing_comma(node, corrector)\n          remove_incorrect_external_trailing_comma(node, corrector)\n          add_correct_external_trailing_comma(node, corrector)\n        end",
    "comment": "External trailing comma helpers.",
    "label": "",
    "id": "319"
  },
  {
    "raw_code": "def external_trailing_comma_offset_from_loc_end(node)\n          end_pos = node.source_range.end_pos\n          offset = 0\n          limit = 20\n          offset += 1 while offset < limit && space?(end_pos + offset)\n          char = processed_source.buffer.source[end_pos + offset]\n          return unless char == ','\n\n          offset + 1 # Add one to include the comma.\n        end",
    "comment": "Returns nil if no trailing external comma.",
    "label": "",
    "id": "320"
  },
  {
    "raw_code": "def last_magic_comment(source)\n          comments_before_code(source)\n            .reverse\n            .find { |comment| MagicComment.parse(comment.text).any? }\n        end",
    "comment": "Find the last magic comment in the source file.  Take all comments that precede the first line of code (or just take them all in the case when there is no code), select the magic comments, and return the last magic comment in the file.  @return [Parser::Source::Comment] if magic comments exist before code @return [nil] otherwise",
    "label": "",
    "id": "321"
  },
  {
    "raw_code": "def other_offense_in_same_range?(node)\n          expr = node.source_range\n          @offense_ranges ||= []\n\n          return true if @offense_ranges.any? { |r| within?(expr, r) }\n\n          @offense_ranges << expr\n          false\n        end",
    "comment": "Returns true if the given node is within another node that has already been marked for autocorrection by this cop.",
    "label": "",
    "id": "322"
  },
  {
    "raw_code": "def column_of(range)\n          source = range.source.strip\n          if source.include?(\"\\n\")\n            previous_code_line(range.line + source.count(\"\\n\") + 1) =~ /\\S/\n          else\n            display_column(range)\n          end",
    "comment": "Returns the column of the given range. For single line ranges, this is simple. For ranges with line breaks, we look a the last code line.",
    "label": "",
    "id": "323"
  },
  {
    "raw_code": "def previous_code_line(line_number)\n          line = ''\n          while line.blank? || comment_lines.include?(line_number)\n            line_number -= 1\n            line = processed_source.lines[line_number - 1]\n          end",
    "comment": "Takes the line number of a given code line and returns a string containing the previous line that's not a comment line or a blank line.",
    "label": "",
    "id": "324"
  },
  {
    "raw_code": "def check(node)\n          alignment_node = alignment_node(node)\n          return if alignment_node.nil?\n\n          alignment_loc = alignment_location(alignment_node)\n          kw_loc        = node.loc.keyword\n\n          return if alignment_loc.column == kw_loc.column || same_line?(alignment_loc, kw_loc)\n\n          add_offense(\n            kw_loc, message: format_message(alignment_node, alignment_loc, kw_loc)\n          ) do |corrector|\n            autocorrect(corrector, node, alignment_loc)\n          end",
    "comment": "Check alignment of node with rescue or ensure modifiers.",
    "label": "",
    "id": "325"
  },
  {
    "raw_code": "def alignment_source(node, starting_loc)\n          ending_loc =\n            case node.type\n            when :block, :numblock, :itblock, :kwbegin\n              node.loc.begin\n            when :def, :defs, :class, :module,\n                 :lvasgn, :ivasgn, :cvasgn, :gvasgn, :casgn\n              node.loc.name\n            when :masgn\n              node.lhs.source_range\n            else\n              # It is a wrapper with receiver of object attribute or access modifier.\n              node.receiver&.source_range || node.child_nodes.first.loc.name\n            end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "326"
  },
  {
    "raw_code": "def alignment_node(node)\n          ancestor_node = ancestor_node(node)\n\n          return ancestor_node if ancestor_node.nil? || ancestor_node.kwbegin_type?\n          return if ancestor_node.respond_to?(:send_node) &&\n                    aligned_with_line_break_method?(ancestor_node, node)\n\n          assignment_node = assignment_node(ancestor_node)\n          return assignment_node if same_line?(ancestor_node, assignment_node)\n\n          access_modifier_node = access_modifier_node(ancestor_node)\n          return access_modifier_node unless access_modifier_node.nil?\n\n          ancestor_node\n        end",
    "comment": "rubocop:enable Metrics/AbcSize We will use ancestor or wrapper with access modifier.",
    "label": "",
    "id": "327"
  },
  {
    "raw_code": "def on_begin(node)\n          node.children.each_cons(2) do |prev, n|\n            nodes = [prev, n]\n            check_defs(nodes) if nodes.all? { |def_candidate| candidate?(def_candidate) }\n          end",
    "comment": "We operate on `begin` nodes, instead of using `OnMethodDef`, so that we can walk over pairs of consecutive nodes and efficiently access a node's predecessor; #prev_node ends up doing a linear scan over siblings, so we don't want to call it on each def.",
    "label": "",
    "id": "328"
  },
  {
    "raw_code": "def unexpected_indent_offset\n          configured_indentation_width - expected_indent_offset\n        end",
    "comment": "An offset that is not expected, but correct if the configuration is changed.",
    "label": "",
    "id": "329"
  },
  {
    "raw_code": "def autocorrect_preceding_comments(corrector, comment)\n          comments = processed_source.comments\n          index = comments.index(comment)\n\n          comments[0..index]\n            .reverse_each\n            .each_cons(2)\n            .take_while { |below, above| should_correct?(above, below) }\n            .map { |_, above| autocorrect_one(corrector, above) }\n        end",
    "comment": "Corrects all comment lines that occur immediately before the given comment and have the same indentation. This is to avoid a long chain of correcting, saving the file, parsing and inspecting again, and then correcting one more line, and so on.",
    "label": "",
    "id": "330"
  },
  {
    "raw_code": "def correctly_aligned_with_preceding_comment?(comment_index, column)\n          return false unless cop_config['AllowForAlignment']\n\n          processed_source.comments[0...comment_index].reverse_each do |other_comment|\n            return other_comment.loc.column == column unless own_line_comment?(other_comment)\n          end",
    "comment": "Returns true if: a) the cop is configured to allow extra indentation for alignment, and b) the currently inspected comment is aligned with the nearest preceding end-of-line comment.",
    "label": "",
    "id": "331"
  },
  {
    "raw_code": "def self.autocorrect_incompatible_with\n          [Style::StringLiterals]\n        end",
    "comment": "When both cops are activated and run in the same iteration of the correction loop, `Style/StringLiterals` undoes the moving of spaces that `Layout/LineContinuationLeadingSpace` performs. This is because `Style/StringLiterals` takes the original string content and transforms it, rather than just modifying the delimiters, in order to handle escaping for quotes within the string.",
    "label": "",
    "id": "332"
  },
  {
    "raw_code": "def simplecov_directive_comment?(comment)\n          SIMPLE_DIRECTIVE_COMMENT_PATTERN.match?(comment.text)\n        end",
    "comment": "SimpleCov excludes code from the coverage report by wrapping it in `# :nocov:`: https://github.com/simplecov-ruby/simplecov#ignoringskipping-code",
    "label": "",
    "id": "333"
  },
  {
    "raw_code": "def heredoc_indent_type(node)\n          node.source[/^<<([~-])/, 1]\n        end",
    "comment": "Returns '~', '-' or nil",
    "label": "",
    "id": "334"
  },
  {
    "raw_code": "def breakable_string_range(node)\n          source_range = node.source_range\n          relevant_substr = largest_possible_string(node)\n\n          if (space_pos = relevant_substr.rindex(/\\s/))\n            source_range.resize(space_pos + 1)\n          elsif (escape_pos = relevant_substr.rindex(/\\\\(u[\\da-f]{0,4}|x[\\da-f]{0,2})?\\z/))\n            source_range.resize(escape_pos)\n          else\n            adjustment = max - source_range.last_column - 3\n            return if adjustment.abs > source_range.size\n\n            source_range.adjust(end_pos: adjustment)\n          end",
    "comment": "Locate where to break a string that is too long, ensuring that escape characters are not bisected. If the string contains spaces, use them to determine a place for a clean break; otherwise, the string will be broken at the line length limit.",
    "label": "",
    "id": "335"
  },
  {
    "raw_code": "def largest_possible_string(node)\n          # The maximum allowed length of a string value is:\n          # `Max` - end delimiter (quote) - continuation characters (space and slash)\n          max_length = max - 3\n          # If the string doesn't start at the beginning of the line, the max length is offset\n          max_length -= column_offset_between(node.loc, node.parent.loc) if node.parent\n          node.source[0...(max_length)]\n        end",
    "comment": "Find the largest possible substring of a string node to retain before a break",
    "label": "",
    "id": "336"
  },
  {
    "raw_code": "def on_class(class_node)\n          previous = -1\n          walk_over_nested_class_definition(class_node) do |node, category|\n            index = expected_order.index(category)\n            if index < previous\n              message = format(MSG, category: category, previous: expected_order[previous])\n              add_offense(node, message: message) { |corrector| autocorrect(corrector, node) }\n            end",
    "comment": "Validates code style on class declaration. Add offense when find a node out of expected order.",
    "label": "",
    "id": "337"
  },
  {
    "raw_code": "def autocorrect(corrector, node)\n          previous = node.left_siblings.reverse.find do |sibling|\n            !ignore_for_autocorrect?(node, sibling)\n          end",
    "comment": "Autocorrect by swapping between two nodes autocorrecting them",
    "label": "",
    "id": "338"
  },
  {
    "raw_code": "def classify(node)\n          return node.to_s unless node.respond_to?(:type)\n\n          case node.type\n          when :block\n            classify(node.send_node)\n          when :send\n            find_category(node)\n          else\n            humanize_node(node)\n          end.to_s\n        end",
    "comment": "Classifies a node to match with something in the {expected_order} @param node to be analysed @return String when the node type is a `:block` then {classify} recursively with the first children @return String when the node type is a `:send` then {find_category} by method name @return String otherwise trying to {humanize_node} of the current node",
    "label": "",
    "id": "339"
  },
  {
    "raw_code": "def find_category(node)\n          name = node.method_name.to_s\n          category, = categories.find { |_, names| names.include?(name) }\n          key = category || name\n          visibility_key =\n            if node.def_modifier?\n              \"#{name}_methods\"\n            else\n              \"#{node_visibility(node)}_#{key}\"\n            end",
    "comment": "Categorize a node according to the {expected_order} Try to match {categories} values against the node's method_name given also its visibility. @param node to be analysed. @return [String] with the key category or the `method_name` as string",
    "label": "",
    "id": "340"
  },
  {
    "raw_code": "def expected_order\n          cop_config['ExpectedOrder']\n        end",
    "comment": "Load expected order from `ExpectedOrder` config. Define new terms in the expected order by adding new {categories}.",
    "label": "",
    "id": "341"
  },
  {
    "raw_code": "def categories\n          cop_config['Categories']\n        end",
    "comment": "Setting categories hash allow you to group methods in group to match in the {expected_order}.",
    "label": "",
    "id": "342"
  },
  {
    "raw_code": "def base_description(indent_base_type)\n          case indent_base_type\n          when :left_brace_or_bracket\n            'the position of the opening brace'\n          when :first_column_after_left_parenthesis\n            'the first position after the preceding left parenthesis'\n          when :parent_hash_key\n            'the parent hash key'\n          else\n            'the start of the line where the left curly brace is'\n          end",
    "comment": "Returns the description of what the correct indentation is based on.",
    "label": "",
    "id": "343"
  },
  {
    "raw_code": "def semantic_alignment_base(node, rhs)\n          return unless rhs.source.start_with?('.', '&.')\n\n          node = semantic_alignment_node(node)\n          return unless node&.loc&.selector && node.loc.dot\n\n          node.loc.dot.join(node.loc.selector)\n        end",
    "comment": "a.b .c",
    "label": "",
    "id": "344"
  },
  {
    "raw_code": "def receiver_alignment_base(node)\n          node = node.receiver while node.receiver\n          node = node.parent\n          node = node.parent until node.loc.dot\n\n          node&.receiver&.source_range\n        end",
    "comment": "a .b .c",
    "label": "",
    "id": "345"
  },
  {
    "raw_code": "def find_lhs_node(node)\n          node = node.lhs while node.type?(:op_asgn, :masgn)\n          node\n        end",
    "comment": "In offense message, we want to show the assignment LHS rather than the entire assignment.",
    "label": "",
    "id": "346"
  },
  {
    "raw_code": "def base_description(_)\n          if style == brace_alignment_style\n            'the position of the opening parenthesis'\n          else\n            'the start of the line where the left parenthesis is'\n          end",
    "comment": "Returns the description of what the correct indentation is based on.",
    "label": "",
    "id": "347"
  },
  {
    "raw_code": "def ignored_literal_ranges(ast)\n          # which lines start inside a string literal?\n          return [] if ast.nil?\n\n          ast.each_node(:str, :dstr, :array).with_object(Set.new) do |literal, ranges|\n            loc = literal.location\n\n            if literal.array_type?\n              next unless literal.percent_literal?\n\n              ranges << loc.expression\n            elsif literal.heredoc?\n              ranges << loc.heredoc_body\n            elsif (loc.respond_to?(:begin) && loc.begin) || ignored_parent?(literal)\n              ranges << loc.expression\n            end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "348"
  },
  {
    "raw_code": "def comment_ranges(comments)\n          comments.map(&:source_range)\n        end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "349"
  },
  {
    "raw_code": "def irrelevant_line?(source_line)\n            source_line.blank? || (!count_comments? && comment_line?(source_line))\n          end",
    "comment": "Returns true for lines that shall not be included in the count.",
    "label": "",
    "id": "350"
  },
  {
    "raw_code": "def initialize(node, discount_repeated_attributes: false)\n            super(node)\n            return unless discount_repeated_attributes\n\n            self_attributes = {} # Share hash for `(send nil? :foo)` and `(send (self) :foo)`\n            @known_attributes = { s(:self) => self_attributes, nil => self_attributes }\n            # example after running `obj = foo.bar; obj.baz.qux`\n            # { nil => {foo: {bar: {}}},\n            #   s(self) => same hash ^,\n            #   s(:lvar, :obj) => {baz: {qux: {}}}\n            # }\n          end",
    "comment": "Plug into the calculator",
    "label": "",
    "id": "351"
  },
  {
    "raw_code": "def find_attributes(node, &block)\n            if attribute_call?(node)\n              calls = find_attributes(node.receiver, &block)\n              value = node.method_name\n            elsif root_node?(node)\n              calls = @known_attributes\n              value = node\n            else\n              return yield nil\n            end",
    "comment": "Returns the \"known_attributes\" for the `node` by walking the receiver tree If at any step the subdirectory does not exist, it is yielded with the associated key (method_name) If the node is not a series of `(c)send` calls with no arguments, then `nil` is yielded",
    "label": "",
    "id": "352"
  },
  {
    "raw_code": "def setter_to_getter(node)\n            if (type = VAR_SETTER_TO_GETTER[node.type])\n              # (lvasgn :my_var (int 42)) => [(lvar my_var), nil]\n              [s(type, node.children.first), nil]\n            elsif node.shorthand_asgn? # (or-asgn (send _receiver :foo) _value)\n              # (or-asgn (send _receiver :foo) _value) => [_receiver, :foo]\n              node.children.first.children\n            elsif node.respond_to?(:setter_method?) && node.setter_method?\n              # (send _receiver :foo= (int 42) ) => [_receiver, :foo]\n              method_name = node.method_name[0...-1].to_sym\n              [node.receiver, method_name]\n            end",
    "comment": "@returns `[receiver, method | nil]` for the given setter `node` or `nil` if it is not a setter.",
    "label": "",
    "id": "353"
  },
  {
    "raw_code": "def block_method_name(node)\n            case node.type\n            when :block\n              node.method_name\n            when :block_pass\n              node.parent.method_name\n            end",
    "comment": "Returns the name of the method called with a block if node is a block node, or a block-pass node.",
    "label": "",
    "id": "354"
  },
  {
    "raw_code": "def iterating_method?(name)\n            KNOWN_ITERATING_METHODS.include? name\n          end",
    "comment": "Returns true iff name is a known iterating type (e.g. :each, :transform_values)",
    "label": "",
    "id": "355"
  },
  {
    "raw_code": "def iterating_block?(node)\n            name = block_method_name(node)\n            name && iterating_method?(name)\n          end",
    "comment": "Returns nil if node is neither a block node or a block-pass node. Otherwise returns true/false if method call is a known iterating call",
    "label": "",
    "id": "356"
  },
  {
    "raw_code": "def preceding_comment?(node1, node2)\n        node1 && node2 && precede?(node2, node1) && comment_line?(node2.source)\n      end",
    "comment": "The args node1 & node2 may represent a RuboCop::AST::Node or a Parser::Source::Comment. Both respond to #loc.",
    "label": "",
    "id": "357"
  },
  {
    "raw_code": "def precede?(node1, node2)\n        node2.loc.line - node1.loc.line == 1\n      end",
    "comment": "The args node1 & node2 may represent a RuboCop::AST::Node or a Parser::Source::Comment. Both respond to #loc.",
    "label": "",
    "id": "358"
  },
  {
    "raw_code": "def class_emitter_method?(node, name)\n        return false unless node.parent && node.defs_type?\n\n        # a class emitter method may be defined inside `def self.included`,\n        # `def self.extended`, etc.\n        node = node.parent while node.parent.defs_type?\n\n        node.parent.each_child_node(:class).any? { |c| c.loc.name.is?(name.to_s) }\n      end",
    "comment": "A class emitter method is a singleton method in a class/module, where the method has the same name as a class defined in the class/module.",
    "label": "",
    "id": "359"
  },
  {
    "raw_code": "def extract_breakable_node_from_elements(node, elements, max)\n        return unless breakable_collection?(node, elements)\n        return if safe_to_ignore?(node)\n\n        line = processed_source.lines[node.first_line - 1]\n        return if processed_source.line_with_comment?(node.loc.line)\n        return if line.length <= max\n\n        extract_first_element_over_column_limit(node, elements, max)\n      end",
    "comment": "@api private",
    "label": "",
    "id": "360"
  },
  {
    "raw_code": "def extract_first_element_over_column_limit(node, elements, max)\n        line = node.first_line\n\n        # If a `send` or `csend` node is not parenthesized, don't move the first element, because it\n        # can result in changed behavior or a syntax error.\n        if node.call_type? && !node.parenthesized? && !first_argument_is_heredoc?(node)\n          elements = elements.drop(1)\n        end",
    "comment": "@api private",
    "label": "",
    "id": "361"
  },
  {
    "raw_code": "def first_argument_is_heredoc?(node)\n        first_argument = node.first_argument\n\n        first_argument.respond_to?(:heredoc?) && first_argument.heredoc?\n      end",
    "comment": "@api private",
    "label": "",
    "id": "362"
  },
  {
    "raw_code": "def shift_elements_for_heredoc_arg(node, elements, index)\n        return index unless node.type?(:call, :array)\n\n        heredoc_index = elements.index { |arg| arg.respond_to?(:heredoc?) && arg.heredoc? }\n        return index unless heredoc_index\n        return nil if heredoc_index.zero?\n\n        heredoc_index >= index ? index : heredoc_index + 1\n      end",
    "comment": "@api private If a `send` or `csend` node contains a heredoc argument, splitting cannot happen after the heredoc or else it will cause a syntax error.",
    "label": "",
    "id": "363"
  },
  {
    "raw_code": "def within_column_limit?(element, max, line)\n        element && element.loc.column <= max && element.loc.line == line\n      end",
    "comment": "@api private",
    "label": "",
    "id": "364"
  },
  {
    "raw_code": "def safe_to_ignore?(node)\n        return true unless max\n        return true if already_on_multiple_lines?(node)\n\n        # If there's a containing breakable collection on the same\n        # line, we let that one get broken first. In a separate pass,\n        # this one might get broken as well, but to avoid conflicting\n        # or redundant edits, we only mark one offense at a time.\n        return true if contained_by_breakable_collection_on_same_line?(node)\n\n        return true if contained_by_multiline_collection_that_could_be_broken_up?(node)\n\n        false\n      end",
    "comment": "@api private",
    "label": "",
    "id": "365"
  },
  {
    "raw_code": "def breakable_collection?(node, elements)\n        # For simplicity we only want to insert breaks in normal\n        # hashes wrapped in a set of curly braces like {foo: 1}.\n        # That is, not a kwargs hash. For method calls, this ensures\n        # the method call is made with parens.\n        starts_with_bracket = !node.hash_type? || node.loc.begin\n\n        # If the call has a second argument, we can insert a line\n        # break before the second argument and the rest of the\n        # argument will get auto-formatted onto separate lines\n        # by other cops.\n        has_second_element = elements.length >= 2\n\n        starts_with_bracket && has_second_element\n      end",
    "comment": "@api private",
    "label": "",
    "id": "366"
  },
  {
    "raw_code": "def contained_by_breakable_collection_on_same_line?(node)\n        node.each_ancestor.find do |ancestor|\n          # Ignore ancestors on different lines.\n          break if ancestor.first_line != node.first_line\n\n          if ancestor.type?(:hash, :array)\n            elements = ancestor.children\n          elsif ancestor.call_type?\n            elements = process_args(ancestor.arguments)\n          else\n            next\n          end",
    "comment": "@api private",
    "label": "",
    "id": "367"
  },
  {
    "raw_code": "def contained_by_multiline_collection_that_could_be_broken_up?(node)\n        node.each_ancestor.find do |ancestor|\n          if ancestor.type?(:hash, :array) &&\n             breakable_collection?(ancestor, ancestor.children)\n            return children_could_be_broken_up?(ancestor.children)\n          end",
    "comment": "@api private",
    "label": "",
    "id": "368"
  },
  {
    "raw_code": "def children_could_be_broken_up?(children)\n        return false if all_on_same_line?(children)\n\n        last_seen_line = -1\n        children.each do |child|\n          return true if last_seen_line >= child.first_line\n\n          last_seen_line = child.last_line\n        end",
    "comment": "@api private",
    "label": "",
    "id": "369"
  },
  {
    "raw_code": "def all_on_same_line?(nodes)\n        return true if nodes.empty?\n\n        nodes.first.first_line == nodes.last.last_line\n      end",
    "comment": "@api private",
    "label": "",
    "id": "370"
  },
  {
    "raw_code": "def process_args(args)\n        # If there is a trailing hash arg without explicit braces, like this:\n        #\n        #    method(1, 'key1' => value1, 'key2' => value2)\n        #\n        # ...then each key/value pair is treated as a method 'argument'\n        # when determining where line breaks should appear.\n        last_arg = args.last\n        args = args[0...-1] + last_arg.children if last_arg&.hash_type? && !last_arg&.braces?\n        args\n      end",
    "comment": "@api private",
    "label": "",
    "id": "371"
  },
  {
    "raw_code": "def already_on_multiple_lines?(node)\n        return node.first_line != node.last_argument.last_line if node.any_def_type?\n\n        !node.single_line?\n      end",
    "comment": "@api private",
    "label": "",
    "id": "372"
  },
  {
    "raw_code": "def allowed_method?(name)\n        allowed_methods.include?(name.to_s)\n      end",
    "comment": "@api public",
    "label": "",
    "id": "373"
  },
  {
    "raw_code": "def ignored_method?\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `ignored_method?` is deprecated. Use `allowed_method?` instead.\n        WARNING\n\n        allowed_method?\n      end",
    "comment": "@deprecated Use allowed_method? instead",
    "label": "",
    "id": "374"
  },
  {
    "raw_code": "def allowed_methods\n        if cop_config_deprecated_values.any?(Regexp)\n          cop_config_allowed_methods\n        else\n          cop_config_allowed_methods + cop_config_deprecated_values\n        end",
    "comment": "@api public",
    "label": "",
    "id": "375"
  },
  {
    "raw_code": "def find_visibility_end(node)\n        possible_visibilities = VISIBILITY_SCOPES - ::Set[node_visibility(node)]\n        right = node.right_siblings\n        right.find do |child_node|\n          possible_visibilities.include?(node_visibility(child_node))\n        end || right.last\n      end",
    "comment": "Navigate to find the last protected method",
    "label": "",
    "id": "376"
  },
  {
    "raw_code": "def ignored_line?(line)\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `ignored_line?` is deprecated. Use `allowed_line?` instead.\n        WARNING\n\n        allowed_line?(line)\n      end",
    "comment": "@deprecated Use allowed_line? instead",
    "label": "",
    "id": "377"
  },
  {
    "raw_code": "def matches_ignored_pattern?(line)\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `matches_ignored_pattern?` is deprecated. Use `matches_allowed_pattern?` instead.\n        WARNING\n\n        matches_allowed_pattern?(line)\n      end",
    "comment": "@deprecated Use matches_allowed_pattern? instead",
    "label": "",
    "id": "378"
  },
  {
    "raw_code": "def irrelevant_line(source_line)\n        source_line.blank? || (!count_comments? && comment_line?(source_line))\n      end",
    "comment": "Returns true for lines that shall not be included in the count.",
    "label": "",
    "id": "379"
  },
  {
    "raw_code": "def left_hand_side(lhs)\n        while lhs.parent&.call_type? && lhs.parent.loc.dot && !lhs.parent.assignment_method?\n          lhs = lhs.parent\n        end",
    "comment": "In a chain of method calls, we regard the top call node as the base for indentation of all lines following the first. For example: a. b c { block }.            <-- b is indented relative to a d                         <-- d is indented relative to a",
    "label": "",
    "id": "380"
  },
  {
    "raw_code": "def correct_indentation(node)\n        kw_node = kw_node_with_special_indentation(node)\n        if kw_node && !postfix_conditional?(kw_node)\n          # This cop could have its own IndentationWidth configuration\n          configured_indentation_width + @config.for_cop('Layout/IndentationWidth')['Width']\n        else\n          configured_indentation_width\n        end",
    "comment": "The correct indentation of `node` is usually `IndentationWidth`, with one exception: prefix keywords.  ``` while foo &&  # Here, `while` is called a \"prefix keyword\" bar       # This is called \"special indentation\" baz end ```  Note that *postfix conditionals* do *not* get \"special indentation\".  ``` next if foo && bar # normal indentation, not special ```",
    "label": "",
    "id": "381"
  },
  {
    "raw_code": "def valid_method_rhs_candidate?(candidate, node)\n        node.setter_method? && valid_rhs_candidate?(candidate, node.last_argument)\n      end",
    "comment": "The []= operator and setters (a.b = c) are parsed as :send nodes.",
    "label": "",
    "id": "382"
  },
  {
    "raw_code": "def postfix_conditional?(node)\n        node.if_type? && node.modifier_form?\n      end",
    "comment": "Returns true if `node` is a conditional whose `body` and `condition` begin on the same line.",
    "label": "",
    "id": "383"
  },
  {
    "raw_code": "def each_bad_alignment(items, base_column)\n        prev_line = -1\n        items.each do |current|\n          if current.loc.line > prev_line && begins_its_line?(current.source_range)\n            @column_delta = base_column - display_column(current.source_range)\n\n            yield current if @column_delta.nonzero?\n          end",
    "comment": "@api private",
    "label": "",
    "id": "384"
  },
  {
    "raw_code": "def display_column(range)\n        line = processed_source.lines[range.line - 1]\n        Unicode::DisplayWidth.of(line[0, range.column])\n      end",
    "comment": "@api public",
    "label": "",
    "id": "385"
  },
  {
    "raw_code": "def within?(inner, outer)\n        inner.begin_pos >= outer.begin_pos && inner.end_pos <= outer.end_pos\n      end",
    "comment": "@api public",
    "label": "",
    "id": "386"
  },
  {
    "raw_code": "def end_of_line_comment(line) # rubocop:disable Naming/PredicateMethod\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `end_of_line_comment` is deprecated. Use `processed_source.line_with_comment?` instead.\n        WARNING\n\n        processed_source.line_with_comment?(line)\n      end",
    "comment": "@deprecated Use processed_source.line_with_comment?(line)",
    "label": "",
    "id": "387"
  },
  {
    "raw_code": "def register_offense(offense_node, message_node)\n        add_offense(offense_node, message: message(message_node)) do |corrector|\n          autocorrect(corrector, message_node)\n        end",
    "comment": "@api private",
    "label": "",
    "id": "388"
  },
  {
    "raw_code": "def style_detected(detected)\n        return if no_acceptable_style?\n\n        # This logic is more complex than it needs to be\n        # to avoid allocating Arrays in the hot code path.\n        updated_list =\n          if detected_style\n            if detected_style.size == 1 && detected_style.include?(SYMBOL_TO_STRING_CACHE[detected])\n              detected_style\n            else\n              detected_as_strings = SYMBOL_TO_STRING_CACHE.values_at(*detected)\n              detected_style & detected_as_strings\n            end",
    "comment": "rubocop:disable Metrics",
    "label": "",
    "id": "389"
  },
  {
    "raw_code": "def no_acceptable_style?\n        config_to_allow_offenses['Enabled'] == false\n      end",
    "comment": "rubocop:enable Metrics",
    "label": "",
    "id": "390"
  },
  {
    "raw_code": "def brackets?(node)\n        node.loc.end\n      end",
    "comment": "Returns true if the node has round/square/curly brackets.",
    "label": "",
    "id": "391"
  },
  {
    "raw_code": "def multiline?(node)\n        node.multiline? && !allowed_multiline_argument?(node)\n      end",
    "comment": "Returns true if the round/square/curly brackets of the given node are on different lines, each item within is on its own line, and the closing bracket is on its own line.",
    "label": "",
    "id": "392"
  },
  {
    "raw_code": "def allowed_multiline_argument?(node)\n        elements(node).one? && !Util.begins_its_line?(node_end_location(node))\n      end",
    "comment": "A single argument with the closing bracket on the same line as the end of the argument is not considered multiline, even if the argument itself might span multiple lines.",
    "label": "",
    "id": "393"
  },
  {
    "raw_code": "def offset\n        1\n      end",
    "comment": "The normal offset, i.e., the distance from the punctuation token where a space should be, is 1.",
    "label": "",
    "id": "394"
  },
  {
    "raw_code": "def rescued_exceptions(resbody)\n        warn Rainbow(<<~WARNING).yellow, uplevel: 1\n          `rescued_exceptions` is deprecated. Use `ResbodyNode#exceptions` instead.\n        WARNING\n\n        rescue_group, = *resbody\n        if rescue_group\n          rescue_group.values\n        else\n          []\n        end",
    "comment": "@deprecated Use ResbodyNode#exceptions instead",
    "label": "",
    "id": "395"
  },
  {
    "raw_code": "def find_end_line(node)\n        if node.if_type?\n          if node.else?\n            node.loc.else.line\n          elsif node.ternary?\n            node.else_branch.loc.line\n          elsif node.elsif?\n            node.each_ancestor(:if).find(&:if?).loc.end.line\n          elsif node.if? && node.parent && parentheses?(node.parent)\n            node.parent.loc.end.line\n          end",
    "comment": "Returns the end line of a node, which might be a comment and not part of the AST End line is considered either the line at which another node starts, or the line at which the parent node ends. rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength, Metrics/PerceivedComplexity",
    "label": "",
    "id": "396"
  },
  {
    "raw_code": "def contents_range(node)\n        range_between(node.loc.begin.end_pos, node.loc.end.begin_pos)\n      end",
    "comment": "A range containing only the contents of a literal with delimiters (e.g. in `%i{1 2 3}` this will be the range covering `1 2 3` only).",
    "label": "",
    "id": "397"
  },
  {
    "raw_code": "def arguments_range(node)\n        node.first_argument.source_range.join(node.last_argument.source_range)\n      end",
    "comment": "A range containing the first to the last argument of a method call or method definition. def foo(a, b:) ^^^^^ bar(1, 2, 3, &blk) ^^^^^^^^^^^^^ baz { |x, y:, z:| } ^^^^^^^^^",
    "label": "",
    "id": "398"
  },
  {
    "raw_code": "def effective_column(range)\n        if range.line == 1 && @processed_source.raw_source.codepoints.first == BYTE_ORDER_MARK\n          range.column - 1\n        else\n          range.column\n        end",
    "comment": "Helpers for above range methods. Do not use inside Cops. Returns the column attribute of the range, except if the range is on the first line and there's a byte order mark at the beginning of that line, in which case 1 is subtracted from the column value. This gives the column as it appears when viewing the file in an editor.",
    "label": "",
    "id": "399"
  },
  {
    "raw_code": "def final_pos(src, pos, increment, continuations, newlines, whitespace)\n        pos = move_pos(src, pos, increment, true, /[ \\t]/)\n        pos = move_pos_str(src, pos, increment, continuations, \"\\\\\\n\")\n        pos = move_pos(src, pos, increment, newlines, /\\n/)\n        move_pos(src, pos, increment, whitespace, /\\s/)\n      end",
    "comment": "rubocop:disable Metrics/ParameterLists",
    "label": "",
    "id": "400"
  },
  {
    "raw_code": "def move_pos(src, pos, step, condition, regexp)\n        offset = step == -1 ? -1 : 0\n        pos += step while condition && regexp.match?(src[pos + offset])\n        pos.negative? ? 0 : pos\n      end",
    "comment": "rubocop:enable Metrics/ParameterLists",
    "label": "",
    "id": "401"
  },
  {
    "raw_code": "def on_bad_each_with_object(_node)\n        raise NotImplementedError\n      end",
    "comment": "@abstract Implemented with `def_node_matcher`",
    "label": "",
    "id": "402"
  },
  {
    "raw_code": "def on_bad_hash_brackets_map(_node)\n        raise NotImplementedError\n      end",
    "comment": "@abstract Implemented with `def_node_matcher`",
    "label": "",
    "id": "403"
  },
  {
    "raw_code": "def on_bad_map_to_h(_node)\n        raise NotImplementedError\n      end",
    "comment": "@abstract Implemented with `def_node_matcher`",
    "label": "",
    "id": "404"
  },
  {
    "raw_code": "def on_bad_to_h(_node)\n        raise NotImplementedError\n      end",
    "comment": "@abstract Implemented with `def_node_matcher`",
    "label": "",
    "id": "405"
  },
  {
    "raw_code": "def extract_captures(_match)\n        raise NotImplementedError\n      end",
    "comment": "@abstract  @return [Captures]",
    "label": "",
    "id": "406"
  },
  {
    "raw_code": "def new_method_name\n        raise NotImplementedError\n      end",
    "comment": "@abstract  @return [String]",
    "label": "",
    "id": "407"
  },
  {
    "raw_code": "def new_line_needed_before_closing_brace?(node)\n        last_element_line = last_element_range_with_trailing_comma(node).last_line\n\n        last_element_commented = processed_source.comment_at_line(last_element_line)\n\n        last_element_commented && (node.chained? || node.argument?)\n      end",
    "comment": "Returns true for the case [a, b # comment ].some_method",
    "label": "",
    "id": "408"
  },
  {
    "raw_code": "def opening_brace_on_same_line?(node)\n        same_line?(node.loc.begin, children(node).first)\n      end",
    "comment": "This method depends on the fact that we have guarded against implicit and empty literals.",
    "label": "",
    "id": "409"
  },
  {
    "raw_code": "def closing_brace_on_same_line?(node)\n        node.loc.end.line == children(node).last.last_line\n      end",
    "comment": "This method depends on the fact that we have guarded against implicit and empty literals.",
    "label": "",
    "id": "410"
  },
  {
    "raw_code": "def last_line_heredoc?(node, parent = nil)\n        parent ||= node\n\n        if node.respond_to?(:loc) &&\n           node.loc.respond_to?(:heredoc_end) &&\n           node.loc.heredoc_end.last_line >= parent.last_line\n          return true\n        end",
    "comment": "Starting with the parent node and recursively for the parent node's children, check if the node is a HEREDOC and if the HEREDOC ends below or on the last line of the parent node.  Example:  # node is `b: ...` parameter # last_line_heredoc?(node) => false foo(a, b: { a: 1, c: <<-EOM baz EOM } )  # node is `b: ...` parameter # last_line_heredoc?(node) => true foo(a, b: <<-EOM baz EOM )",
    "label": "",
    "id": "411"
  },
  {
    "raw_code": "def duplicates?(collection)\n        collection.size > 1 && collection.size > collection.uniq.size\n      end",
    "comment": "Whether the `collection` contains any duplicates.  @param [Array] collection an array to check for duplicates @return [Boolean] whether the array contains any duplicates",
    "label": "",
    "id": "412"
  },
  {
    "raw_code": "def duplicates(collection)\n        grouped_duplicates(collection).flatten\n      end",
    "comment": "Returns all duplicates, including the first instance of the duplicated elements.  @param [Array] collection an array to return duplicates for @return [Array] all the duplicates",
    "label": "",
    "id": "413"
  },
  {
    "raw_code": "def consecutive_duplicates(collection)\n        grouped_duplicates(collection).flat_map { |items| items[1..] }\n      end",
    "comment": "Returns the consecutive duplicates, leaving out the first instance of the duplicated elements.  @param [Array] collection an array to return consecutive duplicates for @return [Array] the consecutive duplicates",
    "label": "",
    "id": "414"
  },
  {
    "raw_code": "def grouped_duplicates(collection)\n        collection.group_by { |item| item }.values.reject(&:one?)\n      end",
    "comment": "Returns a hash of grouped duplicates. The key will be the first instance of the element, and  the value an `array` of the initial element and all duplicate instances.  @param [Array] collection an array to group duplicates for @return [Array] the grouped duplicates",
    "label": "",
    "id": "415"
  },
  {
    "raw_code": "def invalid_percent_array_context?(node)\n        parent = node.parent\n\n        parent&.send_type? && parent.arguments.include?(node) &&\n          !parent.parenthesized? && parent.block_literal?\n      end",
    "comment": "Ruby does not allow percent arrays in an ambiguous block context.  @example  foo %i[bar baz] { qux }",
    "label": "",
    "id": "416"
  },
  {
    "raw_code": "def invalid_percent_array_contents?(_node)\n        false\n      end",
    "comment": "Override to determine values that are invalid in a percent array",
    "label": "",
    "id": "417"
  },
  {
    "raw_code": "def build_message_for_bracketed_array(preferred_array_code)\n        format(\n          self.class::ARRAY_MSG,\n          prefer: if preferred_array_code.include?(\"\\n\")\n                    'an array literal `[...]`'\n                  else\n                    \"`#{preferred_array_code}`\"\n                  end",
    "comment": "@param [String] preferred_array_code @return [String]",
    "label": "",
    "id": "418"
  },
  {
    "raw_code": "def build_bracketed_array_with_appropriate_whitespace(elements:, node:)\n        [\n          '[',\n          whitespace_leading(node),\n          elements.join(\",#{whitespace_between(node)}\"),\n          whitespace_trailing(node),\n          ']'\n        ].join\n      end",
    "comment": "@param [RuboCop::AST::ArrayNode] node @param [Array<String>] elements @return [String]",
    "label": "",
    "id": "419"
  },
  {
    "raw_code": "def whitespace_between(node)\n        if node.children.length >= 2\n          node.children[0].source_range.end.join(node.children[1].source_range.begin).source\n        else\n          ' '\n        end",
    "comment": "Provides whitespace between elements for building a bracketed array. %w[  a   b   c    ] ^^^ @param [RuboCop::AST::ArrayNode] node @return [String]",
    "label": "",
    "id": "420"
  },
  {
    "raw_code": "def whitespace_leading(node)\n        node.loc.begin.end.join(node.children[0].source_range.begin).source\n      end",
    "comment": "Provides leading whitespace for building a bracketed array. %w[  a   b   c    ] ^^ @param [RuboCop::AST::ArrayNode] node @return [String]",
    "label": "",
    "id": "421"
  },
  {
    "raw_code": "def whitespace_trailing(node)\n        node.children[-1].source_range.end.join(node.loc.end.begin).source\n      end",
    "comment": "Provides trailing whitespace for building a bracketed array. %w[  a   b   c    ] ^^^^ @param [RuboCop::AST::ArrayNode] node @return [String]",
    "label": "",
    "id": "422"
  },
  {
    "raw_code": "def each_match_range(range, regex)\n        range.source.scan(regex) { yield match_range(range, Regexp.last_match) }\n      end",
    "comment": "Return a new `Range` covering the first matching group number for each match of `regex` inside `range`",
    "label": "",
    "id": "423"
  },
  {
    "raw_code": "def match_range(range, match)\n        range_between(range.begin_pos + match.begin(1), range.begin_pos + match.end(1))\n      end",
    "comment": "For a `match` inside `range`, return a new `Range` covering the match",
    "label": "",
    "id": "424"
  },
  {
    "raw_code": "def initialize(comment, keywords)\n        @comment = comment\n        @keywords = keywords\n        @margin, @keyword, @colon, @space, @note = split_comment(comment)\n      end",
    "comment": "@param [Parser::Source::Comment] comment @param [Array<String>] keywords",
    "label": "",
    "id": "425"
  },
  {
    "raw_code": "def bounds\n        start = comment.source_range.begin_pos + margin.length\n        length = [keyword, colon, space].reduce(0) { |len, elem| len + elem.to_s.length }\n        [start, start + length]\n      end",
    "comment": "Returns the range bounds for just the annotation",
    "label": "",
    "id": "426"
  },
  {
    "raw_code": "def def_node_that_require_parentheses(node)\n        last_pair = node.parent.pairs.last\n        return unless last_pair.key.source == last_pair.value.source\n        return unless (dispatch_node = find_ancestor_method_dispatch_node(node))\n        return if dispatch_node.assignment_method?\n        return if dispatch_node.parenthesized?\n        return if dispatch_node.parent && parentheses?(dispatch_node.parent)\n        return if last_expression?(dispatch_node) && !method_dispatch_as_argument?(dispatch_node)\n\n        def_node = node.each_ancestor(:call, :super, :yield).first\n\n        DefNode.new(def_node) unless def_node && def_node.arguments.empty?\n      end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "427"
  },
  {
    "raw_code": "def find_ancestor_method_dispatch_node(node)\n        return unless (ancestor = node.parent.parent)\n        return unless ancestor.type?(:call, :super, :yield)\n        return if brackets?(ancestor)\n\n        ancestor\n      end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "428"
  },
  {
    "raw_code": "def aligned_with_preceding_equals_operator(token)\n        preceding_line_range = token.line.downto(1)\n\n        aligned_with_equals_sign(token, preceding_line_range)\n      end",
    "comment": "Allows alignment with a preceding operator that ends with an `=`, including assignment and comparison operators.",
    "label": "",
    "id": "429"
  },
  {
    "raw_code": "def aligned_with_subsequent_equals_operator(token)\n        subsequent_line_range = token.line.upto(processed_source.lines.length)\n\n        aligned_with_equals_sign(token, subsequent_line_range)\n      end",
    "comment": "Allows alignment with a subsequent operator that ends with an `=`, including assignment and comparison operators.",
    "label": "",
    "id": "430"
  },
  {
    "raw_code": "def relevant_assignment_lines(line_range)\n        result                        = []\n        original_line_indent          = processed_source.line_indentation(line_range.first)\n        relevant_line_indent_at_level = true\n\n        line_range.each do |line_number|\n          current_line_indent = processed_source.line_indentation(line_number)\n          blank_line          = processed_source.lines[line_number - 1].blank?\n\n          if (current_line_indent < original_line_indent && !blank_line) ||\n             (relevant_line_indent_at_level && blank_line)\n            break\n          end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity rubocop:disable Metrics/PerceivedComplexity, Metrics/MethodLength",
    "label": "",
    "id": "431"
  },
  {
    "raw_code": "def remove_equals_in_def(asgn_tokens, processed_source)\n        nodes = processed_source.ast.each_node(:optarg, :def)\n        eqls_to_ignore = nodes.with_object([]) do |node, arr|\n          loc = if node.def_type?\n                  node.loc.assignment if node.endless?\n                else\n                  node.loc.operator\n                end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity rubocop:enable Metrics/PerceivedComplexity, Metrics/MethodLength",
    "label": "",
    "id": "432"
  },
  {
    "raw_code": "def handle_orphaned_comma(corrector, node)\n          return unless only_closing_paren_before_comma?(node)\n\n          range = extend_range_for_heredoc(node, parens_range(node))\n          corrector.remove(range)\n\n          add_heredoc_comma(corrector, node)\n        end",
    "comment": "If removing parentheses leaves a comma on its own line, remove all the whitespace preceding it to prevent a syntax error.",
    "label": "",
    "id": "433"
  },
  {
    "raw_code": "def parens_range(node)\n          range_with_surrounding_space(\n            range: node.loc.end,\n            buffer: node.source_range.source_buffer,\n            side: :left,\n            newlines: true,\n            whitespace: true,\n            continuations: true\n          )\n        end",
    "comment": "Get a range for the closing parenthesis and all whitespace to the left of it",
    "label": "",
    "id": "434"
  },
  {
    "raw_code": "def extend_range_for_heredoc(node, range)\n          return range unless heredoc?(node)\n\n          comma_line = range_by_whole_lines(node.loc.end, buffer: node.source_range.source_buffer)\n          offset = comma_line.source.match(COMMA_REGEXP)[0]&.size || 0\n\n          range.adjust(end_pos: offset)\n        end",
    "comment": "If the node contains a heredoc, remove the comma too It'll be added back in the right place later",
    "label": "",
    "id": "435"
  },
  {
    "raw_code": "def add_heredoc_comma(corrector, node)\n          return unless heredoc?(node)\n\n          corrector.insert_after(node.child_nodes.last, ',')\n        end",
    "comment": "Add a comma back after the heredoc identifier",
    "label": "",
    "id": "436"
  },
  {
    "raw_code": "def delimited_string_literal?(node)\n          loc = node.location\n\n          loc.respond_to?(:begin) && loc.begin && loc.respond_to?(:end) && loc.end\n        end",
    "comment": "Some special kinds of string literals are not composed of literal characters between two delimiters: - The source map of `?a` responds to :begin and :end but its end is nil. - The source map of `__FILE__` responds to neither :begin nor :end.",
    "label": "",
    "id": "437"
  },
  {
    "raw_code": "def autocorrect(corrector, node, condition, replacement, guard)\n          corrector.replace(node.loc.keyword.join(condition.source_range), replacement)\n\n          if_branch = node.if_branch\n          else_branch = node.else_branch\n\n          corrector.replace(node.loc.begin, \"\\n\") if node.then?\n\n          if if_branch&.send_type? && heredoc?(if_branch.last_argument)\n            autocorrect_heredoc_argument(corrector, node, if_branch, else_branch, guard)\n          elsif else_branch&.send_type? && heredoc?(else_branch.last_argument)\n            autocorrect_heredoc_argument(corrector, node, else_branch, if_branch, guard)\n          else\n            corrector.remove(node.loc.end)\n            return unless node.else?\n\n            corrector.remove(node.loc.else)\n            corrector.remove(range_of_branch_to_remove(node, guard))\n          end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "438"
  },
  {
    "raw_code": "def heredoc?(argument)\n          argument.respond_to?(:heredoc?) && argument.heredoc?\n        end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "439"
  },
  {
    "raw_code": "def method_with_argument?(line_range, current_token, next_token)\n          return false unless ARGUMENT_TAKING_FLOW_TOKEN_TYPES.include?(current_token.type)\n          return false unless current_token.pos.overlaps?(line_range)\n\n          ARGUMENT_TYPES.include?(next_token.type)\n        end",
    "comment": "A method call without parentheses such as the following cannot remove `\\`:  do_something \\ argument",
    "label": "",
    "id": "440"
  },
  {
    "raw_code": "def on_hash(node)\n          return if node.pairs.empty? || node.pairs.any?(&:hash_rocket?)\n          return unless (parent = node.parent)\n          return unless parent.type?(:call, :kwsplat)\n          return unless mergeable?(parent)\n          return unless (kwsplat = node.each_ancestor(:kwsplat).first)\n          return if !node.braces? || allowed_double_splat_receiver?(kwsplat)\n\n          add_offense(kwsplat) do |corrector|\n            autocorrect(corrector, node, kwsplat)\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "441"
  },
  {
    "raw_code": "def on_lvasgn(node)\n          return unless (rhs = node.rhs)\n          return unless rhs.type?(:any_block, :call) && method_returning_self?(rhs.method_name)\n          return unless (receiver = rhs.receiver)\n\n          receiver_type = ASSIGNMENT_TYPE_TO_RECEIVER_TYPE[node.type]\n          return unless receiver.type == receiver_type && receiver.children.first == node.lhs\n\n          message = format(MSG, method_name: rhs.method_name)\n          add_offense(node.loc.operator, message: message) do |corrector|\n            corrector.replace(node, rhs.source)\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "442"
  },
  {
    "raw_code": "def check_branch(node)\n          return unless node\n\n          case node.type\n          when :case       then check_case_node(node)\n          when :case_match then check_case_match_node(node)\n          when :if         then check_if_node(node)\n          when :rescue, :resbody\n            check_rescue_node(node)\n          when :ensure then check_ensure_node(node)\n          when :begin, :kwbegin\n            check_begin_node(node)\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "443"
  },
  {
    "raw_code": "def check_case_node(node)\n          node.when_branches.each { |when_node| check_branch(when_node.body) }\n          check_branch(node.else_branch)\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "444"
  },
  {
    "raw_code": "def check_branch(node)\n          return unless node\n\n          case node.type\n          when :return then check_return_node(node)\n          when :case   then check_case_node(node)\n          when :case_match then check_case_match_node(node)\n          when :if     then check_if_node(node)\n          when :rescue then check_rescue_node(node)\n          when :resbody then check_resbody_node(node)\n          when :ensure then check_ensure_node(node)\n          when :begin, :kwbegin\n            check_begin_node(node)\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "445"
  },
  {
    "raw_code": "def check_return_node(node)\n          return if cop_config['AllowMultipleReturnValues'] && node.children.size > 1\n\n          add_offense(node.loc.keyword, message: message(node)) do |corrector|\n            if node.arguments?\n              correct_with_arguments(node, corrector)\n            else\n              correct_without_arguments(node, corrector)\n            end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "446"
  },
  {
    "raw_code": "def check_branches(node, branches)\n          # return if any branch is empty. An empty branch can be an `if`\n          # without an `else` or a branch that contains only comments.\n          return if branches.any?(&:nil?)\n\n          tails = branches.map { |branch| tail(branch) }\n          check_expressions(node, tails, :after_condition) if duplicated_expressions?(node, tails)\n\n          return if last_child_of_parent?(node) &&\n                    branches.any? { |branch| single_child_branch?(branch) }\n\n          heads = branches.map { |branch| head(branch) }\n\n          return unless duplicated_expressions?(node, heads)\n\n          condition_variable = assignable_condition_value(node)\n\n          head = heads.first\n          if head.respond_to?(:assignment?) && head.assignment?\n            # The `send` node is used instead of the `indexasgn` node, so `name` cannot be used.\n            # https://github.com/rubocop/rubocop-ast/blob/v1.29.0/lib/rubocop/ast/node/indexasgn_node.rb\n            #\n            # FIXME: It would be better to update `RuboCop::AST::OpAsgnNode` or its subclasses to\n            # handle `self.foo ||= value` as a solution, instead of using `head.node_parts[0].to_s`.\n            assigned_value = head.send_type? ? head.receiver.source : head.node_parts[0].to_s\n\n            return if condition_variable == assigned_value\n          end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "447"
  },
  {
    "raw_code": "def duplicated_expressions?(node, expressions)\n          unique_expressions = expressions.uniq\n          return false unless expressions.size >= 1 && unique_expressions.one?\n\n          unique_expression = unique_expressions.first\n          return true unless unique_expression&.assignment?\n\n          lhs = unique_expression.child_nodes.first\n          node.condition.child_nodes.none? { |n| n.source == lhs.source if n.variable? }\n        end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "448"
  },
  {
    "raw_code": "def check_expressions(node, expressions, insert_position)\n          return if expressions.any?(&:nil?)\n\n          inserted_expression = false\n\n          expressions.each do |expression|\n            add_offense(expression) do |corrector|\n              next if node.if_type? && (node.ternary? || node.then?)\n\n              range = range_by_whole_lines(expression.source_range, include_final_newline: true)\n              corrector.remove(range)\n              next if inserted_expression\n\n              if node.parent&.assignment?\n                correct_assignment(corrector, node, expression, insert_position)\n              else\n                correct_no_assignment(corrector, node, expression, insert_position)\n              end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength, Metrics/PerceivedComplexity",
    "label": "",
    "id": "449"
  },
  {
    "raw_code": "def correct_assignment(corrector, node, expression, insert_position)\n          if insert_position == :after_condition\n            assignment = node.parent.source_range.with(end_pos: node.source_range.begin_pos)\n            corrector.remove(assignment)\n            corrector.insert_after(node, \"\\n#{assignment.source}#{expression.source}\")\n          else\n            corrector.insert_before(node.parent, \"#{expression.source}\\n\")\n          end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength, Metrics/PerceivedComplexity",
    "label": "",
    "id": "450"
  },
  {
    "raw_code": "def expand_elses(branch)\n          if branch.nil?\n            [nil]\n          elsif branch.if_type?\n            _condition, elsif_branch, else_branch = *branch\n            expand_elses(else_branch).unshift(elsif_branch)\n          else\n            [branch]\n          end",
    "comment": "`elsif` branches show up in the if node as nested `else` branches. We need to recursively iterate over all `else` branches.",
    "label": "",
    "id": "451"
  },
  {
    "raw_code": "def on_send(node)\n          fix_exploded(node) || fix_compact(node)\n        end",
    "comment": "Switch `raise RuntimeError, 'message'` to `raise 'message'`, and `raise RuntimeError.new('message')` to `raise 'message'`.",
    "label": "",
    "id": "452"
  },
  {
    "raw_code": "def inspect_chain(node)\n          arguments = node.arguments.dup\n          end_range = node.source_range.end\n\n          while dig?(node = node.receiver)\n            begin_range = node.loc.selector\n            arguments.unshift(*node.arguments)\n            ignore_node(node)\n          end",
    "comment": "Walk up the method chain while the receiver is `dig` with arguments.",
    "label": "",
    "id": "453"
  },
  {
    "raw_code": "def partial_matched?(node, condition)\n          node.child_nodes == node.child_nodes & condition.child_nodes\n        end",
    "comment": "Avoid offending in the following cases: `ENV['key'] if ENV['key'] = x`",
    "label": "",
    "id": "454"
  },
  {
    "raw_code": "def message_chained_with_dot?(node)\n          return false if node.root?\n\n          parent = node.parent\n          return false if !parent.call_type? || parent.children.first != node\n\n          parent.dot? || parent.safe_navigation?\n        end",
    "comment": "Check if the node is a receiver and receives a message with dot syntax.",
    "label": "",
    "id": "455"
  },
  {
    "raw_code": "def allowable_use?(node)\n          used_as_flag?(node) || message_chained_with_dot?(node) || assigned?(node) || or_lhs?(node)\n        end",
    "comment": "The following are allowed cases:  - Used as a flag (e.g., `if ENV['X']` or `!ENV['X']`) because it simply checks whether the variable is set. - Receiving a message with dot syntax, e.g. `ENV['X'].nil?`. - `ENV['key']` assigned by logical AND/OR assignment. - `ENV['key']` is the LHS of a `||`.",
    "label": "",
    "id": "456"
  },
  {
    "raw_code": "def assigned?(node)\n          return false unless (parent = node.parent)&.assignment?\n\n          lhs, _method, _rhs = *parent\n          node == lhs\n        end",
    "comment": "The following are allowed cases:  - `ENV['key']` is a receiver of `||=`, e.g. `ENV['X'] ||= y`. - `ENV['key']` is a receiver of `&&=`, e.g. `ENV['X'] &&= y`.",
    "label": "",
    "id": "457"
  },
  {
    "raw_code": "def magic_comment_in_scope(node)\n            processed_source_till_node(node).reverse_each.find do |line|\n              MagicComment.parse(line).valid_shareable_constant_value?\n            end",
    "comment": "Identifies the most recent magic comment with valid shareable constant values that's in scope for this node",
    "label": "",
    "id": "458"
  },
  {
    "raw_code": "def autocorrect(corrector, node, begin_of_arguments)\n          arguments = node.arguments\n          joined_arguments = arguments.map(&:source).join(', ')\n          last_line_source_of_arguments = last_line_source_of_arguments(arguments)\n\n          if last_line_source_of_arguments.start_with?(')')\n            joined_arguments = \"#{joined_arguments}#{last_line_source_of_arguments}\"\n\n            corrector.remove(range_by_whole_lines(arguments.loc.end, include_final_newline: true))\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "459"
  },
  {
    "raw_code": "def last_line_source_of_arguments(arguments)\n          processed_source[arguments.last_line - 1].strip\n        end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "460"
  },
  {
    "raw_code": "def allowed_escape?(node, range)\n          escaped = range.source[(1..-1)]\n\n          # Inside a single-quoted string, escapes (except \\\\ and \\') do not have special meaning,\n          # and so are not redundant, as they are a literal backslash.\n          return true if interpolation_not_enabled?(node)\n\n          # Strictly speaking a few single-letter chars are currently unnecessary to \"escape\", e.g.\n          # d, but enumerating them is rather difficult, and their behavior could change over time\n          # with different versions of Ruby so that e.g. /\\d/ != /d/\n          return true if /[\\n\\\\[[:alnum:]]]/.match?(escaped[0])\n\n          return true if escaped[0] == ' ' && (percent_array_literal?(node) || node.heredoc?)\n\n          return true if disabling_interpolation?(range)\n          return true if delimiter?(node, escaped[0])\n\n          false\n        end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "461"
  },
  {
    "raw_code": "def interpolation_not_enabled?(node)\n          single_quoted?(node) ||\n            percent_w_literal?(node) ||\n            percent_q_literal?(node) ||\n            heredoc_with_disabled_interpolation?(node)\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "462"
  },
  {
    "raw_code": "def offense_range(node)\n          if reject_method_with_block_pass?(node) || grep_v_with_nil?(node)\n            range(node, node)\n          else\n            block_node = node.parent\n\n            return unless block_node&.block_type?\n            unless (args, receiver = reject_method?(block_node) || select_method?(block_node))\n              return\n            end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "463"
  },
  {
    "raw_code": "def to_enum_method?(node)\n          return false unless node.receiver.send_type?\n\n          TO_ENUM_METHODS.include?(node.receiver.method_name)\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "464"
  },
  {
    "raw_code": "def get_blocks(node, &block)\n          case node.type\n          when :block, :numblock, :itblock\n            yield node\n          when :send, :csend\n            # When a method has an argument which is another method with a block,\n            # that block needs braces, otherwise a syntax error will be introduced\n            # for subsequent arguments.\n            # Additionally, even without additional arguments, changing `{...}` to\n            # `do...end` will change the binding of the block to the outer method.\n            get_blocks(node.receiver, &block) if node.receiver\n            node.arguments.each { |argument| get_blocks(argument, &block) }\n          when :hash\n            # A hash which is passed as method argument may have no braces\n            # In that case, one of the K/V pairs could contain a block node\n            # which could change in meaning if `do...end` is replaced with `{...}`\n            return if node.braces?\n\n            node.each_child_node { |child| get_blocks(child, &block) }\n          when :pair\n            node.each_child_node { |child| get_blocks(child, &block) }\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "465"
  },
  {
    "raw_code": "def proper_block_style?(node)\n          return true if require_do_end?(node)\n          return special_method_proper_block_style?(node) if special_method?(node.method_name)\n\n          case style\n          when :line_count_based    then line_count_based_block_style?(node)\n          when :semantic            then semantic_block_style?(node)\n          when :braces_for_chaining then braces_for_chaining_style?(node)\n          when :always_braces       then braces_style?(node)\n          end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "466"
  },
  {
    "raw_code": "def derived_from_braceless_interpolation?(node)\n          %i[dstr regexp xstr].include?(node.parent&.type)\n        end",
    "comment": "@private @param [RuboCop::AST::Node] node @return [Boolean]",
    "label": "",
    "id": "467"
  },
  {
    "raw_code": "def format_message(node:, preferred_expression:)\n          original_expression = original_expression_of(node)\n          format(\n            MESSAGE_FORMAT,\n            original_expression: original_expression,\n            preferred_expression: preferred_expression\n          )\n        end",
    "comment": "@private @param [RuboCop::AST::Node] node @param [String] preferred_expression @return [String]",
    "label": "",
    "id": "468"
  },
  {
    "raw_code": "def original_expression_of(node)\n          first = node.to_a.first\n          if first.is_a?(::Integer)\n            \"$#{first}\"\n          else\n            first.to_s\n          end",
    "comment": "@private @param [RuboCop::AST::Node] node @return [String]",
    "label": "",
    "id": "469"
  },
  {
    "raw_code": "def preferred_expression_to(node)\n          first = node.to_a.first\n          case first\n          when ::Integer\n            \"Regexp.last_match(#{first})\"\n          when :$&, :$MATCH\n            'Regexp.last_match(0)'\n          when :$`, :$PREMATCH\n            'Regexp.last_match.pre_match'\n          when :$', :$POSTMATCH\n            'Regexp.last_match.post_match'\n          when :$+, :$LAST_PAREN_MATCH\n            'Regexp.last_match(-1)'\n          end",
    "comment": "@private @param [RuboCop::AST::Node] node @return [String, nil]",
    "label": "",
    "id": "470"
  },
  {
    "raw_code": "def preferred_expression_to_node_with_constant_prefix(node)\n          expression = preferred_expression_to(node)\n          return unless expression\n\n          \"#{constant_prefix(node)}#{expression}\"\n        end",
    "comment": "@private @param [RuboCop::AST::Node] node @return [String, nil]",
    "label": "",
    "id": "471"
  },
  {
    "raw_code": "def constant_prefix(node)\n          if node.each_ancestor(:class, :module).any?\n            '::'\n          else\n            ''\n          end",
    "comment": "@private @param [RuboCop::AST::Node] node @return [String]",
    "label": "",
    "id": "472"
  },
  {
    "raw_code": "def on_back_ref_or_gvar_or_nth_ref(node)\n          preferred_expression = preferred_expression_to_node_with_constant_prefix(node)\n          return unless preferred_expression\n\n          add_offense(\n            node,\n            message: format_message(node: node, preferred_expression: preferred_expression)\n          ) do |corrector|\n            if derived_from_braceless_interpolation?(node)\n              preferred_expression = \"{#{preferred_expression}}\"\n            end",
    "comment": "@private @param [RuboCop::AST::Node] node",
    "label": "",
    "id": "473"
  },
  {
    "raw_code": "def on_send(node)\n          return unless node.receiver\n\n          style_check?(node) do\n            add_offense(node.loc.selector) do |corrector|\n              if prefer_comparison?\n                range = node.loc.dot.join(node.loc.selector.end)\n                corrector.replace(range, ' == nil')\n              else\n                range = node.receiver.source_range.end.join(node.source_range.end)\n                corrector.replace(range, '.nil?')\n              end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "474"
  },
  {
    "raw_code": "def check_unused_block_args(node, key, value)\n          return if node.body.nil?\n\n          value_unused = unused_block_arg_exist?(node, value)\n          key_unused = unused_block_arg_exist?(node, key)\n          return if value_unused && key_unused\n\n          if value_unused\n            message = message('each_key', node.method_name, value.source)\n            unused_range = key.source_range.end.join(value.source_range.end)\n\n            register_each_args_offense(node, message, 'each_key', unused_range)\n          elsif key_unused\n            message = message('each_value', node.method_name, key.source)\n            unused_range = key.source_range.begin.join(value.source_range.begin)\n\n            register_each_args_offense(node, message, 'each_value', unused_range)\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "475"
  },
  {
    "raw_code": "def on_block_pass(node)\n          kv_each_with_block_pass(node.parent) do |target, method|\n            register_kv_with_block_pass_offense(node, target, method)\n          end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "476"
  },
  {
    "raw_code": "def format_list(items)\n          items.join('` or `')\n        end",
    "comment": "For now, we assume that lists are 2 items or less. Easy grammar!",
    "label": "",
    "id": "477"
  },
  {
    "raw_code": "def preferred_argument(regexp_node)\n          new_argument = replacement(regexp_node)\n\n          if new_argument.include?('\"')\n            new_argument.gsub!(\"'\", \"\\\\\\\\'\")\n            new_argument.gsub!('\\\"', '\"')\n            quote = \"'\"\n          elsif new_argument.include?(\"\\\\'\")\n            quote = \"'\"\n          elsif new_argument.include?('\\'')\n            new_argument.gsub!(\"'\", \"\\\\\\\\'\")\n            quote = \"'\"\n          elsif new_argument.include?('\\\\')\n            quote = '\"'\n          else\n            quote = enforce_double_quotes? ? '\"' : \"'\"\n          end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "478"
  },
  {
    "raw_code": "def replacement(regexp_node)\n          regexp_content = regexp_node.content\n          stack = []\n          chars = regexp_content.chars.each_with_object([]) do |char, strings|\n            if stack.empty? && char == '\\\\'\n              stack.push(char)\n            else\n              strings << \"#{stack.pop}#{char}\"\n            end",
    "comment": "rubocop:enable Metrics/MethodLength",
    "label": "",
    "id": "479"
  },
  {
    "raw_code": "def opposite_style_detected; end\n\n        # Dummy implementation of method in ConfigurableEnforcedStyle that is\n        # called from StringHelp.\n        def correct_style_detected; end\n\n        private\n\n        def allowed_addresses\n          allowed_addresses = cop_config['AllowedAddresses']\n          Array(allowed_addresses).map(&:downcase)\n        end\n\n        def potential_ip?(str)\n          # If the string is too long, it can't be an IP\n          return false if too_long?(str)\n\n          # If the string doesn't start with a colon or hexadecimal char,\n          # we know it's not an IP address\n          starts_with_hex_or_colon?(str)\n        end\n\n        def too_long?(str)\n          str.size > IPV6_MAX_SIZE\n        end\n\n        def starts_with_hex_or_colon?(str)\n          first_char = str[0].ord\n          (48..58).cover?(first_char) || (65..70).cover?(first_char) || (97..102).cover?(first_char)\n        end\n      end\n    end",
    "comment": "Dummy implementation of method in ConfigurableEnforcedStyle that is called from StringHelp.",
    "label": "",
    "id": "480"
  },
  {
    "raw_code": "def on_if(node)\n          return unless if_else?(node)\n          return unless (condition = unwrap_begin_nodes(node.condition))\n          return if double_negation?(condition) || !negated_condition?(condition)\n          return unless condition.arguments.size < 2\n\n          message = message(node)\n          add_offense(node, message: message) do |corrector|\n            unless corrected_ancestor?(node)\n              correct_negated_condition(corrector, condition)\n              swap_branches(corrector, node)\n\n              @corrected_nodes ||= Set.new.compare_by_identity\n              @corrected_nodes.add(node)\n            end",
    "comment": "rubocop:disable Metrics/AbcSize,Metrics/CyclomaticComplexity",
    "label": "",
    "id": "481"
  },
  {
    "raw_code": "def if_range(node)\n          if node.ternary?\n            node.if_branch\n          else\n            range_between(node.condition.source_range.end_pos, node.loc.else.begin_pos)\n          end",
    "comment": "Collect the entire if branch, including whitespace and comments",
    "label": "",
    "id": "482"
  },
  {
    "raw_code": "def else_range(node)\n          if node.ternary?\n            node.else_branch\n          else\n            range_between(node.loc.else.end_pos, node.loc.end.begin_pos)\n          end",
    "comment": "Collect the entire else branch, including whitespace and comments",
    "label": "",
    "id": "483"
  },
  {
    "raw_code": "def correct_rescue_block(corrector, node, parenthesized)\n          operation = node.body\n\n          node_indentation, node_offset = indentation_and_offset(node, parenthesized)\n\n          corrector.wrap(operation, '[', ']') if operation.array_type? && !operation.bracketed?\n          corrector.remove(range_between(operation.source_range.end_pos, node.source_range.end_pos))\n          corrector.insert_before(operation, \"begin\\n#{node_indentation}\")\n          corrector.insert_after(heredoc_end(operation) || operation, <<~RESCUE_CLAUSE.chop)\n\n            #{node_offset}rescue\n            #{node_indentation}#{node.resbody_branches.first.body.source}\n            #{node_offset}end\n          RESCUE_CLAUSE\n        end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "484"
  },
  {
    "raw_code": "def indentation_and_offset(node, parenthesized)\n          node_indentation = indentation(node)\n          node_offset = offset(node)\n          if parenthesized\n            node_indentation = node_indentation[0...-1]\n            node_offset = node_offset[0...-1]\n          end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "485"
  },
  {
    "raw_code": "def format_int_part(int_part)\n          int_part = Integer(int_part)\n          formatted_int = int_part.abs.to_s.reverse.gsub(/...(?=.)/, '\\&_').reverse\n          formatted_int.insert(0, '-') if int_part.negative?\n          formatted_int\n        end",
    "comment": "@param int_part [String]",
    "label": "",
    "id": "486"
  },
  {
    "raw_code": "def find_target(node)\n          case node.type\n          when :begin\n            find_target(node.children.first)\n          when :or\n            find_target(node.lhs)\n          when :match_with_lvasgn\n            lhs, rhs = *node # rubocop:disable InternalAffairs/NodeDestructuring\n            if lhs.regexp_type?\n              rhs\n            elsif rhs.regexp_type?\n              lhs\n            end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "487"
  },
  {
    "raw_code": "def find_target_in_send_node(node)\n          case node.method_name\n          when :is_a?\n            node.receiver\n          when :==, :eql?, :equal?\n            find_target_in_equality_node(node)\n          when :===\n            node.first_argument\n          when :include?, :cover?\n            find_target_in_include_or_cover_node(node)\n          when :match, :match?, :=~\n            find_target_in_match_node(node)\n          end",
    "comment": "rubocop:enable Metrics/MethodLength",
    "label": "",
    "id": "488"
  },
  {
    "raw_code": "def condition_from_send_node(node, target)\n          case node.method_name\n          when :is_a?\n            node.first_argument if node.receiver == target\n          when :==, :eql?, :equal?\n            condition_from_equality_node(node, target)\n          when :=~, :match, :match?\n            condition_from_match_node(node, target)\n          when :===\n            node.receiver if node.first_argument == target\n          when :include?, :cover?\n            condition_from_include_or_cover_node(node, target)\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "489"
  },
  {
    "raw_code": "def condition_from_equality_node(node, target)\n          condition = condition_from_binary_op(node.receiver, node.first_argument, target)\n          condition if condition && !class_reference?(condition)\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "490"
  },
  {
    "raw_code": "def regexp_with_working_captures?(node)\n          case node.type\n          when :match_with_lvasgn\n            lhs, _rhs = *node # rubocop:disable InternalAffairs/NodeDestructuring\n            node.loc.selector.source == '=~' && regexp_with_named_captures?(lhs)\n          when :send\n            node.method?(:match) &&\n              [node.receiver, node.first_argument].any? { |n| regexp_with_named_captures?(n) }\n          end",
    "comment": "Named captures work with `=~` (if regexp is on lhs) and with `match` (both sides)",
    "label": "",
    "id": "491"
  },
  {
    "raw_code": "def groupable_accessor?(node)\n          return true unless (previous_expression = node.left_siblings.last)\n\n          # Accessors with Sorbet `sig { ... }` blocks shouldn't be groupable.\n          if previous_expression.block_type?\n            previous_expression.child_nodes.each do |child_node|\n              break previous_expression = child_node if child_node.send_type?\n            end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "492"
  },
  {
    "raw_code": "def class_send_elements(class_node)\n          class_def = class_node.body\n\n          if !class_def || class_def.def_type?\n            []\n          elsif class_def.send_type?\n            [class_def]\n          else\n            class_def.each_child_node(:send).to_a\n          end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "493"
  },
  {
    "raw_code": "def skip_for_grouping?(node)\n          node.right_siblings.any?(&:casgn_type?) &&\n            node.right_siblings.any? { |n| n.send_type? && groupable_sibling_accessor?(node, n) }\n        end",
    "comment": "Group after constants",
    "label": "",
    "id": "494"
  },
  {
    "raw_code": "def on_if(node)\n          return unless node.modifier_form? && node.body.if_type?\n\n          add_offense(node.loc.keyword, message: format(MSG, keyword: node.keyword)) do |corrector|\n            corrector.wrap(node.if_branch, \"#{node.keyword} #{node.condition.source}\\n\", \"\\nend\")\n            corrector.remove(node.if_branch.source_range.end.join(node.condition.source_range.end))\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "495"
  },
  {
    "raw_code": "def expand_elses(branch)\n          elsif_branches = expand_elsif(branch)\n          else_branch = elsif_branches.any? ? elsif_branches.pop : branch\n          [elsif_branches, else_branch]\n        end",
    "comment": "`elsif` branches show up in the `node` as an `else`. We need to recursively iterate over all `else` branches and consider all but the last `node` an `elsif` branch and consider the last `node` the actual `else` branch.",
    "label": "",
    "id": "496"
  },
  {
    "raw_code": "def expand_when_branches(when_branches)\n          when_branches.map(&:body)\n        end",
    "comment": "`when` nodes contain the entire branch including the condition. We only need the contents of the branch, not the condition.",
    "label": "",
    "id": "497"
  },
  {
    "raw_code": "def correction_exceeds_line_limit?(node, branches)\n          return false unless line_length_cop_enabled?\n\n          assignment = lhs(tail(branches[0]))\n\n          longest_line_exceeds_line_limit?(node, assignment)\n        end",
    "comment": "If `Layout/LineLength` is enabled, we do not want to introduce an offense by autocorrecting this cop. Find the max configured line length. Find the longest line of condition. Remove the assignment from lines that contain the offending assignment because after correcting, this will not be on the line anymore. Check if the length of the longest line + the length of the corrected assignment is greater than the max configured line length",
    "label": "",
    "id": "498"
  },
  {
    "raw_code": "def remove_whitespace_in_branches(corrector, branch, condition, column)\n          branch.each_node do |child|\n            next if child.source_range.nil?\n            next if child.parent.dstr_type?\n\n            white_space = white_space_range(child, column)\n            corrector.remove(white_space) if white_space.source.strip.empty?\n          end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity",
    "label": "",
    "id": "499"
  },
  {
    "raw_code": "def same_line?(node1, node2)\n          RuboCop::Cop::Util.same_line?(node1, node2)\n        end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity",
    "label": "",
    "id": "500"
  },
  {
    "raw_code": "def message_text(style)\n          {\n            annotated: 'annotated tokens (like `%<foo>s`)',\n            template: 'template tokens (like `%{foo}`)',\n            unannotated: 'unannotated tokens (like `%s`)'\n          }[style]\n        end",
    "comment": "rubocop:disable Style/FormatStringToken",
    "label": "",
    "id": "501"
  },
  {
    "raw_code": "def tokens(str_node, &block)\n          return if str_node.source == '__FILE__'\n\n          token_ranges(str_contents(str_node.loc), &block)\n        end",
    "comment": "rubocop:enable Style/FormatStringToken",
    "label": "",
    "id": "502"
  },
  {
    "raw_code": "def range_size(range_node)\n          vals = range_node.to_a\n          return :unknown unless vals.all? { |val| val.nil? || val.int_type? }\n\n          low, high = vals.map { |val| val.nil? ? 0 : val.children[0] }\n          return :unknown unless low.zero? && high >= 0\n\n          case range_node.type\n          when :erange\n            (low...high).size\n          when :irange\n            (low..high).size\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "503"
  },
  {
    "raw_code": "def source_range(shuffle_node, node)\n          shuffle_node.loc.selector.join(node.source_range.end)\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "504"
  },
  {
    "raw_code": "def on_send(node)\n          return unless node.arguments.size == 1 && node.first_argument.int_type?\n\n          value = node.first_argument.value\n          return unless [0, -1].include?(value)\n\n          node = innermost_braces_node(node)\n          return if node.parent && brace_method?(node.parent)\n\n          preferred = (value.zero? ? 'first' : 'last')\n          offense_range = find_offense_range(node)\n\n          add_offense(offense_range, message: format(MSG, preferred: preferred)) do |corrector|\n            corrector.replace(offense_range, preferred_value(node, preferred))\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "505"
  },
  {
    "raw_code": "def on_send(node)\n          return if allow_send? && !node.method?(:public_send)\n          return unless (first_argument = node.first_argument)\n          return unless first_argument.type?(*STATIC_METHOD_NAME_NODE_TYPES)\n\n          offense_range = offense_range(node)\n          method_name = first_argument.value\n          return if !METHOD_NAME_PATTERN.match?(method_name) || RESERVED_WORDS.include?(method_name)\n\n          add_offense(offense_range, message: format(MSG, method_name: method_name)) do |corrector|\n            if node.arguments.one?\n              corrector.replace(offense_range, method_name)\n            else\n              corrector.replace(node.loc.selector, method_name)\n              corrector.remove(removal_argument_range(first_argument, node.arguments[1]))\n            end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "506"
  },
  {
    "raw_code": "def on_block(node)\n          symbol_proc?(node) do |dispatch_node, arguments_node, method_name|\n            if active_support_extensions_enabled?\n              return if proc_node?(dispatch_node)\n              return if LAMBDA_OR_PROC.include?(dispatch_node.method_name)\n            end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "507"
  },
  {
    "raw_code": "def unsafe_hash_usage?(node)\n          node.receiver&.hash_type? && %i[reject select].include?(node.method_name)\n        end",
    "comment": "See: https://github.com/rubocop/rubocop/issues/10864",
    "label": "",
    "id": "508"
  },
  {
    "raw_code": "def on_regexp(node); end\n\n        private\n\n        def message(_node)\n          # single_quotes -> single-quoted\n          kind = style.to_s.sub(/_(.*)s/, '-\\1d')\n\n          \"Prefer #{kind} strings inside interpolations.\"\n        end\n\n        def offense?(node)\n          # If it's not a string within an interpolation, then it's not an\n          # offense for this cop.\n          return false unless inside_interpolation?(node)\n\n          wrong_quotes?(node)\n        end\n      end",
    "comment": "Cop classes that include the StringHelp module usually ignore regexp nodes. Not so for this cop, which is why we override the on_regexp definition with an empty one.",
    "label": "",
    "id": "509"
  },
  {
    "raw_code": "def arguments_identical?(def_node, super_node, def_args, super_args)\n          return false if argument_list_size_differs?(def_args, super_args, super_node)\n\n          def_args.zip(super_args).each do |def_arg, super_arg|\n            next if positional_arg_same?(def_arg, super_arg)\n            next if positional_rest_arg_same(def_arg, super_arg)\n            next if keyword_arg_same?(def_arg, super_arg)\n            next if keyword_rest_arg_same?(def_arg, super_arg)\n            next if block_arg_same?(def_node, super_node, def_arg, super_arg)\n            next if forward_arg_same?(def_arg, super_arg)\n\n            return false\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "510"
  },
  {
    "raw_code": "def argument_list_size_differs?(def_args, super_args, super_node)\n          # If the def node has a block argument and the super node has an explicit block,\n          # the number of arguments is the same, so ignore the def node block arg.\n          def_args_size = def_args.size\n          def_args_size -= 1 if def_args.any?(&:blockarg_type?) && block_sends_to_super?(super_node)\n\n          def_args_size != super_args.size\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "511"
  },
  {
    "raw_code": "def block_reassigned?(def_node, block_arg_name)\n          def_node.each_node(*ASSIGN_TYPES).any? do |assign_node|\n            # TODO: Since `Symbol#name` is supported from Ruby 3.0, the inheritance check for\n            # `AST::Node` can be removed when requiring Ruby 3.0+.\n            lhs = assign_node.node_parts[0]\n            next if lhs.is_a?(AST::Node) && !lhs.respond_to?(:name)\n\n            assign_node.name == block_arg_name\n          end",
    "comment": "Reassigning the block argument will still pass along the original block to super https://bugs.ruby-lang.org/issues/20505",
    "label": "",
    "id": "512"
  },
  {
    "raw_code": "def on_block(node)\n          return if !node.single_line? || node.braces?\n          return if single_line_blocks_preferred? && suitable_as_single_line?(node)\n\n          add_offense(node) do |corrector|\n            corrector.insert_after(do_line(node), \"\\n\")\n\n            node_body = node.body\n\n            if node_body.respond_to?(:heredoc?) && node_body.heredoc?\n              corrector.remove(node.loc.end)\n              corrector.insert_after(node_body.loc.heredoc_end, \"\\nend\")\n            else\n              corrector.insert_before(node.loc.end, \"\\n\")\n            end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "513"
  },
  {
    "raw_code": "def on_interpolation(node)\n          node.each_child_node(:if) do |child_node|\n            if style == :trailing_conditional\n              if empty_if_outcome?(child_node)\n                ternary_style_autocorrect(child_node, child_node.else_branch.source, 'unless')\n              end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/MethodLength, Metrics/PerceivedComplexity",
    "label": "",
    "id": "514"
  },
  {
    "raw_code": "def possible_class_hierarchy_check?(lhs, rhs, method)\n          CLASS_COMPARISON_METHODS.include?(method) &&\n            (camel_case_constant?(lhs) || (rhs.size == 1 && camel_case_constant?(rhs.first)))\n        end",
    "comment": "When comparing classes, `!(Integer < Numeric)` is not the same as `Integer > Numeric`.",
    "label": "",
    "id": "515"
  },
  {
    "raw_code": "def accumulator_param_assigned_to?(body, args)\n          first_arg, = *args\n          accumulator_var, = *first_arg\n\n          body.each_descendant.any? do |n|\n            next unless n.assignment?\n\n            lhs, _rhs = *n\n            lhs.equal?(accumulator_var)\n          end",
    "comment": "if the accumulator parameter is assigned to in the block, then we can't convert to each_with_object",
    "label": "",
    "id": "516"
  },
  {
    "raw_code": "def reindent(lines, node, corrector)\n          range  = node.source_range\n          buffer = range.source_buffer\n\n          target_indent = range.source_line =~ /\\S/\n          delta = actual_indent(lines, buffer) - target_indent\n          lines.each { |lineno| reindent_line(corrector, lineno, delta, buffer) }\n        end",
    "comment": "Adjust indentation of `lines` to match `node`",
    "label": "",
    "id": "517"
  },
  {
    "raw_code": "def lhs_range_to_remove(term)\n          source = @processed_source.buffer.source\n\n          pos = term.source_range.end_pos\n          pos += 1 until source[..pos].end_with?(*OPERATORS)\n\n          range_with_surrounding_space(\n            range: term.source_range.with(end_pos: pos + 1),\n            side: :right,\n            newlines: false\n          )\n        end",
    "comment": "If the redundant `defined?` node is the LHS of an `and` node, the term as well as the subsequent `&&`/`and` operator will be removed.",
    "label": "",
    "id": "518"
  },
  {
    "raw_code": "def rhs_range_to_remove(term)\n          source = @processed_source.buffer.source\n\n          pos = term.source_range.begin_pos\n          pos -= 1 until source[pos, 3].start_with?(*OPERATORS)\n\n          range_with_surrounding_space(\n            range: term.source_range.with(begin_pos: pos - 1),\n            side: :right,\n            newlines: false\n          )\n        end",
    "comment": "If the redundant `defined?` node is the RHS of an `and` node, the term as well as the preceding `&&`/`and` operator will be removed.",
    "label": "",
    "id": "519"
  },
  {
    "raw_code": "def on_send(node)\n          return if target_ruby_version < 2.6 && node.method?(:filter)\n          return unless (block_node = node.block_node)\n          return if block_node.body&.begin_type?\n          return if receiver_allowed?(block_node.receiver)\n          return unless (regexp_method_send_node = extract_send_node(block_node))\n          return if match_predicate_without_receiver?(regexp_method_send_node)\n\n          replacement = replacement(regexp_method_send_node, node)\n          return if target_ruby_version <= 2.2 && replacement == 'grep_v'\n\n          regexp = find_regexp(regexp_method_send_node, block_node)\n\n          register_offense(node, block_node, regexp, replacement)\n        end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "520"
  },
  {
    "raw_code": "def find_offense_message(begin_node, node)\n          return 'a keyword' if keyword_with_redundant_parentheses?(node)\n          return 'a literal' if node.literal? && disallowed_literal?(begin_node, node)\n          return 'a variable' if node.variable?\n          return 'a constant' if node.const_type?\n          if node.assignment? && (begin_node.parent.nil? || begin_node.parent.begin_type?)\n            return 'an assignment'\n          end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength, Metrics/PerceivedComplexity",
    "label": "",
    "id": "521"
  },
  {
    "raw_code": "def scope_type(node)\n          while (parent = node.parent)\n            case parent.type\n            when :class, :module\n              return :lexical\n            when :def, :defs\n              return :dynamic\n            when :block\n              return :instance_eval if parent.method?(:instance_eval)\n\n              return :dynamic\n            end",
    "comment": "In this expression, will `self` be the same as the innermost enclosing class or module block (:lexical)? Or will it be something else (:dynamic)? If we're in an instance_eval block, return that.",
    "label": "",
    "id": "522"
  },
  {
    "raw_code": "def methods_accepting_symbol\n          Array(cop_config['MethodsAcceptingSymbol'])\n        end",
    "comment": "Some enumerable methods accept a bare symbol (ie. _not_ Symbol#to_proc) instead of a block.",
    "label": "",
    "id": "523"
  },
  {
    "raw_code": "def on_send(node)\n          return unless !node.arguments? && node.parenthesized?\n          return if ineligible_node?(node)\n          return if default_argument?(node)\n          return if allowed_method_name?(node.method_name)\n          return if same_name_assignment?(node)\n          return if parenthesized_it_method_in_block?(node)\n\n          register_offense(node)\n        end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "524"
  },
  {
    "raw_code": "def parenthesized_it_method_in_block?(node)\n          return false unless node.method?(:it)\n          return false unless (block_node = node.each_ancestor(:block).first)\n          return false unless block_node.arguments.empty_and_without_delimiters?\n\n          !node.receiver && node.arguments.empty? && !node.block_literal?\n        end",
    "comment": "Respects `Lint/ItWithoutArgumentsInBlock` cop and the following Ruby 3.3's warning:  $ ruby -e '0.times { begin; it; end }' -e:1: warning: `it` calls without arguments will refer to the first block param in Ruby 3.4; use it() or self.it ",
    "label": "",
    "id": "525"
  },
  {
    "raw_code": "def semicolon_position(tokens)\n          if tokens.last.semicolon?\n            -1\n          elsif tokens.first.semicolon?\n            0\n          elsif exist_semicolon_before_right_curly_brace?(tokens)\n            -3\n          elsif exist_semicolon_after_left_curly_brace?(tokens) ||\n                exist_semicolon_after_left_string_interpolation_brace?(tokens)\n            2\n          elsif exist_semicolon_after_left_lambda_curly_brace?(tokens)\n            3\n          elsif exist_semicolon_before_right_string_interpolation_brace?(tokens)\n            -4\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "526"
  },
  {
    "raw_code": "def exist_semicolon_before_right_curly_brace?(tokens)\n          tokens[-2]&.right_curly_brace? && tokens[-3]&.semicolon?\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "527"
  },
  {
    "raw_code": "def on_if(node)\n          return if node.ternary? || node.unless?\n\n          else_branch = node.else_branch\n\n          return unless else_branch&.if_type? && else_branch.if?\n          return if allow_if_modifier_in_else_branch?(else_branch)\n\n          add_offense(else_branch.loc.keyword) do |corrector|\n            next if part_of_ignored_node?(node)\n\n            autocorrect(corrector, else_branch)\n            ignore_node(node)\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "528"
  },
  {
    "raw_code": "def on_send(node)\n          return unless (dot = node.loc.dot)\n          return if node.receiver.const_type? || !node.arguments.one?\n\n          return unless (rhs = node.first_argument)\n          return if method_call_with_parenthesized_arg?(rhs)\n          return if invalid_syntax_argument?(rhs)\n\n          add_offense(dot) do |corrector|\n            wrap_in_parentheses_if_chained(corrector, node)\n            corrector.replace(dot, ' ')\n\n            selector = node.loc.selector\n            corrector.insert_after(selector, ' ') if insert_space_after?(node)\n          end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity",
    "label": "",
    "id": "529"
  },
  {
    "raw_code": "def method_call_with_parenthesized_arg?(argument)\n          return false unless argument.parent.parent&.send_type?\n\n          argument.children.first && argument.parent.parenthesized?\n        end",
    "comment": "Checks for an acceptable case of `foo.+(bar).baz`.",
    "label": "",
    "id": "530"
  },
  {
    "raw_code": "def require_then?(in_pattern_node)\n          return true unless in_pattern_node.pattern.single_line?\n          return false unless in_pattern_node.body\n\n          same_line?(in_pattern_node, in_pattern_node.body)\n        end",
    "comment": "Requires `then` for write `in` and its body on the same line.",
    "label": "",
    "id": "531"
  },
  {
    "raw_code": "def correct_not(node, receiver, corrector)\n          if node.prefix_bang?\n            return unless receiver.send_type?\n\n            correct_send(receiver, corrector)\n          elsif node.prefix_not?\n            correct_other(node, corrector)\n          else\n            raise 'unrecognized unary negation operator'\n          end",
    "comment": "! is a special case: 'x and !obj.method arg' can be autocorrected if we recurse down a level and add parens to 'obj.method arg' however, 'not x' also parses as (send x :!)",
    "label": "",
    "id": "532"
  },
  {
    "raw_code": "def directives\n            @directives ||= begin\n              matches = []\n\n              text.scan(DIRECTIVE_REGEXP) do\n                offset = Regexp.last_match.offset(0)\n                matches << loc.expression.adjust(begin_pos: offset.first)\n                              .with(end_pos: loc.expression.begin_pos + offset.last)\n              end",
    "comment": "A magic comment can contain one directive (normal style) or multiple directives (emacs style)",
    "label": "",
    "id": "533"
  },
  {
    "raw_code": "def values\n            @values ||= begin\n              matches = []\n\n              text.scan(VALUE_REGEXP) do\n                offset = Regexp.last_match.offset(1)\n                matches << loc.expression.adjust(begin_pos: offset.first)\n                              .with(end_pos: loc.expression.begin_pos + offset.last)\n              end",
    "comment": "A magic comment can contain one value (normal style) or multiple directives (emacs style)",
    "label": "",
    "id": "534"
  },
  {
    "raw_code": "def on_send(node)\n          return if node.arguments.empty?\n          return unless node.arguments.all?(&:array_type?)\n\n          offense = offense_range(node)\n          current = offense.source\n\n          if (use_percent_literal = node.arguments.any?(&:percent_literal?))\n            if percent_literals_includes_only_basic_literals?(node)\n              prefer = preferred_method(node)\n              message = format(MSG, prefer: prefer, current: current)\n            else\n              message = format(MSG_FOR_PERCENT_LITERALS, current: current)\n            end",
    "comment": "rubocop:disable Metrics",
    "label": "",
    "id": "535"
  },
  {
    "raw_code": "def accessor_start(node)\n          if node.loc.dot\n            node.loc.dot.begin_pos\n          else\n            node.loc.selector.begin_pos\n          end",
    "comment": "This gets the start of the accessor whether it has a dot (e.g. `.first`) or doesn't (e.g. `[0]`)",
    "label": "",
    "id": "536"
  },
  {
    "raw_code": "def restore_removed_comments(corrector, offense_range, node, first_child)\n          comments_range = range_between(offense_range.end_pos, first_child.source_range.begin_pos)\n          comments = comments_range.source\n\n          corrector.insert_before(node.parent, comments) unless comments.blank?\n        end",
    "comment": "Restore comments that occur between \"begin\" and \"first_child\". These comments will be moved to above the assignment line.",
    "label": "",
    "id": "537"
  },
  {
    "raw_code": "def add_forward_all_offenses(node, send_classifications, forwardable_args)\n          rest_arg, kwrest_arg, block_arg = *forwardable_args\n          registered_block_arg_offense = false\n\n          send_classifications.each do |send_node, c, forward_rest, forward_kwrest, forward_block_arg| # rubocop:disable Layout/LineLength\n            if !forward_rest && !forward_kwrest && c != :all_anonymous\n              if allow_anonymous_forwarding_in_block?(forward_block_arg)\n                register_forward_block_arg_offense(!forward_rest, node.arguments, block_arg)\n                register_forward_block_arg_offense(!forward_rest, send_node, forward_block_arg)\n              end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength, Metrics/PerceivedComplexity",
    "label": "",
    "id": "538"
  },
  {
    "raw_code": "def forward_all_first_argument(node)\n          node.arguments.reverse_each.find(&:forwarded_restarg_type?)\n        end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength, Metrics/PerceivedComplexity",
    "label": "",
    "id": "539"
  },
  {
    "raw_code": "def add_post_ruby_32_offenses(def_node, send_classifications, forwardable_args)\n          return unless use_anonymous_forwarding?\n          return unless all_forwarding_offenses_correctable?(send_classifications)\n\n          rest_arg, kwrest_arg, block_arg = *forwardable_args\n\n          send_classifications.each do |send_node, _c, forward_rest, forward_kwrest, forward_block_arg| # rubocop:disable Layout/LineLength\n            if allow_anonymous_forwarding_in_block?(forward_rest)\n              register_forward_args_offense(def_node.arguments, rest_arg)\n              register_forward_args_offense(send_node, forward_rest)\n            end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/MethodLength",
    "label": "",
    "id": "540"
  },
  {
    "raw_code": "def non_splat_or_block_pass_lvar_references(body)\n          body.each_descendant(:lvar, :lvasgn).filter_map do |lvar|\n            parent = lvar.parent\n\n            next if lvar.lvar_type? && FORWARDING_LVAR_TYPES.include?(parent.type)\n\n            lvar.children.first\n          end.uniq\n        end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/MethodLength",
    "label": "",
    "id": "541"
  },
  {
    "raw_code": "def all_forwarding_offenses_correctable?(send_classifications)\n          return true if target_ruby_version >= 3.4\n\n          send_classifications.none? do |send_node, *|\n            send_node.each_ancestor(:any_block).any?\n          end",
    "comment": "Checks if forwarding is uses both in blocks and outside of blocks. On Ruby 3.3.0, anonymous block forwarding in blocks can be is a syntax error, so we only want to register an offense if we can change all occurrences.",
    "label": "",
    "id": "542"
  },
  {
    "raw_code": "def allow_anonymous_forwarding_in_block?(node)\n          return false unless node\n          return true if target_ruby_version >= 3.4\n\n          node.each_ancestor(:any_block).none?\n        end",
    "comment": "Ruby 3.3.0 had a bug where accessing an anonymous block argument inside of a block was a syntax error in unambiguous cases: https://bugs.ruby-lang.org/issues/20090 We disallow this also for earlier Ruby versions so that code is forwards compatible.",
    "label": "",
    "id": "543"
  },
  {
    "raw_code": "def can_forward_all?\n            return false if any_arg_referenced?\n            return false if ruby_30_or_lower_optarg?\n            return false if ruby_32_or_higher_missing_rest_or_kwest?\n            return false unless offensive_block_forwarding?\n            return false if additional_kwargs_or_forwarded_kwargs?\n\n            no_additional_args? || (target_ruby_version >= 3.0 && no_post_splat_args?)\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "544"
  },
  {
    "raw_code": "def ruby_30_or_lower_optarg?\n            target_ruby_version <= 3.0 && @def_node.arguments.any?(&:optarg_type?)\n          end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity def foo(a = 41, ...) is a syntax error in 3.0.",
    "label": "",
    "id": "545"
  },
  {
    "raw_code": "def redundant_each_method(node)\n          return if node.last_argument&.block_pass_type?\n\n          if node.method?(:each) && !node.parent&.block_type?\n            ancestor_node = node.each_ancestor(:call).detect do |ancestor|\n              ancestor.receiver == node &&\n                (RESTRICT_ON_SEND.include?(ancestor.method_name) || ancestor.method?(:reverse_each))\n            end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "546"
  },
  {
    "raw_code": "def range(node)\n          return node.selector unless node.method?(:each)\n\n          if node.parent&.call_type?\n            node.selector.join(node.parent.loc.dot)\n          else\n            node.loc.dot.join(node.selector)\n          end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "547"
  },
  {
    "raw_code": "def on_send(node)\n          return unless node.receiver&.begin_type?\n          return unless (preferred_method = preferred_method(node))\n\n          bit_operation = node.receiver.children.first\n          lhs, _operator, rhs = *bit_operation\n\n          preferred = if preferred_method == 'allbits?' && lhs.source == node.first_argument.source\n                        \"#{rhs.source}.allbits?(#{lhs.source})\"\n                      else\n                        \"#{lhs.source}.#{preferred_method}(#{rhs.source})\"\n                      end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "548"
  },
  {
    "raw_code": "def acceptable_19_syntax_symbol?(sym_name)\n          sym_name.delete_prefix!(':')\n\n          if cop_config['PreferHashRocketsForNonAlnumEndingSymbols'] &&\n             # Prefer { :production? => false } over { production?: false } and\n             # similarly for other non-alnum final characters (except quotes,\n             # to prefer { \"x y\": 1 } over { :\"x y\" => 1 }).\n             !/[\\p{Alnum}\"']\\z/.match?(sym_name)\n            return false\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "549"
  },
  {
    "raw_code": "def check(pairs, delim, msg)\n          pairs.each do |pair|\n            if pair.delimiter == delim\n              location = pair.source_range.begin.join(pair.loc.operator)\n              add_offense(location, message: msg) do |corrector|\n                autocorrect(corrector, pair)\n\n                opposite_style_detected\n              end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "550"
  },
  {
    "raw_code": "def after_class(class_node)\n          @macros_to_rewrite[class_node].each do |macro|\n            node = macro.node\n            range = range_by_whole_lines(node.source_range, include_final_newline: true)\n\n            correct(range) do |corrector|\n              if macro.writer?\n                correct_writer(corrector, macro, node, range)\n              else\n                correct_reader(corrector, macro, node, range)\n              end",
    "comment": "Each offending macro is captured and registered in `on_class` but correction happens in `after_class` because a macro might have multiple attributes rewritten from it",
    "label": "",
    "id": "551"
  },
  {
    "raw_code": "def complex_condition?(condition)\n          if condition.begin_type?\n            condition.to_a.any? { |x| complex_condition?(x) }\n          else\n            !non_complex_expression?(condition)\n          end",
    "comment": "If the condition is parenthesized we recurse and check for any complex expressions within it.",
    "label": "",
    "id": "552"
  },
  {
    "raw_code": "def non_complex_expression?(condition)\n          NON_COMPLEX_TYPES.include?(condition.type) || non_complex_send?(condition)\n        end",
    "comment": "Anything that is not a variable, constant, or method/.method call will be counted as a complex expression.",
    "label": "",
    "id": "553"
  },
  {
    "raw_code": "def on_if(node)\n          return if endless_method?(node.body)\n\n          condition = node.condition\n          return if defined_nodes(condition).any? { |n| defined_argument_is_undefined?(node, n) } ||\n                    pattern_matching_nodes(condition).any?\n\n          return unless (msg = message(node))\n\n          add_offense(node.loc.keyword, message: format(msg, keyword: node.keyword)) do |corrector|\n            next if part_of_ignored_node?(node)\n\n            autocorrect(corrector, node)\n            ignore_node(node)\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "554"
  },
  {
    "raw_code": "def add_self_to_getters(right_elements)\n          right_elements.map do |e|\n            implicit_self_getter?(e) { |var| s(:send, s(:self), var) } || e\n          end",
    "comment": "Converts (send nil :something) nodes to (send (:self) :something). This makes the sorting algorithm work for expressions such as `self.a, self.b = b, a`.",
    "label": "",
    "id": "555"
  },
  {
    "raw_code": "def dependencies_for_assignment(assignment)\n            my_lhs, _my_rhs = *assignment\n\n            @assignments.filter_map do |other|\n              # Exclude self, there are no dependencies in cases such as `a, b = a, b`.\n              next if other == assignment\n\n              _other_lhs, other_rhs = *other\n              next unless dependency?(my_lhs, other_rhs)\n\n              other\n            end",
    "comment": "Returns all the assignments which must come after `assignment` (due to dependencies on the previous value of the assigned var)",
    "label": "",
    "id": "556"
  },
  {
    "raw_code": "def accesses?(rhs, lhs)\n            if lhs.method?(:[]=)\n              # FIXME: Workaround `rubocop:disable` comment for JRuby.\n              # rubocop:disable Performance/RedundantEqualityComparisonBlock\n              matching_calls(rhs, lhs.receiver, :[]).any? { |args| args == lhs.arguments }\n              # rubocop:enable Performance/RedundantEqualityComparisonBlock\n            else\n              access_method = lhs.method_name.to_s.chop.to_sym\n              matching_calls(rhs, lhs.receiver, access_method).any?\n            end",
    "comment": "`lhs` is an assignment method call like `obj.attr=` or `ary[idx]=`. Does `rhs` access the same value which is assigned by `lhs`?",
    "label": "",
    "id": "557"
  },
  {
    "raw_code": "def require_then?(when_node)\n          unless when_node.conditions.first.first_line == when_node.conditions.last.last_line\n            return true\n          end",
    "comment": "Requires `then` for write `when` and its body on the same line.",
    "label": "",
    "id": "558"
  },
  {
    "raw_code": "def autocorrect(corrector, to_h, map)\n          removal_range = range_between(to_h.loc.dot.begin_pos, to_h.loc.selector.end_pos)\n\n          corrector.remove(range_with_surrounding_space(removal_range, side: :left))\n          if (map_dot = map.loc.dot)\n            corrector.replace(map_dot, to_h.loc.dot.source)\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "559"
  },
  {
    "raw_code": "def valid_yoda?(node)\n          return true unless (rhs = node.first_argument)\n\n          lhs = node.receiver\n          return true if (constant_portion?(lhs) && constant_portion?(rhs)) ||\n                         (!constant_portion?(lhs) && !constant_portion?(rhs)) ||\n                         interpolation?(lhs)\n\n          enforce_yoda? ? constant_portion?(lhs) : constant_portion?(rhs)\n        end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "560"
  },
  {
    "raw_code": "def message(node)\n          format(MSG, source: node.source)\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "561"
  },
  {
    "raw_code": "def on_block(node)\n          return unless node.parent&.begin_type?\n          return unless collection_looping_method?(node)\n          return unless same_collection_looping_block?(node, node.left_sibling)\n          return unless node.body && node.left_sibling.body\n\n          add_offense(node) do |corrector|\n            next unless node.arguments == node.left_sibling.arguments\n\n            combine_with_left_sibling(corrector, node)\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "562"
  },
  {
    "raw_code": "def nodoc_comment?(node, require_all: false)\n          return false unless node&.children&.first\n\n          nodoc = nodoc(node)\n\n          return true if same_line?(nodoc, node) && nodoc?(nodoc, require_all: require_all)\n\n          nodoc_comment?(node.parent, require_all: true)\n        end",
    "comment": "First checks if the :nodoc: comment is associated with the class/module. Unless the element is tagged with :nodoc:, the search proceeds to check its ancestors for :nodoc: all. Note: How end-of-line comments are associated with code changed in parser-2.2.0.4.",
    "label": "",
    "id": "563"
  },
  {
    "raw_code": "def on_or_asgn(node)\n          allow_self(node.lhs)\n\n          lhs_name = node.lhs.lvasgn_type? ? node.lhs.name : node.lhs\n          add_lhs_to_local_variables_scopes(node.rhs, lhs_name)\n        end",
    "comment": "Assignment of self.x",
    "label": "",
    "id": "564"
  },
  {
    "raw_code": "def on_def(node)\n          add_scope(node)\n        end",
    "comment": "Using self.x to distinguish from local variable x",
    "label": "",
    "id": "565"
  },
  {
    "raw_code": "def it_method_in_block?(node)\n          return false unless node.method?(:it)\n          return false unless (block_node = node.each_ancestor(:block).first)\n          return false unless block_node.arguments.empty_and_without_delimiters?\n\n          node.arguments.empty? && !node.block_literal?\n        end",
    "comment": "Respects `Lint/ItWithoutArgumentsInBlock` cop and the following Ruby 3.3's warning:  $ ruby -e '0.times { begin; it; end }' -e:1: warning: `it` calls without arguments will refer to the first block param in Ruby 3.4; use it() or self.it ",
    "label": "",
    "id": "566"
  },
  {
    "raw_code": "def if_branch_is_true_type_and_else_is_not?(node)\n          return false unless node.ternary? || node.if?\n\n          cond = node.condition\n          return false unless cond.call_type?\n          return false if !cond.predicate_method? || allowed_method?(cond.method_name)\n\n          node.if_branch&.true_type? && node.else_branch && !node.else_branch.true_type?\n        end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "567"
  },
  {
    "raw_code": "def branches_have_assignment?(node)\n          _condition, if_branch, else_branch = *node # rubocop:disable InternalAffairs/NodeDestructuring\n\n          return false unless if_branch && else_branch\n\n          asgn_type?(if_branch) && (if_branch_variable_name = if_branch.name) &&\n            asgn_type?(else_branch) && (else_branch_variable_name = else_branch.name) &&\n            if_branch_variable_name == else_branch_variable_name\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "568"
  },
  {
    "raw_code": "def argument_with_operator?(argument)\n          return true if ARGUMENT_WITH_OPERATOR_TYPES.include?(argument.type)\n          return false unless argument.hash_type?\n          return false unless (node = argument.children.first)\n\n          node.type?(:kwsplat, :forwarded_kwrestarg)\n        end",
    "comment": "If the argument is using an operator, it is an invalid syntax. e.g. `foo || *bar`, `foo || **bar`, and `foo || &bar`.",
    "label": "",
    "id": "569"
  },
  {
    "raw_code": "def if_source(if_branch, arithmetic_operation)\n          if branches_have_method?(if_branch.parent) && if_branch.parenthesized?\n            if_branch.source.delete_suffix(')')\n          elsif arithmetic_operation\n            argument_source = if_branch.first_argument.source\n\n            \"#{if_branch.receiver.source} #{if_branch.method_name} (#{argument_source}\"\n          elsif if_branch.true_type?\n            condition = if_branch.parent.condition\n            return condition.source if condition.arguments.empty? || condition.parenthesized?\n\n            wrap_arguments_with_parens(condition)\n          else\n            if_branch.source\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "570"
  },
  {
    "raw_code": "def else_source(else_branch, arithmetic_operation) # rubocop:disable Metrics/AbcSize\n          if arithmetic_operation\n            \"#{else_branch.first_argument.source})\"\n          elsif branches_have_method?(else_branch.parent)\n            else_source_if_has_method(else_branch)\n          elsif require_parentheses?(else_branch)\n            \"(#{else_branch.source})\"\n          elsif without_argument_parentheses_method?(else_branch)\n            \"#{else_branch.method_name}(#{else_branch.arguments.map(&:source).join(', ')})\"\n          elsif branches_have_assignment?(else_branch.parent)\n            else_source_if_has_assignment(else_branch)\n          else\n            else_branch.source\n          end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "571"
  },
  {
    "raw_code": "def on_case(case_node)\n          if case_node.condition || NOT_SUPPORTED_PARENT_TYPES.include?(case_node.parent&.type)\n            return\n          end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "572"
  },
  {
    "raw_code": "def all_fields_literal?(string, arguments)\n          count = 0\n          sequences = RuboCop::Cop::Utils::FormatString.new(string).format_sequences\n          return false unless sequences.any?\n\n          sequences.each do |sequence|\n            next if sequence.percent?\n            next if unknown_variable_width?(sequence, arguments)\n\n            hash = arguments.detect(&:hash_type?)\n            next unless (argument = find_argument(sequence, arguments, hash))\n            next unless matching_argument?(sequence, argument)\n\n            count += 1\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "573"
  },
  {
    "raw_code": "def unknown_variable_width?(sequence, arguments)\n          return false unless sequence.variable_width?\n\n          argument = arguments[sequence.variable_width_argument_number - 1]\n          !numeric?(argument)\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity If the sequence has a variable (`*`) width, it cannot be autocorrected if the width is not given as a numeric literal argument",
    "label": "",
    "id": "574"
  },
  {
    "raw_code": "def find_argument(sequence, arguments, hash)\n          if hash && (sequence.annotated? || sequence.template?)\n            find_hash_value_node(hash, sequence.name.to_sym).first\n          elsif sequence.variable_width?\n            # If the specifier contains `*`, the argument for the width can be ignored.\n            arguments.delete_at(sequence.variable_width_argument_number - 1)\n            arguments.shift\n          elsif sequence.arg_number\n            arguments[sequence.arg_number.to_i - 1]\n          else\n            arguments.shift\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "575"
  },
  {
    "raw_code": "def matching_argument?(sequence, argument)\n          # Template specifiers don't give a type, any acceptable literal type is ok.\n          return argument.type?(*ACCEPTABLE_LITERAL_TYPES) if sequence.template?\n\n          # An argument matches a specifier if it can be easily converted\n          # to that type.\n          case sequence.type\n          when 's'\n            argument.type?(*ACCEPTABLE_LITERAL_TYPES)\n          when 'd', 'i', 'u'\n            integer?(argument)\n          when 'f'\n            float?(argument)\n          else\n            false\n          end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "576"
  },
  {
    "raw_code": "def quote(string, node)\n          str_node = node.first_argument\n          start_delimiter = str_node.loc.begin.source\n          end_delimiter = str_node.loc.end.source\n\n          # If there is any interpolation, the delimiters need to be changed potentially\n          if node.each_descendant(:dstr, :dsym).any?\n            case start_delimiter\n            when \"'\"\n              start_delimiter = end_delimiter = '\"'\n            when /\\A%q(.)/\n              start_delimiter = \"%Q#{Regexp.last_match[1]}\"\n            end",
    "comment": "Add correct quotes to the formatted string, preferring retaining the existing quotes if possible.",
    "label": "",
    "id": "577"
  },
  {
    "raw_code": "def on_if(node)\n          return if allowed_if_condition?(node)\n\n          checked_variable, receiver, method_chain, _method = extract_parts_from_if(node)\n          return unless offending_node?(node, checked_variable, method_chain, receiver)\n\n          body = extract_if_body(node)\n          method_call = receiver.parent\n          return if dotless_operator_call?(method_call) || method_call.double_colon?\n\n          removal_ranges = [begin_range(node, body), end_range(node, body)]\n\n          report_offense(node, method_chain, method_call, *removal_ranges) do |corrector|\n            corrector.replace(receiver, checked_variable.source) if checked_variable.csend_type?\n            corrector.insert_before(method_call.loc.dot, '&') unless method_call.safe_navigation?\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "578"
  },
  {
    "raw_code": "def on_and(node) # rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength\n          collect_and_clauses(node).each do |(lhs, lhs_operator_range), (rhs, _rhs_operator_range)|\n            lhs_not_nil_check = not_nil_check?(lhs)\n            lhs_receiver = lhs_not_nil_check || lhs\n            rhs_receiver = find_matching_receiver_invocation(strip_begin(rhs), lhs_receiver)\n\n            next if !cop_config['ConvertCodeThatCanStartToReturnNil'] && lhs_not_nil_check\n            next unless offending_node?(node, lhs_receiver, rhs, rhs_receiver)\n\n            # Since we are evaluating every clause in potentially a complex chain of `and` nodes,\n            # we need to ensure that there isn't an object check happening\n            lhs_method_chain = find_method_chain(lhs_receiver)\n            next unless lhs_method_chain == lhs_receiver || lhs_not_nil_check\n\n            report_offense(\n              node,\n              rhs, rhs_receiver,\n              range_with_surrounding_space(range: lhs.source_range, side: :right),\n              range_with_surrounding_space(range: lhs_operator_range, side: :right),\n              offense_range: range_between(lhs.source_range.begin_pos, rhs.source_range.end_pos)\n            ) do |corrector|\n              corrector.replace(rhs_receiver, lhs_receiver.source)\n            end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "579"
  },
  {
    "raw_code": "def remove_end(corrector, body)\n          remove_begin_pos = if same_line?(body.loc.name, body.loc.end)\n                               body.loc.name.end_pos\n                             else\n                               body.loc.end.begin_pos - leading_spaces(body).size\n                             end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "580"
  },
  {
    "raw_code": "def unindent(corrector, node)\n          return unless node.body.children.last\n\n          last_child_leading_spaces = leading_spaces(node.body.children.last)\n          return if spaces_size(leading_spaces(node)) == spaces_size(last_child_leading_spaces)\n\n          column_delta = configured_indentation_width - spaces_size(last_child_leading_spaces)\n          return if column_delta.zero?\n\n          AlignmentCorrector.correct(corrector, processed_source, node, column_delta)\n        end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "581"
  },
  {
    "raw_code": "def on_or(node)\n          root_of_or_node = root_of_or_node(node)\n          return unless node == root_of_or_node\n          return unless nested_comparison?(node)\n\n          return unless (variable, values = find_offending_var(node))\n          return if values.size < comparisons_threshold\n\n          range = offense_range(values)\n\n          add_offense(range) do |corrector|\n            elements = values.map(&:source).join(', ')\n            argument = variable.lvar_type? ? variable_name(variable) : variable.source\n            prefer_method = \"[#{elements}].include?(#{argument})\"\n\n            corrector.replace(range, prefer_method)\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "582"
  },
  {
    "raw_code": "def find_offending_var(node, variables = Set.new, values = [])\n          if node.or_type?\n            find_offending_var(node.lhs, variables, values)\n            find_offending_var(node.rhs, variables, values)\n          elsif simple_double_comparison?(node)\n            return\n          elsif (var, obj = simple_comparison(node))\n            return if allow_method_comparison? && obj.call_type?\n\n            variables << var\n            return if variables.size > 1\n\n            values << obj\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "583"
  },
  {
    "raw_code": "def offense_range(values)\n          values.first.parent.source_range.begin.join(values.last.parent.source_range.end)\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "584"
  },
  {
    "raw_code": "def opposite_style_detected; end\n\n        # Dummy implementation of method in ConfigurableEnforcedStyle that is\n        # called from StringHelp.\n        def correct_style_detected; end\n      end\n    end",
    "comment": "Dummy implementation of method in ConfigurableEnforcedStyle that is called from StringHelp.",
    "label": "",
    "id": "585"
  },
  {
    "raw_code": "def last_expression?(node)\n            !(node.parent&.assignment? ? node.parent.right_sibling : node.right_sibling)\n          end",
    "comment": "Require hash value omission be enclosed in parentheses to prevent the following issue: https://bugs.ruby-lang.org/issues/18396.",
    "label": "",
    "id": "586"
  },
  {
    "raw_code": "def call_with_ambiguous_arguments?(node)\n            call_with_braced_block?(node) ||\n              call_in_argument_with_block?(node) ||\n              call_as_argument_or_chain?(node) ||\n              call_in_match_pattern?(node) ||\n              hash_literal_in_arguments?(node) ||\n              ambiguous_range_argument?(node) ||\n              node.descendants.any? do |n|\n                n.type?(:forwarded_args, :any_block) ||\n                  ambiguous_literal?(n) || logical_operator?(n)\n              end",
    "comment": "rubocop:disable Metrics/PerceivedComplexity",
    "label": "",
    "id": "587"
  },
  {
    "raw_code": "def call_with_braced_block?(node)\n            node.type?(:call, :super) && node.block_node&.braces?\n          end",
    "comment": "rubocop:enable Metrics/PerceivedComplexity",
    "label": "",
    "id": "588"
  },
  {
    "raw_code": "def initialize(source, corr = [])\n          super(source)\n          if corr.is_a?(CorrectionsProxy)\n            merge!(corr.send(:corrector))\n          else\n            unless corr.empty?\n              warn Rainbow(<<~WARNING).yellow, uplevel: 1\n                `Corrector.new` with corrections is deprecated.\n                See https://docs.rubocop.org/rubocop/v1_upgrade_notes.html\n              WARNING\n            end",
    "comment": "Support legacy second argument",
    "label": "",
    "id": "589"
  },
  {
    "raw_code": "def on_block(node)\n          return unless node.receiver\n          return if node.method?(:with_index) && !node.receiver.receiver\n          return unless (send = redundant_with_index?(node))\n\n          range = with_index_range(send)\n\n          add_offense(range, message: message(send)) do |corrector|\n            if send.method?(:each_with_index)\n              corrector.replace(send.loc.selector, 'each')\n            else\n              corrector.remove(range)\n              corrector.remove(send.loc.dot)\n            end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "590"
  },
  {
    "raw_code": "def check(node)\n          return unless node.method?(:initialize)\n\n          check_body(node.body)\n        end",
    "comment": "@param [DefNode] node a constructor definition",
    "label": "",
    "id": "591"
  },
  {
    "raw_code": "def check_body_lines(lines)\n          lines.each do |line|\n            case line.type\n            when :or_asgn\n              check_disjunctive_assignment(line)\n            else\n              # Once we encounter something other than a disjunctive\n              # assignment, we cease our investigation, because we can't be\n              # certain that any future disjunctive assignments are offensive.\n              # You're off the case, detective!\n              break\n            end",
    "comment": "@param [Array] lines the logical lines of the constructor",
    "label": "",
    "id": "592"
  },
  {
    "raw_code": "def check_disjunctive_assignment(node)\n          lhs = node.child_nodes.first\n          return unless lhs.ivasgn_type?\n\n          add_offense(node.loc.operator) do |corrector|\n            corrector.replace(node.loc.operator, '=')\n          end",
    "comment": "Add an offense if the LHS of the given disjunctive assignment is an instance variable.  For now, we only care about assignments to instance variables.  @param [Node] node a disjunctive assignment",
    "label": "",
    "id": "593"
  },
  {
    "raw_code": "def on_send(node)\n          return if node.arguments.any? || hash_or_set_with_block?(node)\n\n          receiver = find_receiver(node)\n          return unless literal_receiver?(node, receiver) ||\n                        constructor?(node, receiver) ||\n                        chained_conversion?(node, receiver) ||\n                        chained_to_typed_method?(node, receiver)\n\n          message = format(MSG, method: node.method_name)\n\n          add_offense(node.loc.selector, message: message) do |corrector|\n            corrector.remove(node.loc.dot.join(node.loc.end || node.loc.selector))\n          end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity",
    "label": "",
    "id": "594"
  },
  {
    "raw_code": "def offense_message(directive_comment)\n          comment = directive_comment.comment\n          after_marker = comment.text.sub(DirectiveComment::DIRECTIVE_MARKER_REGEXP, '')\n          mode = after_marker.split(' ', 2).first\n          additional_msg = if mode.nil?\n                             MISSING_MODE_NAME_MSG\n                           elsif !DirectiveComment::AVAILABLE_MODES.include?(mode)\n                             INVALID_MODE_NAME_MSG\n                           elsif directive_comment.missing_cop_name?\n                             MISSING_COP_NAME_MSG\n                           else\n                             MALFORMED_COP_NAMES_MSG\n                           end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "595"
  },
  {
    "raw_code": "def allowed_arguments?(arguments)\n          return false if arguments.empty?\n\n          arguments.each_child_node(:restarg).any? &&\n            arguments.each_child_node(:kwarg, :kwoptarg, :kwrestarg).none?\n        end",
    "comment": "`ruby2_keywords` is only allowed if there's a `restarg` and no keyword arguments",
    "label": "",
    "id": "596"
  },
  {
    "raw_code": "def within_interpolation?(node, child)\n          parse_tree_child_loc = child.expression\n\n          interpolation_locs(node).any? { |il| il.overlaps?(parse_tree_child_loc) }\n        end",
    "comment": "Since we blank interpolations with a space for every char of the interpolation, we would mark every space (except the first) as duplicate if we do not skip regexp_parser nodes that are within an interpolation.",
    "label": "",
    "id": "597"
  },
  {
    "raw_code": "def ineffective_modifier(node, ignored_methods = nil, modifier = nil, &block)\n          node.each_child_node do |child|\n            case child.type\n            when :send\n              modifier = child if access_modifier?(child)\n            when :defs\n              ignored_methods ||= private_class_method_names(node)\n              next if correct_visibility?(child, modifier, ignored_methods)\n\n              yield child, modifier\n            when :kwbegin\n              ignored_methods ||= private_class_method_names(node)\n              ineffective_modifier(child, ignored_methods, modifier, &block)\n            end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "598"
  },
  {
    "raw_code": "def access_modifier?(node)\n          node.bare_access_modifier? && !node.method?(:module_function)\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "599"
  },
  {
    "raw_code": "def on_rescue(node)\n          if (method, exception_classes = begin_numeric_constructor_rescue_nil(node.parent))\n            return unless expected_exception_classes_only?(exception_classes)\n\n            node = node.parent\n          else\n            return unless (method = numeric_constructor_rescue_nil(node))\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "600"
  },
  {
    "raw_code": "def check_for_unused_assignments(variable)\n          return if variable.should_be_unused?\n\n          variable.assignments.reverse_each do |assignment|\n            assignment_node = assignment.node\n            next if assignment.used? || part_of_ignored_node?(assignment_node)\n\n            message = message_for_useless_assignment(assignment)\n            range = offense_range(assignment)\n\n            add_offense(range, message: message) do |corrector|\n              # In cases like `x = 1, y = 2`, where removing a variable would cause a syntax error,\n              # and where changing `x ||= 1` to `x = 1` would cause `NameError`,\n              # the autocorrect will be skipped, even if the variable is unused.\n              if sequential_assignment?(assignment_node) || assignment_node.parent&.or_asgn_type?\n                next\n              end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/PerceivedComplexity, Metrics/CyclomaticComplexity",
    "label": "",
    "id": "601"
  },
  {
    "raw_code": "def message_for_useless_assignment(assignment)\n          variable = assignment.variable\n\n          format(MSG, variable: variable.name) + message_specification(assignment, variable).to_s\n        end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/PerceivedComplexity, Metrics/CyclomaticComplexity",
    "label": "",
    "id": "602"
  },
  {
    "raw_code": "def return_value_node_of_scope(scope)\n          body_node = scope.body_node\n\n          if body_node.begin_type?\n            body_node.children.last\n          else\n            body_node\n          end",
    "comment": "TODO: More precise handling (rescue, ensure, nested begin, etc.)",
    "label": "",
    "id": "603"
  },
  {
    "raw_code": "def autocorrect(corrector, assignment)\n          if assignment.exception_assignment?\n            remove_exception_assignment_part(corrector, assignment.node)\n          elsif assignment.multiple_assignment? || assignment.rest_assignment? ||\n                assignment.for_assignment?\n            rename_variable_with_underscore(corrector, assignment.node)\n          elsif assignment.operator_assignment?\n            remove_trailing_character_from_operator(corrector, assignment.node)\n          elsif assignment.regexp_named_capture?\n            replace_named_capture_group_with_non_capturing_group(corrector, assignment.node,\n                                                                 assignment.variable.name)\n          else\n            remove_local_variable_assignment_part(corrector, assignment.node)\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "604"
  },
  {
    "raw_code": "def remove_exception_assignment_part(corrector, node)\n          corrector.remove(\n            range_between(\n              (node.parent.children.first&.source_range || node.parent.location.keyword).end_pos,\n              node.source_range.end_pos\n            )\n          )\n        end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "605"
  },
  {
    "raw_code": "def redundant_feature?(feature_name)\n          feature_name == 'enumerator' ||\n            (target_ruby_version >= 2.1 && feature_name == 'thread') ||\n            (target_ruby_version >= 2.2 && RUBY_22_LOADED_FEATURES.include?(feature_name)) ||\n            (target_ruby_version >= 2.7 && feature_name == 'ruby2_keywords') ||\n            (target_ruby_version >= 3.1 && feature_name == 'fiber') ||\n            (target_ruby_version >= 3.2 && feature_name == 'set')\n        end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "606"
  },
  {
    "raw_code": "def check_void_op(node, &block)\n          node = node.children.first while node&.begin_type?\n          return unless node&.call_type? && OPERATORS.include?(node.method_name)\n          if !UNARY_OPERATORS.include?(node.method_name) && node.loc.dot && node.arguments.none?\n            return\n          end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "607"
  },
  {
    "raw_code": "def check_var(node)\n          return unless node.variable? || node.const_type?\n\n          if node.const_type?\n            template = node.special_keyword? ? VAR_MSG : CONST_MSG\n\n            offense_range = node\n            message = format(template, var: node.source)\n          else\n            offense_range = node.loc.name\n            message = format(VAR_MSG, var: node.loc.name.source)\n          end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "608"
  },
  {
    "raw_code": "def assignment_without_argument_usage(argument)\n          argument.assignments.reduce(true) do |location_known, assignment|\n            assignment_node = assignment.meta_assignment_node || assignment.node\n\n            # Shorthand assignments always use their arguments\n            next false if assignment_node.shorthand_asgn?\n            next false unless assignment_node.parent\n\n            conditional_assignment =\n              conditional_assignment?(assignment_node.parent, argument.scope.node)\n\n            unless uses_var?(assignment_node, argument.name)\n              # It's impossible to decide whether a branch or block is executed,\n              # so the precise reassignment location is undecidable.\n              next false if conditional_assignment\n\n              yield(assignment.node, location_known)\n              break\n            end",
    "comment": "Find the first argument assignment, which doesn't reference the argument at the rhs. If the assignment occurs inside a branch or block, it is impossible to tell whether it's executed, so precise shadowing location is not known. ",
    "label": "",
    "id": "609"
  },
  {
    "raw_code": "def conditional_assignment?(node, stop_search_node)\n          return false if node == stop_search_node\n\n          node.conditional? || node.type?(:block, :rescue) ||\n            conditional_assignment?(node.parent, stop_search_node)\n        end",
    "comment": "Check whether the given node is always executed or not ",
    "label": "",
    "id": "610"
  },
  {
    "raw_code": "def argument_references(argument)\n          assignment_references = argument.assignments.flat_map(&:references).map(&:source_range)\n\n          argument.references.reject do |ref|\n            next false unless ref.explicit?\n\n            assignment_references.include?(ref.node.source_range)\n          end",
    "comment": "Get argument references without assignments' references ",
    "label": "",
    "id": "611"
  },
  {
    "raw_code": "def find_consistent_parts(grouped_operands)\n          csend_in_and, csend_in_or, send_in_and, send_in_or = most_left_indices(grouped_operands)\n\n          return if csend_in_and && csend_in_or && csend_in_and < csend_in_or\n\n          if csend_in_and\n            ['.', (send_in_and ? [send_in_and, csend_in_and].min : csend_in_and) + 1]\n          elsif send_in_or && csend_in_or\n            send_in_or < csend_in_or ? ['.', send_in_or + 1] : ['&.', csend_in_or + 1]\n          elsif send_in_and && csend_in_or && send_in_and < csend_in_or\n            ['.', csend_in_or]\n          end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "612"
  },
  {
    "raw_code": "def already_appropriate_call?(operand, dot_op)\n          return true if operand.safe_navigation? && dot_op == '&.'\n\n          (operand.dot? || operand.operator_method?) && dot_op == '.'\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "613"
  },
  {
    "raw_code": "def most_left_indices(grouped_operands)\n          indices = { csend_in_and: nil, csend_in_or: nil, send_in_and: nil, send_in_or: nil }\n\n          grouped_operands.each_with_index do |operand, index|\n            indices[:csend_in_and] ||= index if operand_in_and?(operand) && operand.csend_type?\n            indices[:csend_in_or] ||= index if operand_in_or?(operand) && operand.csend_type?\n            indices[:send_in_and] ||= index if operand_in_and?(operand) && !nilable?(operand)\n            indices[:send_in_or] ||= index if operand_in_or?(operand) && !nilable?(operand)\n          end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "614"
  },
  {
    "raw_code": "def operand_in_and?(node)\n          return true if node.parent.and_type?\n\n          parent = node.parent.parent while node.parent.begin_type?\n\n          parent&.and_type?\n        end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "615"
  },
  {
    "raw_code": "def only_reraising?(resbody_node)\n          return false if use_exception_variable_in_ensure?(resbody_node)\n\n          body = resbody_node.body\n\n          return false if body.nil? || !body.send_type? || !body.method?(:raise) || body.receiver\n          return true unless body.arguments?\n          return false if body.arguments.size > 1\n\n          exception_name = body.first_argument.source\n\n          exception_objects(resbody_node).include?(exception_name)\n        end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity",
    "label": "",
    "id": "616"
  },
  {
    "raw_code": "def use_exception_variable_in_ensure?(resbody_node)\n          return false unless (exception_variable = resbody_node.exception_variable)\n          return false unless (ensure_node = resbody_node.each_ancestor(:ensure).first)\n          return false unless (ensure_body = ensure_node.branch)\n\n          ensure_body.each_descendant(:lvar).map(&:source).include?(exception_variable.source)\n        end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity",
    "label": "",
    "id": "617"
  },
  {
    "raw_code": "def last_arg_range(node)\n          node.last_argument.source_range.join(node.arguments[-2].source_range.end)\n        end",
    "comment": "Returns range of last argument including comma and whitespace.  @return [Parser::Source::Range] ",
    "label": "",
    "id": "618"
  },
  {
    "raw_code": "def replacement_range_and_content(node)\n          variable = node.children.first\n          expression = node.source_range\n\n          if array_new?(variable)\n            expression = node.parent.source_range if node.parent.array_type?\n            [expression, variable.source]\n          elsif !variable.array_type?\n            [expression, \"[#{variable.source}]\"]\n          elsif redundant_brackets?(node)\n            [expression, remove_brackets(variable)]\n          else\n            [node.loc.operator, '']\n          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "619"
  },
  {
    "raw_code": "def array_splat?(node)\n          node.children.first.array_type?\n        end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "620"
  },
  {
    "raw_code": "def on_while_post(node)\n          return if node.condition.source == 'true'\n\n          if node.condition.truthy_literal?\n            add_offense(node.condition) do |corrector|\n              corrector.replace(node, node.source.sub(node.condition.source, 'true'))\n            end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "621"
  },
  {
    "raw_code": "def on_until(node)\n          return if node.condition.source == 'false'\n\n          if node.condition.falsey_literal?\n            add_offense(node.condition) do |corrector|\n              corrector.replace(node.condition, 'false')\n            end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "622"
  },
  {
    "raw_code": "def on_until_post(node)\n          return if node.condition.source == 'false'\n\n          if node.condition.falsey_literal?\n            add_offense(node.condition) do |corrector|\n              corrector.replace(node, node.source.sub(node.condition.source, 'false'))\n            end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "623"
  },
  {
    "raw_code": "def on_case(case_node)\n          if (cond = case_node.condition)\n            return if !cond.falsey_literal? && !cond.truthy_literal?\n\n            check_case(case_node)\n          else\n            case_node.when_branches.each do |when_node|\n              next unless when_node.conditions.all?(&:literal?)\n\n              range = when_conditions_range(when_node)\n              message = message(range)\n\n              add_offense(range, message: message)\n            end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "624"
  },
  {
    "raw_code": "def correct_if_node(node, cond)\n          result = condition_evaluation?(node, cond)\n\n          new_node = if node.elsif? && result\n                       \"else\\n  #{range_with_comments(node.if_branch).source}\"\n                     elsif node.elsif? && !result\n                       \"else\\n  #{node.else_branch.source}\"\n                     elsif node.if_branch && result\n                       node.if_branch.source\n                     elsif node.elsif_conditional?\n                       \"#{node.else_branch.source.sub('elsif', 'if')}\\nend\"\n                     elsif node.else? || node.ternary?\n                       node.else_branch.source\n                     else\n                       '' # Equivalent to removing the node\n                     end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/MethodLength, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "625"
  },
  {
    "raw_code": "def top_level_return?(return_node)\n          return_node.each_ancestor(:block, :any_def).none?\n        end",
    "comment": "This cop works by validating the ancestors of the return node. A top-level return node's ancestors should not be of block, def, or defs type.",
    "label": "",
    "id": "626"
  },
  {
    "raw_code": "def on_interpolation(begin_node)\n          final_node = begin_node.children.last\n          return unless offending?(final_node)\n\n          # %W and %I split the content into words before expansion\n          # treating each interpolation as a word component, so\n          # interpolation should not be removed if the expanded value\n          # contains a space character.\n          expanded_value = autocorrected_value(final_node)\n          expanded_value = handle_special_regexp_chars(begin_node, expanded_value)\n\n          return if in_array_percent_literal?(begin_node) && /\\s|\\A\\z/.match?(expanded_value)\n\n          add_offense(final_node) do |corrector|\n            next if final_node.dstr_type? # nested, fixed in next iteration\n\n            replacement = if final_node.str_type? && !final_node.value.valid_encoding?\n                            final_node.source.delete_prefix('\"').delete_suffix('\"')\n                          else\n                            expanded_value\n                          end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "627"
  },
  {
    "raw_code": "def autocorrected_value(node)\n          case node.type\n          when :int\n            node.children.last.to_i.to_s\n          when :float\n            node.children.last.to_f.to_s\n          when :str\n            autocorrected_value_for_string(node)\n          when :sym\n            autocorrected_value_for_symbol(node)\n          when :array\n            autocorrected_value_for_array(node)\n          when :hash\n            autocorrected_value_for_hash(node)\n          when :nil\n            ''\n          else\n            node.source.gsub('\"', '\\\"')\n          end",
    "comment": "rubocop:disable Metrics/MethodLength, Metrics/CyclomaticComplexity",
    "label": "",
    "id": "628"
  },
  {
    "raw_code": "def handle_special_regexp_chars(begin_node, value)\n          parent_node = begin_node.parent\n\n          return value unless parent_node.regexp_type? && parent_node.slash_literal? && value['/']\n\n          # When a literal string containing a forward slash preceded by backslashes\n          # is interpolated inside a regexp, the number of resultant backslashes in the\n          # compiled Regexp is `(2(n+1) / 4)+1`, where `n` is the number of backslashes\n          # inside the interpolation.\n          # ie. 0-2 backslashes is compiled to 1, 3-6 is compiled to 3, etc.\n          # This maintains that same behavior in order to ensure the Regexp behavior\n          # does not change upon removing the interpolation.\n          value.gsub(%r{(\\\\*)/}) do\n            backslashes = Regexp.last_match[1]\n            backslash_count = backslashes.length\n            needed_backslashes = (2 * ((backslash_count + 1) / 4)) + 1\n\n            \"#{'\\\\' * needed_backslashes}/\"\n          end",
    "comment": "rubocop:enable Metrics/MethodLength, Metrics/CyclomaticComplexity",
    "label": "",
    "id": "629"
  },
  {
    "raw_code": "def autocorrected_value_in_hash(node)\n          case node.type\n          when :int\n            node.children.last.to_i.to_s\n          when :float\n            node.children.last.to_f.to_s\n          when :str\n            \"\\\\\\\"#{node.value.to_s.gsub('\"') { '\\\\\\\\\\\"' }}\\\\\\\"\"\n          when :sym\n            autocorrected_value_in_hash_for_symbol(node)\n          when :array\n            autocorrected_value_for_array(node)\n          when :hash\n            autocorrected_value_for_hash(node)\n          else\n            node.source.gsub('\"', '\\\"')\n          end",
    "comment": "rubocop:disable Metrics/MethodLength, Metrics/AbcSize",
    "label": "",
    "id": "630"
  },
  {
    "raw_code": "def prints_as_self?(node)\n          node.basic_literal? ||\n            (COMPOSITE.include?(node.type) && node.children.all? { |child| prints_as_self?(child) })\n        end",
    "comment": "rubocop:enable Metrics/MethodLength, Metrics/AbcSize Does node print its own source when converted to a string?",
    "label": "",
    "id": "631"
  },
  {
    "raw_code": "def on_str(node)\n          return if node.parent&.regexp_type?\n          return unless /(?<!\\\\)#\\{.*\\}/.match?(node.source)\n          return if heredoc?(node)\n          return unless node.loc.begin && node.loc.end\n          return unless valid_syntax?(node)\n\n          add_offense(node) { |corrector| autocorrect(corrector, node) }\n        end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "632"
  },
  {
    "raw_code": "def on_dstr(node)\n          each_bad_cons(node) do |lhs_node, rhs_node|\n            range = lhs_node.source_range.join(rhs_node.source_range)\n            message = format(MSG, lhs: display_str(lhs_node), rhs: display_str(rhs_node))\n            if node.parent&.array_type?\n              message << FOR_ARRAY\n            elsif node.parent&.send_type?\n              message << FOR_METHOD\n            end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/MethodLength, Metrics/PerceivedComplexity",
    "label": "",
    "id": "633"
  },
  {
    "raw_code": "def return_values(block_body_node)\n          nodes = [block_body_node.begin_type? ? block_body_node.child_nodes.last : block_body_node]\n\n          block_body_node.each_descendant(:next, :break) do |n|\n            # Ignore `next`/`break` inside an inner block\n            next if n.each_ancestor(:any_block).first != block_body_node.parent\n            next unless n.first_argument\n\n            nodes << n.first_argument\n          end",
    "comment": "Return values in a block are either the value given to next, the last line of a multiline block, or the only line of the block",
    "label": "",
    "id": "634"
  },
  {
    "raw_code": "def returned_accumulator_index(return_values, accumulator_name, element_name)\n          return_values.detect do |val|\n            next unless accumulator_index?(val, accumulator_name)\n            next true if val.method?(:[]=)\n\n            val.arguments.none? { |arg| lvar_used?(arg, element_name) }\n          end",
    "comment": "Look for an index of the accumulator being returned, except where the index is the element. This is always an offense, in order to try to catch potential exceptions due to type mismatches",
    "label": "",
    "id": "635"
  },
  {
    "raw_code": "def returns_accumulator_anywhere?(return_values, accumulator_name)\n          return_values.any? { |node| lvar_used?(node, accumulator_name) }\n        end",
    "comment": "If the accumulator is used in any return value, the node is acceptable since the accumulator has a chance to change each iteration",
    "label": "",
    "id": "636"
  },
  {
    "raw_code": "def acceptable_return?(return_val, element_name)\n          vars = expression_values(return_val).uniq\n          return true if vars.none? || (vars - [element_name]).any?\n\n          false\n        end",
    "comment": "Determine if a return value is acceptable for the purposes of this cop If it is an expression containing the accumulator, it is acceptable Otherwise, it is only unacceptable if it contains the iterated element, since we otherwise do not have enough information to prevent false positives.",
    "label": "",
    "id": "637"
  },
  {
    "raw_code": "def allowed_type?(parent_node)\n          !parent_node.dstr_type?\n        end",
    "comment": "Exclude `begin` nodes inside a `dstr` from being collected by `return_values`",
    "label": "",
    "id": "638"
  },
  {
    "raw_code": "def call_range_to_safely_reposition(node, heredoc)\n          return nil if calls_on_multiple_lines?(node, heredoc)\n\n          heredoc_end_pos = heredoc_end_pos(heredoc)\n          call_end_pos = call_end_pos(node)\n\n          call_range = range_between(heredoc_end_pos, call_end_pos)\n          call_line_range = call_line_range(node)\n\n          call_source = call_range.source.strip\n          call_line_source = call_line_range.source.strip\n\n          return call_range if call_source == call_line_source\n\n          if trailing_comma?(call_source, call_line_source)\n            # If there's some on the last line other than the call, e.g.\n            # a trailing comma, then we leave the \"\\n\" following the\n            # heredoc_end in place.\n            return range_between(heredoc_end_pos, call_end_pos + 1)\n          end",
    "comment": "Returns nil if no range can be safely repositioned.",
    "label": "",
    "id": "639"
  },
  {
    "raw_code": "def check_child_nodes(node, unused, cur_vis)\n          node.child_nodes.each do |child|\n            if child.send_type? && access_modifier?(child)\n              cur_vis, unused = check_send_node(child, cur_vis, unused)\n            elsif child.block_type? && included_block?(child)\n              next\n            elsif method_definition?(child)\n              unused = nil\n            elsif start_of_new_scope?(child)\n              check_scope(child)\n            elsif !child.defs_type?\n              cur_vis, unused = check_child_nodes(child, unused, cur_vis)\n            end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "640"
  },
  {
    "raw_code": "def check_send_node(node, cur_vis, unused)\n          if node.bare_access_modifier?\n            check_new_visibility(node, unused, node.method_name, cur_vis)\n          elsif node.method?(:private_class_method) && !node.arguments?\n            add_offense(node, message: format(MSG, current: node.method_name)) do |corrector|\n              autocorrect(corrector, node)\n            end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "641"
  },
  {
    "raw_code": "def acceptable?(node)\n          node.begin_type? ||\n            node.literal? || rational_literal?(node) ||\n            node.variable? || node.const_type? || node.self_type? ||\n            (node.call_type? && acceptable_call?(node))\n        end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "642"
  },
  {
    "raw_code": "def acceptable_call?(node)\n          return true if node.unary_operation?\n\n          # Require parentheses when making a method call on a literal\n          # to avoid the ambiguity of `1..2.to_a`.\n          return false if node.receiver&.basic_literal?\n\n          return false if node.operator_method? && !node.method?(:[])\n\n          require_parentheses_for_method_chain? || node.receiver.nil?\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity",
    "label": "",
    "id": "643"
  },
  {
    "raw_code": "def on_csend(node)\n          range = node.loc.dot\n\n          if infer_non_nil_receiver?\n            checker = Lint::Utils::NilReceiverChecker.new(node.receiver, additional_nil_methods)\n\n            if checker.cant_be_nil?\n              add_offense(range, message: MSG_NON_NIL) { |corrector| corrector.replace(range, '.') }\n              return\n            end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "644"
  },
  {
    "raw_code": "def on_or(node)\n          conversion_with_default?(node) do |send_node|\n            range = send_node.loc.dot.begin.join(node.source_range.end)\n\n            add_offense(range, message: MSG_LITERAL) do |corrector|\n              corrector.replace(send_node.loc.dot, '.')\n\n              range_with_default = node.lhs.source_range.end.begin.join(node.source_range.end)\n              corrector.remove(range_with_default)\n            end",
    "comment": "rubocop:enable Metrics/AbcSize rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "645"
  },
  {
    "raw_code": "def each_already_disabled(cop, line_ranges)\n          line_ranges.each_cons(2) do |previous_range, range|\n            next if ignore_offense?(range)\n            # If a cop is disabled in a range that begins on the same line as\n            # the end of the previous range, it means that the cop was\n            # already disabled by an earlier comment. So it's redundant\n            # whether there are offenses or not.\n            next unless followed_ranges?(previous_range, range)\n\n            comment = processed_source.comment_at_line(range.begin)\n\n            next unless comment\n            # Comments disabling all cops don't count since it's reasonable\n            # to disable a few select cops first and then all cops further\n            # down in the code.\n            next if all_disabled?(comment)\n\n            redundant =\n              if department_disabled?(cop, comment)\n                find_redundant_department(cop, range)\n              else\n                cop\n              end",
    "comment": "rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "646"
  },
  {
    "raw_code": "def find_redundant_cop(cop, range)\n          cop_offenses = offenses_to_check.select { |offense| offense.cop_name == cop }\n          cop if range_with_offense?(range, cop_offenses)\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "647"
  },
  {
    "raw_code": "def argument_match?(send_arg, def_arg)\n          def_arg_name = def_arg.children[0]\n\n          case def_arg.type\n          when :arg, :restarg\n            send_arg.source == def_arg.source\n          when :optarg\n            send_arg.source == def_arg_name.to_s\n          when :kwoptarg, :kwarg\n            send_arg.hash_type? &&\n              send_arg.pairs.any? { |pair| passing_keyword_arg?(pair, def_arg_name) }\n          when :kwrestarg\n            send_arg.each_child_node(:kwsplat, :forwarded_kwrestarg).any? do |child|\n              child.source == def_arg.source\n            end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength",
    "label": "",
    "id": "648"
  },
  {
    "raw_code": "def range_with_comma_after(comment, start, begin_pos, end_pos)\n          begin_pos += 1 if comment.source[end_pos + 1] != ' '\n\n          range_between(start + begin_pos, start + end_pos + 1)\n        end",
    "comment": "If the list of cops is comma-separated, but without an empty space after the comma, we should **not** remove the prepending empty space, thus begin_pos += 1",
    "label": "",
    "id": "649"
  },
  {
    "raw_code": "def add_safe_navigation_operator(offense_range:, send_node:)\n          source =\n            if brackets?(send_node)\n              format(\n                '%<method_name>s(%<arguments>s)%<method_chain>s',\n                arguments: send_node.arguments.map(&:source).join(', '),\n                method_name: send_node.method_name,\n                method_chain: send_node.source_range.end.join(send_node.source_range.end).source\n              )\n            else\n              offense_range.source\n            end",
    "comment": "@param [Parser::Source::Range] offense_range @param [RuboCop::AST::SendNode] send_node @return [String]",
    "label": "",
    "id": "650"
  },
  {
    "raw_code": "def autocorrect(corrector, offense_range:, send_node:)\n          corrector.replace(\n            offense_range,\n            add_safe_navigation_operator(offense_range: offense_range, send_node: send_node)\n          )\n\n          corrector.wrap(send_node, '(', ')') if require_parentheses?(send_node)\n        end",
    "comment": "@param [RuboCop::Cop::Corrector] corrector @param [Parser::Source::Range] offense_range @param [RuboCop::AST::SendNode] send_node",
    "label": "",
    "id": "651"
  },
  {
    "raw_code": "def _cant_be_nil?(node, receiver)\n            return false unless node\n\n            # For some nodes, we check their parent and then some children for these parents.\n            # This is added to avoid infinite loops.\n            return false if @checked_nodes.key?(node)\n\n            @checked_nodes[node] = true\n\n            case node.type\n            when :def, :class, :module, :sclass\n              return false\n            when :send\n              return non_nil_method?(node.method_name) if node.receiver == receiver\n\n              node.arguments.each do |argument|\n                return true if _cant_be_nil?(argument, receiver)\n              end",
    "comment": "rubocop:disable Metrics",
    "label": "",
    "id": "652"
  },
  {
    "raw_code": "def non_nil_method?(method_name)\n            !NIL_METHODS.include?(method_name) && !@additional_nil_methods.include?(method_name)\n          end",
    "comment": "rubocop:enable Metrics",
    "label": "",
    "id": "653"
  },
  {
    "raw_code": "def sole_condition_of_parent_if?(node)\n            parent = node.parent\n\n            while parent\n              if parent.if_type?\n                if parent.condition == node\n                  return true\n                elsif parent.elsif?\n                  parent = find_top_if(parent)\n                end",
    "comment": "rubocop:disable Metrics/PerceivedComplexity",
    "label": "",
    "id": "654"
  },
  {
    "raw_code": "def else_branch?(node)\n            node.parent&.if_type? && node.parent.else_branch == node\n          end",
    "comment": "rubocop:enable Metrics/PerceivedComplexity",
    "label": "",
    "id": "655"
  },
  {
    "raw_code": "def explicit?\n          ![ZERO_ARITY_SUPER_TYPE, SEND_TYPE].include?(@node.type)\n        end",
    "comment": "There's an implicit variable reference by the zero-arity `super`:  def some_method(foo) super end  Another case is `binding`:  def some_method(foo) do_something(binding) end  In these cases, the variable `foo` is not explicitly referenced, but it can be considered used implicitly by the `super` or `binding`.",
    "label": "",
    "id": "656"
  },
  {
    "raw_code": "def reference!(node)\n          reference = Reference.new(node, @scope)\n          @references << reference\n          consumed_branches = nil\n\n          @assignments.reverse_each do |assignment|\n            next if consumed_branches&.include?(assignment.branch)\n\n            assignment.reference!(node) unless assignment.run_exclusively_with?(reference)\n\n            # Modifier if/unless conditions are special. Assignments made in\n            # them do not put the assigned variable in scope to the left of the\n            # if/unless keyword. A preceding assignment is needed to put the\n            # variable in scope. For this reason we skip to the next assignment\n            # here.\n            next if in_modifier_conditional?(assignment)\n\n            break if !assignment.branch || assignment.branch == reference.branch\n\n            unless assignment.branch.may_run_incompletely?\n              (consumed_branches ||= Set.new) << assignment.branch\n            end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "657"
  },
  {
    "raw_code": "def in_modifier_conditional?(assignment)\n          parent = assignment.node.parent\n          parent = parent.parent if parent&.begin_type?\n          return false if parent.nil?\n\n          parent.basic_conditional? && parent.modifier_form?\n        end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity",
    "label": "",
    "id": "658"
  },
  {
    "raw_code": "def used?\n          @captured_by_block || referenced?\n        end",
    "comment": "This is a convenient way to check whether the variable is used in its entire variable lifetime. For more precise usage check, refer Assignment#used?.  Once the variable is captured by a block, we have no idea when, where, and how many times the block would be invoked. This means we cannot track the usage of the variable. So we consider it's used to suppress false positive offenses.",
    "label": "",
    "id": "659"
  },
  {
    "raw_code": "def expression\n            @expression ||= origin.adjust(begin_pos: ts, end_pos: ts + full_length)\n          end",
    "comment": "Shortcut to `loc.expression`",
    "label": "",
    "id": "660"
  },
  {
    "raw_code": "def loc\n            @loc ||= Map.new(expression, **build_location)\n          end",
    "comment": "@returns a location map like `parser` does, with: - expression: complete expression - quantifier: for `+`, `{1,2}`, etc. - begin/end: for `[` and `]` (only CharacterSet for now)  E.g. [a-z]{2,} ^^^^^^^^^ expression ^^^^ quantifier ^^^^^     body ^         begin ^     end  Please open issue if you need other locations",
    "label": "",
    "id": "661"
  },
  {
    "raw_code": "def single_line?\n        first_line == last_line\n      end",
    "comment": "Adds `Range#single_line?` to parallel `Node#single_line?`",
    "label": "",
    "id": "662"
  },
  {
    "raw_code": "def dump_pending(*); end\n\n      # The BEGIN/END comments are used by `spec_runner.rake` to determine what\n      # output goes where in the final parallelized output, and should not be\n      # removed!\n      def dump_failures(notification)\n        return if notification.failure_notifications.empty?\n\n        output.puts '# FAILURES BEGIN'\n        notification.failure_notifications.each do |failure|\n          output.puts failure.fully_formatted('*', colorizer)\n        end\n        output.puts\n        output.puts '# FAILURES END'\n      end",
    "comment": "Don't show pending tests",
    "label": "",
    "id": "663"
  },
  {
    "raw_code": "def output_summary(summary)\n        output.puts '# SUMMARY BEGIN'\n        output.puts colorize_summary(summary)\n        output.puts '# SUMMARY END'\n      end",
    "comment": "The BEGIN/END comments are used by `spec_runner.rake` to determine what output goes where in the final parallelized output, and should not be removed!",
    "label": "",
    "id": "664"
  },
  {
    "raw_code": "def output_rerun_commands(summary)\n        output.puts '# RERUN BEGIN'\n        output.puts summary.colorized_rerun_commands.lines[3..].join\n        output.puts '# RERUN END'\n      end",
    "comment": "The BEGIN/END comments are used by `spec_runner.rake` to determine what output goes where in the final parallelized output, and should not be removed!",
    "label": "",
    "id": "665"
  },
  {
    "raw_code": "def expect_offense(source, file = nil, severity: nil, chomp: false, **replacements)\n        expected_annotations = parse_annotations(source, **replacements)\n        source = expected_annotations.plain_source\n        source = source.chomp if chomp\n\n        @processed_source = parse_processed_source(source, file)\n        @offenses = _investigate(cop, @processed_source)\n        actual_annotations = expected_annotations.with_offense_annotations(@offenses)\n\n        expect(actual_annotations).to eq(expected_annotations), ''\n        expect(@offenses.map(&:severity).uniq).to eq([severity]) if severity\n\n        # Validate that all offenses have a range that formatters can display\n        expect do\n          @offenses.each { |offense| offense.location.source_line }\n        end.not_to raise_error, 'One of the offenses has a misconstructed range, for ' \\\n                                'example if the offense is on line 1 and the source is empty'\n\n        @offenses\n      end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "666"
  },
  {
    "raw_code": "def expect_correction(correction, loop: true, source: nil)\n        if source\n          expected_annotations = parse_annotations(source, raise_error: false)\n          @processed_source = parse_processed_source(expected_annotations.plain_source)\n          _investigate(cop, @processed_source)\n        end",
    "comment": "rubocop:enable Metrics/AbcSize rubocop:disable Metrics/AbcSize, Metrics/MethodLength, Metrics/CyclomaticComplexity",
    "label": "",
    "id": "667"
  },
  {
    "raw_code": "def expect_no_corrections\n        raise '`expect_no_corrections` must follow `expect_offense`' unless @processed_source\n\n        return if @last_corrector.empty?\n\n        # This is just here for a pretty diff if the source actually got changed\n        new_source = @last_corrector.rewrite\n        expect(new_source).to eq(@processed_source.buffer.source)\n\n        # There is an infinite loop if a corrector is present that did not make\n        # any changes. It will cause the same offense/correction on the next loop.\n        raise RuboCop::Runner::InfiniteCorrectionLoop.new(@processed_source.path, [@offenses])\n      end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/MethodLength, Metrics/CyclomaticComplexity",
    "label": "",
    "id": "668"
  },
  {
    "raw_code": "def self.parse(annotated_source)\n          source      = []\n          annotations = []\n\n          annotated_source.each_line do |source_line|\n            if ANNOTATION_PATTERN.match?(source_line)\n              annotations << [source.size, source_line]\n            else\n              source << source_line\n            end",
    "comment": "@param annotated_source [String] string passed to the matchers  Separates annotation lines from source lines. Tracks the real source line number that each annotation corresponds to.  @return [AnnotatedSource]",
    "label": "",
    "id": "669"
  },
  {
    "raw_code": "def initialize(lines, annotations)\n          @lines       = lines.freeze\n          @annotations = annotations.sort.freeze\n        end",
    "comment": "@param lines [Array<String>] @param annotations [Array<(Integer, String)>] each entry is the annotated line number and the annotation text  @note annotations are sorted so that reconstructing the annotation text via {#to_s} is deterministic",
    "label": "",
    "id": "670"
  },
  {
    "raw_code": "def match_annotations?(other)\n          annotations.zip(other.annotations) do |(_actual_line, actual_annotation),\n                                                 (_expected_line, expected_annotation)|\n            if expected_annotation&.end_with?(ABBREV) &&\n               actual_annotation.start_with?(expected_annotation[0...-ABBREV.length])\n\n              expected_annotation.replace(actual_annotation)\n            end",
    "comment": "Dirty hack: expectations with [...] are rewritten when they match This way the diff is clean.",
    "label": "",
    "id": "671"
  },
  {
    "raw_code": "def to_s\n          reconstructed = lines.dup\n\n          annotations.reverse_each do |line_number, annotation|\n            reconstructed.insert(line_number, annotation)\n          end",
    "comment": "Construct annotated source string (like what we parse)  Reconstruct a deterministic annotated source string. This is useful for eliminating semantically irrelevant annotation ordering differences.  @example standardization  source1 = AnnotatedSource.parse(<<-RUBY) line1 ^ Annotation 1 ^^ Annotation 2 RUBY  source2 = AnnotatedSource.parse(<<-RUBY) line1 ^^ Annotation 2 ^ Annotation 1 RUBY  source1.to_s == source2.to_s # => true  @return [String]",
    "label": "",
    "id": "672"
  },
  {
    "raw_code": "def plain_source\n          lines.join\n        end",
    "comment": "Return the plain source code without annotations  @return [String]",
    "label": "",
    "id": "673"
  },
  {
    "raw_code": "def with_offense_annotations(offenses)\n          offense_annotations =\n            offenses.map do |offense|\n              indent     = ' ' * offense.column\n              carets     = '^' * offense.column_length\n              carets     = '^{}' if offense.column_length.zero?\n\n              [offense.line, \"#{indent}#{carets} #{offense.message}\\n\"]\n            end",
    "comment": "Annotate the source code with the RuboCop offenses provided  @param offenses [Array<RuboCop::Cop::Offense>]  @return [self]",
    "label": "",
    "id": "674"
  },
  {
    "raw_code": "def source_range(range, buffer: source_buffer)\n    Parser::Source::Range.new(buffer, range.begin,\n                              range.exclude_end? ? range.end : range.end + 1)\n  end",
    "comment": "Utilities",
    "label": "",
    "id": "675"
  },
  {
    "raw_code": "def blank?\n      empty? || lstrip.empty?\n    end",
    "comment": "Checks whether a string is blank. A string is considered blank if it is either empty or contains only whitespace characters.  @return [Boolean] true is the string is blank, false otherwise  @example ''.blank?       #=> true '    '.blank?   #=> true '  test'.blank? #=> false",
    "label": "",
    "id": "676"
  },
  {
    "raw_code": "def run(env, name)\n          class_for(name).new(env).run\n        end",
    "comment": "Find the command with a given name and run it in an environment.",
    "label": "",
    "id": "677"
  },
  {
    "raw_code": "def run(name)\n        Command.run(self, name)\n      end",
    "comment": "Run a command in this environment.",
    "label": "",
    "id": "678"
  },
  {
    "raw_code": "def run_line_length_cop\n          puts Rainbow(PHASE_1).yellow\n          @options[:only] = ['Layout/LineLength']\n          execute_runner\n          @options.delete(:only)\n          @config_store = ConfigStore.new\n          @config_store.apply_options!(@options)\n          # Save the todo configuration of the LineLength cop.\n          File.read(AUTO_GENERATED_FILE).lines.drop_while { |line| line.start_with?('#') }.join\n        end",
    "comment": "Do an initial run with only Layout/LineLength so that cops that depend on Layout/LineLength:Max get the correct value for that parameter.",
    "label": "",
    "id": "679"
  },
  {
    "raw_code": "def process_arguments(argv)\n        server_arguments = delete_server_argument_from(argv)\n\n        detach = !server_arguments.delete('--no-detach')\n\n        if server_arguments.size >= 2\n          return error(\"#{server_arguments.join(', ')} cannot be specified together.\")\n        end",
    "comment": "rubocop:disable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength",
    "label": "",
    "id": "680"
  },
  {
    "raw_code": "def run_command(server_command, detach:)\n        case server_command\n        when '--server'\n          Server::ClientCommand::Start.new(detach: detach).run unless Server.running?\n        when '--no-server'\n          Server::ClientCommand::Stop.new.run if Server.running?\n        when '--restart-server'\n          @exit = true\n          Server::ClientCommand::Restart.new.run\n        when '--start-server'\n          @exit = true\n          Server::ClientCommand::Start.new(detach: detach).run\n        when '--stop-server'\n          @exit = true\n          Server::ClientCommand::Stop.new.run\n        when '--server-status'\n          @exit = true\n          Server::ClientCommand::Status.new.run\n        end",
    "comment": "rubocop:enable Metrics/AbcSize, Metrics/CyclomaticComplexity, Metrics/MethodLength rubocop:disable Metrics/CyclomaticComplexity, Metrics/MethodLength",
    "label": "",
    "id": "681"
  },
  {
    "raw_code": "def fetch_cache_root_path_from(arguments)\n        cache_root = arguments.detect { |argument| argument.start_with?('--cache-root') }\n        return unless cache_root\n\n        if cache_root.start_with?('--cache-root=')\n          cache_root.split('=')[1]\n        else\n          arguments[arguments.index(cache_root) + 1]\n        end",
    "comment": "rubocop:enable Metrics/CyclomaticComplexity, Metrics/MethodLength",
    "label": "",
    "id": "682"
  },
  {
    "raw_code": "def project_dir\n          current_dir = Dir.pwd\n          while current_dir != '/'\n            return current_dir if GEMFILE_NAMES.any? do |gemfile|\n              File.exist?(File.join(current_dir, gemfile))\n            end",
    "comment": "Searches for Gemfile or gems.rb in the current dir or any parent dirs",
    "label": "",
    "id": "683"
  },
  {
    "raw_code": "def restart_key(args_config_file_path: nil)\n          lockfile_path = LOCKFILE_NAMES.map do |lockfile_name|\n            Pathname(project_dir).join(lockfile_name)\n          end.find(&:exist?)\n          version_data = lockfile_path&.read || RuboCop::Version::STRING\n          config_data = Pathname(\n            args_config_file_path || ConfigFinder.find_config_path(Dir.pwd)\n          ).read\n          yaml = load_erb_templated_yaml(config_data)\n\n          inherit_from_data = inherit_from_data(yaml)\n          require_data = require_data(yaml)\n\n          Digest::SHA1.hexdigest(version_data + config_data + inherit_from_data + require_data)\n        end",
    "comment": "rubocop:disable Metrics/AbcSize",
    "label": "",
    "id": "684"
  },
  {
    "raw_code": "def dir\n          Pathname.new(File.join(cache_path, project_dir_cache_key)).tap do |d|\n            d.mkpath unless d.exist?\n          end",
    "comment": "rubocop:enable Metrics/AbcSize",
    "label": "",
    "id": "685"
  },
  {
    "raw_code": "def warning?\n        false\n      end",
    "comment": "Cop rules currently can only be failures, not warnings",
    "label": "",
    "id": "686"
  },
  {
    "raw_code": "def cop_rule?\n        false\n      end",
    "comment": "Does this rule relate to cops?",
    "label": "",
    "id": "687"
  },
  {
    "raw_code": "def parameter_rule?\n        false\n      end",
    "comment": "Does this rule relate to parameters?",
    "label": "",
    "id": "688"
  },
  {
    "raw_code": "def register_additional_file_watchers(global_state, message_queue)\n        return unless global_state.supports_watching_files\n\n        message_queue << Request.new(\n          id: 'rubocop-file-watcher',\n          method: 'client/registerCapability',\n          params: Interface::RegistrationParams.new(\n            registrations: [\n              Interface::Registration.new(\n                id: 'workspace/didChangeWatchedFilesRuboCop',\n                method: 'workspace/didChangeWatchedFiles',\n                register_options: Interface::DidChangeWatchedFilesRegistrationOptions.new(\n                  watchers: [\n                    Interface::FileSystemWatcher.new(\n                      glob_pattern: \"**/{#{RESTART_WATCHERS.join(',')}}\",\n                      kind: Constant::WatchKind::CREATE | Constant::WatchKind::CHANGE | Constant::WatchKind::DELETE\n                    )\n                  ]\n                )\n              )\n            ]\n          )\n        )\n      end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "689"
  },
  {
    "raw_code": "def workspace_did_change_watched_files(changes)\n        if (changed_config_file = changed_config_file(changes))\n          @runtime_adapter.reload_config\n\n          ::RuboCop::LSP::Logger.log(<<~MESSAGE, prefix: '[RuboCop]')\n            Re-initialized RuboCop LSP addon #{::RuboCop::Version::STRING} due to #{changed_config_file} change.\n          MESSAGE\n        end",
    "comment": "rubocop:enable Metrics/MethodLength",
    "label": "",
    "id": "690"
  },
  {
    "raw_code": "def uri_to_path(uri)\n        if uri.respond_to?(:to_standardized_path) && (standardized_path = uri.to_standardized_path)\n          standardized_path\n        else\n          uri.to_s.delete_prefix('file://')\n        end",
    "comment": "duplicated from: lib/standard/lsp/routes.rb modified to incorporate Ruby LSP's to_standardized_path method",
    "label": "",
    "id": "691"
  },
  {
    "raw_code": "def parse_release(unreleased)\n    unreleased\n      .lines\n      .map(&:chomp)\n      .reject(&:empty?)\n      .slice_before(HEADER)\n      .to_h do |header, *entries|\n        [HEADER.match(header)[1], entries]\n      end",
    "comment": "@return [Hash<type, Array<String>]]",
    "label": "",
    "id": "692"
  },
  {
    "raw_code": "def index\n    @books = Book.all\n  end",
    "comment": "GET /books GET /books.json",
    "label": "",
    "id": "693"
  },
  {
    "raw_code": "def show\n  end",
    "comment": "GET /books/1 GET /books/1.json",
    "label": "",
    "id": "694"
  },
  {
    "raw_code": "def new\n    @book = Book.new\n  end",
    "comment": "GET /books/new",
    "label": "",
    "id": "695"
  },
  {
    "raw_code": "def edit\n  end",
    "comment": "GET /books/1/edit",
    "label": "",
    "id": "696"
  },
  {
    "raw_code": "def create\n    @book = Book.new(book_params)\n\n    respond_to do |format|\n      if @book.save\n        format.html { redirect_to @book, notice: 'Book was successfully created.' } # aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n        format.json { render :show, status: :created, location: @book }\n      else\n        format.html { render :new }\n        format.json { render json: @book.errors, status: :unprocessable_entity }\n      end",
    "comment": "POST /books POST /books.json",
    "label": "",
    "id": "697"
  },
  {
    "raw_code": "def update\n    respond_to do |format|\n      if @book.update(book_params)\n        format.html { redirect_to @book, notice: 'Book was successfully updated.' } # aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n        format.json { render :show, status: :ok, location: @book }\n      else\n        format.html { render :edit }\n        format.json { render json: @book.errors, status: :unprocessable_entity }\n      end",
    "comment": "PATCH/PUT /books/1 PATCH/PUT /books/1.json",
    "label": "",
    "id": "698"
  },
  {
    "raw_code": "def destroy\n    @book.destroy\n    respond_to do |format|\n      format.html { redirect_to books_url, notice: 'Book was successfully destroyed.' } # aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n      format.json { head :no_content }\n    end",
    "comment": "DELETE /books/1 DELETE /books/1.json",
    "label": "",
    "id": "699"
  },
  {
    "raw_code": "def set_book\n      @book = Book.find(params[:id])\n    end",
    "comment": "Use callbacks to share common setup or constraints between actions.",
    "label": "",
    "id": "700"
  },
  {
    "raw_code": "def book_params\n      params.require(:book).permit(:name)\n    end",
    "comment": "Never trust parameters from the scary internet, only allow the allow list through. aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    "label": "",
    "id": "701"
  },
  {
    "raw_code": "def index\n    @books = Book.all\n  end",
    "comment": "GET /books GET /books.json",
    "label": "",
    "id": "702"
  },
  {
    "raw_code": "def show\n  end",
    "comment": "GET /books/1 GET /books/1.json",
    "label": "",
    "id": "703"
  },
  {
    "raw_code": "def new\n    @book = Book.new\n  end",
    "comment": "GET /books/new",
    "label": "",
    "id": "704"
  },
  {
    "raw_code": "def edit\n  end",
    "comment": "GET /books/1/edit",
    "label": "",
    "id": "705"
  },
  {
    "raw_code": "def create\n    @book = Book.new(book_params)\n\n    respond_to do |format|\n      if @book.save\n        format.html { redirect_to @book, notice: 'Book was successfully created.' } # aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n        format.json { render :show, status: :created, location: @book }\n      else\n        format.html { render :new }\n        format.json { render json: @book.errors, status: :unprocessable_entity }\n      end",
    "comment": "POST /books POST /books.json",
    "label": "",
    "id": "706"
  },
  {
    "raw_code": "def update\n    respond_to do |format|\n      if @book.update(book_params)\n        format.html { redirect_to @book, notice: 'Book was successfully updated.' } # aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n        format.json { render :show, status: :ok, location: @book }\n      else\n        format.html { render :edit }\n        format.json { render json: @book.errors, status: :unprocessable_entity }\n      end",
    "comment": "PATCH/PUT /books/1 PATCH/PUT /books/1.json",
    "label": "",
    "id": "707"
  },
  {
    "raw_code": "def destroy\n    @book.destroy\n    respond_to do |format|\n      format.html { redirect_to books_url, notice: 'Book was successfully destroyed.' } # aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n      format.json { head :no_content }\n    end",
    "comment": "DELETE /books/1 DELETE /books/1.json",
    "label": "",
    "id": "708"
  },
  {
    "raw_code": "def set_book\n      @book = Book.find(params[:id])\n    end",
    "comment": "Use callbacks to share common setup or constraints between actions.",
    "label": "",
    "id": "709"
  },
  {
    "raw_code": "def book_params\n      params.require(:book).permit(:name)\n    end",
    "comment": "Never trust parameters from the scary internet, only allow the allow list through. aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
    "label": "",
    "id": "710"
  },
  {
    "raw_code": "def meow\n                puts('Meow!')\n              end",
    "comment": "A feline creature {parent} Cat",
    "label": "",
    "id": "711"
  },
  {
    "raw_code": "def method(foo, bar, qux, fred, arg5, f) end #{'#' * 85}\n        RUBY\n\n        create_file('rubocop.yml', <<~YAML)\n          #{key}:\n            Severity: error\n          Metrics/ParameterLists:\n            Severity: convention\n        YAML\n\n        cli.run(%w[--format simple -c rubocop.yml])\n        expect($stdout.string).to eq(<<~RESULT)\n          == example/example1.rb ==\n          C:  3: 11: Metrics/ParameterLists: Avoid parameter lists longer than 5 parameters. [6/5]\n          C:  3: 39: Naming/MethodParameterName: Method parameter must be at least 3 characters long.\n          C:  3: 46: [Correctable] Style/CommentedKeyword: Do not place comments on the same line as the def keyword.\n          E:  3:121: Layout/LineLength: Line is too long. [130/120]\n\n          1 file inspected, 4 offenses detected, 1 offense autocorrectable\n        RESULT\n        expect($stderr.string).to eq('')\n      end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "712"
  },
  {
    "raw_code": "def expect_autocorrect_options_for_fix_layout\n      options_keys = options.instance_variable_get(:@options).keys\n      expect(options_keys).to include(:fix_layout)\n      expect(options_keys).to include(:autocorrect)\n      expect(options_keys).not_to include(:safe_autocorrect)\n      expect(options_keys).not_to include(:autocorrect_all)\n    end",
    "comment": "rubocop:enable Naming/InclusiveLanguage",
    "label": "",
    "id": "713"
  },
  {
    "raw_code": "def some_method\n          puts 'foo'                                                        # 03\n        end",
    "comment": "rubocop:disable Metrics/MethodLength with a comment why",
    "label": "",
    "id": "714"
  },
  {
    "raw_code": "def some_method\n          puts 'foo'\n        end",
    "comment": "rubocop:disable Metrics/MethodLength with a comment why",
    "label": "",
    "id": "715"
  },
  {
    "raw_code": "def some_method\n          puts 'foo'\n        end",
    "comment": "rubocop:enable Metrics/MethodLength, Security/Eval",
    "label": "",
    "id": "716"
  },
  {
    "raw_code": "def some_method\n          puts 'foo'\n        end",
    "comment": "rubocop:disable Metrics/MethodLength                                01",
    "label": "",
    "id": "717"
  },
  {
    "raw_code": "def valid_code; end\n      RUBY\n\n      it 'returns true' do\n        expect(runner.run([])).to be true\n      end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "718"
  },
  {
    "raw_code": "def INVALID_CODE; end\n      RUBY\n\n      it 'returns false' do\n        expect(runner.run([])).to be false\n      end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "719"
  },
  {
    "raw_code": "def valid_code; end\n                RUBY\n              },\n              {\n                offset: 2,\n                processed_source: RuboCop::ProcessedSource.new(source, 3.3, 'dummy.rb', parser_engine: parser_engine)\n              }\n            ]\n          end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "720"
  },
  {
    "raw_code": "def INVALID_CODE; end\n          RUBY\n        end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "721"
  },
  {
    "raw_code": "def INVALID_CODE; end\n        RUBY\n\n        it 'sends the offense to a formatter' do\n          runner.run([])\n          expect(formatter_output).to eq <<~RESULT\n            Inspecting 1 file\n            C\n\n            Offenses:\n\n            example.rb:3:5: C: Naming/MethodName: Use snake_case for method names.\n            def INVALID_CODE; end\n                ^^^^^^^^^^^^\n\n            1 file inspected, 1 offense detected\n          RESULT\n        end\n      end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "722"
  },
  {
    "raw_code": "def foo; end\n        RUBY\n\n        shared_examples 'error handling' do\n          it 'raises an error with the crashing extractor/file' do\n            expect do\n              runner.run([])\n            end.to raise_error(RuboCop::Error, /runner_spec\\.rb failed to process .*example\\.rb/)\n          end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "723"
  },
  {
    "raw_code": "def INVALID_CODE; end\n          RUBY\n        }\n      end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "724"
  },
  {
    "raw_code": "def foo\n            # foo 2\n          end",
    "comment": "foo 1",
    "label": "",
    "id": "725"
  },
  {
    "raw_code": "def bar\n            # bar 2\n          end",
    "comment": "bar 1",
    "label": "",
    "id": "726"
  },
  {
    "raw_code": "def baz\n            # baz 2\n          end",
    "comment": "baz 1",
    "label": "",
    "id": "727"
  },
  {
    "raw_code": "def bar\n          # bar 2\n        end",
    "comment": "bar 1",
    "label": "",
    "id": "728"
  },
  {
    "raw_code": "def on_send(node)\n                  return unless bad_method?(node)\n\n                  add_offense(node)\n                end",
    "comment": "Called on every `send` node (method call) while walking the AST. TODO: remove this method if inspecting `send` nodes is unneeded for your cop. By default, this is aliased to `on_csend` as well to handle method calls with safe navigation, remove the alias if this is unnecessary. If kept, ensure your tests cover safe navigation as well!",
    "label": "",
    "id": "729"
  },
  {
    "raw_code": "def self.Model(source)\n            end",
    "comment": "{kind} Sequel",
    "label": "",
    "id": "730"
  },
  {
    "raw_code": "def method\n              end",
    "comment": "{bom}class Test",
    "label": "",
    "id": "731"
  },
  {
    "raw_code": "def baz\n          ^{} Use 2 (not 0) spaces for indentation.\n          do_something\n          ^{} Use 2 (not 0) spaces for indentation.\n          end",
    "comment": "The method has no block comment inside, but it's within a class that has a block comment, so it's not corrected either.",
    "label": "",
    "id": "732"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "comment",
    "label": "",
    "id": "733"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "comment",
    "label": "",
    "id": "734"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "comment",
    "label": "",
    "id": "735"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "comment",
    "label": "",
    "id": "736"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "comment comment",
    "label": "",
    "id": "737"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "comment comment",
    "label": "",
    "id": "738"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "rubocop:disable Department/Cop",
    "label": "",
    "id": "739"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "rubocop:disable Department/Cop",
    "label": "",
    "id": "740"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "rubocop:enable Department/Cop",
    "label": "",
    "id": "741"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "rubocop:enable Department/Cop",
    "label": "",
    "id": "742"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "rubocop:enable Department/Cop comment",
    "label": "",
    "id": "743"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "rubocop:enable Department/Cop comment",
    "label": "",
    "id": "744"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "rubocop:enable Department/Cop",
    "label": "",
    "id": "745"
  },
  {
    "raw_code": "def do_something\n      end",
    "comment": "comment",
    "label": "",
    "id": "746"
  },
  {
    "raw_code": "def p\n        end",
    "comment": "checks something",
    "label": "",
    "id": "747"
  },
  {
    "raw_code": "def m\n      end",
    "comment": "123",
    "label": "",
    "id": "748"
  },
  {
    "raw_code": "def m\n        end",
    "comment": "calculates value",
    "label": "",
    "id": "749"
  },
  {
    "raw_code": "def n\n        end",
    "comment": "calculates size",
    "label": "",
    "id": "750"
  },
  {
    "raw_code": "def html_escape(s)\n        end",
    "comment": "def html_escape",
    "label": "",
    "id": "751"
  },
  {
    "raw_code": "def foo; end\n        RUBY\n      end",
    "comment": ": ( |   Integer, |   String | ) -> void",
    "label": "",
    "id": "752"
  },
  {
    "raw_code": "def foo #\n              ^ Source code comment is empty.\n        something\n      end",
    "comment": "comment",
    "label": "",
    "id": "753"
  },
  {
    "raw_code": "def foo\n        something\n      end",
    "comment": "comment",
    "label": "",
    "id": "754"
  },
  {
    "raw_code": "def hello\n        end",
    "comment": "Description of `hello` method.",
    "label": "",
    "id": "755"
  },
  {
    "raw_code": "def hello\n        end",
    "comment": " Description of `hello` method. ",
    "label": "",
    "id": "756"
  },
  {
    "raw_code": "def hello\n        end",
    "comment": " Description of `hello` method. ",
    "label": "",
    "id": "757"
  },
  {
    "raw_code": "def hello\n        end",
    "comment": "Description of `hello` method.",
    "label": "",
    "id": "758"
  },
  {
    "raw_code": "def do_something\n        end",
    "comment": "{method} Foo",
    "label": "",
    "id": "759"
  },
  {
    "raw_code": "def do_something\n        end",
    "comment": "{method} Foo # my comment",
    "label": "",
    "id": "760"
  },
  {
    "raw_code": "def do_something\n        end",
    "comment": "my comment",
    "label": "",
    "id": "761"
  },
  {
    "raw_code": "def do_something\n        end",
    "comment": "{method} Foo my comment",
    "label": "",
    "id": "762"
  },
  {
    "raw_code": "def do_something\n        end",
    "comment": "rubocop:enable Department/Cop",
    "label": "",
    "id": "763"
  },
  {
    "raw_code": "def do_something\n        end",
    "comment": "rubocop:disable Department/Cop {method} Foo rubocop:enable Department/Cop",
    "label": "",
    "id": "764"
  },
  {
    "raw_code": "def do_something\n        end",
    "comment": "rubocop:enable Department/Cop comment",
    "label": "",
    "id": "765"
  },
  {
    "raw_code": "def do_something\n        end",
    "comment": "rubocop:disable Department/Cop {method} Foo rubocop:enable Department/Cop comment",
    "label": "",
    "id": "766"
  },
  {
    "raw_code": "def do_something\n          end",
    "comment": "{method} Bar, Baz",
    "label": "",
    "id": "767"
  },
  {
    "raw_code": "def do_something\n          end",
    "comment": "{method} Foo",
    "label": "",
    "id": "768"
  },
  {
    "raw_code": "def do_something\n          end",
    "comment": "{method} Foo",
    "label": "",
    "id": "769"
  },
  {
    "raw_code": "def do_something\n        end",
    "comment": "rubocop:disable Department/Cop {method} Foo rubocop:enable Department/Cop",
    "label": "",
    "id": "770"
  },
  {
    "raw_code": "def do_something\n        end",
    "comment": "{method} Foo",
    "label": "",
    "id": "771"
  },
  {
    "raw_code": "def do_something\n        end",
    "comment": "{method} Foo {method} Foo",
    "label": "",
    "id": "772"
  },
  {
    "raw_code": "def test; end\n        RUBY\n      end",
    "comment": "d",
    "label": "",
    "id": "773"
  },
  {
    "raw_code": "def m\n            #\n            if a\n              #\n              b\n            # this is accepted\n            elsif aa\n              # this is accepted\n            else\n              #\n            end",
    "comment": "***",
    "label": "",
    "id": "774"
  },
  {
    "raw_code": "def foo\n          end",
    "comment": "rubocop:disable",
    "label": "",
    "id": "775"
  },
  {
    "raw_code": "def foo\n          end",
    "comment": "rubocop:disable",
    "label": "",
    "id": "776"
  },
  {
    "raw_code": "def self.some_method\n          end",
    "comment": "public class methods are next in line",
    "label": "",
    "id": "777"
  },
  {
    "raw_code": "def initialize\n          end",
    "comment": "initialization goes between class methods and other instance methods",
    "label": "",
    "id": "778"
  },
  {
    "raw_code": "def some_method\n          end",
    "comment": "followed by other public instance methods",
    "label": "",
    "id": "779"
  },
  {
    "raw_code": "def meow_at_3am?\n              rand < 0.8\n            end",
    "comment": "Here we go back an indentation level again. This is a violation of the indented_internal_methods style, but it's not for this cop to report. Layout/IndentationWidth will handle it.",
    "label": "",
    "id": "780"
  },
  {
    "raw_code": "def meow_at_4am?\n              rand < 0.8\n            end",
    "comment": "As long as the indentation of this method is consistent with that of the last one, we're fine.",
    "label": "",
    "id": "781"
  },
  {
    "raw_code": "def meow_at_3am?\n              rand < 0.8\n            end",
    "comment": "Here we go back an indentation level again. This is a violation of the indented_internal_methods style, but it's not for this cop to report. Layout/IndentationWidth will handle it.",
    "label": "",
    "id": "782"
  },
  {
    "raw_code": "def meow_at_4am?\n              rand < 0.8\n            end",
    "comment": "As long as the indentation of this method is consistent with that of the last one, we're fine.",
    "label": "",
    "id": "783"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier} {'^' * access_modifier.size} Keep a blank line before and after `#{access_modifier}`.",
    "label": "",
    "id": "784"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "785"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier} {'^' * access_modifier.size} Keep a blank line before and after `#{access_modifier}`.",
    "label": "",
    "id": "786"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "787"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "This comment is fine {access_modifier}",
    "label": "",
    "id": "788"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier} # let's modify the rest {'^' * access_modifier.size} Keep a blank line before and after `#{access_modifier}`.",
    "label": "",
    "id": "789"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier} # let's modify the rest",
    "label": "",
    "id": "790"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "791"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "792"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "793"
  },
  {
    "raw_code": "def do_something\n            end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "794"
  },
  {
    "raw_code": "def do_something\n            end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "795"
  },
  {
    "raw_code": "def do_something\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "796"
  },
  {
    "raw_code": "def test\n            end",
    "comment": "{access_modifier} {'^' * access_modifier.size} Keep a blank line after `#{access_modifier}`.",
    "label": "",
    "id": "797"
  },
  {
    "raw_code": "def do_something\n          end",
    "comment": "comment {access_modifier}",
    "label": "",
    "id": "798"
  },
  {
    "raw_code": "def test; end\n              end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "799"
  },
  {
    "raw_code": "def test; end\n              end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "800"
  },
  {
    "raw_code": "def test\n                end",
    "comment": "{access_modifier} {'^' * access_modifier.size} Keep a blank line after `#{access_modifier}`.",
    "label": "",
    "id": "801"
  },
  {
    "raw_code": "def test; end\n              }\n            RUBY\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "802"
  },
  {
    "raw_code": "def test; end\n              }\n            RUBY\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "803"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "804"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier} {'^' * access_modifier.size} Remove a blank line after `#{access_modifier}`.",
    "label": "",
    "id": "805"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "806"
  },
  {
    "raw_code": "def do_something\n            end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "807"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier} {'^' * access_modifier.size} Keep a blank line before `#{access_modifier}`.",
    "label": "",
    "id": "808"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "809"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier} {'^' * access_modifier.size} Keep a blank line before and after `#{access_modifier}`.",
    "label": "",
    "id": "810"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "811"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier} {'^' * access_modifier.size} Keep a blank line before and after `#{access_modifier}`.",
    "label": "",
    "id": "812"
  },
  {
    "raw_code": "def test; end\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "813"
  },
  {
    "raw_code": "def \\#{unsafe_method}(*params, &block)\n            to_str.\\#{unsafe_method}(*params, &block)\n          end",
    "comment": "def capitalize(*params, &block) to_str.capitalize(*params, &block) end",
    "label": "",
    "id": "814"
  },
  {
    "raw_code": "def \\#{unsafe_method}(*params, &block)\n            to_str.\\#{unsafe_method}(*params, &block) # { note: etc. }\n          end",
    "comment": "def capitalize(*params, &block) to_str.capitalize(*params, &block) end",
    "label": "",
    "id": "815"
  },
  {
    "raw_code": "def \\#{unsafe_method}(*params, &block)\n            to_str.\\#{unsafe_method}(*params, &block)\n          end",
    "comment": "EXAMPLE: def capitalize(*params, &block) to_str.capitalize(*params, &block) end",
    "label": "",
    "id": "816"
  },
  {
    "raw_code": "def \\#{unsafe_method}(*params, &block)\n            to_str.\\#{unsafe_method}(*params, &block)\n          end",
    "comment": "def capitalize(*params, &block) to_str.capitalize(*params, &block) end  def capitalize!(*params) @dirty = true super end",
    "label": "",
    "id": "817"
  },
  {
    "raw_code": "def \\#{unsafe_method}(*params, &block)\n            to_str.\\#{unsafe_method}(*params, &block)\n          end",
    "comment": "def capitalize(*params, &block) to_str.capitalize(*params, &block) end",
    "label": "",
    "id": "818"
  },
  {
    "raw_code": "def \\#{unsafe_method}!(*params)\n            @dirty = true\n            super\n          end",
    "comment": "def capitalize!(*params) @dirty = true super end",
    "label": "",
    "id": "819"
  },
  {
    "raw_code": "def \\#{unsafe_method}(*params, &block)\n            to_str.\\#{unsafe_method}(*params, &block)\n          end",
    "comment": "def capitalize(*params, &block) str.capitalize(*params, &block) end",
    "label": "",
    "id": "820"
  },
  {
    "raw_code": "def foobar\n            if %{variable}\n            ^^^^{variable} Use safe navigation (`&.`) instead [...]\n              # comment 2\n              %{variable}.bar\n            end",
    "comment": "comment one",
    "label": "",
    "id": "821"
  },
  {
    "raw_code": "def foobar\n            # comment 2\n          #{variable}&.bar\n          end",
    "comment": "comment one",
    "label": "",
    "id": "822"
  },
  {
    "raw_code": "def x\n        y\n      end",
    "comment": "comment",
    "label": "",
    "id": "823"
  },
  {
    "raw_code": "def x(a, b)\n        y\n      end",
    "comment": "comment",
    "label": "",
    "id": "824"
  },
  {
    "raw_code": "def x\n        end",
    "comment": "steep",
    "label": "",
    "id": "825"
  },
  {
    "raw_code": "def x\n        end",
    "comment": "steep:ignore",
    "label": "",
    "id": "826"
  },
  {
    "raw_code": "def x\n        end",
    "comment": "steep:ignoreMethodBodyTypeMismatch",
    "label": "",
    "id": "827"
  },
  {
    "raw_code": "def foo\n      end",
    "comment": "comment line 1  comment line 2",
    "label": "",
    "id": "828"
  },
  {
    "raw_code": "def two\n            end",
    "comment": "Multiline comment.",
    "label": "",
    "id": "829"
  },
  {
    "raw_code": "def self.two\n          end",
    "comment": "Multiline comment.",
    "label": "",
    "id": "830"
  },
  {
    "raw_code": "def foo = true\n              end",
    "comment": "{operator} bar",
    "label": "",
    "id": "831"
  },
  {
    "raw_code": "def foo; end\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "832"
  },
  {
    "raw_code": "def foo; end\n        RUBY\n      end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "833"
  },
  {
    "raw_code": "def foo; end\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "834"
  },
  {
    "raw_code": "def foo; end\n          end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "835"
  },
  {
    "raw_code": "def foo; end\n            end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "836"
  },
  {
    "raw_code": "def foo; end\n            end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "837"
  },
  {
    "raw_code": "def foo; end\n            end",
    "comment": "{access_modifier}",
    "label": "",
    "id": "838"
  },
  {
    "raw_code": "def foo\n                # comment\n              end",
    "comment": "{access_modifier} comment",
    "label": "",
    "id": "839"
  },
  {
    "raw_code": "def bar; end\n            end",
    "comment": "{access_modifier} get_method_name if get_method_name =~ /a/ {access_modifier}",
    "label": "",
    "id": "840"
  },
  {
    "raw_code": "def bar; end\n            end",
    "comment": "{access_modifier} get_method_name_1 if get_method_name_1 =~ /a/ {access_modifier} get_method_name_2 if get_method_name_2 =~ /b/ {access_modifier}",
    "label": "",
    "id": "841"
  },
  {
    "raw_code": "def foo; end\n          end",
    "comment": "{access_modifier} :foo",
    "label": "",
    "id": "842"
  },
  {
    "raw_code": "def method\n              end",
    "comment": "documentation comment {keyword} Test",
    "label": "",
    "id": "843"
  },
  {
    "raw_code": "def method\n            end",
    "comment": "{keyword} Test #:nodoc:",
    "label": "",
    "id": "844"
  },
  {
    "raw_code": "def method\n            end",
    "comment": "{keyword} A::B::Test #:nodoc:",
    "label": "",
    "id": "845"
  },
  {
    "raw_code": "def foo\n            puts 'bar'\n          end",
    "comment": "Documentation",
    "label": "",
    "id": "846"
  },
  {
    "raw_code": "def foo; end\n        RUBY\n      end",
    "comment": "Documentation",
    "label": "",
    "id": "847"
  },
  {
    "raw_code": "def foo\n              puts 'bar'\n            end",
    "comment": "Documentation",
    "label": "",
    "id": "848"
  },
  {
    "raw_code": "def foo\n              puts 'bar'\n            end",
    "comment": "Documentation",
    "label": "",
    "id": "849"
  },
  {
    "raw_code": "def bar\n                  puts 'baz'\n                end",
    "comment": "Documentation",
    "label": "",
    "id": "850"
  },
  {
    "raw_code": "def bar; end\n              end",
    "comment": "Documentation",
    "label": "",
    "id": "851"
  },
  {
    "raw_code": "def bar\n              ^^^^^^^ Missing method documentation comment.\n                puts 'baz'\n              end",
    "comment": "FIXME: offense",
    "label": "",
    "id": "852"
  },
  {
    "raw_code": "def bar\n              ^^^^^^^ Missing method documentation comment.\n                puts 'baz'\n              end",
    "comment": "rubocop:disable Style/For",
    "label": "",
    "id": "853"
  },
  {
    "raw_code": "def bar\n                  puts 'baz'\n                end",
    "comment": "Documentation",
    "label": "",
    "id": "854"
  },
  {
    "raw_code": "def bar\n                  puts 'baz'\n                end",
    "comment": "Documentation",
    "label": "",
    "id": "855"
  },
  {
    "raw_code": "def bar\n                  puts 'baz'\n                end",
    "comment": "Documentation",
    "label": "",
    "id": "856"
  },
  {
    "raw_code": "def bar; end\n              end",
    "comment": "Documentation",
    "label": "",
    "id": "857"
  },
  {
    "raw_code": "def bar; end\n\n                module_function :bar\n              end",
    "comment": "Documentation",
    "label": "",
    "id": "858"
  },
  {
    "raw_code": "def bar\n                  puts 'baz'\n                end",
    "comment": "Documentation",
    "label": "",
    "id": "859"
  },
  {
    "raw_code": "def bar\n                  puts 'baz'\n                end",
    "comment": "Documentation",
    "label": "",
    "id": "860"
  },
  {
    "raw_code": "def foo.bar\n              puts 'baz'\n            end",
    "comment": "Documentation",
    "label": "",
    "id": "861"
  },
  {
    "raw_code": "def foo.bar; end\n          RUBY\n        end",
    "comment": "Documentation",
    "label": "",
    "id": "862"
  },
  {
    "raw_code": "def foo.bar\n                  puts 'baz'\n                end",
    "comment": "Documentation",
    "label": "",
    "id": "863"
  },
  {
    "raw_code": "def foo.bar\n                  puts 'baz'\n                end",
    "comment": "Documentation",
    "label": "",
    "id": "864"
  },
  {
    "raw_code": "def foo() end\n    RUBY\n  end",
    "comment": "encoding: us-ascii",
    "label": "",
    "id": "865"
  },
  {
    "raw_code": "def foo() end\n    RUBY\n  end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "866"
  },
  {
    "raw_code": "def some_method\n            implement 1\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "867"
  },
  {
    "raw_code": "def some_method\n            implement 1\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "868"
  },
  {
    "raw_code": "def self.some_method\n            implement 1\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "869"
  },
  {
    "raw_code": "def self.some_method\n            implement 1\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "870"
  },
  {
    "raw_code": "def some_method\n            implement 1\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "871"
  },
  {
    "raw_code": "def some_method\n            implement 1\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "872"
  },
  {
    "raw_code": "def some_method\n            implement 1\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "873"
  },
  {
    "raw_code": "def some_method\n          ^^^^^^^^^^^^^^^ Method `A#some_method` is defined at both dups.rb:2 and dups.rb:7.\n            implement 2\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "874"
  },
  {
    "raw_code": "def self.some_method\n            implement 1\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "875"
  },
  {
    "raw_code": "def self.some_method\n          ^^^^^^^^^^^^^^^^^^^^ Method `A.some_method` is defined at both test.rb:2 and test.rb:7.\n            implement 2\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "876"
  },
  {
    "raw_code": "def some_method\n            implement 1\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "877"
  },
  {
    "raw_code": "def some_method\n          ^^^^^^^^^^^^^^^ Method `A#some_method` is defined at both first.rb:2 and second.rb:2.\n            implement 2\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "878"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "879"
  },
  {
    "raw_code": "def some_method\n            implement 1\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "880"
  },
  {
    "raw_code": "def some_method\n            implement 1\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "881"
  },
  {
    "raw_code": "def some_method\n            implement 1\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "882"
  },
  {
    "raw_code": "def some_method\n            implement 1\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "883"
  },
  {
    "raw_code": "def something\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "884"
  },
  {
    "raw_code": "def something=(right)\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "885"
  },
  {
    "raw_code": "def something\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "886"
  },
  {
    "raw_code": "def something=(right)\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "887"
  },
  {
    "raw_code": "def something\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "888"
  },
  {
    "raw_code": "def foo\n            def some_method\n              implement 1\n            end\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "889"
  },
  {
    "raw_code": "def self.foo\n            def some_method\n              implement 1\n            end\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "890"
  },
  {
    "raw_code": "def foo\n            def some_method\n              implement 1\n            end\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "891"
  },
  {
    "raw_code": "def self.foo\n            def some_method\n              implement 1\n            end\n          end",
    "comment": "{opening_line}",
    "label": "",
    "id": "892"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "893"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "894"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "895"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "896"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "897"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "898"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "899"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "900"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "901"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "902"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "903"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "904"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "905"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "906"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "907"
  },
  {
    "raw_code": "def some_method\n              implement 1\n            end",
    "comment": "{opening_line}",
    "label": "",
    "id": "908"
  },
  {
    "raw_code": "def A.some_method\n            implement 1\n          end",
    "comment": "{type} A",
    "label": "",
    "id": "909"
  },
  {
    "raw_code": "def self.some_method\n            implement 1\n          end",
    "comment": "{type} A",
    "label": "",
    "id": "910"
  },
  {
    "raw_code": "def my_method\n              end",
    "comment": "@api private",
    "label": "",
    "id": "911"
  },
  {
    "raw_code": "def my_method\n              end",
    "comment": "@api private",
    "label": "",
    "id": "912"
  },
  {
    "raw_code": "def bar\n            do_something\n          end",
    "comment": "rubocop:disable Metrics/ClassLength",
    "label": "",
    "id": "913"
  },
  {
    "raw_code": "def bar\n            do_something\n          end",
    "comment": "rubocop:disable Metrics",
    "label": "",
    "id": "914"
  },
  {
    "raw_code": "def bar\n            do_something # rubocop:disable Metrics/ClassLength\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Unnecessary disabling of `Metrics/ClassLength`.\n          end",
    "comment": "rubocop:disable Metrics",
    "label": "",
    "id": "915"
  },
  {
    "raw_code": "def bar\n            do_something\n          end",
    "comment": "rubocop:disable Metrics",
    "label": "",
    "id": "916"
  },
  {
    "raw_code": "def bar\n            do_something # rubocop:disable Metrics/ClassLength - note\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Unnecessary disabling of `Metrics/ClassLength`.\n          end",
    "comment": "rubocop:disable Metrics",
    "label": "",
    "id": "917"
  },
  {
    "raw_code": "def bar\n            do_something # - note\n          end",
    "comment": "rubocop:disable Metrics",
    "label": "",
    "id": "918"
  },
  {
    "raw_code": "def bar\n            do_something # rubocop:disable Metrics - note\n                         ^^^^^^^^^^^^^^^^^^^^^^^^^ Unnecessary disabling of `Metrics` department.\n          end",
    "comment": "rubocop:disable Metrics",
    "label": "",
    "id": "919"
  },
  {
    "raw_code": "def bar\n            do_something # - note\n          end",
    "comment": "rubocop:disable Metrics",
    "label": "",
    "id": "920"
  },
  {
    "raw_code": "def bar\n            do_something\n          end",
    "comment": "rubocop:disable Metrics",
    "label": "",
    "id": "921"
  },
  {
    "raw_code": "def self.useful_class_method\n          do_something\n        end",
    "comment": "{trailing_whitespace} {trailing_whitespace}",
    "label": "",
    "id": "922"
  },
  {
    "raw_code": "def _investigate(cop, processed_source)\n          cop.instance_variable_get(:@options)[:autocorrect] = false\n          super\n        end",
    "comment": "very dirty hack",
    "label": "",
    "id": "923"
  },
  {
    "raw_code": "def method\n          end",
    "comment": "{keyword} A",
    "label": "",
    "id": "924"
  },
  {
    "raw_code": "def method1\n          end",
    "comment": "{keyword} A {modifier == 'private' ? 'protected' : 'private'}",
    "label": "",
    "id": "925"
  },
  {
    "raw_code": "def method1\n          end",
    "comment": "{keyword} A",
    "label": "",
    "id": "926"
  },
  {
    "raw_code": "def method1\n          end",
    "comment": "{keyword} A",
    "label": "",
    "id": "927"
  },
  {
    "raw_code": "def method1\n          end",
    "comment": "{keyword} A",
    "label": "",
    "id": "928"
  },
  {
    "raw_code": "def method1\n          end",
    "comment": "{keyword} A",
    "label": "",
    "id": "929"
  },
  {
    "raw_code": "def method1\n          end",
    "comment": "{keyword} A",
    "label": "",
    "id": "930"
  },
  {
    "raw_code": "def blah\n          end",
    "comment": "{keyword} A {modifier == 'private' ? 'protected' : 'private'}",
    "label": "",
    "id": "931"
  },
  {
    "raw_code": "def foo\n          end",
    "comment": "{keyword} A",
    "label": "",
    "id": "932"
  },
  {
    "raw_code": "def method1\n              end",
    "comment": "{keyword} A {modifier} {conditional_type} x",
    "label": "",
    "id": "933"
  },
  {
    "raw_code": "def method1\n            end",
    "comment": "{keyword} A {modifier}",
    "label": "",
    "id": "934"
  },
  {
    "raw_code": "def method2\n              end",
    "comment": "{modifier}",
    "label": "",
    "id": "935"
  },
  {
    "raw_code": "def method1\n            end",
    "comment": "{keyword} A",
    "label": "",
    "id": "936"
  },
  {
    "raw_code": "def foo\n          end",
    "comment": "{klass}.new do {modifier}",
    "label": "",
    "id": "937"
  },
  {
    "raw_code": "def method1\n          end",
    "comment": "{keyword} A {modifier}",
    "label": "",
    "id": "938"
  },
  {
    "raw_code": "def method2\n            end",
    "comment": "{keyword} B",
    "label": "",
    "id": "939"
  },
  {
    "raw_code": "def method3\n            end",
    "comment": "{modifier}",
    "label": "",
    "id": "940"
  },
  {
    "raw_code": "def method1\n              end",
    "comment": "{keyword} B",
    "label": "",
    "id": "941"
  },
  {
    "raw_code": "def foo\n            end",
    "comment": "{modifier}",
    "label": "",
    "id": "942"
  },
  {
    "raw_code": "def f\n            #{'  #' * 46}\n              if #{'a' * 120}\n                return y\n              end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "943"
  },
  {
    "raw_code": "def bar(varOne, varTwo)\n            varOne + varTwo\n          end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "944"
  },
  {
    "raw_code": "def bar\n            puts #{'a' * 150}\n          end",
    "comment": "rubocop:disable Layout/LineLength",
    "label": "",
    "id": "945"
  },
  {
    "raw_code": "def batch\n        @areas   = params[:param].map do\n                     var_1      = 123_456\n                     variable_2 = 456_123\n                   end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "946"
  },
  {
    "raw_code": "def verify_section\n        scroll_down_until_element_exists\n      rescue StandardError\n        scroll_down_until_element_exists\n      end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "947"
  },
  {
    "raw_code": "def func\n        begin\n          foo\n          bar\n        rescue StandardError\n          baz\n        end",
    "comment": "comment 1 comment 2",
    "label": "",
    "id": "948"
  },
  {
    "raw_code": "def func\n        foo\n        bar\n      rescue StandardError\n        baz\n      end",
    "comment": "frozen_string_literal: true comment 1 comment 2",
    "label": "",
    "id": "949"
  },
  {
    "raw_code": "def func\n          # rubocop:enable Metrics/MethodLength\n          x = foo # rubocop:disable Lint/UselessAssignment,Style/For\n          # rubocop:disable all\n          # rubocop:disable Style/ClassVars\n          @@bar = \"3\"\n        end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "950"
  },
  {
    "raw_code": "def func\n        foo\n        bar\n      rescue StandardError\n        baz\n      end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "951"
  },
  {
    "raw_code": "def baz\n              do_something\n            end",
    "comment": "This is a nice long comment which spans a few lines",
    "label": "",
    "id": "952"
  },
  {
    "raw_code": "def do_even_more_stuff\n            foo = begin\n      do_stuff(\n                      a: 1,\n                               b: 2,\n                               c: 3\n                              )\n                                    rescue StandardError\n                             nil\n      end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "953"
  },
  {
    "raw_code": "def do_even_more_stuff\n        do_stuff(\n          a: 1,\n          b: 2,\n          c: 3\n        )\n      rescue StandardError\n        nil\n      end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "954"
  },
  {
    "raw_code": "def short_description_of_cop(cop)\n        desc = full_description_of_cop(cop)\n        desc ? desc.lines.first.strip : ''\n      end",
    "comment": "Extracts the first line out of the description",
    "label": "",
    "id": "955"
  },
  {
    "raw_code": "def full_description_of_cop(cop)\n        cop_config = global_conf.for_cop(cop)\n        cop_config['Description']\n      end",
    "comment": "Gets the full description of the cop or nil if no description is set.",
    "label": "",
    "id": "956"
  },
  {
    "raw_code": "def ordinary_method(_some_arg)\n            puts 'Ignoring args'\n          end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "957"
  },
  {
    "raw_code": "def lolol; end\n            end",
    "comment": "rubocop:enable Lint/UselessConstantScoping",
    "label": "",
    "id": "958"
  },
  {
    "raw_code": "def choose_move(who_to_move) # rubocop:todo Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/MethodLength\n                legal_moves = all_legal_moves_that_dont_put_me_in_check(who_to_move)\n\n                return nil if legal_moves.empty?\n\n                mating_move = checkmating_move(legal_moves)\n                return mating_move if mating_move\n\n                best_moves = checking_moves(legal_moves)\n                best_moves = castling_moves(legal_moves) if best_moves.empty?\n                best_moves = taking_moves(legal_moves) if best_moves.empty?\n                best_moves = legal_moves if best_moves.empty?\n                best_moves = remove_dangerous_moves(best_moves, who_to_move)\n                best_moves = legal_moves if best_moves.empty?\n                best_moves.sample\n              end",
    "comment": "rubocop:todo Metrics/MethodLength rubocop:todo Metrics/AbcSize",
    "label": "",
    "id": "959"
  },
  {
    "raw_code": "def our_function\n              ourVariable = \"foo\"\n              script = <<~JS\n                <script>\n                  window.stuff = \"#{ourVariable}\"\n                </script>\n              JS\n              puts(script)\n            end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "960"
  },
  {
    "raw_code": "def our_function\n              ourVariable = 'foo' # rubocop:todo Naming/VariableName\n              # rubocop:todo Naming/VariableName\n              script = <<~JS\n                <script>\n                  window.stuff = \"#{ourVariable}\"\n                </script>\n              JS\n              # rubocop:enable Naming/VariableName\n              puts(script)\n            end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "961"
  },
  {
    "raw_code": "def foo # rubocop:todo Metrics/MethodLength\n              bar do\n                %w[]\n              end",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "962"
  },
  {
    "raw_code": "def create_server(source, uri)\n    server = RubyLsp::Server.new(test_mode: true)\n    server.global_state.formatter = 'rubocop'\n    server.global_state.instance_variable_set(:@linters, ['rubocop'])\n\n    if source\n      server.process_message(\n        id: request_id.next,\n        method: 'textDocument/didOpen',\n        params: {\n          textDocument: {\n            uri: uri,\n            text: source,\n            version: 1\n          }\n        }\n      )\n    end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "963"
  },
  {
    "raw_code": "def process_message(method, **params)\n    server.process_message(id: request_id.next, method: method, params: params)\n  end",
    "comment": "rubocop:enable Metrics/MethodLength",
    "label": "",
    "id": "964"
  },
  {
    "raw_code": "def strip_margin(margin_characters)\n      margin = Regexp.quote(margin_characters)\n      gsub(/^\\s+#{margin}/, '')\n    end",
    "comment": "The method strips the characters preceding a special margin character. Useful for HEREDOCs and other multi-line strings.  @example  code = <<-END.strip_margin('|') |def test |  some_method |  other_method |end END  #=> \"def\\n  some_method\\n  \\nother_method\\nend\"",
    "label": "",
    "id": "965"
  },
  {
    "raw_code": "def create_file(file_path, content, retain_line_terminators: false)\n    file_path = File.expand_path(file_path)\n\n    # On Windows, when a file is opened in 'w' mode, LF line terminators (`\\n`)\n    # are automatically converted to CRLF (`\\r\\n`).\n    # If this is not desired, `force_lf: true` will cause the file to be opened\n    # in 'wb' mode instead, which keeps existing line terminators.\n    file_mode = retain_line_terminators ? 'wb' : 'w'\n\n    ensure_descendant(file_path)\n\n    dir_path = File.dirname(file_path)\n    FileUtils.mkdir_p dir_path\n\n    File.open(file_path, file_mode) do |file|\n      break if content.nil?\n\n      case content\n      when String\n        file.puts content\n      when Array\n        file.puts content.join(\"\\n\")\n      end",
    "comment": "rubocop:disable Metrics/MethodLength",
    "label": "",
    "id": "966"
  },
  {
    "raw_code": "def create_empty_file(file_path)\n    create_file(file_path, '')\n  end",
    "comment": "rubocop:enable Metrics/MethodLength rubocop:disable InternalAffairs/CreateEmptyFile",
    "label": "",
    "id": "967"
  },
  {
    "raw_code": "def create_link(link_path, target_path)\n    link_path = File.expand_path(link_path)\n\n    ensure_descendant(link_path)\n\n    dir_path = File.dirname(link_path)\n    FileUtils.mkdir_p dir_path\n\n    FileUtils.symlink(target_path, link_path)\n  end",
    "comment": "rubocop:enable InternalAffairs/CreateEmptyFile",
    "label": "",
    "id": "968"
  },
  {
    "raw_code": "def do_something; end\n\n          end",
    "comment": "{type} SomeObject",
    "label": "",
    "id": "969"
  },
  {
    "raw_code": "def do_something; end\n            ^ #{missing_begin}\n            end",
    "comment": "{type} SomeObject",
    "label": "",
    "id": "970"
  },
  {
    "raw_code": "def do_something; end\n\n            end",
    "comment": "{type} SomeObject",
    "label": "",
    "id": "971"
  },
  {
    "raw_code": "def do_something\n                end",
    "comment": "{type} Parent {type} SomeObject",
    "label": "",
    "id": "972"
  },
  {
    "raw_code": "def do_something\n              ^ #{missing_begin}\n                  end",
    "comment": "{type} Parent {type} SomeObject",
    "label": "",
    "id": "973"
  },
  {
    "raw_code": "def do_something\n                  end",
    "comment": "{type} Parent {type} SomeObject",
    "label": "",
    "id": "974"
  },
  {
    "raw_code": "def do_something\n                  end",
    "comment": "{type} SomeObject",
    "label": "",
    "id": "975"
  },
  {
    "raw_code": "def do_something\n                  end",
    "comment": "{type} Parent {type} SomeObject",
    "label": "",
    "id": "976"
  },
  {
    "raw_code": "def do_something; end\n\n            end",
    "comment": "Comment",
    "label": "",
    "id": "977"
  },
  {
    "raw_code": "def do_something\n              end",
    "comment": "{type} Parent {type} Mom",
    "label": "",
    "id": "978"
  },
  {
    "raw_code": "def do_something; end\n\n            end",
    "comment": "{type} SomeObject",
    "label": "",
    "id": "979"
  },
  {
    "raw_code": "def trailing_whitespace\n  ' '\nend",
    "comment": "frozen_string_literal: true",
    "label": "",
    "id": "980"
  },
  {
    "raw_code": "def braces(open_line_break, *args, close_line_break)\n    args = default_args if args.empty?\n\n    open + (open_line_break ? \"\\n\" : '') +\n      args.map { |a| a.respond_to?(:join) ? a.join(\"\\n\") : a }.join(\",\\n\") +\n      (close_line_break ? \"\\n\" : '') + close\n  end",
    "comment": "Construct the source code for the braces. For instance, for an array the `open` brace would be `[` and the `close` brace would be `]`, so you could construct the following:  braces(true, 'a', 'b', 'c', false)  [ # line break indicated by `true` as the first argument. a, b, c] # no line break indicated by `false` as the last argument.  This method also supports multi-line arguments. For example:  braces(true, 'a', ['{', 'foo: bar', '}'], true)  [ # line break indicated by `true` as the first argument. a, { foo: bar } # line break indicated by `true` as the last argument. ]",
    "label": "",
    "id": "981"
  },
  {
    "raw_code": "def construct(*args)\n    \"#{prefix}#{braces(*args)}\\n#{suffix}\"\n  end",
    "comment": "Construct a piece of source code for brace layout testing. This farms out most of the work to `#braces` but it also includes a prefix and suffix.",
    "label": "",
    "id": "982"
  }
]