[
  {
    "raw_code": "def self.configure(version, &block)\n    Config.run(version, &block)\n  end",
    "comment": "Configure a Vagrant environment. The version specifies the version of the configuration that is expected by the block. The block, based on that version, configures the environment.  Note that the block isn't run immediately. Instead, the configuration block is stored until later, and is run when an environment is loaded.  @param [String] version Version of the configuration",
    "label": "",
    "id": "1"
  },
  {
    "raw_code": "def self.has_plugin?(name, version=nil)\n    return false unless Vagrant.plugins_enabled?\n\n    if !version\n      # We check the plugin names first because those are cheaper to check\n      return true if plugin(\"2\").manager.registered.any? { |p| p.name == name }\n    end",
    "comment": "This checks if a plugin with the given name is available (installed and enabled). This can be used from the Vagrantfile to easily branch based on plugin availability.",
    "label": "",
    "id": "2"
  },
  {
    "raw_code": "def self.plugin(version, component=nil)\n    # Build up the key and return a result\n    key    = version.to_s.to_sym\n    key    = [key, component.to_s.to_sym] if component\n    result = PLUGIN_COMPONENTS.get(key)\n\n    # If we found our component then we return that\n    return result if result\n\n    # If we didn't find a result, then raise an exception, depending\n    # on if we got a component or not.\n    raise ArgumentError, \"Plugin superclass not found for version/component: \" +\n      \"#{version} #{component}\"\n  end",
    "comment": "Returns a superclass to use when creating a plugin for Vagrant. Given a specific version, this returns a proper superclass to use to register plugins for that version.  Optionally, if you give a specific component, then it will return the proper superclass for that component as well.  Plugins and plugin components should subclass the classes returned by this method. This method lets Vagrant core control these superclasses and change them over time without affecting plugins. For example, if the V1 superclass happens to be \"Vagrant::V1,\" future versions of Vagrant may move it to \"Vagrant::Plugins::V1\" and plugins will not be affected.  @param [String] version @param [String] component @return [Class]",
    "label": "",
    "id": "3"
  },
  {
    "raw_code": "def self.require_plugin(name)\n    puts \"require_plugin is deprecated and has no effect any longer.\"\n    puts \"Use `vagrant plugin` commands to manage plugins. This warning will\"\n    puts \"be removed in the next version of Vagrant.\"\n  end",
    "comment": "@deprecated",
    "label": "",
    "id": "4"
  },
  {
    "raw_code": "def self.version?(*requirements)\n    req = Gem::Requirement.new(*requirements)\n    req.satisfied_by?(Gem::Version.new(VERSION))\n  end",
    "comment": "This checks if Vagrant is installed in a specific version.  Example:  Vagrant.version?(\">= 2.1.0\") ",
    "label": "",
    "id": "5"
  },
  {
    "raw_code": "def self.require_version(*requirements)\n    logger = Log4r::Logger.new(\"vagrant::root\")\n    logger.info(\"Version requirements from Vagrantfile: #{requirements.inspect}\")\n\n    if version?(*requirements)\n      logger.info(\"  - Version requirements satisfied!\")\n      return\n    end",
    "comment": "This allows a Vagrantfile to specify the version of Vagrant that is required. You can specify a list of requirements which will all be checked against the running Vagrant version.  This should be specified at the _top_ of any Vagrantfile.  Examples are shown below:  require_version(\">= 1.3.5\") require_version(\">= 1.3.5\", \"< 1.4.0\") require_version(\"~> 1.3.5\") ",
    "label": "",
    "id": "6"
  },
  {
    "raw_code": "def self.original_env\n    {}.tap do |h|\n      ENV.each do |k,v|\n        if k.start_with?(\"VAGRANT_OLD_ENV\")\n          key = k.sub(/^VAGRANT_OLD_ENV_/, \"\")\n          if !key.empty?\n            h[key] = v\n          end",
    "comment": "This allows plugin developers to access the original environment before Vagrant even ran. This is useful when shelling out, especially to other Ruby processes.  @return [Hash]",
    "label": "",
    "id": "7"
  },
  {
    "raw_code": "def initialize(id, short, long)\n      @id                = id\n      @short_description = short\n      @long_description  = long\n    end",
    "comment": "Creates a new instance to represent the state of a machine.  @param [Symbol] id Unique identifier for this state. @param [String] short Short (preferably one-word) description of the state. @param [String] long Long description (can span multiple lines) of the state.",
    "label": "",
    "id": "8"
  },
  {
    "raw_code": "def initialize(name, provider, version, directory, architecture: nil, metadata_url: nil, hook: nil)\n      @name      = name\n      @version   = version\n      @provider  = provider\n      @directory = directory\n      @architecture = architecture\n      @metadata_url = metadata_url\n      @hook = hook\n\n      metadata_file = directory.join(\"metadata.json\")\n      raise Errors::BoxMetadataFileNotFound, name: @name if !metadata_file.file?\n\n      begin\n        @metadata = JSON.parse(directory.join(\"metadata.json\").read)\n        validate_metadata_json(@metadata)\n      rescue JSON::ParserError\n        raise Errors::BoxMetadataCorrupted, name: @name\n      end",
    "comment": "This is used to initialize a box.  @param [String] name Logical name of the box. @param [Symbol] provider The provider that this box implements. @param [Pathname] directory The directory where this box exists on disk. @param [String] architecture Architecture the box was built for @param [String] metadata_url Metadata URL for box @param [Hook] hook A hook to apply to the box downloader, for example, for authentication",
    "label": "",
    "id": "9"
  },
  {
    "raw_code": "def destroy!\n      # Delete the directory to delete the box.\n      FileUtils.rm_r(@directory)\n\n      # Just return true always\n      true\n    rescue Errno::ENOENT\n      # This means the directory didn't exist. Not a problem.\n      return true\n    end",
    "comment": "This deletes the box. This is NOT undoable.",
    "label": "",
    "id": "10"
  },
  {
    "raw_code": "def in_use?(index)\n      results = []\n      index.each do |entry|\n        box_data = entry.extra_data[\"box\"]\n        next if !box_data\n\n        # If all the data matches, record it\n        if box_data[\"name\"] == self.name &&\n          box_data[\"provider\"] == self.provider.to_s &&\n          box_data[\"architecture\"] == self.architecture &&\n          box_data[\"version\"] == self.version.to_s\n          results << entry\n        end",
    "comment": "Checks if this box is in use according to the given machine index and returns the entries that appear to be using the box.  The entries returned, if any, are not tested for validity with {MachineIndex::Entry#valid?}, so the caller should do that if the caller cares.  @param [MachineIndex] index @return [Array<MachineIndex::Entry>]",
    "label": "",
    "id": "11"
  },
  {
    "raw_code": "def load_metadata(download_options={})\n      tf = Tempfile.new(\"vagrant-load-metadata\")\n      tf.close\n\n      url = @metadata_url\n      if File.file?(url) || url !~ /^[a-z0-9]+:.*$/i\n        url = File.expand_path(url)\n        url = Util::Platform.cygwin_windows_path(url)\n        url = \"file:#{url}\"\n      end",
    "comment": "Loads the metadata URL and returns the latest metadata associated with this box.  @param [Hash] download_options Options to pass to the downloader. @return [BoxMetadata]",
    "label": "",
    "id": "12"
  },
  {
    "raw_code": "def has_update?(version=nil, download_options: {})\n      if !@metadata_url\n        raise Errors::BoxUpdateNoMetadata, name: @name\n      end",
    "comment": "Checks if the box has an update and returns the metadata, version, and provider. If the box doesn't have an update that satisfies the constraints, it will return nil.  This will potentially make a network call if it has to load the metadata from the network.  @param [String] version Version constraints the update must satisfy. If nil, the version constrain defaults to being a larger version than this box. @return [Array]",
    "label": "",
    "id": "13"
  },
  {
    "raw_code": "def automatic_update_check_allowed?\n      check_path = directory.join(\"box_update_check\")\n      if check_path.exist?\n        last_check_span = Time.now.to_i - check_path.mtime.to_i\n        if last_check_span < BOX_UPDATE_CHECK_INTERVAL\n          @logger.info(\"box update check is under the interval threshold\")\n          return false\n        end",
    "comment": "Check if a box update check is allowed. Uses a file in the box data directory to track when the last auto update check was performed and returns true if the BOX_UPDATE_CHECK_INTERVAL has passed.  @return [Boolean]",
    "label": "",
    "id": "14"
  },
  {
    "raw_code": "def repackage(path)\n      @logger.debug(\"Repackaging box '#{@name}' to: #{path}\")\n\n      Util::SafeChdir.safe_chdir(@directory) do\n        # Find all the files in our current directory and tar it up!\n        files = Dir.glob(File.join(\".\", \"**\", \"*\")).select { |f| File.file?(f) }\n\n        # Package!\n        Util::Subprocess.execute(\"bsdtar\", \"-czf\", path.to_s, *files)\n      end",
    "comment": "This repackages this box and outputs it to the given path.  @param [Pathname] path The full path (filename included) of where to output this box. @return [Boolean] true if this succeeds.",
    "label": "",
    "id": "15"
  },
  {
    "raw_code": "def <=>(other)\n      return super if !other.is_a?(self.class)\n\n      # Comparison is done by composing the name and provider\n      \"#{@name}-#{@version}-#{@provider}-#{@architecture}\" <=>\n      \"#{other.name}-#{other.version}-#{other.provider}-#{other.architecture}\"\n    end",
    "comment": "Implemented for comparison with other boxes. Comparison is implemented by comparing names, providers, and architectures.",
    "label": "",
    "id": "16"
  },
  {
    "raw_code": "def initialize(directory, options=nil)\n      options ||= {}\n\n      @directory = directory\n      @hook      = options[:hook]\n      @lock      = Monitor.new\n      @temp_root = options[:temp_dir_root]\n      @logger    = Log4r::Logger.new(\"vagrant::box_collection\")\n    end",
    "comment": "Initializes the collection.  @param [Pathname] directory The directory that contains the collection of boxes.",
    "label": "",
    "id": "17"
  },
  {
    "raw_code": "def add(path, name, version, **opts)\n      architecture = opts[:architecture]\n      providers = opts[:providers]\n      providers = Array(providers) if providers\n      provider = nil\n\n      # A helper to check if a box exists. We store this in a variable\n      # since we call it multiple times.\n      check_box_exists = lambda do |box_formats, box_architecture|\n        box = find(name, box_formats, version, box_architecture)\n        next if !box\n\n        if !opts[:force]\n          @logger.error(\n            \"Box already exists, can't add: #{name} v#{version} #{box_formats.join(\", \")}\")\n          raise Errors::BoxAlreadyExists,\n            name: name,\n            provider: box_formats.join(\", \"),\n            version: version\n        end",
    "comment": "This adds a new box to the system.  There are some exceptional cases: * BoxAlreadyExists - The box you're attempting to add already exists. * BoxProviderDoesntMatch - If the given box provider doesn't match the actual box provider in the untarred box. * BoxUnpackageFailure - An invalid tar file.  Preconditions: * File given in `path` must exist.  @param [Pathname] path Path to the box file on disk. @param [String] name Logical name for the box. @param [String] version The version of this box. @param [Array<String>] providers The providers that this box can be a part of. This will be verified with the `metadata.json` and is meant as a basic check. If this isn't given, then whatever provider the box represents will be added. @param [Boolean] force If true, any existing box with the same name and provider will be replaced.",
    "label": "",
    "id": "18"
  },
  {
    "raw_code": "def all\n      results = []\n\n      with_collection_lock do\n        @logger.debug(\"Finding all boxes in: #{@directory}\")\n        @directory.children(true).each do |child|\n          # Ignore non-directories, since files are not interesting to\n          # us in our folder structure.\n          next if !child.directory?\n\n          box_name = undir_name(child.basename.to_s)\n\n          # Otherwise, traverse the subdirectories and see what versions\n          # we have.\n          child.children(true).each do |versiondir|\n            next if !versiondir.directory?\n            next if versiondir.basename.to_s.start_with?(\".\")\n\n            version = versiondir.basename.to_s\n            # Ensure version of box is correct before continuing\n            if !Gem::Version.correct?(version)\n              ui = Vagrant::UI::Prefixed.new(Vagrant::UI::Colored.new, \"vagrant\")\n              ui.warn(I18n.t(\"vagrant.box_version_malformed\",\n                             version: version, box_name: box_name))\n              @logger.debug(\"Invalid version #{version} for box #{box_name}\")\n              next\n            end",
    "comment": "This returns an array of all the boxes on the system, given by their name and their provider.  @return [Array] Array of `[name, version, provider, architecture]` of the boxes installed on this system.",
    "label": "",
    "id": "19"
  },
  {
    "raw_code": "def find(name, providers, version, box_architecture=:auto)\n      providers = Array(providers)\n      architecture = box_architecture\n      architecture = Util::Platform.architecture if architecture == :auto\n\n      # Build up the requirements we have\n      requirements = version.to_s.split(\",\").map do |v|\n        begin\n          Gem::Requirement.new(v.strip)\n        rescue Gem::Requirement::BadRequirementError\n          raise Errors::BoxVersionInvalid,\n                version: v.strip\n        end",
    "comment": "Find a box in the collection with the given name and provider.  @param [String] name Name of the box (logical name). @param [Array] providers Providers that the box implements. @param [String] version Version constraints to adhere to. Example: \"~> 1.0\" or \"= 1.0, ~> 1.1\" @return [Box] The box found, or `nil` if not found.",
    "label": "",
    "id": "20"
  },
  {
    "raw_code": "def upgrade_v1_1_v1_5\n      with_collection_lock do\n        temp_dir = Pathname.new(Dir.mktmpdir(TEMP_PREFIX, @temp_root))\n\n        @directory.children(true).each do |boxdir|\n          # Ignore all non-directories because they can't be boxes\n          next if !boxdir.directory?\n\n          box_name = boxdir.basename.to_s\n\n          # If it is a v1 box, then we need to upgrade it first\n          if v1_box?(boxdir)\n            upgrade_dir = v1_upgrade(boxdir)\n            FileUtils.mv(upgrade_dir, boxdir.join(\"virtualbox\"))\n          end",
    "comment": "This upgrades a v1.1 - v1.4 box directory structure up to a v1.5 directory structure. This will raise exceptions if it fails in any way.",
    "label": "",
    "id": "21"
  },
  {
    "raw_code": "def clean(name)\n      return false if exists?(name)\n      path = File.join(directory, dir_name(name))\n      FileUtils.rm_rf(path)\n    end",
    "comment": "Cleans the directory for a box by removing the folders that are empty.",
    "label": "",
    "id": "22"
  },
  {
    "raw_code": "def dir_name(name)\n      name = name.dup\n      name.gsub!(\":\", VAGRANT_COLON) if Util::Platform.windows?\n      name.gsub!(\"/\", VAGRANT_SLASH)\n      name\n    end",
    "comment": "Returns the directory name for the box of the given name.  @param [String] name @return [String]",
    "label": "",
    "id": "23"
  },
  {
    "raw_code": "def undir_name(name)\n      name = name.dup\n      name.gsub!(VAGRANT_COLON, \":\")\n      name.gsub!(VAGRANT_SLASH, \"/\")\n      name\n    end",
    "comment": "Returns the directory name for the box cleaned up",
    "label": "",
    "id": "24"
  },
  {
    "raw_code": "def v1_box?(dir)\n      # We detect a V1 box given by whether there is a \"box.ovf\" which\n      # is a heuristic but is pretty accurate.\n      dir.join(\"box.ovf\").file?\n    end",
    "comment": "This checks if the given directory represents a V1 box on the system.  @param [Pathname] dir Directory where the box is unpacked. @return [Boolean]",
    "label": "",
    "id": "25"
  },
  {
    "raw_code": "def v1_upgrade(dir)\n      @logger.debug(\"Upgrading box in directory: #{dir}\")\n\n      temp_dir = Pathname.new(Dir.mktmpdir(TEMP_PREFIX, @temp_root))\n      @logger.debug(\"Temporary directory for upgrading: #{temp_dir}\")\n\n      # Move all the things into the temporary directory\n      dir.children(true).each do |child|\n        # Don't move the temp_dir\n        next if child == temp_dir\n\n        # Move every other directory into the temporary directory\n        @logger.debug(\"Copying to upgrade directory: #{child}\")\n        FileUtils.mv(child, temp_dir.join(child.basename))\n      end",
    "comment": "This upgrades the V1 box contained unpacked in the given directory and returns the directory of the upgraded version. This is _destructive_ to the contents of the old directory. That is, the contents of the old V1 box will be destroyed or moved.  Preconditions: * `dir` is a valid V1 box. Verify with {#v1_box?}  @param [Pathname] dir Directory where the V1 box is unpacked. @return [Pathname] Path to the unpackaged V2 box.",
    "label": "",
    "id": "26"
  },
  {
    "raw_code": "def with_collection_lock\n      @lock.synchronize do\n        return yield\n      end",
    "comment": "This locks the region given by the block with a lock on this collection.",
    "label": "",
    "id": "27"
  },
  {
    "raw_code": "def with_temp_dir(dir=nil)\n      dir ||= Dir.mktmpdir(TEMP_PREFIX, @temp_root)\n      dir = Pathname.new(dir)\n\n      yield dir\n    ensure\n      FileUtils.rm_rf(dir.to_s)\n    end",
    "comment": "This is a helper that makes sure that our temporary directories are cleaned up no matter what.  @param [String] dir Path to a temporary directory @return [Object] The result of whatever the yield is",
    "label": "",
    "id": "28"
  },
  {
    "raw_code": "def exists?(box_name)\n      all.any? { |box| box.first.eql?(box_name) }\n    end",
    "comment": "Checks if a box with a given name exists.",
    "label": "",
    "id": "29"
  },
  {
    "raw_code": "def register(key, &block)\n      raise ArgumentError, \"block required\" if !block_given?\n      @items[key] = block\n    end",
    "comment": "Register a key with a lazy-loaded value.  If a key with the given name already exists, it is overwritten.",
    "label": "",
    "id": "30"
  },
  {
    "raw_code": "def get(key)\n      return nil if !@items.key?(key)\n      return @results_cache[key] if @results_cache.key?(key)\n      @results_cache[key] = @items[key].call\n    end",
    "comment": "Get a value by the given key.  This will evaluate the block given to `register` and return the resulting value.",
    "label": "",
    "id": "31"
  },
  {
    "raw_code": "def key?(key)\n      @items.key?(key)\n    end",
    "comment": "Checks if the given key is registered with the registry.  @return [Boolean]",
    "label": "",
    "id": "32"
  },
  {
    "raw_code": "def keys\n      @items.keys\n    end",
    "comment": "Returns an array populated with the keys of this object.  @return [Array]",
    "label": "",
    "id": "33"
  },
  {
    "raw_code": "def each(&block)\n      @items.each do |key, _|\n        yield key, get(key)\n      end",
    "comment": "Iterate over the keyspace.",
    "label": "",
    "id": "34"
  },
  {
    "raw_code": "def map(&block)\n      @items.map do |key, _|\n        yield key, get(key)\n      end",
    "comment": "Iterate over the keyspace and return result  @return [Array]",
    "label": "",
    "id": "35"
  },
  {
    "raw_code": "def length\n      @items.keys.length\n    end",
    "comment": "Return the number of elements in this registry.  @return [Integer]",
    "label": "",
    "id": "36"
  },
  {
    "raw_code": "def empty?\n      @items.keys.empty?\n    end",
    "comment": "Checks if this registry has any items.  @return [Boolean]",
    "label": "",
    "id": "37"
  },
  {
    "raw_code": "def merge(other)\n      self.class.new.tap do |result|\n        result.merge!(self)\n        result.merge!(other)\n      end",
    "comment": "Merge one registry with another and return a completely new registry. Note that the result cache is completely busted, so any gets on the new registry will result in a cache miss.",
    "label": "",
    "id": "38"
  },
  {
    "raw_code": "def merge!(other)\n      @items.merge!(other.__internal_state[:items])\n      self\n    end",
    "comment": "Like #{merge} but merges into self.",
    "label": "",
    "id": "39"
  },
  {
    "raw_code": "def to_hash\n      result = {}\n      self.each do |key, value|\n        result[key] = value\n      end",
    "comment": "Converts this registry to a hash",
    "label": "",
    "id": "40"
  },
  {
    "raw_code": "def initialize(data_dir)\n      @data_dir   = data_dir\n      @index_file = data_dir.join(\"index\")\n      @lock       = Monitor.new\n      @machines  = {}\n      @machine_locks = {}\n\n      with_index_lock do\n        unlocked_reload\n      end",
    "comment": "Initializes a MachineIndex at the given file location.  @param [Pathname] data_dir Path to the directory where data for the index can be stored. This folder should exist and must be writable.",
    "label": "",
    "id": "41"
  },
  {
    "raw_code": "def delete(entry)\n      return true if !entry.id\n\n      @lock.synchronize do\n        with_index_lock do\n          return true if !@machines[entry.id]\n\n          # If we don't have the lock, then we need to acquire it.\n          if !@machine_locks[entry.id]\n            raise \"Unlocked delete on machine: #{entry.id}\"\n          end",
    "comment": "Deletes a machine by UUID.  The machine being deleted with this UUID must either be locked by this index or must be unlocked.  @param [Entry] entry The entry to delete. @return [Boolean] true if delete is successful",
    "label": "",
    "id": "42"
  },
  {
    "raw_code": "def each(reload=false)\n      if reload\n        @lock.synchronize do\n          with_index_lock do\n            unlocked_reload\n          end",
    "comment": "Iterate over every machine in the index. The yielded {Entry} objects will NOT be locked, so you'll have to call {#get} manually to acquire the lock on them.",
    "label": "",
    "id": "43"
  },
  {
    "raw_code": "def get(uuid)\n      entry = nil\n\n      @lock.synchronize do\n        with_index_lock do\n          # Reload the data\n          unlocked_reload\n\n          data = find_by_prefix(uuid)\n          return nil if !data\n          uuid = data[\"id\"]\n\n          entry = Entry.new(uuid, data)\n\n          # Lock this machine\n          lock_file = lock_machine(uuid)\n          if !lock_file\n            raise Errors::MachineLocked,\n              name: entry.name,\n              provider: entry.provider\n          end",
    "comment": "Accesses a machine by UUID and returns a {MachineIndex::Entry}  The entry returned is locked and can't be read again or updated by this process or any other. To unlock the machine, call {#release} with the entry.  You can only {#set} an entry (update) when the lock is held.  @param [String] uuid UUID for the machine to access. @return [MachineIndex::Entry]",
    "label": "",
    "id": "44"
  },
  {
    "raw_code": "def include?(uuid)\n      @lock.synchronize do\n        with_index_lock do\n          unlocked_reload\n          return !!find_by_prefix(uuid)\n        end",
    "comment": "Tests if the index has the given UUID.  @param [String] uuid @return [Boolean]",
    "label": "",
    "id": "45"
  },
  {
    "raw_code": "def release(entry)\n      @lock.synchronize do\n        unlocked_release(entry.id)\n      end",
    "comment": "Releases an entry, unlocking it.  This is an idempotent operation. It is safe to call this even if you're unsure if an entry is locked or not.  After calling this, the previous entry should no longer be used.  @param [Entry] entry",
    "label": "",
    "id": "46"
  },
  {
    "raw_code": "def set(entry)\n      # Get the struct and update the updated_at attribute\n      struct = entry.to_json_struct\n\n      # Set an ID if there isn't one already set\n      id     = entry.id\n\n      @lock.synchronize do\n        with_index_lock do\n          # Reload so we have the latest machine data. This allows other\n          # processes to update their own machines without conflicting\n          # with our own.\n          unlocked_reload\n\n          # If we don't have a machine ID, try to look one up\n          if !id\n            self.each do |other|\n              if entry.name == other.name &&\n                entry.provider == other.provider &&\n                entry.vagrantfile_path.to_s == other.vagrantfile_path.to_s\n                id = other.id\n                break\n              end",
    "comment": "Creates/updates an entry object and returns the resulting entry.  If the entry was new (no UUID), then the UUID will be set on the resulting entry and can be used. Additionally, the a lock will be created for the resulting entry, so you must {#release} it if you want others to be able to access it.  If the entry isn't new (has a UUID). then this process must hold that entry's lock or else this set will fail.  @param [Entry] entry @return [Entry]",
    "label": "",
    "id": "47"
  },
  {
    "raw_code": "def recover(entry)\n      @lock.synchronize do\n        with_index_lock do\n          # Reload the data\n          unlocked_reload\n          # Don't recover if entry already exists in the global\n          return entry if find_by_prefix(entry.id)\n\n          lock_file = lock_machine(entry.id)\n          if !lock_file\n            raise Errors::MachineLocked,\n              name: entry.name,\n              provider: entry.provider\n          end",
    "comment": "Reinsert a machine into the global index if it has a valid existing uuid but does not currently exist in the index.  @param [Entry] entry @return [Entry]",
    "label": "",
    "id": "48"
  },
  {
    "raw_code": "def find_by_prefix(prefix)\n      return if !prefix || prefix == \"\"\n      @machines.each do |uuid, data|\n        return data.merge(\"id\" => uuid) if uuid.start_with?(prefix)\n      end",
    "comment": "Finds a machine where the UUID is prefixed by the given string.  @return [Hash]",
    "label": "",
    "id": "49"
  },
  {
    "raw_code": "def lock_machine(uuid)\n      lock_path = @data_dir.join(\"#{uuid}.lock\")\n      lock_file = lock_path.open(\"w+\")\n      if lock_file.flock(File::LOCK_EX | File::LOCK_NB) === false\n        lock_file.close\n        lock_file = nil\n      end",
    "comment": "Locks a machine exclusively to us, returning the file handle that holds the lock.  If the lock cannot be acquired, then nil is returned.  This should be called within an index lock.  @return [File]",
    "label": "",
    "id": "50"
  },
  {
    "raw_code": "def unlocked_release(id)\n      lock_file = @machine_locks[id]\n      if lock_file\n        lock_file.close\n        begin\n          File.delete(lock_file.path)\n        rescue Errno::EACCES\n          # Another process is probably opened it, no problem.\n        end",
    "comment": "Releases a local lock on a machine. This does not acquire any locks so make sure to lock around it.  @param [String] id",
    "label": "",
    "id": "51"
  },
  {
    "raw_code": "def unlocked_reload\n      return if !@index_file.file?\n\n      data = nil\n      begin\n        data = JSON.load(@index_file.read)\n      rescue JSON::ParserError\n        raise Errors::CorruptMachineIndex, path: @index_file.to_s\n      end",
    "comment": "This will reload the data without locking the index. It is assumed the caller with lock the index outside of this call.  @param [File] f",
    "label": "",
    "id": "52"
  },
  {
    "raw_code": "def unlocked_save\n      @index_file.open(\"w\") do |f|\n        f.write(JSON.dump({\n          \"version\"  => 1,\n          \"machines\" => @machines,\n        }))\n      end",
    "comment": "Saves the index.",
    "label": "",
    "id": "53"
  },
  {
    "raw_code": "def with_index_lock\n      lock_path = \"#{@index_file}.lock\"\n      File.open(lock_path, \"w+\") do |f|\n        f.flock(File::LOCK_EX)\n        yield\n      end",
    "comment": "This will hold a lock to the index so it can be read or updated.",
    "label": "",
    "id": "54"
  },
  {
    "raw_code": "def initialize(id=nil, raw=nil)\n        @logger = Log4r::Logger.new(\"vagrant::machine_index::entry\")\n\n        @extra_data = {}\n        @id = id\n        # Do nothing if we aren't given a raw value. Otherwise, parse it.\n        return if !raw\n\n        @local_data_path  = raw[\"local_data_path\"]\n        @name             = raw[\"name\"]\n        @provider         = raw[\"provider\"]\n        @architecture     = raw[\"architecture\"]\n        @state            = raw[\"state\"]\n        @full_state       = raw[\"full_state\"]\n        @vagrantfile_name = raw[\"vagrantfile_name\"]\n        @vagrantfile_path = raw[\"vagrantfile_path\"]\n        # TODO(mitchellh): parse into a proper datetime\n        @updated_at       = raw[\"updated_at\"]\n        @extra_data       = raw[\"extra_data\"] || {}\n\n        # Be careful with the paths\n        @local_data_path = nil  if @local_data_path == \"\"\n        @vagrantfile_path = nil if @vagrantfile_path == \"\"\n\n        # Convert to proper types\n        @local_data_path = Pathname.new(@local_data_path) if @local_data_path\n        @vagrantfile_path = Pathname.new(@vagrantfile_path) if @vagrantfile_path\n      end",
    "comment": "Initializes an entry.  The parameter given should be nil if this is being created publicly.",
    "label": "",
    "id": "55"
  },
  {
    "raw_code": "def valid?(home_path)\n        return false if !vagrantfile_path\n        return false if !vagrantfile_path.directory?\n\n        # Create an environment so we can determine the active\n        # machines...\n        found = false\n        env = vagrant_env(home_path)\n        env.active_machines.each do |name, provider|\n          if name.to_s == self.name.to_s &&\n            provider.to_s == self.provider.to_s\n            found = true\n            break\n          end",
    "comment": "Returns boolean true if this entry appears to be valid. The criteria for being valid:  * Vagrantfile directory exists * Vagrant environment contains a machine with this name and provider.  This method is _slow_. It should be used with care.  @param [Pathname] home_path The home path for the Vagrant environment. @return [Boolean]",
    "label": "",
    "id": "56"
  },
  {
    "raw_code": "def vagrant_env(home_path, opts={})\n        Vagrant::Util::SilenceWarnings.silence! do\n          Environment.new({\n            cwd: @vagrantfile_path,\n            home_path: home_path,\n            local_data_path: @local_data_path,\n            vagrantfile_name: @vagrantfile_name,\n          }.merge(opts))\n        end",
    "comment": "Creates a {Vagrant::Environment} for this entry.  @return [Vagrant::Environment]",
    "label": "",
    "id": "57"
  },
  {
    "raw_code": "def to_json_struct\n        {\n          \"local_data_path\"  => @local_data_path.to_s,\n          \"name\"             => @name,\n          \"provider\"         => @provider,\n          \"architecture\"     => @architecture,\n          \"state\"            => @state,\n          \"vagrantfile_name\" => @vagrantfile_name,\n          \"vagrantfile_path\" => @vagrantfile_path.to_s,\n          \"updated_at\"       => @updated_at,\n          \"extra_data\"       => @extra_data,\n        }\n      end",
    "comment": "Converts to the structure used by the JSON",
    "label": "",
    "id": "58"
  },
  {
    "raw_code": "def help\n      # We use the optionparser for this. Its just easier. We don't use\n      # an optionparser above because I don't think the performance hits\n      # of creating a whole object are worth checking only a couple flags.\n      opts = OptionParser.new do |o|\n        o.banner = \"Usage: vagrant [options] <command> [<args>]\"\n        o.separator \"\"\n        o.on(\"-v\", \"--version\", \"Print the version and exit.\")\n        o.on(\"-h\", \"--help\", \"Print this help.\")\n        o.separator \"\"\n        o.separator \"Common commands:\"\n\n        # Add the available subcommands as separators in order to print them\n        # out as well.\n        commands = {}\n        longest = 0\n        Vagrant.plugin(\"2\").manager.commands.each do |key, data|\n          # Skip non-primary commands. These only show up in extended\n          # help output.\n          next if !data[1][:primary]\n\n          key           = key.to_s\n          klass         = data[0].call\n          commands[key] = klass.synopsis\n          longest       = key.length if key.length > longest\n        end",
    "comment": "This prints out the help for the CLI.",
    "label": "",
    "id": "59"
  },
  {
    "raw_code": "def initialize_capabilities!(host, hosts, capabilities, *args)\n      @cap_logger = Log4r::Logger.new(\n        \"vagrant::capability_host::#{self.class.to_s.downcase}\")\n\n      if host && !hosts[host]\n        raise Errors::CapabilityHostExplicitNotDetected, value: host.to_s\n      end",
    "comment": "Initializes the capability system by detecting the proper capability host to execute on and building the chain of capabilities to execute.  @param [Symbol] host The host to use for the capabilities, or nil if we should auto-detect it. @param [Hash<Symbol, Array<Class, Symbol>>] hosts Potential capability hosts. The key is the name of the host, value[0] is a class that implements `#detect?` and value[1] is a parent host (if any). @param [Hash<Symbol, Hash<Symbol, Class>>] capabilities The capabilities that are supported. The key is the host of the capability. Within that is a hash where the key is the name of the capability and the value is the class/module implementing it.",
    "label": "",
    "id": "60"
  },
  {
    "raw_code": "def capability_host_chain\n      @cap_host_chain\n    end",
    "comment": "Returns the chain of hosts that will be checked for capabilities.  @return [Array<Array<Symbol, Class>>]",
    "label": "",
    "id": "61"
  },
  {
    "raw_code": "def capability?(cap_name)\n      !capability_module(cap_name.to_sym).nil?\n    end",
    "comment": "Tests whether the given capability is possible.  @param [Symbol] cap_name Capability name @return [Boolean]",
    "label": "",
    "id": "62"
  },
  {
    "raw_code": "def capability(cap_name, *args)\n      cap_mod = capability_module(cap_name.to_sym)\n      if !cap_mod\n        raise Errors::CapabilityNotFound,\n          cap:  cap_name.to_s,\n          host: @cap_host_chain[0][0].to_s\n      end",
    "comment": "Executes the capability with the given name, optionally passing more arguments onwards to the capability. If the capability returns a value, it will be returned.  @param [Symbol] cap_name Name of the capability",
    "label": "",
    "id": "63"
  },
  {
    "raw_code": "def capability_module(cap_name)\n      @cap_logger.debug(\"Searching for cap: #{cap_name}\")\n      @cap_host_chain.each do |host_name, host|\n        @cap_logger.debug(\"Checking in: #{host_name}\")\n        caps = @cap_caps[host_name]\n\n        if caps && caps.key?(cap_name)\n          @cap_logger.debug(\"Found cap: #{cap_name} in #{host_name}\")\n          return caps[cap_name]\n        end",
    "comment": "Returns the registered module for a capability with the given name.  @param [Symbol] cap_name @return [Module]",
    "label": "",
    "id": "64"
  },
  {
    "raw_code": "def initialize(name, provider_name, provider_cls, provider_config, provider_options, config, data_dir, box, env, vagrantfile, base=false)\n      @logger = Log4r::Logger.new(\"vagrant::machine\")\n      @logger.info(\"Initializing machine: #{name}\")\n      @logger.info(\"  - Provider: #{provider_cls}\")\n      @logger.info(\"  - Box: #{box}\")\n      @logger.info(\"  - Data dir: #{data_dir}\")\n\n      @box             = box\n      @config          = config\n      @data_dir        = data_dir\n      @env             = env\n      @vagrantfile     = vagrantfile\n      @guest           = Guest.new(\n        self,\n        Vagrant.plugin(\"2\").manager.guests,\n        Vagrant.plugin(\"2\").manager.guest_capabilities)\n      @name            = name\n      @provider_config = provider_config\n      @provider_name   = provider_name\n      @provider_options = provider_options\n      @ui              = Vagrant::UI::Prefixed.new(@env.ui, @name)\n      @ui_mutex        = Mutex.new\n      @state_mutex     = Mutex.new\n      @triggers        = Vagrant::Plugin::V2::Trigger.new(@env, @config.trigger, self, @ui)\n\n      # Read the ID, which is usually in local storage\n      @id = nil\n\n      # XXX: This is temporary. This will be removed very soon.\n      if base\n        @id = name\n\n        # For base setups, we don't want to insert the key\n        @config.ssh.insert_key = false\n      else\n        reload\n      end",
    "comment": "Initialize a new machine.  @param [String] name Name of the virtual machine. @param [Class] provider The provider backing this machine. This is currently expected to be a V1 `provider` plugin. @param [Object] provider_config The provider-specific configuration for this machine. @param [Hash] provider_options The provider-specific options from the plugin definition. @param [Object] config The configuration for this machine. @param [Pathname] data_dir The directory where machine-specific data can be stored. This directory is ensured to exist. @param [Box] box The box that is backing this virtual machine. @param [Environment] env The environment that this machine is a part of.",
    "label": "",
    "id": "65"
  },
  {
    "raw_code": "def action(name, opts=nil)\n      @logger.info(\"Calling action: #{name} on provider #{@provider}\")\n\n      opts ||= {}\n\n      # Determine whether we lock or not\n      lock = true\n      lock = opts.delete(:lock) if opts.key?(:lock)\n\n      # Extra env keys are the remaining opts\n      extra_env = opts.dup\n\n      check_cwd # Warns the UI if the machine was last used on a different dir\n\n      # Create a deterministic ID for this machine\n      vf = nil\n      vf = @env.vagrantfile_name[0] if @env.vagrantfile_name\n      id = Digest::MD5.hexdigest(\n        \"#{@env.root_path}#{vf}#{@env.local_data_path}#{@name}\")\n\n      # We only lock if we're not executing an SSH action. In the future\n      # we will want to do more fine-grained unlocking in actions themselves\n      # but for a 1.6.2 release this will work.\n      locker = Proc.new { |*args, &block| block.call }\n      locker = @env.method(:lock) if lock && !name.to_s.start_with?(\"ssh\")\n\n      # Lock this machine for the duration of this action\n      return_env = locker.call(\"machine-action-#{id}\") do\n        # Get the callable from the provider.\n        callable = @provider.action(name)\n\n        # If this action doesn't exist on the provider, then an exception\n        # must be raised.\n        if callable.nil?\n          raise Errors::UnimplementedProviderAction,\n            action: name,\n            provider: @provider.to_s\n        end",
    "comment": "This calls an action on the provider. The provider may or may not actually implement the action.  @param [Symbol] name Name of the action to run. @param [Hash] extra_env This data will be passed into the action runner as extra data set on the environment hash for the middleware runner.",
    "label": "",
    "id": "66"
  },
  {
    "raw_code": "def action_raw(name, callable, extra_env={})\n      if !extra_env.is_a?(Hash)\n        extra_env = {}\n      end",
    "comment": "This calls a raw callable in the proper context of the machine using the middleware stack.  @param [Symbol] name Name of the action @param [Proc] callable @param [Hash] extra_env Extra env for the action env. @return [Hash] The resulting env",
    "label": "",
    "id": "67"
  },
  {
    "raw_code": "def communicate\n      if !@communicator\n        requested  = @config.vm.communicator\n        requested ||= :ssh\n        klass = Vagrant.plugin(\"2\").manager.communicators[requested]\n        raise Errors::CommunicatorNotFound, comm: requested.to_s if !klass\n        @communicator = klass.new(self)\n      end",
    "comment": "Returns a communication object for executing commands on the remote machine. Note that the _exact_ semantics of this are up to the communication provider itself. Despite this, the semantics are expected to be consistent across operating systems. For example, all linux-based systems should have similar communication (usually a shell). All Windows systems should have similar communication as well. Therefore, prior to communicating with the machine, users of this method are expected to check the guest OS to determine their behavior.  This method will _always_ return some valid communication object. The `ready?` API can be used on the object to check if communication is actually ready.  @return [Object]",
    "label": "",
    "id": "68"
  },
  {
    "raw_code": "def guest\n      raise Errors::MachineGuestNotReady if !communicate.ready?\n      @guest.detect! if !@guest.ready?\n      @guest\n    end",
    "comment": "Returns a guest implementation for this machine. The guest implementation knows how to do guest-OS specific tasks, such as configuring networks, mounting folders, etc.  @return [Guest]",
    "label": "",
    "id": "69"
  },
  {
    "raw_code": "def id=(value)\n      @logger.info(\"New machine ID: #{value.inspect}\")\n\n      id_file = nil\n      if @data_dir\n        # The file that will store the id if we have one. This allows the\n        # ID to persist across Vagrant runs. Also, store the UUID for the\n        # machine index.\n        id_file = @data_dir.join(\"id\")\n      end",
    "comment": "This sets the unique ID associated with this machine. This will persist this ID so that in the future Vagrant will be able to find this machine again. The unique ID must be absolutely unique to the virtual machine, and can be used by providers for finding the actual machine associated with this instance.  **WARNING:** Only providers should ever use this method.  @param [String] value The ID.",
    "label": "",
    "id": "70"
  },
  {
    "raw_code": "def index_uuid\n      return nil if !@index_uuid_file\n      return @index_uuid_file.read.chomp if @index_uuid_file.file?\n      return nil\n    end",
    "comment": "Returns the UUID associated with this machine in the machine index. We only have a UUID if an ID has been set.  @return [String] UUID or nil if we don't have one yet.",
    "label": "",
    "id": "71"
  },
  {
    "raw_code": "def inspect\n      \"#<#{self.class}: #{@name} (#{@provider.class})>\"\n    end",
    "comment": "This returns a clean inspect value so that printing the value via a pretty print (`p`) results in a readable value.  @return [String]",
    "label": "",
    "id": "72"
  },
  {
    "raw_code": "def reload\n      old_id = @id\n      @id = nil\n\n      if @data_dir\n        # Read the id file from the data directory if it exists as the\n        # ID for the pre-existing physical representation of this machine.\n        id_file = @data_dir.join(\"id\")\n        id_content = id_file.read.strip if id_file.file?\n        if !id_content.to_s.empty?\n          @id = id_content\n        end",
    "comment": "This reloads the ID of the underlying machine.",
    "label": "",
    "id": "73"
  },
  {
    "raw_code": "def ssh_info\n      # First, ask the provider for their information. If the provider\n      # returns nil, then the machine is simply not ready for SSH, and\n      # we return nil as well.\n      info = @provider.ssh_info\n      return nil if info.nil?\n\n      # Delete out the nil entries.\n      info.dup.each do |key, value|\n        info.delete(key) if value.nil?\n      end",
    "comment": "This returns the SSH info for accessing this machine. This SSH info is queried from the underlying provider. This method returns `nil` if the machine is not ready for SSH communication.  The structure of the resulting hash is guaranteed to contain the following structure, although it may return other keys as well not documented here:  { host: \"1.2.3.4\", port: \"22\", username: \"mitchellh\", private_key_path: \"/path/to/my/key\" }  Note that Vagrant makes no guarantee that this info works or is correct. This is simply the data that the provider gives us or that is configured via a Vagrantfile. It is still possible after this point when attempting to connect via SSH to get authentication errors.  @return [Hash] SSH information.",
    "label": "",
    "id": "74"
  },
  {
    "raw_code": "def state\n      result = @provider.state\n      raise Errors::MachineStateInvalid if !result.is_a?(MachineState)\n\n      # Update our state cache if we have a UUID and an entry in the\n      # master index.\n      uuid = index_uuid\n      if uuid\n        # active_machines provides access to query this info on each machine\n        # from a different thread, ensure multiple machines do not access\n        # the locked entry simultaneously as this triggers a locked machine\n        # exception.\n        @state_mutex.synchronize do\n          entry = @env.machine_index.get(uuid)\n          if entry\n            entry.state = result.short_description\n            @env.machine_index.set(entry)\n            @env.machine_index.release(entry)\n          end",
    "comment": "Returns the state of this machine. The state is queried from the backing provider, so it can be any arbitrary symbol.  @return [MachineState]",
    "label": "",
    "id": "75"
  },
  {
    "raw_code": "def recover_machine(state)\n      entry = @env.machine_index.get(index_uuid)\n      if entry\n        @env.machine_index.release(entry)\n        return entry\n      end",
    "comment": "Returns the state of this machine. The state is queried from the backing provider, so it can be any arbitrary symbol.  @param [Symbol] state of machine @return [Entry] entry of recovered machine",
    "label": "",
    "id": "76"
  },
  {
    "raw_code": "def uid\n      path = uid_file\n      return nil if !path\n      return nil if !path.file?\n      return uid_file.read.chomp\n    end",
    "comment": "Returns the user ID that created this machine. This is specific to the host machine that this was created on.  @return [String]",
    "label": "",
    "id": "77"
  },
  {
    "raw_code": "def with_ui(ui)\n      @ui_mutex.synchronize do\n        begin\n          old_ui = @ui\n          @ui    = ui\n          yield\n        ensure\n          @ui = old_ui\n        end",
    "comment": "Temporarily changes the machine UI. This is useful if you want to execute an {#action} with a different UI.",
    "label": "",
    "id": "78"
  },
  {
    "raw_code": "def synced_folders\n      self.class.synced_folders(self)\n    end",
    "comment": "This returns the set of shared folders that should be done for this machine. It returns the folders in a hash keyed by the implementation class for the synced folders.  @return [Hash<Symbol, Hash<String, Hash>>]",
    "label": "",
    "id": "79"
  },
  {
    "raw_code": "def uid_file\n      return nil if !@data_dir\n      @data_dir.join(\"creator_uid\")\n    end",
    "comment": "Returns the path to the file that stores the UID.",
    "label": "",
    "id": "80"
  },
  {
    "raw_code": "def check_cwd\n      desired_encoding = @env.root_path.to_s.encoding\n      vagrant_cwd_filepath = @data_dir.join('vagrant_cwd')\n      vagrant_cwd = if File.exist?(vagrant_cwd_filepath)\n                      File.read(vagrant_cwd_filepath,\n                        external_encoding: desired_encoding\n                      ).chomp\n                    end",
    "comment": "Checks the current directory for a given machine and displays a warning if that machine has moved from its previous location on disk. If the machine has moved, it prints a warning to the user.",
    "label": "",
    "id": "81"
  },
  {
    "raw_code": "def initialize(loader, keys)\n      @keys   = keys\n      @loader = loader\n      @config, _ = loader.load(keys)\n      @logger = Log4r::Logger.new(\"vagrant::vagrantfile\")\n    end",
    "comment": "Initializes by loading a Vagrantfile.  @param [Config::Loader] loader Configuration loader that should already be configured with the proper Vagrantfile locations. This usually comes from {Vagrant::Environment} @param [Array<Symbol>] keys The Vagrantfiles to load and the order to load them in (keys within the loader).",
    "label": "",
    "id": "82"
  },
  {
    "raw_code": "def machine(name, provider, boxes, data_path, env)\n      # Load the configuration for the machine\n      results = machine_config(name, provider, boxes, data_path)\n      box             = results[:box]\n      config          = results[:config]\n      config_errors   = results[:config_errors]\n      config_warnings = results[:config_warnings]\n      provider_cls    = results[:provider_cls]\n      provider_options = results[:provider_options]\n\n      # If there were warnings or errors we want to output them\n      if !config_warnings.empty? || !config_errors.empty?\n        # The color of the output depends on whether we have warnings\n        # or errors...\n        level  = config_errors.empty? ? :warn : :error\n        output = Util::TemplateRenderer.render(\n          \"config/messages\",\n          warnings: config_warnings,\n          errors: config_errors).chomp\n        env.ui.send(level, I18n.t(\"vagrant.general.config_upgrade_messages\",\n                               name: name,\n                               output: output))\n\n        # If we had errors, then we bail\n        raise Errors::ConfigUpgradeErrors if !config_errors.empty?\n      end",
    "comment": "Returns a {Machine} for the given name and provider that is represented by this Vagrantfile.  @param [Symbol] name Name of the machine. @param [Symbol] provider The provider the machine should be backed by (required for provider overrides). @param [BoxCollection] boxes BoxCollection to look up the box Vagrantfile. @param [Pathname] data_path Path where local machine data can be stored. @param [Environment] env The environment running this machine @return [Machine]",
    "label": "",
    "id": "83"
  },
  {
    "raw_code": "def machine_config(name, provider, boxes, data_path=nil, validate_provider=true)\n      keys = @keys.dup\n\n      sub_machine = @config.vm.defined_vms[name]\n      if !sub_machine\n        raise Errors::MachineNotFound,\n          name: name, provider: provider\n      end",
    "comment": "Returns the configuration for a single machine.  When loading a box Vagrantfile, it will be prepended to the key order specified when initializing this class. Sub-machine and provider-specific overrides are appended at the end. The actual order is:  - box - keys specified for #initialize - sub-machine - provider  The return value is a hash with the following keys (symbols) and values:  - box: the {Box} backing the machine - config: the actual configuration - config_errors: list of errors, if any - config_warnings: list of warnings, if any - provider_cls: class of the provider backing the machine - provider_options: options for the provider  @param [Symbol] name Name of the machine. @param [Symbol] provider The provider the machine should be backed by (required for provider overrides). @param [BoxCollection] boxes BoxCollection to look up the box Vagrantfile. @param [Pathname] data_path Machine data path @return [Hash<Symbol, Object>] Various configuration parameters for a machine. See the main documentation body for more info.",
    "label": "",
    "id": "84"
  },
  {
    "raw_code": "def machine_names\n      @config.vm.defined_vm_keys.dup\n    end",
    "comment": "Returns a list of the machines that are defined within this Vagrantfile.  @return [Array<Symbol>]",
    "label": "",
    "id": "85"
  },
  {
    "raw_code": "def machine_names_and_options\n      {}.tap do |r|\n        @config.vm.defined_vms.each do |name, subvm|\n          r[name] = subvm.options || {}\n        end",
    "comment": "Returns a list of the machine names as well as the options that were specified for that machine.  @return [Hash<Symbol, Hash>]",
    "label": "",
    "id": "86"
  },
  {
    "raw_code": "def primary_machine_name\n      # If it is a single machine environment, then return the name\n      return machine_names.first if machine_names.length == 1\n\n      # If it is a multi-machine environment, then return the primary\n      @config.vm.defined_vms.each do |name, subvm|\n        return name if subvm.options[:primary]\n      end",
    "comment": "Returns the name of the machine that is designated as the \"primary.\"  In the case of a single-machine environment, this is just the single machine name. In the case of a multi-machine environment, then this is the machine that is marked as primary, or nil if no primary machine was specified.  @return [Symbol]",
    "label": "",
    "id": "87"
  },
  {
    "raw_code": "def self.action_box_add\n      Builder.new.tap do |b|\n        b.use Builtin::BoxAdd\n      end",
    "comment": "This is the action that will add a box from a URL. This middleware sequence is built-in to Vagrant. Plugins can hook into this like any other middleware sequence. This is particularly useful for provider plugins, which can hook in to do things like verification of boxes that are downloaded.",
    "label": "",
    "id": "88"
  },
  {
    "raw_code": "def self.action_box_outdated\n      Builder.new.tap do |b|\n        b.use Builtin::BoxCheckOutdated\n      end",
    "comment": "This actions checks if a box is outdated in a given Vagrant environment for a single machine.",
    "label": "",
    "id": "89"
  },
  {
    "raw_code": "def self.action_box_remove\n      Builder.new.tap do |b|\n        b.use Builtin::BoxRemove\n      end",
    "comment": "This is the action that will remove a box given a name (and optionally a provider). This middleware sequence is built-in to Vagrant. Plugins can hook into this like any other middleware sequence.",
    "label": "",
    "id": "90"
  },
  {
    "raw_code": "def color?\n        return false\n      end",
    "comment": "@return [false]",
    "label": "",
    "id": "91"
  },
  {
    "raw_code": "def machine(type, *data)\n        @logger.info(\"Machine: #{type} #{data.inspect}\")\n      end",
    "comment": "For machine-readable output.  @param [String] type The type of the data @param [Array] data The data associated with the type",
    "label": "",
    "id": "92"
  },
  {
    "raw_code": "def rewriting\n        yield self\n      end",
    "comment": "Yields self (UI) Provides a way for selectively displaying or not displaying updating content like download progress.",
    "label": "",
    "id": "93"
  },
  {
    "raw_code": "def report_progress(progress, total, show_parts=true)\n        if total && total > 0\n          percent = (progress.to_f / total.to_f) * 100\n          line    = \"Progress: #{percent.to_i}%\"\n          line   << \" (#{progress} / #{total})\" if show_parts\n        else\n          line    = \"Progress: #{progress}\"\n        end",
    "comment": "This is used to output progress reports to the UI. Send this method progress/total and it will output it to the UI. Send `clear_line` to clear the line to show a continuous progress meter.",
    "label": "",
    "id": "94"
  },
  {
    "raw_code": "def say(type, message, opts={})\n        defaults = { new_line: true, prefix: true }\n        opts     = defaults.merge(@opts).merge(opts)\n\n        # Don't output if we're hiding details\n        return if type == :detail && opts[:hide_detail]\n\n        # Determine whether we're expecting to output our\n        # own new line or not.\n        printer = opts[:new_line] ? :puts : :print\n\n        # Determine the proper IO channel to send this message\n        # to based on the type of the message\n        channel = type == :error || opts[:channel] == :error ? @stderr : @stdout\n\n        # Output! We wrap this in a lock so that it safely outputs only\n        # one line at a time. We wrap this in a thread because as of Ruby 2.0\n        # we can't acquire locks in a trap context (ctrl-c), so we have to\n        # do this.\n        Thread.new do\n          @lock.synchronize do\n            safe_puts(format_message(type, message, **opts),\n                      io: channel, printer: printer)\n          end",
    "comment": "This method handles actually outputting a message of a given type to the console.",
    "label": "",
    "id": "95"
  },
  {
    "raw_code": "def machine(type, *data)\n        opts = {}\n        opts = data.pop if data.last.is_a?(Hash)\n        opts[:target] = @prefix\n        data << opts\n        @ui.machine(type, *data)\n      end",
    "comment": "For machine-readable output, set the prefix in the options hash and continue it on.",
    "label": "",
    "id": "96"
  },
  {
    "raw_code": "def opts\n        @ui.opts\n      end",
    "comment": "Return the parent's opts.  @return [Hash]",
    "label": "",
    "id": "97"
  },
  {
    "raw_code": "def color?\n        return true\n      end",
    "comment": "@return [true]",
    "label": "",
    "id": "98"
  },
  {
    "raw_code": "def format_message(type, message, **opts)\n        # Get the format of the message before adding color.\n        message = super\n\n        opts = @opts.merge(opts)\n\n        # Special case some colors for certain message types\n        opts[:color] = :red if type == :error\n        opts[:color] = :green if type == :success\n        opts[:color] = :yellow if type == :warn\n\n        # If it is a detail, it is not bold. Every other message type\n        # is bolded.\n        bold  = !!opts[:bold]\n        colorseq = \"#{bold ? 1 : 0 }\"\n        if opts[:color] && opts[:color] != :default\n          color = COLORS[opts[:color]]\n          colorseq += \";#{color}\"\n        end",
    "comment": "This is called by `say` to format the message for output.",
    "label": "",
    "id": "99"
  },
  {
    "raw_code": "def error_message; \"No error message\"; end\n\n      # The default error namespace which is used for the error key.\n      # This can be overridden here or by calling the \"error_namespace\"\n      # class method.\n      def error_namespace; \"vagrant.errors\"; end\n\n      # The key for the error message. This should be set using the\n      # {error_key} method but can be overridden here if needed.\n      def error_key; nil; end\n\n      # This is the exit code that should be used when exiting from\n      # this exception.\n      #\n      # @return [Integer]\n      def status_code; 1; end\n\n      protected\n\n      def translate_error(opts)\n        return nil if !opts[:_key]\n        I18n.t(\"#{opts[:_namespace]}.#{opts[:_key]}\", **opts)\n      end\n    end\n\n    class ActiveMachineWithDifferentProvider < VagrantError\n      error_key(:active_machine_with_different_provider)\n    end\n\n    class AliasInvalidError < VagrantError\n      error_key(:alias_invalid_error)\n    end\n\n    class BatchMultiError < VagrantError\n      error_key(:batch_multi_error)\n    end",
    "comment": "The error message for this error. This is used if no error_key is specified for a translatable error message.",
    "label": "",
    "id": "100"
  },
  {
    "raw_code": "def commands\n      @aliases\n    end",
    "comment": "This returns all the registered alias commands.",
    "label": "",
    "id": "101"
  },
  {
    "raw_code": "def interpret(line)\n      # is it a comment?\n      return nil if line.strip.start_with?(\"#\")\n\n      keyword, command = line.split(\"=\", 2).collect(&:strip)\n\n      # validate the keyword\n      if keyword.match(/\\s/i)\n        raise Errors::AliasInvalidError, alias: line, message: \"Alias keywords must not contain any whitespace.\"\n      end",
    "comment": "This interprets a raw line from the aliases file.",
    "label": "",
    "id": "102"
  },
  {
    "raw_code": "def register(keyword, command)\n      @aliases.register(keyword.to_sym) do\n        lambda do |args|\n          # directly execute shell commands\n          if command.start_with?(\"!\")\n            return Util::SafeExec.exec \"#{command[1..-1]} #{args.join(\" \")}\".strip\n          end",
    "comment": "This registers an alias.",
    "label": "",
    "id": "103"
  },
  {
    "raw_code": "def self.global_lock\n    @@global_lock.synchronize do\n      return yield\n    end",
    "comment": "This holds a global lock for the duration of the block. This should be invoked around anything that is modifying process state (such as environmental variables).",
    "label": "",
    "id": "104"
  },
  {
    "raw_code": "def self.in_installer?\n    !!ENV[\"VAGRANT_INSTALLER_ENV\"]\n  end",
    "comment": "This returns a true/false showing whether we're running from the environment setup by the Vagrant installers.  @return [Boolean]",
    "label": "",
    "id": "105"
  },
  {
    "raw_code": "def self.in_bundler?\n    !!ENV[\"BUNDLE_GEMFILE\"] &&\n      !defined?(::Bundler).nil?\n  end",
    "comment": "This returns a true/false if we are running within a bundler environment  @return [Boolean]",
    "label": "",
    "id": "106"
  },
  {
    "raw_code": "def self.installer_embedded_dir\n    return nil if !Vagrant.in_installer?\n    ENV[\"VAGRANT_INSTALLER_EMBEDDED_DIR\"]\n  end",
    "comment": "Returns the path to the embedded directory of the Vagrant installer, if there is one (if we're running in an installer).  @return [String]",
    "label": "",
    "id": "107"
  },
  {
    "raw_code": "def self.plugins_init?\n    !ENV['VAGRANT_DISABLE_PLUGIN_INIT']\n  end",
    "comment": "Should the plugin system be initialized  @return [Boolean]",
    "label": "",
    "id": "108"
  },
  {
    "raw_code": "def self.plugins_enabled?\n    !ENV[\"VAGRANT_NO_PLUGINS\"]\n  end",
    "comment": "This returns whether or not 3rd party plugins should and can be loaded.  @return [Boolean]",
    "label": "",
    "id": "109"
  },
  {
    "raw_code": "def self.very_quiet?\n    !!ENV[\"VAGRANT_I_KNOW_WHAT_IM_DOING_PLEASE_BE_QUIET\"]\n  end",
    "comment": "Whether or not super quiet mode is enabled. This is ill-advised.  @return [Boolean]",
    "label": "",
    "id": "110"
  },
  {
    "raw_code": "def self.log_level\n    ENV.fetch(\"VAGRANT_LOG\", \"fatal\").downcase\n  end",
    "comment": "The current log level for Vagrant  @return [String]",
    "label": "",
    "id": "111"
  },
  {
    "raw_code": "def self.server_url(config_server_url=nil)\n    result = ENV[\"VAGRANT_SERVER_URL\"]\n    result = config_server_url if result == \"\" or result == nil\n    result || DEFAULT_SERVER_URL\n  end",
    "comment": "Returns the URL prefix to the server.  @return [String]",
    "label": "",
    "id": "112"
  },
  {
    "raw_code": "def self.source_root\n    @source_root ||= Pathname.new(File.expand_path('../../../', __FILE__))\n  end",
    "comment": "The source root is the path to the root directory of the Vagrant source.  @return [Pathname]",
    "label": "",
    "id": "113"
  },
  {
    "raw_code": "def self.user_data_path\n    # Use user specified env var if available\n    path = ENV[\"VAGRANT_HOME\"]\n\n    # On Windows, we default to the USERPROFILE directory if it\n    # is available. This is more compatible with Cygwin and sharing\n    # the home directory across shells.\n    if !path && ENV[\"USERPROFILE\"]\n      path = \"#{ENV[\"USERPROFILE\"]}/.vagrant.d\"\n    end",
    "comment": "This returns the path to the ~/.vagrant.d folder where Vagrant's per-user state is stored.  @return [Pathname]",
    "label": "",
    "id": "114"
  },
  {
    "raw_code": "def self.prerelease?\n    Gem::Version.new(Vagrant::VERSION).prerelease?\n  end",
    "comment": "This returns true/false if the running version of Vagrant is a pre-release version (development)  @return [Boolean]",
    "label": "",
    "id": "115"
  },
  {
    "raw_code": "def self.allow_prerelease_dependencies?\n    !!ENV[\"VAGRANT_ALLOW_PRERELEASE\"]\n  end",
    "comment": "This returns true/false if the Vagrant should allow prerelease versions when resolving plugin dependency constraints  @return [Boolean]",
    "label": "",
    "id": "116"
  },
  {
    "raw_code": "def self.strict_dependency_enforcement\n    if ENV[\"VAGRANT_DISABLE_STRICT_DEPENDENCY_ENFORCEMENT\"]\n      false\n    else\n      true\n    end",
    "comment": "This allows control over dependency resolution when installing plugins into vagrant. When true, dependency libraries that Vagrant core relies upon will be hard constraints.  @return [Boolean]",
    "label": "",
    "id": "117"
  },
  {
    "raw_code": "def self.auto_install_local_plugins?\n    if ENV[\"VAGRANT_INSTALL_LOCAL_PLUGINS\"]\n      true\n    else\n      false\n    end",
    "comment": "Automatically install locally defined plugins instead of waiting for user confirmation.  @return [Boolean]",
    "label": "",
    "id": "118"
  },
  {
    "raw_code": "def self.enable_resolv_replace\n    if ENV[\"VAGRANT_ENABLE_RESOLV_REPLACE\"]\n      if !ENV[\"VAGRANT_DISABLE_RESOLV_REPLACE\"]\n        begin\n          require \"resolv-replace\"\n          true\n        rescue\n          false\n        end",
    "comment": "Use Ruby Resolv in place of libc  @return [boolean] enabled or not",
    "label": "",
    "id": "119"
  },
  {
    "raw_code": "def self.global_logger=(log)\n    @_global_logger = log\n  end",
    "comment": "Set the global logger  @param log Logger @return [Logger]",
    "label": "",
    "id": "120"
  },
  {
    "raw_code": "def self.global_logger\n    if @_global_logger.nil?\n      require \"log4r\"\n      @_global_logger = Log4r::Logger.new(\"vagrant::global\")\n    end",
    "comment": "Get the global logger instance  @return [Logger]",
    "label": "",
    "id": "121"
  },
  {
    "raw_code": "def self.add_default_cli_options(block)\n    if !block.is_a?(Proc)\n      raise TypeError,\n        \"Expecting type `Proc` but received `#{block.class}`\"\n    end",
    "comment": "Add a new block of default CLI options which should be automatically added to all commands  @param [Proc] block Proc instance containing OptParser configuration @return [nil]",
    "label": "",
    "id": "122"
  },
  {
    "raw_code": "def self.default_cli_options\n    @_default_cli_options = [] if !@_default_cli_options\n    @_default_cli_options.dup\n  end",
    "comment": "Array of default CLI options to automatically add to commands.  @return [Array<Proc>] Default optparse options",
    "label": "",
    "id": "123"
  },
  {
    "raw_code": "def action(machine, action, options=nil)\n      @actions << [machine, action, options]\n    end",
    "comment": "Add an action to the batch of actions that will be run.  This will **not** run the action now. The action will be run when {#run} is called.  @param [Machine] machine The machine to run the action on @param [Symbol] action The action to run @param [Hash] options Any additional options to send in.",
    "label": "",
    "id": "124"
  },
  {
    "raw_code": "def custom(machine, &block)\n      @actions << [machine, block, nil]\n    end",
    "comment": "Custom runs a custom proc against a machine.  @param [Machine] machine The machine to run against.",
    "label": "",
    "id": "125"
  },
  {
    "raw_code": "def run\n      par = false\n\n      if @allow_parallel\n        par = true\n        @logger.info(\"Enabling parallelization by default.\")\n      end",
    "comment": "Run all the queued up actions, parallelizing if possible.  This will parallelize if and only if the provider of every machine supports parallelization and parallelization is possible from initialization of the class.",
    "label": "",
    "id": "126"
  },
  {
    "raw_code": "def initialize(io, **_)\n      begin\n        @raw = JSON.load(io)\n      rescue JSON::ParserError => e\n        raise Errors::BoxMetadataMalformed,\n          error: e.to_s\n      end",
    "comment": "Loads the metadata associated with the box from the given IO.  @param [IO] io An IO object to read the metadata from.",
    "label": "",
    "id": "127"
  },
  {
    "raw_code": "def version(version, **opts)\n      requirements = version.split(\",\").map do |v|\n        Gem::Requirement.new(v.strip)\n      end",
    "comment": "Returns data about a single version that is included in this metadata.  @param [String] version The version to return, this can also be a constraint. @option [Symbol, Array<Symbol>] :provider Provider filter @option [Symbol] :architecture Architecture filter  @return [Version] The matching version or nil if a matching version was not found.",
    "label": "",
    "id": "128"
  },
  {
    "raw_code": "def versions(**opts)\n      architecture = opts[:architecture]\n      provider = Array(opts[:provider]).map(&:to_sym) if opts[:provider]\n\n      # Return full version list if no filters provided\n      if provider.nil? && architecture.nil?\n        return @version_map.keys.sort.map(&:to_s)\n      end",
    "comment": "Returns all the versions supported by this metadata. These versions are sorted so the last element of the list is the latest version. Optionally filter versions by a matching provider.  @option [Symbol, Array<Symbol>] :provider Provider filter @option [Symbol] :architecture Architecture filter  @return[Array<String>]",
    "label": "",
    "id": "129"
  },
  {
    "raw_code": "def provider(name, architecture=nil)\n        name = name.to_sym\n        arch_name = architecture\n        arch_name = Util::Platform.architecture if arch_name == :auto\n        arch_name = arch_name.to_s if arch_name\n\n        # If the provider doesn't exist in the map, return immediately\n        return if !@provider_map.key?(name)\n\n        # If the arch_name value is set, filter based\n        # on architecture and return match if found. If\n        # no match is found and architecture wasn't automatically\n        # detected, return nil as an explicit match is\n        # being requested\n        if arch_name\n          match = @provider_map[name].detect do |p|\n            p.architecture == arch_name\n          end",
    "comment": "Returns a [Provider] for the given name, or nil if it isn't supported by this version.",
    "label": "",
    "id": "130"
  },
  {
    "raw_code": "def providers(architecture=nil)\n        return @provider_map.keys.map(&:to_sym) if architecture.nil?\n\n        @provider_map.keys.find_all { |k|\n          provider(k, architecture)\n        }.map(&:to_sym)\n      end",
    "comment": "Returns the providers that are available for this version of the box.  @return [Array<Symbol>]",
    "label": "",
    "id": "131"
  },
  {
    "raw_code": "def detect!\n      guest_name = @machine.config.vm.guest\n      initialize_capabilities!(guest_name, @guests, @capabilities, @machine)\n    rescue Errors::CapabilityHostExplicitNotDetected => e\n      raise Errors::GuestExplicitNotDetected, value: e.extra_data[:value]\n    rescue Errors::CapabilityHostNotDetected\n      raise Errors::GuestNotDetected\n    end",
    "comment": "This will detect the proper guest OS for the machine and set up the class to actually execute capabilities.",
    "label": "",
    "id": "132"
  },
  {
    "raw_code": "def capability(*args)\n      super\n    rescue Errors::CapabilityNotFound => e\n      raise Errors::GuestCapabilityNotFound,\n        cap: e.extra_data[:cap],\n        guest: name\n    rescue Errors::CapabilityInvalid => e\n      raise Errors::GuestCapabilityInvalid,\n        cap: e.extra_data[:cap],\n        guest: name\n    end",
    "comment": "See {CapabilityHost#capability}",
    "label": "",
    "id": "133"
  },
  {
    "raw_code": "def name\n      capability_host_chain[0][0]\n    end",
    "comment": "Returns the specified or detected guest type name.  @return [Symbol]",
    "label": "",
    "id": "134"
  },
  {
    "raw_code": "def ready?\n      !!capability_host_chain\n    end",
    "comment": "This returns whether the guest is ready to work. If this returns `false`, then {#detect!} should be called in order to detect the guest OS.  @return [Boolean]",
    "label": "",
    "id": "135"
  },
  {
    "raw_code": "def initialize(opts=nil)\n      opts = {\n        cwd:              nil,\n        home_path:        nil,\n        local_data_path:  nil,\n        ui_class:         nil,\n        ui_opts:          nil,\n        vagrantfile_name: nil,\n      }.merge(opts || {})\n\n      # Set the default working directory to look for the vagrantfile\n      opts[:cwd] ||= ENV[\"VAGRANT_CWD\"] if ENV.key?(\"VAGRANT_CWD\")\n      opts[:cwd] ||= Dir.pwd\n      opts[:cwd] = Pathname.new(opts[:cwd])\n      if !opts[:cwd].directory?\n        raise Errors::EnvironmentNonExistentCWD, cwd: opts[:cwd].to_s\n      end",
    "comment": "Initializes a new environment with the given options. The options is a hash where the main available key is `cwd`, which defines where the environment represents. There are other options available but they shouldn't be used in general. If `cwd` is nil, then it defaults to the `Dir.pwd` (which is the cwd of the executing process).",
    "label": "",
    "id": "136"
  },
  {
    "raw_code": "def default_private_key_path\n      # TODO(spox): Add deprecation warning\n      @default_private_key_path\n    end",
    "comment": "The path to the default private key NOTE: deprecated, used default_private_keys_directory instead",
    "label": "",
    "id": "137"
  },
  {
    "raw_code": "def inspect\n      \"#<#{self.class}: #{@cwd}>\".encode('external')\n    end",
    "comment": "Return a human-friendly string for pretty printed or inspected instances.  @return [String]",
    "label": "",
    "id": "138"
  },
  {
    "raw_code": "def action_runner\n      @action_runner ||= Action::PrimaryRunner.new do\n        {\n          action_runner:  action_runner,\n          box_collection: boxes,\n          hook:           method(:hook),\n          host:           host,\n          machine_index:  machine_index,\n          gems_path:      gems_path,\n          home_path:      home_path,\n          root_path:      root_path,\n          tmp_path:       tmp_path,\n          ui:             @ui,\n          env:            self\n        }\n      end",
    "comment": "Action runner for executing actions in the context of this environment.  @return [Action::Runner]",
    "label": "",
    "id": "139"
  },
  {
    "raw_code": "def active_machines\n      # We have no active machines if we have no data path\n      return [] if !@local_data_path\n\n      machine_folder = @local_data_path.join(\"machines\")\n\n      # If the machine folder is not a directory then we just return\n      # an empty array since no active machines exist.\n      return [] if !machine_folder.directory?\n\n      # Traverse the machines folder accumulate a result\n      result = []\n\n      machine_folder.children(true).each do |name_folder|\n        # If this isn't a directory then it isn't a machine\n        next if !name_folder.directory?\n\n        name = name_folder.basename.to_s.to_sym\n        name_folder.children(true).each do |provider_folder|\n          # If this isn't a directory then it isn't a provider\n          next if !provider_folder.directory?\n\n          # If this machine doesn't have an ID, then ignore\n          next if !provider_folder.join(\"id\").file?\n\n          provider = provider_folder.basename.to_s.to_sym\n          result << [name, provider]\n        end",
    "comment": "Returns a list of machines that this environment is currently managing that physically have been created.  An \"active\" machine is a machine that Vagrant manages that has been created. The machine itself may be in any state such as running, suspended, etc. but if a machine is \"active\" then it exists.  Note that the machines in this array may no longer be present in the Vagrantfile of this environment. In this case the machine can be considered an \"orphan.\" Determining which machines are orphan and which aren't is not currently a supported feature, but will be in a future version.  @return [Array<String, Symbol>]",
    "label": "",
    "id": "140"
  },
  {
    "raw_code": "def batch(parallel=true)\n      parallel = false if ENV[\"VAGRANT_NO_PARALLEL\"]\n\n      @batch_lock.synchronize do\n        BatchAction.new(parallel).tap do |b|\n          # Yield it so that the caller can setup actions\n          yield b\n\n          # And run it!\n          b.run\n        end",
    "comment": "This creates a new batch action, yielding it, and then running it once the block is called.  This handles the case where batch actions are disabled by the VAGRANT_NO_PARALLEL environmental variable.",
    "label": "",
    "id": "141"
  },
  {
    "raw_code": "def cli(*args)\n      CLI.new(args.flatten, self).execute\n    end",
    "comment": "Makes a call to the CLI with the given arguments as if they came from the real command line (sometimes they do!). An example:  env.cli(\"package\", \"--vagrantfile\", \"Vagrantfile\") ",
    "label": "",
    "id": "142"
  },
  {
    "raw_code": "def default_provider(**opts)\n      opts[:exclude]       = Set.new(opts[:exclude]) if opts[:exclude]\n      opts[:force_default] = true if !opts.key?(:force_default)\n      opts[:check_usable] = true if !opts.key?(:check_usable)\n\n      # Implement the algorithm from\n      # https://www.vagrantup.com/docs/providers/basic_usage.html#default-provider\n      # with additional steps 2.5 and 3.5 from\n      # https://bugzilla.redhat.com/show_bug.cgi?id=1444492\n      # to allow system-configured provider priorities.\n      #\n      # 1. The --provider flag on a vagrant up is chosen above all else, if it is\n      #    present.\n      #\n      # (Step 1 is done by the caller; this method is only called if --provider\n      # wasn't given.)\n      #\n      # 2. If the VAGRANT_DEFAULT_PROVIDER environmental variable is set, it\n      #    takes next priority and will be the provider chosen.\n\n      default = ENV[\"VAGRANT_DEFAULT_PROVIDER\"].to_s\n      if default.empty?\n        default = nil\n      else\n        default = default.to_sym\n        @logger.debug(\"Default provider: `#{default}`\")\n      end",
    "comment": "This returns the provider name for the default provider for this environment.  @param check_usable [Boolean] (true) whether to filter for `.usable?` providers @param exclude [Array<Symbol>] ([]) list of provider names to exclude from consideration @param force_default [Boolean] (true) whether to prefer the value of VAGRANT_DEFAULT_PROVIDER over other strategies if it is set @param machine [Symbol] (nil) a machine name to scope this lookup @return [Symbol] Name of the default provider.",
    "label": "",
    "id": "143"
  },
  {
    "raw_code": "def can_install_provider?(name)\n      host.capability?(provider_install_key(name))\n    end",
    "comment": "Returns whether or not we know how to install the provider with the given name.  @return [Boolean]",
    "label": "",
    "id": "144"
  },
  {
    "raw_code": "def install_provider(name)\n      host.capability(provider_install_key(name))\n    end",
    "comment": "Installs the provider with the given name.  This will raise an exception if we don't know how to install the provider with the given name. You should guard this call with `can_install_provider?` for added safety.  An exception will be raised if there are any failures installing the provider.",
    "label": "",
    "id": "145"
  },
  {
    "raw_code": "def boxes\n      @_boxes ||= BoxCollection.new(\n        boxes_path,\n        hook: method(:hook),\n        temp_dir_root: tmp_path)\n    end",
    "comment": "Returns the collection of boxes for the environment.  @return [BoxCollection]",
    "label": "",
    "id": "146"
  },
  {
    "raw_code": "def config_loader\n      return @config_loader if @config_loader\n\n      home_vagrantfile = nil\n      root_vagrantfile = nil\n      home_vagrantfile = find_vagrantfile(home_path) if home_path\n      if root_path\n        root_vagrantfile = find_vagrantfile(root_path, @vagrantfile_name)\n      end",
    "comment": "Returns the {Config::Loader} that can be used to load Vagrantfiles given the settings of this environment.  @return [Config::Loader]",
    "label": "",
    "id": "147"
  },
  {
    "raw_code": "def environment(vagrantfile, **opts)\n      path = File.expand_path(vagrantfile, root_path)\n      file = File.basename(path)\n      path = File.dirname(path)\n\n      Util::SilenceWarnings.silence! do\n        Environment.new({\n          child:     true,\n          cwd:       path,\n          home_path: home_path,\n          ui_class:  ui_class,\n          vagrantfile_name: file,\n        }.merge(opts))\n      end",
    "comment": "Loads another environment for the given Vagrantfile, sharing as much useful state from this Environment as possible (such as UI and paths). Any initialization options can be overidden using the opts hash.  @param [String] vagrantfile Path to a Vagrantfile @return [Environment]",
    "label": "",
    "id": "148"
  },
  {
    "raw_code": "def hook(name, opts=nil)\n      @logger.info(\"Running hook: #{name}\")\n\n      opts ||= {}\n      opts[:callable] ||= Action::Builder.new\n      opts[:runner] ||= action_runner\n      opts[:action_name] = name\n      opts[:env] = self\n      opts.delete(:runner).run(opts.delete(:callable), opts)\n    end",
    "comment": "This defines a hook point where plugin action hooks that are registered against the given name will be run in the context of this environment.  @param [Symbol] name Name of the hook. @param [Action::Runner] action_runner A custom action runner for running hooks.",
    "label": "",
    "id": "149"
  },
  {
    "raw_code": "def host\n      return @host if defined?(@host)\n\n      # Determine the host class to use. \":detect\" is an old Vagrant config\n      # that shouldn't be valid anymore, but we respect it here by assuming\n      # its old behavior. No need to deprecate this because I thin it is\n      # fairly harmless.\n      host_klass = vagrantfile.config.vagrant.host\n      host_klass = nil if host_klass == :detect\n\n      begin\n        @host = Host.new(\n          host_klass,\n          Vagrant.plugin(\"2\").manager.hosts,\n          Vagrant.plugin(\"2\").manager.host_capabilities,\n          self)\n      rescue Errors::CapabilityHostNotDetected\n        # If the auto-detect failed, then we create a brand new host\n        # with no capabilities and use that. This should almost never happen\n        # since Vagrant works on most host OS's now, so this is a \"slow path\"\n        klass = Class.new(Vagrant.plugin(\"2\", :host)) do\n          def detect?(env); true; end\n        end\n\n        hosts     = { generic: [klass, nil] }\n        host_caps = {}\n\n        @host = Host.new(:generic, hosts, host_caps, self)\n      rescue Errors::CapabilityHostExplicitNotDetected => e\n        raise Errors::HostExplicitNotDetected, e.extra_data\n      end",
    "comment": "Returns the host object associated with this environment.  @return [Class]",
    "label": "",
    "id": "150"
  },
  {
    "raw_code": "def lock(name=\"global\", **opts)\n      f = nil\n\n      # If we don't have a block, then locking is useless, so ignore it\n      return if !block_given?\n\n      # This allows multiple locks in the same process to be nested\n      return yield if @locks[name] || opts[:noop]\n\n      # The path to this lock\n      lock_path = data_dir.join(\"lock.#{name}.lock\")\n\n      @logger.debug(\"Attempting to acquire process-lock: #{name}\")\n      lock(\"dotlock\", noop: name == \"dotlock\", retry: true) do\n        f = File.open(lock_path, \"w+\")\n      end",
    "comment": "This acquires a process-level lock with the given name.  The lock file is held within the data directory of this environment, so make sure that all environments that are locking are sharing the same data directory.  This will raise Errors::EnvironmentLockedError if the lock can't be obtained.  @param [String] name Name of the lock, since multiple locks can be held at one time.",
    "label": "",
    "id": "151"
  },
  {
    "raw_code": "def push(name, manager: Vagrant.plugin(\"2\").manager)\n      @logger.info(\"Getting push: #{name}\")\n\n      name = name.to_sym\n\n      pushes = self.vagrantfile.config.push.__compiled_pushes\n      if !pushes.key?(name)\n        raise Vagrant::Errors::PushStrategyNotDefined,\n          name: name,\n          pushes: pushes.keys\n      end",
    "comment": "This executes the push with the given name, raising any exceptions that occur.  @param name [String] Push plugin name @param manager [Vagrant::Plugin::Manager] Plugin Manager to use, defaults to the primary one registered but parameterized so it can be overridden in server mode  @see VagrantPlugins::CommandServe::Service::PushService Server mode behavior  Precondition: the push is not nil and exists.",
    "label": "",
    "id": "152"
  },
  {
    "raw_code": "def pushes\n      self.vagrantfile.config.push.__compiled_pushes.keys\n    end",
    "comment": "The list of pushes defined in this Vagrantfile.  @return [Array<Symbol>]",
    "label": "",
    "id": "153"
  },
  {
    "raw_code": "def machine(name, provider, refresh=false)\n      @logger.info(\"Getting machine: #{name} (#{provider})\")\n\n      # Compose the cache key of the name and provider, and return from\n      # the cache if we have that.\n      cache_key = [name, provider]\n      @machines ||= {}\n      if refresh\n        @logger.info(\"Refreshing machine (busting cache): #{name} (#{provider})\")\n        @machines.delete(cache_key)\n      end",
    "comment": "This returns a machine with the proper provider for this environment. The machine named by `name` must be in this environment.  @param [Symbol] name Name of the machine (as configured in the Vagrantfile). @param [Symbol] provider The provider that this machine should be backed by. @param [Boolean] refresh If true, then if there is a cached version it is reloaded. @return [Machine]",
    "label": "",
    "id": "154"
  },
  {
    "raw_code": "def machine_index\n      @machine_index ||= MachineIndex.new(@machine_index_dir)\n    end",
    "comment": "The {MachineIndex} to store information about the machines.  @return [MachineIndex]",
    "label": "",
    "id": "155"
  },
  {
    "raw_code": "def machine_names\n      vagrantfile.machine_names\n    end",
    "comment": "This returns a list of the configured machines for this environment. Each of the names returned by this method is valid to be used with the {#machine} method.  @return [Array<Symbol>] Configured machine names.",
    "label": "",
    "id": "156"
  },
  {
    "raw_code": "def primary_machine_name\n      vagrantfile.primary_machine_name\n    end",
    "comment": "This returns the name of the machine that is the \"primary.\" In the case of  a single-machine environment, this is just the single machine name. In the case of a multi-machine environment, then this can potentially be nil if no primary machine is specified.  @return [Symbol]",
    "label": "",
    "id": "157"
  },
  {
    "raw_code": "def root_path\n      return @root_path if defined?(@root_path)\n\n      root_finder = lambda do |path|\n        # Note: To remain compatible with Ruby 1.8, we have to use\n        # a `find` here instead of an `each`.\n        vf = find_vagrantfile(path, @vagrantfile_name)\n        return path if vf\n        return nil if path.root? || !File.exist?(path)\n        root_finder.call(path.parent)\n      end",
    "comment": "The root path is the path where the top-most (loaded last) Vagrantfile resides. It can be considered the project root for this environment.  @return [String]",
    "label": "",
    "id": "158"
  },
  {
    "raw_code": "def unload\n      hook(:environment_unload)\n    end",
    "comment": "Unload the environment, running completion hooks. The environment should not be used after this (but CAN be, technically). It is recommended to always immediately set the variable to `nil` after running this so you can't accidentally run any more methods. Example:  env.unload env = nil ",
    "label": "",
    "id": "159"
  },
  {
    "raw_code": "def vagrantfile\n      @vagrantfile ||= Vagrantfile.new(config_loader, [:home, :root])\n    end",
    "comment": "Represents the default Vagrantfile, or the Vagrantfile that is in the working directory or a parent of the working directory of this environment.  The existence of this function is primarily a convenience. There is nothing stopping you from instantiating your own {Vagrantfile} and loading machines in any way you see fit. Typical behavior of Vagrant, however, loads this Vagrantfile.  This Vagrantfile is comprised of two major sources: the Vagrantfile in the user's home directory as well as the \"root\" Vagrantfile or the Vagrantfile in the working directory (or parent).  @return [Vagrantfile]",
    "label": "",
    "id": "160"
  },
  {
    "raw_code": "def setup_home_path\n      @logger.info(\"Home path: #{@home_path}\")\n\n      # Setup the list of child directories that need to be created if they\n      # don't already exist.\n      dirs    = [\n        @home_path,\n        @home_path.join(\"rgloader\"),\n        @boxes_path,\n        @data_dir,\n        @gems_path,\n        @tmp_path,\n        @machine_index_dir,\n      ]\n\n      # Go through each required directory, creating it if it doesn't exist\n      dirs.each do |dir|\n        next if File.directory?(dir)\n\n        begin\n          @logger.info(\"Creating: #{dir}\")\n          FileUtils.mkdir_p(dir)\n        rescue Errno::EACCES, Errno::EROFS\n          raise Errors::HomeDirectoryNotAccessible, home_path: @home_path.to_s\n        end",
    "comment": "--------------------------------------------------------------- Load Methods --------------------------------------------------------------- This sets the `@home_path` variable properly.  @return [Pathname]",
    "label": "",
    "id": "161"
  },
  {
    "raw_code": "def setup_local_data_path(force=false)\n      if @local_data_path.nil?\n        @logger.warn(\"No local data path is set. Local data cannot be stored.\")\n        return\n      end",
    "comment": "This creates the local data directory and show an error if it couldn't properly be created.",
    "label": "",
    "id": "162"
  },
  {
    "raw_code": "def guess_provider\n      gp = nil\n      ARGV.each_with_index do |val, idx|\n        if val.start_with?(\"--provider=\")\n          gp = val.split(\"=\", 2).last\n          break\n        elsif val == \"--provider\"\n          gp = ARGV[idx+1]\n          break\n        end",
    "comment": "Attempt to guess the configured provider in use. Will fallback to the default provider if an explicit provider name is not provided. This can be pretty error prone, but is used during initial environment setup to allow loading plugins so it doesn't need to be perfect  @return [String]",
    "label": "",
    "id": "163"
  },
  {
    "raw_code": "def find_configured_plugins\n      plugins = []\n      provider = guess_provider\n      vagrantfile.machine_names.each do |mname|\n        ldp = @local_data_path.join(\"machines/#{mname}/#{provider}\") if @local_data_path\n        plugins << vagrantfile.machine_config(mname, provider, boxes, ldp, false)[:config]\n      end",
    "comment": "Load any configuration provided by guests defined within the Vagrantfile to pull plugin information they may have defined.",
    "label": "",
    "id": "164"
  },
  {
    "raw_code": "def process_configured_plugins\n      return if !Vagrant.plugins_enabled?\n      errors = vagrantfile.config.vagrant.validate(nil)\n      if !Array(errors[\"vagrant\"]).empty?\n        raise Errors::ConfigInvalid,\n          errors: Util::TemplateRenderer.render(\n            \"config/validation_failed\",\n            errors: {vagrant: errors[\"vagrant\"]}\n          )\n      end",
    "comment": "Check for any local plugins defined within the Vagrantfile. If found, validate they are available. If they are not available, request to install them, or raise an exception  @return [Hash] plugin list for loading",
    "label": "",
    "id": "165"
  },
  {
    "raw_code": "def copy_insecure_private_keys\n      # First setup the deprecated single key path\n      if !@default_private_key_path.exist?\n        @logger.info(\"Copying private key to home directory\")\n\n        source      = File.expand_path(\"keys/vagrant\", Vagrant.source_root)\n        destination = @default_private_key_path\n\n        begin\n          FileUtils.cp(source, destination)\n        rescue Errno::EACCES\n          raise Errors::CopyPrivateKeyFailed,\n            source: source,\n            destination: destination\n        end",
    "comment": "This method copies the private keys into the home directory if they do not already exist. The `default_private_key_path` references the original rsa based private key and is retained for compatibility. The `default_private_keys_directory` contains the list of valid private keys supported by Vagrant.  NOTE: The keys are copied because `ssh` requires that the key is chmod 0600, but if Vagrant is installed as a separate user, then the effective uid won't be able to read the key. So the key is copied to the home directory and chmod 0600.",
    "label": "",
    "id": "166"
  },
  {
    "raw_code": "def find_vagrantfile(search_path, filenames=nil)\n      filenames ||= [\"Vagrantfile\", \"vagrantfile\"]\n      filenames.each do |vagrantfile|\n        current_path = search_path.join(vagrantfile)\n        return current_path if current_path.file?\n      end",
    "comment": "Finds the Vagrantfile in the given directory.  @param [Pathname] path Path to search in. @return [Pathname]",
    "label": "",
    "id": "167"
  },
  {
    "raw_code": "def provider_install_key(name)\n      \"provider_install_#{name}\".to_sym\n    end",
    "comment": "Returns the key used for the host capability for provider installs of the given name.",
    "label": "",
    "id": "168"
  },
  {
    "raw_code": "def upgrade_home_path_v1_1\n      if !ENV[\"VAGRANT_UPGRADE_SILENT_1_5\"]\n        @ui.ask(I18n.t(\"vagrant.upgrading_home_path_v1_5\"))\n      end",
    "comment": "This upgrades a home directory that was in the v1.1 format to the v1.5 format. It will raise exceptions if anything fails.",
    "label": "",
    "id": "169"
  },
  {
    "raw_code": "def upgrade_v1_dotfile(path)\n      @logger.info(\"Upgrading V1 dotfile to V2 directory structure...\")\n\n      # First, verify the file isn't empty. If it is an empty file, we\n      # just delete it and go on with life.\n      contents = path.read.strip\n      if contents.strip == \"\"\n        @logger.info(\"V1 dotfile was empty. Removing and moving on.\")\n        path.delete\n        return\n      end",
    "comment": "This upgrades a Vagrant 1.0.x \"dotfile\" to the new V2 format.  This is a destructive process. Once the upgrade is complete, the old dotfile is removed, and the environment becomes incompatible for Vagrant 1.0 environments.  @param [Pathname] path The path to the dotfile",
    "label": "",
    "id": "170"
  },
  {
    "raw_code": "def self.run(version=\"1\", &block)\n      # Store it for later\n      @last_procs ||= []\n      @last_procs << [version.to_s, block]\n    end",
    "comment": "This is the method which is called by all Vagrantfiles to configure Vagrant. This method expects a block which accepts a single argument representing an instance of the {Config::Top} class.  Note that the block is not run immediately. Instead, it's proc is stored away for execution later.",
    "label": "",
    "id": "171"
  },
  {
    "raw_code": "def self.capture_configures\n      CONFIGURE_MUTEX.synchronize do\n        # Reset the last procs so that we start fresh\n        @last_procs = []\n\n        # Yield to allow the caller to do whatever loading needed\n        yield\n\n        # Return the last procs we've seen while still in the mutex,\n        # knowing we're safe.\n        return @last_procs\n      end",
    "comment": "This is a method which will yield to a block and will capture all ``Vagrant.configure`` calls, returning an array of `Proc`s.  Wrapping this around anytime you call code which loads configurations will force a mutex so that procs never get mixed up. This keeps the configuration loading part of Vagrant thread-safe.",
    "label": "",
    "id": "172"
  },
  {
    "raw_code": "def initialize(plugin_file:, solution_file: nil)\n        @logger = Log4r::Logger.new(\"vagrant::bundler::solution_file\")\n        @plugin_file = Pathname.new(plugin_file.to_s)\n        if solution_file\n          @solution_file = Pathname.new(solution_file.to_s)\n        else\n          @solution_file = Pathname.new(@plugin_file.to_s + \".sol\")\n        end",
    "comment": "@param [Pathname] plugin_file Path to plugin file @param [Pathname] solution_file Custom path to solution file",
    "label": "",
    "id": "173"
  },
  {
    "raw_code": "def dependency_list=(dependency_list)\n        Array(dependency_list).each do |d|\n          if !d.is_a?(Gem::Dependency)\n            raise TypeError, \"Expected `Gem::Dependency` but received `#{d.class}`\"\n          end",
    "comment": "Set the list of dependencies for this solution  @param [Array<Gem::Dependency>] dependency_list List of dependencies for the solution @return [Array<Gem::Resolver::DependencyRequest>]",
    "label": "",
    "id": "174"
  },
  {
    "raw_code": "def valid?\n        @valid\n      end",
    "comment": "@return [Boolean] contained solution is valid",
    "label": "",
    "id": "175"
  },
  {
    "raw_code": "def invalidate!\n        @valid = false\n        @logger.debug(\"manually invalidating solution file #{self}\")\n        @valid\n      end",
    "comment": "@return [FalseClass] invalidate this solution file",
    "label": "",
    "id": "176"
  },
  {
    "raw_code": "def delete!\n        if !solution_file.exist?\n          @logger.debug(\"solution file does not exist. nothing to delete.\")\n          return false\n        end",
    "comment": "Delete the solution file  @return [Boolean] true if file was deleted",
    "label": "",
    "id": "177"
  },
  {
    "raw_code": "def store!\n        if !plugin_file.exist?\n          @logger.debug(\"plugin file does not exist, not storing solution\")\n          return\n        end",
    "comment": "Store the solution file",
    "label": "",
    "id": "178"
  },
  {
    "raw_code": "def load\n        if !plugin_file.exist? || !solution_file.exist?\n          @logger.debug(\"missing file so skipping loading\")\n          return\n        end",
    "comment": "Load the solution file for the plugin path provided if it exists. Validate solution is still applicable before injecting dependencies.",
    "label": "",
    "id": "179"
  },
  {
    "raw_code": "def valid_solution?(checksum:, version:)\n        file_checksum = plugin_file_checksum\n        @logger.debug(\"solution validation check CHECKSUM #{file_checksum} <-> #{checksum}\" \\\n          \" VERSION #{Vagrant::VERSION} <-> #{version}\")\n        plugin_file_checksum == checksum &&\n          Vagrant::VERSION == version\n      end",
    "comment": "Validate the given checksum matches the plugin file checksum  @param [String] checksum Checksum value to validate @return [Boolean]",
    "label": "",
    "id": "180"
  },
  {
    "raw_code": "def plugin_file_checksum\n        digest = Digest::SHA256.new\n        digest.file(plugin_file.to_s)\n        digest.hexdigest\n      end",
    "comment": "@return [String] checksum of plugin file",
    "label": "",
    "id": "181"
  },
  {
    "raw_code": "def read_solution\n        @logger.debug(\"reading solution file - #{solution_file}\")\n        begin\n          hash = JSON.load(solution_file.read)\n          Vagrant::Util::HashWithIndifferentAccess.new(hash)\n        rescue => err\n          @logger.warn(\"failed to load solution file, ignoring (error: #{err})\")\n          nil\n        end",
    "comment": "Read contents of solution file and parse  @return [Hash]",
    "label": "",
    "id": "182"
  },
  {
    "raw_code": "def environment_path=(env_data_path)\n      if !env_data_path.is_a?(Pathname)\n        raise TypeError, \"Expected `Pathname` but received `#{env_data_path.class}`\"\n      end",
    "comment": "Enable Vagrant environment specific plugins at given data path  @param [Pathname] Path to Vagrant::Environment data directory @return [Pathname] Path to environment specific gem directory",
    "label": "",
    "id": "183"
  },
  {
    "raw_code": "def load_solution_file(opts={})\n      return if !opts[:local] && !opts[:global]\n      return if opts[:local] && opts[:global]\n      return if opts[:local] && environment_data_path.nil?\n      solution_path = (environment_data_path || Vagrant.user_data_path) + \"bundler\"\n      solution_path += opts[:local] ? \"local.sol\" : \"global.sol\"\n      SolutionFile.new(\n        plugin_file: opts[:local] || opts[:global],\n        solution_file: solution_path\n      )\n    end",
    "comment": "Use the given options to create a solution file instance for use during initialization. When a Vagrant environment is in use, solution files will be stored within the environment's data directory. This is because the solution for loading global plugins is dependent on any solution generated for local plugins. When no Vagrant environment is in use (running Vagrant without a Vagrantfile), the Vagrant user data path will be used for solution storage since only the global plugins will be used.  @param [Hash] opts Options passed to #init! @return [SolutionFile]",
    "label": "",
    "id": "184"
  },
  {
    "raw_code": "def init!(plugins, repair=false, **opts)\n      if !@initial_specifications\n        @initial_specifications = Gem::Specification.find_all{true}\n      else\n        Gem::Specification.all = @initial_specifications\n        Gem::Specification.reset\n      end",
    "comment": "Initializes Bundler and the various gem paths so that we can begin loading gems.",
    "label": "",
    "id": "185"
  },
  {
    "raw_code": "def deinit\n      # no-op\n    end",
    "comment": "Removes any temporary files created by init",
    "label": "",
    "id": "186"
  },
  {
    "raw_code": "def install(plugins, env_local=false)\n      internal_install(plugins, nil, env_local: env_local)\n    end",
    "comment": "Installs the list of plugins.  @param [Hash] plugins @param [Boolean] env_local Environment local plugin install @return [Array<Gem::Specification>]",
    "label": "",
    "id": "187"
  },
  {
    "raw_code": "def install_local(path, opts={})\n      plugin_source = Gem::Source::SpecificFile.new(path)\n      plugin_info = {\n        plugin_source.spec.name => {\n          \"gem_version\" => plugin_source.spec.version.to_s,\n          \"local_source\" => plugin_source,\n          \"sources\" => opts.fetch(:sources, [])\n        }\n      }\n      @logger.debug(\"Installing local plugin - #{plugin_info}\")\n      internal_install(plugin_info, nil, env_local: opts[:env_local])\n      plugin_source.spec\n    end",
    "comment": "Installs a local '*.gem' file so that Bundler can find it.  @param [String] path Path to a local gem file. @return [Gem::Specification]",
    "label": "",
    "id": "188"
  },
  {
    "raw_code": "def update(plugins, specific, **opts)\n      specific ||= []\n      update = opts.merge({gems: specific.empty? ? true : specific})\n      internal_install(plugins, update)\n    end",
    "comment": "Update updates the given plugins, or every plugin if none is given.  @param [Hash] plugins @param [Array<String>] specific Specific plugin names to update. If empty or nil, all plugins will be updated.",
    "label": "",
    "id": "189"
  },
  {
    "raw_code": "def clean(plugins, **opts)\n      @logger.debug(\"Cleaning Vagrant plugins of stale gems.\")\n      # Generate dependencies for all registered plugins\n      plugin_deps = plugins.map do |name, info|\n        gem_version = info['installed_gem_version']\n        gem_version = info['gem_version'] if gem_version.to_s.empty?\n        gem_version = \"> 0\" if gem_version.to_s.empty?\n        Gem::Dependency.new(name, gem_version)\n      end",
    "comment": "Clean removes any unused gems.",
    "label": "",
    "id": "190"
  },
  {
    "raw_code": "def verbose\n      if block_given?\n        initial_state = @verbose\n        @verbose = true\n        yield\n        @verbose = initial_state\n      else\n        @verbose = true\n      end",
    "comment": "During the duration of the yielded block, Bundler loud output is enabled.",
    "label": "",
    "id": "191"
  },
  {
    "raw_code": "def generate_vagrant_set\n      sets = [generate_builtin_set, generate_plugin_set]\n      if env_plugin_gem_path && env_plugin_gem_path.exist?\n        sets << generate_plugin_set(env_plugin_gem_path)\n      end",
    "comment": "Generate the composite resolver set totally all of vagrant (builtin + plugin set)",
    "label": "",
    "id": "192"
  },
  {
    "raw_code": "def vagrant_internal_specs\n      # activate any dependencies up front so we can always\n      # pin them when resolving\n      self_spec = Gem::Specification.find { |s| s.name == \"vagrant\" && s.activated? }\n      if !self_spec\n        @logger.warn(\"Failed to locate activated vagrant specification. Activating...\")\n        self_spec = Gem::Specification.find { |s| s.name == \"vagrant\" }\n        if !self_spec\n          @logger.error(\"Failed to locate Vagrant RubyGem specification\")\n          raise Vagrant::Errors::SourceSpecNotFound\n        end",
    "comment": "@return [Array<[Gem::Specification]>] spec list",
    "label": "",
    "id": "193"
  },
  {
    "raw_code": "def validate_configured_sources!\n      Gem.sources.each_source do |src|\n        begin\n          src.load_specs(:released)\n        rescue Gem::Exception => source_error\n          if ENV[\"VAGRANT_ALLOW_PLUGIN_SOURCE_ERRORS\"]\n            @logger.warn(\"Failed to load configured plugin source: #{src}!\")\n            @logger.warn(\"Error received attempting to load source (#{src}): #{source_error}\")\n            @logger.warn(\"Ignoring plugin source load failure due user request via env variable\")\n          else\n            @logger.error(\"Failed to load configured plugin source `#{src}`: #{source_error}\")\n            raise Vagrant::Errors::PluginSourceError,\n              source: src.uri.to_s,\n              error_msg: source_error.message\n          end",
    "comment": "Iterates each configured RubyGem source to validate that it is properly available. If source is unavailable an exception is raised.",
    "label": "",
    "id": "194"
  },
  {
    "raw_code": "def generate_builtin_set(system_plugins=[])\n      builtin_set = BuiltinSet.new\n      @logger.debug(\"Generating new builtin set instance.\")\n      vagrant_internal_specs.each do |spec|\n        if !system_plugins.include?(spec.name)\n          builtin_set.add_builtin_spec(spec)\n        end",
    "comment": "Generate the builtin resolver set",
    "label": "",
    "id": "195"
  },
  {
    "raw_code": "def generate_plugin_set(*args)\n      plugin_path = args.detect{|i| i.is_a?(Pathname) } || plugin_gem_path\n      skip = args.detect{|i| i.is_a?(Array) } || []\n      plugin_set = PluginSet.new\n      @logger.debug(\"Generating new plugin set instance. Skip gems - #{skip}\")\n      Dir.glob(plugin_path.join('specifications/*.gemspec').to_s).each do |spec_path|\n        spec = Gem::Specification.load(spec_path)\n        desired_spec_path = File.join(spec.gem_dir, \"#{spec.name}.gemspec\")\n        # Vendor set requires the spec to be within the gem directory. Some gems will package their\n        # spec file, and that's not what we want to load.\n        if !File.exist?(desired_spec_path) || !FileUtils.cmp(spec.spec_file, desired_spec_path)\n          File.write(desired_spec_path, spec.to_ruby)\n        end",
    "comment": "Generate the plugin resolver set. Optionally provide specification names (short or full) that should be ignored  @param [Pathname] path to plugins @param [Array<String>] gems to skip @return [PluginSet]",
    "label": "",
    "id": "196"
  },
  {
    "raw_code": "def activate_solution(solution)\n      retried = false\n      begin\n        @logger.debug(\"Activating solution set: #{solution.map(&:full_name)}\")\n        solution.each do |activation_request|\n          unless activation_request.full_spec.activated?\n            @logger.debug(\"Activating gem #{activation_request.full_spec.full_name}\")\n            activation_request.full_spec.activate\n            if(defined?(::Bundler))\n              @logger.debug(\"Marking gem #{activation_request.full_spec.full_name} loaded within Bundler.\")\n              ::Bundler.rubygems.mark_loaded activation_request.full_spec\n            end",
    "comment": "Activate a given solution",
    "label": "",
    "id": "197"
  },
  {
    "raw_code": "def find_all(req)\n        result = super\n        if system_plugins.include?(req.name)\n          result.delete_if do |spec|\n            spec.is_a?(Gem::Resolver::InstalledSpecification)\n          end",
    "comment": "Allow InstallerSet to find matching specs, then filter for preferred sources",
    "label": "",
    "id": "198"
  },
  {
    "raw_code": "def add_vendor_gem(name, directory)\n        gemspec = File.join(directory, \"#{name}.gemspec\")\n        spec = Gem::Specification.load(gemspec)\n        if !spec\n          raise Gem::GemNotFoundException,\n            \"unable to find #{gemspec} for gem #{name}\"\n        end",
    "comment": " Adds a specification to the set with the given +name+ which has been unpacked into the given +directory+.",
    "label": "",
    "id": "199"
  },
  {
    "raw_code": "def find_all(req)\n        @specs.values.flatten.select do |spec|\n          req.match?(spec, prerelease)\n        end.map do |spec|\n          source = Gem::Source::Vendor.new(@directories[spec])\n          Gem::Resolver::VendorSpecification.new(self, spec, source)\n        end",
    "comment": " Returns an Array of VendorSpecification objects matching the DependencyRequest +req+.",
    "label": "",
    "id": "200"
  },
  {
    "raw_code": "def load_spec(name, version, platform, source)\n        version = Gem::Version.new(version) if !version.is_a?(Gem::Version)\n        @specs.fetch(name, []).detect{|s| s.name == name && s.version == version}\n      end",
    "comment": " Loads a spec with the given +name+. +version+, +platform+ and +source+ are ignored.",
    "label": "",
    "id": "201"
  },
  {
    "raw_code": "def initialize(versions, version_order)\n        @logger        = Log4r::Logger.new(\"vagrant::config::loader\")\n        @config_cache  = {}\n        @proc_cache    = {}\n        @sources       = {}\n        @versions      = versions\n        @version_order = version_order\n      end",
    "comment": "Initializes a configuration loader.  @param [Registry] versions A registry of the available versions and their associated loaders. @param [Array] version_order An array of the order of the versions in the registry. This is used to determine if upgrades are necessary. Additionally, the last version in this order is always considered the \"current\" version.",
    "label": "",
    "id": "202"
  },
  {
    "raw_code": "def set(name, sources)\n        # Sources should be an array\n        sources = [sources] if !sources.kind_of?(Array)\n\n        reliably_inspected_sources = sources.reduce({}) { |accum, source|\n          begin\n            accum[source] = source.inspect\n          rescue Encoding::CompatibilityError\n            accum[source] = \"<!Vagrant failed to call #inspect source with object id #{source.object_id} and class #{source.class} due to a string encoding error>\"\n          end",
    "comment": "Set the configuration data for the given name.  The `name` should be a symbol and must uniquely identify the data being given.  `data` can either be a path to a Ruby Vagrantfile or a `Proc` directly. `data` can also be an array of such values.  At this point, no configuration is actually loaded. Note that calling `set` multiple times with the same name will override any previously set values. In this way, the last set data for a given name wins.",
    "label": "",
    "id": "203"
  },
  {
    "raw_code": "def load(order)\n        @logger.info(\"Loading configuration in order: #{order.inspect}\")\n\n        unknown_sources = @sources.keys - order\n        if !unknown_sources.empty?\n          @logger.warn(\"Unknown config sources: #{unknown_sources.inspect}\")\n        end",
    "comment": "This loads the configuration sources in the given order and returns an actual configuration object that is ready to be used.  @param [Array<Symbol>] order The order of configuration to load. @return [Object] The configuration object. This is different for each configuration version.",
    "label": "",
    "id": "204"
  },
  {
    "raw_code": "def partial_load(key)\n        raise KeyError,\n              \"Unknown path key provided (#{key})\" if !@sources.key?(key)\n\n        version, proc = @sources[key].first\n        @logger.debug(\"Loading from: #{key} (evaluating)\")\n\n        # Get the proper version loader for this version and load\n        version_loader = @versions.get(version)\n        raise KeyError,\n              \"Failed to create loader for requested version: #{version}\" if version_loader.nil?\n\n        begin\n          version_config = version_loader.load(proc)\n        rescue NameError => e\n          line = \"(unknown)\"\n          path = \"(unknown)\"\n          if e.backtrace && e.backtrace[0]\n            backtrace_tokens = e.backtrace[0].split(\":\")\n            path = e.backtrace.first.slice(0, e.backtrace.first.rindex(':')).rpartition(':').first\n            backtrace_tokens.each do |part|\n              if part =~ /\\d+/\n                line = part.to_i\n                break\n              end",
    "comment": "This method is used for doing partial loads of the Vagrantfile. It will load the contents of a single location and return the config. No merging is performed and no finalization is applied.  @param key [Symbol] name of location @return [Object] configuration @note: This will load either version, but we assume a v2 result @todo(spox): check version and raise error on v1",
    "label": "",
    "id": "205"
  },
  {
    "raw_code": "def procs_for_source(source, reliably_inspected_sources)\n        # Convert all pathnames to strings so we just have their path\n        source = source.to_s if source.is_a?(Pathname)\n\n        if source.is_a?(Array)\n          # An array must be formatted as [version, proc], so verify\n          # that and then return it\n          raise ArgumentError, \"String source must have format [version, proc]\" if source.length != 2\n\n          # Return it as an array since we're expected to return an array\n          # of [version, proc] pairs, but an array source only has one.\n          return [source]\n        elsif source.is_a?(String)\n          # Strings are considered paths, so load them\n          return procs_for_path(source)\n        else\n          raise ArgumentError, \"Unknown configuration source: #{reliably_inspected_sources[source]}\"\n        end",
    "comment": "This returns an array of `Proc` objects for the given source. The `Proc` objects returned will expect a single argument for the configuration object and are expected to mutate this configuration object.",
    "label": "",
    "id": "206"
  },
  {
    "raw_code": "def procs_for_path(path)\n        @logger.debug(\"Load procs for pathname: #{path}\")\n\n        return Config.capture_configures do\n          begin\n            Kernel.load path\n          rescue SyntaxError => e\n            # Report syntax errors in a nice way.\n            raise Errors::VagrantfileSyntaxError, file: e.message\n          rescue SystemExit\n            # Continue raising that exception...\n            raise\n          rescue Vagrant::Errors::VagrantError\n            # Continue raising known Vagrant errors since they already\n            # contain well worded error messages and context.\n            raise\n          rescue Exception => e\n            @logger.error(\"Vagrantfile load error: #{e.message}\")\n            @logger.error(e.backtrace.join(\"\\n\"))\n\n            line = \"(unknown)\"\n            if e.backtrace && e.backtrace[0]\n              e.backtrace[0].split(\":\").each do |part|\n                if part =~ /\\d+/\n                  line = part.to_i\n                  break\n                end",
    "comment": "This returns an array of `Proc` objects for the given path source.  @param [String] path Path to the file which contains the proper `Vagrant.configure` calls. @return [Array<Proc>]",
    "label": "",
    "id": "207"
  },
  {
    "raw_code": "def self.init\n        raise NotImplementedError\n      end",
    "comment": "Returns an empty configuration object. This can be any kind of object, since it is treated as an opaque value on the other side, used only for things like calling into {merge}.  @return [Object]",
    "label": "",
    "id": "208"
  },
  {
    "raw_code": "def self.finalize(obj)\n        obj\n      end",
    "comment": "This is called just before configuration loading is complete of a potentially completely-merged value to perform final touch-ups to the configuration, if required.  This is an optional method to implement. The default implementation will simply return the same object.  This will ONLY be called if this is the version that is being used. In the case that an `upgrade` is called, this will never be called.  @param [Object] obj Final configuration object. @param [Object] Finalized configuration object.",
    "label": "",
    "id": "209"
  },
  {
    "raw_code": "def self.load(proc)\n        raise NotImplementedError\n      end",
    "comment": "Loads the configuration for the given proc and returns a configuration object. The return value is treated as an opaque object, so it can be anything you'd like. The return value is the object that is passed into methods like {merge}, so it should be something you expect.  @param [Proc] proc The proc that is to be configured. @return [Object]",
    "label": "",
    "id": "210"
  },
  {
    "raw_code": "def self.merge(old, new)\n        raise NotImplementedError\n      end",
    "comment": "Merges two configuration objects, returning the merged object. The values of `old` and `new` are the opaque objects returned by {load} or {init}.  Once again, the return object is treated as an opaque value by the Vagrant configuration loader, so it can be anything you'd like.  @param [Object] old Old configuration object. @param [Object] new New configuration object. @return [Object] The merged configuration object.",
    "label": "",
    "id": "211"
  },
  {
    "raw_code": "def self.upgrade(old)\n        raise NotImplementedError\n      end",
    "comment": "This is called if a previous version of configuration needs to be upgraded to this version. Each version of configuration should know how to upgrade the version immediately prior to it. This should be a best effort upgrade that makes many assumptions. The goal is for this to work in almost every case, but perhaps with some warnings. The return value for this is a 3-tuple: `[object, warnings, errors]`, where `object` is the upgraded configuration object, `warnings` is an array of warning messages, and `errors` is an array of error messages.  @param [Object] old The version of the configuration object just prior to this one. @return [Array] The 3-tuple result. Please see the above documentation for more information on the exact structure of this object.",
    "label": "",
    "id": "212"
  },
  {
    "raw_code": "def self.init\n          new_root_object\n        end",
    "comment": "Returns a bare empty configuration object.  @return [V1::Root]",
    "label": "",
    "id": "213"
  },
  {
    "raw_code": "def self.finalize(config)\n          # Call the `#finalize` method on each of the configuration keys.\n          # They're expected to modify themselves in our case.\n          config.finalize!\n\n          # Return the object\n          config\n        end",
    "comment": "Finalizes the configuration by making sure there is at least one VM defined in it.",
    "label": "",
    "id": "214"
  },
  {
    "raw_code": "def self.load(config_proc)\n          # Create a root configuration object\n          root = new_root_object\n\n          # Call the proc with the root\n          config_proc.call(root)\n\n          # Return the root object, which doubles as the configuration object\n          # we actually use for accessing as well.\n          root\n        end",
    "comment": "Loads the configuration for the given proc and returns a configuration object.  @param [Proc] config_proc @return [Object]",
    "label": "",
    "id": "215"
  },
  {
    "raw_code": "def self.merge(old, new)\n          # Grab the internal states, we use these heavily throughout the process\n          old_state = old.__internal_state\n          new_state = new.__internal_state\n\n          # The config map for the new object is the old one merged with the\n          # new one.\n          config_map = old_state[\"config_map\"].merge(new_state[\"config_map\"])\n\n          # Merge the keys.\n          old_keys = old_state[\"keys\"]\n          new_keys = new_state[\"keys\"]\n          keys     = {}\n          old_keys.each do |key, old_value|\n            if new_keys.key?(key)\n              # We need to do a merge, which we expect to be available\n              # on the config class itself.\n              keys[key] = old_value.merge(new_keys[key])\n            else\n              # We just take the old value, but dup it so that we can modify.\n              keys[key] = old_value.dup\n            end",
    "comment": "Merges two configuration objects.  @param [V1::Root] old The older root config. @param [V1::Root] new The newer root config. @return [V1::Root]",
    "label": "",
    "id": "216"
  },
  {
    "raw_code": "def initialize(config_map, keys=nil)\n          @keys              = keys || {}\n          @config_map        = config_map\n          @missing_key_calls = Set.new\n        end",
    "comment": "Initializes a root object that maps the given keys to specific configuration classes.  @param [Hash] config_map Map of key to config class.",
    "label": "",
    "id": "217"
  },
  {
    "raw_code": "def method_missing(name, *args)\n          return @keys[name] if @keys.key?(name)\n\n          config_klass = @config_map[name.to_sym]\n          if config_klass\n            # Instantiate the class and return the instance\n            @keys[name] = config_klass.new\n            return @keys[name]\n          else\n            # Record access to a missing key as an error\n            @missing_key_calls.add(name.to_s)\n            return DummyConfig.new\n          end",
    "comment": "We use method_missing as a way to get the configuration that is used for Vagrant and load the proper configuration classes for each.",
    "label": "",
    "id": "218"
  },
  {
    "raw_code": "def finalize!\n          @keys.each do |_key, instance|\n            instance.finalize!\n          end",
    "comment": "Called to finalize this object just prior to it being used by the Vagrant system. The \"!\" signifies that this is expected to mutate itself.",
    "label": "",
    "id": "219"
  },
  {
    "raw_code": "def __internal_state\n          {\n            \"config_map\"        => @config_map,\n            \"keys\"              => @keys,\n            \"missing_key_calls\" => @missing_key_calls\n          }\n        end",
    "comment": "Returns the internal state of the root object. This is used by outside classes when merging, and shouldn't be called directly. Note the strange method name is to attempt to avoid any name clashes with potential configuration keys.",
    "label": "",
    "id": "220"
  },
  {
    "raw_code": "def self.init\n          new_root_object\n        end",
    "comment": "Returns a bare empty configuration object.  @return [V2::Root]",
    "label": "",
    "id": "221"
  },
  {
    "raw_code": "def self.finalize(config)\n          # Call the `#finalize` method on each of the configuration keys.\n          # They're expected to modify themselves in our case.\n          config.finalize!\n\n          # Return the object\n          config\n        end",
    "comment": "Finalizes the configuration by making sure there is at least one VM defined in it.",
    "label": "",
    "id": "222"
  },
  {
    "raw_code": "def self.load(config_proc)\n          # Create a root configuration object\n          root = new_root_object\n\n          # Call the proc with the root\n          config_proc.call(root)\n\n          # Return the root object, which doubles as the configuration object\n          # we actually use for accessing as well.\n          root\n        end",
    "comment": "Loads the configuration for the given proc and returns a configuration object.  @param [Proc] config_proc @return [Object]",
    "label": "",
    "id": "223"
  },
  {
    "raw_code": "def self.merge(old, new)\n          # Grab the internal states, we use these heavily throughout the process\n          old_state = old.__internal_state\n          new_state = new.__internal_state\n\n          # Make sure we instantiate every key in the config so that we\n          # merge every key. This avoids issues with the same reference\n          # being part of the config.\n          old_state[\"config_map\"].each do |k, _|\n            old.public_send(k)\n          end",
    "comment": "Merges two configuration objects.  @param [V2::Root] old The older root config. @param [V2::Root] new The newer root config. @return [V2::Root]",
    "label": "",
    "id": "224"
  },
  {
    "raw_code": "def self.upgrade(old)\n          # Get a new root\n          root = new_root_object\n\n          # Store the warnings/errors\n          warnings = []\n          errors   = []\n\n          # Go through the old keys and upgrade them if they can be\n          old.__internal_state[\"keys\"].each do |_, old_value|\n            if old_value.respond_to?(:upgrade)\n              result = old_value.upgrade(root)\n\n              # Sanity check to guard against random return values\n              if result.is_a?(Array)\n                warnings += result[0]\n                errors   += result[1]\n              end",
    "comment": "Upgrade a V1 configuration to a V2 configuration. We do this by creating a V2 configuration, and calling \"upgrade\" on each of the V1 configurations, expecting them to set the right settings on the new root.  @param [V1::Root] old @return [Array] A 3-tuple result.",
    "label": "",
    "id": "225"
  },
  {
    "raw_code": "def initialize(config_map, keys=nil)\n          @keys              = keys || {}\n          @config_map        = config_map\n          @missing_key_calls = Set.new\n          @logger            = Log4r::Logger.new(\"vagrant::config\")\n        end",
    "comment": "Initializes a root object that maps the given keys to specific configuration classes.  @param [Hash] config_map Map of key to config class.",
    "label": "",
    "id": "226"
  },
  {
    "raw_code": "def method_missing(name, *args)\n          return @keys[name] if @keys.key?(name)\n\n          config_klass = @config_map[name.to_sym]\n          if config_klass\n            # Instantiate the class and return the instance\n            @keys[name] = config_klass.new\n          else\n            @logger.debug(\"missing key request name=#{name} loc=#{caller.first}\")\n            # Record access to a missing key as an error\n            @missing_key_calls.add(name.to_s)\n            @keys[name] = DummyConfig.new\n          end",
    "comment": "We use method_missing as a way to get the configuration that is used for Vagrant and load the proper configuration classes for each.",
    "label": "",
    "id": "227"
  },
  {
    "raw_code": "def finalize!\n          @config_map.each do |key, klass|\n            if !@keys.key?(key)\n              @keys[key] = klass.new\n            end",
    "comment": "Called to finalize this object just prior to it being used by the Vagrant system. The \"!\" signifies that this is expected to mutate itself.",
    "label": "",
    "id": "228"
  },
  {
    "raw_code": "def validate(machine, ignore_provider=nil)\n          # Go through each of the configuration keys and validate\n          errors = {}\n          @keys.each do |_key, instance|\n            if instance.respond_to?(:validate)\n              # Validate this single item, and if we have errors then\n              # we merge them into our total errors list.\n              if _key == :vm\n                result = instance.validate(machine, ignore_provider)\n              else\n                result = instance.validate(machine)\n              end",
    "comment": "This validates the configuration and returns a hash of error messages by section. If there are no errors, an empty hash is returned.  @param [Environment] env @return [Hash]",
    "label": "",
    "id": "229"
  },
  {
    "raw_code": "def __internal_state\n          {\n            \"config_map\"        => @config_map,\n            \"keys\"              => @keys,\n            \"missing_key_calls\" => @missing_key_calls\n          }\n        end",
    "comment": "Returns the internal state of the root object. This is used by outside classes when merging, and shouldn't be called directly. Note the strange method name is to attempt to avoid any name clashes with potential configuration keys.",
    "label": "",
    "id": "230"
  },
  {
    "raw_code": "def __set_internal_state(state)\n          @config_map        = state[\"config_map\"] if state.key?(\"config_map\")\n          @keys              = state[\"keys\"] if state.key?(\"keys\")\n          @missing_key_calls = state[\"missing_key_calls\"] if state.key?(\"missing_key_calls\")\n        end",
    "comment": "This sets the internal state. This is used by the core to do some merging logic and shouldn't be used by the general public.",
    "label": "",
    "id": "231"
  },
  {
    "raw_code": "def self.merge_errors(first, second)\n          first.dup.tap do |result|\n            second.each do |key, value|\n              result[key] ||= []\n              result[key] += value\n            end",
    "comment": "This merges two error hashes from validate methods.  @param [Hash] first @param [Hash] second @return [Hash] Merged result",
    "label": "",
    "id": "232"
  },
  {
    "raw_code": "def self.factory(name, *args)\n      l = Log4r::Logger::Repository[name]\n      return l unless l.nil?\n      Log4r::Logger.new(name, *args)\n    end",
    "comment": "The factory allows using a previously created logger instance if it exists. Doing this prevents knocking out configuration that may have already been applied to the logger instance (like log level)",
    "label": "",
    "id": "233"
  },
  {
    "raw_code": "def flag_cleaner(flags)\n  parts = flags.split(\" -\")\n  parts.map! do |p|\n    if p !~ %r{[A-Za-z]:(/|\\\\)}\n      next p\n    elsif p =~ %r{\"[A-Za-z]:(/|\\\\).+\"$}\n      next p\n    end",
    "comment": "Attempt to detect and quote Windos paths found within the given string of flags  @param [String] flags Compiler/linker flags @return [String] flags with paths quoted",
    "label": "",
    "id": "234"
  },
  {
    "raw_code": "def clean_flags!\n  $CFLAGS = flag_cleaner($CFLAGS)\n  $CPPFLAGS = flag_cleaner($CPPFLAGS)\n  $LDFLAGS = flag_cleaner($LDFLAGS)\n  $INCFLAGS = flag_cleaner($INCFLAGS)\nend",
    "comment": "Check values defined for CFLAGS, CPPFLAGS, LDFLAGS, and INCFLAGS for unquoted Windows paths and quote them.",
    "label": "",
    "id": "235"
  },
  {
    "raw_code": "def vagrant_create_makefile(*args)\n  clean_flags!\n\n  ruby_create_makefile(*args)\nend",
    "comment": "Since mkmf loads the MakeMakefile module directly into the current scope, apply patches directly in the scope",
    "label": "",
    "id": "236"
  },
  {
    "raw_code": "def self.user_plugins_file\n        Vagrant.user_data_path.join(\"plugins.json\")\n      end",
    "comment": "Returns the path to the [StateFile] for user plugins.  @return [Pathname]",
    "label": "",
    "id": "237"
  },
  {
    "raw_code": "def self.system_plugins_file\n        dir = Vagrant.installer_embedded_dir\n        return nil if !dir\n        Pathname.new(dir).join(\"plugins.json\")\n      end",
    "comment": "Returns the path to the [StateFile] for system plugins.",
    "label": "",
    "id": "238"
  },
  {
    "raw_code": "def initialize(user_file)\n        @logger = Log4r::Logger.new(\"vagrant::plugin::manager\")\n        @user_file   = StateFile.new(user_file)\n\n        system_path  = self.class.system_plugins_file\n        @system_file = nil\n        @system_file = StateFile.new(system_path) if system_path && system_path.file?\n\n        @local_file = nil\n        @globalized = @localized = false\n      end",
    "comment": "@param [Pathname] user_file",
    "label": "",
    "id": "239"
  },
  {
    "raw_code": "def globalize!\n        @globalized = true\n        @logger.debug(\"Enabling globalized plugins\")\n        plugins = installed_plugins\n        bundler_init(plugins, global: user_file.path)\n        plugins\n      end",
    "comment": "Enable global plugins  @return [Hash] list of plugins",
    "label": "",
    "id": "240"
  },
  {
    "raw_code": "def localize!(env)\n        @localized = true\n        if env.local_data_path\n          @logger.debug(\"Enabling localized plugins\")\n          @local_file = StateFile.new(env.local_data_path.join(\"plugins.json\"))\n          Vagrant::Bundler.instance.environment_path = env.local_data_path\n          plugins = local_file.installed_plugins\n          bundler_init(plugins, local: local_file.path)\n          plugins\n        end",
    "comment": "Enable environment local plugins  @param [Environment] env Vagrant environment @return [Hash, nil] list of plugins",
    "label": "",
    "id": "241"
  },
  {
    "raw_code": "def ready?\n        @globalized && @localized\n      end",
    "comment": "@return [Boolean] local and global plugins are loaded",
    "label": "",
    "id": "242"
  },
  {
    "raw_code": "def bundler_init(plugins, **opts)\n        if !Vagrant.plugins_init?\n          @logger.warn(\"Plugin initialization is disabled\")\n          return nil\n        end",
    "comment": "Initialize bundler with given plugins  @param [Hash] plugins List of plugins @return [nil]",
    "label": "",
    "id": "243"
  },
  {
    "raw_code": "def install_plugin(name, **opts)\n        if opts[:env_local] && @local_file.nil?\n          raise Errors::PluginNoLocalError\n        end",
    "comment": "Installs another plugin into our gem directory.  @param [String] name Name of the plugin (gem) @return [Gem::Specification]",
    "label": "",
    "id": "244"
  },
  {
    "raw_code": "def uninstall_plugin(name, **opts)\n        if @system_file\n          if !@user_file.has_plugin?(name) && @system_file.has_plugin?(name)\n            raise Errors::PluginUninstallSystem,\n              name: name\n          end",
    "comment": "Uninstalls the plugin with the given name.  @param [String] name",
    "label": "",
    "id": "245"
  },
  {
    "raw_code": "def update_plugins(specific, **opts)\n        if opts[:env_local] && @local_file.nil?\n          raise Errors::PluginNoLocalError\n        end",
    "comment": "Updates all or a specific set of plugins.",
    "label": "",
    "id": "246"
  },
  {
    "raw_code": "def installed_plugins\n        system = {}\n        if @system_file\n          @system_file.installed_plugins.each do |k, v|\n            system[k] = v.merge(\"system\" => true)\n          end",
    "comment": "This returns the list of plugins that should be enabled.  @return [Hash]",
    "label": "",
    "id": "247"
  },
  {
    "raw_code": "def installed_specs\n        installed_plugin_info = installed_plugins\n        installed = Set.new(installed_plugin_info.keys)\n        installed_versions = Hash[\n          installed_plugin_info.map{|plugin_name, plugin_info|\n            gem_version = plugin_info[\"gem_version\"].to_s\n            gem_version = \"> 0\" if gem_version.empty?\n            [plugin_name, Gem::Requirement.new(gem_version)]\n          }\n        ]\n\n        # Go through the plugins installed in this environment and\n        # get the latest version of each.\n        installed_map = {}\n        Gem::Specification.find_all.each do |spec|\n          # Ignore specs that aren't in our installed list\n          next if !installed.include?(spec.name)\n\n          next if installed_versions[spec.name] &&\n            !installed_versions[spec.name].satisfied_by?(spec.version)\n\n          # If we already have a newer version in our list of installed,\n          # then ignore it\n          next if installed_map.key?(spec.name) &&\n            installed_map[spec.name].version >= spec.version\n\n          installed_map[spec.name] = spec\n        end",
    "comment": "This returns the list of plugins that are installed as Gem::Specifications.  @return [Array<Gem::Specification>]",
    "label": "",
    "id": "248"
  },
  {
    "raw_code": "def load_plugins(plugins)\n        if !Vagrant.plugins_enabled?\n          @logger.warn(\"Plugin loading is disabled\")\n          return\n        end",
    "comment": "Loads the requested plugins into the Vagrant runtime  @param [Hash] plugins List of plugins to load @return [nil]",
    "label": "",
    "id": "249"
  },
  {
    "raw_code": "def plugin_installed?(name, version=nil)\n        # Make the requirement object\n        version = Gem::Requirement.new([version.to_s]) if version\n\n        # If plugins are loaded, check for match in loaded specs\n        if ready?\n          return installed_specs.any? do |s|\n            match = s.name == name\n            next match if !version\n            next match && version.satisfied_by?(s.version)\n          end",
    "comment": "Check if the requested plugin is installed  @param [String] name Name of plugin @param [String] version Specific version of the plugin @return [Boolean]",
    "label": "",
    "id": "250"
  },
  {
    "raw_code": "def add_plugin(name, **opts)\n        @data[\"installed\"][name] = {\n          \"ruby_version\"          => RUBY_VERSION,\n          \"vagrant_version\"       => Vagrant::VERSION,\n          \"gem_version\"           => opts[:version] || \"\",\n          \"require\"               => opts[:require] || \"\",\n          \"sources\"               => opts[:sources] || [],\n          \"installed_gem_version\" => opts[:installed_gem_version],\n          \"env_local\"             => !!opts[:env_local]\n        }\n\n        save!\n      end",
    "comment": "Add a plugin that is installed to the state file.  @param [String] name The name of the plugin",
    "label": "",
    "id": "251"
  },
  {
    "raw_code": "def add_source(url)\n        @data[\"sources\"] ||= []\n        @data[\"sources\"] << url if !@data[\"sources\"].include?(url)\n        save!\n      end",
    "comment": "Adds a RubyGems index source to look up gems.  @param [String] url URL of the source.",
    "label": "",
    "id": "252"
  },
  {
    "raw_code": "def installed_plugins\n        @data[\"installed\"]\n      end",
    "comment": "This returns a hash of installed plugins according to the state file. Note that this may _not_ directly match over to actually installed gems.  @return [Hash]",
    "label": "",
    "id": "253"
  },
  {
    "raw_code": "def has_plugin?(name)\n        @data[\"installed\"].key?(name)\n      end",
    "comment": "Returns true/false if the plugin is present in this state file.  @return [Boolean]",
    "label": "",
    "id": "254"
  },
  {
    "raw_code": "def remove_plugin(name)\n        @data[\"installed\"].delete(name)\n        save!\n      end",
    "comment": "Remove a plugin that is installed from the state file.  @param [String] name The name of the plugin.",
    "label": "",
    "id": "255"
  },
  {
    "raw_code": "def remove_source(url)\n        @data[\"sources\"] ||= []\n        @data[\"sources\"].delete(url)\n        save!\n      end",
    "comment": "Remove a source for RubyGems.  @param [String] url URL of the source",
    "label": "",
    "id": "256"
  },
  {
    "raw_code": "def sources\n        @data[\"sources\"] || []\n      end",
    "comment": "Returns the list of RubyGems sources that will be searched for plugins.  @return [Array<String>]",
    "label": "",
    "id": "257"
  },
  {
    "raw_code": "def save!\n        Tempfile.open(@path.basename.to_s, @path.dirname.to_s) do |f|\n          f.binmode\n          f.write(JSON.dump(@data))\n          f.fsync\n          f.chmod(0644)\n          f.close\n          FileUtils.mv(f.path, @path)\n        end",
    "comment": "This saves the state back into the state file.",
    "label": "",
    "id": "258"
  },
  {
    "raw_code": "def upgrade_v0!\n        @data[\"version\"] = \"1\"\n\n        new_installed = {}\n        (@data[\"installed\"] || []).each do |plugin|\n          new_installed[plugin] = {\n            \"ruby_version\"    => \"0\",\n            \"vagrant_version\" => \"0\",\n          }\n        end",
    "comment": "This upgrades the internal data representation from V0 (the initial version) to V1.",
    "label": "",
    "id": "259"
  },
  {
    "raw_code": "def initialize(machine)\n        end",
    "comment": "Initialize the provider to represent the given machine.  @param [Vagrant::Machine] machine The machine that this provider is responsible for.",
    "label": "",
    "id": "260"
  },
  {
    "raw_code": "def action(name)\n          nil\n        end",
    "comment": "This should return an action callable for the given name.  @param [Symbol] name Name of the action. @return [Object] A callable action sequence object, whether it is a proc, object, etc.",
    "label": "",
    "id": "261"
  },
  {
    "raw_code": "def machine_id_changed\n        end",
    "comment": "This method is called if the underlying machine ID changes. Providers can use this method to load in new data for the actual backing machine or to realize that the machine is now gone (the ID can become `nil`). No parameters are given, since the underlying machine is simply the machine instance given to this object. And no return value is necessary.",
    "label": "",
    "id": "262"
  },
  {
    "raw_code": "def ssh_info\n          nil\n        end",
    "comment": "This should return a hash of information that explains how to SSH into the machine. If the machine is not at a point where SSH is even possible, then `nil` should be returned.  The general structure of this returned hash should be the following:  { host: \"1.2.3.4\", port: \"22\", username: \"mitchellh\", private_key_path: \"/path/to/my/key\" }  **Note:** Vagrant only supports private key based authentication, mainly for the reason that there is no easy way to exec into an `ssh` prompt with a password, whereas we can pass a private key via commandline.  @return [Hash] SSH information. For the structure of this hash read the accompanying documentation for this method.",
    "label": "",
    "id": "263"
  },
  {
    "raw_code": "def state\n          nil\n        end",
    "comment": "This should return the state of the machine within this provider. The state can be any symbol.  @return [Symbol]",
    "label": "",
    "id": "264"
  },
  {
    "raw_code": "def self.config_class\n        end",
    "comment": "This method is expected to return a class that is used for configuring the provisioner. This return value is expected to be a subclass of {Config}.  @return [Config]",
    "label": "",
    "id": "265"
  },
  {
    "raw_code": "def prepare\n        end",
    "comment": "This is the method called to \"prepare\" the provisioner. This is called before any actions are run by the action runner (see {Vagrant::Actions::Runner}). This can be used to setup shared folders, forward ports, etc. Whatever is necessary on a \"meta\" level.  No return value is expected.",
    "label": "",
    "id": "266"
  },
  {
    "raw_code": "def provision!\n        end",
    "comment": "This is the method called to provision the system. This method is expected to do whatever necessary to provision the system (create files, SSH, etc.)",
    "label": "",
    "id": "267"
  },
  {
    "raw_code": "def cleanup\n        end",
    "comment": "This is the method called to when the system is being destroyed and allows the provisioners to engage in any cleanup tasks necessary.",
    "label": "",
    "id": "268"
  },
  {
    "raw_code": "def communicators\n          result = {}\n\n          @registered.each do |plugin|\n            result.merge!(plugin.communicator.to_hash)\n          end",
    "comment": "This returns all the registered communicators.  @return [Hash]",
    "label": "",
    "id": "269"
  },
  {
    "raw_code": "def config\n          result = {}\n\n          @registered.each do |plugin|\n            plugin.config.each do |key, klass|\n              result[key] = klass\n            end",
    "comment": "This returns all the registered configuration classes.  @return [Hash]",
    "label": "",
    "id": "270"
  },
  {
    "raw_code": "def config_upgrade_safe\n          result = {}\n\n          @registered.each do |plugin|\n            configs = plugin.data[:config_upgrade_safe]\n            if configs\n              configs.each do |key|\n                result[key] = plugin.config.get(key)\n              end",
    "comment": "This returns all the registered configuration classes that were marked as \"upgrade safe.\"  @return [Hash]",
    "label": "",
    "id": "271"
  },
  {
    "raw_code": "def guests\n          result = {}\n\n          @registered.each do |plugin|\n            result.merge!(plugin.guest.to_hash)\n          end",
    "comment": "This returns all the registered guests.  @return [Hash]",
    "label": "",
    "id": "272"
  },
  {
    "raw_code": "def hosts\n          hosts = {}\n\n          @registered.each do |plugin|\n            hosts.merge!(plugin.host.to_hash)\n          end",
    "comment": "This returns all registered host classes.  @return [Hash]",
    "label": "",
    "id": "273"
  },
  {
    "raw_code": "def providers\n          providers = {}\n\n          @registered.each do |plugin|\n            providers.merge!(plugin.provider.to_hash)\n          end",
    "comment": "This returns all registered providers.  @return [Hash]",
    "label": "",
    "id": "274"
  },
  {
    "raw_code": "def register(plugin)\n          if !@registered.include?(plugin)\n            @logger.info(\"Registered plugin: #{plugin.name}\")\n            @registered << plugin\n          end",
    "comment": "This registers a plugin. This should _NEVER_ be called by the public and should only be called from within Vagrant. Vagrant will automatically register V1 plugins when a name is set on the plugin.",
    "label": "",
    "id": "275"
  },
  {
    "raw_code": "def reset!\n          @registered.clear\n        end",
    "comment": "This clears out all the registered plugins. This is only used by unit tests and should not be called directly.",
    "label": "",
    "id": "276"
  },
  {
    "raw_code": "def unregister(plugin)\n          if @registered.include?(plugin)\n            @logger.info(\"Unregistered: #{plugin.name}\")\n            @registered.delete(plugin)\n          end",
    "comment": "This unregisters a plugin so that its components will no longer be used. Note that this should only be used for testing purposes.",
    "label": "",
    "id": "277"
  },
  {
    "raw_code": "def execute\n        end",
    "comment": "This is what is called on the class to actually execute it. Any subclasses should implement this method and do any option parsing and validation here.",
    "label": "",
    "id": "278"
  },
  {
    "raw_code": "def parse_options(opts=nil)\n          # Creating a shallow copy of the arguments so the OptionParser\n          # doesn't destroy the originals.\n          argv = @argv.dup\n\n          # Default opts to a blank optionparser if none is given\n          opts ||= OptionParser.new\n\n          # Add the help option, which must be on every command.\n          opts.on_tail(\"-h\", \"--help\", \"Print this help\") do\n            safe_puts(opts.help)\n            return nil\n          end",
    "comment": "Parses the options given an OptionParser instance.  This is a convenience method that properly handles duping the originally argv array so that it is not destroyed.  This method will also automatically detect \"-h\" and \"--help\" and print help. And if any invalid options are detected, the help will be printed, as well.  If this method returns `nil`, then you should assume that help was printed and parsing failed.",
    "label": "",
    "id": "279"
  },
  {
    "raw_code": "def with_target_vms(names=nil, options=nil)\n          # Using VMs requires a Vagrant environment to be properly setup\n          raise Errors::NoEnvironmentError if !@env.root_path\n\n          # Setup the options hash\n          options ||= {}\n\n          # Require that names be an array\n          names ||= []\n          names = [names] if !names.is_a?(Array)\n\n          # First determine the proper array of VMs.\n          vms = []\n          if names.length > 0\n            names.each do |name|\n              if pattern = name[/^\\/(.+?)\\/$/, 1]\n                # This is a regular expression name, so we convert to a regular\n                # expression and allow that sort of matching.\n                regex = Regexp.new(pattern)\n\n                @env.vms.each do |name, vm|\n                  vms << vm if name =~ regex\n                end",
    "comment": "Yields a VM for each target VM for the command.  This is a convenience method for easily implementing methods that take a target VM (in the case of multi-VM) or every VM if no specific VM name is specified.  @param [String] name The name of the VM. Nil if every VM. @param [Boolean] single_target If true, then an exception will be raised if more than one target is found.",
    "label": "",
    "id": "280"
  },
  {
    "raw_code": "def split_main_and_subcommand(argv)\n          # Initialize return variables\n          main_args   = nil\n          sub_command = nil\n          sub_args    = []\n\n          # We split the arguments into two: One set containing any\n          # flags before a word, and then the rest. The rest are what\n          # get actually sent on to the subcommand.\n          argv.each_index do |i|\n            if !argv[i].start_with?(\"-\")\n              # We found the beginning of the sub command. Split the\n              # args up.\n              main_args   = argv[0, i]\n              sub_command = argv[i]\n              sub_args    = argv[i + 1, argv.length - i + 1]\n\n              # Break so we don't find the next non flag and shift our\n              # main args.\n              break\n            end",
    "comment": "This method will split the argv given into three parts: the flags to this command, the subcommand, and the flags to the subcommand. For example:  -v status -h -v  The above would yield 3 parts:  [\"-v\"] \"status\" [\"-h\", \"-v\"]  These parts are useful because the first is a list of arguments given to the current command, the second is a subcommand, and the third are the commands given to the subcommand.  @return [Array] The three parts.",
    "label": "",
    "id": "281"
  },
  {
    "raw_code": "def self.match?\n          nil\n        end",
    "comment": "This returns true/false depending on if the current running system matches the host class.  @return [Boolean]",
    "label": "",
    "id": "282"
  },
  {
    "raw_code": "def self.precedence\n          5\n        end",
    "comment": "The precedence of the host when checking for matches. This is to allow certain host such as generic OS's (\"Linux\", \"BSD\", etc.) to be specified last.  The hosts with the higher numbers will be checked first.  If you're implementing a basic host, you can probably ignore this.",
    "label": "",
    "id": "283"
  },
  {
    "raw_code": "def initialize(ui)\n          @ui = ui\n        end",
    "comment": "Initializes a new host class.  The only required parameter is a UI object so that the host objects have some way to communicate with the outside world.  @param [UI] ui UI for the hosts to output to.",
    "label": "",
    "id": "284"
  },
  {
    "raw_code": "def nfs?\n          false\n        end",
    "comment": "Returns true of false denoting whether or not this host supports NFS shared folder setup. This method ideally should verify that NFS is installed.  @return [Boolean]",
    "label": "",
    "id": "285"
  },
  {
    "raw_code": "def nfs_export(id, ip, folders)\n        end",
    "comment": "Exports the given hash of folders via NFS.  @param [String] id A unique ID that is guaranteed to be unique to match these sets of folders. @param [String] ip IP of the guest machine. @param [Hash] folders Shared folders to sync.",
    "label": "",
    "id": "286"
  },
  {
    "raw_code": "def nfs_prune(valid_ids)\n        end",
    "comment": "Prunes any NFS exports made by Vagrant which aren't in the set of valid ids given.  @param [Array<String>] valid_ids Valid IDs that should not be pruned.",
    "label": "",
    "id": "287"
  },
  {
    "raw_code": "def self.manager\n          @manager ||= Manager.new\n        end",
    "comment": "This returns the manager for all V1 plugins.  @return [V1::Manager]",
    "label": "",
    "id": "288"
  },
  {
    "raw_code": "def self.name(name=UNSET_VALUE)\n          # Get or set the value first, so we have a name for logging when\n          # we register.\n          result = get_or_set(:name, name)\n\n          # The plugin should be registered if we're setting a real name on it\n          Plugin.manager.register(self) if name != UNSET_VALUE\n\n          # Return the result\n          result\n        end",
    "comment": "Set the name of the plugin. The moment that this is called, the plugin will be registered and available. Before this is called, a plugin does not exist. The name must be unique among all installed plugins.  @param [String] name Name of the plugin. @return [String] The name of the plugin.",
    "label": "",
    "id": "289"
  },
  {
    "raw_code": "def self.description(value=UNSET_VALUE)\n          get_or_set(:description, value)\n        end",
    "comment": "Sets a human-friendly description of the plugin.  @param [String] value Description of the plugin. @return [String] Description of the plugin.",
    "label": "",
    "id": "290"
  },
  {
    "raw_code": "def self.action_hook(name, &block)\n          # Get the list of hooks for the given hook name\n          data[:action_hooks] ||= {}\n          hooks = data[:action_hooks][name.to_sym] ||= []\n\n          # Return the list if we don't have a block\n          return hooks if !block_given?\n\n          # Otherwise add the block to the list of hooks for this action.\n          hooks << block\n        end",
    "comment": "Registers a callback to be called when a specific action sequence is run. This allows plugin authors to hook into things like VM bootup, VM provisioning, etc.  @param [Symbol] name Name of the action. @return [Array] List of the hooks for the given action.",
    "label": "",
    "id": "291"
  },
  {
    "raw_code": "def self.command(name=UNSET_VALUE, &block)\n          data[:command] ||= Registry.new\n\n          if name != UNSET_VALUE\n            # Validate the name of the command\n            if name.to_s !~ /^[-a-z0-9]+$/i\n              raise InvalidCommandName, \"Commands can only contain letters, numbers, and hyphens\"\n            end",
    "comment": "Defines additional command line commands available by key. The key becomes the subcommand, so if you register a command \"foo\" then \"vagrant foo\" becomes available.  @param [String] name Subcommand key.",
    "label": "",
    "id": "292"
  },
  {
    "raw_code": "def self.communicator(name=UNSET_VALUE, &block)\n          data[:communicator] ||= Registry.new\n\n          # Register a new communicator class only if a name was given.\n          data[:communicator].register(name.to_sym, &block) if name != UNSET_VALUE\n\n          # Return the registry\n          data[:communicator]\n        end",
    "comment": "Defines additional communicators to be available. Communicators should be returned by a block passed to this method. This is done to ensure that the class is lazy loaded, so if your class inherits from or uses any Vagrant internals specific to Vagrant 1.0, then the plugin can still be defined without breaking anything in future versions of Vagrant.  @param [String] name Communicator name.",
    "label": "",
    "id": "293"
  },
  {
    "raw_code": "def self.config(name=UNSET_VALUE, upgrade_safe=false, &block)\n          data[:config] ||= Registry.new\n\n          # Register a new config class only if a name was given.\n          if name != UNSET_VALUE\n            data[:config].register(name.to_sym, &block)\n\n            # If we were told this is an upgrade safe configuration class\n            # then we add it to the set.\n            if upgrade_safe\n              data[:config_upgrade_safe] ||= Set.new\n              data[:config_upgrade_safe].add(name.to_sym)\n            end",
    "comment": "Defines additional configuration keys to be available in the Vagrantfile. The configuration class should be returned by a block passed to this method. This is done to ensure that the class is lazy loaded, so if your class inherits from any classes that are specific to Vagrant 1.0, then the plugin can still be defined without breaking anything in future versions of Vagrant.  @param [String] name Configuration key. @param [Boolean] upgrade_safe If this is true, then this configuration key is safe to load during an upgrade, meaning that it depends on NO Vagrant internal classes. Do _not_ set this to true unless you really know what you're doing, since you can cause Vagrant to crash (although Vagrant will output a user-friendly error message if this were to happen).",
    "label": "",
    "id": "294"
  },
  {
    "raw_code": "def self.guest(name=UNSET_VALUE, &block)\n          data[:guests] ||= Registry.new\n\n          # Register a new guest class only if a name was given\n          data[:guests].register(name.to_sym, &block) if name != UNSET_VALUE\n\n          # Return the registry\n          data[:guests]\n        end",
    "comment": "Defines an additionally available guest implementation with the given key.  @param [String] name Name of the guest.",
    "label": "",
    "id": "295"
  },
  {
    "raw_code": "def self.host(name=UNSET_VALUE, &block)\n          data[:hosts] ||= Registry.new\n\n          # Register a new host class only if a name was given\n          data[:hosts].register(name.to_sym, &block) if name != UNSET_VALUE\n\n          # Return the registry\n          data[:hosts]\n        end",
    "comment": "Defines an additionally available host implementation with the given key.  @param [String] name Name of the host.",
    "label": "",
    "id": "296"
  },
  {
    "raw_code": "def self.provider(name=UNSET_VALUE, &block)\n          data[:providers] ||= Registry.new\n\n          # Register a new provider class only if a name was given\n          data[:providers].register(name.to_sym, &block) if name != UNSET_VALUE\n\n          # Return the registry\n          data[:providers]\n        end",
    "comment": "Registers additional providers to be available.  @param [Symbol] name Name of the provider.",
    "label": "",
    "id": "297"
  },
  {
    "raw_code": "def self.provisioner(name=UNSET_VALUE, &block)\n          data[:provisioners] ||= Registry.new\n\n          # Register a new provisioner class only if a name was given\n          data[:provisioners].register(name.to_sym, &block) if name != UNSET_VALUE\n\n          # Return the registry\n          data[:provisioners]\n        end",
    "comment": "Registers additional provisioners to be available.  @param [String] name Name of the provisioner.",
    "label": "",
    "id": "298"
  },
  {
    "raw_code": "def self.data\n          @data ||= {}\n        end",
    "comment": "Returns the internal data associated with this plugin. This should NOT be called by the general public.  @return [Hash]",
    "label": "",
    "id": "299"
  },
  {
    "raw_code": "def self.get_or_set(key, value=UNSET_VALUE)\n          # If no value is to be set, then return the value we have already set\n          return data[key] if value.eql?(UNSET_VALUE)\n\n          # Otherwise set the value\n          data[key] = value\n        end",
    "comment": "Helper method that will set a value if a value is given, or otherwise return the already set value.  @param [Symbol] key Key for the data @param [Object] value Value to store. @return [Object] Stored value.",
    "label": "",
    "id": "300"
  },
  {
    "raw_code": "def initialize(vm)\n          @vm = vm\n        end",
    "comment": "Initializes the system. Any subclasses MUST make sure this method is called on the parent. Therefore, if a subclass overrides `initialize`, then you must call `super`.",
    "label": "",
    "id": "301"
  },
  {
    "raw_code": "def distro_dispatch\n        end",
    "comment": "This method is automatically called when the system is available (when Vagrant can successfully SSH into the machine) to give the system a chance to determine the distro and return a distro-specific system.  If this method returns nil, then this instance is assumed to be the most specific guest implementation.",
    "label": "",
    "id": "302"
  },
  {
    "raw_code": "def halt\n          raise BaseError, _key: :unsupported_halt\n        end",
    "comment": "Halt the machine. This method should gracefully shut down the operating system. This method will cause `vagrant halt` and associated commands to _block_, meaning that if the machine doesn't halt in a reasonable amount of time, this method should just return.  If when this method returns, the machine's state isn't \"powered_off,\" Vagrant will proceed to forcefully shut the machine down.",
    "label": "",
    "id": "303"
  },
  {
    "raw_code": "def mount_shared_folder(name, guestpath, options)\n          raise BaseError, _key: :unsupported_shared_folder\n        end",
    "comment": "Mounts a shared folder.  This method should create, mount, and properly set permissions on the shared folder. This method should also properly adhere to any configuration values such as `shared_folder_uid` on `config.vm`.  @param [String] name The name of the shared folder. @param [String] guestpath The path on the machine which the user wants the folder mounted. @param [Hash] options Additional options for the shared folder which can be honored.",
    "label": "",
    "id": "304"
  },
  {
    "raw_code": "def mount_nfs(ip, folders)\n          raise BaseError, _key: :unsupported_nfs\n        end",
    "comment": "Mounts a shared folder via NFS. This assumes that the exports via the host are already done.",
    "label": "",
    "id": "305"
  },
  {
    "raw_code": "def configure_networks(networks)\n          raise BaseError, _key: :unsupported_configure_networks\n        end",
    "comment": "Configures the given list of networks on the virtual machine.  The networks parameter will be an array of hashes where the hashes represent the configuration of a network interface. The structure of the hash will be roughly the following:  { type:      :static, ip:        \"192.168.33.10\", netmask:   \"255.255.255.0\", interface: 1 } ",
    "label": "",
    "id": "306"
  },
  {
    "raw_code": "def change_host_name(name)\n          raise BaseError, _key: :unsupported_host_name\n        end",
    "comment": "Called to change the hostname of the virtual machine.",
    "label": "",
    "id": "307"
  },
  {
    "raw_code": "def finalize!\n          # Default implementation is to do nothing.\n        end",
    "comment": "This is called as a last-minute hook that allows the configuration object to finalize itself before it will be put into use. This is a useful place to do some defaults in the case the user didn't configure something or so on.  An example of where this sort of thing is used or has been used: the \"vm\" configuration key uses this to make sure that at least one sub-VM has been defined: the default VM.  The configuration object is expected to mutate itself.",
    "label": "",
    "id": "308"
  },
  {
    "raw_code": "def merge(other)\n          result = self.class.new\n\n          # Set all of our instance variables on the new class\n          [self, other].each do |obj|\n            obj.instance_variables.each do |key|\n              # Ignore keys that start with a double underscore. This allows\n              # configuration classes to still hold around internal state\n              # that isn't propagated.\n              if !key.to_s.start_with?(\"@__\")\n                result.instance_variable_set(key, obj.instance_variable_get(key))\n              end",
    "comment": "Merge another configuration object into this one. This assumes that the other object is the same class as this one. This should not mutate this object, but instead should return a new, merged object.  The default implementation will simply iterate over the instance variables and merge them together, with this object overriding any conflicting instance variables of the older object. Instance variables starting with \"__\" (double underscores) will be ignored. This lets you set some sort of instance-specific state on your configuration keys without them being merged together later.  @param [Object] other The other configuration object to merge from, this must be the same type of object as this one. @return [Object] The merged object.",
    "label": "",
    "id": "309"
  },
  {
    "raw_code": "def set_options(options)\n          options.each do |key, value|\n            send(\"#{key}=\", value)\n          end",
    "comment": "Allows setting options from a hash. By default this simply calls the `#{key}=` method on the config class with the value, which is the expected behavior most of the time.  This is expected to mutate itself.  @param [Hash] options A hash of options to set on this configuration key.",
    "label": "",
    "id": "310"
  },
  {
    "raw_code": "def to_json(*a)\n          instance_variables_hash.to_json(*a)\n        end",
    "comment": "Converts this configuration object to JSON.",
    "label": "",
    "id": "311"
  },
  {
    "raw_code": "def instance_variables_hash\n          instance_variables.inject({}) do |acc, iv|\n            acc[iv.to_s[1..-1]] = instance_variable_get(iv)\n            acc\n          end",
    "comment": "Returns the instance variables as a hash of key-value pairs.",
    "label": "",
    "id": "312"
  },
  {
    "raw_code": "def upgrade(new)\n        end",
    "comment": "This is called to upgrade this V1 config to V2. The parameter given is the full V2 configuration object, so you can do anything to it that you want.  No return value is expected, modifications should be made directly to the new V2 object.  @param [V2::Root] new",
    "label": "",
    "id": "313"
  },
  {
    "raw_code": "def validate(env, errors)\n        end",
    "comment": "Called after the configuration is finalized and loaded to validate this object.  @param [Environment] env Vagrant::Environment object of the environment that this configuration has been loaded into. This gives you convenient access to things like the the root path and so on. @param [ErrorRecorder] errors",
    "label": "",
    "id": "314"
  },
  {
    "raw_code": "def self.match?(machine)\n          false\n        end",
    "comment": "This returns true/false depending on if the given machine can be communicated with using this communicator. If this returns `true`, then this class will be used as the primary communication method for the machine.  @return [Boolean]",
    "label": "",
    "id": "315"
  },
  {
    "raw_code": "def initialize(machine)\n        end",
    "comment": "Initializes the communicator with the machine that we will be communicating with. This base method does nothing (it doesn't even store the machine in an instance variable for you), so you're expected to override this and do something with the machine if you care about it.  @param [Machine] machine The machine this instance is expected to communicate with.",
    "label": "",
    "id": "316"
  },
  {
    "raw_code": "def ready?\n          false\n        end",
    "comment": "Checks if the target machine is ready for communication. If this returns true, then all the other methods for communicating with the machine are expected to be functional.  @return [Boolean]",
    "label": "",
    "id": "317"
  },
  {
    "raw_code": "def download(from, to)\n        end",
    "comment": "Download a file from the remote machine to the local machine.  @param [String] from Path of the file on the remote machine. @param [String] to Path of where to save the file locally.",
    "label": "",
    "id": "318"
  },
  {
    "raw_code": "def upload(from, to)\n        end",
    "comment": "Upload a file to the remote machine.  @param [String] from Path of the file locally to upload. @param [String] to Path of where to save the file on the remote machine.",
    "label": "",
    "id": "319"
  },
  {
    "raw_code": "def execute(command, opts=nil)\n        end",
    "comment": "Execute a command on the remote machine. The exact semantics of this method are up to the implementor, but in general the users of this class will expect this to be a shell.  This method gives you no way to write data back to the remote machine, so only execute commands that don't expect input.  @param [String] command Command to execute. @yield [type, data] Realtime output of the command being executed. @yieldparam [String] type Type of the output. This can be `:stdout`, `:stderr`, etc. The exact types are up to the implementor. @yieldparam [String] data Data for the given output. @return [Integer] Exit code of the command.",
    "label": "",
    "id": "320"
  },
  {
    "raw_code": "def sudo(command, opts=nil)\n        end",
    "comment": "Executes a command on the remote machine with administrative privileges. See {#execute} for documentation, as the API is the same.  @see #execute",
    "label": "",
    "id": "321"
  },
  {
    "raw_code": "def test(command, opts=nil)\n        end",
    "comment": "Executes a command and returns true if the command succeeded, and false otherwise. By default, this executes as a normal user, and it is up to the communicator implementation if they expose an option for running tests as an administrator.  @see #execute",
    "label": "",
    "id": "322"
  },
  {
    "raw_code": "def initialize(env, config)\n          @env     = env\n          @config  = config\n        end",
    "comment": "Initializes the pusher with the given environment the push configuration.  @param [Environment] env @param [Object] config Push configuration",
    "label": "",
    "id": "323"
  },
  {
    "raw_code": "def push\n        end",
    "comment": "This is the method called when the actual pushing should be done.  No return value is expected.",
    "label": "",
    "id": "324"
  },
  {
    "raw_code": "def initialize(env, config, machine, ui)\n          @env        = env\n          @config     = config\n          @machine    = machine\n          @ui         = ui\n\n          @logger = Log4r::Logger.new(\"vagrant::trigger::#{self.class.to_s.downcase}\")\n        end",
    "comment": "This class is responsible for setting up basic triggers that were defined inside a Vagrantfile.  @param [Vagrant::Environment] env Vagrant environment @param [Kernel_V2::TriggerConfig] config Trigger configuration @param [Vagrant::Machine] machine Active Machine @param [Vagrant::UI] ui Class for printing messages to user",
    "label": "",
    "id": "325"
  },
  {
    "raw_code": "def fire(name, stage, guest, type, all: false)\n          if community_plugin_detected?\n            @logger.warn(\"Community plugin `vagrant-triggers detected, so core triggers will not fire\")\n            return\n          end",
    "comment": "Fires all triggers, if any are defined for the named type and guest. Returns early and logs a warning if the community plugin `vagrant-triggers` is installed  @param [Symbol] name Name of `type` thing to fire trigger on @param [Symbol] stage :before or :after @param [String] guest The guest that invoked firing the triggers @param [Symbol] type Type of trigger to fire (:action, :hook, :command)",
    "label": "",
    "id": "326"
  },
  {
    "raw_code": "def find(name, stage, guest, type, all: false)\n          triggers = nil\n          name = nameify(name)\n\n          if stage == :before\n            triggers = config.before_triggers.select do |t|\n              (all && t.command.respond_to?(:to_sym) && t.command.to_sym == :all && !t.ignore.include?(name.to_sym)) ||\n                (type == :hook && matched_hook?(t.command, name)) ||\n                nameify(t.command) == name\n            end",
    "comment": "Find all triggers defined for the named type and guest.  @param [Symbol] name Name of `type` thing to fire trigger on @param [Symbol] stage :before or :after @param [String] guest The guest that invoked firing the triggers @param [Symbol] type Type of trigger to fire @return [Array]",
    "label": "",
    "id": "327"
  },
  {
    "raw_code": "def nameify(object)\n          if object.is_a?(Class)\n            object.name.to_s\n          else\n            object.to_s\n          end",
    "comment": "Convert object into name  @param [Object, Class] object Object to name @return [String]",
    "label": "",
    "id": "328"
  },
  {
    "raw_code": "def matched_hook?(key, subject)\n          subject = nameify(subject)\n          Vagrant.plugin(\"2\").manager.generate_hook_keys(key).any? do |k|\n            k == subject\n          end",
    "comment": "------------------------------------------------------------------- Internal methods, don't call these. ------------------------------------------------------------------- Generate all valid lookup keys for given action key  @param [Class, String] key Base key for generation @return [Array<String>] all valid keys",
    "label": "",
    "id": "329"
  },
  {
    "raw_code": "def community_plugin_detected?\n          if !defined?(@_triggers_enabled)\n            plugins = Vagrant::Plugin::Manager.instance.installed_plugins\n            @_triggers_enabled = plugins.keys.include?(\"vagrant-triggers\")\n          end",
    "comment": "Looks up if the community plugin `vagrant-triggers` is installed and also caches the result  @return [Boolean]",
    "label": "",
    "id": "330"
  },
  {
    "raw_code": "def filter_triggers(triggers, guest_name, type)\n          # look for only_on trigger constraint and if it doesn't match guest\n          # name, throw it away also be sure to preserve order\n          filter = triggers.dup\n\n          filter.each do |trigger|\n            index = nil\n            match = false\n            if trigger.only_on\n              trigger.only_on.each do |o|\n                if o.match(guest_name.to_s)\n                  # trigger matches on current guest, so we're fine to use it\n                  match = true\n                  break\n                end",
    "comment": "Filters triggers to be fired based on configured restraints  @param [Array] triggers An array of triggers to be filtered @param [String] guest_name The name of the current guest @param [Symbol] type The type of trigger (:command or :type) @return [Array] The filtered array of triggers",
    "label": "",
    "id": "331"
  },
  {
    "raw_code": "def execute(triggers)\n          # ensure on_error is respected by exiting or continuing\n          triggers.each do |trigger|\n            @logger.debug(\"Running trigger #{trigger.id}...\")\n\n            if trigger.name\n              @ui.info(I18n.t(\"vagrant.trigger.fire_with_name\",\n                                      name: trigger.name))\n            else\n              @ui.info(I18n.t(\"vagrant.trigger.fire\"))\n            end",
    "comment": "Execute all triggers in the given array  @param [Array] triggers An array of triggers to be fired",
    "label": "",
    "id": "332"
  },
  {
    "raw_code": "def info(message)\n          @ui.info(message)\n        end",
    "comment": "Prints the given message at info level for a trigger  @param [String] message The string to be printed",
    "label": "",
    "id": "333"
  },
  {
    "raw_code": "def warn(message)\n          @ui.warn(message)\n        end",
    "comment": "Prints the given message at warn level for a trigger  @param [String] message The string to be printed",
    "label": "",
    "id": "334"
  },
  {
    "raw_code": "def run(config, on_error, exit_codes)\n          if config.inline\n            if Vagrant::Util::Platform.windows?\n              cmd = config.inline\n            else\n              cmd = Shellwords.split(config.inline)\n            end",
    "comment": "Runs a script on a guest  @param [Provisioners::Shell::Config] config A Shell provisioner config",
    "label": "",
    "id": "335"
  },
  {
    "raw_code": "def run_remote(config, on_error, exit_codes)\n          if !@machine\n            # machine doesn't even exist.\n            if on_error == :halt\n              raise Errors::TriggersGuestNotExist\n            else\n              @ui.warn(I18n.t(\"vagrant.errors.triggers_guest_not_exist\"))\n              @ui.warn(I18n.t(\"vagrant.trigger.on_error_continue\"))\n              return\n            end",
    "comment": "Runs a script on the guest  @param [ShellProvisioner/Config] config A Shell provisioner config",
    "label": "",
    "id": "336"
  },
  {
    "raw_code": "def trigger_abort(exit_code)\n          if Thread.current[:batch_parallel_action]\n            @ui.warn(I18n.t(\"vagrant.trigger.abort_threaded\"))\n            @logger.debug(\"Trigger abort within parallel batch action. \" \\\n              \"Setting exit code and terminating.\")\n            Thread.current[:exit_code] = exit_code\n            Thread.current.terminate\n          else\n            @ui.warn(I18n.t(\"vagrant.trigger.abort\"))\n            @logger.debug(\"Trigger abort within non-parallel action, exiting directly\")\n            Process.exit!(exit_code)\n          end",
    "comment": "Exits Vagrant immediately  @param [Integer] code Code to exit Vagrant on",
    "label": "",
    "id": "337"
  },
  {
    "raw_code": "def execute_ruby(ruby_block)\n          ruby_block.call(@env, @machine)\n        end",
    "comment": "Calls the given ruby block for execution  @param [Proc] ruby_block",
    "label": "",
    "id": "338"
  },
  {
    "raw_code": "def self.usable?(raise_error=false)\n          # Return true by default for backwards compat since this was\n          # introduced long after providers were being written.\n          true\n        end",
    "comment": "This is called early, before a machine is instantiated, to check if this provider is usable. This should return true or false.  If raise_error is true, then instead of returning false, this should raise an error with a helpful message about why this provider cannot be used.  @param [Boolean] raise_error If true, raise exception if not usable. @return [Boolean]",
    "label": "",
    "id": "339"
  },
  {
    "raw_code": "def self.installed?\n          # By default return true for backwards compat so all providers\n          # continue to work.\n          true\n        end",
    "comment": "This is called early, before a machine is instantiated, to check if this provider is installed. This should return true or false.  If the provider is not installed and Vagrant determines it is able to install this provider, then it will do so. Installation is done by calling Environment.install_provider.  If Environment.can_install_provider? returns false, then an error will be shown to the user.",
    "label": "",
    "id": "340"
  },
  {
    "raw_code": "def initialize(machine)\n        end",
    "comment": "Initialize the provider to represent the given machine.  @param [Vagrant::Machine] machine The machine that this provider is responsible for.",
    "label": "",
    "id": "341"
  },
  {
    "raw_code": "def action(name)\n          nil\n        end",
    "comment": "This should return an action callable for the given name.  @param [Symbol] name Name of the action. @return [Object] A callable action sequence object, whether it is a proc, object, etc.",
    "label": "",
    "id": "342"
  },
  {
    "raw_code": "def machine_id_changed\n        end",
    "comment": "This method is called if the underlying machine ID changes. Providers can use this method to load in new data for the actual backing machine or to realize that the machine is now gone (the ID can become `nil`). No parameters are given, since the underlying machine is simply the machine instance given to this object. And no return value is necessary.",
    "label": "",
    "id": "343"
  },
  {
    "raw_code": "def ssh_info\n          nil\n        end",
    "comment": "This should return a hash of information that explains how to SSH into the machine. If the machine is not at a point where SSH is even possible, then `nil` should be returned.  The general structure of this returned hash should be the following:  { host: \"1.2.3.4\", port: \"22\", username: \"mitchellh\", private_key_path: \"/path/to/my/key\" }  **Note:** Vagrant only supports private key based authentication, mainly for the reason that there is no easy way to exec into an `ssh` prompt with a password, whereas we can pass a private key via commandline.  @return [Hash] SSH information. For the structure of this hash read the accompanying documentation for this method.",
    "label": "",
    "id": "344"
  },
  {
    "raw_code": "def state\n          nil\n        end",
    "comment": "This should return the state of the machine within this provider. The state must be an instance of {MachineState}. Please read the documentation of that class for more information.  @return [MachineState]",
    "label": "",
    "id": "345"
  },
  {
    "raw_code": "def _initialize(name, machine)\n          initialize_capabilities!(\n            name.to_sym,\n            { name.to_sym => [Class.new, nil] },\n            Vagrant.plugin(\"2\").manager.provider_capabilities,\n            machine,\n          )\n        end",
    "comment": "This is an internal initialize function that should never be overridden. It is used to initialize some common internal state that is used in a provider.",
    "label": "",
    "id": "346"
  },
  {
    "raw_code": "def initialize(machine, config)\n          @machine = machine\n          @config  = config\n        end",
    "comment": "Initializes the provisioner with the machine that it will be provisioning along with the provisioner configuration (if there is any).  The provisioner should _not_ do anything at this point except initialize internal state.  @param [Machine] machine The machine that this will be provisioning. @param [Object] config Provisioner configuration, if one was set.",
    "label": "",
    "id": "347"
  },
  {
    "raw_code": "def configure(root_config)\n        end",
    "comment": "Called with the root configuration of the machine so the provisioner can add some configuration on top of the machine.  During this step, and this step only, the provisioner should modify the root machine configuration to add any additional features it may need. Examples include sharing folders, networking, and so on. This step is guaranteed to be called before any of those steps are done so the provisioner may do that.  No return value is expected.",
    "label": "",
    "id": "348"
  },
  {
    "raw_code": "def provision\n        end",
    "comment": "This is the method called when the actual provisioning should be done. The communicator is guaranteed to be ready at this point, and any shared folders or networks are already setup.  No return value is expected.",
    "label": "",
    "id": "349"
  },
  {
    "raw_code": "def cleanup\n        end",
    "comment": "This is the method called when destroying a machine that allows for any state related to the machine created by the provisioner to be cleaned up.",
    "label": "",
    "id": "350"
  },
  {
    "raw_code": "def action_hooks(hook_name)\n          result = []\n\n          @registered.each do |plugin|\n            result += plugin.components.action_hooks[Plugin::ALL_ACTIONS]\n            result += plugin.components.action_hooks[hook_name]\n          end",
    "comment": "This returns all the action hooks.  @return [Array]",
    "label": "",
    "id": "351"
  },
  {
    "raw_code": "def find_action_hooks(key)\n          result = []\n\n          generate_hook_keys(key).each do |k|\n            @registered.each do |plugin|\n              result += plugin.components.action_hooks[k]\n              result += plugin.components.action_hooks[k.to_sym]\n            end",
    "comment": "Find all hooks that are applicable for the given key. This lookup does not include hooks which are defined for ALL_ACTIONS. Key lookups will match on either string or symbol values. The provided keys is broken down into multiple parts for lookups, which allows defining hooks with an entire namespaced name, or a short suffx. For example:  Assume we are given an action class key = Vagrant::Action::Builtin::SyncedFolders  The list of keys that will be checked for hooks: [\"Vagrant::Action::Builtin::SyncedFolders\", \"vagrant_action_builtin_synced_folders\", \"Action::Builtin::SyncedFolders\", \"action_builtin_synced_folders\", \"Builtin::SyncedFolders\", \"builtin_synced_folders\", \"SyncedFolders\", \"synced_folders\"]  @param key [Class, String] key Key for hook lookups @return [Array<Proc>]",
    "label": "",
    "id": "352"
  },
  {
    "raw_code": "def generate_hook_keys(key)\n          if key.is_a?(Class)\n            key = key.name.to_s\n          else\n            key = key.to_s\n          end",
    "comment": "Generate all valid lookup keys for given key  @param [Class, String] key Base key for generation @return [Array<String>] all valid keys",
    "label": "",
    "id": "353"
  },
  {
    "raw_code": "def commands\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.components.commands)\n            end",
    "comment": "This returns all the registered commands.  @return [Registry<Symbol, Array<Proc, Hash>>]",
    "label": "",
    "id": "354"
  },
  {
    "raw_code": "def communicators\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.communicator)\n            end",
    "comment": "This returns all the registered communicators.  @return [Hash]",
    "label": "",
    "id": "355"
  },
  {
    "raw_code": "def config\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.components.configs[:top])\n            end",
    "comment": "This returns all the registered configuration classes.  @return [Hash]",
    "label": "",
    "id": "356"
  },
  {
    "raw_code": "def guests\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.components.guests)\n            end",
    "comment": "This returns all the registered guests.  @return [Hash]",
    "label": "",
    "id": "357"
  },
  {
    "raw_code": "def guest_capabilities\n          results = Hash.new { |h, k| h[k] = Registry.new }\n\n          @registered.each do |plugin|\n            plugin.components.guest_capabilities.each do |guest, caps|\n              results[guest].merge!(caps)\n            end",
    "comment": "This returns all the registered guest capabilities.  @return [Hash]",
    "label": "",
    "id": "358"
  },
  {
    "raw_code": "def hosts\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.components.hosts)\n            end",
    "comment": "This returns all the registered guests.  @return [Hash]",
    "label": "",
    "id": "359"
  },
  {
    "raw_code": "def host_capabilities\n          results = Hash.new { |h, k| h[k] = Registry.new }\n\n          @registered.each do |plugin|\n            plugin.components.host_capabilities.each do |host, caps|\n              results[host].merge!(caps)\n            end",
    "comment": "This returns all the registered host capabilities.  @return [Hash]",
    "label": "",
    "id": "360"
  },
  {
    "raw_code": "def providers\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.components.providers)\n            end",
    "comment": "This returns all registered providers.  @return [Hash]",
    "label": "",
    "id": "361"
  },
  {
    "raw_code": "def provider_capabilities\n          results = Hash.new { |h, k| h[k] = Registry.new }\n\n          @registered.each do |plugin|\n            plugin.components.provider_capabilities.each do |provider, caps|\n              results[provider].merge!(caps)\n            end",
    "comment": "This returns all the registered provider capabilities.  @return [Hash]",
    "label": "",
    "id": "362"
  },
  {
    "raw_code": "def provider_configs\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.components.configs[:provider])\n            end",
    "comment": "This returns all the config classes for the various providers.  @return [Hash]",
    "label": "",
    "id": "363"
  },
  {
    "raw_code": "def provisioner_configs\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.components.configs[:provisioner])\n            end",
    "comment": "This returns all the config classes for the various provisioners.  @return [Registry]",
    "label": "",
    "id": "364"
  },
  {
    "raw_code": "def provisioners\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.provisioner)\n            end",
    "comment": "This returns all registered provisioners.  @return [Hash]",
    "label": "",
    "id": "365"
  },
  {
    "raw_code": "def pushes\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.components.pushes)\n            end",
    "comment": "This returns all registered pushes.  @return [Registry]",
    "label": "",
    "id": "366"
  },
  {
    "raw_code": "def push_configs\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.components.configs[:push])\n            end",
    "comment": "This returns all the config classes for the various pushes.  @return [Registry]",
    "label": "",
    "id": "367"
  },
  {
    "raw_code": "def synced_folders\n          Registry.new.tap do |result|\n            @registered.each do |plugin|\n              result.merge!(plugin.components.synced_folders)\n            end",
    "comment": "This returns all synced folder implementations.  @return [Registry]",
    "label": "",
    "id": "368"
  },
  {
    "raw_code": "def synced_folder_capabilities\n          results = Hash.new { |h, k| h[k] = Registry.new }\n\n          @registered.each do |plugin|\n            plugin.components.synced_folder_capabilities.each do |synced_folder, caps|\n              results[synced_folder].merge!(caps)\n            end",
    "comment": "This returns all the registered synced folder capabilities.  @return [Hash]",
    "label": "",
    "id": "369"
  },
  {
    "raw_code": "def register(plugin)\n          if !@registered.include?(plugin)\n            @logger.info(\"Registered plugin: #{plugin.name}\")\n            @registered << plugin\n          end",
    "comment": "This registers a plugin. This should _NEVER_ be called by the public and should only be called from within Vagrant. Vagrant will automatically register V2 plugins when a name is set on the plugin.",
    "label": "",
    "id": "370"
  },
  {
    "raw_code": "def reset!\n          @registered.clear\n        end",
    "comment": "This clears out all the registered plugins. This is only used by unit tests and should not be called directly.",
    "label": "",
    "id": "371"
  },
  {
    "raw_code": "def unregister(plugin)\n          if @registered.include?(plugin)\n            @logger.info(\"Unregistered: #{plugin.name}\")\n            @registered.delete(plugin)\n          end",
    "comment": "This unregisters a plugin so that its components will no longer be used. Note that this should only be used for testing purposes.",
    "label": "",
    "id": "372"
  },
  {
    "raw_code": "def self.synopsis\n          \"\"\n        end",
    "comment": "This should return a brief (60 characters or less) synopsis of what this command does. It will be used in the output of the help.  @return [String]",
    "label": "",
    "id": "373"
  },
  {
    "raw_code": "def execute\n        end",
    "comment": "This is what is called on the class to actually execute it. Any subclasses should implement this method and do any option parsing and validation here.",
    "label": "",
    "id": "374"
  },
  {
    "raw_code": "def parse_options(opts=nil)\n          # make sure optparse doesn't use POSIXLY_CORRECT parsing\n          ENV[\"POSIXLY_CORRECT\"] = nil\n\n          # Creating a shallow copy of the arguments so the OptionParser\n          # doesn't destroy the originals.\n          argv = @argv.dup\n\n          # Default opts to a blank optionparser if none is given\n          opts ||= Vagrant::OptionParser.new\n\n          # Add the help option, which must be on every command.\n          opts.on_tail(\"-h\", \"--help\", \"Print this help\") do\n            safe_puts(opts.help)\n            return nil\n          end",
    "comment": "Parses the options given an OptionParser instance.  This is a convenience method that properly handles duping the originally argv array so that it is not destroyed.  This method will also automatically detect \"-h\" and \"--help\" and print help. And if any invalid options are detected, the help will be printed, as well.  If this method returns `nil`, then you should assume that help was printed and parsing failed.",
    "label": "",
    "id": "375"
  },
  {
    "raw_code": "def with_target_vms(names=nil, options=nil)\n          @logger.debug(\"Getting target VMs for command. Arguments:\")\n          @logger.debug(\" -- names: #{names.inspect}\")\n          @logger.debug(\" -- options: #{options.inspect}\")\n\n          # Setup the options hash\n          options ||= {}\n\n          # Require that names be an array\n          names ||= []\n          names = [names] if !names.is_a?(Array)\n\n          # Determine if we require a local Vagrant environment. There are\n          # two cases that we require a local environment:\n          #\n          #   * We're asking for ANY/EVERY VM (no names given).\n          #\n          #   * We're asking for specific VMs, at least once of which\n          #     is NOT in the local machine index.\n          #\n          requires_local_env = false\n          requires_local_env = true if names.empty?\n          requires_local_env ||= names.any? { |n|\n            !@env.machine_index.include?(n)\n          }\n          raise Errors::NoEnvironmentError if requires_local_env && !@env.root_path\n\n          @logger.info(\"getting active machines\")\n          # Cache the active machines outside the loop\n          active_machines = @env.active_machines\n\n          # This is a helper that gets a single machine with the proper\n          # provider. The \"proper provider\" in this case depends on what was\n          # given:\n          #\n          #   * If a provider was explicitly specified, then use that provider.\n          #     But if an active machine exists with a DIFFERENT provider,\n          #     then throw an error (for now), since we don't yet support\n          #     bringing up machines with different providers.\n          #\n          #   * If no provider was specified, then use the active machine's\n          #     provider if it exists, otherwise use the default provider.\n          #\n          get_machine = lambda do |name|\n            # Check for an active machine with the same name\n            provider_to_use = options[:provider]\n            provider_to_use = provider_to_use.to_sym if provider_to_use\n\n            # If we have this machine in our index, load that.\n            entry = @env.machine_index.get(name.to_s)\n            if entry\n              @env.machine_index.release(entry)\n\n              # Create an environment for this location and yield the\n              # machine in that environment. We silence warnings here because\n              # Vagrantfiles often have constants, so people would otherwise\n              # constantly (heh) get \"already initialized constant\" warnings.\n              begin\n                env = entry.vagrant_env(\n                  @env.home_path, ui_class: @env.ui_class)\n              rescue Vagrant::Errors::EnvironmentNonExistentCWD\n                # This means that this environment working directory\n                # no longer exists, so delete this entry.\n                entry = @env.machine_index.get(name.to_s)\n                @env.machine_index.delete(entry) if entry\n                raise\n              end",
    "comment": "Yields a VM for each target VM for the command.  This is a convenience method for easily implementing methods that take a target VM (in the case of multi-VM) or every VM if no specific VM name is specified.  @param [String] name The name of the VM. Nil if every VM. @param [Hash] options Additional tweakable settings. @option options [Symbol] :provider The provider to back the machines with. All machines will be backed with this provider. If none is given, a sensible default is chosen. @option options [Boolean] :reverse If true, the resulting order of machines is reversed. @option options [Boolean] :single_target If true, then an exception will be raised if more than one target is found.",
    "label": "",
    "id": "376"
  },
  {
    "raw_code": "def split_main_and_subcommand(argv)\n          # Initialize return variables\n          main_args   = nil\n          sub_command = nil\n          sub_args    = []\n\n          # We split the arguments into two: One set containing any\n          # flags before a word, and then the rest. The rest are what\n          # get actually sent on to the subcommand.\n          argv.each_index do |i|\n            if !argv[i].start_with?(\"-\")\n              # We found the beginning of the sub command. Split the\n              # args up.\n              main_args   = argv[0, i]\n              sub_command = argv[i]\n              sub_args    = argv[i + 1, argv.length - i + 1]\n\n              # Break so we don't find the next non flag and shift our\n              # main args.\n              break\n            end",
    "comment": "This method will split the argv given into three parts: the flags to this command, the subcommand, and the flags to the subcommand. For example:  -v status -h -v  The above would yield 3 parts:  [\"-v\"] \"status\" [\"-h\", \"-v\"]  These parts are useful because the first is a list of arguments given to the current command, the second is a subcommand, and the third are the commands given to the subcommand.  @return [Array] The three parts.",
    "label": "",
    "id": "377"
  },
  {
    "raw_code": "def detect?(env)\n          false\n        end",
    "comment": "This returns true/false depending on if the current running system matches the host class.  @return [Boolean]",
    "label": "",
    "id": "378"
  },
  {
    "raw_code": "def types\n            keys\n          end",
    "comment": "@return [Array<Symbol>] names of synced folder types",
    "label": "",
    "id": "379"
  },
  {
    "raw_code": "def type(t)\n            f = detect { |k, _| k.to_sym == t.to_sym }.last\n            raise KeyError, \"Unknown synced folder type\" if !f\n            f.values.first[:plugin]\n          end",
    "comment": "Fetch the synced plugin folder of the given type  @param [Symbol] t Synced folder type @return [Vagrant::Plugin::V2::SyncedFolder]",
    "label": "",
    "id": "380"
  },
  {
    "raw_code": "def to_h\n            c = lambda do |h|\n              h.keys.each do |k|\n                if h[k].is_a?(Hash)\n                  h[k] = c.call(h[k].to_h.clone)\n                end",
    "comment": "Converts to a regular Hash and removes plugin instances so the result is ready for serialization  @return [Hash]",
    "label": "",
    "id": "381"
  },
  {
    "raw_code": "def usable?(machine, raise_error=false)\n        end",
    "comment": "This is called early when the synced folder is set to determine if this implementation can be used for this machine. This should return true or false.  @param [Machine] machine @param [Boolean] raise_error If true, should raise an exception if it isn't usable. @return [Boolean]",
    "label": "",
    "id": "382"
  },
  {
    "raw_code": "def prepare(machine, folders, opts)\n        end",
    "comment": "DEPRECATED: This will be removed.  @deprecated",
    "label": "",
    "id": "383"
  },
  {
    "raw_code": "def enable(machine, folders, opts)\n        end",
    "comment": "This is called after the machine is booted and after networks are setup.  This might be called with new folders while the machine is running. If so, then this should add only those folders without removing any existing ones.  No return value.",
    "label": "",
    "id": "384"
  },
  {
    "raw_code": "def disable(machine, folders, opts)\n        end",
    "comment": "This is called to remove the synced folders from a running machine.  This is not guaranteed to be called, but this should be implemented by every synced folder implementation.  @param [Machine] machine The machine to modify. @param [Hash] folders The folders to remove. This will not contain any folders that should remain. @param [Hash] opts Any options for the synced folders.",
    "label": "",
    "id": "385"
  },
  {
    "raw_code": "def cleanup(machine, opts)\n        end",
    "comment": "This is called after destroying the machine during a `vagrant destroy` and also prior to syncing folders during a `vagrant up`.  No return value.  @param [Machine] machine @param [Hash] opts",
    "label": "",
    "id": "386"
  },
  {
    "raw_code": "def self.manager\n          @manager ||= local_manager\n        end",
    "comment": "This returns the manager for all V2 plugins.  @return [V2::Manager]",
    "label": "",
    "id": "387"
  },
  {
    "raw_code": "def self.components\n          @components ||= Components.new\n        end",
    "comment": "Returns the {Components} for this plugin.  @return [Components]",
    "label": "",
    "id": "388"
  },
  {
    "raw_code": "def self.name(name=UNSET_VALUE)\n          # Get or set the value first, so we have a name for logging when\n          # we register.\n          result = get_or_set(:name, name)\n\n          # The plugin should be registered if we're setting a real name on it\n          Plugin.manager.register(self) if name != UNSET_VALUE\n\n          # Return the result\n          result\n        end",
    "comment": "Set the name of the plugin. The moment that this is called, the plugin will be registered and available. Before this is called, a plugin does not exist. The name must be unique among all installed plugins.  @param [String] name Name of the plugin. @return [String] The name of the plugin.",
    "label": "",
    "id": "389"
  },
  {
    "raw_code": "def self.description(value=UNSET_VALUE)\n          get_or_set(:description, value)\n        end",
    "comment": "Sets a human-friendly description of the plugin.  @param [String] value Description of the plugin. @return [String] Description of the plugin.",
    "label": "",
    "id": "390"
  },
  {
    "raw_code": "def self.action_hook(name, hook_name=nil, &block)\n          # The name is currently not used but we want it for the future.\n          hook_name = hook_name.to_s if hook_name\n\n          hook_name ||= ALL_ACTIONS\n          components.action_hooks[hook_name.to_sym] << block\n        end",
    "comment": "Registers a callback to be called when a specific action sequence is run. This allows plugin authors to hook into things like VM bootup, VM provisioning, etc.  @param [String] name Name of the action. @param [Symbol] hook_name The location to hook. If this isn't set, every middleware action is hooked. @return [Array] List of the hooks for the given action.",
    "label": "",
    "id": "391"
  },
  {
    "raw_code": "def self.command(name, **opts, &block)\n          # Validate the name of the command\n          if name.to_s !~ /^[-a-z0-9]+$/i\n            raise InvalidCommandName, \"Commands can only contain letters, numbers, and hyphens\"\n          end",
    "comment": "Defines additional command line commands available by key. The key becomes the subcommand, so if you register a command \"foo\" then \"vagrant foo\" becomes available.  @param [String] name Subcommand key.",
    "label": "",
    "id": "392"
  },
  {
    "raw_code": "def self.communicator(name=UNSET_VALUE, &block)\n          data[:communicator] ||= Registry.new\n\n          # Register a new communicator class only if a name was given.\n          data[:communicator].register(name.to_sym, &block) if name != UNSET_VALUE\n\n          # Return the registry\n          data[:communicator]\n        end",
    "comment": "Defines additional communicators to be available. Communicators should be returned by a block passed to this method. This is done to ensure that the class is lazy loaded, so if your class inherits from or uses any Vagrant internals specific to Vagrant 1.0, then the plugin can still be defined without breaking anything in future versions of Vagrant.  @param [String] name Communicator name.",
    "label": "",
    "id": "393"
  },
  {
    "raw_code": "def self.config(name, scope=nil, &block)\n          scope ||= :top\n          components.configs[scope].register(name.to_sym, &block)\n          nil\n        end",
    "comment": "Defines additional configuration keys to be available in the Vagrantfile. The configuration class should be returned by a block passed to this method. This is done to ensure that the class is lazy loaded, so if your class inherits from any classes that are specific to Vagrant 1.0, then the plugin can still be defined without breaking anything in future versions of Vagrant.  @param [String] name Configuration key.",
    "label": "",
    "id": "394"
  },
  {
    "raw_code": "def self.guest(name, parent=nil, &block)\n          components.guests.register(name.to_sym) do\n            parent = parent.to_sym if parent\n\n            [block.call, parent]\n          end",
    "comment": "Defines an additionally available guest implementation with the given key.  @param [String] name Name of the guest. @param [String] parent Name of the parent guest (if any)",
    "label": "",
    "id": "395"
  },
  {
    "raw_code": "def self.guest_capability(guest, cap, &block)\n          components.guest_capabilities[guest.to_sym].register(cap.to_sym, &block)\n          nil\n        end",
    "comment": "Defines a capability for the given guest. The block should return a class/module that has a method with the capability name, ready to be executed. This means that if it is an instance method, the block should return an instance of the class.  @param [String] guest The name of the guest @param [String] cap The name of the capability",
    "label": "",
    "id": "396"
  },
  {
    "raw_code": "def self.host(name, parent=nil, &block)\n          components.hosts.register(name.to_sym) do\n            parent = parent.to_sym if parent\n\n            [block.call, parent]\n          end",
    "comment": "Defines an additionally available host implementation with the given key.  @param [String] name Name of the host. @param [String] parent Name of the parent host (if any)",
    "label": "",
    "id": "397"
  },
  {
    "raw_code": "def self.host_capability(host, cap, &block)\n          components.host_capabilities[host.to_sym].register(cap.to_sym, &block)\n          nil\n        end",
    "comment": "Defines a capability for the given host. The block should return a class/module that has a method with the capability name, ready to be executed. This means that if it is an instance method, the block should return an instance of the class.  @param [String] host The name of the host @param [String] cap The name of the capability",
    "label": "",
    "id": "398"
  },
  {
    "raw_code": "def self.provider(name=UNSET_VALUE, options=nil, &block)\n          options ||= {}\n          options[:priority] ||= 5\n\n          components.providers.register(name.to_sym) do\n            [block.call, options]\n          end",
    "comment": "Registers additional providers to be available.  @param [Symbol] name Name of the provider.",
    "label": "",
    "id": "399"
  },
  {
    "raw_code": "def self.provider_capability(provider, cap, &block)\n          components.provider_capabilities[provider.to_sym].register(cap.to_sym, &block)\n          nil\n        end",
    "comment": "Defines a capability for the given provider. The block should return a class/module that has a method with the capability name, ready to be executed. This means that if it is an instance method, the block should return an instance of the class.  @param [String] provider The name of the provider @param [String] cap The name of the capability",
    "label": "",
    "id": "400"
  },
  {
    "raw_code": "def self.provisioner(name=UNSET_VALUE, &block)\n          data[:provisioners] ||= Registry.new\n\n          # Register a new provisioner class only if a name was given\n          data[:provisioners].register(name.to_sym, &block) if name != UNSET_VALUE\n\n          # Return the registry\n          data[:provisioners]\n        end",
    "comment": "Registers additional provisioners to be available.  @param [String] name Name of the provisioner.",
    "label": "",
    "id": "401"
  },
  {
    "raw_code": "def self.push(name, options=nil, &block)\n          components.pushes.register(name.to_sym) do\n            [block.call, options]\n          end",
    "comment": "Registers additional pushes to be available.  @param [String] name Name of the push. @param [Hash] options List of options for the push.",
    "label": "",
    "id": "402"
  },
  {
    "raw_code": "def self.synced_folder(name, priority=10, &block)\n          components.synced_folders.register(name.to_sym) do\n            [block.call, priority]\n          end",
    "comment": "Registers additional synced folder implementations.  @param [String] name Name of the implementation. @param [Integer] priority The priority of the implementation, higher (big) numbers are tried before lower (small) numbers.",
    "label": "",
    "id": "403"
  },
  {
    "raw_code": "def self.synced_folder_capability(synced_folder, cap, &block)\n          components.synced_folder_capabilities[synced_folder.to_sym].register(cap.to_sym, &block)\n          nil\n        end",
    "comment": "Defines a capability for the given synced folder. The block should return a class/module that has a method with the capability name, ready to be executed. This means that if it is an instance method, the block should return an instance of the class.  @param [String] synced_folder The name of the synced folder @param [String] cap The name of the capability",
    "label": "",
    "id": "404"
  },
  {
    "raw_code": "def self.data\n          @data ||= {}\n        end",
    "comment": "Returns the internal data associated with this plugin. This should NOT be called by the general public.  @return [Hash]",
    "label": "",
    "id": "405"
  },
  {
    "raw_code": "def self.get_or_set(key, value=UNSET_VALUE)\n          # If no value is to be set, then return the value we have already set\n          return data[key] if value.eql?(UNSET_VALUE)\n\n          # Otherwise set the value\n          data[key] = value\n        end",
    "comment": "Helper method that will set a value if a value is given, or otherwise return the already set value.  @param [Symbol] key Key for the data @param [Object] value Value to store. @return [Object] Stored value.",
    "label": "",
    "id": "406"
  },
  {
    "raw_code": "def detect?(machine)\n          false\n        end",
    "comment": "This method is called when the machine is booted and has communication capabilities in order to detect whether this guest operating system is running within the machine.  @return [Boolean]",
    "label": "",
    "id": "407"
  },
  {
    "raw_code": "def finalize!\n          # Default implementation is to do nothing.\n        end",
    "comment": "This is called as a last-minute hook that allows the configuration object to finalize itself before it will be put into use. This is a useful place to do some defaults in the case the user didn't configure something or so on.  An example of where this sort of thing is used or has been used: the \"vm\" configuration key uses this to make sure that at least one sub-VM has been defined: the default VM.  The configuration object is expected to mutate itself.",
    "label": "",
    "id": "408"
  },
  {
    "raw_code": "def merge(other)\n          result = self.class.new\n\n          # Set all of our instance variables on the new class\n          [self, other].each do |obj|\n            obj.instance_variables.each do |key|\n              # Ignore keys that start with a double underscore. This allows\n              # configuration classes to still hold around internal state\n              # that isn't propagated.\n              if !key.to_s.start_with?(\"@__\")\n                # Don't set the value if it is the unset value, either.\n                value = obj.instance_variable_get(key)\n                result.instance_variable_set(key, value) if value != UNSET_VALUE\n              end",
    "comment": "Merge another configuration object into this one. This assumes that the other object is the same class as this one. This should not mutate this object, but instead should return a new, merged object.  The default implementation will simply iterate over the instance variables and merge them together, with this object overriding any conflicting instance variables of the older object. Instance variables starting with \"__\" (double underscores) will be ignored. This lets you set some sort of instance-specific state on your configuration keys without them being merged together later.  @param [Object] other The other configuration object to merge from, this must be the same type of object as this one. @return [Object] The merged object.",
    "label": "",
    "id": "409"
  },
  {
    "raw_code": "def method_missing(name, *args, &block)\n          return super if @__finalized\n\n          # There are a few scenarios where ruby will attempt to implicity\n          # coerce a given object into a certain type. Configs can end up\n          # in some of these scenarios when they're being shipped around in\n          # callbacks with splats. If method_missing allows these methods to be\n          # called but continues to return Config back, Ruby will raise a\n          # TypeError. Doing the normal thing of raising NoMethodError allows\n          # Config to behave normally as its being passed through splats.\n          #\n          # For a bit more detail and some keywords for further searching, see:\n          # https://ruby-doc.org/core-2.7.2/doc/implicit_conversion_rdoc.html\n          if [:to_hash, :to_ary].include?(name)\n            return super\n          end",
    "comment": "Capture all bad configuration calls and save them for an error message later during validation.",
    "label": "",
    "id": "410"
  },
  {
    "raw_code": "def set_options(options)\n          options.each do |key, value|\n            send(\"#{key}=\", value)\n          end",
    "comment": "Allows setting options from a hash. By default this simply calls the `#{key}=` method on the config class with the value, which is the expected behavior most of the time.  This is expected to mutate itself.  @param [Hash] options A hash of options to set on this configuration key.",
    "label": "",
    "id": "411"
  },
  {
    "raw_code": "def to_json(*a)\n          instance_variables_hash.to_json(*a)\n        end",
    "comment": "Converts this configuration object to JSON.",
    "label": "",
    "id": "412"
  },
  {
    "raw_code": "def to_s\n          self.class.to_s\n        end",
    "comment": "A default to_s implementation.",
    "label": "",
    "id": "413"
  },
  {
    "raw_code": "def instance_variables_hash\n          instance_variables.inject({}) do |acc, iv|\n            acc[iv.to_s[1..-1]] = instance_variable_get(iv)\n            acc\n          end",
    "comment": "Returns the instance variables as a hash of key-value pairs.",
    "label": "",
    "id": "414"
  },
  {
    "raw_code": "def validate(machine)\n          return { self.to_s => _detected_errors }\n        end",
    "comment": "Called after the configuration is finalized and loaded to validate this object.  @param [Machine] machine Access to the machine that is being validated. @return [Hash]",
    "label": "",
    "id": "415"
  },
  {
    "raw_code": "def _detected_errors\n          return [] if !@__invalid_methods || @__invalid_methods.empty?\n          return [I18n.t(\"vagrant.config.common.bad_field\",\n                         fields: @__invalid_methods.to_a.sort.join(\", \"))]\n        end",
    "comment": "This returns any automatically detected errors.  @return [Array<String>]",
    "label": "",
    "id": "416"
  },
  {
    "raw_code": "def _finalize!\n          @__finalized = true\n        end",
    "comment": "An internal finalize call that no subclass should override.",
    "label": "",
    "id": "417"
  },
  {
    "raw_code": "def self.match?(machine)\n          true\n        end",
    "comment": "This returns true/false depending on if the given machine can be communicated with using this communicator. If this returns `true`, then this class will be used as the primary communication method for the machine.  @return [Boolean]",
    "label": "",
    "id": "418"
  },
  {
    "raw_code": "def initialize(machine)\n        end",
    "comment": "Initializes the communicator with the machine that we will be communicating with. This base method does nothing (it doesn't even store the machine in an instance variable for you), so you're expected to override this and do something with the machine if you care about it.  @param [Machine] machine The machine this instance is expected to communicate with.",
    "label": "",
    "id": "419"
  },
  {
    "raw_code": "def ready?\n          false\n        end",
    "comment": "Checks if the target machine is ready for communication. If this returns true, then all the other methods for communicating with the machine are expected to be functional.  @return [Boolean]",
    "label": "",
    "id": "420"
  },
  {
    "raw_code": "def wait_for_ready(duration)\n          # By default, we implement a naive solution.\n          begin\n            Timeout.timeout(duration) do\n              while true\n                return true if ready?\n                sleep 0.5\n              end",
    "comment": "wait_for_ready waits until the communicator is ready, blocking until then. It will wait up to the given duration or raise an exception if something goes wrong.  @param [Integer] duration Timeout in seconds. @return [Boolean] Will return true on successful connection or false on timeout.",
    "label": "",
    "id": "421"
  },
  {
    "raw_code": "def download(from, to)\n        end",
    "comment": "Download a file from the remote machine to the local machine.  @param [String] from Path of the file on the remote machine. @param [String] to Path of where to save the file locally.",
    "label": "",
    "id": "422"
  },
  {
    "raw_code": "def upload(from, to)\n        end",
    "comment": "Upload a file to the remote machine.  @param [String] from Path of the file locally to upload. @param [String] to Path of where to save the file on the remote machine.",
    "label": "",
    "id": "423"
  },
  {
    "raw_code": "def execute(command, opts=nil)\n        end",
    "comment": "Execute a command on the remote machine. The exact semantics of this method are up to the implementor, but in general the users of this class will expect this to be a shell.  This method gives you no way to write data back to the remote machine, so only execute commands that don't expect input.  @param [String] command Command to execute. @yield [type, data] Realtime output of the command being executed. @yieldparam [String] type Type of the output. This can be `:stdout`, `:stderr`, etc. The exact types are up to the implementor. @yieldparam [String] data Data for the given output. @return [Integer] Exit code of the command.",
    "label": "",
    "id": "424"
  },
  {
    "raw_code": "def sudo(command, opts=nil)\n        end",
    "comment": "Executes a command on the remote machine with administrative privileges. See {#execute} for documentation, as the API is the same.  @see #execute",
    "label": "",
    "id": "425"
  },
  {
    "raw_code": "def test(command, opts=nil)\n        end",
    "comment": "Executes a command and returns true if the command succeeded, and false otherwise. By default, this executes as a normal user, and it is up to the communicator implementation if they expose an option for running tests as an administrator.  @see #execute",
    "label": "",
    "id": "426"
  },
  {
    "raw_code": "def reset!\n        end",
    "comment": "Reset the communicator. For communicators which establish a persistent connection to the remote machine, this connection should be terminated and re-established. The communicator instance should be in a \"fresh\" state after calling this method.",
    "label": "",
    "id": "427"
  },
  {
    "raw_code": "def checksum\n        digest = @digest_klass.new\n        buf = ''\n\n        File.open(@path, \"rb\") do |f|\n          while !f.eof\n            begin\n              f.readpartial(BUFFER_SIZE, buf)\n              digest.update(buf)\n            rescue EOFError\n              # Although we check for EOF earlier, this seems to happen\n              # sometimes anyways [GH-2716].\n              break\n            end",
    "comment": "This calculates the checksum of the file and returns it as a string.  @return [String]",
    "label": "",
    "id": "428"
  },
  {
    "raw_code": "def self.directory_changed?(dir_path, threshold_time)\n        Dir.glob(Pathname.new(dir_path).join(\"**\", \"*\")).any? do |path|\n          Pathname.new(path).mtime > threshold_time\n        end",
    "comment": "Check if directory has any new updates  @param [Pathname, String] Path to directory @param [Time] time to compare to eg. has any file in dir_path changed since this time @return [Boolean]",
    "label": "",
    "id": "429"
  },
  {
    "raw_code": "def self.with_clean_env\n        with_original_env do\n          if ENV[\"BUNDLE_ORIG_MANPATH\"]\n            ENV[\"MANPATH\"] = ENV[\"BUNDLE_ORIG_MANPATH\"]\n          end",
    "comment": "Execute the given command, removing any Ruby-specific environment variables. This is an \"enhanced\" version of `Bundler.with_clean_env`, which only removes Bundler-specific values. We need to remove all values, specifically:  - _ORIGINAL_GEM_PATH - GEM_PATH - GEM_HOME - GEM_ROOT - BUNDLE_BIN_PATH - BUNDLE_GEMFILE - RUBYLIB - RUBYOPT - RUBY_ENGINE - RUBY_ROOT - RUBY_VERSION  This will escape Vagrant's environment entirely, which is required if calling an executable that lives in another Ruby environment. The original environment restored at the end of this call.  @param [Proc] block the block to execute with the cleaned environment",
    "label": "",
    "id": "430"
  },
  {
    "raw_code": "def self.from_octal(octal)\n        perms = sprintf(\"%o\", octal)\n        perms.reverse[0..2].reverse\n      end",
    "comment": "This returns the file permissions as a string from an octal number.",
    "label": "",
    "id": "431"
  },
  {
    "raw_code": "def string_to_bytes(str)\n          bytes = nil\n\n          str = str.to_s.strip\n          matches = SHORTHAND_MATCH_REGEX.match(str)\n          if matches\n            number = matches[:number].to_i\n            unit = matches[:unit].to_sym\n\n            if BYTES_CONVERSION_MAP.key?(unit)\n              bytes = number * BYTES_CONVERSION_MAP[unit]\n            else\n              LOGGER.error(\"An invalid unit or format was given, string_to_bytes cannot convert #{str}\")\n            end",
    "comment": "A helper that converts a shortcut string to its bytes representation. The expected format of `str` is essentially: \"<Number>XX\" Where `XX` is shorthand for KB, MB, GB, TB, PB, or EB. For example, 50 megabytes:  str = \"50MB\"  @param [String] - str @return [Integer,nil] - bytes - returns nil if method fails to convert to bytes",
    "label": "",
    "id": "432"
  },
  {
    "raw_code": "def bytes_to_string(bytes)\n          # We want to locate the size that will return the\n          # smallest whole value number\n          BYTES_CONVERSION_MAP.sort { |a, b|\n            b.last <=> a.last\n          }.each do |suffix, size|\n            val = bytes.to_f / size\n            next if val < 1\n            val = sprintf(\"%.2f\", val)\n            val.slice!(-1, 1) while val.end_with?(\"0\")\n            val.slice!(-1, 1) if val.end_with?(\".\")\n            return \"#{val}#{suffix}\"\n          end",
    "comment": "Convert bytes to a user friendly string representation  @param [Numeric] bytes Number of bytes to represent @return [String] user friendly output",
    "label": "",
    "id": "433"
  },
  {
    "raw_code": "def bytes_to_megabytes(bytes)\n          (bytes / MEGABYTE.to_f).round(2)\n        end",
    "comment": "Rounds actual value to two decimal places  @param [Integer] bytes @return [Integer] megabytes - bytes representation in megabytes",
    "label": "",
    "id": "434"
  },
  {
    "raw_code": "def reset!\n          instance_variables.each(&method(:remove_instance_variable))\n        end",
    "comment": "@private Reset the cached values for platform. This is not considered a public API and should only be used for testing.",
    "label": "",
    "id": "435"
  },
  {
    "raw_code": "def initialize(content_type=\"multipart/mixed\")\n          @content_id = \"#{Time.now.to_i}@#{SecureRandom.alphanumeric(24)}.local\"\n          @boundary = \"Boundary_#{SecureRandom.alphanumeric(24)}\"\n          @content_type = MIME::Types[content_type].first\n          @content = []\n          @headers = {\n            \"Content-ID\"=> \"<#{@content_id}>\",\n            \"Content-Type\"=> \"#{content_type}; boundary=#{@boundary}\",\n          }\n        end",
    "comment": "@param [String] (optional) mime content type @param [String] (optional) mime version",
    "label": "",
    "id": "436"
  },
  {
    "raw_code": "def add(entry)\n          content << entry\n        end",
    "comment": "Add an entry to the multipart mime  @param entry to add",
    "label": "",
    "id": "437"
  },
  {
    "raw_code": "def to_s\n          output_string = \"\"\n          headers.each do |k, v|\n            output_string += \"#{k}: #{v}\\n\"\n          end",
    "comment": "Output MimeEntity as a string  @return [String] mime data",
    "label": "",
    "id": "438"
  },
  {
    "raw_code": "def initialize(content, content_type)\n          if !MIME::Types.include?(content_type)\n            MIME::Types.add(MIME::Type.new(\"content-type\" => content_type))\n          end",
    "comment": "@param [String] entity content @param [String] type of the entity content",
    "label": "",
    "id": "439"
  },
  {
    "raw_code": "def to_s\n          output_string = \"Content-ID: <#{@content_id}>\\n\"\n          output_string += \"Content-Type: #{@content_type}\\n\"\n          if disposition\n            output_string += \"Content-Disposition: #{@disposition}\\n\"\n          end",
    "comment": "Output MimeEntity as a string  @return [String] mime data",
    "label": "",
    "id": "440"
  },
  {
    "raw_code": "def render(*args)\n          render_with(:render, *args)\n        end",
    "comment": "Render a given template and return the result. This method optionally takes a block which will be passed the renderer prior to rendering, which allows the caller to set any view variables within the renderer itself.  @return [String] Rendered template",
    "label": "",
    "id": "441"
  },
  {
    "raw_code": "def render_string(*args)\n          render_with(:render_string, *args)\n        end",
    "comment": "Render a given string and return the result. This method optionally takes a block which will be passed the renderer prior to rendering, which allows the caller to set any view variables within the renderer itself.  @param [String] template The template data string. @return [String] Rendered template",
    "label": "",
    "id": "442"
  },
  {
    "raw_code": "def render_with(method, template, data={})\n          renderer = new(template, data)\n          yield renderer if block_given?\n          renderer.send(method.to_sym)\n        end",
    "comment": "Method used internally to DRY out the other renderers. This method creates and sets up the renderer before calling a specified method on it.",
    "label": "",
    "id": "443"
  },
  {
    "raw_code": "def render\n        old_template = template\n        result = nil\n        File.open(full_template_path, 'r') do |f|\n          self.template = f.read\n          result = render_string\n        end",
    "comment": "Renders the template using the class instance as the binding. Because the renderer inherits from `OpenStruct`, additional view variables can be added like normal accessors.  @return [String]",
    "label": "",
    "id": "444"
  },
  {
    "raw_code": "def render_string\n        binding.eval(Erubi::Engine.new(template, trim: true).src)\n      end",
    "comment": "Renders a template, handling the template as a string, but otherwise acting the same way as {#render}.  @return [String]",
    "label": "",
    "id": "445"
  },
  {
    "raw_code": "def full_template_path\n        @template_root.join(\"#{template}.erb\").to_s.squeeze(\"/\")\n      end",
    "comment": "Returns the full path to the template, taking into account the gem directory and adding the `.erb` extension to the end.  @return [String]",
    "label": "",
    "id": "446"
  },
  {
    "raw_code": "def self.read_until_block(io)\n        data = \"\"\n\n        while true\n          begin\n            if Platform.windows?\n              # Windows doesn't support non-blocking reads on\n              # file descriptors or pipes so we have to get\n              # a bit more creative.\n\n              # Check if data is actually ready on this IO device.\n              # We have to do this since `readpartial` will actually block\n              # until data is available, which can cause blocking forever\n              # in some cases.\n              results = ::IO.select([io], nil, nil, 1.0)\n              break if !results || results[0].empty?\n\n              # Read!\n              data << io.readpartial(READ_CHUNK_SIZE).encode(\n                \"UTF-8\", Encoding.default_external,\n                invalid: :replace,\n                undef: :replace\n              )\n            else\n              # Do a simple non-blocking read on the IO object\n              data << io.read_nonblock(READ_CHUNK_SIZE)\n            end",
    "comment": "Reads data from an IO object while it can, returning the data it reads. When it encounters a case when it can't read anymore, it returns the data.  @return [String]",
    "label": "",
    "id": "447"
  },
  {
    "raw_code": "def keys\n        regexp = /^#\\s*VAGRANT-BEGIN:\\s*(.+?)$\\r?\\n?(.*)$\\r?\\n?^#\\s*VAGRANT-END:\\s(\\1)$/m\n        @value.scan(regexp).map do |match|\n          match[0]\n        end",
    "comment": "This returns the keys (or ids) that are in the string.  @return [<Array<String>]",
    "label": "",
    "id": "448"
  },
  {
    "raw_code": "def delete(key)\n        key    = Regexp.quote(key)\n        regexp = /^#\\s*VAGRANT-BEGIN:\\s*#{key}$.*^#\\s*VAGRANT-END:\\s*#{key}$\\r?\\n?/m\n        @value.gsub!(regexp, \"\")\n      end",
    "comment": "This deletes the block with the given key if it exists.",
    "label": "",
    "id": "449"
  },
  {
    "raw_code": "def get(key)\n        key    = Regexp.quote(key)\n        regexp = /^#\\s*VAGRANT-BEGIN:\\s*#{key}$\\r?\\n?(.*?)\\r?\\n?^#\\s*VAGRANT-END:\\s*#{key}$\\r?\\n?/m\n        match  = regexp.match(@value)\n        return nil if !match\n        match[1]\n      end",
    "comment": "This gets the value of the block with the given key.",
    "label": "",
    "id": "450"
  },
  {
    "raw_code": "def insert(key, value)\n        # Insert the new block into the value\n        new_block = <<BLOCK\n# VAGRANT-BEGIN: #{key}\n#{value.strip}\n# VAGRANT-END: #{key}\nBLOCK\n\n        @value << new_block\n      end",
    "comment": "This inserts a block with the given key and value.  @param [String] key @param [String] value",
    "label": "",
    "id": "451"
  },
  {
    "raw_code": "def self.which(cmd, **opts)\n        exts = nil\n\n        if !Platform.windows? || ENV['PATHEXT'].nil?\n          # If the PATHEXT variable is empty, we're on *nix and need to find\n          # the exact filename\n          exts = ['']\n        elsif File.extname(cmd).length != 0\n          # On Windows: if filename contains an extension, we must match that\n          # exact filename\n          exts = ['']\n        else\n          # On Windows: otherwise try to match all possible executable file\n          # extensions (.EXE .COM .BAT etc.)\n          exts = ENV['PATHEXT'].split(';')\n        end",
    "comment": "Cross-platform way of finding an executable in the PATH.  which('ruby') #=> /usr/bin/ruby  This code is adapted from the following post by mislav: http://stackoverflow.com/questions/2108727/which-in-ruby-checking-if-program-exists-in-path-from-ruby  @param [String] cmd The command to search for in the PATH. @param [Hash] opts Optional flags @option [Boolean] :original_path Search within original path if available @return [String] The full path to the executable or `nil` if not found.",
    "label": "",
    "id": "452"
  },
  {
    "raw_code": "def download!\n        # This variable can contain the proc that'll be sent to\n        # the subprocess execute.\n        data_proc = nil\n\n        extra_subprocess_opts = {}\n        if @ui\n          # If we're outputting progress, then setup the subprocess to\n          # tell us output so we can parse it out.\n          extra_subprocess_opts[:notify] = :stderr\n\n          data_proc = Vagrant::Util::CurlHelper.capture_output_proc(@logger, @ui, @source)\n        end",
    "comment": "This executes the actual download, downloading the source file to the destination with the given options used to initialize this class.  If this method returns without an exception, the download succeeded. An exception will be raised if the download failed.",
    "label": "",
    "id": "453"
  },
  {
    "raw_code": "def head\n        options, subprocess_options = self.options\n        options.unshift(\"-I\")\n        options << @source\n\n        @logger.info(\"HEAD: #{@source}\")\n        result = execute_curl(options, subprocess_options)\n        result.stdout\n      end",
    "comment": "Does a HEAD request of the URL and returns the output.",
    "label": "",
    "id": "454"
  },
  {
    "raw_code": "def validate_download!(source, path, checksums)\n        checksums.each do |type, expected|\n          actual = FileChecksum.new(path, type).checksum\n          @logger.debug(\"Validating checksum (#{type}) for #{source}. \" \\\n            \"expected: #{expected} actual: #{actual}\")\n          if actual.casecmp(expected) != 0\n            raise Errors::DownloaderChecksumError.new(\n              source: source,\n              path: path,\n              type: type,\n              expected_checksum: expected,\n              actual_checksum: actual\n            )\n          end",
    "comment": "Apply any checksum validations based on provided options content  @param source [String] Source of file @param path [String, Pathname] local file path @param checksums [Hash] User provided options @option checksums [String] :md5 Compare MD5 checksum @option checksums [String] :sha1 Compare SHA1 checksum @return [Boolean]",
    "label": "",
    "id": "455"
  },
  {
    "raw_code": "def options\n        # Build the list of parameters to execute with cURL\n        options = [\n          \"--fail\",\n          \"--location\",\n          \"--max-redirs\", \"10\", \"--verbose\",\n          \"--user-agent\", USER_AGENT,\n        ]\n\n        options += [\"--cacert\", @ca_cert] if @ca_cert\n        options += [\"--capath\", @ca_path] if @ca_path\n        options += [\"--continue-at\", \"-\"] if @continue\n        options << \"--insecure\" if @insecure\n        options << \"--cert\" << @client_cert if @client_cert\n        options << \"-u\" << @auth if @auth\n        options << \"--location-trusted\" if @location_trusted\n        options << \"--ssl-revoke-best-effort\" if @ssl_revoke_best_effort\n\n        options.concat(@extra_download_options)\n\n        if @headers\n          Array(@headers).each do |header|\n            options << \"-H\" << header\n          end",
    "comment": "Returns the various cURL and subprocess options.  @return [Array<Array, Hash>]",
    "label": "",
    "id": "456"
  },
  {
    "raw_code": "def self.valid_type?(key)\n        VALID_TYPES.keys.include?(key)\n      end",
    "comment": "Check if provided key is a supported key type  @param [Symbol] key Key type to check @return [Boolean] key type is supported",
    "label": "",
    "id": "457"
  },
  {
    "raw_code": "def self.available_types\n        PREFER_KEY_TYPES.values\n      end",
    "comment": "@return [Array<Symbol>] list of supported key types",
    "label": "",
    "id": "458"
  },
  {
    "raw_code": "def self.create(password=nil, type: :rsa)\n        if !VALID_TYPES.key?(type)\n          raise ArgumentError,\n                \"Invalid key type requested (supported types: #{available_types.map(&:inspect).join(\", \")})\"\n        end",
    "comment": "Create a new keypair  @param [String] password Password for the key or nil for no password (only supported for rsa type) @param [Symbol] type Key type to generate @return [Array<String, String, String>] Public key, openssh private key, openssh public key with comment",
    "label": "",
    "id": "459"
  },
  {
    "raw_code": "def self.string(s)\n          [s.length].pack(\"N\") + s\n        end",
    "comment": "Encodes given string  @param [String] s String to encode @return [String]",
    "label": "",
    "id": "460"
  },
  {
    "raw_code": "def self.padded_string(s, blocksize)\n          pad = blocksize - (s.length % blocksize)\n          string(s + Array(1..pad).pack(\"c*\"))\n        end",
    "comment": "Encodes given string with padding to block size  @param [String] s String to encode @param [Integer] blocksize Defined block size @return [String]",
    "label": "",
    "id": "461"
  },
  {
    "raw_code": "def self.create(password=nil)\n          if password\n            raise NotImplementedError,\n                  \"Ed25519 key pair generation does not support passwords\"\n          end",
    "comment": "Creates an ed25519 SSH key pair @return [Array<String, String, String>] Public key, openssh private key, openssh public key with comment @note Password support was not included as it's not actively used anywhere. If it ends up being something that's needed, it can be revisited",
    "label": "",
    "id": "462"
  },
  {
    "raw_code": "def self.create(password=nil)\n          # This sometimes fails with RSAError. It is inconsistent and strangely\n          # sleeps seem to fix it. We just retry this a few times. See GH-5056\n          rsa_key = nil\n          retryable(on: OpenSSL::PKey::RSAError, sleep: 2, tries: 5) do\n            rsa_key = OpenSSL::PKey::RSA.new(2048)\n          end",
    "comment": "Creates an SSH keypair and returns it.  @param [String] password Password for the key, or nil for no password. @return [Array<String, String, String>] PEM-encoded public and private key, respectively. The final element is the OpenSSH encoded public key.",
    "label": "",
    "id": "463"
  },
  {
    "raw_code": "def self.string(s)\n          [s.length].pack(\"N\") + s\n        end",
    "comment": "Encodes given string  @param [String] s String to encode @return [String]",
    "label": "",
    "id": "464"
  },
  {
    "raw_code": "def self.padded_string(s, blocksize)\n          pad = blocksize - (s.length % blocksize)\n          string(s + Array(1..pad).pack(\"c*\"))\n        end",
    "comment": "Encodes given string with padding to block size  @param [String] s String to encode @param [Integer] blocksize Defined block size @return [String]",
    "label": "",
    "id": "465"
  },
  {
    "raw_code": "def self.create(password=nil)\n          if password\n            raise NotImplementedError,\n                  \"Ecdsa key pair generation does not support passwords\"\n          end",
    "comment": "Creates an ed25519 SSH key pair @return [Array<String, String, String>] Public key, openssh private key, openssh public key with comment @note Password support was not included as it's not actively used anywhere. If it ends up being something that's needed, it can be revisited",
    "label": "",
    "id": "466"
  },
  {
    "raw_code": "def initialize(mutex_path)\n        @mutex_path = mutex_path\n      end",
    "comment": "Create a new FileMutex instance  @param mutex_path [String] path for file",
    "label": "",
    "id": "467"
  },
  {
    "raw_code": "def with_lock(&block)\n        lock\n        begin\n          block.call\n        rescue => e\n          raise e\n        ensure\n          unlock\n        end",
    "comment": "Execute provided block within lock and unlock when completed",
    "label": "",
    "id": "468"
  },
  {
    "raw_code": "def lock\n        if lock_file.flock(File::LOCK_EX|File::LOCK_NB) === false\n          raise Errors::VagrantLocked, lock_file_path: @mutex_path\n        end",
    "comment": "Attempt to acquire the lock",
    "label": "",
    "id": "469"
  },
  {
    "raw_code": "def unlock\n        lock_file.flock(File::LOCK_UN)\n        lock_file.close\n        File.delete(@mutex_path) if File.file?(@mutex_path)\n      end",
    "comment": "Unlock the file",
    "label": "",
    "id": "470"
  },
  {
    "raw_code": "def initialize(destination, file, options=nil)\n        options ||= {}\n        @logger         = Log4r::Logger.new(\"vagrant::util::uploader\")\n        @destination    = destination.to_s\n        @file           = file.to_s\n        @ui             = options[:ui]\n        @request_method = options[:method]\n\n        if !@request_method\n          @request_method = \"PUT\"\n        end",
    "comment": "@param [String] destination Valid URL to upload file to @param [String] file Location of file to upload on disk @param [Hash] options @option options [Vagrant::UI] :ui UI interface for output @option options [String, Symbol] :method Request method for upload",
    "label": "",
    "id": "471"
  },
  {
    "raw_code": "def present?(obj)\n        case obj\n        when String\n          !obj.strip.empty?\n        when Symbol\n          !obj.to_s.strip.empty?\n        when Array\n          !obj.compact.empty?\n        when Hash\n          !obj.empty?\n        when TrueClass, FalseClass\n          obj\n        when NilClass\n          false\n        when Object\n          true\n        end",
    "comment": "Determines if the given object is \"present\". A String is considered present if the stripped contents are not empty. An Array/Hash is considered present if they have a length of more than 1. \"true\" is always present and `false` and `nil` are always not present. Any other object is considered to be present.  @return [true, false]",
    "label": "",
    "id": "472"
  },
  {
    "raw_code": "def presence(obj)\n        if present?(obj)\n          obj\n        else\n          false\n        end",
    "comment": "Returns the presence of the object. If the object is {present?}, it is returned. Otherwise `false` is returned.  @return [Object, false]",
    "label": "",
    "id": "473"
  },
  {
    "raw_code": "def self.longname(name)\n        # We loop over the API call in case we didn't allocate enough\n        # buffer space. In general it is usually enough.\n        bufferlen = 250\n        buffer    = nil\n        while true\n          buffer = ' ' * bufferlen\n          len    = API.GetLongPathNameA(name.to_s, buffer, buffer.size)\n          if bufferlen < len\n            # If the length returned is larger than our buffer length,\n            # it is the API telling us it needs more space. Allocate it\n            # and retry.\n            bufferlen = len\n            continue\n          end",
    "comment": "Converts a Windows shortname to a long name. This only works for ASCII paths currently and doesn't use the wide character support.",
    "label": "",
    "id": "474"
  },
  {
    "raw_code": "def enabled?\n          if !defined?(@_experimental)\n            experimental = features_requested\n            if experimental.size >= 1 && experimental.first != \"0\"\n              @_experimental = true\n            else\n              @_experimental = false\n            end",
    "comment": "A method for determining if the experimental flag has been enabled with any features  @return [Boolean]",
    "label": "",
    "id": "475"
  },
  {
    "raw_code": "def global_enabled?\n          if !defined?(@_global_enabled)\n            experimental = features_requested\n            if experimental.size == 1 && experimental.first == \"1\"\n              @_global_enabled = true\n            else\n              @_global_enabled = false\n            end",
    "comment": "A method for determining if all experimental features have been enabled by either a global enabled value \"1\" or all features explicitly enabled.  @return [Boolean]",
    "label": "",
    "id": "476"
  },
  {
    "raw_code": "def feature_enabled?(feature)\n          experimental = features_requested\n          feature = feature.to_s\n\n          return global_enabled? || experimental.include?(feature)\n        end",
    "comment": "A method for Vagrant internals to determine if a given feature has been abled by the user, is a valid feature flag and can be used.  @param [String] feature @return [Boolean] - A hash containing the original array and if it is valid",
    "label": "",
    "id": "477"
  },
  {
    "raw_code": "def features_requested\n          if !defined?(@_requested_features)\n            @_requested_features = ENV[\"VAGRANT_EXPERIMENTAL\"].to_s.downcase.split(',')\n          end",
    "comment": "Returns the features requested for the experimental flag  @return [Array] - Returns an array of requested experimental features",
    "label": "",
    "id": "478"
  },
  {
    "raw_code": "def guard_with(*features, &block)\n          yield if block_given? && features.any? {|f| feature_enabled?(f)}\n        end",
    "comment": "A function to guard experimental blocks of code from being executed  @param [Array] features - Array of features to guard a method with @param [Block] block - Block of ruby code to be guarded against",
    "label": "",
    "id": "479"
  },
  {
    "raw_code": "def reset!\n          instance_variables.each(&method(:remove_instance_variable))\n        end",
    "comment": "@private Reset the cached values for platform. This is not considered a public API and should only be used for testing.",
    "label": "",
    "id": "480"
  },
  {
    "raw_code": "def self.map_to_command_options(map, cmd_flag=\"--\")\n        opt_list = []\n        if map == nil\n          return opt_list\n        end",
    "comment": "Given a hash map of user specified argments, will generate a list. Set the key to the command flag, and the value to it's value. If the value is boolean (true), only the flag is added. eg. {a: \"opt-a\", b: true} -> [\"--a\", \"opt-a\", \"--b\"]  @param [Hash]   map of commands @param [String] string prepended to cmd line flags (keys)  @return[Array<String>] commands in list form",
    "label": "",
    "id": "481"
  },
  {
    "raw_code": "def architecture\n          if !defined?(@_host_architecture)\n            if ENV[\"VAGRANT_HOST_ARCHITECTURE\"].to_s != \"\"\n              return @_host_architecture = ENV[\"VAGRANT_HOST_ARCHITECTURE\"]\n            end",
    "comment": "Detect architecture of host system  @return [String]",
    "label": "",
    "id": "482"
  },
  {
    "raw_code": "def windows_admin?\n          return @_windows_admin if defined?(@_windows_admin)\n\n          @_windows_admin = -> {\n            ps_cmd = '(new-object System.Security.Principal.WindowsPrincipal([System.Security.Principal.WindowsIdentity]::GetCurrent())).IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)'\n            output = Vagrant::Util::PowerShell.execute_cmd(ps_cmd)\n            return output == 'True'\n          }.call\n\n          return @_windows_admin\n        end",
    "comment": "Checks if the user running Vagrant on Windows has administrative privileges.  From: https://support.microsoft.com/en-us/kb/243330 SID: S-1-5-19  @return [Boolean]",
    "label": "",
    "id": "483"
  },
  {
    "raw_code": "def windows_hyperv_admin?\n          return @_windows_hyperv_admin if defined?(@_windows_hyperv_admin)\n\n          if ENV[\"VAGRANT_IS_HYPERV_ADMIN\"]\n            return @_windows_hyperv_admin = true\n          end",
    "comment": "Checks if Hyper-V is accessible to the local user. It will check if user is in the \"Hyper-V Administrators\" group, is a Domain administrator, and finally will run a manual interaction with Hyper-V to determine if Hyper-V is usable for the current user.  From: https://support.microsoft.com/en-us/kb/243330 SID: S-1-5-32-578 Name: BUILTIN\\Hyper-V Administrators SID: S-1-5-21DOMAIN-512 Name: Domain Admins  @return [Boolean]",
    "label": "",
    "id": "484"
  },
  {
    "raw_code": "def windows_hyperv_enabled?\n          return @_windows_hyperv_enabled if defined?(@_windows_hyperv_enabled)\n\n          @_windows_hyperv_enabled = -> {\n            check_commands = Array.new.tap do |c|\n              c << \"(Get-WindowsOptionalFeature -FeatureName Microsoft-Hyper-V-Hypervisor -Online).State\"\n              c << \"(Get-WindowsFeature -FeatureName Microsoft-Hyper-V-Hypervisor).State\"\n            end",
    "comment": "Checks if Hyper-V is enabled on the host system and returns true if enabled.  @return [Boolean]",
    "label": "",
    "id": "485"
  },
  {
    "raw_code": "def cygwin_path(path)\n          begin\n            cygpath = Vagrant::Util::Which.which(\"cygpath\")\n            if cygpath.nil?\n              # If Which can't find it, just attempt to invoke it directly\n              cygpath = \"cygpath\"\n            else\n              cygpath.gsub!(\"/\", '\\\\')\n            end",
    "comment": "This takes any path and converts it from a Windows path to a Cygwin style path.  @param [String] path @return [String]",
    "label": "",
    "id": "486"
  },
  {
    "raw_code": "def msys_path(path)\n          begin\n            # We have to revert to the old env\n            # path here, otherwise it looks like\n            # msys2 ends up using the wrong cygpath\n            # binary and ends up with a `/cygdrive`\n            # when it doesn't exist in msys2\n            original_path_env = ENV['PATH']\n            ENV['PATH'] = ENV['VAGRANT_OLD_ENV_PATH']\n            cygwin_path(path)\n          ensure\n            ENV['PATH'] = original_path_env\n          end",
    "comment": "This takes any path and converts it from a Windows path to a msys style path.  @param [String] path @return [String]",
    "label": "",
    "id": "487"
  },
  {
    "raw_code": "def cygwin_windows_path(path)\n          return path if !cygwin?\n\n          # Replace all \"\\\" with \"/\", otherwise cygpath doesn't work.\n          path = unix_windows_path(path)\n\n          # Call out to cygpath and gather the result\n          process = Subprocess.execute(\"cygpath\", \"-w\", \"-l\", \"-a\", path.to_s)\n          return process.stdout.chomp\n        end",
    "comment": "This takes any path and converts it to a full-length Windows path on Windows machines in Cygwin.  @return [String]",
    "label": "",
    "id": "488"
  },
  {
    "raw_code": "def unix_windows_path(path)\n          path.gsub(\"\\\\\", \"/\")\n        end",
    "comment": "This takes any path and converts Windows-style path separators to Unix-like path separators. @return [String]",
    "label": "",
    "id": "489"
  },
  {
    "raw_code": "def fs_case_sensitive?\n          return @_fs_case_sensitive if defined?(@_fs_case_sensitive)\n          @_fs_case_sensitive = Dir.mktmpdir(\"vagrant-fs-case-sensitive\") do |dir|\n            tmp_file = File.join(dir, \"FILE\")\n            File.open(tmp_file, \"w\") do |f|\n              f.write(\"foo\")\n            end",
    "comment": "This checks if the filesystem is case sensitive. This is not a 100% correct check, since it is possible that the temporary directory runs a different filesystem than the root directory. However, this works in many cases.",
    "label": "",
    "id": "490"
  },
  {
    "raw_code": "def fs_real_path(path, **opts)\n          path = Pathname.new(File.expand_path(path))\n\n          if path.exist? && !fs_case_sensitive?\n            # If the path contains a Windows short path, then we attempt to\n            # expand. The require below is embedded here since it requires\n            # windows to work.\n            if windows? && path.to_s =~ /~\\d(\\/|\\\\)/\n              require_relative \"windows_path\"\n              path = Pathname.new(WindowsPath.longname(path.to_s))\n            end",
    "comment": "This expands the path and ensures proper casing of each part of the path.",
    "label": "",
    "id": "491"
  },
  {
    "raw_code": "def windows_unc_path(path)\n          path = path.gsub(\"/\", \"\\\\\")\n\n          # Convert to UNC path\n          if path =~ /^[a-zA-Z]:\\\\?$/\n            # If the path is just a drive letter, then return that as-is\n            path + \"\\\\\"\n          elsif path.start_with?(\"\\\\\\\\\")\n            # If the path already starts with `\\\\` assume UNC and return as-is\n            path\n          else\n            \"\\\\\\\\?\\\\\" + path.gsub(\"/\", \"\\\\\")\n          end",
    "comment": "Converts a given path to UNC format by adding a prefix and converting slashes. @param [String] path Path to convert to UNC for Windows @return [String]",
    "label": "",
    "id": "492"
  },
  {
    "raw_code": "def terminal_supports_colors?\n          return @_terminal_supports_colors if defined?(@_terminal_supports_colors)\n          @_terminal_supports_colors = -> {\n            if windows?\n              return true if ENV.key?(\"ANSICON\")\n              return true if cygwin?\n              return true if ENV[\"TERM\"] == \"cygwin\"\n              return false\n            end",
    "comment": "Returns a boolean noting whether the terminal supports color. output.",
    "label": "",
    "id": "493"
  },
  {
    "raw_code": "def wsl_path?(path)\n          wsl? && !path.to_s.downcase.start_with?(\"/mnt/\")\n        end",
    "comment": "Determine if given path is within the WSL rootfs. Returns true if within the subsystem, or false if outside the subsystem.  @param [String] path Path to check @return [Boolean] path is within subsystem",
    "label": "",
    "id": "494"
  },
  {
    "raw_code": "def wsl_rootfs\n          return @_wsl_rootfs if defined?(@_wsl_rootfs)\n\n          if wsl?\n            # Mark our filesystem with a temporary file having an unique name.\n            marker = Tempfile.new(Time.now.to_i.to_s)\n            logger = Log4r::Logger.new(\"vagrant::util::platform::wsl\")\n\n            # Check for lxrun installation first\n            lxrun_path = [wsl_windows_appdata_local, \"lxss\"].join(\"\\\\\")\n            paths = [lxrun_path]\n\n            logger.debug(\"checking registry for WSL installation path\")\n            paths += PowerShell.execute_cmd(\n              '(Get-ChildItem HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Lxss ' \\\n                '| ForEach-Object {Get-ItemProperty $_.PSPath}).BasePath').to_s.split(\"\\r\\n\").map(&:strip)\n            paths.delete_if{|path| path.to_s.empty?}\n\n            paths.each do |path|\n              # Lowercase the drive letter, skip the next symbol (which is a\n              # colon from a Windows path) and convert path to UNIX style.\n              check_path = \"/mnt/#{path[0, 1].downcase}#{path[2..-1].tr('\\\\', '/')}/rootfs\"\n              begin\n                process = Subprocess.execute(\"wslpath\", \"-u\", \"-a\", path)\n                check_path = \"#{process.stdout.chomp}/rootfs\" if process.exit_code == 0\n              rescue Errors::CommandUnavailable => e\n                # pass\n              end",
    "comment": "Compute the path to rootfs of currently active WSL.  @return [String] A path to rootfs of a current WSL instance.",
    "label": "",
    "id": "495"
  },
  {
    "raw_code": "def wsl_to_windows_path(path)\n          path = path.to_s\n          if wsl? && wsl_windows_access? && !path.match(/^[a-zA-Z]:/)\n            path = File.expand_path(path)\n            begin\n              process = Subprocess.execute(\"wslpath\", \"-w\", \"-a\", path)\n              return process.stdout.chomp if process.exit_code == 0\n            rescue Errors::CommandUnavailable => e\n              # pass\n            end",
    "comment": "Convert a WSL path to the local Windows path. This is useful for conversion when calling out to Windows executables from the WSL  @param [String, Pathname] path Path to convert @return [String]",
    "label": "",
    "id": "496"
  },
  {
    "raw_code": "def format_windows_path(path, *args)\n          path = cygwin_path(path) if cygwin?\n          path = msys_path(path) if msys?\n          path = wsl_to_windows_path(path) if wsl?\n          if windows? || wsl?\n            path = windows_unc_path(path) if !args.include?(:disable_unc)\n          end",
    "comment": "Takes a windows path and formats it to the 'unix' style (i.e. `/cygdrive/c` or `/c/`)  @param [Pathname, String] path Path to convert @param [Hash] hash of arguments @return [String]",
    "label": "",
    "id": "497"
  },
  {
    "raw_code": "def windows_path(path)\n          path = cygwin_windows_path(path)\n          path = wsl_to_windows_path(path)\n          if windows? || wsl?\n            path = windows_unc_path(path)\n          end",
    "comment": "Automatically convert a given path to a Windows path. Will only be applied if running on a Windows host. If running on Windows host within the WSL, the actual Windows path will be returned.  @param [Pathname, String] path Path to convert @return [String]",
    "label": "",
    "id": "498"
  },
  {
    "raw_code": "def wsl_windows_access?\n          if !defined?(@_wsl_windows_access)\n            @_wsl_windows_access = wsl? && ENV[\"VAGRANT_WSL_ENABLE_WINDOWS_ACCESS\"]\n          end",
    "comment": "Allow Vagrant to access Vagrant managed machines outside the Windows Subsystem for Linux  @return [Boolean]",
    "label": "",
    "id": "499"
  },
  {
    "raw_code": "def wsl_windows_accessible_path\n          if !defined?(@_wsl_windows_accessible_path)\n            access_path = ENV[\"VAGRANT_WSL_WINDOWS_ACCESS_USER_HOME_PATH\"]\n            if access_path.to_s.empty?\n              begin\n                process = Subprocess.execute(\"wslpath\", \"-u\", \"-a\", wsl_windows_home)\n                access_path = process.stdout.chomp if process.exit_code == 0\n              rescue Errors::CommandUnavailable => e\n                # pass\n              end",
    "comment": "The allowed windows system path Vagrant can manage from the Windows Subsystem for Linux  @return [Pathname]",
    "label": "",
    "id": "500"
  },
  {
    "raw_code": "def wsl_windows_access_bypass?(path)\n          wsl? && wsl_windows_access? &&\n            path.to_s.start_with?(wsl_windows_accessible_path.to_s)\n        end",
    "comment": "Checks given path to determine if Vagrant is allowed to bypass checks  @param [String] path Path to check @return [Boolean] Vagrant is allowed to bypass checks",
    "label": "",
    "id": "501"
  },
  {
    "raw_code": "def wsl_drvfs_mounts\n          if !defined?(@_wsl_drvfs_mounts)\n            @_wsl_drvfs_mounts = []\n            if wsl?\n              result = Util::Subprocess.execute(\"mount\")\n              result.stdout.each_line do |line|\n                info = line.match(MOUNT_PATTERN)\n                if info && (info[:type] == \"drvfs\" || info[:type] == \"9p\")\n                  @_wsl_drvfs_mounts << info[:mount]\n                end",
    "comment": "Get list of local mount paths that are DrvFs file systems  @return [Array<String>] @todo(chrisroberts): Constantize types for check",
    "label": "",
    "id": "502"
  },
  {
    "raw_code": "def wsl_drvfs_path?(path)\n          if wsl?\n            wsl_drvfs_mounts.each do |mount_path|\n              return true if path.to_s.start_with?(mount_path)\n            end",
    "comment": "Check if given path is located on DrvFs file system  @param [String, Pathname] path Path to check @return [Boolean]",
    "label": "",
    "id": "503"
  },
  {
    "raw_code": "def wsl_init(env, logger=nil)\n          if wsl?\n            if ENV[\"VAGRANT_WSL_ENABLE_WINDOWS_ACCESS\"]\n              wsl_validate_matching_vagrant_versions!\n              shared_user = ENV[\"VAGRANT_WSL_WINDOWS_ACCESS_USER\"]\n              if shared_user.to_s.empty?\n                shared_user = wsl_windows_username\n              end",
    "comment": "If running within the Windows Subsystem for Linux, this will provide simple setup to allow sharing of the user's VAGRANT_HOME directory within the subsystem  @param [Environment] env @param [Logger] logger Optional logger to display information",
    "label": "",
    "id": "504"
  },
  {
    "raw_code": "def wsl_windows_username\n          if !@_wsl_windows_username\n            result = Util::Subprocess.execute(\"cmd.exe\", \"/c\", \"echo %USERNAME%\")\n            if result.exit_code == 0\n              @_wsl_windows_username = result.stdout.strip\n            end",
    "comment": "Fetch the Windows username currently in use  @return [String, Nil]",
    "label": "",
    "id": "505"
  },
  {
    "raw_code": "def wsl_windows_home\n          if !@_wsl_windows_home\n            result = Util::Subprocess.execute(\"cmd.exe\", \"/c\" \"echo %USERPROFILE%\")\n            if result.exit_code == 0\n              @_wsl_windows_home = result.stdout.gsub(\"\\\"\", \"\").strip\n            end",
    "comment": "Fetch the Windows user home directory  @return [String, Nil]",
    "label": "",
    "id": "506"
  },
  {
    "raw_code": "def wsl_windows_appdata_local\n          if !@_wsl_windows_appdata_local\n            result = Util::Subprocess.execute(\"cmd.exe\", \"/c\", \"echo %LOCALAPPDATA%\")\n            if result.exit_code == 0\n              @_wsl_windows_appdata_local = result.stdout.gsub(\"\\\"\", \"\").strip\n            end",
    "comment": "Fetch the Windows user local app data directory  @return [String, Nil]",
    "label": "",
    "id": "507"
  },
  {
    "raw_code": "def wsl_validate_matching_vagrant_versions!\n          valid = false\n          if Util::Which.which(\"vagrant.exe\")\n            result = Util::Subprocess.execute(\"vagrant.exe\", \"--version\")\n            if result.exit_code == 0\n              windows_version = result.stdout.match(/Vagrant (?<version>[\\w.-]+)/)\n              if windows_version\n                windows_version = windows_version[:version].strip\n                valid = windows_version == Vagrant::VERSION\n              end",
    "comment": "Confirm Vagrant versions installed within the WSL and the Windows system are the same. Raise error if they do not match.",
    "label": "",
    "id": "508"
  },
  {
    "raw_code": "def systemd?\n          if !defined?(@_systemd)\n            if !windows?\n              result = Vagrant::Util::Subprocess.execute(\"ps\", \"-o\", \"comm=\", \"1\")\n              @_systemd = result.stdout.chomp == \"systemd\"\n            else\n              @_systemd = false\n            end",
    "comment": "systemd is in use",
    "label": "",
    "id": "509"
  },
  {
    "raw_code": "def reset!\n          instance_variables.each(&method(:remove_instance_variable))\n        end",
    "comment": "@private Reset the cached values for platform. This is not considered a public API and should only be used for testing.",
    "label": "",
    "id": "510"
  },
  {
    "raw_code": "def self.scrub(string)\n        string = url_scrubber(string)\n      end",
    "comment": "Attempt to remove detected credentials from string  @param [String] string @return [String]",
    "label": "",
    "id": "511"
  },
  {
    "raw_code": "def self.url_scrubber(string)\n        string.gsub(%r{(ftp|https?)://[^\\s]+@[^\\s]+}) do |address|\n          uri = URI.parse(address)\n          uri.user = uri.password = REPLACEMENT_TEXT\n          uri.to_s\n        end",
    "comment": "Detect URLs and remove any embedded credentials  @param [String] string @return [String]",
    "label": "",
    "id": "512"
  },
  {
    "raw_code": "def self.desensitize(string)\n        string = string.to_s.dup\n        sensitive_strings.each do |remove|\n          string.gsub!(/(\\W|^)#{Regexp.escape(remove)}(\\W|$)/, \"\\\\1#{REPLACEMENT_TEXT}\\\\2\")\n        end",
    "comment": "Remove sensitive information from string  @param [String] string @return [String]",
    "label": "",
    "id": "513"
  },
  {
    "raw_code": "def self.sensitive(string)\n        string = string.to_s.dup\n        if string.length > 0\n          sensitive_strings.push(string).uniq!\n        end",
    "comment": "Register a sensitive string to be scrubbed",
    "label": "",
    "id": "514"
  },
  {
    "raw_code": "def self.unsensitive(string)\n        sensitive_strings.delete(string)\n        nil\n      end",
    "comment": "Deregister a sensitive string and allow output",
    "label": "",
    "id": "515"
  },
  {
    "raw_code": "def self.sensitive_strings\n        if !defined?(@_sensitive_strings)\n          @_sensitive_strings = []\n        end",
    "comment": "@return [Array<string>]",
    "label": "",
    "id": "516"
  },
  {
    "raw_code": "def self.reset!\n        instance_variables.each(&method(:remove_instance_variable))\n      end",
    "comment": "@private Reset the cached values for scrubber. This is not considered a public API and should only be used for testing.",
    "label": "",
    "id": "517"
  },
  {
    "raw_code": "def get_current_devices(comm)\n          {}.tap do |cd|\n            comm.execute(\"nmcli -t c show\") do |type, data|\n              if type == :stdout\n                data.strip.lines.map(&:chomp).each do |line|\n                  next if line.strip.empty?\n                  _, id, _, dev = line.strip.split(':')\n                  cd[dev] = id\n                end",
    "comment": "Get all network devices currently managed by NetworkManager. @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @return [Hash] A hash of current device names and their associated IDs.",
    "label": "",
    "id": "518"
  },
  {
    "raw_code": "def self.silence!\n        original = $VERBOSE\n        $VERBOSE = nil\n        return yield\n      ensure\n        $VERBOSE = original\n      end",
    "comment": "This silences any Ruby warnings.",
    "label": "",
    "id": "519"
  },
  {
    "raw_code": "def network_address(ip, subnet)\n        begin\n          IPAddr.new(ip).mask(subnet).to_s\n        rescue IPAddr::InvalidPrefixError\n          LOGGER.warn(\"Provided mask '#{subnet}' is invalid. Falling back to using mask '#{DEFAULT_MASK}'\")\n          IPAddr.new(ip).mask(DEFAULT_MASK).to_s\n        end",
    "comment": "Returns the network address of the given IP and subnet.  @return [String]",
    "label": "",
    "id": "520"
  },
  {
    "raw_code": "def proc_stack\n        @_proc_stack ||= []\n      end",
    "comment": "Returns the proc stack. This should always be called as the accessor of the stack. The instance variable itself should _never_ be used.  @return [Array<Proc>]",
    "label": "",
    "id": "521"
  },
  {
    "raw_code": "def push_proc(&block)\n        proc_stack << block\n      end",
    "comment": "Adds (pushes) a proc to the stack. The actual proc added here is not executed, but merely stored.  @param [Proc] block",
    "label": "",
    "id": "522"
  },
  {
    "raw_code": "def run_procs!(*args)\n        proc_stack.each do |proc|\n          proc.call(*args)\n        end",
    "comment": "Executes all the procs on the stack, passing in the given arguments. The stack is not cleared afterwards. It is up to the user of this mixin to clear the stack by calling `proc_stack.clear`.",
    "label": "",
    "id": "523"
  },
  {
    "raw_code": "def self.safe_chdir(dir)\n        lock = @@chdir_lock\n\n        begin\n          @@chdir_lock.synchronize {}\n        rescue ThreadError\n          # If we already hold the lock, just create a new lock so we\n          # definitely don't block and don't get an error.\n          lock = Mutex.new\n        end",
    "comment": "Safely changes directory of this process by putting a lock around it so that it is thread safe. This will yield a block and when the block exits it changes back to the original directory.  @param [String] dir Dir to change to temporarily",
    "label": "",
    "id": "524"
  },
  {
    "raw_code": "def initialize(formatter)\n        @formatter = formatter\n      end",
    "comment": "Creates a new formatter wrapper instance.  @param [Log4r::Formatter]",
    "label": "",
    "id": "525"
  },
  {
    "raw_code": "def format(event)\n        msg = formatter.format(event)\n        CredentialScrubber.desensitize(msg)\n      end",
    "comment": "Format event and scrub output",
    "label": "",
    "id": "526"
  },
  {
    "raw_code": "def setup(env)\n        begin\n          require \"checkpoint\"\n          @enabled = true\n        rescue LoadError\n          @logger.warn(\"checkpoint library not found. disabling.\")\n        end",
    "comment": "Setup will attempt to load the checkpoint library and define required paths  @param [Vagrant::Environment] env @return [self]",
    "label": "",
    "id": "527"
  },
  {
    "raw_code": "def complete?\n        !@checkpoint_thread.nil? && !@checkpoint_thread.alive?\n      end",
    "comment": "Check has completed",
    "label": "",
    "id": "528"
  },
  {
    "raw_code": "def result\n        if !enabled || @checkpoint_thread.nil?\n          nil\n        elsif !defined?(@result)\n          @checkpoint_thread.join(CHECKPOINT_TIMEOUT)\n          @result = @checkpoint_thread[:result]\n        else\n          @result\n        end",
    "comment": "Result of check  @return [Hash, nil]",
    "label": "",
    "id": "529"
  },
  {
    "raw_code": "def check\n        if enabled && @checkpoint_thread.nil?\n          logger.debug(\"starting plugin check\")\n          @checkpoint_thread = Thread.new do\n            Thread.current.abort_on_exception = false\n            if Thread.current.respond_to?(:report_on_exception=)\n              Thread.current.report_on_exception = false\n            end",
    "comment": "Run check  @return [self]",
    "label": "",
    "id": "530"
  },
  {
    "raw_code": "def display\n        if !defined?(@displayed)\n          if !complete?\n            @logger.debug(\"waiting for checkpoint to complete...\")\n          end",
    "comment": "Display any alerts or version update information  @return [boolean] true if displayed, false if not",
    "label": "",
    "id": "531"
  },
  {
    "raw_code": "def reset!\n        logger = @logger\n        instance_variables.each(&method(:remove_instance_variable))\n        @logger = logger\n        @enabled = false\n      end",
    "comment": "@private Reset the cached values for platform. This is not considered a public API and should only be used for testing.",
    "label": "",
    "id": "532"
  },
  {
    "raw_code": "def retryable(opts=nil)\n        logger = nil\n        opts   = { tries: 1, on: Exception }.merge(opts || {})\n\n        begin\n          return yield\n        rescue *opts[:on] => e\n          if (opts[:tries] -= 1) > 0\n            logger = Log4r::Logger.new(\"vagrant::util::retryable\")\n            logger.info(\"Retryable exception raised: #{e.inspect}\")\n\n            sleep opts[:sleep].to_f if opts[:sleep]\n            retry\n          end",
    "comment": "Retries a given block a specified number of times in the event the specified exception is raised. If the retries run out, the final exception is raised.  This code is adapted slightly from the following blog post: http://blog.codefront.net/2008/01/14/retrying-code-blocks-in-ruby-on-exceptions-whatever/",
    "label": "",
    "id": "533"
  },
  {
    "raw_code": "def self.check_key_permissions(key_path)\n        # Don't do anything if we're on Windows, since Windows doesn't worry\n        # about key permissions.\n        return if Platform.windows? || Platform.wsl_windows_access_bypass?(key_path)\n\n        LOGGER.debug(\"Checking key permissions: #{key_path}\")\n        stat = key_path.stat\n\n        if !stat.owned? && Process.uid != 0\n          # The SSH key must be owned by ourselves, unless we're root\n          raise Errors::SSHKeyBadOwner, key_path: key_path\n        end",
    "comment": "Checks that the permissions for a private key are valid, and fixes them if possible. SSH requires that permissions on the private key are 0600 on POSIX based systems. This will make a best effort to fix these permissions if they are not properly set.  @param [Pathname] key_path The path to the private key.",
    "label": "",
    "id": "534"
  },
  {
    "raw_code": "def self.exec(ssh_info, opts={})\n        # Ensure the platform supports ssh. On Windows there are several programs which\n        # include ssh, notably git, mingw and cygwin, but make sure ssh is in the path!\n\n        # First try using the original path provided\n        if ENV[\"VAGRANT_PREFER_SYSTEM_BIN\"] != \"0\"\n          ssh_path = Which.which(\"ssh\", original_path: true)\n        end",
    "comment": "Halts the running of this process and replaces it with a full-fledged SSH shell into a remote machine.  Note: This method NEVER returns. The process ends after this.  @param [Hash] ssh_info This is the SSH information. For the keys required please see the documentation of {Machine#ssh_info}. @param [Hash] opts These are additional options that are supported by exec.",
    "label": "",
    "id": "535"
  },
  {
    "raw_code": "def safe_puts(message=nil, opts=nil)\n        message ||= \"\"\n        opts = {\n          io: $stdout,\n          printer: :puts\n        }.merge(opts || {})\n\n        begin\n          opts[:io].send(opts[:printer], message)\n        rescue Errno::EPIPE\n          # This is what makes this a `safe` puts.\n          return\n        end",
    "comment": "Uses `puts` on the given IO object and safely ignores any Errno::EPIPE.  @param [String] message Message to output. @param [Hash] opts Options hash.",
    "label": "",
    "id": "536"
  },
  {
    "raw_code": "def self.deep_merge(myself, other_hash, &block)\n        myself = myself.dup\n        other_hash.each_pair do |k,v|\n          tv = myself[k]\n          if tv.is_a?(Hash) && v.is_a?(Hash)\n            myself[k] = deep_merge(tv, v, &block)\n          else\n            myself[k] = block && tv ? block.call(k, tv, v) : v\n          end",
    "comment": "This was lifted straight from Rails 4.0.2 as a basic Hash deep merge.",
    "label": "",
    "id": "537"
  },
  {
    "raw_code": "def dos_to_unix(string)\n        string.gsub(\"\\r\\n\", \"\\n\")\n      end",
    "comment": "Converts line endings to unix-style line endings in the given string.  @param [String] string Original string @return [String] The fixed string",
    "label": "",
    "id": "538"
  },
  {
    "raw_code": "def self.change_env\n        yield ENV\n      rescue Errno::EINVAL\n        raise Errors::EnvInval\n      end",
    "comment": "This yields an environment hash to change and catches any issues while changing the environment variables and raises a helpful error to end users.",
    "label": "",
    "id": "539"
  },
  {
    "raw_code": "def deprecation_command_name\n        name_parts = self.class.name.split(\"::\")\n        [\n          name_parts[1].sub('Command', ''),\n          name_parts[3]\n        ].compact.map(&:downcase).join(\" \")\n      end",
    "comment": "@return [String] generated name of command",
    "label": "",
    "id": "540"
  },
  {
    "raw_code": "def build_iso(iso_command, source_directory, file_destination)\n          FileUtils.mkdir_p(file_destination.dirname)\n          if !file_destination.exist? || Vagrant::Util::Directory.directory_changed?(source_directory, file_destination.mtime)\n            result = Vagrant::Util::Subprocess.execute(*iso_command)\n            if result.exit_code != 0\n              raise Vagrant::Errors::ISOBuildFailed, cmd: iso_command.join(\" \"), stdout: result.stdout, stderr: result.stderr\n            end",
    "comment": "Builds an iso given a compatible iso_command  @param [List<String>] command to build iso @param [Pathname] input directory for iso build @param [Pathname] output file for iso build",
    "label": "",
    "id": "541"
  },
  {
    "raw_code": "def shell_installed(home)\n        @logger.info(\"Searching for config in home #{home}\")\n        @config_paths.each do |path|\n          config_file = File.join(home, path)\n          if File.exist?(config_file)\n            @logger.info(\"Found config file #{config_file}\")\n            return config_file\n          end",
    "comment": "Searches a users home dir for a shell config file based on a given home dir and a configured set of config paths. If there are multiple config paths, it will return the first match.  @param [string] path to users home dir @return [string] path to shell config file if exists",
    "label": "",
    "id": "542"
  },
  {
    "raw_code": "def is_installed(path)\n        File.foreach(path) do |line|\n          if line.include?(@prepend_string)\n            @logger.info(\"Found completion already installed in #{path}\")\n            return true\n          end",
    "comment": "Searches a given file for the existence of a set prepend string. This can be used to find if vagrant has inserted some strings to a file  @param [string] path to a file (config file) @return [boolean] true if the prepend string is found in the file",
    "label": "",
    "id": "543"
  },
  {
    "raw_code": "def install(home)\n        path = shell_installed(home)\n        if path && !is_installed(path)\n          File.open(path, \"a\") do |f|\n            f.write(\"\\n\")\n            f.write(@prepend_string)\n            f.write(\"\\n\")\n            f.write(@string_insert)\n            f.write(\"\\n\")\n            f.write(@append_string)\n            f.write(\"\\n\")\n          end",
    "comment": "Given a path to the users home dir, will install some given strings marked by a prepend and append string  @param [string] path to users home dir @return [string] path to shell config file that was modified if exists",
    "label": "",
    "id": "544"
  },
  {
    "raw_code": "def systemd?(comm)\n          comm.test(\"ps -o comm= 1 | grep systemd\", sudo: true)\n        end",
    "comment": "systemd helpers systemd is in use  @return [Boolean]",
    "label": "",
    "id": "545"
  },
  {
    "raw_code": "def systemd_networkd?(comm)\n          comm.test(\"systemctl -q is-active systemd-networkd.service\", sudo: true)\n        end",
    "comment": "systemd-networkd.service is in use  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @return [Boolean]",
    "label": "",
    "id": "546"
  },
  {
    "raw_code": "def systemd_network_manager?(comm)\n          comm.test(\"systemctl -q is-active NetworkManager.service\", sudo: true)\n        end",
    "comment": "NetworkManager.service is in use  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @return [Boolean]",
    "label": "",
    "id": "547"
  },
  {
    "raw_code": "def systemd_unit_file?(comm, name)\n          comm.test(\"systemctl -q list-unit-files | grep \\\"#{name}\\\"\")\n        end",
    "comment": "Check if a unit file with the given name is defined. Name can be a pattern or explicit name.  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @param [String] name Name or pattern to search @return [Boolean]",
    "label": "",
    "id": "548"
  },
  {
    "raw_code": "def systemd_unit?(comm, name)\n          comm.test(\"systemctl -q list-units | grep \\\"#{name}\\\"\")\n        end",
    "comment": "Check if a unit is currently active within systemd  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @param [String] name Name or pattern to search @return [Boolean]",
    "label": "",
    "id": "549"
  },
  {
    "raw_code": "def systemd_controlled?(comm, service_name)\n          comm.test(\"systemctl -q is-active #{service_name}\", sudo: true)\n        end",
    "comment": "Check if given service is controlled by systemd  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @param [String] service_name Name of the service to check @return [Boolean]",
    "label": "",
    "id": "550"
  },
  {
    "raw_code": "def hostnamectl?(comm)\n          comm.test(\"command -v hostnamectl && hostnamectl\")\n        end",
    "comment": "systemd hostname set is via hostnamectl  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @return [Boolean] NOTE: This test includes actually calling `hostnamectl` to verify that it is in working order. This prevents attempts to use the hostnamectl command when it is available, but dbus is not which renders the command useless",
    "label": "",
    "id": "551"
  },
  {
    "raw_code": "def netplan?(comm)\n          comm.test(\"command -v netplan\")\n        end",
    "comment": "netplan helpers netplan is installed  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @return [Boolean]",
    "label": "",
    "id": "552"
  },
  {
    "raw_code": "def networkd?(comm)\n          comm.test(\"command -v networkd\")\n        end",
    "comment": "is networkd isntalled  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @return [Boolean]",
    "label": "",
    "id": "553"
  },
  {
    "raw_code": "def nmcli?(comm)\n          comm.test(\"command -v nmcli\")\n        end",
    "comment": "nmcli helpers nmcli is installed  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @return [Boolean]",
    "label": "",
    "id": "554"
  },
  {
    "raw_code": "def nm_controlled?(comm, device_name)\n          comm.test(\"nmcli -t d show #{device_name}\") &&\n            !comm.test(\"nmcli -t d show #{device_name} | grep unmanaged\")\n        end",
    "comment": "NetworkManager currently controls device  @param [Vagrant::Plugin::V2::Communicator] comm Guest communicator @param device_name [String] @return [Boolean]",
    "label": "",
    "id": "555"
  },
  {
    "raw_code": "def is_port_open?(host, port)\n        begin\n          Socket.tcp(host, port, connect_timeout: 0.1).close\n          true\n        rescue Errno::ETIMEDOUT, Errno::ECONNREFUSED, Errno::EHOSTUNREACH, \\\n            Errno::ENETUNREACH, Errno::EACCES, Errno::ENOTCONN, Errno::EALREADY\n          false\n        end",
    "comment": "Checks if a port is open (listening) on a given host and port.  @param [String] host Hostname or IP address. @param [Integer] port Port to check. @return [Boolean] `true` if the port is open (listening), `false` otherwise.",
    "label": "",
    "id": "556"
  },
  {
    "raw_code": "def self.executable\n        if !defined?(@_powershell_executable)\n          prefer_name = ENV[\"VAGRANT_PREFERRED_POWERSHELL\"].to_s.sub(\".exe\", \"\")\n          if !POWERSHELL_NAMES.include?(prefer_name)\n            prefer_name = POWERSHELL_NAMES.first\n          end",
    "comment": "@return [String|nil] a powershell executable, depending on environment",
    "label": "",
    "id": "557"
  },
  {
    "raw_code": "def self.available?\n        !executable.nil?\n      end",
    "comment": "@return [Boolean] powershell executable available on PATH",
    "label": "",
    "id": "558"
  },
  {
    "raw_code": "def self.execute(path, *args, **opts, &block)\n        validate_install!\n        if opts.delete(:sudo) || opts.delete(:runas)\n          powerup_command(path, args, opts)\n        else\n          if mpath = opts.delete(:module_path)\n            m_env = opts.fetch(:env, {})\n            m_env[\"PSModulePath\"] = \"$env:PSModulePath+';#{mpath}'\"\n            opts[:env] = m_env\n          end",
    "comment": "Execute a powershell script.  @param [String] path Path to the PowerShell script to execute. @param [Array<String>] args Command arguments @param [Hash] opts Options passed to execute @option opts [Hash] :env Custom environment variables @return [Subprocess::Result]",
    "label": "",
    "id": "559"
  },
  {
    "raw_code": "def self.execute_cmd(command, **opts)\n        validate_install!\n        if mpath = opts.delete(:module_path)\n          m_env = opts.fetch(:env, {})\n          m_env[\"PSModulePath\"] = \"$env:PSModulePath+';#{mpath}'\"\n          opts[:env] = m_env\n        end",
    "comment": "Execute a powershell command.  @param [String] command PowerShell command to execute. @param [Hash] opts Extra options @option opts [Hash] :env Custom environment variables @return [nil, String] Returns nil if exit code is non-zero. Returns stdout string if exit code is zero.",
    "label": "",
    "id": "560"
  },
  {
    "raw_code": "def self.execute_inline(*command, **opts, &block)\n        validate_install!\n        if mpath = opts.delete(:module_path)\n          m_env = opts.fetch(:env, {})\n          m_env[\"PSModulePath\"] = \"$env:PSModulePath+';#{mpath}'\"\n          opts[:env] = m_env\n        end",
    "comment": "Execute a powershell command and return a result  @param [String] command PowerShell command to execute. @param [Hash] opts A collection of options for subprocess::execute @option opts [Hash] :env Custom environment variables @param [Block] block Ruby block",
    "label": "",
    "id": "561"
  },
  {
    "raw_code": "def self.version\n        if !defined?(@_powershell_version)\n          command = [\n            executable,\n            \"-NoLogo\",\n            \"-NoProfile\",\n            \"-NonInteractive\",\n            \"-ExecutionPolicy\", \"Bypass\",\n            \"-Command\",\n            \"Write-Output $PSVersionTable.PSVersion.Major\"\n          ].flatten\n\n          version = nil\n          timeout = ENV[\"VAGRANT_POWERSHELL_VERSION_DETECTION_TIMEOUT\"].to_i\n          if timeout < 1\n            timeout = DEFAULT_VERSION_DETECTION_TIMEOUT\n          end",
    "comment": "Returns the version of PowerShell that is installed.  @return [String]",
    "label": "",
    "id": "562"
  },
  {
    "raw_code": "def self.validate_install!\n        if !defined?(@_powershell_validation)\n          raise Errors::PowerShellNotFound if !available?\n          if version.to_i < MINIMUM_REQUIRED_VERSION\n            raise Errors::PowerShellInvalidVersion,\n              minimum_version: MINIMUM_REQUIRED_VERSION,\n              installed_version: version ? version : \"N/A\"\n          end",
    "comment": "Validates that powershell is installed, available, and at or above minimum required version  @return [Boolean] @raises []",
    "label": "",
    "id": "563"
  },
  {
    "raw_code": "def self.powerup_command(path, args, opts)\n        Dir.mktmpdir(\"vagrant\") do |dpath|\n          all_args = [path] + args.flatten.map{ |a|\n            a.gsub(/^['\"](.+)['\"]$/, \"\\\\1\")\n          }\n          arg_list = \"\\\"\" + all_args.join(\"\\\" \\\"\") + \"\\\"\"\n          stdout = File.join(dpath, \"stdout.txt\")\n          stderr = File.join(dpath, \"stderr.txt\")\n\n          script = \"& #{arg_list} ; exit $LASTEXITCODE;\"\n          script_content = Base64.strict_encode64(script.encode(\"UTF-16LE\", \"UTF-8\"))\n\n          # Wrap so we can redirect output to read later\n          wrapper = \"$p = Start-Process -FilePath powershell -ArgumentList @('-NoLogo', '-NoProfile', \" \\\n            \"'-NonInteractive', '-ExecutionPolicy', 'Bypass', '-EncodedCommand', '#{script_content}') \" \\\n            \"-PassThru -WindowStyle Hidden -Wait -RedirectStandardOutput '#{stdout}' -RedirectStandardError '#{stderr}'; \" \\\n            \"if($p){ exit $p.ExitCode; }else{ exit 1 }\"\n          wrapper_content = Base64.strict_encode64(wrapper.encode(\"UTF-16LE\", \"UTF-8\"))\n\n          powerup = \"$p = Start-Process -FilePath powershell -ArgumentList @('-NoLogo', '-NoProfile', \" \\\n            \"'-NonInteractive', '-ExecutionPolicy', 'Bypass', '-EncodedCommand', '#{wrapper_content}') \" \\\n            \"-PassThru -WindowStyle Hidden -Wait -Verb RunAs; if($p){ exit $p.ExitCode; }else{ exit 1 }\"\n\n          cmd = [\n            executable,\n            \"-NoLogo\",\n            \"-NoProfile\",\n            \"-NonInteractive\",\n            \"-ExecutionPolicy\", \"Bypass\",\n            \"-Command\", powerup\n          ]\n\n          result = Subprocess.execute(*cmd.push(opts))\n          r_stdout = result.stdout\n          if File.exist?(stdout)\n            r_stdout += File.read(stdout)\n          end",
    "comment": "Powerup the given command to perform privileged operations.  @param [String] path @param [Array<String>] args @return [Array<String>]",
    "label": "",
    "id": "564"
  },
  {
    "raw_code": "def self.reset!\n        instance_variables.each(&method(:remove_instance_variable))\n      end",
    "comment": "@private Reset the cached values for platform. This is not considered a public API and should only be used for testing.",
    "label": "",
    "id": "565"
  },
  {
    "raw_code": "def add_hostname_to_loopback_interface(comm, name, loop_bound=DEAFAULT_LOOPBACK_CHECK_LIMIT)\n          basename = name.split(\".\", 2)[0]\n          comm.sudo <<-EOH.gsub(/^ {14}/, '')\n          grep -w '#{name}' /etc/hosts || {\n            for i in #{[*1..loop_bound].join(' ')}; do\n              grep -w \"127.0.${i}.1\" /etc/hosts || {\n                echo \"127.0.${i}.1 #{name} #{basename}\" >> /etc/hosts\n                break\n              }\n            done\n          }\n          EOH\n        end",
    "comment": "Add hostname to a loopback address on /etc/hosts if not already there Will insert name at the first free address of the form 127.0.X.1, up to the loop_bound  @param [Communicator] @param [String] full hostanme @param [int] (option) defines the upper bound for searching for an available loopback address",
    "label": "",
    "id": "566"
  },
  {
    "raw_code": "def replace_host(comm, name, ip)\n          basename = name.split(\".\", 2)[0]\n          comm.sudo <<-EOH.gsub(/^ {14}/, '')\n          sed -i '/#{name}/d' /etc/hosts\n          sed -i'' '1i '#{ip}'\\\\t#{name}\\\\t#{basename}' /etc/hosts\n          EOH\n        end",
    "comment": "Remove any line in /etc/hosts that contains hostname, then add hostname with associated ip  @param [Communicator] @param [String] full hostanme @param [String] target ip",
    "label": "",
    "id": "567"
  },
  {
    "raw_code": "def replace_host(comm, name, ip)\n          basename = name.split(\".\", 2)[0]\n          comm.sudo <<-EOH.gsub(/^ {14}/, '')\n          sed -i.bak '/#{name}/d' /etc/hosts\n          sed -i.bak '1i\\\\\\n#{ip}\\t#{name}\\t#{basename}\\n' /etc/hosts\n          EOH\n        end",
    "comment": "Remove any line in /etc/hosts that contains hostname, then add hostname with associated ip  @param [Communicator] @param [String] full hostanme @param [String] target ip",
    "label": "",
    "id": "568"
  },
  {
    "raw_code": "def remove_ansi_escape_codes(text)\n        # An array of regular expressions which match various kinds\n        # of escape sequences. I can't think of a better single regular\n        # expression or any faster way to do this.\n        matchers = [/\\e\\[\\d*[ABCD]/,       # Matches things like \\e[4D\n                    /\\e\\[(\\d*;)?\\d*[HF]/,  # Matches \\e[1;2H or \\e[H\n                    /\\e\\[(s|u|2J|K)/,      # Matches \\e[s, \\e[2J, etc.\n                    /\\e\\[=\\d*[hl]/,        # Matches \\e[=24h\n                    /\\e\\[\\?[1-9][hl]/,     # Matches \\e[?2h\n                    /\\e\\[20[hl]/,          # Matches \\e[20l]\n                    /\\e[DME78H]/,          # Matches \\eD, \\eH, etc.\n                    /\\e\\[[0-3]?[JK]/,      # Matches \\e[0J, \\e[K, etc.\n                    ]\n\n        # Take each matcher and replace it with emptiness.\n        matchers.each do |matcher|\n          text.gsub!(matcher, \"\")\n        end",
    "comment": "Removes ANSI escape code sequences from the text and returns it.  This removes all the ANSI escape codes listed here along with the escape codes for VT100 terminals:  http://ascii-table.com/ansi-escape-sequences.php",
    "label": "",
    "id": "569"
  },
  {
    "raw_code": "def busy(sig_callback)\n          register(sig_callback)\n          return yield\n        ensure\n          unregister(sig_callback)\n        end",
    "comment": "Mark a given block of code as a \"busy\" block of code, which will register a SIGINT handler for the duration of the block. When a SIGINT occurs, the `sig_callback` proc will be called. It is up to the callback to behave properly and exit the application.",
    "label": "",
    "id": "570"
  },
  {
    "raw_code": "def register(sig_callback)\n          @@mutex.synchronize do\n            registered << sig_callback\n            registered.uniq!\n\n            # Register the handler if this is our first callback.\n            Signal.trap(\"INT\") { fire_callbacks } if registered.length == 1\n          end",
    "comment": "Registers a SIGINT handler. This typically is called from {busy}. Callbacks are only registered once, so calling this multiple times with the same callback has no consequence.",
    "label": "",
    "id": "571"
  },
  {
    "raw_code": "def unregister(sig_callback)\n          @@mutex.synchronize do\n            registered.delete(sig_callback)\n\n            # Remove the signal trap if no more registered callbacks exist\n            Signal.trap(\"INT\", \"DEFAULT\") if registered.empty?\n          end",
    "comment": "Unregisters a SIGINT handler.",
    "label": "",
    "id": "572"
  },
  {
    "raw_code": "def fire_callbacks\n          registered.reverse.each { |r| r.call }\n        end",
    "comment": "Fires all the registered callbacks.",
    "label": "",
    "id": "573"
  },
  {
    "raw_code": "def registered; @@registered; end\n      end",
    "comment": "Helper method to get access to the class variable. This is mostly exposed for tests. This shouldn't be mucked with directly, since it's structure may change at any time.",
    "label": "",
    "id": "574"
  },
  {
    "raw_code": "def self.execute(*command, &block)\n        new(*command).execute(&block)\n      end",
    "comment": "Convenience method for executing a method.",
    "label": "",
    "id": "575"
  },
  {
    "raw_code": "def running?\n        !!(@process && @process.alive?)\n      end",
    "comment": "@return [TrueClass, FalseClass] subprocess is currently running",
    "label": "",
    "id": "576"
  },
  {
    "raw_code": "def stop\n        if @process && @process.alive?\n          @process.stop\n          true\n        else\n          false\n        end",
    "comment": "Stop the subprocess if running  @return [TrueClass] FalseClass] true if process was running and stopped",
    "label": "",
    "id": "577"
  },
  {
    "raw_code": "def execute\n        # Get the timeout, if we have one\n        timeout = @options[:timeout]\n\n        # Get the working directory\n        workdir = @options[:workdir] || Dir.pwd\n\n        # Get what we're interested in being notified about\n        notify  = @options[:notify] || []\n        notify  = [notify] if !notify.is_a?(Array)\n        if notify.empty? && block_given?\n          # If a block is given, subscribers must be given, otherwise the\n          # block is never called. This is usually NOT what you want, so this\n          # is an error.\n          message = \"A list of notify subscriptions must be given if a block is given\"\n          raise ArgumentError, message\n        end",
    "comment": "Start the process  @return [Result]",
    "label": "",
    "id": "578"
  },
  {
    "raw_code": "def jailbreak(env = {})\n        return if ENV.key?(\"VAGRANT_SKIP_SUBPROCESS_JAILBREAK\")\n\n        if defined?(::Bundler) && defined?(::Bundler::ORIGINAL_ENV)\n          env.replace(::Bundler::ORIGINAL_ENV)\n        end",
    "comment": "This is, quite possibly, the saddest function in all of Vagrant.  If a user is running Vagrant via Bundler (but not via the official installer), we want to reset to the \"original\" environment so that when shelling out to other Ruby processes (specifically), the original environment is restored. This is super important for things like rbenv and chruby, who rely on environment variables to locate gems, but Bundler stomps on those environment variables like an angry T-Rex after watching Jurassic Park 2 and realizing they replaced you with CGI.  If a user is running in Vagrant via the official installer, BUT trying to execute a subprocess *outside* of the installer, we want to reset to the \"original\" environment. In this case, the Vagrant installer actually knows what the original environment was and replaces it completely.  Finally, we reset any Bundler-specific environment variables, since the subprocess being called could, itself, be Bundler. And Bundler does not behave very nicely in these circumstances.  This function was added in Vagrant 1.7.3, but there is a failsafe because the author doesn't trust himself that this functionality won't break existing assumptions, so users can specify `VAGRANT_SKIP_SUBPROCESS_JAILBREAK` and none of the above will happen.  This function modifies the given hash in place!  @return [nil]",
    "label": "",
    "id": "579"
  },
  {
    "raw_code": "def self.escape(text, quote)\n        text.gsub(/#{quote}/) do |m|\n          \"#{m}\\\\#{m}#{m}\"\n        end",
    "comment": "This will auto-escape the text with the given quote mark type.  @param [String] text Text to escape @param [String] quote The quote character, such as \"",
    "label": "",
    "id": "580"
  },
  {
    "raw_code": "def initialize(&callback)\n        raise ArgumentError,\n          \"Expected callback but received none\" if callback.nil?\n        @mu = Mutex.new\n        @callback = callback\n        @buffer = \"\"\n      end",
    "comment": "Create a new line buffer. The registered block will be called when a new line is encountered on provided input, or the max line length is reached",
    "label": "",
    "id": "581"
  },
  {
    "raw_code": "def <<(str)\n        @mu.synchronize do\n          while i = str.index(\"\\n\")\n            @callback.call((@buffer + str[0, i+1]).rstrip)\n            @buffer.clear\n            str = str[i+1, str.length].to_s\n          end",
    "comment": "Add string data to output  @param [String] str String of data to output @return [self]",
    "label": "",
    "id": "582"
  },
  {
    "raw_code": "def close\n        @mu.synchronize do\n          # Send any remaining output on the buffer\n          @callback.call(@buffer.dup) if !@buffer.empty?\n          # Disable this buffer instance\n          @callback = nil\n          @buffer.clear\n          @buffer.freeze\n        end",
    "comment": "Closes the buffer. Any remaining data that has been buffered will be given to the callback. Once closed the instance will no longer be usable.  @return [self]",
    "label": "",
    "id": "583"
  },
  {
    "raw_code": "def initialize(globals=nil, &block)\n        @globals      = globals || {}\n        @lazy_globals = block\n        @logger       = Log4r::Logger.new(\"vagrant::action::runner\")\n      end",
    "comment": "@param globals [Hash] variables for the env to be passed to the action @yieldreturn [Hash] lazy-loaded vars merged into the env before action run",
    "label": "",
    "id": "584"
  },
  {
    "raw_code": "def primary?\n        false\n      end",
    "comment": "@see PrimaryRunner @see Vagrant::Action::Builder#primary",
    "label": "",
    "id": "585"
  },
  {
    "raw_code": "def recover(env)\n        @logger.info(\"Beginning recovery process...\")\n\n        @stack.each do |act|\n          if act.respond_to?(:recover)\n            @logger.info(\"Calling recover: #{act}\")\n            act.recover(env)\n          end",
    "comment": "We implement the recover method ourselves in case a Warden is embedded within another Warden. To recover, we just do our own recovery process on our stack.",
    "label": "",
    "id": "586"
  },
  {
    "raw_code": "def finalize_action(action, env)\n        if action.is_a?(Builder::StackItem)\n          klass = action.middleware\n          args = action.arguments.parameters\n          keywords = action.arguments.keywords\n          block = action.arguments.block\n        else\n          klass = action\n          args = []\n          keywords = {}\n        end",
    "comment": "A somewhat confusing function which simply initializes each middleware properly to call the next middleware in the sequence.",
    "label": "",
    "id": "587"
  },
  {
    "raw_code": "def self.build(middleware, *args, **keywords, &block)\n        new.use(middleware, *args, **keywords, &block)\n      end",
    "comment": "This is a shortcut for a middleware sequence with only one item in it. For a description of the arguments and the documentation, please see {#use} instead.  @return [Builder]",
    "label": "",
    "id": "588"
  },
  {
    "raw_code": "def initialize_copy(original)\n        super\n\n        @stack = original.stack.dup\n      end",
    "comment": "Implement a custom copy that copies the stack variable over so that we don't clobber that.",
    "label": "",
    "id": "589"
  },
  {
    "raw_code": "def flatten\n        lambda do |env|\n          self.call(env)\n        end",
    "comment": "Returns a mergeable version of the builder. If `use` is called with the return value of this method, then the stack will merge, instead of being treated as a separate single middleware.",
    "label": "",
    "id": "590"
  },
  {
    "raw_code": "def use(middleware, *args, **keywords, &block)\n        item = StackItem.new(\n          middleware: middleware,\n          arguments: MiddlewareArguments.new(\n            parameters: args,\n            keywords: keywords,\n            block: block\n          )\n        )\n\n        if middleware.kind_of?(Builder)\n          # Merge in the other builder's stack into our own\n          self.stack.concat(middleware.stack)\n        else\n          self.stack << item\n        end",
    "comment": "Adds a middleware class to the middleware stack. Any additional args and a block, if given, are saved and passed to the initializer of the middleware.  @param [Class] middleware The middleware class",
    "label": "",
    "id": "591"
  },
  {
    "raw_code": "def insert(idx_or_item, middleware, *args, **keywords, &block)\n        item = StackItem.new(\n          middleware: middleware,\n          arguments: MiddlewareArguments.new(\n            parameters: args,\n            keywords: keywords,\n            block: block\n          )\n        )\n\n        if idx_or_item.is_a?(Integer)\n          index = idx_or_item\n        else\n          index = self.index(idx_or_item)\n        end",
    "comment": "Inserts a middleware at the given index or directly before the given middleware object.",
    "label": "",
    "id": "592"
  },
  {
    "raw_code": "def insert_after(idx_or_item, middleware, *args, **keywords, &block)\n        if idx_or_item.is_a?(Integer)\n          index = idx_or_item\n        else\n          index = self.index(idx_or_item)\n        end",
    "comment": "Inserts a middleware after the given index or middleware object.",
    "label": "",
    "id": "593"
  },
  {
    "raw_code": "def replace(index, middleware, *args, **keywords, &block)\n        if index.is_a?(Integer)\n          delete(index)\n          insert(index, middleware, *args, **keywords, &block)\n        else\n          insert_before(index, middleware, *args, **keywords, &block)\n          delete(index)\n        end",
    "comment": "Replaces the given middlware object or index with the new middleware.",
    "label": "",
    "id": "594"
  },
  {
    "raw_code": "def delete(index)\n        index = self.index(index) unless index.is_a?(Integer)\n        stack.delete_at(index)\n      end",
    "comment": "Deletes the given middleware object or index",
    "label": "",
    "id": "595"
  },
  {
    "raw_code": "def call(env)\n        to_app(env).call(env)\n      end",
    "comment": "Runs the builder stack with the given environment.",
    "label": "",
    "id": "596"
  },
  {
    "raw_code": "def index(object)\n        stack.each_with_index do |item, i|\n          return i if item == object\n          return i if item.middleware == object\n          return i if item.middleware.respond_to?(:name) &&\n            item.middleware.name == object\n        end",
    "comment": "Returns the numeric index for the given middleware object.  @param [Object] object The item to find the index for @return [Integer]",
    "label": "",
    "id": "597"
  },
  {
    "raw_code": "def to_app(env)\n        # Start with a duplicate of ourself which can\n        # be modified\n        builder = self.dup\n\n        # Apply all dynamic modifications of the stack. This\n        # will generate dynamic hooks for all actions within\n        # the stack, load any triggers for action classes, and\n        # apply them to the builder's stack\n        builder.apply_dynamic_updates(env)\n\n        # Now that the stack is fully expanded, apply any\n        # action hooks that may be defined so they are on\n        # the outermost locations of the stack\n        builder.apply_action_name(env)\n\n        # Wrap the middleware stack with the Warden to provide a consistent\n        # and predictable behavior upon exceptions.\n        Warden.new(builder.stack.dup, env)\n      end",
    "comment": "Converts the builder stack to a runnable action sequence.  @param [Hash] env The action environment hash @return [Warden] A callable object",
    "label": "",
    "id": "598"
  },
  {
    "raw_code": "def apply_dynamic_updates(env)\n        triggers = env[:triggers]\n\n        # Use a Hook as a convenient interface for injecting\n        # any applicable trigger actions within the stack\n        machine_name = env[:machine].name if env[:machine]\n\n        # Iterate over all items in the stack and apply new items\n        # into the hook as they are found. Must be sure to dup the\n        # stack here since we are modifying the stack in the loop.\n        stack.dup.each do |item|\n          hook = Hook.new\n\n          action = item.first\n          next if action.is_a?(Proc)\n\n          # Start with adding any action triggers that may be defined\n          if triggers && !triggers.find(action, :before, machine_name, :action).empty?\n            hook.prepend(Vagrant::Action::Builtin::Trigger,\n              action.name, triggers, :before, :action)\n          end",
    "comment": "Find any action hooks or triggers which have been defined for items within the stack. Update the stack with any hooks or triggers found.  @param [Hash] env Call environment @return [Builder] self",
    "label": "",
    "id": "599"
  },
  {
    "raw_code": "def apply_action_name(env)\n        env[:builder_raw_applied] ||= []\n        return self if !env[:action_name]\n\n        hook = Hook.new\n        machine_name = env[:machine].name if env[:machine]\n\n        # Start with loading any hook triggers if applicable\n        if env[:triggers]\n          if !env[:triggers].find(env[:action_name], :before, machine_name, :hook).empty?\n            hook.prepend(Vagrant::Action::Builtin::Trigger,\n              env[:action_name], env[:triggers], :before, :hook)\n          end",
    "comment": "If action hooks have not already been set, this method will perform three tasks: 1. Load any hook triggers defined for the action_name 2. Load any action_hooks defined from plugins 3. Load any action triggers based on machine action called (not action classes)  @param [Hash] env Call environment @return [Builder]",
    "label": "",
    "id": "600"
  },
  {
    "raw_code": "def before(existing, new, *args, **keywords, &block)\n        item = Builder::StackItem.new(\n          middleware: new,\n          arguments: Builder::MiddlewareArguments.new(\n            parameters: args,\n            keywords: keywords,\n            block: block\n          )\n        )\n        @before_hooks[existing] << item\n      end",
    "comment": "Add a middleware before an existing middleware.  @param [Class] existing The existing middleware. @param [Class] new The new middleware.",
    "label": "",
    "id": "601"
  },
  {
    "raw_code": "def after(existing, new, *args, **keywords, &block)\n        item = Builder::StackItem.new(\n          middleware: new,\n          arguments: Builder::MiddlewareArguments.new(\n            parameters: args,\n            keywords: keywords,\n            block: block\n          )\n        )\n        @after_hooks[existing] << item\n      end",
    "comment": "Add a middleware after an existing middleware.  @param [Class] existing The existing middleware. @param [Class] new The new middleware.",
    "label": "",
    "id": "602"
  },
  {
    "raw_code": "def append(new, *args, **keywords, &block)\n        item = Builder::StackItem.new(\n          middleware: new,\n          arguments: Builder::MiddlewareArguments.new(\n            parameters: args,\n            keywords: keywords,\n            block: block\n          )\n        )\n        @append_hooks << item\n      end",
    "comment": "Append a middleware to the end of the stack. Note that if the middleware sequence ends early, then the new middleware won't be run.  @param [Class] new The middleware to append.",
    "label": "",
    "id": "603"
  },
  {
    "raw_code": "def prepend(new, *args, **keywords, &block)\n        item = Builder::StackItem.new(\n          middleware: new,\n          arguments: Builder::MiddlewareArguments.new(\n            parameters: args,\n            keywords: keywords,\n            block: block\n          )\n        )\n        @prepend_hooks << item\n      end",
    "comment": "Prepend a middleware to the beginning of the stack.  @param [Class] new The new middleware to prepend.",
    "label": "",
    "id": "604"
  },
  {
    "raw_code": "def empty?\n        before_hooks.empty? &&\n          after_hooks.empty? &&\n          prepend_hooks.empty? &&\n          append_hooks.empty?\n      end",
    "comment": "@return [Boolean]",
    "label": "",
    "id": "605"
  },
  {
    "raw_code": "def apply(builder, options={})\n        if !options[:no_prepend_or_append]\n          # Prepends first\n          @prepend_hooks.each do |item|\n            if options[:root]\n              idx = builder.index(options[:root])\n            else\n              idx = 0\n            end",
    "comment": "This applies the given hook to a builder. This should not be called directly.  @param [Builder] builder",
    "label": "",
    "id": "606"
  },
  {
    "raw_code": "def self.validate!(output, directory)\n          filename = File.basename(output.to_s)\n          output   = fullpath(output)\n\n          if File.directory?(output)\n            raise Vagrant::Errors::PackageOutputDirectory\n          end",
    "comment": "Perform sanity validations that the provided output filepath is sane. In particular, this function validates:  - The output path is a regular file (not a directory or symlink) - No file currently exists at the given path - A directory of package files was actually provided (internal)  @param [String] output path to the output file @param [String] directory path to a directory containing the files",
    "label": "",
    "id": "607"
  },
  {
    "raw_code": "def self.fullpath(output)\n          File.expand_path(output, Dir.pwd)\n        end",
    "comment": "Calculate the full path of the given path, relative to the current working directory (where the command was run).  @param [String] output the relative path",
    "label": "",
    "id": "608"
  },
  {
    "raw_code": "def copy_include_files\n          include_directory = Pathname.new(@env[\"package.directory\"]).join(\"include\")\n\n          @env[\"package.files\"].each do |from, dest|\n            # We place the file in the include directory\n            to = include_directory.join(dest)\n\n            @env[:ui].info I18n.t(\"vagrant.actions.general.package.packaging\", file: from)\n            FileUtils.mkdir_p(to.parent)\n\n            # Copy directory contents recursively.\n            if File.directory?(from)\n              FileUtils.cp_r(Dir.glob(from), to.parent, preserve: true)\n            else\n              FileUtils.cp(from, to, preserve: true)\n            end",
    "comment": "This method copies the include files (passed in via command line) to the temporary directory so they are included in a sub-folder within the actual box",
    "label": "",
    "id": "609"
  },
  {
    "raw_code": "def copy_info\n          info_path = Pathname.new(@env[\"package.info\"])\n\n          if info_path.file?\n            FileUtils.cp(info_path, @env[\"package.directory\"], preserve: true)\n          end",
    "comment": "This method copies the specified info.json file to the temporary directory so that it is accessible via the 'box list -i' command",
    "label": "",
    "id": "610"
  },
  {
    "raw_code": "def compress\n          # Get the output path. We have to do this up here so that the\n          # pwd returns the proper thing.\n          output_path = fullpath.to_s\n\n          # Switch into that directory and package everything up\n          Util::SafeChdir.safe_chdir(@env[\"package.directory\"]) do\n            # Find all the files in our current directory and tar it up!\n            files = Dir.glob(File.join(\".\", \"*\"))\n\n            # Package!\n            Util::Subprocess.execute(\"bsdtar\", \"-czf\", output_path, *files)\n          end",
    "comment": "Compress the exported file into a package",
    "label": "",
    "id": "611"
  },
  {
    "raw_code": "def write_metadata_json\n          meta_path = File.join(@env[\"package.directory\"], \"metadata.json\")\n          return if File.exist?(meta_path)\n\n          if @env[:machine] && @env[:machine].provider_name\n            provider_name = @env[:machine].provider_name\n          elsif @env[:env] && @env[:env].default_provider\n            provider_name = @env[:env].default_provider\n          else\n            return\n          end",
    "comment": "Write the metadata file into the box so that the provider can be automatically detected when adding the box",
    "label": "",
    "id": "612"
  },
  {
    "raw_code": "def setup_private_key\n          # If we don't have machine, we do nothing (weird)\n          return if !@env[:machine]\n\n          # If we don't have a data dir, we also do nothing (base package)\n          return if !@env[:machine].data_dir\n\n          # If we don't have a generated private key, we do nothing\n          path = @env[:machine].data_dir.join(\"private_key\")\n          if !path.file?\n            # If we have a private key that was copied into this box,\n            # then we copy that. This is a bit of a heuristic and can be a\n            # security risk if the key is named the correct thing, but\n            # we'll take that risk for dev environments.\n            (@env[:machine].config.ssh.private_key_path || []).each do |p|\n              # If we have the correctly named key, copy it\n              if File.basename(p) == \"vagrant_private_key\"\n                path = Pathname.new(p)\n                break\n              end",
    "comment": "This will copy the generated private key into the box and use it for SSH by default. We have to do this because we now generate random keypairs on boot, so packaged boxes would stop working without this.",
    "label": "",
    "id": "613"
  },
  {
    "raw_code": "def invalid_info?\n          if @env[\"package.info\"] != \"\"\n            info_path = Pathname.new(@env[\"package.info\"])\n\n            return !info_path.file? || File.basename(info_path) != \"info.json\"\n          end",
    "comment": "Check to see if package.info is a valid file and titled info.json",
    "label": "",
    "id": "614"
  },
  {
    "raw_code": "def default_synced_folder_type(machine, plugins)\n          ordered = []\n\n          # First turn the plugins into an array\n          plugins.each do |key, data|\n            impl     = data[0]\n            priority = data[1]\n\n            ordered << [priority, key, impl]\n          end",
    "comment": "This goes over all the registered synced folder types and returns the highest priority implementation that is usable for this machine.",
    "label": "",
    "id": "615"
  },
  {
    "raw_code": "def impl_opts(name, env)\n          {}.tap do |result|\n            env.each do |k, v|\n              if k.to_s.start_with?(\"#{name}_\")\n                # While I generally don't like the 'rescue' syntax,\n                # we do this to just fall back to the default value\n                # if it isn't dup-able.\n                k = k.dup rescue k\n                v = v.dup rescue v\n\n                result[k] = v\n              end",
    "comment": "This finds the options in the env that are set for a given synced folder type.",
    "label": "",
    "id": "616"
  },
  {
    "raw_code": "def plugins\n          @plugins ||= Vagrant.plugin(\"2\").manager.synced_folders\n        end",
    "comment": "This returns the available synced folder implementations. This is a separate method so that it can be easily stubbed by tests.",
    "label": "",
    "id": "617"
  },
  {
    "raw_code": "def save_synced_folders(machine, folders, opts={})\n          if opts[:merge]\n            existing = cached_synced_folders(machine)\n            if existing\n              if opts[:vagrantfile]\n                # Go through and find any cached that were from the\n                # Vagrantfile itself. We remove those if it was requested.\n                existing.each do |impl, fs|\n                  fs.each do |id, data|\n                    fs.delete(id) if data[:__vagrantfile]\n                  end",
    "comment": "This saves the synced folders data to the machine data directory. They can then be retrieved again with `synced_folders` by passing the `cached` option to it.  @param [Machine] machine The machine that the folders belong to @param [Hash] folders The result from a {#synced_folders} call.",
    "label": "",
    "id": "618"
  },
  {
    "raw_code": "def synced_folders(machine, **opts)\n          return cached_synced_folders(machine) if opts[:cached]\n\n          config = opts[:config]\n          root   = false\n          if !config\n            config = machine.config.vm\n            root   = true\n          end",
    "comment": "This returns the set of shared folders that should be done for this machine. It returns the folders in a hash keyed by the implementation class for the synced folders.  @return [Hash<Symbol, Hash<String, Hash>>]",
    "label": "",
    "id": "619"
  },
  {
    "raw_code": "def synced_folders_diff(one, two)\n          existing_ids = {}\n          one.each do |impl, fs|\n            fs.each do |id, data|\n              existing_ids[id] = data\n            end",
    "comment": "This finds the difference between two lists of synced folder definitions.  This will return a hash with three keys: \"added\", \"removed\", and \"modified\". These will contain a set of IDs of folders that were added, removed, or modified, respectively.  The parameters should be results from the {#synced_folders} call.  @return [hash]",
    "label": "",
    "id": "620"
  },
  {
    "raw_code": "def add_direct(urls, env)\n          env[:ui].output(I18n.t(\"vagrant.box_adding_direct\"))\n\n          name = env[:box_name]\n          if !name || name == \"\"\n            raise Errors::BoxAddNameRequired\n          end",
    "comment": "Adds a box file directly (no metadata component, versioning, etc.)  @param [Array<String>] urls @param [Hash] env",
    "label": "",
    "id": "621"
  },
  {
    "raw_code": "def add_from_metadata(url, env, expanded)\n          original_url = env[:box_url]\n          architecture = env[:box_architecture]\n          display_architecture = architecture == :auto ?\n                                   Util::Platform.architecture : architecture\n          provider = env[:box_provider]\n          provider = Array(provider) if provider\n          version = env[:box_version]\n\n          authenticated_url = url\n          if url.is_a?(Array)\n            # We have both a normal URL and \"authenticated\" URL. Split\n            # them up.\n            authenticated_url = url[1]\n            url               = url[0]\n          end",
    "comment": "Adds a box given that the URL is a metadata document.  @param [String | Array<String>] url The URL of the metadata for the box to add. If this is an array, then it must be a two-element array where the first element is the original URL and the second element is an authenticated URL. @param [Hash] env @param [Bool] expanded True if the metadata URL was expanded with a Atlas server URL.",
    "label": "",
    "id": "622"
  },
  {
    "raw_code": "def box_add(urls, name, version, provider, md_url, env, **opts)\n          display_architecture = opts[:architecture] == :auto ?\n                                   Util::Platform.architecture : opts[:architecture]\n          env[:ui].output(I18n.t(\n            \"vagrant.box_add_with_version\",\n            name: name,\n            version: version,\n            providers: [\n              provider,\n              display_architecture ? \"(#{display_architecture})\" : nil\n            ].compact.join(\" \")))\n\n          # Verify the box we're adding doesn't already exist\n          if provider && !env[:box_force]\n            box = env[:box_collection].find(\n              name, provider, version, opts[:architecture])\n            if box\n              raise Errors::BoxAlreadyExists,\n                name: name,\n                provider: provider,\n                version: version\n            end",
    "comment": "Shared helper to add a box once you know various details about it. Shared between adding via metadata or by direct.  @param [Array<String>] urls @param [String] name @param [String] version @param [String] provider @param [Hash] env @return [Box]",
    "label": "",
    "id": "623"
  },
  {
    "raw_code": "def downloader(url, env, **opts)\n          opts[:ui] = true if !opts.key?(:ui)\n\n          temp_path = env[:tmp_path].join(\"box\" + Digest::SHA1.hexdigest(url))\n          @logger.info(\"Downloading box: #{url} => #{temp_path}\")\n\n          if File.file?(url) || url !~ /^[a-z0-9]+:.*$/i\n            @logger.info(\"URL is a file or protocol not found and assuming file.\")\n            file_path = File.expand_path(url)\n            file_path = Util::Platform.cygwin_windows_path(file_path)\n            file_path = file_path.gsub(\"\\\\\", \"/\")\n            file_path = \"/#{file_path}\" if !file_path.start_with?(\"/\")\n            url = \"file://#{file_path}\"\n          end",
    "comment": "Returns the download options for the download.  @return [Hash]",
    "label": "",
    "id": "624"
  },
  {
    "raw_code": "def metadata_url?(url, env)\n          d = downloader(url, env, json: true, ui: false)\n          env[:hook].call(:authenticate_box_downloader, downloader: d)\n\n          # If we're downloading a file, cURL just returns no\n          # content-type (makes sense), so we just test if it is JSON\n          # by trying to parse JSON!\n          uri = URI.parse(d.source)\n          if uri.scheme == \"file\"\n            url = uri.path\n            url ||= uri.opaque\n            #7570 Strip leading slash left in front of drive letter by uri.path\n            Util::Platform.windows? && url.gsub!(/^\\/([a-zA-Z]:)/, '\\1')\n            url = @parser.unescape(url)\n\n            begin\n              File.open(url, \"r\") do |f|\n                if f.size > METADATA_SIZE_LIMIT\n                  # Quit early, don't try to parse the JSON of gigabytes\n                  # of box files...\n                  return false\n                end",
    "comment": "Tests whether the given URL points to a metadata file or a box file without completely downloading the file.  @param [String] url @return [Boolean] true if metadata",
    "label": "",
    "id": "625"
  },
  {
    "raw_code": "def initialize(app, env, name, triggers, timing, type=:action, all: false)\n          @app         = app\n          @env         = env\n          @triggers    = triggers\n          @name        = name\n          @timing      = timing\n          @type        = type\n          @all         = all\n\n          if ![:before, :after].include?(timing)\n            raise ArgumentError,\n              \"Invalid value provided for `timing` (allowed: :before or :after)\"\n          end",
    "comment": "@param [Class, String, Symbol] name Name of trigger to fire @param [Vagrant::Plugin::V2::Triger] triggers Trigger object @param [Symbol] timing When trigger should fire (:before/:after) @param [Symbol] type Type of trigger",
    "label": "",
    "id": "626"
  },
  {
    "raw_code": "def initialize(app, env, callable)\n          if !callable.respond_to?(:call)\n            raise TypeError, \"Callable argument is expected to respond to `#call`\"\n          end",
    "comment": "@param [Object] callable The object to call (must respond to #call)",
    "label": "",
    "id": "627"
  },
  {
    "raw_code": "def initialize(app, env, callable, *callable_args, &block)\n          raise ArgumentError, \"A block must be given to Call\" if !block\n\n          @app      = app\n          @callable = callable\n          @callable_args = callable_args\n          @block    = block\n          @child_app = nil\n        end",
    "comment": "For documentation, read the description of the {Call} class.  @param [Object] callable A valid middleware runnable object. This can be a class, a lambda, or an object that responds to `call`. @yield [result, builder] This block is expected to build on `builder` which is the next middleware sequence that will be run.",
    "label": "",
    "id": "628"
  },
  {
    "raw_code": "def initialize(app, env, target_state, source_state=nil)\n          @app          = app\n          @logger       = Log4r::Logger.new(\"vagrant::action::builtin::graceful_halt\")\n          @source_state = source_state\n          @target_state = target_state\n        end",
    "comment": "Note: Any of the arguments can be arrays as well.  @param [Symbol] target_state The target state ID that means that the machine was properly shut down. @param [Symbol] source_state The source state ID that the machine must be in to be shut down.",
    "label": "",
    "id": "629"
  },
  {
    "raw_code": "def provisioner_instances(env)\n          return @_provisioner_instances if @_provisioner_instances\n\n          # Make the mapping that'll keep track of provisioner => type\n          @_provisioner_types = {}\n\n          # Get all the configured provisioners\n          @_provisioner_instances = env[:machine].config.vm.provisioners.map do |provisioner|\n            # Instantiate the provisioner\n            klass  = Vagrant.plugin(\"2\").manager.provisioners[provisioner.type]\n\n            # This can happen in the case the configuration isn't validated.\n            next nil if !klass\n\n            result = klass.new(env[:machine], provisioner.config)\n\n            # Store in the type map so that --provision-with works properly\n            @_provisioner_types[result] = provisioner.type\n\n            # Set top level provisioner name to provisioner configs name if top level name not set.\n            # This is mostly for handling the shell provisioner, if a user has set its name like:\n            #\n            #   config.vm.provision \"shell\", name: \"my_provisioner\"\n            #\n            # Where `name` is a shell config option, not a top level provisioner class option\n            #\n            # Note: `name` is set to a symbol, since it is converted to one via #Config::VM.provision\n            provisioner_name = provisioner.name\n            if !provisioner_name\n              if provisioner.config.respond_to?(:name) &&\n                  provisioner.config.name\n                provisioner_name = provisioner.config.name.to_sym\n              end",
    "comment": "This returns all the instances of the configured provisioners. This is safe to call multiple times since it will cache the results.  @return [Array<Provisioner, Hash>]",
    "label": "",
    "id": "630"
  },
  {
    "raw_code": "def sort_provisioner_instances(pvs)\n          final_provs = []\n          root_provs = []\n          # extract root provisioners\n          root_provs = pvs.find_all { |_, o| o[:before].nil? && o[:after].nil? }\n\n          if root_provs.size == pvs.size\n            # no dependencies found\n            return pvs\n          end",
    "comment": "Sorts provisioners based on order specified with before/after options  @return [Array<Provisioner, Hash>]",
    "label": "",
    "id": "631"
  },
  {
    "raw_code": "def provisioner_type_map(env)\n          # Call this in order to initial the map if it hasn't been already\n          provisioner_instances(env)\n\n          # Return the type map\n          @_provisioner_types\n        end",
    "comment": "This will return a mapping of a provisioner instance to its type.",
    "label": "",
    "id": "632"
  },
  {
    "raw_code": "def self.reset!\n          instance_variables.each(&method(:remove_instance_variable))\n        end",
    "comment": "@private Reset the cached values for platform. This is not considered a public API and should only be used for testing.",
    "label": "",
    "id": "633"
  },
  {
    "raw_code": "def initialize(app, env)\n          @app    = app\n          @logger = Log4r::Logger.new(\"vagrant::action::builtin::disk\")\n        end",
    "comment": "Removes any attached disks no longer defined in a Vagrantfile config",
    "label": "",
    "id": "634"
  },
  {
    "raw_code": "def initialize(app, env, message, force_key=nil, **opts)\n          @app      = app\n          @message  = message\n          @force_key = force_key\n          @allowed  = opts[:allowed]\n        end",
    "comment": "For documentation, read the description of the {Confirm} class.  @param [String] message The message to ask the user. @param [Symbol] force_key The key that if present and true in the environment hash will skip the confirmation question.",
    "label": "",
    "id": "635"
  },
  {
    "raw_code": "def setup_user_data(machine, env, user_data_cfgs)\n          machine.ui.info(I18n.t(\"vagrant.actions.vm.cloud_init_user_data_setup\"))\n\n          text_cfgs = user_data_cfgs.map { |cfg| read_text_cfg(machine, cfg) }\n\n          user_data = generate_cfg_msg(machine, text_cfgs)\n          user_data\n        end",
    "comment": "@param [Vagrant::Machine] machine @param [Vagrant::Environment] env @param [Array<#VagrantPlugins::Kernel_V2::VagrantConfigCloudInit>] user_data_cfgs @return [Vagrant::Util::Mime::MultiPart] user_data",
    "label": "",
    "id": "636"
  },
  {
    "raw_code": "def read_text_cfg(machine, cfg)\n          if cfg.path\n            text = File.read(Pathname.new(cfg.path).expand_path(machine.env.root_path))\n          else\n            text = cfg.inline\n          end",
    "comment": "Reads an individual cloud_init config and stores its contents and the content_type as a MIME text  @param [Vagrant::Machine] machine @param [VagrantPlugins::Kernel_V2::VagrantConfigCloudInit] cfg @return [Vagrant::Util::Mime::Entity] text_msg",
    "label": "",
    "id": "637"
  },
  {
    "raw_code": "def generate_cfg_msg(machine, text_cfgs)\n          msg = Vagrant::Util::Mime::Multipart.new\n          msg.headers[\"MIME-Version\"] = \"1.0\"\n\n          text_cfgs.each do |c|\n            msg.add(c)\n          end",
    "comment": "Combines all known cloud_init configs into a multipart mixed MIME text message  @param [Vagrant::Machine] machine @param [Array<Vagrant::Util::Mime::Entity>] text_msg - One or more text configs @return [Vagrant::Util::Mime::Multipart] msg",
    "label": "",
    "id": "638"
  },
  {
    "raw_code": "def write_cfg_iso(machine, env, user_data, meta_data)\n          raise Errors::CreateIsoHostCapNotFound if !env[:env].host.capability?(:create_iso)\n\n          iso_path = catch(:iso_path) do\n            # This iso sentinel file is used to store the path of the\n            # generated iso file and its checksum. If the file does\n            # not exist, or the actual checksum of the file does not\n            # match that stored in the sentinel file, it is ignored\n            # and the iso is generated. This is used to prevent multiple\n            # iso file from being created over time.\n            iso_sentinel = env[:machine].data_dir.join(\"action_cloud_init_iso\")\n            if iso_sentinel.file?\n              checksum, path = iso_sentinel.read.chomp.split(\":\", 2)\n              if File.exist?(path) && Vagrant::Util::FileChecksum.new(path, :sha256).checksum == checksum\n                throw :iso_path, Pathname.new(path)\n              end",
    "comment": "Writes the contents of the guests cloud_init config to a tmp dir and passes that source directory along to the host cap to be written to an iso  @param [Vagrant::Machine] machine @param [Vagrant::Util::Mime::Multipart] user_data @param [Hash] meta_data",
    "label": "",
    "id": "639"
  },
  {
    "raw_code": "def attach_disk_config(machine, env, iso_path)\n          @logger.info(\"Adding cloud_init iso '#{iso_path}' to disk config\")\n          machine.config.vm.disk :dvd, file: iso_path, name: \"vagrant-cloud_init-disk\"\n          machine.config.vm.disks.each { |d| d.finalize! if d.type == :dvd && d.file == iso_path }\n        end",
    "comment": "Adds a new :dvd disk config with the given iso_path to be attached to the guest later  @param [Vagrant::Machine] machine @param [Vagrant::Environment] env @param [String] iso_path",
    "label": "",
    "id": "640"
  },
  {
    "raw_code": "def is_forwarded_already(extra_in_use, hostport, hostip)\n          hostip = '*' if hostip.nil? || hostip.empty?\n          # ret. false if none of the VMs we spun up had this port forwarded.\n          return false if not extra_in_use.has_key?(hostport)\n\n          # ret. true if the user has requested to bind on all interfaces but\n          # we already have a rule in one the VMs we spun up.\n          if hostip == '*'\n            if extra_in_use.fetch(hostport).size != 0\n              return true\n            else\n              return false\n            end",
    "comment": "This functions checks to see if the current instance's hostport and hostip for forwarding is in use by the virtual machines created previously.",
    "label": "",
    "id": "641"
  },
  {
    "raw_code": "def run_provisioner(env)\n          env[:provisioner].provision\n        end",
    "comment": "This is pulled out into a separate method so that users can subclass and implement custom behavior if they'd like to work around this step.",
    "label": "",
    "id": "642"
  },
  {
    "raw_code": "def initialize(app, env, check, **opts)\n          @app    = app\n          @logger = Log4r::Logger.new(\"vagrant::action::builtin::is_state\")\n          @check  = check\n          @invert = !!opts[:invert]\n        end",
    "comment": "Note: Any of the arguments can be arrays as well.  @param [Symbol] target_state The target state ID that means that the machine was properly shut down. @param [Symbol] source_state The source state ID that the machine must be in to be shut down.",
    "label": "",
    "id": "643"
  },
  {
    "raw_code": "def execute_inline!(inline, args)\n        script = Tempfile.new([\"vagrant-local-exec-script\", \".sh\"])\n        script.write(inline)\n        script.rewind\n        script.close\n\n        execute_script!(script.path, args)\n      ensure\n        if script\n          script.close\n          script.unlink\n        end",
    "comment": "Execute the inline script by writing it to a tempfile and executing.",
    "label": "",
    "id": "644"
  },
  {
    "raw_code": "def execute_script!(path, args)\n        path = File.expand_path(path, env.root_path)\n        FileUtils.chmod(\"+x\", path)\n\n        if args.is_a?(String)\n          args = \" #{args.to_s}\"\n        elsif args.is_a?(Array)\n          args = args.map { |a| quote_and_escape(a) }\n          args = \" #{args.join(\" \")}\"\n        end",
    "comment": "Execute the script, expanding the path relative to the current env root.",
    "label": "",
    "id": "645"
  },
  {
    "raw_code": "def execute!(*cmd)\n        if Vagrant::Util::Platform.windows?\n          execute_subprocess!(*cmd)\n        else\n          execute_exec!(*cmd)\n        end",
    "comment": "Execute the script, raising an exception if it fails.",
    "label": "",
    "id": "646"
  },
  {
    "raw_code": "def quote_and_escape(text, quote = '\"')\n        \"#{quote}#{text.gsub(/#{quote}/) { |m| \"#{m}\\\\#{m}#{m}\" }}#{quote}\"\n      end",
    "comment": "Quote and escape strings for shell execution, thanks to Capistrano.",
    "label": "",
    "id": "647"
  },
  {
    "raw_code": "def execute_exec!(*cmd)\n        @@logger.debug(\"executing command via exec: #{cmd.inspect}\")\n        Vagrant::Util::SafeExec.exec(cmd[0], *cmd[1..-1])\n      end",
    "comment": "Run the command as exec (unix).",
    "label": "",
    "id": "648"
  },
  {
    "raw_code": "def execute_subprocess!(*cmd)\n        @@logger.debug(\"executing command via subprocess: #{cmd.inspect}\")\n        cmd = cmd.dup << { notify: [:stdout, :stderr] }\n        result = Vagrant::Util::Subprocess.execute(*cmd) do |type, data|\n          if type == :stdout\n            @env.ui.info(data, new_line: false)\n          elsif type == :stderr\n            @env.ui.warn(data, new_line: false)\n          end",
    "comment": "Run the command as a subprocess (windows).",
    "label": "",
    "id": "649"
  },
  {
    "raw_code": "def missing?(obj)\n        obj.to_s.strip.empty?\n      end",
    "comment": "Determine if the given string is \"missing\" (blank) @return [true, false]",
    "label": "",
    "id": "650"
  },
  {
    "raw_code": "def args_valid?\n        return true if !args\n        return true if args.is_a?(String)\n        return true if args.is_a?(Integer)\n        if args.is_a?(Array)\n          args.each do |a|\n            return false if !a.kind_of?(String) && !a.kind_of?(Integer)\n          end",
    "comment": "Args are optional, but if they're provided we only support them as a string or as an array.",
    "label": "",
    "id": "651"
  },
  {
    "raw_code": "def execute(uploader)\n        cmd = []\n        cmd << \"-debug\" if !Vagrant.log_level.nil?\n        cmd << \"-vcs\" if config.vcs\n        cmd += config.includes.map { |v| [\"-include\", v] }\n        cmd += config.excludes.map { |v| [\"-exclude\", v] }\n        cmd += metadata.map { |k,v| [\"-metadata\", \"#{k}=#{v}\"] }\n        cmd += [\"-address\", config.address] if config.address\n        cmd += [\"-token\", config.token] if config.token\n        cmd << config.app\n        cmd << File.expand_path(config.dir, env.root_path)\n        Vagrant::Util::SafeExec.exec(uploader, *cmd.flatten)\n      end",
    "comment": "Executes the uploader with the proper flags based on the configuration. This function shouldn't return since it will exec, but might return if we're on a system that doesn't support exec, so handle that properly.",
    "label": "",
    "id": "652"
  },
  {
    "raw_code": "def uploader_path\n        # Determine the uploader path\n        if uploader = config.uploader_path\n          return uploader\n        end",
    "comment": "This returns the path to the uploader binary, or nil if it can't be found.  @return [String]",
    "label": "",
    "id": "653"
  },
  {
    "raw_code": "def metadata\n        box     = env.vagrantfile.config.vm.box\n        box_url = env.vagrantfile.config.vm.box_url\n\n        result = {}\n\n        if !box.nil? && !box.empty?\n          result[\"box\"] = box\n        end",
    "comment": "The metadata command for this push.  @return [Array<String>]",
    "label": "",
    "id": "654"
  },
  {
    "raw_code": "def include(filepath)\n        @includes << filepath\n      end",
    "comment": "Add the filepath to the list of includes @param [String] filepath",
    "label": "",
    "id": "655"
  },
  {
    "raw_code": "def exclude(filepath)\n        @excludes << filepath\n      end",
    "comment": "Add the filepath to the list of excludes @param [String] filepath",
    "label": "",
    "id": "656"
  },
  {
    "raw_code": "def missing?(obj)\n        obj.to_s.strip.empty?\n      end",
    "comment": "Determine if the given string is \"missing\" (blank) @return [true, false]",
    "label": "",
    "id": "657"
  },
  {
    "raw_code": "def token_from_vagrant_login(env)\n        client = VagrantPlugins::LoginCommand::Client.new(env)\n        client.token\n      end",
    "comment": "Attempt to load the token from disk using the vagrant-login plugin. If the constant is not defined, that means the user is operating in some bespoke and unsupported Ruby environment.  @param [Vagrant::Environment] env  @return [String, nil] the token, or nil if it does not exist",
    "label": "",
    "id": "658"
  },
  {
    "raw_code": "def verify_git_bin!(path)\n        if Vagrant::Util::Which.which(path).nil?\n          raise Errors::GitNotFound, bin: path\n        end",
    "comment": "Verify that git is installed. @raise [Errors::GitNotFound]",
    "label": "",
    "id": "659"
  },
  {
    "raw_code": "def verify_git_repo!(path)\n        if !File.directory?(git_dir(path))\n          raise Errors::NotAGitRepo, path: path\n        end",
    "comment": "Verify that the given path is a git directory. @raise [Errors::NotAGitRepo] @param [String]",
    "label": "",
    "id": "660"
  },
  {
    "raw_code": "def interpret_app(path)\n        File.basename(path)\n      end",
    "comment": "Interpret the name of the Heroku application from the given path. @param [String] path @return [String]",
    "label": "",
    "id": "661"
  },
  {
    "raw_code": "def git_dir(path)\n        \"#{path}/.git\"\n      end",
    "comment": "The git directory for the given path. @param [String] path @return [String]",
    "label": "",
    "id": "662"
  },
  {
    "raw_code": "def git_branch(path)\n        result = execute!(\"git\",\n          \"--git-dir\", git_dir(path),\n          \"--work-tree\", path,\n          \"symbolic-ref\",\n          \"HEAD\",\n        )\n\n        # Returns something like \"* master\"\n        result.stdout.sub(\"*\", \"\").strip\n      end",
    "comment": "The name of the current git branch. @param [String] path @return [String]",
    "label": "",
    "id": "663"
  },
  {
    "raw_code": "def git_push_heroku(remote, branch, path)\n        execute!(\"git\",\n          \"--git-dir\", git_dir(path),\n          \"--work-tree\", path,\n          \"push\", remote, \"#{branch}:master\",\n        )\n      end",
    "comment": "Push to the Heroku remote. @param [String] remote @param [String] branch",
    "label": "",
    "id": "664"
  },
  {
    "raw_code": "def has_git_remote?(remote, path)\n        result = execute!(\"git\",\n          \"--git-dir\", git_dir(path),\n          \"--work-tree\", path,\n          \"remote\",\n        )\n        remotes = result.stdout.split(/\\r?\\n/).map(&:strip)\n        remotes.include?(remote.to_s)\n      end",
    "comment": "Check if the git remote has the given remote. @param [String] remote @return [true, false]",
    "label": "",
    "id": "665"
  },
  {
    "raw_code": "def add_heroku_git_remote(remote, app, path)\n        execute!(\"git\",\n          \"--git-dir\", git_dir(path),\n          \"--work-tree\", path,\n          \"remote\", \"add\", remote, heroku_git_url(app),\n        )\n      end",
    "comment": "Add the Heroku to the current repository. @param [String] remote @param [String] app",
    "label": "",
    "id": "666"
  },
  {
    "raw_code": "def heroku_git_url(app)\n        \"git@heroku.com:#{app}.git\"\n      end",
    "comment": "The URL for this project on Heroku. @return [String]",
    "label": "",
    "id": "667"
  },
  {
    "raw_code": "def execute!(*cmd)\n        subproccmd = cmd.dup << { notify: [:stdout, :stderr] }\n        result = Vagrant::Util::Subprocess.execute(*subproccmd) do |type, data|\n          if type == :stdout\n            @env.ui.info(data, new_line: false)\n          elsif type == :stderr\n            @env.ui.warn(data, new_line: false)\n          end",
    "comment": "Execute the command, raising an exception if it fails. @return [Vagrant::Util::Subprocess::Result]",
    "label": "",
    "id": "668"
  },
  {
    "raw_code": "def missing?(obj)\n        obj.to_s.strip.empty?\n      end",
    "comment": "Determine if the given string is \"missing\" (blank) @return [true, false]",
    "label": "",
    "id": "669"
  },
  {
    "raw_code": "def connect(&block)\n        klass = config.secure ? SFTPAdapter : FTPAdapter\n        ftp = klass.new(config.host, config.username, config.password,\n          passive: config.passive)\n        ftp.connect(&block)\n      end",
    "comment": "Helper method for creating the FTP or SFTP connection. @yield [Adapter]",
    "label": "",
    "id": "670"
  },
  {
    "raw_code": "def all_files\n        files = glob(\"#{base_dir}/**/*\") + includes_files\n        filter_excludes!(files, config.excludes)\n        files.reject! { |f| !File.file?(f) }\n        files\n      end",
    "comment": "The list of all files that should be pushed by this push. This method only returns **files**, not folders or symlinks! @return [Array<String>]",
    "label": "",
    "id": "671"
  },
  {
    "raw_code": "def includes_files\n        includes = config.includes.flat_map do |i|\n          path = absolute_path_for(i, base_dir)\n          [path, \"#{path}/**/*\"]\n        end",
    "comment": "The list of files to include in addition to those specified in `dir`. @return [Array<String>]",
    "label": "",
    "id": "672"
  },
  {
    "raw_code": "def filter_excludes!(list, excludes)\n        excludes = Array(excludes)\n        excludes = excludes + DEFAULT_EXCLUDES\n        excludes = excludes.flat_map { |e| [e, \"#{e}/*\"] }\n\n        list.reject! do |file|\n          basename = relative_path_for(file, config.dir)\n\n          # Handle the special case where the file is outside of the working\n          # directory...\n          if basename.start_with?(\"../\")\n            basename = file\n          end",
    "comment": "Filter the excludes out of the given list. This method modifies the given list in memory!  @param [Array<String>] list the filepaths @param [Array<String>] excludes the exclude patterns or files",
    "label": "",
    "id": "673"
  },
  {
    "raw_code": "def glob(pattern)\n        Dir.glob(pattern, File::FNM_DOTMATCH).sort.reject do |file|\n          IGNORED_FILES.include?(File.basename(file))\n        end",
    "comment": "Get the list of files that match the given pattern. @return [Array<String>]",
    "label": "",
    "id": "674"
  },
  {
    "raw_code": "def absolute_path_for(path, parent)\n        path = Pathname.new(path)\n        return path if path.absolute?\n        File.expand_path(path, parent)\n      end",
    "comment": "The absolute path to the given `path` and `parent`, unless the given path is absolute. @return [String]",
    "label": "",
    "id": "675"
  },
  {
    "raw_code": "def relative_path_for(path, parent)\n        Pathname.new(path).relative_path_from(Pathname.new(parent)).to_s\n      rescue ArgumentError\n        return path\n      end",
    "comment": "The relative path from the given `parent`. If files exist on another device, this will probably blow up. @return [String]",
    "label": "",
    "id": "676"
  },
  {
    "raw_code": "def parse_host(host)\n        if host.include?(\":\")\n          split = host.split(\":\", 2)\n          [split[0], split[1].to_i]\n        else\n          [host, default_port]\n        end",
    "comment": "Parse the host into it's url and port parts. @return [Array]",
    "label": "",
    "id": "677"
  },
  {
    "raw_code": "def include(filepath)\n        @includes << filepath\n      end",
    "comment": "Add the filepath to the list of includes @param [String] filepath",
    "label": "",
    "id": "678"
  },
  {
    "raw_code": "def exclude(filepath)\n        @excludes << filepath\n      end",
    "comment": "Add the filepath to the list of excludes @param [String] filepath",
    "label": "",
    "id": "679"
  },
  {
    "raw_code": "def missing?(obj)\n        obj.to_s.strip.empty?\n      end",
    "comment": "Determine if the given string is \"missing\" (blank) @return [true, false]",
    "label": "",
    "id": "680"
  },
  {
    "raw_code": "def shell_cmd(opts)\n        case opts[:shell].to_s\n        when \"cmd\"\n          \"cmd.exe /c '#{opts[:command]}'\"\n        else\n          opts[:command]\n        end",
    "comment": "Wrap the shell if required. By default we are using powershell which requires no modification. If cmd is defined as shell, add prefix to start within cmd.exe",
    "label": "",
    "id": "681"
  },
  {
    "raw_code": "def shell_execute(connection, command, **opts)\n        opts[:shell] ||= machine_config_ssh.shell\n\n        command = shell_cmd(opts.merge(command: command))\n\n        @logger.info(\"Execute: #{command} - opts: #{opts}\")\n        exit_status = nil\n\n        # Open the channel so we can execute or command\n        channel = connection.open_channel do |ch|\n          marker_found = false\n          data_buffer = ''\n          stderr_marker_found = false\n          stderr_data_buffer = ''\n\n          @logger.debug(\"Base SSH exec command: #{command}\")\n          command = \"$ProgressPreference = 'SilentlyContinue';Write-Output #{CMD_GARBAGE_MARKER};[Console]::Error.WriteLine('#{CMD_GARBAGE_MARKER}');#{command}\"\n\n          ch.exec(command) do |ch2, _|\n            # Setup the channel callbacks so we can get data and exit status\n            ch2.on_data do |ch3, data|\n              # Filter out the clear screen command\n              data = remove_ansi_escape_codes(data)\n\n              if !marker_found\n                data_buffer << data\n                marker_index = data_buffer.index(CMD_GARBAGE_MARKER)\n                if marker_index\n                  marker_found = true\n                  data_buffer.slice!(0, marker_index + CMD_GARBAGE_MARKER.size)\n                  data.replace(data_buffer)\n                  data_buffer = nil\n                end",
    "comment": "Executes the command on an SSH connection within a login shell.",
    "label": "",
    "id": "682"
  },
  {
    "raw_code": "def upload(from, to)\n        to = Vagrant::Util::Platform.unix_windows_path(to)\n        @logger.debug(\"Uploading: #{from} to #{to}\")\n\n        if File.directory?(from)\n          if from.end_with?(\".\")\n            @logger.debug(\"Uploading directory contents of: #{from}\")\n            from = from.sub(/\\.$/, \"\")\n          else\n            @logger.debug(\"Uploading full directory container of: #{from}\")\n            to = File.join(to, File.basename(File.expand_path(from)))\n          end",
    "comment": "Note: I could not get Net::SFTP to throw a permissions denied error, even when uploading to a directory where I did not have write privileges. I believe this is because Windows SSH sessions are started in an elevated process.",
    "label": "",
    "id": "683"
  },
  {
    "raw_code": "def sftp_connect\n        # Connect to SFTP and yield the SFTP object\n        connect do |connection|\n          return yield connection.sftp\n        end",
    "comment": "Opens an SFTP connection and yields it so that you can download and upload files. SFTP works more reliably than SCP on Windows due to issues with shell quoting and escaping.",
    "label": "",
    "id": "684"
  },
  {
    "raw_code": "def connect(**opts)\n        connection = nil\n        super { |c| connection = c }\n\n        if !connection.instance_variable_get(:@winssh_patched)\n          open_chan = connection.method(:open_channel)\n          connection.define_singleton_method(:open_channel) do |*args, &chan_block|\n            open_chan.call(*args) do |ch|\n              exec = ch.method(:exec)\n              ch.define_singleton_method(:exec) do |command, &block|\n                command = Base64.strict_encode64(command.encode(\"UTF-16LE\", \"UTF-8\"))\n                command = \"powershell -NoLogo -NonInteractive -ExecutionPolicy Bypass \" \\\n                  \"-NoProfile -EncodedCommand #{command}\"\n                exec.call(command, &block)\n              end",
    "comment": "The WinSSH communicator connection provides isolated modification to the generated connection instances. This modification forces all provided commands to run within powershell",
    "label": "",
    "id": "685"
  },
  {
    "raw_code": "def filter(command)\n        command_filters.each { |c| command = c.filter(command) if c.accept?(command) }\n        command\n      end",
    "comment": "Filter the given Vagrant command to ensure compatibility with Windows  @param [String] The Vagrant shell command @returns [String] Windows runnable command or empty string",
    "label": "",
    "id": "686"
  },
  {
    "raw_code": "def command_filters\n        @command_filters ||= create_command_filters()\n      end",
    "comment": "All the available Linux command filters  @returns [Array] All Linux command filter instances",
    "label": "",
    "id": "687"
  },
  {
    "raw_code": "def self.winrm_info(machine)\n        info = {}\n        if machine.provider.capability?(:winrm_info)\n          info = machine.provider.capability(:winrm_info)\n          raise Errors::WinRMNotReady if !info\n        end",
    "comment": "Returns the host and port to access WinRM.  This asks the provider via the `winrm_info` capability if it exists, otherwise defaulting to its own heuristics.  @param [Vagrant::Machine] machine @return [Hash]",
    "label": "",
    "id": "688"
  },
  {
    "raw_code": "def self.winrm_address(machine)\n        addr = machine.config.winrm.host\n        return addr if addr\n\n        ssh_info = machine.ssh_info\n        raise Errors::WinRMNotReady if winrm_info_invalid?(ssh_info)\n        return ssh_info[:host]\n      end",
    "comment": "Returns the address to access WinRM. This does not contain the port.  @param [Vagrant::Machine] machine @return [String]",
    "label": "",
    "id": "689"
  },
  {
    "raw_code": "def self.winrm_port(machine, local=true)\n        host_port = machine.config.winrm.port\n        if machine.config.winrm.guest_port\n          # If we're not requesting a local port, return\n          # the guest port directly.\n          return machine.config.winrm.guest_port if !local\n\n          # Search by guest port if we can. We use a provider capability\n          # if we have it. Otherwise, we just scan the Vagrantfile defined\n          # ports.\n          port = nil\n          if machine.provider.capability?(:forwarded_ports)\n            Array(machine.provider.capability(:forwarded_ports)).each do |host, guest|\n              if guest == machine.config.winrm.guest_port\n                port = host\n                break\n              end",
    "comment": "Returns the port to access WinRM.  @param [Vagrant::Machine] machine @return [Integer]",
    "label": "",
    "id": "690"
  },
  {
    "raw_code": "def self.reset!\n        send(:remove_instance_variable, :@_init)\n      end",
    "comment": "@private Reset the cached init value. This is not considered a public API and should only be used for testing.",
    "label": "",
    "id": "691"
  },
  {
    "raw_code": "def upload(from, to)\n        file_manager = WinRM::FS::FileManager.new(connection)\n        if from.is_a?(String) && File.directory?(from)\n          if from.end_with?(\".\")\n            from = from[0, from.length - 1]\n          else\n            to = File.join(to, File.basename(File.expand_path(from)))\n          end",
    "comment": "@param from [Array<String>, String] a single path or folder, or an array of paths and folders to upload to the guest @param to [String] a path or folder on the guest to upload to @return [FixNum] Total size transfered from host to guest",
    "label": "",
    "id": "692"
  },
  {
    "raw_code": "def create_shell\n        winrm_info = Helper.winrm_info(@machine)\n\n        WinRMShell.new(\n          winrm_info[:host],\n          winrm_info[:port],\n          @machine.config.winrm\n        )\n      end",
    "comment": "This creates a new WinRMShell based on the information we know about this machine.",
    "label": "",
    "id": "693"
  },
  {
    "raw_code": "def execution_output(output, opts)\n        if opts[:shell] == :wql\n          return output\n        elsif opts[:error_check] && \\\n          !opts[:good_exit].include?(output.exitcode)\n          raise_execution_error(output, opts)\n        end",
    "comment": "Handles the raw WinRM shell result and converts it to a standard Vagrant communicator result",
    "label": "",
    "id": "694"
  },
  {
    "raw_code": "def connect(**opts)\n        if @connection && !@connection.closed?\n          # There is a chance that the socket is closed despite us checking\n          # 'closed?' above. To test this we need to send data through the\n          # socket.\n          #\n          # We wrap the check itself in a 5 second timeout because there\n          # are some cases where this will just hang.\n          begin\n            Timeout.timeout(5) do\n              @connection.exec!(\"\")\n            end",
    "comment": "Opens an SSH connection and yields it to a block.",
    "label": "",
    "id": "695"
  },
  {
    "raw_code": "def shell_cmd(opts)\n        sudo  = opts[:sudo]\n        shell = opts[:shell]\n\n        # Determine the shell to execute. Prefer the explicitly passed in shell\n        # over the default configured shell. If we are using `sudo` then we\n        # need to wrap the shell in a `sudo` call.\n        cmd = machine_config_ssh.shell\n        cmd = shell if shell\n        cmd = machine_config_ssh.sudo_command.gsub(\"%c\", cmd) if sudo\n        cmd\n      end",
    "comment": "The shell wrapper command used in shell_execute defined by the sudo and shell options.",
    "label": "",
    "id": "696"
  },
  {
    "raw_code": "def shell_execute(connection, command, **opts)\n        opts = {\n          sudo: false,\n          shell: nil\n        }.merge(opts)\n\n        sudo  = opts[:sudo]\n\n        @logger.info(\"Execute: #{command} (sudo=#{sudo.inspect})\")\n        exit_status = nil\n\n        # These variables are used to scrub PTY output if we're in a PTY\n        pty = false\n        pty_stdout = \"\"\n\n        # Open the channel so we can execute or command\n        channel = connection.open_channel do |ch|\n          if machine_config_ssh.pty\n            ch.request_pty do |ch2, success|\n              pty = success && command != \"\"\n\n              if success\n                @logger.debug(\"pty obtained for connection\")\n              else\n                @logger.warn(\"failed to obtain pty, will try to continue anyways\")\n              end",
    "comment": "Executes the command on an SSH connection within a login shell.",
    "label": "",
    "id": "697"
  },
  {
    "raw_code": "def scp_connect\n        # Connect to SCP and yield the SCP object\n        connect do |connection|\n          scp = Net::SCP.new(connection)\n          return yield scp\n        end",
    "comment": "Opens an SCP connection and yields it so that you can download and upload files.",
    "label": "",
    "id": "698"
  },
  {
    "raw_code": "def insecure_key?(path)\n        return false if !path\n        return false if !File.file?(path)\n        Dir.glob(Vagrant.source_root.join(\"keys\", \"vagrant.key.*\")).any? do |source_path|\n          File.read(path).chomp == File.read(source_path).chomp\n        end",
    "comment": "This will test whether path is the Vagrant insecure private key.  @param [String] path",
    "label": "",
    "id": "699"
  },
  {
    "raw_code": "def supports_key_type?(type)\n        if @connection.nil?\n          raise Vagrant::Errors::SSHNotReady\n        end",
    "comment": "Check if server supports given key type  @param [String, Symbol] type Key type @return [Boolean] @note This does not use a stable API and may be subject to unexpected breakage on net-ssh updates",
    "label": "",
    "id": "700"
  },
  {
    "raw_code": "def customize(command=nil)\n        @customizations << command if command\n      end",
    "comment": "This argument is nil only because the old style was deprecated and we didn't want to break Vagrantfiles. This was never removed and since we've moved onto V2 configuration, we might as well keep this around forever.",
    "label": "",
    "id": "701"
  },
  {
    "raw_code": "def upgrade(new)\n        warnings = []\n\n        new.vm.base_mac          = self.base_mac if self.base_mac\n        new.vm.box               = self.box if self.box\n        new.vm.box_url           = self.box_url if self.box_url\n        new.vm.guest             = self.guest if self.guest\n        new.vm.hostname          = self.host_name if self.host_name\n        new.vm.usable_port_range = self.auto_port_range if self.auto_port_range\n\n        if self.boot_mode\n          new.vm.provider :virtualbox do |vb|\n            # Enable the GUI if the boot mode is GUI.\n            vb.gui = (self.boot_mode.to_s == \"gui\")\n          end",
    "comment": "Upgrade to a V2 configuration",
    "label": "",
    "id": "702"
  },
  {
    "raw_code": "def self.exclude_to_regexp(exclude)\n        start_anchor = false\n\n        if exclude.start_with?(\"/\")\n          start_anchor = true\n        end",
    "comment": "This converts an rsync exclude pattern to a regular expression we can send to Listen.  Note: Listen expects a path relative to the parameter passed into the Listener, not a fully qualified path  @param [String]  - exclude path @return [Regexp] - A regex of the path, modified, to exclude",
    "label": "",
    "id": "703"
  },
  {
    "raw_code": "def self.rsync_chown_support?(machine)\n        if !RSYNC_CHOWN_REQUIREMENT.satisfied_by?(Gem::Version.new(local_rsync_version))\n          return false\n        end",
    "comment": "Check if rsync versions support using chown option  @param [Vagrant::Machine] machine The remote machine @return [Boolean]",
    "label": "",
    "id": "704"
  },
  {
    "raw_code": "def self.machine_rsync_version(machine)\n        if machine.guest.capability?(:rsync_command)\n          rsync_path = machine.guest.capability(:rsync_command)\n        else\n          rsync_path = \"rsync\"\n        end",
    "comment": "@return [String, nil] version of remote rsync",
    "label": "",
    "id": "705"
  },
  {
    "raw_code": "def self.local_rsync_version\n        if !@_rsync_version\n          r = Vagrant::Util::Subprocess.execute(\"rsync\", \"--version\")\n          vmatch = r.stdout.to_s.match(/version\\s+(?<version>[\\d.]+)\\s/)\n          if vmatch\n            @_rsync_version = vmatch[:version]\n          end",
    "comment": "@return [String, nil] version of local rsync",
    "label": "",
    "id": "706"
  },
  {
    "raw_code": "def self.reset!\n        instance_variables.each(&method(:remove_instance_variable))\n      end",
    "comment": "@private Reset the cached values for helper. This is not considered a public API and should only be used for testing.",
    "label": "",
    "id": "707"
  },
  {
    "raw_code": "def self.wsl_allow_non_drvfs?\n        true\n      end",
    "comment": "Enable rsync synced folders within WSL when in use on non-DrvFs file systems",
    "label": "",
    "id": "708"
  },
  {
    "raw_code": "def callback(paths, modified, added, removed)\n          @logger.info(\"File change callback called!\")\n          @logger.info(\"  - Modified: #{modified.inspect}\")\n          @logger.info(\"  - Added: #{added.inspect}\")\n          @logger.info(\"  - Removed: #{removed.inspect}\")\n\n          tosync = []\n          paths.each do |hostpath, folders|\n            # Find out if this path should be synced\n            found = catch(:done) do\n              [modified, added, removed].each do |changed|\n                changed.each do |listenpath|\n                  throw :done, true if listenpath.start_with?(hostpath)\n                end",
    "comment": "This is the callback that is called when any changes happen",
    "label": "",
    "id": "709"
  },
  {
    "raw_code": "def disable(machine, folders, opts)\n        folders.each do |_, data|\n          clean_folder_configuration(data)\n        end",
    "comment": "Nothing to do here but ensure folder options are scrubbed",
    "label": "",
    "id": "710"
  },
  {
    "raw_code": "def clean_folder_configuration(data)\n        return if !data.is_a?(Hash)\n        data.delete(:smb_password)\n        nil\n      end",
    "comment": "Remove data that should not be persisted within folder specific configuration  @param [Hash] data Folder configuration",
    "label": "",
    "id": "711"
  },
  {
    "raw_code": "def self.mount_options(machine, name, guest_path, options)\n          mount_options = options.fetch(:mount_options, [])\n          options[:smb_id] ||= name\n          detected_ids = detect_owner_group_ids(machine, guest_path, mount_options, options)\n          mount_uid = detected_ids[:uid]\n          mount_gid = detected_ids[:gid]\n\n          mnt_opts = []\n          if machine.env.host.capability?(:smb_mount_options)\n            mnt_opts += machine.env.host.capability(:smb_mount_options)\n          else\n            mnt_opts << \"sec=ntlmssp\"\n          end",
    "comment": "Returns mount options for a smb synced folder  @param [Machine] machine @param [String] name of mount @param [String] path of mount on guest @param [Hash] hash of mount options",
    "label": "",
    "id": "712"
  },
  {
    "raw_code": "def prepare_permission(machine, perm, opts)\n        key = \"map_#{perm}\".to_sym\n        return nil if opts.key?(key) && opts[key].nil?\n\n        # The options on the hash get priority, then the default\n        # values\n        value = opts.key?(key) ? opts[key] : machine.config.nfs.send(key)\n        return value if value != :auto\n\n        # Get UID/GID from folder if we've made it this far\n        # (value == :auto)\n        stat = File.stat(opts[:hostpath])\n        return stat.send(perm)\n      end",
    "comment": "Prepares the UID/GID settings for a single folder.",
    "label": "",
    "id": "713"
  },
  {
    "raw_code": "def define(name, **options, &block)\n        name = name.to_sym\n        strategy = options[:strategy] || name\n\n        @__defined_pushes[name] ||= []\n        @__defined_pushes[name] << [strategy.to_sym, block]\n      end",
    "comment": "Define a new push in the Vagrantfile with the given name.  @example vm.push.define \"ftp\"  @example vm.push.define \"ftp\" do |s| s.host = \"...\" end  @example vm.push.define \"production\", strategy: \"docker\" do |s| # ... end  @param [#to_sym] name The name of the this strategy. By default, this is also the name of the strategy, but the `:strategy` key can be given to customize this behavior @param [Hash] options The list of options ",
    "label": "",
    "id": "714"
  },
  {
    "raw_code": "def to_s\n        \"Push\"\n      end",
    "comment": "The String representation of this Push.  @return [String]",
    "label": "",
    "id": "715"
  },
  {
    "raw_code": "def merge(other)\n        super.tap do |result|\n          other_pushes = other.instance_variable_get(:@__defined_pushes)\n          new_pushes   = @__defined_pushes.dup\n\n          other_pushes.each do |key, tuples|\n            new_pushes[key] ||= []\n            new_pushes[key] += tuples\n          end",
    "comment": "Custom merge method",
    "label": "",
    "id": "716"
  },
  {
    "raw_code": "def validate(machine)\n        errors = { \"push\" => _detected_errors }\n\n        __compiled_pushes.each do |_, push|\n          config = push[1]\n          push_errors = config.validate(machine)\n\n          if push_errors\n            errors = Vagrant::Config::V2::Util.merge_errors(errors, push_errors)\n          end",
    "comment": "Validate all pushes",
    "label": "",
    "id": "717"
  },
  {
    "raw_code": "def __compiled_pushes\n        raise \"Must finalize first!\" if !@__finalized\n        @__compiled_pushes.dup\n      end",
    "comment": "This returns the list of compiled pushes as a hash by name.  @return [Hash<Symbol, Array<Class, Object>>]",
    "label": "",
    "id": "718"
  },
  {
    "raw_code": "def validate(machine)\n        errors = _detected_errors\n\n        if @sensitive && (!@sensitive.is_a?(Array) && !@sensitive.is_a?(String))\n          errors << I18n.t(\"vagrant.config.root.sensitive_bad_type\")\n        end",
    "comment": "Validate the configuration  @param [Vagrant::Machine, NilClass] machine Machine instance or nil @return [Hash]",
    "label": "",
    "id": "719"
  },
  {
    "raw_code": "def initialize\n        @logger = Log4r::Logger.new(\"vagrant::config::trigger\")\n\n        # Internal State\n        @_before_triggers = [] # An array of VagrantConfigTrigger objects\n        @_after_triggers  = [] # An array of VagrantConfigTrigger objects\n      end",
    "comment": "The TriggerConfig class is what gets called when a user defines a new trigger in their Vagrantfile. The two entry points are either `config.trigger.before` or `config.trigger.after`.",
    "label": "",
    "id": "720"
  },
  {
    "raw_code": "def before(*command, &block)\n        command.flatten!\n        blk = block\n\n        if command.last.is_a?(Hash)\n          if block_given?\n            extra_cfg = command.pop\n          else\n            # We were given a hash rather than a block,\n            # so the last element should be the \"config block\"\n            # and the rest are commands for the trigger\n            blk = command.pop\n          end",
    "comment": "------------------------------------------------------------------- Trigger before/after functions -------------------------------------------------------------------  Commands are expected to be ether: - splat + config.trigger.before :up, :destroy, :halt do |trigger|.... - array + config.trigger.before [:up, :destroy, :halt] do |trigger|....  Config is expected to be given as a block, or the last parameter as a hash  - block + config.trigger.before :up, :destroy, :halt do |trigger| trigger.option = \"option\" end - hash + config.trigger.before :up, :destroy, :halt, options: \"option\" Reads in and parses Vagrant command whitelist and settings for a defined trigger  @param [Symbol] command Vagrant command to create trigger on @param [Block] block The defined before block",
    "label": "",
    "id": "721"
  },
  {
    "raw_code": "def after(*command, &block)\n        command.flatten!\n        blk = block\n\n        if command.last.is_a?(Hash)\n          if block_given?\n            extra_cfg = command.pop\n          else\n            # We were given a hash rather than a block,\n            # so the last element should be the \"config block\"\n            # and the rest are commands for the trigger\n            blk = command.pop\n          end",
    "comment": "Reads in and parses Vagrant command whitelist and settings for a defined trigger  @param [Symbol] command Vagrant command to create trigger on @param [Block] block The defined after block",
    "label": "",
    "id": "722"
  },
  {
    "raw_code": "def create_trigger(command, block, extra_cfg=nil)\n        trigger = VagrantConfigTrigger.new(command)\n        if block.is_a?(Hash)\n          trigger.set_options(block)\n        else\n          block.call(trigger, VagrantConfigTrigger)\n          trigger.set_options(extra_cfg) if extra_cfg\n        end",
    "comment": "------------------------------------------------------------------- Internal methods, don't call these. ------------------------------------------------------------------- Creates a new trigger config. If a block is given, parse that block by calling it with the created trigger. Otherwise set the options if it's a hash.  @param [Symbol] command Vagrant command to create trigger on @param [Block] block The defined config block @param [Hash] extra_cfg Extra configurations for a block defined trigger (Optional) @return [VagrantConfigTrigger]",
    "label": "",
    "id": "723"
  },
  {
    "raw_code": "def finalize!\n        if !@_before_triggers.empty?\n          @_before_triggers.map { |t| t.finalize! }\n        end",
    "comment": "Iterates over all defined triggers and finalizes their config objects",
    "label": "",
    "id": "724"
  },
  {
    "raw_code": "def validate(machine)\n        errors = _detected_errors\n        @_before_triggers.each do |bt|\n          error = bt.validate(machine)\n          errors.concat error if !error.empty?\n        end",
    "comment": "Validate Trigger Arrays",
    "label": "",
    "id": "725"
  },
  {
    "raw_code": "def before_triggers\n        @_before_triggers\n      end",
    "comment": "return [Array]",
    "label": "",
    "id": "726"
  },
  {
    "raw_code": "def after_triggers\n        @_after_triggers\n      end",
    "comment": "return [Array]",
    "label": "",
    "id": "727"
  },
  {
    "raw_code": "def to_s\n        \"trigger\"\n      end",
    "comment": "The String representation of this Trigger.  @return [String]",
    "label": "",
    "id": "728"
  },
  {
    "raw_code": "def validate(machine)\n        errors = _detected_errors\n\n        if @private_key_path\n          @private_key_path.each do |raw_path|\n            path = File.expand_path(raw_path, machine.env.root_path)\n            if !File.file?(path)\n              errors << I18n.t(\n                \"vagrant.config.ssh.private_key_missing\",\n                path: raw_path)\n            end",
    "comment": "NOTE: This is _not_ a valid config validation method, since it returns an _array_ of strings rather than a Hash. This is meant to be used with a subclass that handles this.  @return [Array<String>]",
    "label": "",
    "id": "729"
  },
  {
    "raw_code": "def ruby(&block)\n        @ruby_block = block\n      end",
    "comment": "Config option `ruby` for a trigger which reads in a ruby block and sets it to be evaluated when the configured trigger fires. This method is only invoked when the regular \"block\" syntax is used. Otherwise the proc is set through the attr_accessor if the hash syntax is used.  @param [Proc] block",
    "label": "",
    "id": "730"
  },
  {
    "raw_code": "def validate(machine)\n        errors = _detected_errors\n\n        if @type && !VALID_TRIGGER_TYPES.include?(@type)\n          errors << I18n.t(\"vagrant.config.triggers.bad_trigger_type\",\n                           type: @type,\n                           trigger: @command,\n                           types: VALID_TRIGGER_TYPES.join(', '))\n        end",
    "comment": "@return [Array] array of strings of error messages from config option validation",
    "label": "",
    "id": "731"
  },
  {
    "raw_code": "def to_s\n        \"trigger config\"\n      end",
    "comment": "The String representation of this Trigger.  @return [String]",
    "label": "",
    "id": "732"
  },
  {
    "raw_code": "def validate(machine, provisioners)\n        errors = _detected_errors\n\n        provisioner_names = provisioners.map { |i| i.name.to_s if i.name != name }.compact\n\n        if ![TrueClass, FalseClass].include?(@communicator_required.class)\n          errors << I18n.t(\"vagrant.provisioners.base.wrong_type\", opt: \"communicator_required\", type: \"boolean\")\n        end",
    "comment": "Validates the before/after options  @param [Vagrant::Machine] machine - machine to validate against @param [Array] provisioners - Array of defined provisioners for the guest machine @return [Array] array of strings of error messages from config option validation",
    "label": "",
    "id": "733"
  },
  {
    "raw_code": "def invalid?\n        @invalid\n      end",
    "comment": "Returns whether the provisioner used was invalid or not. A provisioner is invalid if it can't be found.  @return [Boolean]",
    "label": "",
    "id": "734"
  },
  {
    "raw_code": "def host_name=(value)\n        @hostname = value\n      end",
    "comment": "This was from V1, but we just kept it here as an alias for hostname because too many people mess this up.",
    "label": "",
    "id": "735"
  },
  {
    "raw_code": "def merge(other)\n        super.tap do |result|\n          other_networks = other.instance_variable_get(:@__networks)\n\n          result.instance_variable_set(:@__networks, @__networks.merge(other_networks))\n\n          # Merge defined VMs by first merging the defined VM keys,\n          # preserving the order in which they were defined.\n          other_defined_vm_keys = other.instance_variable_get(:@__defined_vm_keys)\n          other_defined_vm_keys -= @__defined_vm_keys\n          new_defined_vm_keys   = @__defined_vm_keys + other_defined_vm_keys\n\n          # Merge the actual defined VMs.\n          other_defined_vms = other.instance_variable_get(:@__defined_vms)\n          new_defined_vms   = {}\n\n          @__defined_vms.each do |key, subvm|\n            new_defined_vms[key] = subvm.clone\n          end",
    "comment": "Custom merge method since some keys here are merged differently.",
    "label": "",
    "id": "736"
  },
  {
    "raw_code": "def synced_folder(hostpath, guestpath, options=nil)\n        if Vagrant::Util::Platform.windows?\n          # On Windows, Ruby just uses normal '/' for path seps, so\n          # just replace normal Windows style seps with Unix ones.\n          hostpath = hostpath.to_s.gsub(\"\\\\\", \"/\")\n        end",
    "comment": "Defines a synced folder pair. This pair of folders will be synced to/from the machine. Note that if the machine you're using doesn't support multi-directional syncing (perhaps an rsync backed synced folder) then the host is always synced to the guest but guest data may not be synced back to the host.  @param [String] hostpath Path to the host folder to share. If this is a relative path, it is relative to the location of the Vagrantfile. @param [String] guestpath Path on the guest to mount the shared folder. @param [Hash] options Additional options.",
    "label": "",
    "id": "737"
  },
  {
    "raw_code": "def network(type, **options)\n        options = options.dup\n        options[:protocol] ||= \"tcp\"\n\n        # Convert to symbol to allow strings\n        type = type.to_sym\n\n        if !options[:id]\n          default_id = nil\n\n          if type == :forwarded_port\n            # For forwarded ports, set the default ID to be the\n            # concat of host_ip, proto and host_port. This would ensure Vagrant\n            # caters for port forwarding in an IP aliased environment where\n            # different host IP addresses are to be listened on the same port.\n            default_id = \"#{options[:host_ip]}#{options[:protocol]}#{options[:host]}\"\n          end",
    "comment": "Define a way to access the machine via a network. This exposes a high-level abstraction for networking that may not directly map 1-to-1 for every provider. For example, AWS has no equivalent to \"port forwarding.\" But most providers will attempt to implement this in a way that behaves similarly.  `type` can be one of:  * `:forwarded_port` - A port that is accessible via localhost that forwards into the machine. * `:private_network` - The machine gets an IP that is not directly publicly accessible, but ideally accessible from this machine. * `:public_network` - The machine gets an IP on a shared network.  @param [Symbol] type Type of network @param [Hash] options Options for the network.",
    "label": "",
    "id": "738"
  },
  {
    "raw_code": "def provider(name, &block)\n        name = name.to_sym\n        @__providers[name] ||= []\n        @__provider_overrides[name] ||= []\n\n        # Add the provider to the ordering list\n        @__provider_order << name\n\n        if block_given?\n          @__providers[name] << block if block_given?\n\n          # If this block takes two arguments, then we curry it and store\n          # the configuration override for use later.\n          if block.arity == 2\n            @__provider_overrides[name] << block.curry[Vagrant::Config::V2::DummyConfig.new]\n          end",
    "comment": "Configures a provider for this VM.  @param [Symbol] name The name of the provider.",
    "label": "",
    "id": "739"
  },
  {
    "raw_code": "def defined_vm_keys\n        @__defined_vm_keys\n      end",
    "comment": "This returns the keys of the sub-vms in the order they were defined.",
    "label": "",
    "id": "740"
  },
  {
    "raw_code": "def disk(type, **options, &block)\n        disk_config = VagrantConfigDisk.new(type)\n\n        # Remove provider__option options before set_options, otherwise will\n        # show up as missing setting\n        # Extract provider hash options as well\n        provider_options = {}\n        options.delete_if do |p,o|\n          if o.is_a?(Hash) || p.to_s.include?(\"__\")\n            provider_options[p] = o\n            true\n          end",
    "comment": "Stores disk config options from Vagrantfile  @param [Symbol] type @param [Hash]   options @param [Block]  block",
    "label": "",
    "id": "741"
  },
  {
    "raw_code": "def cloud_init(type=nil, **options, &block)\n        type = type.to_sym if type\n\n        cloud_init_config = VagrantConfigCloudInit.new(type)\n\n        if block_given?\n          block.call(cloud_init_config, VagrantConfigCloudInit)\n        else\n          # config is hash\n          cloud_init_config.set_options(options)\n        end",
    "comment": "Stores config options for cloud_init  @param [Symbol] type @param [Hash]   options @param [Block]  block",
    "label": "",
    "id": "742"
  },
  {
    "raw_code": "def finalize!\n        # Defaults\n        @allowed_synced_folder_types = nil if @allowed_synced_folder_types == UNSET_VALUE\n        @base_mac = nil if @base_mac == UNSET_VALUE\n        @base_address = nil if @base_address == UNSET_VALUE\n        @boot_timeout = 300 if @boot_timeout == UNSET_VALUE\n        @box = nil if @box == UNSET_VALUE\n        @box_architecture = :auto if @box_architecture == UNSET_VALUE\n        # If box architecture value was set, force to string\n        if @box_architecture && @box_architecture != :auto\n          @box_architecture = @box_architecture.to_s\n        end",
    "comment": "------------------------------------------------------------------- Internal methods, don't call these. -------------------------------------------------------------------",
    "label": "",
    "id": "743"
  },
  {
    "raw_code": "def get_provider_config(name)\n        raise \"Must finalize first.\" if !@__finalized\n\n        @logger = Log4r::Logger.new(self.class.name.downcase)\n        @logger.info(\"looking up provider config for: #{name.inspect}\")\n\n        result = @__compiled_provider_configs[name]\n\n        @logger.info(\"provider config value that was stored: #{result.inspect}\")\n\n        # If no compiled configuration was found, then we try to just\n        # use the default configuration from the plugin.\n        if !result\n          @logger.info(\"no result so doing plugin config lookup using name: #{name.inspect}\")\n          config_class = Vagrant.plugin(\"2\").manager.provider_configs[name]\n          @logger.info(\"config class that we got for the lookup: #{config_class}\")\n          if config_class\n            result = config_class.new\n            result.finalize!\n          end",
    "comment": "This returns the compiled provider-specific configuration for the given provider.  @param [Symbol] name Name of the provider.",
    "label": "",
    "id": "744"
  },
  {
    "raw_code": "def get_provider_overrides(name)\n        (@__provider_overrides[name] || []).map do |p|\n          [\"2\", p]\n        end",
    "comment": "This returns a list of VM configurations that are overrides for this provider.  @param [Symbol] name Name of the provider @return [Array<Proc>]",
    "label": "",
    "id": "745"
  },
  {
    "raw_code": "def networks\n        @__networks.values\n      end",
    "comment": "This returns the list of networks configured.",
    "label": "",
    "id": "746"
  },
  {
    "raw_code": "def synced_folders\n        @__synced_folders\n      end",
    "comment": "This returns the list of synced folders",
    "label": "",
    "id": "747"
  },
  {
    "raw_code": "def validate(machine)\n        errors = _detected_errors\n\n        if @type && @type != DEFAULT_CONFIG_TYPE\n          errors << I18n.t(\"vagrant.cloud_init.incorrect_type_set\",\n                           type: @type,\n                           machine: machine.name,\n                           default_type: DEFAULT_CONFIG_TYPE)\n        end",
    "comment": "@return [Array] array of strings of error messages from config option validation",
    "label": "",
    "id": "748"
  },
  {
    "raw_code": "def to_s\n        \"cloud_init config\"\n      end",
    "comment": "The String representation of this config.  @return [String]",
    "label": "",
    "id": "749"
  },
  {
    "raw_code": "def add_provider_config(**options, &block)\n        current = {}\n        options.each do |k,v|\n          opts = k.to_s.split(\"__\")\n\n          if opts.size == 2\n            current[opts[0].to_sym] = {opts[1].to_sym => v}\n          elsif v.is_a?(Hash)\n            current[k] = v\n          else\n            @logger.warn(\"Disk option '#{k}' found that does not match expected provider disk config schema.\")\n          end",
    "comment": "Helper method for storing provider specific config options  Expected format is:  - `provider__diskoption: value` - `{provider: {diskoption: value, otherdiskoption: value, ...}`  Duplicates will be overriden  @param [Hash] options",
    "label": "",
    "id": "750"
  },
  {
    "raw_code": "def validate(machine)\n        errors = _detected_errors\n        # validate type with list of known disk types\n\n        if !DEFAULT_DISK_TYPES.include?(@type)\n          errors << I18n.t(\"vagrant.config.disk.invalid_type\", type: @type,\n                           types: DEFAULT_DISK_TYPES.join(', '))\n        end",
    "comment": "@return [Array] array of strings of error messages from config option validation",
    "label": "",
    "id": "751"
  },
  {
    "raw_code": "def to_s\n        \"disk config\"\n      end",
    "comment": "The String representation of this Disk.  @return [String]",
    "label": "",
    "id": "752"
  },
  {
    "raw_code": "def action(name)\n        action_method = \"action_#{name}\"\n        return Action.send(action_method) if Action.respond_to?(action_method)\n        nil\n      end",
    "comment": "@see Vagrant::Plugin::V2::Provider#action",
    "label": "",
    "id": "753"
  },
  {
    "raw_code": "def driver\n        if !@driver\n          if @machine.provider_config.compose\n            @driver = Driver::Compose.new(@machine)\n          else\n            @driver = Driver.new\n          end",
    "comment": "Returns the driver instance for this provider.",
    "label": "",
    "id": "754"
  },
  {
    "raw_code": "def host_vm\n        return @host_vm if @host_vm\n\n        vf_path           = @machine.provider_config.vagrant_vagrantfile\n        host_machine_name = @machine.provider_config.vagrant_machine || :default\n        if !vf_path\n          # We don't have a Vagrantfile path set, so we're going to use\n          # the default but we need to copy it into the data dir so that\n          # we don't write into our installation dir (we can't).\n          default_path = File.expand_path(\"../hostmachine/Vagrantfile\", __FILE__)\n          vf_path      = @machine.env.data_dir.join(\"docker-host\", \"Vagrantfile\")\n          begin\n            @machine.env.lock(\"docker-provider-hostvm\") do\n              vf_path.dirname.mkpath\n              FileUtils.cp(default_path, vf_path)\n            end",
    "comment": "This returns the {Vagrant::Machine} that is our host machine. It does not perform any action on the machine or verify it is running.  @return [Vagrant::Machine]",
    "label": "",
    "id": "755"
  },
  {
    "raw_code": "def host_vm_lock\n        hash = Digest::MD5.hexdigest(host_vm.data_dir.to_s)\n\n        # We do a process-level mutex on the outside, since we can\n        # wait for that a short amount of time. Then, we do a process lock\n        # on the inside, which will raise an exception if locked.\n        host_vm_mutex.synchronize do\n          @machine.env.lock(hash) do\n            return yield\n          end",
    "comment": "This acquires a lock on the host VM.",
    "label": "",
    "id": "756"
  },
  {
    "raw_code": "def host_vm_mutex\n        @@host_vm_mutex\n      end",
    "comment": "This is a process-local mutex that can be used by parallel providers to lock the host VM access.",
    "label": "",
    "id": "757"
  },
  {
    "raw_code": "def host_vm?\n        @machine.provider_config.force_host_vm\n      end",
    "comment": "This says whether or not Docker will be running within a VM rather than directly on our system. Docker needs to run in a VM when we're not on Linux, or not on a Linux that supports Docker.",
    "label": "",
    "id": "758"
  },
  {
    "raw_code": "def ssh_info\n        # If the container isn't running, we can't SSH into it\n        return nil if state.id != :running\n\n        port_name = \"#{@machine.config.ssh.guest_port}/tcp\"\n        network   = driver.inspect_container(@machine.id)['NetworkSettings']\n\n        if network[\"Ports\"][port_name].respond_to?(:first)\n          port_info = network[\"Ports\"][port_name].first\n        else\n          ip = network[\"IPAddress\"]\n          port = @machine.config.ssh.guest_port\n          if !ip.to_s.empty?\n            port_info = {\n              \"HostIp\" => ip,\n              \"HostPort\" => port\n            }\n          end",
    "comment": "Returns the SSH info for accessing the Container.",
    "label": "",
    "id": "759"
  },
  {
    "raw_code": "def self.action_run_command\n        Vagrant::Action::Builder.new.tap do |b|\n          # We just call the \"up\" action. We create a separate action\n          # to hold this though in case we modify it in the future, and\n          # so that we can switch on the \"machine_action\" env var.\n          b.use action_up\n        end",
    "comment": "This action starts another container just like the real one running but only for the purpose of running a single command rather than to exist long-running.",
    "label": "",
    "id": "760"
  },
  {
    "raw_code": "def self.action_up\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use Call, IsState, :not_created do |env, b2|\n            if env[:result]\n              b2.use HandleBox\n            end",
    "comment": "This action brings the \"machine\" up from nothing, including creating the container, configuring metadata, and booting.",
    "label": "",
    "id": "761"
  },
  {
    "raw_code": "def self.action_provision\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use ConfigValidate\n          b.use Call, IsState, :not_created do |env, b2|\n            if env[:result]\n              b2.use Message, I18n.t(\"docker_provider.messages.not_created\")\n              next\n            end",
    "comment": "This action just runs the provisioners on the machine.",
    "label": "",
    "id": "762"
  },
  {
    "raw_code": "def self.action_halt\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use Call, IsState, :host_state_unknown do |env, b2|\n            if env[:result]\n              b2.use HostMachine\n            end",
    "comment": "This is the action that is primarily responsible for halting the virtual machine, gracefully or by force.",
    "label": "",
    "id": "763"
  },
  {
    "raw_code": "def self.action_reload\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use ConfigValidate\n          b.use Call, IsState, :not_created do |env, b2|\n            if env[:result]\n              b2.use Message, I18n.t(\"docker_provider.messages.not_created\")\n              next\n            end",
    "comment": "This action is responsible for reloading the machine, which brings it down, sucks in new configuration, and brings the machine back up with the new configuration.",
    "label": "",
    "id": "764"
  },
  {
    "raw_code": "def self.action_destroy\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use Call, IsHostMachineCreated do |env, b2|\n            if !env[:result]\n              b2.use Message, I18n.t(\"docker_provider.messages.not_created\")\n              next\n            end",
    "comment": "This is the action that is primarily responsible for completely freeing the resources of the underlying virtual machine.",
    "label": "",
    "id": "765"
  },
  {
    "raw_code": "def self.action_ssh\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use Call, IsState, :not_created do |env, b2|\n            if env[:result]\n              raise Errors::ContainerNotCreatedError\n            end",
    "comment": "This is the action that will exec into an SSH shell.",
    "label": "",
    "id": "766"
  },
  {
    "raw_code": "def self.action_ssh_run\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use Call, IsState, :not_created do |env, b2|\n            if env[:result]\n              raise Errors::ContainerNotCreatedError\n            end",
    "comment": "This is the action that will run a single SSH command.",
    "label": "",
    "id": "767"
  },
  {
    "raw_code": "def build(dir, **opts, &block)\n        args = Array(opts[:extra_args])\n        args << dir\n        opts = {with_stderr: true}\n        result = execute('docker', 'build', *args, **opts, &block)\n        # Check for the new output format 'writing image sha256...'\n        # In this case, docker buildkit is enabled. Its format is different\n        # from standard docker\n        matches = result.scan(/writing image .+:([^\\s]+)/i).last\n        if !matches\n          # Check for outout of docker using containerd backend store\n          matches = result.scan(/exporting manifest list .+:([^\\s]+)/i).last\n        end",
    "comment": "Returns the id for a new container built from `docker build`. Raises an exception if the id was unable to be captured from the output  @return [String] id - ID matched from the docker build output.",
    "label": "",
    "id": "768"
  },
  {
    "raw_code": "def podman?\n        execute('docker', '--version').include?(\"podman\")\n      end",
    "comment": "Check if podman emulating docker CLI is enabled.  @return [Bool]",
    "label": "",
    "id": "769"
  },
  {
    "raw_code": "def read_used_ports\n        used_ports = Hash.new{|hash,key| hash[key] = Set.new}\n\n        all_containers.each do |c|\n          container_info = inspect_container(c)\n\n          active = container_info[\"State\"][\"Running\"]\n          next unless active # Ignore used ports on inactive containers\n\n          if container_info[\"HostConfig\"][\"PortBindings\"]\n            port_bindings = container_info[\"HostConfig\"][\"PortBindings\"]\n            next if port_bindings.empty? # Nothing defined, but not nil either\n\n            port_bindings.each do |guest_port,host_mapping|\n              host_mapping.each do |h|\n                if h[\"HostIp\"] == \"\"\n                  hostip = \"*\"\n                else\n                  hostip = h[\"HostIp\"]\n                end",
    "comment": "Reads all current docker containers and determines what ports are currently registered to be forwarded {2222=>#<Set: {\"127.0.0.1\"}>, 8080=>#<Set: {\"*\"}>, 9090=>#<Set: {\"*\"}>}  Note: This is this format because of what the builtin action for resolving colliding port forwards expects.  @return [Hash[Set]] used_ports - {forward_port: #<Set: {\"host ip address\"}>}",
    "label": "",
    "id": "770"
  },
  {
    "raw_code": "def inspect_container(cid)\n        JSON.parse(execute('docker', 'inspect', cid)).first\n      end",
    "comment": "Inspect the provided container  @param [String] cid ID or name of container @return [Hash]",
    "label": "",
    "id": "771"
  },
  {
    "raw_code": "def all_containers\n        execute('docker', 'ps', '-a', '-q', '--no-trunc').to_s.split\n      end",
    "comment": "@return [Array<String>] list of all container IDs",
    "label": "",
    "id": "772"
  },
  {
    "raw_code": "def docker_bridge_ip\n        bridge = inspect_network(\"bridge\")&.first\n        if bridge \n          bridge_ip = bridge.dig(\"IPAM\", \"Config\", 0, \"Gateway\")\n        end",
    "comment": "Attempts to first use the docker-cli tool to inspect the default bridge subnet Falls back to using /sbin/ip if that fails  @return [String] IP address of the docker bridge",
    "label": "",
    "id": "773"
  },
  {
    "raw_code": "def connect_network(network, cid, opts=nil)\n        command = ['docker', 'network', 'connect', network, cid].push(*opts)\n        output = execute(*command)\n        output\n      end",
    "comment": "@param [String] network - name of network to connect conatiner to @param [String] cid - container id @param [Array]  opts - An array of flags used for listing networks",
    "label": "",
    "id": "774"
  },
  {
    "raw_code": "def create_network(network, opts=nil)\n        command = ['docker', 'network', 'create', network].push(*opts)\n        output = execute(*command)\n        output\n      end",
    "comment": "@param [String] network - name of network to create @param [Array]  opts - An array of flags used for listing networks",
    "label": "",
    "id": "775"
  },
  {
    "raw_code": "def disconnect_network(network, cid)\n        command = ['docker', 'network', 'disconnect', network, cid, \"--force\"]\n        output = execute(*command)\n        output\n      end",
    "comment": "@param [String] network - name of network to disconnect container from @param [String] cid - container id",
    "label": "",
    "id": "776"
  },
  {
    "raw_code": "def inspect_network(network, opts=nil)\n        command = ['docker', 'network', 'inspect'] + Array(network)\n        command = command.push(*opts)\n        output = execute(*command)\n        begin\n          JSON.load(output)\n        rescue JSON::ParserError\n          @logger.warn(\"Failed to parse network inspection of network: #{network}\")\n          @logger.debug(\"Failed network output content: `#{output.inspect}`\")\n          nil\n        end",
    "comment": "@param [Array]  networks - list of networks to inspect @param [Array]  opts - An array of flags used for listing networks",
    "label": "",
    "id": "777"
  },
  {
    "raw_code": "def list_network(*opts)\n        command = ['docker', 'network', 'ls', *opts]\n        output = execute(*command)\n        output\n      end",
    "comment": "@param [String] opts - Flags used for listing networks",
    "label": "",
    "id": "778"
  },
  {
    "raw_code": "def prune_network(opts=nil)\n        command = ['docker', 'network', 'prune', '--force'].push(*opts)\n        output = execute(*command)\n        output\n      end",
    "comment": "Will delete _all_ defined but unused networks in the docker engine. Even networks not created by Vagrant.  @param [Array] opts - An array of flags used for listing networks",
    "label": "",
    "id": "779"
  },
  {
    "raw_code": "def rm_network(*network)\n        command = ['docker', 'network', 'rm', *network]\n        output = execute(*command)\n        output\n      end",
    "comment": "Delete network(s)  @param [String] network - name of network to remove",
    "label": "",
    "id": "780"
  },
  {
    "raw_code": "def execute(*cmd, **opts, &block)\n        @executor.execute(*cmd, **opts, &block)\n      end",
    "comment": "@param [Array] opts - An array of flags used for listing networks",
    "label": "",
    "id": "781"
  },
  {
    "raw_code": "def network_defined?(subnet_string)\n        all_networks = list_network_names\n\n        network_info = inspect_network(all_networks)\n        network_info.each do |network|\n          config = Array(network.dig(\"IPAM\", \"Config\"))\n          next if config.empty? || !config.first.is_a?(Hash)\n          if (config.first[\"Subnet\"] == subnet_string)\n            @logger.debug(\"Found existing network #{network[\"Name\"]} already configured with #{subnet_string}\")\n            return network[\"Name\"]\n          end",
    "comment": "###################### Docker network helpers ###################### Determines if a given network has been defined through vagrant with a given subnet string  @param [String] subnet_string - Subnet to look for @return [String] network name - Name of network with requested subnet.`nil` if not found",
    "label": "",
    "id": "782"
  },
  {
    "raw_code": "def network_containing_address(address)\n        names = list_network_names\n        networks = inspect_network(names)\n        return if !networks\n        networks.each do |net|\n          next if !net[\"IPAM\"]\n          config = net[\"IPAM\"][\"Config\"]\n          next if !config || config.size < 1\n          config.each do |opts|\n            subnet = IPAddr.new(opts[\"Subnet\"])\n            if subnet.include?(address)\n              return net[\"Name\"]\n            end",
    "comment": "Locate network which contains given address  @param [String] address IP address @return [String] network name",
    "label": "",
    "id": "783"
  },
  {
    "raw_code": "def existing_named_network?(network_name)\n        result = list_network_names\n        result.any?{|net_name| net_name == network_name}\n      end",
    "comment": "Looks to see if a docker network has already been defined with the given name  @param [String] network_name - name of network to look for @return [Bool]",
    "label": "",
    "id": "784"
  },
  {
    "raw_code": "def list_network_names\n        list_network(\"--format={{.Name}}\").split(\"\\n\").map(&:strip)\n      end",
    "comment": "@return [Array<String>] list of all docker networks",
    "label": "",
    "id": "785"
  },
  {
    "raw_code": "def network_used?(network)\n        result = inspect_network(network)\n        return nil if !result\n        return result.first[\"Containers\"].size > 0\n      end",
    "comment": "Returns true or false if network is in use or not. Nil if Vagrant fails to receive proper JSON from `docker network inspect`  @param [String] network - name of network to look for @return [Bool,nil]",
    "label": "",
    "id": "786"
  },
  {
    "raw_code": "def _links\n        @links\n      end",
    "comment": "-------------------------------------------------------------- Functions below should not be called by config files --------------------------------------------------------------",
    "label": "",
    "id": "787"
  },
  {
    "raw_code": "def ready?\n        # We can't be ready if we can't talk to the host VM\n        return false if !@host_vm.communicate.ready?\n\n        # We're ready if we can establish an SSH connection to the container\n        command = container_ssh_command\n        return false if !command\n        @host_vm.communicate.test(\"#{command} exit\")\n      end",
    "comment": "------------------------------------------------------------------- Communicator Methods -------------------------------------------------------------------",
    "label": "",
    "id": "788"
  },
  {
    "raw_code": "def container_ssh_command\n        # Get the container's SSH info\n        info = @machine.ssh_info\n        return nil if !info\n        info[:port] ||= 22\n\n        # Make sure our private keys are synced over to the host VM\n        ssh_args = sync_private_keys(info).map do |path|\n          \"-i #{path}\"\n        end",
    "comment": "------------------------------------------------------------------- Other Methods ------------------------------------------------------------------- This returns the raw SSH command string that can be used to connect via SSH to the container if you're on the same machine as the container.  @return [String]",
    "label": "",
    "id": "789"
  },
  {
    "raw_code": "def initialize(machine)\n          if !Vagrant::Util::Which.which(\"docker-compose\")\n            raise Errors::DockerComposeNotInstalledError\n          end",
    "comment": "Create a new driver instance  @param [Vagrant::Machine] machine Machine instance for this driver",
    "label": "",
    "id": "790"
  },
  {
    "raw_code": "def build(dir, **opts, &block)\n          name = machine.name.to_s\n          @logger.debug(\"Applying build for `#{name}` using `#{dir}` directory.\")\n          begin\n            update_composition do |composition|\n              services = composition[\"services\"] ||= {}\n              services[name] ||= {}\n              services[name][\"build\"] = {\"context\" => dir}\n              # Extract custom dockerfile location if set\n              if opts[:extra_args] && opts[:extra_args].include?(\"--file\")\n                services[name][\"build\"][\"dockerfile\"] = opts[:extra_args][opts[:extra_args].index(\"--file\") + 1]\n              end",
    "comment": "Updates the docker compose config file with the given arguments  @param [String] dir - local directory or git repo URL @param [Hash] opts - valid key: extra_args @param [Block] block @return [Nil]",
    "label": "",
    "id": "791"
  },
  {
    "raw_code": "def get_container_id(name)\n          compose_execute(\"ps\", \"-q\", name).chomp\n        end",
    "comment": "Lookup the ID for the container with the given name  @param [String] name Name of container @return [String] Container ID",
    "label": "",
    "id": "792"
  },
  {
    "raw_code": "def compose_execute(*cmd, **opts, &block)\n          synchronized do\n            execute(\"docker-compose\", \"-f\", composition_path.to_s,\n              \"-p\", machine.env.cwd.basename.to_s, *cmd, **opts, &block)\n          end",
    "comment": "Execute a `docker-compose` command",
    "label": "",
    "id": "793"
  },
  {
    "raw_code": "def apply_composition!(*args)\n          block = args.detect{|arg| arg.is_a?(Proc) }\n          execute_args = [\"up\", \"--remove-orphans\"]\n          if args.include?(:detach)\n            execute_args << \"-d\"\n          end",
    "comment": "Apply any changes made to the composition",
    "label": "",
    "id": "794"
  },
  {
    "raw_code": "def update_composition(*args)\n          synchronized do\n            machine.env.lock(\"compose\", retry: true) do\n              composition = get_composition\n              result = yield composition\n              write_composition(composition)\n              if args.include?(:apply) || (args.include?(:conditional) && result)\n                apply_composition!(*args)\n              end",
    "comment": "Update the composition and apply changes if requested  @param [Boolean] apply Apply composition changes",
    "label": "",
    "id": "795"
  },
  {
    "raw_code": "def get_composition\n          composition = {\"version\" => COMPOSE_VERSION.dup}\n          if composition_path.exist?\n            composition = Vagrant::Util::DeepMerge.deep_merge(composition, YAML.load(composition_path.read))\n          end",
    "comment": "@return [Hash] current composition contents",
    "label": "",
    "id": "796"
  },
  {
    "raw_code": "def write_composition(composition)\n          @logger.debug(\"Saving composition to `#{composition_path}`: #{composition}\")\n          tmp_file = Tempfile.new(\"vagrant-docker-compose\")\n          tmp_file.write(composition.to_yaml)\n          tmp_file.close\n          synchronized do\n            FileUtils.mv(tmp_file.path, composition_path.to_s)\n          end",
    "comment": "Save the composition  @param [Hash] composition New composition",
    "label": "",
    "id": "797"
  },
  {
    "raw_code": "def composition_path\n          data_directory.join(\"docker-compose.yml\")\n        end",
    "comment": "@return [Pathname] path to the docker-compose.yml file",
    "label": "",
    "id": "798"
  },
  {
    "raw_code": "def execute_single(machine, options)\n          command = [\"docker\", \"logs\"]\n          command << \"--follow\" if options[:follow]\n          command << machine.id\n\n          output_options = {}\n          output_options[:prefix] = false if !options[:prefix]\n\n          data_acc = \"\"\n          machine.provider.driver.execute(*command) do |type, data|\n            # Accumulate the data so we only output lines at a time\n            data_acc << data\n\n            # If we have a newline, then output all the lines we have so far\n            if data_acc.include?(\"\\n\")\n              lines    = data_acc.split(\"\\n\")\n\n              if !data_acc.end_with?(\"\\n\")\n                data_acc = lines.pop.chomp\n              else\n                data_acc = \"\"\n              end",
    "comment": "Executes the \"docker logs\" command on a single machine and proxies the output to our UI.",
    "label": "",
    "id": "799"
  },
  {
    "raw_code": "def call(env)\n          env[:machine].provider_config.ports.each do |p|\n            host_ip = nil\n            protocol = \"tcp\"\n            host, guest = p.split(\":\", 2)\n            if guest.include?(\":\")\n              host_ip = host\n              host, guest = guest.split(\":\", 2)\n            end",
    "comment": "Converts the `ports` docker provider param into proper network configs of type :forwarded_port",
    "label": "",
    "id": "800"
  },
  {
    "raw_code": "def port_check(env, host_port)\n          extra_in_use = env[:port_collision_extra_in_use]\n\n          if extra_in_use\n            return extra_in_use.include?(host_port.to_s)\n          else\n            return false\n          end",
    "comment": "This check is required the docker provider. Containers can bind ports but be halted. We don't want new containers to grab these bound ports, so this check is here for that since the checks above won't detect it  @param [Vagrant::Environment] env @param [String] host_port @returns [Bool]",
    "label": "",
    "id": "801"
  },
  {
    "raw_code": "def using_nfs?\n          @machine.config.vm.synced_folders.any? { |_, opts| opts[:type] == :nfs }\n        end",
    "comment": "We're using NFS if we have any synced folder with NFS configured. If we are not using NFS we don't need to do the extra work to populate these fields in the environment.",
    "label": "",
    "id": "802"
  },
  {
    "raw_code": "def add_ips_to_env!(env)\n          provider = env[:machine].provider\n\n          host_ip    = provider.driver.docker_bridge_ip\n          machine_ip = provider.ssh_info[:host]\n\n          raise Vagrant::Errors::NFSNoHostonlyNetwork if !host_ip || !machine_ip\n\n          env[:nfs_host_ip]    = host_ip\n          env[:nfs_machine_ip] = machine_ip\n        end",
    "comment": "Extracts the proper host and guest IPs for NFS mounts and stores them in the environment for the SyncedFolder action to use them in mounting.  The ! indicates that this method modifies its argument.",
    "label": "",
    "id": "803"
  },
  {
    "raw_code": "def generate_connect_cli_arguments(options)\n          options.map do |key, value|\n            # If value is false, option is not set\n            next if value.to_s == \"false\"\n            # If value is true, consider feature flag with no value\n            opt = value.to_s == \"true\" ? [] : [value]\n            opt.unshift(\"--#{key.to_s.tr(\"_\", \"-\")}\")\n          end.flatten.compact\n        end",
    "comment": "Generate CLI arguments for creating the docker network.  @param [Hash] options Options from the network config @returns[Array<String> Network create arguments",
    "label": "",
    "id": "804"
  },
  {
    "raw_code": "def call(env)\n          # If we are using a host VM, then don't worry about it\n          machine = env[:machine]\n          if machine.provider.host_vm?\n            @logger.debug(\"Not setting up networks because docker host_vm is in use\")\n            return @app.call(env)\n          end",
    "comment": "Execute the action",
    "label": "",
    "id": "805"
  },
  {
    "raw_code": "def generate_create_cli_arguments(options)\n          options.map do |key, value|\n            # If value is false, option is not set\n            next if value.to_s == \"false\"\n            # If value is true, consider feature flag with no value\n            opt = value.to_s == \"true\" ? [] : [value]\n            opt.unshift(\"--#{key.to_s.tr(\"_\", \"-\")}\")\n          end.flatten.compact\n        end",
    "comment": "Generate CLI arguments for creating the docker network.  @param [Hash] options Options from the network config @returns[Array<String>] Network create arguments",
    "label": "",
    "id": "806"
  },
  {
    "raw_code": "def list_interfaces\n          Socket.getifaddrs.find_all do |i|\n            !i.addr.nil? && i.addr.ip? && !i.addr.ipv4_loopback? &&\n              !i.addr.ipv6_loopback? && !i.addr.ipv6_linklocal?\n          end",
    "comment": "@return [Array<Socket::Ifaddr>] interface list",
    "label": "",
    "id": "807"
  },
  {
    "raw_code": "def validate_network_name!(network_name, env)\n          if !env[:machine].provider.driver.existing_named_network?(network_name)\n            raise Errors::NetworkNameUndefined,\n              network_name: network_name\n          end",
    "comment": "Validates that a network name exists. If it does not exist, an exception is raised.  @param [String] network_name Name of existing network @param [Hash] env Local call env @return [Boolean]",
    "label": "",
    "id": "808"
  },
  {
    "raw_code": "def validate_network_configuration!(network_name, root_options, network_options, driver)\n          if root_options[:ip] &&\n              driver.network_containing_address(root_options[:ip]) != network_name\n            raise Errors::NetworkAddressInvalid,\n              address: root_options[:ip],\n              network_name: network_name\n          end",
    "comment": "Validates that the provided options are compatible with a pre-existing network. Raises exceptions on invalid configurations  @param [String] network_name Name of the network @param [Hash] root_options Root networking options @param [Hash] network_options Docker scoped networking options @param [Driver] driver Docker driver @return [Boolean]",
    "label": "",
    "id": "809"
  },
  {
    "raw_code": "def process_private_network(root_options, network_options, env)\n          if root_options[:name] && validate_network_name!(root_options[:name], env)\n            network_name = root_options[:name]\n          end",
    "comment": "Generate configuration for private network  @param [Hash] root_options Root networking options @param [Hash] net_options Docker scoped networking options @param [Hash] env Local call env @return [String, Hash] Network name and updated network_options",
    "label": "",
    "id": "810"
  },
  {
    "raw_code": "def process_public_network(root_options, net_options, env)\n          if root_options[:name] && validate_network_name!(root_options[:name], env)\n            network_name = root_options[:name]\n          end",
    "comment": "Generate configuration for public network  TODO: When the Vagrant installer upgrades to Ruby 2.5.x, remove all instances of the roundabout way of determining a prefix and instead just use the built-in `.prefix` method  @param [Hash] root_options Root networking options @param [Hash] net_options Docker scoped networking options @param [Hash] env Local call env @return [String, Hash] Network name and updated network_options",
    "label": "",
    "id": "811"
  },
  {
    "raw_code": "def request_public_gateway(network_options, interface, env)\n          subnet = IPAddr.new(network_options[:subnet])\n          gateway = nil\n          while !gateway\n            gateway = env[:ui].ask(I18n.t(\n              \"docker_provider.network_bridge_gateway_request\",\n              interface: interface,\n              default_gateway: network_options[:gateway]) + \" \",\n              prefix: false\n            ).strip\n            if gateway.empty?\n              gateway = network_options[:gateway]\n            end",
    "comment": "Request the gateway address for the public network  @param [Hash] network_options Docker scoped networking options @param [String] interface The bridge interface used @param [Hash] env Local call env @return [String] Gateway address",
    "label": "",
    "id": "812"
  },
  {
    "raw_code": "def request_public_iprange(network_options, interface, env)\n          return network_options[:ip_range] if network_options[:ip_range]\n          subnet = IPAddr.new(network_options[:subnet])\n          env[:ui].info(I18n.t(\n            \"docker_provider.network_bridge_iprange_info\") + \"\\n\",\n            prefix: false\n          )\n          range = nil\n          while !range\n            range = env[:ui].ask(I18n.t(\n              \"docker_provider.network_bridge_iprange_request\",\n              interface: interface.name,\n              default_range: network_options[:subnet]) + \" \",\n              prefix: false\n            ).strip\n            if range.empty?\n              range = network_options[:subnet]\n            end",
    "comment": "Request the IP range allowed for use by docker when creating a new public network  TODO: When the Vagrant installer upgrades to Ruby 2.5.x, remove all instances of the roundabout way of determining a prefix and instead just use the built-in `.prefix` method  @param [Hash] network_options Docker scoped networking options @param [Socket::Ifaddr] interface The bridge interface used @param [Hash] env Local call env @return [String] Address range",
    "label": "",
    "id": "813"
  },
  {
    "raw_code": "def call(env)\n          # If we are using a host VM, then don't worry about it\n          machine = env[:machine]\n          if machine.provider.host_vm?\n            @logger.debug(\"Not setting up networks because docker host_vm is in use\")\n            return @app.call(env)\n          end",
    "comment": "Execute the action",
    "label": "",
    "id": "814"
  },
  {
    "raw_code": "def action(name)\n        # Attempt to get the action method from the Action class if it\n        # exists, otherwise return nil to show that we don't support the\n        # given action.\n        action_method = \"action_#{name}\"\n        return Action.send(action_method) if Action.respond_to?(action_method)\n        nil\n      end",
    "comment": "@see Vagrant::Plugin::V1::Provider#action",
    "label": "",
    "id": "815"
  },
  {
    "raw_code": "def machine_id_changed\n        id = @machine.id\n\n        begin\n          @logger.debug(\"Instantiating the driver for machine ID: #{@machine.id.inspect}\")\n          @driver = Driver::Meta.new(id)\n        rescue Driver::Meta::VMNotFound\n          # The virtual machine doesn't exist, so we probably have a stale\n          # ID. Just clear the id out of the machine and reload it.\n          @logger.debug(\"VM not found! Clearing saved machine ID and reloading.\")\n          id = nil\n          retry\n        end",
    "comment": "If the machine ID changed, then we need to rebuild our underlying driver.",
    "label": "",
    "id": "816"
  },
  {
    "raw_code": "def ssh_info\n        # If the VM is not running that we can't possibly SSH into it\n        return nil if state.id != :running\n\n        # Return what we know. The host is always \"127.0.0.1\" because\n        # VirtualBox VMs are always local. The port we try to discover\n        # by reading the forwarded ports.\n        return {\n          host: \"127.0.0.1\",\n          port: @driver.ssh_port(@machine.config.ssh.guest_port)\n        }\n      end",
    "comment": "Returns the SSH info for accessing the VirtualBox VM.",
    "label": "",
    "id": "817"
  },
  {
    "raw_code": "def state\n        # We have to check if the UID matches to avoid issues with\n        # VirtualBox.\n        if Vagrant::Util::Platform.wsl_windows_access_bypass?(@machine.data_dir)\n          @logger.warn(\"Skipping UID check on machine by user request for WSL Windows access.\")\n        else\n          uid = @machine.uid\n          if uid && uid.to_s != Process.uid.to_s\n            raise Vagrant::Errors::VirtualBoxUserMismatch,\n              original_uid: uid.to_s,\n              uid: Process.uid.to_s\n          end",
    "comment": "Return the state of VirtualBox virtual machine by actually querying VBoxManage.  @return [Symbol]",
    "label": "",
    "id": "818"
  },
  {
    "raw_code": "def to_s\n        id = @machine.id ? @machine.id : \"new VM\"\n        \"VirtualBox (#{id})\"\n      end",
    "comment": "Returns a human-friendly string version of this provider which includes the machine's ID that this provider represents, if it has one.  @return [String]",
    "label": "",
    "id": "819"
  },
  {
    "raw_code": "def self.action_boot\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckAccessible\n          b.use CleanMachineFolder\n          b.use SetName\n          b.use ClearForwardedPorts\n          b.use Provision\n          b.use EnvSet, port_collision_repair: true\n          b.use PrepareForwardedPortCollisionParams\n          b.use HandleForwardedPortCollisions\n          b.use PrepareNFSValidIds\n          b.use SyncedFolderCleanup\n          b.use SyncedFolders\n          b.use PrepareNFSSettings\n          b.use SetDefaultNICType\n          b.use ClearNetworkInterfaces\n          b.use Network\n          b.use NetworkFixIPv6\n          b.use ForwardPorts\n          b.use SetHostname\n          b.use SaneDefaults\n          b.use CloudInitSetup\n          b.use CleanupDisks\n          b.use Disk\n          b.use Customize, \"pre-boot\"\n          b.use Boot\n          b.use Customize, \"post-boot\"\n          b.use WaitForCommunicator, [:starting, :running, :paused]\n          b.use CloudInitWait\n          b.use Customize, \"post-comm\"\n          b.use CheckGuestAdditions\n        end",
    "comment": "This action boots the VM, assuming the VM is in a state that requires a bootup (i.e. not saved).",
    "label": "",
    "id": "820"
  },
  {
    "raw_code": "def self.action_destroy\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use Call, Created do |env1, b2|\n            if !env1[:result]\n              b2.use MessageNotCreated\n              next\n            end",
    "comment": "This is the action that is primarily responsible for completely freeing the resources of the underlying virtual machine.",
    "label": "",
    "id": "821"
  },
  {
    "raw_code": "def self.action_halt\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use Call, Created do |env, b2|\n            if env[:result]\n              b2.use CheckAccessible\n              b2.use DiscardState\n\n              b2.use Call, IsPaused do |env2, b3|\n                next if !env2[:result]\n                b3.use Resume\n              end",
    "comment": "This is the action that is primarily responsible for halting the virtual machine, gracefully or by force.",
    "label": "",
    "id": "822"
  },
  {
    "raw_code": "def self.action_package\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use Call, Created do |env1, b2|\n            if !env1[:result]\n              b2.use MessageNotCreated\n              next\n            end",
    "comment": "This action packages the virtual machine into a single box file.",
    "label": "",
    "id": "823"
  },
  {
    "raw_code": "def self.action_provision\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use ConfigValidate\n          b.use Call, Created do |env1, b2|\n            if !env1[:result]\n              b2.use MessageNotCreated\n              next\n            end",
    "comment": "This action just runs the provisioners on the machine.",
    "label": "",
    "id": "824"
  },
  {
    "raw_code": "def self.action_reload\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use Call, Created do |env1, b2|\n            if !env1[:result]\n              b2.use MessageNotCreated\n              next\n            end",
    "comment": "This action is responsible for reloading the machine, which brings it down, sucks in new configuration, and brings the machine back up with the new configuration.",
    "label": "",
    "id": "825"
  },
  {
    "raw_code": "def self.action_resume\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use Call, Created do |env, b2|\n            if env[:result]\n              b2.use CheckAccessible\n              b2.use EnvSet, port_collision_repair: false\n              b2.use PrepareForwardedPortCollisionParams\n              b2.use HandleForwardedPortCollisions\n              b2.use Resume\n              b2.use Provision\n              b2.use WaitForCommunicator, [:restoring, :running]\n            else\n              b2.use MessageNotCreated\n            end",
    "comment": "This is the action that is primarily responsible for resuming suspended machines.",
    "label": "",
    "id": "826"
  },
  {
    "raw_code": "def self.action_snapshot_restore\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use Call, Created do |env, b2|\n            if !env[:result]\n              raise Vagrant::Errors::VMNotCreatedError\n            end",
    "comment": "This is the action that is primarily responsible for restoring a snapshot",
    "label": "",
    "id": "827"
  },
  {
    "raw_code": "def self.action_snapshot_save\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use Call, Created do |env, b2|\n            if env[:result]\n              b2.use SnapshotSave\n            else\n              b2.use MessageNotCreated\n            end",
    "comment": "This is the action that is primarily responsible for saving a snapshot",
    "label": "",
    "id": "828"
  },
  {
    "raw_code": "def self.action_ssh\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use CheckCreated\n          b.use CheckAccessible\n          b.use CheckRunning\n          b.use SSHExec\n        end",
    "comment": "This is the action that will exec into an SSH shell.",
    "label": "",
    "id": "829"
  },
  {
    "raw_code": "def self.action_ssh_run\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use CheckCreated\n          b.use CheckAccessible\n          b.use CheckRunning\n          b.use SSHRun\n        end",
    "comment": "This is the action that will run a single SSH command.",
    "label": "",
    "id": "830"
  },
  {
    "raw_code": "def self.action_start\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use ConfigValidate\n          b.use BoxCheckOutdated\n          b.use Call, IsRunning do |env, b2|\n            # If the VM is running, run the necessary provisioners\n            if env[:result]\n              b2.use action_provision\n              next\n            end",
    "comment": "This action starts a VM, assuming it is already imported and exists. A precondition of this action is that the VM exists.",
    "label": "",
    "id": "831"
  },
  {
    "raw_code": "def self.action_suspend\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n          b.use Call, Created do |env, b2|\n            if env[:result]\n              b2.use CheckAccessible\n              b2.use Suspend\n            else\n              b2.use MessageNotCreated\n            end",
    "comment": "This is the action that is primarily responsible for suspending the virtual machine.",
    "label": "",
    "id": "832"
  },
  {
    "raw_code": "def self.action_sync_folders\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use PrepareNFSValidIds\n          b.use SyncedFolders\n          b.use PrepareNFSSettings\n        end",
    "comment": "This is the action that is called to sync folders to a running machine without a reboot.",
    "label": "",
    "id": "833"
  },
  {
    "raw_code": "def self.action_up\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckVirtualbox\n\n          # Handle box_url downloading early so that if the Vagrantfile\n          # references any files in the box or something it all just\n          # works fine.\n          b.use Call, Created do |env, b2|\n            if !env[:result]\n              b2.use HandleBox\n            end",
    "comment": "This action brings the machine up from nothing, including importing the box, configuring metadata, and booting.",
    "label": "",
    "id": "834"
  },
  {
    "raw_code": "def driver(machine)\n        machine.provider.driver\n      end",
    "comment": "This is here so that we can stub it for tests",
    "label": "",
    "id": "835"
  },
  {
    "raw_code": "def share_folders(machine, folders, transient)\n        defs = []\n        warn_user_symlink = false\n\n        folders.each do |id, data|\n          hostpath = data[:hostpath]\n          if !data[:hostpath_exact]\n            hostpath = Vagrant::Util::Platform.cygwin_windows_path(hostpath)\n          end",
    "comment": "share_folders sets up the shared folder definitions on the VirtualBox VM.  The transient parameter determines if we're FORCING transient or not. If this is false, then any shared folders will be shared as non-transient unless they've specifically asked for transient.",
    "label": "",
    "id": "836"
  },
  {
    "raw_code": "def self.forwarded_ports(machine)\n        return nil if machine.state.id != :running\n\n        {}.tap do |result|\n          machine.provider.driver.read_forwarded_ports.each do |_, _, h, g|\n            result[h] = g\n          end",
    "comment": "Reads the forwarded ports that currently exist on the machine itself. This raises an exception if the machine isn't running.  This also may not match up with configured forwarded ports, because Vagrant auto port collision fixing may have taken place.  @return [Hash<Integer, Integer>] Host => Guest port mappings.",
    "label": "",
    "id": "837"
  },
  {
    "raw_code": "def self.nic_mac_addresses(machine)\n        machine.provider.driver.read_mac_addresses\n      end",
    "comment": "Reads the network interface card MAC addresses and returns them.  @return [Hash<String, String>] Adapter => MAC address",
    "label": "",
    "id": "838"
  },
  {
    "raw_code": "def self.snapshot_list(machine)\n        return [] if machine.id.nil?\n        machine.provider.driver.list_snapshots(machine.id)\n      end",
    "comment": "Returns a list of the snapshots that are taken on this machine.  @return [Array<String>] Snapshot Name",
    "label": "",
    "id": "839"
  },
  {
    "raw_code": "def customize(*command)\n        event   = command.first.is_a?(String) ? command.shift : \"pre-boot\"\n        command = command[0]\n        @customizations << [event, command]\n      end",
    "comment": "Customize the VM by calling `VBoxManage` with the given arguments.  When called multiple times, the customizations will be applied in the order given.  The special `:name` parameter in the command will be replaced with the unique ID or name of the virtual machine. This is useful for parameters to `modifyvm` and the like.  @param [Array] command An array of arguments to pass to VBoxManage.",
    "label": "",
    "id": "840"
  },
  {
    "raw_code": "def network_adapter(slot, type, **opts)\n        @network_adapters[slot] = [type, opts]\n      end",
    "comment": "This defines a network adapter that will be added to the VirtualBox virtual machine in the given slot.  @param [Integer] slot The slot for this network adapter. @param [Symbol] type The type of adapter.",
    "label": "",
    "id": "841"
  },
  {
    "raw_code": "def memory=(size)\n        customize(\"pre-boot\", [\"modifyvm\", :id, \"--memory\", size.to_s])\n      end",
    "comment": "Shortcut for setting memory size for the virtual machine. Calls #customize internally.  @param size [Integer, String] the memory size in MB",
    "label": "",
    "id": "842"
  },
  {
    "raw_code": "def cpus=(count)\n        customize(\"pre-boot\", [\"modifyvm\", :id, \"--cpus\", count.to_i])\n      end",
    "comment": "Shortcut for setting CPU count for the virtual machine. Calls #customize internally.  @param count [Integer, String] the count of CPUs",
    "label": "",
    "id": "843"
  },
  {
    "raw_code": "def finalize!\n        # Default is to auto the DNS proxy\n        @auto_nat_dns_proxy = true if @auto_nat_dns_proxy == UNSET_VALUE\n\n        if @check_guest_additions == UNSET_VALUE\n          @check_guest_additions = true\n        end",
    "comment": "This is the hook that is called to finalize the object before it is put into use.",
    "label": "",
    "id": "844"
  },
  {
    "raw_code": "def reconfig_host_only(options)\n          return super if !use_host_only_nets?\n        end",
    "comment": "Disabled when host only nets are in use",
    "label": "",
    "id": "845"
  },
  {
    "raw_code": "def remove_dhcp_server(*_, **_)\n          super if !use_host_only_nets?\n        end",
    "comment": "Disabled when host only nets are in use since the host only nets will provide the dhcp server",
    "label": "",
    "id": "846"
  },
  {
    "raw_code": "def create_dhcp_server(*_, **_)\n          super if !use_host_only_nets?\n        end",
    "comment": "Disabled when host only nets are in use since the host only nets will provide the dhcp server",
    "label": "",
    "id": "847"
  },
  {
    "raw_code": "def read_forwarded_ports(uuid=nil, active_only=false)\n          # Only use this override for the 7.0.0 release.\n          return super if get_version.to_s != \"7.0.0\"\n\n          uuid ||= @uuid\n\n          @logger.debug(\"read_forward_ports: uuid=#{uuid} active_only=#{active_only}\")\n\n          results = []\n\n          info = execute(\"showvminfo\", uuid, \"--machinereadable\", retryable: true)\n          result = info.match(/CfgFile=\"(?<path>.+?)\"/)\n          if result.nil?\n            raise Vagrant::Errors::VirtualBoxConfigNotFound,\n                  uuid: uuid\n          end",
    "comment": "The initial VirtualBox 7.0 release has an issue with displaying port forward information. When a single port forward is defined, the forwarding information can be found in the `showvminfo` output. Once more than a single port forward is defined, no forwarding information is provided in the `showvminfo` output. To work around this we grab the VM configuration file from the `showvminfo` output and extract the port forward information from there instead.",
    "label": "",
    "id": "848"
  },
  {
    "raw_code": "def read_host_only_networks\n          networks = []\n          current = nil\n          execute(\"list\", \"hostonlynets\", retryable: true).split(\"\\n\").each do |line|\n            line.chomp!\n            next if line.empty?\n            key, value = line.split(\":\", 2).map(&:strip)\n            key = key.downcase\n            if key == \"name\"\n              networks.push(current) if !current.nil?\n              current = Vagrant::Util::HashWithIndifferentAccess.new\n            end",
    "comment": "Generate list of host only networks NOTE: This is darwin specific",
    "label": "",
    "id": "849"
  },
  {
    "raw_code": "def use_host_only_nets?\n          Vagrant::Util::Platform.darwin? &&\n            HOSTONLY_NET_REQUIREMENT.satisfied_by?(get_version)\n        end",
    "comment": "Returns if hostonlynets are enabled on the current host platform  @return [Boolean]",
    "label": "",
    "id": "850"
  },
  {
    "raw_code": "def get_version\n          return @version if @version\n          @version = Gem::Version.new(Meta.new.version)\n        end",
    "comment": "VirtualBox version in use  @return [Gem::Version]",
    "label": "",
    "id": "851"
  },
  {
    "raw_code": "def clear_forwarded_ports\n        end",
    "comment": "Clears the forwarded ports that have been set on the virtual machine.",
    "label": "",
    "id": "852"
  },
  {
    "raw_code": "def clear_shared_folders\n        end",
    "comment": "Clears the shared folders that have been set on the virtual machine.",
    "label": "",
    "id": "853"
  },
  {
    "raw_code": "def create_dhcp_server(network, options)\n        end",
    "comment": "Creates a DHCP server for a host only network.  @param [String] network Name of the host-only network. @param [Hash] options Options for the DHCP server.",
    "label": "",
    "id": "854"
  },
  {
    "raw_code": "def create_host_only_network(options)\n        end",
    "comment": "Creates a host only network with the given options.  @param [Hash] options Options to create the host only network. @return [Hash] The details of the host only network, including keys `:name`, `:ip`, and `:netmask`",
    "label": "",
    "id": "855"
  },
  {
    "raw_code": "def delete\n        end",
    "comment": "Deletes the virtual machine references by this driver.",
    "label": "",
    "id": "856"
  },
  {
    "raw_code": "def delete_unused_host_only_networks\n        end",
    "comment": "Deletes any host only networks that aren't being used for anything.",
    "label": "",
    "id": "857"
  },
  {
    "raw_code": "def discard_saved_state\n        end",
    "comment": "Discards any saved state associated with this VM.",
    "label": "",
    "id": "858"
  },
  {
    "raw_code": "def enable_adapters(adapters)\n        end",
    "comment": "Enables network adapters on the VM.  The format of each adapter specification should be like so:  { type:     :hostonly, hostonly: \"vboxnet0\", mac_address: \"tubes\" }  This must support setting up both host only and bridged networks.  @param [Array<Hash>] adapters Array of adapters to enable.",
    "label": "",
    "id": "859"
  },
  {
    "raw_code": "def execute_command(command)\n        end",
    "comment": "Execute a raw command straight through to VBoxManage.  Accepts a retryable: true option if the command should be retried upon failure.  Raises a VBoxManage error if it fails.  @param [Array] command Command to execute.",
    "label": "",
    "id": "860"
  },
  {
    "raw_code": "def export(path)\n        end",
    "comment": "Exports the virtual machine to the given path.  @param [String] path Path to the OVF file. @yield [progress] Yields the block with the progress of the export.",
    "label": "",
    "id": "861"
  },
  {
    "raw_code": "def forward_ports(ports)\n        end",
    "comment": "Forwards a set of ports for a VM.  This will not affect any previously set forwarded ports, so be sure to delete those if you need to.  The format of each port hash should be the following:  { name: \"foo\", hostport: 8500, guestport: 80, adapter: 1, protocol: \"tcp\" }  Note that \"adapter\" and \"protocol\" are optional and will default to 1 and \"tcp\" respectively.  @param [Array<Hash>] ports An array of ports to set. See documentation for more information on the format.",
    "label": "",
    "id": "862"
  },
  {
    "raw_code": "def halt\n        end",
    "comment": "Halts the virtual machine (pulls the plug).",
    "label": "",
    "id": "863"
  },
  {
    "raw_code": "def import(ovf)\n        end",
    "comment": "Imports the VM from an OVF file.  @param [String] ovf Path to the OVF file. @return [String] UUID of the imported VM.",
    "label": "",
    "id": "864"
  },
  {
    "raw_code": "def max_network_adapters\n          8\n        end",
    "comment": "Returns the maximum number of network adapters.",
    "label": "",
    "id": "865"
  },
  {
    "raw_code": "def read_forwarded_ports(uuid=nil, active_only=false)\n        end",
    "comment": "Returns a list of forwarded ports for a VM.  @param [String] uuid UUID of the VM to read from, or `nil` if this VM. @param [Boolean] active_only If true, only VMs that are running will be checked. @return [Array<Array>]",
    "label": "",
    "id": "866"
  },
  {
    "raw_code": "def read_bridged_interfaces\n        end",
    "comment": "Returns a list of bridged interfaces.  @return [Hash]",
    "label": "",
    "id": "867"
  },
  {
    "raw_code": "def read_dhcp_servers\n        end",
    "comment": "Returns a list of configured DHCP servers  Each DHCP server is represented as a Hash with the following details:  { :network => String, # name of the associated network interface as #   parsed from the NetworkName, e.g. \"vboxnet0\" :ip      => String, # IP address of the DHCP server, e.g. \"172.28.128.2\" :lower   => String, # lower IP address of the DHCP lease range, e.g. \"172.28.128.3\" :upper   => String, # upper IP address of the DHCP lease range, e.g. \"172.28.128.254\" }  @return [Array<Hash>] See comment above for details",
    "label": "",
    "id": "868"
  },
  {
    "raw_code": "def read_guest_additions_version\n        end",
    "comment": "Returns the guest additions version that is installed on this VM.  @return [String]",
    "label": "",
    "id": "869"
  },
  {
    "raw_code": "def read_guest_property(property)\n        end",
    "comment": "Returns the value of a guest property on the current VM.  @param  [String] property the name of the guest property to read @return [String] value of the guest property @raise  [VirtualBoxGuestPropertyNotFound] if the guest property does not have a value",
    "label": "",
    "id": "870"
  },
  {
    "raw_code": "def read_host_only_interfaces\n        end",
    "comment": "Returns a list of available host only interfaces.  Each interface is represented as a Hash with the following details:  { :name         => String, # interface name, e.g. \"vboxnet0\" :ip           => String, # IP address of the interface, e.g. \"172.28.128.1\" :netmask      => String, # netmask associated with the interface, e.g. \"255.255.255.0\" :status       => String, # status of the interface, e.g. \"Up\", \"Down\" :display_name => String, # user friendly display name if available }  @return [Array<Hash>] See comment above for details",
    "label": "",
    "id": "871"
  },
  {
    "raw_code": "def read_mac_address\n        end",
    "comment": "Returns the MAC address of the first network interface.  @return [String]",
    "label": "",
    "id": "872"
  },
  {
    "raw_code": "def read_machine_folder\n        end",
    "comment": "Returns the folder where VirtualBox places it's VMs.  @return [String]",
    "label": "",
    "id": "873"
  },
  {
    "raw_code": "def read_network_interfaces\n        end",
    "comment": "Returns a list of network interfaces of the VM.  @return [Hash]",
    "label": "",
    "id": "874"
  },
  {
    "raw_code": "def read_state\n        end",
    "comment": "Returns the current state of this VM.  @return [Symbol]",
    "label": "",
    "id": "875"
  },
  {
    "raw_code": "def read_used_ports\n        end",
    "comment": "Returns a list of all forwarded ports in use by active virtual machines.  @return [Array]",
    "label": "",
    "id": "876"
  },
  {
    "raw_code": "def read_vms\n        end",
    "comment": "Returns a list of all UUIDs of virtual machines currently known by VirtualBox.  @return [Array<String>]",
    "label": "",
    "id": "877"
  },
  {
    "raw_code": "def reconfig_host_only(interface)\n        end",
    "comment": "Reconfigure the hostonly network given by interface (the result of read_host_only_networks). This is a sad function that only exists to work around VirtualBox bugs.  @return nil",
    "label": "",
    "id": "878"
  },
  {
    "raw_code": "def remove_dhcp_server(network_name)\n        end",
    "comment": "Removes the DHCP server identified by the provided network name.  @param [String] network_name The the full network name associated with the DHCP server to be removed, e.g. \"HostInterfaceNetworking-vboxnet0\"",
    "label": "",
    "id": "879"
  },
  {
    "raw_code": "def set_mac_address(mac)\n        end",
    "comment": "Sets the MAC address of the first network adapter.  @param [String] mac MAC address without any spaces/hyphens.",
    "label": "",
    "id": "880"
  },
  {
    "raw_code": "def share_folders(folders)\n        end",
    "comment": "Share a set of folders on this VM.  @param [Array<Hash>] folders",
    "label": "",
    "id": "881"
  },
  {
    "raw_code": "def ssh_port(expected)\n        end",
    "comment": "Reads the SSH port of this VM.  @param [Integer] expected Expected guest port of SSH.",
    "label": "",
    "id": "882"
  },
  {
    "raw_code": "def start(mode)\n        end",
    "comment": "Starts the virtual machine.  @param [String] mode Mode to boot the VM. Either \"headless\" or \"gui\"",
    "label": "",
    "id": "883"
  },
  {
    "raw_code": "def suspend\n        end",
    "comment": "Suspend the virtual machine.",
    "label": "",
    "id": "884"
  },
  {
    "raw_code": "def unshare_folders(names)\n        end",
    "comment": "Unshare folders.",
    "label": "",
    "id": "885"
  },
  {
    "raw_code": "def verify!\n        end",
    "comment": "Verifies that the driver is ready to accept work.  This should raise a VagrantError if things are not ready.",
    "label": "",
    "id": "886"
  },
  {
    "raw_code": "def verify_image(path)\n        end",
    "comment": "Verifies that an image can be imported properly.  @param [String] path Path to an OVF file. @return [Boolean]",
    "label": "",
    "id": "887"
  },
  {
    "raw_code": "def vm_exists?(uuid)\n        end",
    "comment": "Checks if a VM with the given UUID exists.  @return [Boolean]",
    "label": "",
    "id": "888"
  },
  {
    "raw_code": "def show_vm_info\n          info = {}\n          execute('showvminfo', @uuid, '--machinereadable', retryable: true).split(\"\\n\").each do |line|\n            parts = line.partition('=')\n            key = parts.first.gsub('\"', '')\n            value = parts.last.gsub('\"', '')\n            info[key] = value\n          end",
    "comment": "Returns a hash of information about a given virtual machine  @param [String] uuid @return [Hash] info",
    "label": "",
    "id": "889"
  },
  {
    "raw_code": "def execute(*command, &block)\n          # Get the options hash if it exists\n          opts = {}\n          opts = command.pop if command.last.is_a?(Hash)\n\n          tries = 0\n          tries = 3 if opts[:retryable]\n\n          # Variable to store our execution result\n          r = nil\n\n          retryable(on: Vagrant::Errors::VBoxManageError, tries: tries, sleep: 1) do\n            # If there is an error with VBoxManage, this gets set to true\n            errored = false\n\n            # Execute the command\n            r = raw(*command, &block)\n\n            # If the command was a failure, then raise an exception that is\n            # nicely handled by Vagrant.\n            if r.exit_code != 0\n              if @interrupted\n                @logger.info(\"Exit code != 0, but interrupted. Ignoring.\")\n              elsif r.exit_code == 126\n                # This exit code happens if VBoxManage is on the PATH,\n                # but another executable it tries to execute is missing.\n                # This is usually indicative of a corrupted VirtualBox install.\n                raise Vagrant::Errors::VBoxManageNotFoundError\n              else\n                errored = true\n              end",
    "comment": "Execute the given subcommand for VBoxManage and return the output.",
    "label": "",
    "id": "890"
  },
  {
    "raw_code": "def raw(*command, &block)\n          int_callback = lambda do\n            @interrupted = true\n\n            # We have to execute this in a thread due to trap contexts\n            # and locks.\n            Thread.new { @logger.info(\"Interrupted.\") }.join\n          end",
    "comment": "Executes a command and returns the raw result object.",
    "label": "",
    "id": "891"
  },
  {
    "raw_code": "def env_lang\n          # If already set, just return immediately\n          return @env_lang if @env_lang\n\n          # Default the LANG to C\n          @env_lang = {LANG: \"C\"}\n\n          # If the locale command is not available, return default\n          return @env_lang if !Vagrant::Util::Which.which(\"locale\")\n\n          if defined?(@@env_lang)\n            return @env_lang = @@env_lang\n          end",
    "comment": "By default set the LANG to C. If the host has the locale command available, check installed locales and verify C is included (or use C variant if available).",
    "label": "",
    "id": "892"
  },
  {
    "raw_code": "def read_version\n          # The version string is usually in one of the following formats:\n          #\n          # * 4.1.8r1234\n          # * 4.1.8r1234_OSE\n          # * 4.1.8_MacPortsr1234\n          #\n          # Below accounts for all of these.\n\n          # Note: We split this into multiple lines because apparently \"\".split(\"_\")\n          # is [], so we have to check for an empty array in between.\n          output = \"\"\n          retryable(on: Vagrant::Errors::VirtualBoxVersionEmpty, tries: 3, sleep: 1) do\n            output = execute(\"--version\")\n            if output =~ /vboxdrv kernel module is not loaded/ ||\n              output =~ /VirtualBox kernel modules are not loaded/i\n              raise Vagrant::Errors::VirtualBoxKernelModuleNotLoaded\n            elsif output =~ /Please install/\n              # Check for installation incomplete warnings, for example:\n              # \"WARNING: The character device /dev/vboxdrv does not\n              # exist. Please install the virtualbox-ose-dkms package and\n              # the appropriate headers, most likely linux-headers-generic.\"\n              raise Vagrant::Errors::VirtualBoxInstallIncomplete\n            elsif output.chomp == \"\"\n              # This seems to happen on Windows for uncertain reasons.\n              # Raise an error otherwise the error is that they have an\n              # incompatible version of VirtualBox which isn't true.\n              raise Vagrant::Errors::VirtualBoxVersionEmpty,\n                vboxmanage: @vboxmanage_path.to_s\n            end",
    "comment": "This returns the version of VirtualBox that is running.  @return [String]",
    "label": "",
    "id": "893"
  },
  {
    "raw_code": "def attach_disk(controller_name, port, device, type, file, **opts)\n          comment = \"This disk is managed externally by Vagrant. Removing or adjusting settings could potentially cause issues with Vagrant.\"\n\n          execute('storageattach', @uuid,\n                  '--storagectl', controller_name,\n                  '--port', port.to_s,\n                  '--device', device.to_s,\n                  '--type', type,\n                  '--medium', file,\n                  '--comment', comment)\n        end",
    "comment": "Controller-Port-Device looks like: SATA Controller-ImageUUID-0-0 (sub out ImageUUID) - Controller: SATA Controller - Port: 0 - Device: 0  @param [String] controller_name - name of storage controller to attach disk to @param [String] port - port on device to attach disk to @param [String] device - device on controller for disk @param [String] type - type of disk to attach @param [String] file - disk file path @param [Hash]   opts -  additional options",
    "label": "",
    "id": "894"
  },
  {
    "raw_code": "def clone_disk(source, destination, disk_format, **opts)\n          execute(\"clonemedium\", source, destination, '--format', disk_format)\n        end",
    "comment": "@param [String] source @param [String] destination @param [String] disk_format",
    "label": "",
    "id": "895"
  },
  {
    "raw_code": "def close_medium(disk_uuid)\n          execute(\"closemedium\", disk_uuid, '--delete')\n        end",
    "comment": "Removes a disk from the given virtual machine  @param [String] disk_uuid or file path @param [Hash]   opts -  additional options",
    "label": "",
    "id": "896"
  },
  {
    "raw_code": "def create_disk(disk_file, disk_size, disk_format=\"VDI\", **opts)\n          execute(\"createmedium\", '--filename', disk_file, '--sizebyte', disk_size.to_i.to_s, '--format', disk_format)\n        end",
    "comment": "Creates a disk. Default format is VDI unless overridden  @param [String] disk_file @param [Integer] disk_size - size in bytes @param [String] disk_format - format of disk, defaults to \"VDI\" @param [Hash]  opts -  additional options",
    "label": "",
    "id": "897"
  },
  {
    "raw_code": "def list_hdds\n          hdds = []\n          tmp_drive = {}\n          execute('list', 'hdds', retryable: true).split(\"\\n\").each do |line|\n            if line == \"\" # separator between disks\n              hdds << tmp_drive\n              tmp_drive = {}\n              next\n            end",
    "comment": "Lists all attached harddisks from a given virtual machine. Additionally, this method adds a new key \"Disk Name\" based on the disks file path from \"Location\"  @return [Array] hdds An array of hashes of harddrive info for a guest",
    "label": "",
    "id": "898"
  },
  {
    "raw_code": "def remove_disk(controller_name, port, device)\n          execute('storageattach', @uuid,\n                  '--storagectl', controller_name,\n                  '--port', port.to_s,\n                  '--device', device.to_s,\n                  '--medium', \"none\")\n        end",
    "comment": "@param [String] controller_name - controller name to remove disk from @param [String] port - port on device to attach disk to @param [String] device - device on controller for disk",
    "label": "",
    "id": "899"
  },
  {
    "raw_code": "def resize_disk(disk_file, disk_size, **opts)\n          execute(\"modifymedium\", disk_file, '--resizebyte', disk_size.to_i.to_s)\n        end",
    "comment": "@param [String] disk_file @param [Integer] disk_size in bytes @param [Hash]   opts -  additional options",
    "label": "",
    "id": "900"
  },
  {
    "raw_code": "def get_port_and_device(disk_uuid)\n          disk = {}\n\n          storage_controllers = read_storage_controllers\n          storage_controllers.each do |controller|\n            controller.attachments.each do |attachment|\n              if disk_uuid == attachment[:uuid]\n                disk[:port] = attachment[:port]\n                disk[:device] = attachment[:device]\n                return disk\n              end",
    "comment": "Returns port and device for an attached disk given a disk uuid. Returns empty hash if disk is not attachd to guest  @param [String] disk_uuid - the UUID for the disk we are searching for @return [Hash] disk_info - Contains a device and port number",
    "label": "",
    "id": "901"
  },
  {
    "raw_code": "def show_medium_info(disk_type, disk_uuid_or_file)\n          disk = {}\n          execute('showmediuminfo', disk_type, disk_uuid_or_file, retryable: true).split(\"\\n\").each do |line|\n            parts = line.partition(\":\")\n            key = parts.first.strip\n            value = parts.last.strip\n            disk[key] = value\n\n            if key == \"Location\"\n              disk[\"Disk Name\"] = File.basename(value, \".*\")\n            end",
    "comment": "Returns information for a given disk  @param [String] disk_type - can be \"disk\", \"dvd\", or \"floppy\" @param [String] disk_uuid_or_file @return [Hash] disk",
    "label": "",
    "id": "902"
  },
  {
    "raw_code": "def vmdk_to_vdi(defined_disk_path)\n          source = defined_disk_path\n          destination = File.join(File.dirname(source), File.basename(source, \".*\")) + \".vdi\"\n\n          clone_disk(source, destination, 'VDI')\n\n          destination\n        end",
    "comment": "@param [VagrantPlugins::VirtualboxProvider::Driver] driver @param [String] defined_disk_path @return [String] destination - The cloned disk",
    "label": "",
    "id": "903"
  },
  {
    "raw_code": "def vdi_to_vmdk(defined_disk_path)\n          source = defined_disk_path\n          destination = File.join(File.dirname(source), File.basename(source, \".*\")) + \".vmdk\"\n\n          clone_disk(source, destination, 'VMDK')\n\n          destination\n        end",
    "comment": "@param [VagrantPlugins::VirtualboxProvider::Driver] driver @param [String] defined_disk_path @return [String] destination - The cloned disk",
    "label": "",
    "id": "904"
  },
  {
    "raw_code": "def read_storage_controllers\n          vm_info = show_vm_info\n          count = vm_info.count { |key, value| key.match(/^storagecontrollername\\d+$/) }\n          all_disks = list_hdds\n\n          storage_controllers = Model::StorageControllerArray.new\n\n          (0..count - 1).each do |n|\n            # basic controller metadata\n            name = vm_info[\"storagecontrollername#{n}\"]\n            type = vm_info[\"storagecontrollertype#{n}\"]\n            maxportcount = vm_info[\"storagecontrollermaxportcount#{n}\"].to_i\n\n            # build attachments array\n            attachments = []\n            vm_info.each do |k, v|\n              if /^#{name}-ImageUUID-(\\d+)-(\\d+)$/ =~ k\n                port = $1.to_s\n                device = $2.to_s\n                uuid = v\n                location = vm_info[\"#{name}-#{port}-#{device}\"]\n\n                extra_disk_data = all_disks.detect { |d| d[\"UUID\"] == uuid }\n\n                attachment = { port: port,\n                               device: device,\n                               uuid: uuid,\n                               location: location }\n\n                extra_disk_data&.each do |dk,dv|\n                  # NOTE: We convert the keys from VirtualBox to symbols\n                  # to be consistent with the other keys\n                  attachment[dk.downcase.gsub(' ', '_').to_sym] = dv\n                end",
    "comment": "Helper method to get a list of storage controllers added to the current VM  @return [VagrantPlugins::ProviderVirtualBox::Model::StorageControllerArray]",
    "label": "",
    "id": "905"
  },
  {
    "raw_code": "def self.validate_disk_ext(machine, disk_ext)\n          DEFAULT_DISK_EXT_LIST.include?(disk_ext)\n        end",
    "comment": "@param [Vagrant::Machine] machine @param [String] disk_ext @return [Bool]",
    "label": "",
    "id": "906"
  },
  {
    "raw_code": "def self.default_disk_exts(machine)\n          DEFAULT_DISK_EXT_LIST\n        end",
    "comment": "@param [Vagrant::Machine] machine @return [Array]",
    "label": "",
    "id": "907"
  },
  {
    "raw_code": "def self.set_default_disk_ext(machine)\n          DEFAULT_DISK_EXT\n        end",
    "comment": "@param [Vagrant::Machine] machine @return [String]",
    "label": "",
    "id": "908"
  },
  {
    "raw_code": "def self.cleanup_disks(machine, defined_disks, disk_meta_file)\n          return if disk_meta_file.values.flatten.empty?\n\n          handle_cleanup_disk(machine, defined_disks, disk_meta_file[\"disk\"])\n          handle_cleanup_dvd(machine, defined_disks, disk_meta_file[\"dvd\"])\n          # TODO: Floppy disks\n        end",
    "comment": "@param [Vagrant::Machine] machine @param [VagrantPlugins::Kernel_V2::VagrantConfigDisk] defined_disks @param [Hash] disk_meta_file - A hash of all the previously defined disks from the last configure_disk action",
    "label": "",
    "id": "909"
  },
  {
    "raw_code": "def self.handle_cleanup_disk(machine, defined_disks, disk_meta)\n          raise TypeError, \"Expected `Array` but received `#{disk_meta.class}`\" if !disk_meta.is_a?(Array)\n          storage_controllers = machine.provider.driver.read_storage_controllers\n\n          primary = storage_controllers.get_primary_attachment\n          primary_uuid = primary[:uuid]\n\n          disk_meta.each do |d|\n            dsk = defined_disks.select { |dk| dk.name == d[\"name\"] }\n            if !dsk.empty? || d[\"uuid\"] == primary_uuid\n              next\n            else\n              LOGGER.warn(\"Found disk not in Vagrantfile config: '#{d[\"name\"]}'. Removing disk from guest #{machine.name}\")\n              machine.ui.warn(I18n.t(\"vagrant.cap.cleanup_disks.disk_cleanup\", name: d[\"name\"]), prefix: true)\n\n              controller = storage_controllers.get_controller(d[\"controller\"])\n              attachment = controller.get_attachment(uuid: d[\"uuid\"])\n\n              if !attachment\n                LOGGER.warn(\"Disk '#{d[\"name\"]}' not attached to guest, but still exists.\")\n              else\n                machine.provider.driver.remove_disk(controller.name, attachment[:port], attachment[:device])\n              end",
    "comment": "@param [Vagrant::Machine] machine @param [VagrantPlugins::Kernel_V2::VagrantConfigDisk] defined_disks @param [Array<Hash>] disk_meta - An array of all the previously defined disks from the last configure_disk action",
    "label": "",
    "id": "910"
  },
  {
    "raw_code": "def self.handle_cleanup_dvd(machine, defined_dvds, dvd_meta)\n          raise TypeError, \"Expected `Array` but received `#{dvd_meta.class}`\" if !dvd_meta.is_a?(Array)\n          dvd_meta.each do |d|\n            dsk = defined_dvds.select { |dk| dk.name == d[\"name\"] }\n            if !dsk.empty?\n              next\n            else\n              LOGGER.warn(\"Found dvd not in Vagrantfile config: '#{d[\"name\"]}'. Removing dvd from guest #{machine.name}\")\n              machine.ui.warn(\"DVD '#{d[\"name\"]}' no longer exists in Vagrant config. Removing medium from guest...\", prefix: true)\n\n              storage_controllers = machine.provider.driver.read_storage_controllers\n              controller = storage_controllers.get_controller(d[\"controller\"])\n              attachment = controller.get_attachment(uuid: d[\"uuid\"])\n\n              if !attachment\n                LOGGER.warn(\"DVD '#{d[\"name\"]}' not attached to guest, but still exists.\")\n              else\n                machine.provider.driver.remove_disk(controller.name, attachment[:port], attachment[:device])\n              end",
    "comment": "@param [Vagrant::Machine] machine @param [VagrantPlugins::Kernel_V2::VagrantConfigDisk] defined_dvds @param [Array<Hash>] dvd_meta - An array of all the previously defined dvds from the last configure_disk action",
    "label": "",
    "id": "911"
  },
  {
    "raw_code": "def self.configure_disks(machine, defined_disks)\n          return {} if defined_disks.empty?\n\n          machine.ui.info(I18n.t(\"vagrant.cap.configure_disks.start\"))\n\n          storage_controllers = machine.provider.driver.read_storage_controllers\n\n          # Check to determine which controller we should attach disks to.\n          # If there is only one storage controller attached to the VM, use\n          # it. If there are multiple controllers (e.g. IDE/SATA), attach DVDs\n          # to the IDE controller and disks to the SATA controller.\n          if storage_controllers.size == 1\n            controller = storage_controllers.first\n\n            # The only way you can define up to the controller limit is if\n            # exactly one disk is a primary disk, otherwise we need to reserve\n            # a slot for the primary\n            if (defined_disks.any? { |d| d.primary } && defined_disks.size > controller.limit) ||\n               defined_disks.size > controller.limit - 1\n              raise Vagrant::Errors::VirtualBoxDisksDefinedExceedLimit,\n                limit: controller.limit,\n                name: controller.name\n            else\n              disk_controller = controller\n              dvd_controller = controller\n            end",
    "comment": "@param [Vagrant::Machine] machine @param [VagrantPlugins::Kernel_V2::VagrantConfigDisk] defined_disks @return [Hash] configured_disks - A hash of all the current configured disks",
    "label": "",
    "id": "912"
  },
  {
    "raw_code": "def self.get_current_disk(machine, disk, all_disks)\n          current_disk = nil\n          if disk.primary\n            storage_controllers = machine.provider.driver.read_storage_controllers\n            current_disk = storage_controllers.get_primary_attachment\n          else\n            current_disk = all_disks.detect { |d| d[:disk_name] == disk.name }\n          end",
    "comment": "@param [Vagrant::Machine] machine - the current machine @param [Config::Disk] disk - the current disk to configure @param [Array] all_disks - A list of all currently defined disks in VirtualBox @return [Hash] current_disk - Returns the current disk. Returns nil if it doesn't exist",
    "label": "",
    "id": "913"
  },
  {
    "raw_code": "def self.handle_configure_disk(machine, disk, controller_name)\n          storage_controllers = machine.provider.driver.read_storage_controllers\n          controller = storage_controllers.get_controller(controller_name)\n          all_disks = controller.attachments\n\n          disk_metadata = {}\n\n          # Grab the existing configured disk attached to guest, if it exists\n          current_disk = get_current_disk(machine, disk, all_disks)\n\n          if !current_disk\n            # Look for an existing disk that's not been attached but exists\n            # inside VirtualBox\n            #\n            # NOTE: This assumes that if that disk exists and was created by\n            # Vagrant, it exists in the same location as the primary disk file.\n            # Otherwise Vagrant has no good way to determining if the disk was\n            # associated with the guest, since disk names are not unique\n            # globally to VirtualBox.\n            primary = storage_controllers.get_primary_attachment\n            existing_disk = machine.provider.driver.list_hdds.detect do |d|\n              File.dirname(d[\"Location\"]) == File.dirname(primary[:location]) &&\n                d[\"Disk Name\"] == disk.name\n            end",
    "comment": "Handles all disk configs of type `:disk`  @param [Vagrant::Machine] machine - the current machine @param [Config::Disk] disk - the current disk to configure @param [String] controller_name - the name of the storage controller to use @return [Hash] - disk_metadata",
    "label": "",
    "id": "914"
  },
  {
    "raw_code": "def self.handle_configure_dvd(machine, dvd, controller_name)\n          storage_controllers = machine.provider.driver.read_storage_controllers\n          controller = storage_controllers.get_controller(controller_name)\n\n          dvd_metadata = {}\n\n          dvd_location = File.expand_path(dvd.file)\n          dvd_attached = controller.attachments.detect { |a| a[:location] == dvd_location }\n\n          if dvd_attached\n            LOGGER.info(\"No further configuration required for dvd '#{dvd.name}'\")\n            dvd_metadata[:name] = dvd.name\n            dvd_metadata[:port] = dvd_attached[:port]\n            dvd_metadata[:device] = dvd_attached[:device]\n            dvd_metadata[:uuid] = dvd_attached[:uuid]\n            dvd_metadata[:controller] = controller.name\n          else\n            LOGGER.warn(\"DVD '#{dvd.name}' is not connected to guest '#{machine.name}', Vagrant will attempt to connect dvd to guest\")\n            dsk_info = get_next_port(machine, controller)\n            machine.provider.driver.attach_disk(controller.name,\n                                                dsk_info[:port],\n                                                dsk_info[:device],\n                                                \"dvddrive\",\n                                                dvd.file)\n\n            # Refresh the controller information\n            storage_controllers = machine.provider.driver.read_storage_controllers\n            controller = storage_controllers.get_controller(controller_name)\n\n            attachment = controller.attachments.detect { |a| a[:port] == dsk_info[:port] &&\n                                                             a[:device] == dsk_info[:device] }\n\n            dvd_metadata[:name] = dvd.name\n            dvd_metadata[:port] = dsk_info[:port]\n            dvd_metadata[:device] = dsk_info[:device]\n            dvd_metadata[:uuid] = attachment[:uuid]\n            dvd_metadata[:controller] = controller.name\n          end",
    "comment": "Handles all disk configs of type `:dvd`  @param [Vagrant::Machine] machine - the current machine @param [Config::Disk] dvd - the current disk to configure @param [String] controller_name - the name of the storage controller to use @return [Hash] - dvd_metadata",
    "label": "",
    "id": "915"
  },
  {
    "raw_code": "def self.compare_disk_size(machine, disk_config, defined_disk)\n          requested_disk_size = Vagrant::Util::Numeric.bytes_to_megabytes(disk_config.size)\n          defined_disk_size = defined_disk[:capacity].split(\" \").first.to_f\n\n          if defined_disk_size > requested_disk_size\n            machine.ui.warn(I18n.t(\"vagrant.cap.configure_disks.shrink_size_not_supported\", name: disk_config.name))\n            return false\n          elsif defined_disk_size < requested_disk_size\n            return true\n          else\n            return false\n          end",
    "comment": "Check to see if current disk is configured based on defined_disks  @param [Kernel_V2::VagrantConfigDisk] disk_config @param [Hash] defined_disk @return [Boolean]",
    "label": "",
    "id": "916"
  },
  {
    "raw_code": "def self.create_disk(machine, disk_config, controller)\n          machine.ui.detail(I18n.t(\"vagrant.cap.configure_disks.create_disk\", name: disk_config.name))\n          # NOTE: At the moment, there are no provider specific configs for VirtualBox\n          # but we grab it anyway for future use.\n          disk_provider_config = disk_config.provider_config[:virtualbox] if disk_config.provider_config\n\n          guest_info = machine.provider.driver.show_vm_info\n          guest_folder = File.dirname(guest_info[\"CfgFile\"])\n\n          disk_ext = disk_config.disk_ext\n          disk_file = File.join(guest_folder, disk_config.name) + \".#{disk_ext}\"\n\n          LOGGER.info(\"Attempting to create a new disk file '#{disk_file}' of size '#{disk_config.size}' bytes\")\n\n          disk_var = machine.provider.driver.create_disk(disk_file, disk_config.size, disk_ext.upcase)\n          dsk_controller_info = get_next_port(machine, controller)\n          machine.provider.driver.attach_disk(controller.name,\n                                              dsk_controller_info[:port],\n                                              dsk_controller_info[:device],\n                                              \"hdd\",\n                                              disk_file)\n\n          disk_metadata = { uuid: disk_var.split(\":\").last.strip, name: disk_config.name,\n                            controller: controller.name, port: dsk_controller_info[:port],\n                            device: dsk_controller_info[:device] }\n\n          disk_metadata\n        end",
    "comment": "Creates and attaches a disk to a machine  @param [Vagrant::Machine] machine @param [Kernel_V2::VagrantConfigDisk] disk_config @param [VagrantPlugins::ProviderVirtualBox::Model::StorageController] controller - the storage controller to use",
    "label": "",
    "id": "917"
  },
  {
    "raw_code": "def self.get_next_port(machine, controller)\n          dsk_info = {}\n\n          if controller.devices_per_port == 1\n            used_ports = controller.attachments.map { |a| a[:port].to_i }\n            next_available_port = ((0..(controller.maxportcount - 1)).to_a - used_ports).first\n\n            dsk_info[:port] = next_available_port.to_s\n            dsk_info[:device] = \"0\"\n          elsif controller.devices_per_port == 2\n            # IDE Controllers have primary/secondary devices, so find the first port\n            # with an empty device\n            (0..(controller.maxportcount - 1)).each do |port|\n              # Skip this port if it's full\n              port_attachments = controller.attachments.select { |a| a[:port] == port.to_s }\n              next if port_attachments.count == controller.devices_per_port\n\n              dsk_info[:port] = port.to_s\n\n              # Check for a free device\n              if port_attachments.any? { |a| a[:device] == \"0\" }\n                dsk_info[:device] = \"1\"\n              else\n                dsk_info[:device] = \"0\"\n              end",
    "comment": "Finds the next available port  SATA Controller-ImageUUID-0-0 (sub out ImageUUID) - Controller: SATA Controller - Port: 0 - Device: 0  Note: Virtualbox returns the string above with the port and device info disk_info = key.split(\"-\") port = disk_info[2] device = disk_info[3]  @param [Vagrant::Machine] machine @param [VagrantPlugins::ProviderVirtualBox::Model::StorageController] controller - the storage controller to use @return [Hash] dsk_info - The next available port and device on a given controller",
    "label": "",
    "id": "918"
  },
  {
    "raw_code": "def self.resize_disk(machine, disk_config, defined_disk, controller)\n          machine.ui.detail(I18n.t(\"vagrant.cap.configure_disks.resize_disk\", name: disk_config.name), prefix: true)\n\n          if defined_disk[:storage_format] == \"VMDK\"\n            LOGGER.warn(\"Disk type VMDK cannot be resized in VirtualBox. Vagrant will convert disk to VDI format to resize first, and then convert resized disk back to VMDK format\")\n\n            # original disk information in case anything goes wrong during clone/resize\n            original_disk = defined_disk\n            backup_disk_location = \"#{original_disk[:location]}.backup\"\n\n            # clone disk to vdi formatted disk\n            vdi_disk_file = machine.provider.driver.vmdk_to_vdi(defined_disk[:location])\n            # resize vdi\n            machine.provider.driver.resize_disk(vdi_disk_file, disk_config.size.to_i)\n\n            begin\n              # Danger Zone\n              # remove and close original volume\n              machine.provider.driver.remove_disk(controller.name, defined_disk[:port], defined_disk[:device])\n              # Create a backup of the original disk if something goes wrong\n              LOGGER.warn(\"Making a backup of the original disk at #{defined_disk[:location]}\")\n              FileUtils.mv(defined_disk[:location], backup_disk_location)\n\n              # we have to close here, otherwise we can't re-clone after\n              # resizing the vdi disk\n              machine.provider.driver.close_medium(defined_disk[:uuid])\n\n              # clone back to original vmdk format and attach resized disk\n              vmdk_disk_file = machine.provider.driver.vdi_to_vmdk(vdi_disk_file)\n              machine.provider.driver.attach_disk(controller.name,\n                                                  defined_disk[:port],\n                                                  defined_disk[:device],\n                                                  \"hdd\",\n                                                  vmdk_disk_file)\n            rescue ScriptError, SignalException, StandardError\n              LOGGER.warn(\"Vagrant encountered an error while trying to resize a disk. Vagrant will now attempt to reattach and preserve the original disk...\")\n              machine.ui.error(I18n.t(\"vagrant.cap.configure_disks.recovery_from_resize\",\n                                      location: original_disk[:location],\n                                      name: machine.name))\n              recover_from_resize(machine, defined_disk, backup_disk_location, original_disk, vdi_disk_file, controller)\n              raise\n            ensure\n              # Remove backup disk file if all goes well\n              FileUtils.remove(backup_disk_location, force: true)\n            end",
    "comment": "@param [Vagrant::Machine] machine @param [Config::Disk] disk_config - the current disk to configure @param [Hash] defined_disk - current disk as represented by VirtualBox @param [VagrantPlugins::ProviderVirtualBox::Model::StorageController] controller - the storage controller to use @return [Hash] - disk_metadata",
    "label": "",
    "id": "919"
  },
  {
    "raw_code": "def self.recover_from_resize(machine, disk_info, backup_disk_location, original_disk, vdi_disk_file, controller)\n          begin\n            # move backup to original name\n            FileUtils.mv(backup_disk_location, original_disk[:location], force: true)\n            # Attach disk\n            machine.provider.driver.attach_disk(controller.name,\n                                                disk_info[:port],\n                                                disk_info[:device],\n                                                \"hdd\",\n                                                original_disk[:location])\n\n            # Remove cloned disk if still hanging around\n            if vdi_disk_file\n              machine.provider.driver.close_medium(vdi_disk_file)\n            end",
    "comment": "Recovery method for when an exception occurs during the process of resizing disks  It attempts to move back the backup disk into place, and reattach it to the guest before raising the original error  @param [Vagrant::Machine] machine @param [Hash] disk_info - The disk device and port number to attach back to @param [String] backup_disk_location - The place on disk where vagrant made a backup of the original disk being resized @param [Hash] original_disk - The disk information from VirtualBox @param [String] vdi_disk_file - The place on disk where vagrant made a clone of the original disk being resized @param [VagrantPlugins::ProviderVirtualBox::Model::StorageController] controller - the storage controller to use",
    "label": "",
    "id": "920"
  },
  {
    "raw_code": "def self.mount_options(machine, name, guest_path, options)\n          mount_options = options.fetch(:mount_options, [])\n          detected_ids = detect_owner_group_ids(machine, guest_path, mount_options, options)\n          mount_uid = detected_ids[:uid]\n          mount_gid = detected_ids[:gid]\n\n          mount_options << \"uid=#{mount_uid}\"\n          mount_options << \"gid=#{mount_gid}\"\n          mount_options << \"_netdev\"\n          mount_options = mount_options.join(',')\n          return mount_options, mount_uid, mount_gid\n        end",
    "comment": "Returns mount options for a virtual box synced folder  @param [Machine] machine @param [String] name of mount @param [String] path of mount on guest @param [Hash] hash of mount options",
    "label": "",
    "id": "921"
  },
  {
    "raw_code": "def compile_forwarded_ports(config)\n          mappings = {}\n\n          config.vm.networks.each do |type, options|\n            if type == :forwarded_port\n              guest_port = options[:guest]\n              host_port  = options[:host]\n              host_ip    = options[:host_ip]\n              protocol   = options[:protocol] || \"tcp\"\n              options    = scoped_hash_override(options, :virtualbox)\n              id         = options[:id]\n\n              # If the forwarded port was marked as disabled, ignore.\n              next if options[:disabled]\n\n              key = \"#{host_ip}#{protocol}#{host_port}\"\n              mappings[key] =\n                Model::ForwardedPort.new(id, host_port, guest_port, options)\n            end",
    "comment": "This method compiles the forwarded ports into {ForwardedPort} models.",
    "label": "",
    "id": "922"
  },
  {
    "raw_code": "def attempt_and_log(command, log)\n          begin\n            @env[:machine].provider.driver.execute_command(\n              command + [retryable: true])\n          rescue Vagrant::Errors::VBoxManageError => e\n            @logger.info(\"#{log} (error = #{e.inspect})\")\n          end",
    "comment": "This is just a helper method that executes a single command, logs the given string to the log, and also includes the exit status in the log message.  We assume every command is idempotent and pass along the `retryable` flag. This is because VBoxManage is janky about running simultaneously on the same box, and if we up multiple boxes at the same time, a bunch of modifyvm commands get fired  @param [Array] command Command to run @param [String] log Log message to write.",
    "label": "",
    "id": "923"
  },
  {
    "raw_code": "def enable_dns_proxy?\n          begin\n            contents = File.read(\"/etc/resolv.conf\")\n\n            if contents =~ /^nameserver 127\\.0\\.(0|1)\\.1$/\n              # The use of both natdnsproxy and natdnshostresolver break on\n              # Ubuntu 12.04 and 12.10 that uses resolvconf with localhost. When used\n              # VirtualBox will give the client dns server 10.0.2.3, while\n              # not binding to that address itself. Therefore disable this\n              # feature if host uses the resolvconf server 127.0.0.1 or\n              # 127.0.1.1\n              @logger.info(\"Disabling DNS proxy since resolv.conf contains 127.0.0.1 or 127.0.1.1\")\n              return false\n            end",
    "comment": "This uses some heuristics to determine if the NAT DNS proxy should be enabled or disabled. See the comments within the function body itself to see the checks it does.  @return [Boolean]",
    "label": "",
    "id": "924"
  },
  {
    "raw_code": "def host_only_interface_names(env)\n          env[:machine].provider.driver.read_network_interfaces\n            .map { |_, i| i[:hostonly] if i[:type] == :hostonly }.compact\n        end",
    "comment": "The list of interface names for host-only adapters. @return [Array<String>]",
    "label": "",
    "id": "925"
  },
  {
    "raw_code": "def host_only_interfaces(env)\n          iface_names = self.host_only_interface_names(env)\n          env[:machine].provider.driver.read_host_only_interfaces\n            .select { |interface| iface_names.include?(interface[:name]) }\n        end",
    "comment": "The list of host_only_interfaces that are tied to a host-only adapter. @return [Array]",
    "label": "",
    "id": "926"
  },
  {
    "raw_code": "def add_ips_to_env!(env)\n          adapter, host_ip = find_host_only_adapter\n          machine_ip       = read_static_machine_ips\n\n          if !machine_ip\n            # No static IP, attempt to use the dynamic IP.\n            machine_ip = read_dynamic_machine_ip(adapter)\n          else\n            # We have static IPs, also attempt to read any dynamic IPs.\n            # If there is no dynamic IP on the adapter, it doesn't matter. We\n            # already have a static IP.\n            begin\n              dynamic_ip = read_dynamic_machine_ip(adapter)\n            rescue Vagrant::Errors::NFSNoGuestIP\n              dynamic_ip = nil\n            end",
    "comment": "Extracts the proper host and guest IPs for NFS mounts and stores them in the environment for the SyncedFolder action to use them in mounting.  The ! indicates that this method modifies its argument.",
    "label": "",
    "id": "927"
  },
  {
    "raw_code": "def find_host_only_adapter\n          @machine.provider.driver.read_network_interfaces.each do |adapter, opts|\n            if opts[:type] == :hostonly\n              @machine.provider.driver.read_host_only_interfaces.each do |interface|\n                if interface[:name] == opts[:hostonly]\n                  return adapter, interface[:ip]\n                end",
    "comment": "Finds first host only network adapter and returns its adapter number and IP address  @return [Integer, String] adapter number, ip address of found host-only adapter",
    "label": "",
    "id": "928"
  },
  {
    "raw_code": "def read_static_machine_ips\n          ips = []\n          @machine.config.vm.networks.each do |type, options|\n            options = scoped_hash_override(options, :virtualbox)\n\n            if type == :private_network && options[:type] != :dhcp && options[:ip].is_a?(String)\n              ips << options[:ip]\n            end",
    "comment": "Returns the IP address(es) of the guest by looking for static IPs given to host only adapters in the Vagrantfile  @return [Array]<String> Configured static IPs",
    "label": "",
    "id": "929"
  },
  {
    "raw_code": "def read_dynamic_machine_ip(adapter)\n          return nil unless adapter\n\n          # vbox guest properties are 0-indexed, while showvminfo network\n          # interfaces are 1-indexed. go figure.\n          guestproperty_adapter = adapter - 1\n\n          # we need to wait for the guest's IP to show up as a guest property.\n          # retry thresholds are relatively high since we might need to wait\n          # for DHCP, but even static IPs can take a second or two to appear.\n          retryable(retry_options.merge(on: Vagrant::Errors::VirtualBoxGuestPropertyNotFound)) do\n            @machine.provider.driver.read_guest_ip(guestproperty_adapter)\n          end",
    "comment": "Returns the IP address of the guest by looking at vbox guest property for the appropriate guest adapter.  For DHCP interfaces, the guest property will not be present until the guest completes  @param [Integer] adapter number to read IP for @return [String] ip address of adapter",
    "label": "",
    "id": "930"
  },
  {
    "raw_code": "def retry_options\n          {tries: 15, sleep: 1}\n        end",
    "comment": "Separating these out so we can stub out the sleep in tests",
    "label": "",
    "id": "931"
  },
  {
    "raw_code": "def assign_interface_numbers(networks, adapters)\n          current = 0\n          adapter_to_interface = {}\n\n          # Make a first pass to assign interface numbers by adapter location\n          vm_adapters = @env[:machine].provider.driver.read_network_interfaces\n          vm_adapters.sort.each do |number, adapter|\n            if adapter[:type] != :none\n              # Not used, so assign the interface number and increment\n              adapter_to_interface[number] = current\n              current += 1\n            end",
    "comment": "----------------------------------------------------------------- Misc. helpers ----------------------------------------------------------------- Assigns the actual interface number of a network based on the enabled NICs on the virtual machine.  This interface number is used by the guest to configure the NIC on the guest VM.  The networks are modified in place by adding an \":interface\" field to each.",
    "label": "",
    "id": "932"
  },
  {
    "raw_code": "def hostonly_create_network(config)\n          @env[:machine].provider.driver.create_host_only_network(config)\n        end",
    "comment": "----------------------------------------------------------------- Hostonly Helper Functions ----------------------------------------------------------------- This creates a host only network for the given configuration.",
    "label": "",
    "id": "933"
  },
  {
    "raw_code": "def hostonly_find_matching_network(config)\n          this_netaddr = network_address(config[:ip], config[:netmask])  if config[:ip]\n\n          @env[:machine].provider.driver.read_host_only_interfaces.each do |interface|\n            return interface if config[:name] && config[:name] == interface[:name]\n\n            #if a config name is specified, we should only look for that.\n            if config[:name].to_s != \"\"\n              next\n            end",
    "comment": "This finds a matching host only network for the given configuration.",
    "label": "",
    "id": "934"
  },
  {
    "raw_code": "def validate_hostonly_ip!(ip, driver)\n          return if Gem::Version.new(driver.version) < HOSTONLY_VALIDATE_VERSION ||\n                    (\n                      Vagrant::Util::Platform.darwin? &&\n                      Gem::Version.new(driver.version) >= DARWIN_IGNORE_HOSTONLY_VALIDATE_VERSION\n                    ) ||\n                    Vagrant::Util::Platform.windows?\n\n          ip = IPAddr.new(ip.to_s) if !ip.is_a?(IPAddr)\n          valid_ranges = load_net_conf\n          return if valid_ranges.any?{ |range| range.include?(ip) }\n          raise Vagrant::Errors::VirtualBoxInvalidHostSubnet,\n            address: ip,\n            ranges: valid_ranges.map{ |r| \"#{r}/#{r.prefix}\" }.join(\", \")\n        end",
    "comment": "Validates the IP used to configure the network is within the allowed ranges. It only validates if the network configuration file exists. This was introduced in 6.1.28 so previous version won't have restrictions placed on the valid ranges",
    "label": "",
    "id": "935"
  },
  {
    "raw_code": "def create_dhcp_server_if_necessary(interface, config)\n          existing_dhcp_server = find_matching_dhcp_server(interface)\n          if existing_dhcp_server\n            if dhcp_server_matches_config?(existing_dhcp_server, config)\n              @logger.debug(\"DHCP server already properly configured\")\n              return\n            elsif existing_dhcp_server == DEFAULT_DHCP_SERVER_FROM_VBOX_INSTALL\n              @env[:ui].info I18n.t(\"vagrant.actions.vm.network.cleanup_vbox_default_dhcp\")\n              @env[:machine].provider.driver.remove_dhcp_server(existing_dhcp_server[:network_name])\n            else\n              # We have an invalid DHCP server that we're not able to\n              # automatically clean up, so we need to give up and tell the user\n              # to sort out their own vbox dhcpservers and hostonlyifs\n              raise Vagrant::Errors::NetworkDHCPAlreadyAttached\n            end",
    "comment": " When a host-only network of type: :dhcp is configured, this handles the potential creation of a vbox dhcpserver to manage it.  @param [Hash<String>] interface hash as returned from read_host_only_interfaces @param [Hash<String>] config hash as returned from hostonly_config",
    "label": "",
    "id": "936"
  },
  {
    "raw_code": "def dhcp_server_matches_config?(dhcp_server, config)\n          dhcp_server[:ip]    == config[:dhcp_ip]    &&\n          dhcp_server[:lower] == config[:dhcp_lower] &&\n          dhcp_server[:upper] == config[:dhcp_upper]\n        end",
    "comment": "Detect when an existing DHCP server matches precisely the requested config for a hostonly interface.  @param [Hash<String>] dhcp_server as found by read_dhcp_servers @param [Hash<String>] config as returned from hostonly_config @return [Boolean]",
    "label": "",
    "id": "937"
  },
  {
    "raw_code": "def find_matching_dhcp_server(interface)\n          @env[:machine].provider.driver.read_dhcp_servers.detect do |dhcp_server|\n            interface[:name] && interface[:name] == dhcp_server[:network]\n          end",
    "comment": "Returns the existing dhcp server, if any, that is attached to the specified interface.  @return [Hash<String>] dhcp_server or nil if not found",
    "label": "",
    "id": "938"
  },
  {
    "raw_code": "def create_vagrantfile\n          File.open(File.join(@env[\"export.temp_dir\"], \"Vagrantfile\"), \"w\") do |f|\n            f.write(TemplateRenderer.render(\"package_Vagrantfile\", {\n              base_mac: @env[:machine].provider.driver.read_mac_address\n            }))\n          end",
    "comment": "This method creates the auto-generated Vagrantfile at the root of the box. This Vagrantfile contains the MAC address so that the user doesn't have to worry about it.",
    "label": "",
    "id": "939"
  },
  {
    "raw_code": "def call(env)\n          @env = env\n\n          # Get the ports we're forwarding\n          env[:forwarded_ports] ||= compile_forwarded_ports(env[:machine].config)\n\n          # Warn if we're port forwarding to any privileged ports...\n          env[:forwarded_ports].each do |fp|\n            if fp.host_port <= 1024\n              env[:ui].warn I18n.t(\"vagrant.actions.vm.forward_ports.privileged_ports\")\n              break\n            end",
    "comment": "-------------------------------------------------------------- Execution --------------------------------------------------------------",
    "label": "",
    "id": "940"
  },
  {
    "raw_code": "def correct_host_port(new_port)\n          @host_port = new_port\n        end",
    "comment": "This corrects the host port and changes it to the given new port.  @param [Integer] new_port The new port",
    "label": "",
    "id": "941"
  },
  {
    "raw_code": "def get_controller(name)\n          controller = detect { |c| c.name == name }\n          if !controller\n            raise Vagrant::Errors::VirtualBoxDisksControllerNotFound, name: name\n          end",
    "comment": "Returns a storage controller with the given name. Raises an exception if a matching controller can't be found.  @param [String] name - The name of the storage controller @return [VagrantPlugins::ProviderVirtualBox::Model::StorageController]",
    "label": "",
    "id": "942"
  },
  {
    "raw_code": "def get_primary_controller\n          ordered = find_all(&:supported?).sort_by(&:boot_priority)\n          controller = ordered.detect { |c| c.attachments.any? { |a| hdd?(a) } }\n\n          if !controller\n            raise Vagrant::Errors::VirtualBoxDisksNoSupportedControllers,\n              supported_types: supported_types.join(\", \")\n          end",
    "comment": "Find the controller containing the primary disk (i.e. the boot disk). This is used to determine which controller virtual disks should be attached to.  Raises an exception if no supported controllers are found.  @return [VagrantPlugins::ProviderVirtualBox::Model::StorageController]",
    "label": "",
    "id": "943"
  },
  {
    "raw_code": "def get_primary_attachment\n          attachment = nil\n\n          controller = get_primary_controller\n          attachment = controller.get_attachment(port: \"0\", device: \"0\")\n          if !attachment\n            raise Vagrant::Errors::VirtualBoxDisksPrimaryNotFound\n          end",
    "comment": "Find the attachment representing the primary disk (i.e. the boot disk). We can't rely on the order of #list_hdds, as they will not always come in port order, but primary is always Port 0 Device 0.  @return [Hash] attachment - Primary disk attachment information",
    "label": "",
    "id": "944"
  },
  {
    "raw_code": "def get_dvd_controller\n          ordered = find_all(&:supported?).sort_by(&:boot_priority)\n          controller = ordered.first\n          if !controller\n            raise Vagrant::Errors::VirtualBoxDisksNoSupportedControllers,\n              supported_types: supported_types.join(\", \")\n          end",
    "comment": "Returns the first supported storage controller for attaching dvds. Will raise an exception if no suitable controller can be found.  @return [VagrantPlugins::ProviderVirtualBox::Model::StorageController]",
    "label": "",
    "id": "945"
  },
  {
    "raw_code": "def hdd?(attachment)\n          if !attachment\n            false\n          else\n            ext = File.extname(attachment[:location].to_s).downcase.split('.').last\n            VagrantPlugins::ProviderVirtualBox::Cap::ValidateDiskExt.validate_disk_ext(nil, ext)\n          end",
    "comment": "Determine whether the given attachment is a hard disk.  @param [Hash] attachment - Attachment information @return [Boolean]",
    "label": "",
    "id": "946"
  },
  {
    "raw_code": "def supported_types\n          StorageController::SATA_CONTROLLER_TYPES + StorageController::IDE_CONTROLLER_TYPES +\n            StorageController::SCSI_CONTROLLER_TYPES\n        end",
    "comment": "Returns a list of all the supported controller types.  @return [Array<String>]",
    "label": "",
    "id": "947"
  },
  {
    "raw_code": "def get_attachment(opts = {})\n          if opts[:port] && opts[:device]\n            @attachments.detect { |a| a[:port] == opts[:port] &&\n                                      a[:device] == opts[:device] }\n          elsif opts[:uuid]\n            @attachments.detect { |a| a[:uuid] == opts[:uuid] }\n          end",
    "comment": "Get a single storage device, either by port/device address or by UUID.  @param [Hash] opts - A hash of options to match @return [Hash] attachment - Attachment information",
    "label": "",
    "id": "948"
  },
  {
    "raw_code": "def supported?\n          [:ide, :sata, :scsi].include?(@storage_bus)\n        end",
    "comment": "Returns true if the storage controller has a supported type.  @return [Boolean]",
    "label": "",
    "id": "949"
  },
  {
    "raw_code": "def ide?\n          @storage_bus == :ide\n        end",
    "comment": "Returns true if the storage controller is a IDE type controller.  @return [Boolean]",
    "label": "",
    "id": "950"
  },
  {
    "raw_code": "def sata?\n          @storage_bus == :sata\n        end",
    "comment": "Returns true if the storage controller is a SATA type controller.  @return [Boolean]",
    "label": "",
    "id": "951"
  },
  {
    "raw_code": "def scsi?\n          @storage_bus == :scsi\n        end",
    "comment": "Returns true if the storage controller is a SCSI type controller.  @return [Boolean]",
    "label": "",
    "id": "952"
  },
  {
    "raw_code": "def ssh_info\n        # We can only SSH into a running machine\n        return nil if state.id != :running\n\n        # Read the IP of the machine using Hyper-V APIs\n        guest_ip = nil\n\n        begin\n          network_info = @driver.read_guest_ip\n          guest_ip = network_info[\"ip\"]\n        rescue Errors::PowerShellError\n          @logger.warn(\"Failed to read guest IP.\")\n        end",
    "comment": "@return [Hash]",
    "label": "",
    "id": "953"
  },
  {
    "raw_code": "def self.action_package\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use CheckEnabled\n          b.use Call, IsState, :not_created do |env1, b2|\n            if env1[:result]\n              b2.use Message, I18n.t(\"vagrant_hyperv.message_not_created\")\n              next\n            end",
    "comment": "This action packages the virtual machine into a single box file.",
    "label": "",
    "id": "954"
  },
  {
    "raw_code": "def has_vmcx_support?\n        !!execute(:has_vmcx_support)[\"result\"]\n      end",
    "comment": "@return [Boolean] Supports VMCX",
    "label": "",
    "id": "955"
  },
  {
    "raw_code": "def execute(path, options={})\n        if path.is_a?(Symbol)\n          path = \"#{path}.ps1\"\n        end",
    "comment": "Execute a PowerShell command and process the results  @param [String] path Path to PowerShell script @param [Hash] options Options to pass to command  @return [Object, nil] If the command returned JSON content it will be parsed and returned, otherwise nil will be returned",
    "label": "",
    "id": "956"
  },
  {
    "raw_code": "def get_current_state\n        execute(:get_vm_status, VmId: vm_id)\n      end",
    "comment": "Fetch current state of the VM  @return [Hash<state, status>]",
    "label": "",
    "id": "957"
  },
  {
    "raw_code": "def delete_vm\n        execute(:delete_vm, VmId: vm_id)\n      end",
    "comment": "Delete the VM  @return [nil]",
    "label": "",
    "id": "958"
  },
  {
    "raw_code": "def export(path)\n        execute(:export_vm, VmId: vm_id, Path: path)\n      end",
    "comment": "Export the VM to the given path  @param [String] path Path for export @return [nil]",
    "label": "",
    "id": "959"
  },
  {
    "raw_code": "def read_guest_ip\n        execute(:get_network_config, VmId: vm_id)\n      end",
    "comment": "Get the IP address of the VM  @return [Hash<ip>]",
    "label": "",
    "id": "960"
  },
  {
    "raw_code": "def read_mac_address\n        execute(:get_network_mac, VmId: vm_id)\n      end",
    "comment": "Get the MAC address of the VM  @return [Hash<mac>]",
    "label": "",
    "id": "961"
  },
  {
    "raw_code": "def resume\n        execute(:resume_vm, VmId: vm_id)\n      end",
    "comment": "Resume the VM from suspension  @return [nil]",
    "label": "",
    "id": "962"
  },
  {
    "raw_code": "def start\n        execute(:start_vm, VmId: vm_id )\n      end",
    "comment": "Start the VM  @return [nil]",
    "label": "",
    "id": "963"
  },
  {
    "raw_code": "def stop\n        execute(:stop_vm, VmId: vm_id)\n      end",
    "comment": "Stop the VM  @return [nil]",
    "label": "",
    "id": "964"
  },
  {
    "raw_code": "def suspend\n        execute(:suspend_vm, VmId: vm_id)\n      end",
    "comment": "Suspend the VM  @return [nil]",
    "label": "",
    "id": "965"
  },
  {
    "raw_code": "def import(options)\n        execute(:import_vm, options)\n      end",
    "comment": "Import a new VM  @param [Hash] options Configuration options @return [Hash<id>] New VM ID",
    "label": "",
    "id": "966"
  },
  {
    "raw_code": "def net_set_vlan(vlan_id)\n        execute(:set_network_vlan, VmId: vm_id, VlanId: vlan_id)\n      end",
    "comment": "Set the VLAN ID  @param [String] vlan_id VLAN ID @return [nil]",
    "label": "",
    "id": "967"
  },
  {
    "raw_code": "def net_set_mac(mac_addr)\n        execute(:set_network_mac, VmId: vm_id, Mac: mac_addr)\n      end",
    "comment": "Set the VM adapter MAC address  @param [String] mac_addr MAC address @return [nil]",
    "label": "",
    "id": "968"
  },
  {
    "raw_code": "def create_snapshot(snapshot_name)\n        execute(:create_snapshot, VmId: vm_id, SnapName: snapshot_name)\n      end",
    "comment": "Create a new snapshot with the given name  @param [String] snapshot_name Name of the new snapshot @return [nil]",
    "label": "",
    "id": "969"
  },
  {
    "raw_code": "def restore_snapshot(snapshot_name)\n        execute(:restore_snapshot, VmId: vm_id,  SnapName: snapshot_name)\n      end",
    "comment": "Restore the given snapshot  @param [String] snapshot_name Name of snapshot to restore @return [nil]",
    "label": "",
    "id": "970"
  },
  {
    "raw_code": "def list_snapshots\n        snaps = execute(:list_snapshots, VmID: vm_id)\n        snaps.map { |s| s['Name'] }\n      end",
    "comment": "Get list of current snapshots  @return [Array<String>] snapshot names",
    "label": "",
    "id": "971"
  },
  {
    "raw_code": "def delete_snapshot(snapshot_name)\n        execute(:delete_snapshot, VmID: vm_id, SnapName: snapshot_name)\n      end",
    "comment": "Delete snapshot with the given name  @param [String] snapshot_name Name of snapshot to delete @return [nil]",
    "label": "",
    "id": "972"
  },
  {
    "raw_code": "def set_vm_integration_services(config)\n        config.each_pair do |srv_name, srv_enable|\n          args = {VMID: vm_id, Id: INTEGRATION_SERVICES_MAP.fetch(srv_name.to_sym, srv_name).to_s}\n          args[:Enable] = true if srv_enable\n          execute(:set_vm_integration_services, args)\n        end",
    "comment": "Enable or disable VM integration services  @param [Hash] config Integration services to enable or disable @return [nil] @note Keys in the config hash will be remapped if found in the INTEGRATION_SERVICES_MAP. If they are not, the name will be passed directly. This allows new integration services to configurable even if Vagrant is not aware of them.",
    "label": "",
    "id": "973"
  },
  {
    "raw_code": "def set_name(vmname)\n        execute(:set_name, VMID: vm_id, VMName: vmname)\n      end",
    "comment": "Set the name of the VM  @param [String] vmname Name of the VM @return [nil]",
    "label": "",
    "id": "974"
  },
  {
    "raw_code": "def attach_disk(disk_file_path,  **opts)\n        execute(:attach_disk_drive, VmId: @vm_id, Path: disk_file_path, ControllerType: opts[:ControllerType],\n                ControllerNumber: opts[:ControllerNumber], ControllerLocation: opts[:ControllerLocation])\n      end",
    "comment": " Disk Driver methods  @param [String] controller_type @param [String] controller_number @param [String] controller_location @param [Hash] opts @option opts [String] :ControllerType @option opts [String] :ControllerNumber @option opts [String] :ControllerLocation",
    "label": "",
    "id": "975"
  },
  {
    "raw_code": "def create_disk(path, size_bytes, **opts)\n        execute(:new_vhd, Path: path, SizeBytes: size_bytes, Fixed: opts[:Fixed],\n               BlockSizeBytes: opts[:BlockSizeBytes], LogicalSectorSizeBytes: opts[:LogicalSectorSizeBytes],\n               PhysicalSectorSizeBytes: opts[:PhysicalSectorSizeBytes],\n               SourceDisk: opts[:SourceDisk], Differencing: opts[:Differencing],\n               ParentPath: opts[:ParentPath])\n      end",
    "comment": "@param [String] path @param [Int] size_bytes @param [Hash] opts @option opts [Bool] :Fixed @option opts [String] :BlockSizeBytes @option opts [String] :LogicalSectorSizeBytes @option opts [String] :PhysicalSectorSizeBytes @option opts [String] :SourceDisk @option opts [Bool] :Differencing @option opts [String] :ParentPath",
    "label": "",
    "id": "976"
  },
  {
    "raw_code": "def dismount_disk(disk_file_path)\n        execute(:dismount_vhd, DiskFilePath: disk_file_path)\n      end",
    "comment": "@param [String] disk_file_path",
    "label": "",
    "id": "977"
  },
  {
    "raw_code": "def get_disk(disk_file_path)\n        execute(:get_vhd, DiskFilePath: disk_file_path)\n      end",
    "comment": "@param [String] disk_file_path",
    "label": "",
    "id": "978"
  },
  {
    "raw_code": "def attach_dvd(iso_path)\n        execute(:add_dvd, VmId: vm_id, ISOPath: iso_path)\n      end",
    "comment": "Add a DVD drive to VM  @param [String] iso_path @return [nil]",
    "label": "",
    "id": "979"
  },
  {
    "raw_code": "def detach_dvd(controller_location, controller_number)\n        execute(:remove_dvd,\n          VmId: vm_id,\n          ControllerLocation: controller_location,\n          ControllerNumber: controller_number\n        )\n      end",
    "comment": "Remove a DVD drive from VM  @param [Integer] controller_location @param [Integer] controller_number @return [nil]",
    "label": "",
    "id": "980"
  },
  {
    "raw_code": "def list_hdds\n        execute(:list_hdds, VmId: @vm_id)\n      end",
    "comment": "@return [Array[Hash]]",
    "label": "",
    "id": "981"
  },
  {
    "raw_code": "def remove_disk(controller_type, controller_number, controller_location, disk_file_path, **opts)\n        execute(:remove_disk_drive, VmId: @vm_id, ControllerType: controller_type,\n                ControllerNumber: controller_number, ControllerLocation: controller_location,\n                DiskFilePath: disk_file_path)\n      end",
    "comment": "@param [String] controller_type @param [String] controller_number @param [String] controller_location @param [String] disk_file_path @param [Hash] opts @option opts [String] :ControllerType @option opts [String] :ControllerNumber @option opts [String] :ControllerLocation",
    "label": "",
    "id": "982"
  },
  {
    "raw_code": "def resize_disk(disk_file_path, size_bytes, **opts)\n        execute(:resize_disk_drive, VmId: @vm_id, DiskFilePath: disk_file_path,\n                DiskSize: size_bytes)\n      end",
    "comment": "@param [String] path @param [Int] size_bytes @param [Hash] opts",
    "label": "",
    "id": "983"
  },
  {
    "raw_code": "def set_enhanced_session_transport_type(transport_type)\n        result = execute(:set_enhanced_session_transport_type, VmID: vm_id, type: transport_type)\n        if !result.nil?\n          @logger.debug(\"EnhancedSessionTransportType is not supported by this version of hyperv, ignoring\")\n        end",
    "comment": "Set enhanced session transport type of the VM  @param [String] enhanced session transport type of the VM @return [nil]",
    "label": "",
    "id": "984"
  },
  {
    "raw_code": "def read_scsi_controllers\n        result = execute(:get_scsi_controller, VmId: vm_id)\n        return result if result.is_a?(Array)\n        [result]\n      end",
    "comment": "Get SCSI controllers attached to VM  @return [Array<Hash>]",
    "label": "",
    "id": "985"
  },
  {
    "raw_code": "def self.validate_disk_ext(machine, disk_ext)\n          DEFAULT_DISK_EXT_LIST.include?(disk_ext)\n        end",
    "comment": "@param [Vagrant::Machine] machine @param [String] disk_ext @return [Bool]",
    "label": "",
    "id": "986"
  },
  {
    "raw_code": "def self.default_disk_exts(machine)\n          DEFAULT_DISK_EXT_LIST\n        end",
    "comment": "@param [Vagrant::Machine] machine @return [Array]",
    "label": "",
    "id": "987"
  },
  {
    "raw_code": "def self.set_default_disk_ext(machine)\n          DEFAULT_DISK_EXT\n        end",
    "comment": "@param [Vagrant::Machine] machine @return [String]",
    "label": "",
    "id": "988"
  },
  {
    "raw_code": "def self.cleanup_disks(machine, defined_disks, disk_meta_file)\n          return if disk_meta_file.values.flatten.empty?\n\n          handle_cleanup_disk(machine, defined_disks, disk_meta_file[\"disk\"])\n          handle_cleanup_dvd(machine, defined_disks, disk_meta_file[\"dvd\"])\n          # TODO: Floppy disks\n        end",
    "comment": "@param [Vagrant::Machine] machine @param [VagrantPlugins::Kernel_V2::VagrantConfigDisk] defined_disks @param [Hash] disk_meta_file - A hash of all the previously defined disks from the last configure_disk action",
    "label": "",
    "id": "989"
  },
  {
    "raw_code": "def self.handle_cleanup_disk(machine, defined_disks, disk_meta)\n          all_disks = machine.provider.driver.list_hdds\n\n          disk_meta.each do |d|\n            # look at Path instead of Name or UUID\n            disk_name  = File.basename(d[\"Path\"], '.*')\n            dsk = defined_disks.select { |dk| dk.name == disk_name }\n\n            if !dsk.empty? || d[\"primary\"] == true\n              next\n            else\n              LOGGER.warn(\"Found disk not in Vagrantfile config: '#{d[\"Name\"]}'. Removing disk from guest #{machine.name}\")\n\n              machine.ui.warn(I18n.t(\"vagrant.cap.cleanup_disks.disk_cleanup\", name: d[\"Name\"]), prefix: true)\n\n              disk_actual = all_disks.select { |a| File.realdirpath(a[\"Path\"]) == File.realdirpath(d[\"Path\"]) }.first\n              if !disk_actual\n                machine.ui.warn(I18n.t(\"vagrant.cap.cleanup_disks.disk_not_found\", name: d[\"Name\"]), prefix: true)\n              else\n                machine.provider.driver.remove_disk(disk_actual[\"ControllerType\"], disk_actual[\"ControllerNumber\"], disk_actual[\"ControllerLocation\"], disk_actual[\"Path\"])\n              end",
    "comment": "@param [Vagrant::Machine] machine @param [VagrantPlugins::Kernel_V2::VagrantConfigDisk] defined_disks @param [Hash] disk_meta - A hash of all the previously defined disks from the last configure_disk action",
    "label": "",
    "id": "990"
  },
  {
    "raw_code": "def self.configure_disks(machine, defined_disks)\n          return {} if defined_disks.empty?\n\n          machine.ui.info(I18n.t(\"vagrant.cap.configure_disks.start\"))\n\n          current_disks = machine.provider.driver.list_hdds\n\n          configured_disks = {disk: [], floppy: [], dvd: []}\n\n          defined_disks.each do |disk|\n            if disk.type == :disk\n              disk_data = handle_configure_disk(machine, disk, current_disks)\n              configured_disks[:disk] << disk_data if !disk_data.empty?\n            elsif disk.type == :floppy\n              # TODO: Write me\n              machine.ui.info(I18n.t(\"vagrant.cap.configure_disks.floppy_not_supported\", name: disk.name))\n            elsif disk.type == :dvd\n              disk_data = handle_configure_dvd(machine, disk)\n              configured_disks[:dvd] << disk_data if !disk_data.empty?\n            end",
    "comment": "@param [Vagrant::Machine] machine @param [VagrantPlugins::Kernel_V2::VagrantConfigDisk] defined_disks @return [Hash] configured_disks - A hash of all the current configured disks",
    "label": "",
    "id": "991"
  },
  {
    "raw_code": "def self.get_current_disk(machine, disk, all_disks)\n          current_disk = nil\n          if disk.primary\n            # Ensure we grab the proper primary disk\n            # We can't rely on the order of `all_disks`, as they will not\n            # always come in port order, but primary should always be the\n            # first disk.\n\n            sorted_disks = all_disks.sort_by { |d|\n              [d[\"ControllerNumber\"].to_i, d[\"ControllerLocation\"].to_i]\n            }\n\n            LOGGER.debug(\"sorted disks for primary detection: #{sorted_disks}\")\n\n            current_disk = sorted_disks.first\n\n            # Need to get actual disk info to obtain UUID instead of what's returned\n            #\n            # This is not required for newly created disks, as its metadata is\n            # set when creating and attaching the disk. This is only for the primary\n            # disk, since it already exists.\n            current_disk = machine.provider.driver.get_disk(current_disk[\"Path\"])\n          else\n            # Hyper-V disk names aren't the actual names of the disk, so we have\n            # to grab the name from the file path instead\n            current_disk = all_disks.detect { |d| File.basename(d[\"Path\"], '.*') == disk.name}\n          end",
    "comment": "@param [Vagrant::Machine] machine - the current machine @param [Config::Disk] disk - the current disk to configure @param [Array] all_disks - A list of all currently defined disks in VirtualBox @return [Hash] current_disk - Returns the current disk. Returns nil if it doesn't exist",
    "label": "",
    "id": "992"
  },
  {
    "raw_code": "def self.handle_configure_disk(machine, disk, all_disks)\n          disk_metadata = {}\n\n          # Grab the existing configured disk, if it exists\n          current_disk = get_current_disk(machine, disk, all_disks)\n\n          # Configure current disk\n          if !current_disk\n            # create new disk and attach\n            disk_metadata = create_disk(machine, disk)\n          elsif compare_disk_size(machine, disk, current_disk)\n            disk_metadata = resize_disk(machine, disk, current_disk)\n          else\n            disk_metadata = {UUID: current_disk[\"DiskIdentifier\"], Name: disk.name, Path: current_disk[\"Path\"]}\n            if disk.primary\n              disk_metadata[:primary] = true\n            end",
    "comment": "Handles all disk configs of type `:disk`  @param [Vagrant::Machine] machine - the current machine @param [Config::Disk] disk - the current disk to configure @param [Array] all_disks - A list of all currently defined disks in VirtualBox @return [Hash] - disk_metadata",
    "label": "",
    "id": "993"
  },
  {
    "raw_code": "def self.compare_disk_size(machine, disk_config, defined_disk)\n          # Hyper-V returns disk size in bytes\n          requested_disk_size = disk_config.size\n          disk_actual = machine.provider.driver.get_disk(defined_disk[\"Path\"])\n          defined_disk_size = disk_actual[\"Size\"]\n\n          if defined_disk_size > requested_disk_size\n            if File.extname(disk_actual[\"Path\"]) == \".vhdx\"\n              # VHDX formats can be shrunk\n              return true\n            else\n              machine.ui.warn(I18n.t(\"vagrant.cap.configure_disks.shrink_size_not_supported\", name: disk_config.name))\n              return false\n            end",
    "comment": "Check to see if current disk is configured based on defined_disks  @param [Kernel_V2::VagrantConfigDisk] disk_config @param [Hash] defined_disk @return [Boolean]",
    "label": "",
    "id": "994"
  },
  {
    "raw_code": "def self.create_disk(machine, disk_config)\n          machine.ui.detail(I18n.t(\"vagrant.cap.configure_disks.create_disk\", name: disk_config.name))\n          disk_provider_config = {}\n\n          if disk_config.provider_config && disk_config.provider_config.key?(:hyperv)\n            disk_provider_config = disk_config.provider_config[:hyperv]\n          end",
    "comment": "Creates and attaches a disk to a machine  @param [Vagrant::Machine] machine @param [Kernel_V2::VagrantConfigDisk] disk_config",
    "label": "",
    "id": "995"
  },
  {
    "raw_code": "def self.convert_size_vars!(disk_provider_config)\n          if disk_provider_config.key?(:BlockSizeBytes)\n            bytes = Vagrant::Util::Numeric.string_to_bytes(disk_provider_config[:BlockSizeBytes])\n            disk_provider_config[:BlockSizeBytes] = bytes\n          end",
    "comment": "Converts any \"shortcut\" options such as \"123MB\" into its byte form. This is due to what parameter type is expected when calling the `New-VHD` powershell command  @param [Hash] disk_provider_config @return [Hash] disk_provider_config",
    "label": "",
    "id": "996"
  },
  {
    "raw_code": "def self.resize_disk(machine, disk_config, defined_disk)\n          machine.ui.detail(I18n.t(\"vagrant.cap.configure_disks.resize_disk\", name: disk_config.name), prefix: true)\n\n          machine.provider.driver.resize_disk(defined_disk[\"Path\"], disk_config.size.to_i)\n\n          disk_info = machine.provider.driver.get_disk(defined_disk[\"Path\"])\n\n          # Store updated metadata\n          disk_metadata = {UUID: disk_info[\"DiskIdentifier\"], Name: disk_config.name, Path: disk_info[\"Path\"]}\n\n          disk_metadata\n        end",
    "comment": "@param [Vagrant::Machine] machine @param [Config::Disk] disk_config - the current disk to configure @param [Hash] defined_disk - current disk as represented by VirtualBox @return [Hash] - disk_metadata",
    "label": "",
    "id": "997"
  },
  {
    "raw_code": "def create_metadata\n          File.open(File.join(@env[\"export.temp_dir\"], \"metadata.json\"), \"w\") do |f|\n            f.write(JSON.generate({\n              provider: \"hyperv\"\n            }))\n          end",
    "comment": "This method creates a metadata.json file to tell vagrant this is a Hyper V box",
    "label": "",
    "id": "998"
  },
  {
    "raw_code": "def create_vagrantfile\n          File.open(File.join(@env[\"export.temp_dir\"], \"Vagrantfile\"), \"w\") do |f|\n            mac_address = @env[:machine].provider.driver.read_mac_address\n            f.write(TemplateRenderer.render(\"package_Vagrantfile\", {\n              base_mac: mac_address[\"mac\"]\n            }))\n          end",
    "comment": "This method creates the auto-generated Vagrantfile at the root of the box. This Vagrantfile contains the MAC address so that the user doesn't have to worry about it.",
    "label": "",
    "id": "999"
  },
  {
    "raw_code": "def self.folder_dupe_check(folders)\n          return_folders = {}\n          # Group by hostpath to see if there are multiple exports coming\n          # from the same folder\n          export_groups = folders.values.group_by { |h| h[:hostpath] }\n\n          # We need to check that each group key only has 1 value,\n          # and if not, check each nfs option. If all nfs options are the same\n          # we're good, otherwise throw an exception\n          export_groups.each do |path,group|\n            if group.size > 1\n              # if the linux nfs options aren't all the same throw an exception\n              group1_opts = group.first[:linux__nfs_options]\n\n              if !group.all? {|g| g[:linux__nfs_options] == group1_opts}\n                raise Vagrant::Errors::NFSDupePerms, hostpath: group.first[:hostpath]\n              else\n                # if they're the same just pick the first one\n                return_folders[path] = group.first\n              end",
    "comment": "Takes a hash of folders and removes any duplicate exports that share the same hostpath to avoid duplicate entries in /etc/exports ref: GH-4666",
    "label": "",
    "id": "1000"
  },
  {
    "raw_code": "def self.reset!\n          instance_variables.each(&method(:remove_instance_variable))\n        end",
    "comment": "@private Reset the cached values for capability. This is not considered a public API and should only be used for testing.",
    "label": "",
    "id": "1001"
  },
  {
    "raw_code": "def self.set_ssh_key_permissions(env, key_path)\n          key_path.chmod(0600)\n        end",
    "comment": "Set the ownership and permissions for SSH private key  @param [Vagrant::Environment] env @param [Pathname] key_path",
    "label": "",
    "id": "1002"
  },
  {
    "raw_code": "def self.isofs_available(env)\n          !!Vagrant::Util::Which.which(BUILD_ISO_CMD)\n        end",
    "comment": "Check that the host has the ability to generate ISOs  @param [Vagrant::Environment] env @return [Boolean]",
    "label": "",
    "id": "1003"
  },
  {
    "raw_code": "def self.create_iso(env, source_directory, extra_opts={})\n          source_directory = Pathname.new(source_directory)\n          file_destination = self.ensure_output_iso(extra_opts[:file_destination])\n\n          iso_command = [BUILD_ISO_CMD, \"-joliet\"]\n          iso_command.concat([\"-volid\", extra_opts[:volume_id]]) if extra_opts[:volume_id]\n          iso_command << \"-o\"\n          iso_command << file_destination.to_s\n          iso_command << source_directory.to_s\n          self.build_iso(iso_command, source_directory, file_destination)\n\n          @@logger.info(\"ISO available at #{file_destination}\")\n          file_destination\n        end",
    "comment": "Generate an ISO file of the given source directory  @param [Vagrant::Environment] env @param [String] source_directory Contents of ISO @param [Map] extra arguments to pass to the iso building command :file_destination (string) location to store ISO :volume_id (String) to set the volume name @return [Pathname] ISO location @note If file_destination exists, source_directory will be checked for recent modifications and a new ISO will be generated if requried.",
    "label": "",
    "id": "1004"
  },
  {
    "raw_code": "def self.set_ssh_key_permissions(env, key_path)\n          key_path.chmod(0600)\n        end",
    "comment": "Set the ownership and permissions for SSH private key  @param [Vagrant::Environment] env @param [Pathname] key_path",
    "label": "",
    "id": "1005"
  },
  {
    "raw_code": "def self.generate_config_file(rdp_info)\n          opts   = {\n            \"drivestoredirect:s\"       => \"*\",\n            \"full address:s\"           => \"#{rdp_info[:host]}:#{rdp_info[:port]}\",\n            \"prompt for credentials:i\" => \"1\",\n            \"username:s\"               => rdp_info[:username],\n          }\n\n          # Create the \".rdp\" file\n          t = ::Tempfile.new([\"vagrant-rdp\", \".rdp\"]).tap do |f|\n            f.binmode\n\n            opts.each do |k, v|\n              f.puts(\"#{k}:#{v}\")\n            end",
    "comment": "Generates an RDP connection file and returns the resulting path. @return [String]",
    "label": "",
    "id": "1006"
  },
  {
    "raw_code": "def self.smb_installed(env)\n          File.exist?(\"/usr/sbin/sharing\")\n        end",
    "comment": "If we have the sharing binary available, smb is installed",
    "label": "",
    "id": "1007"
  },
  {
    "raw_code": "def self.smb_start(env)\n          result = Vagrant::Util::Subprocess.execute(\"pwpolicy\", \"gethashtypes\")\n          if result.exit_code == 0 && !result.stdout.include?(\"SMB-NT\")\n            @@logger.error(\"SMB compatible password has not been stored\")\n            raise SyncedFolderSMB::Errors::SMBCredentialsMissing\n          end",
    "comment": "Check if the required SMB services are loaded and enabled. If they are not, then start them up",
    "label": "",
    "id": "1008"
  },
  {
    "raw_code": "def self.smb_mount_options(env)\n          [\"sec=ntlmssp\", \"nounix\", \"noperm\"]\n        end",
    "comment": "Required options for mounting a share hosted on macos.",
    "label": "",
    "id": "1009"
  },
  {
    "raw_code": "def self.machine_id(machine)\n          @@logger.debug(\"generating machine ID name=#{machine.name} cwd=#{machine.env.cwd}\")\n          Digest::MD5.hexdigest(\"#{machine.name}-#{machine.provider_name}-#{machine.env.cwd}\")\n        end",
    "comment": "Generates a unique identifier for the given machine based on the name, provider name, and working directory of the environment.  @param [Vagrant::Machine] machine @return [String]",
    "label": "",
    "id": "1010"
  },
  {
    "raw_code": "def self.isofs_available(env)\n          !!Vagrant::Util::Which.which(BUILD_ISO_CMD)\n        end",
    "comment": "Check that the host has the ability to generate ISOs  @param [Vagrant::Environment] env @return [Boolean]",
    "label": "",
    "id": "1011"
  },
  {
    "raw_code": "def self.create_iso(env, source_directory, extra_opts={})\n          source_directory = Pathname.new(source_directory)\n          file_destination = self.ensure_output_iso(extra_opts[:file_destination])\n\n          iso_command = [BUILD_ISO_CMD, \"makehybrid\", \"-iso\", \"-joliet\", \"-ov\"]\n          iso_command.concat([\"-default-volume-name\", extra_opts[:volume_id]]) if extra_opts[:volume_id]\n          iso_command << \"-o\"\n          iso_command << file_destination.to_s\n          iso_command << source_directory.to_s\n          self.build_iso(iso_command, source_directory, file_destination)\n\n          @@logger.info(\"ISO available at #{file_destination}\")\n          file_destination\n        end",
    "comment": "Generate an ISO file of the given source directory  @param [Vagrant::Environment] env @param [String] source_directory Contents of ISO @param [Map] extra arguments to pass to the iso building command :file_destination (string) location to store ISO :volume_id (String) to set the volume name @return [Pathname] ISO location @note If file_destination exists, source_directory will be checked for recent modifications and a new ISO will be generated if requried.",
    "label": "",
    "id": "1012"
  },
  {
    "raw_code": "def self.resolve_host_path(env, path)\n          path = File.expand_path(path)\n          # Only expand firmlink paths on Catalina\n          host_version = env.host.capability(:version)\n          return path if !CATALINA_CONSTRAINT.satisfied_by?(host_version)\n\n          firmlink = firmlink_map.detect do |mount_path, data_path|\n            path.start_with?(mount_path)\n          end",
    "comment": "Resolve the given host path to the actual usable system path by detecting firmlinks if available on the current system  @param [String] path Host system path @return [String] resolved path",
    "label": "",
    "id": "1013"
  },
  {
    "raw_code": "def self.firmlink_map\n          if !@firmlink_map\n            return @firmlink_map = {} if !File.exist?(FIRMLINK_DEFS)\n            begin\n              @firmlink_map = Hash[\n                File.readlines(FIRMLINK_DEFS).map { |d|\n                  d.strip.split(/\\s+/, 2)\n                }\n              ]\n            rescue => err\n              @@logger.warn(\"Failed to parse firmlink definitions: #{err}\")\n              @firmlink_map = {}\n            end",
    "comment": "Generate mapping of firmlinks if available on the host  @return [Hash<String,String>]",
    "label": "",
    "id": "1014"
  },
  {
    "raw_code": "def self.reset!\n          instance_variables.each(&method(:remove_instance_variable))\n        end",
    "comment": "@private Reset the cached values for capability. This is not considered a public API and should only be used for testing.",
    "label": "",
    "id": "1015"
  },
  {
    "raw_code": "def self.scripts_path\n        Pathname.new(File.expand_path(\"../scripts\", __FILE__))\n      end",
    "comment": "@return [Pathname] Path to scripts directory",
    "label": "",
    "id": "1016"
  },
  {
    "raw_code": "def self.modules_path\n        scripts_path.join(\"utils\")\n      end",
    "comment": "@return [Pathname] Path to modules directory",
    "label": "",
    "id": "1017"
  },
  {
    "raw_code": "def self.smb_mount_options(env)\n          [\"vers=2.0\"]\n        end",
    "comment": "Required options for mounting a share hosted on Windows NOTE: Windows deprecated smb 1.0 so a minimum of 2.0 must be enabled",
    "label": "",
    "id": "1018"
  },
  {
    "raw_code": "def self.existing_shares\n          shares = get_smbshares || get_netshares\n          if shares.nil?\n            raise SyncedFolderSMB::Errors::SMBListFailed\n          end",
    "comment": "Generate a list of existing local smb shares  @return [Hash]",
    "label": "",
    "id": "1019"
  },
  {
    "raw_code": "def self.get_smbshares\n          result = Vagrant::Util::PowerShell.execute_cmd(\"Get-SmbShare|Format-List|Out-String -Width 4096\")\n          if result.nil?\n            return nil\n          end",
    "comment": "Get current SMB share list using Get-SmbShare  @return [Hash]",
    "label": "",
    "id": "1020"
  },
  {
    "raw_code": "def self.get_netshares\n          result = Vagrant::Util::PowerShell.execute_cmd(\"net share | Out-String -Width 4096\")\n          if result.nil?\n            return nil\n          end",
    "comment": "Get current SMB share list using net.exe  @return [Hash]",
    "label": "",
    "id": "1021"
  },
  {
    "raw_code": "def self.machine_id(machine)\n          @@logger.debug(\"generating machine ID name=#{machine.name} cwd=#{machine.env.cwd}\")\n          Digest::MD5.hexdigest(\"#{machine.name}-#{machine.provider_name}-#{machine.env.cwd}\")\n        end",
    "comment": "Generates a unique identifier for the given machine based on the name, provider name, and working directory of the environment.  @param [Vagrant::Machine] machine @return [String]",
    "label": "",
    "id": "1022"
  },
  {
    "raw_code": "def self.set_ssh_key_permissions(env, key_path)\n          script_path = Host.scripts_path.join(\"set_ssh_key_permissions.ps1\")\n          result = Vagrant::Util::PowerShell.execute(\n            script_path.to_s, \"-KeyPath\", key_path.to_s.gsub(' ', '` '),\n            module_path: Host.modules_path.to_s\n          )\n          if result.exit_code != 0\n            raise Vagrant::Errors::PowerShellError,\n              script: script_path,\n              stderr: result.stderr\n          end",
    "comment": "Set the ownership and permissions for SSH private key  @param [Vagrant::Environment] env @param [Pathname] key_path",
    "label": "",
    "id": "1023"
  },
  {
    "raw_code": "def self.isofs_available(env)\n          begin\n            oscdimg_path\n            true\n          rescue Vagrant::Errors::OscdimgCommandMissingError\n            false\n          end",
    "comment": "Check that the host has the ability to generate ISOs  @param [Vagrant::Environment] env @return [Boolean]",
    "label": "",
    "id": "1024"
  },
  {
    "raw_code": "def self.create_iso(env, source_directory, extra_opts={})\n          source_directory = Pathname.new(source_directory)\n          file_destination = self.ensure_output_iso(extra_opts[:file_destination])\n\n          iso_command = [oscdimg_path, \"-j1\", \"-o\", \"-m\"]\n          iso_command << \"-l#{extra_opts[:volume_id]}\" if extra_opts[:volume_id]\n          iso_command << source_directory.to_s\n          iso_command << file_destination.to_s\n          self.build_iso(iso_command, source_directory, file_destination)\n\n          @@logger.info(\"ISO available at #{file_destination}\")\n          file_destination\n        end",
    "comment": "Generate an ISO file of the given source directory  @param [Vagrant::Environment] env @param [String] source_directory Contents of ISO @param [Map] extra arguments to pass to the iso building command :file_destination (string) location to store ISO :volume_id (String) to set the volume name @return [Pathname] ISO location @note If file_destination exists, source_directory will be checked for recent modifications and a new ISO will be generated if requried.",
    "label": "",
    "id": "1025"
  },
  {
    "raw_code": "def self.oscdimg_path\n          return BUILD_ISO_CMD if Vagrant::Util::Which.which(BUILD_ISO_CMD)\n          @@logger.debug(\"#{BUILD_ISO_CMD} not found on PATH\")\n          DEPLOYMENT_KIT_PATHS.each do |base|\n            path = File.join(base, Vagrant::Util::Platform.architecture,\n              \"Oscdimg\", BUILD_ISO_CMD)\n            @@logger.debug(\"#{BUILD_ISO_CMD} check at #{path}\")\n            return path if File.executable?(path)\n          end",
    "comment": "@return [String] oscdimg executable",
    "label": "",
    "id": "1026"
  },
  {
    "raw_code": "def self.systemd?\n          result = Vagrant::Util::Subprocess.execute(\"ps\", \"-o\", \"comm=\", \"1\")\n          return result.stdout.chomp == \"systemd\"\n        end",
    "comment": "This tests to see if systemd is used on the system. This is used in newer versions of ALT, and requires a change in behavior.",
    "label": "",
    "id": "1027"
  },
  {
    "raw_code": "def help\n          opts = OptionParser.new do |opts|\n            opts.banner = \"Usage: vagrant cloud <subcommand> [<args>]\"\n            opts.separator \"\"\n            opts.separator \"The cloud command can be used for taking actions against\"\n            opts.separator \"Vagrant Cloud like searching or uploading a Vagrant Box\"\n            opts.separator \"\"\n            opts.separator \"Available subcommands:\"\n\n            # Add the available subcommands as separators in order to print them\n            # out as well.\n            keys = []\n            @subcommands.each { |key, value| keys << key.to_s }\n\n            keys.sort.each do |key|\n              opts.separator \"     #{key.ljust(15)} #{@subcommand_helptext[key.to_sym]}\"\n            end",
    "comment": "Prints the help out for this command",
    "label": "",
    "id": "1028"
  },
  {
    "raw_code": "def search(query, access_token, options={})\n          account = VagrantCloud::Account.new(\n            custom_server: api_server_url,\n            access_token: access_token\n          )\n          params = {query: query}.merge(options.slice(:architecture, :provider, :sort, :order, :limit, :page))\n          result = account.searcher.search(**params)\n\n          if result.boxes.empty?\n            @env.ui.warn(I18n.t(\"cloud_command.search.no_results\", query: query))\n            return 0\n          end",
    "comment": "Perform requested search and display results to user  @param [String] query Search query string @param [Hash] options @option options [String] :provider Filter by provider @option options [String] :sort Field to sort results @option options [Integer] :limit Number of results to display @option options [Integer] :page Page of results to display @param [String] access_token User access token @return [Integer]",
    "label": "",
    "id": "1029"
  },
  {
    "raw_code": "def api_server_url\n        if Vagrant.server_url == Vagrant::DEFAULT_SERVER_URL\n          return \"#{Vagrant.server_url}/api/v1\"\n        end",
    "comment": "@return [String] Vagrant Cloud server URL",
    "label": "",
    "id": "1030"
  },
  {
    "raw_code": "def client_login(env, options={})\n        return @_client if defined?(@_client)\n        @_client = Client.new(env)\n        return @_client if @_client.logged_in?\n\n        # If directed to be quiet, do not continue and\n        # just return nil\n        return if options[:quiet]\n\n        # Let the user know what is going on.\n        env.ui.output(I18n.t(\"cloud_command.command_header\") + \"\\n\")\n\n        # If it is a private cloud installation, show that\n        if Vagrant.server_url != Vagrant::DEFAULT_SERVER_URL\n          env.ui.output(\"Vagrant Cloud URL: #{Vagrant.server_url}\")\n        end",
    "comment": "@param [Vagrant::Environment] env @param [Hash] options @option options [String] :login Username or email @option options [String] :description Description of login usage for token @option options [String] :code 2FA code for login @option options [Boolean] :quiet Do not prompt user @returns [VagrantPlugins::CloudCommand::Client, nil]",
    "label": "",
    "id": "1031"
  },
  {
    "raw_code": "def format_search_results(search_results, short, json, env)\n        result = search_results.map do |b|\n          {\n            name: b.tag,\n            version: b.current_version.version,\n            downloads: format_downloads(b.downloads.to_s),\n            providers: b.current_version.providers.map(&:name).uniq.join(\", \"),\n            architectures: b.current_version.providers.map(&:architecture).join(\", \")\n          }\n        end",
    "comment": "Print search results from Vagrant Cloud to the console  @param [Array<VagrantCloud::Box>] search_results Box search results from Vagrant Cloud @param [Boolean] short Print short summary @param [Boolean] json Print output in JSON format @param [Vagrant::Environment] env Current Vagrant environment @return [nil]",
    "label": "",
    "id": "1032"
  },
  {
    "raw_code": "def format_box_results(box, env, options={})\n        if box.is_a?(VagrantCloud::Box)\n          info = box_info(box, options)\n        elsif box.is_a?(VagrantCloud::Box::Version)\n          info = version_info(box)\n        else\n          info = provider_info(box)\n        end",
    "comment": "Output box details result from Vagrant Cloud  @param [VagrantCloud::Box, VagrantCloud::Box::Version] box Box or box version to display @param [Vagrant::Environment] env Current Vagrant environment @return [nil]",
    "label": "",
    "id": "1033"
  },
  {
    "raw_code": "def with_box(account:, org:, box:)\n        org = account.organization(name: org)\n        b = org.boxes.detect { |b| b.name == box }\n        if !b\n          @env.ui.error(I18n.t(\"cloud_command.box.not_found\",\n            org: org.username, box_name: box))\n          return 1\n        end",
    "comment": "Load box and yield  @param [VagrantCloud::Account] account Vagrant Cloud account @param [String] org Organization name @param [String] box Box name @yieldparam [VagrantCloud::Box] box Requested Vagrant Cloud box @yieldreturn [Integer] @return [Integer]",
    "label": "",
    "id": "1034"
  },
  {
    "raw_code": "def with_version(account:, org:, box:, version:)\n        with_box(account: account, org: org, box: box) do |b|\n          v = b.versions.detect { |v| v.version == version }\n          if !v\n            @env.ui.error(I18n.t(\"cloud_command.version.not_found\",\n              box_name: box, org: org, version: version))\n            return 1\n          end",
    "comment": "Load box version and yield  @param [VagrantCloud::Account] account Vagrant Cloud account @param [String] org Organization name @param [String] box Box name @param [String] version Box version @yieldparam [VagrantCloud::Box::Version] version Requested Vagrant Cloud box version @yieldreturn [Integer] @return [Integer]",
    "label": "",
    "id": "1035"
  },
  {
    "raw_code": "def with_provider(account:, org:, box:, version:, provider:, architecture:)\n        with_version(account: account, org: org, box: box, version: version) do |v|\n          p = v.providers.detect { |p|\n            p.name == provider &&\n              p.architecture == architecture\n          }\n          if !p\n            @env.ui.error(I18n.t(\"cloud_command.provider.not_found\",\n              org: org, box_name: box, version: version, provider_name: provider))\n            return 1\n          end",
    "comment": "Load box version and yield  @param [VagrantCloud::Account] account Vagrant Cloud account @param [String] org Organization name @param [String] box Box name @param [String] version Box version @param [String] provider Box version provider name @yieldparam [VagrantCloud::Box::Provider] provider Requested Vagrant Cloud box version provider @yieldreturn [Integer] @return [Integer]",
    "label": "",
    "id": "1036"
  },
  {
    "raw_code": "def box_info(box, options={})\n        current_version = box.current_version\n        if current_version\n          current_version = nil if !Array(options[:providers]).empty? &&\n                                   current_version.providers.none? { |p| options[:providers].include?(p.name) }\n          current_version = nil if !Array(options[:architectures]).empty? &&\n                                   current_version.providers.none? { |p| options[:architectures].include?(p.architecture) }\n        end",
    "comment": "Extract box information for display  @param [VagrantCloud::Box] box Box for extracting information @return [Hash<String,String>]",
    "label": "",
    "id": "1037"
  },
  {
    "raw_code": "def version_info(version)\n        provider_arches = version.providers.group_by(&:name).map { |provider_name, info|\n          \"#{provider_name} (#{info.map(&:architecture).sort.join(\", \")})\"\n        }.sort.join(\"\\n\")\n        Hash.new.tap do |i|\n          i[\"Box\"] = version.box.tag\n          i[\"Version\"] = version.version\n          i[\"Description\"] = version.description\n          i[\"Status\"] = version.status\n          i[\"Providers\"] = provider_arches\n          i[\"Created\"] = version.created_at\n          i[\"Updated\"] = version.updated_at\n        end",
    "comment": "Extract version information for display  @param [VagrantCloud::Box::Version] version Box version for extracting information @return [Hash<String,String>]",
    "label": "",
    "id": "1038"
  },
  {
    "raw_code": "def provider_info(provider)\n        {\n          \"Box\" => provider.version.box.tag,\n          \"Private\" => provider.version.box.private ? \"yes\" : \"no\",\n          \"Version\" => provider.version.version,\n          \"Provider\" => provider.name,\n          \"Architecture\" => provider.architecture,\n          \"Default Architecture\" => provider.default_architecture ? \"yes\" : \"no\",\n        }\n      end",
    "comment": "Extract provider information for display  @param [VagrantCloud::Box::Provider] provider Box provider for extracting information @return [Hash<String,String>]",
    "label": "",
    "id": "1039"
  },
  {
    "raw_code": "def print_search_table(env, column_labels, results, to_rjust_keys)\n        columns = column_labels.each_with_object({}) do |(col,label),h|\n          h[col] = {\n            label: label,\n            width: [results.map { |g| g[col].size }.max, label.size].max\n          }\n        end",
    "comment": "Print table results from search request  @param [Vagrant::Environment] env Current Vagrant environment @param [Hash] column_labels A hash of key/value pairs for table labels (i.e. {col1: \"COL1\"}) @param [Array] results An array of hashes representing search resuls @param [Array] to_jrust_keys - List of columns keys to right justify (left justify is defualt) @return [nil] @note Modified from https://stackoverflow.com/a/28685559",
    "label": "",
    "id": "1040"
  },
  {
    "raw_code": "def write_header(env, columns)\n        env.ui.info \"| #{ columns.map { |_,g| g[:label].ljust(g[:width]) }.join(' | ') } |\"\n        nil\n      end",
    "comment": "Write the header for a table  @param [Vagrant::Environment] env Current Vagrant environment @param [Array<Hash>] columns List of columns in Hash format with `:label` and `:width` keys @return [nil]",
    "label": "",
    "id": "1041"
  },
  {
    "raw_code": "def write_divider(env, columns)\n        env.ui.info \"+-#{ columns.map { |_,g| \"-\"*g[:width] }.join(\"-+-\") }-+\"\n        nil\n      end",
    "comment": "Write a row divider for a table  @param [Vagrant::Environment] env Current Vagrant environment @param [Array<Hash>] columns List of columns in Hash format with `:label` and `:width` keys @return [nil]",
    "label": "",
    "id": "1042"
  },
  {
    "raw_code": "def write_line(env, columns, h, to_rjust_keys)\n        str = h.keys.map { |k|\n          if to_rjust_keys.include?(k)\n            h[k].rjust(columns[k][:width])\n          else\n            h[k].ljust(columns[k][:width])\n          end",
    "comment": "Write a line of content for a table  @param [Vagrant::Environment] env Current Vagrant environment @param [Array<Hash>] columns List of columns in Hash format with `:label` and `:width` keys @param [Hash] h Values to print in row @param [Array<String>] to_rjust_keys List of columns to right justify @return [nil]",
    "label": "",
    "id": "1043"
  },
  {
    "raw_code": "def format_downloads(number)\n        number.to_s.chars.reverse.each_slice(3).map(&:join).join(\",\").reverse\n      end",
    "comment": "Converts a string of numbers into a formatted number  1234 -> 1,234  @param [String] number Numer to format",
    "label": "",
    "id": "1044"
  },
  {
    "raw_code": "def upload_box_file(provider, box_file, options={})\n          box_file = File.absolute_path(box_file)\n          @env.ui.info(I18n.t(\"cloud_command.publish.upload_provider\", file: box_file))\n          # Include size check on file and disable direct if over 5G\n          if options[:direct_upload]\n            fsize = File.stat(box_file).size\n            if fsize > (5 * Vagrant::Util::Numeric::GIGABYTE)\n              box_size = Vagrant::Util::Numeric.bytes_to_string(fsize)\n              @env.ui.warn(I18n.t(\"cloud_command.provider.direct_disable\", size: box_size))\n              options[:direct_upload] = false\n            end",
    "comment": "Upload the file for the given box provider  @param [VagrantCloud::Box::Provider] provider Vagrant Cloud box version provider @param [String] box_file Path to local asset for upload @param [Hash] options @option options [Boolean] :direct_upload Upload directly to backend storage @return [nil]",
    "label": "",
    "id": "1045"
  },
  {
    "raw_code": "def release_version(version)\n          @env.ui.info(I18n.t(\"cloud_command.publish.release\"))\n          version.release\n          nil\n        end",
    "comment": "Release the box version  @param [VagrantCloud::Box::Version] version Vagrant Cloud box version @return [nil]",
    "label": "",
    "id": "1046"
  },
  {
    "raw_code": "def set_box_info(box, options={})\n          box.private = options[:private] if options.key?(:private)\n          box.short_description = options[:short_description] if options.key?(:short_description)\n          box.description = options[:description] if options.key?(:description)\n          box\n        end",
    "comment": "Set any box related attributes that were provided  @param [VagrantCloud::Box] box Vagrant Cloud box @param [Hash] options @option options [Boolean] :private Box access is private @option options [String] :short_description Short description of box @option options [String] :description Full description of box @return [VagrantCloud::Box]",
    "label": "",
    "id": "1047"
  },
  {
    "raw_code": "def set_version_info(version, options={})\n          version.description = options[:version_description] if options.key?(:version_description)\n          version\n        end",
    "comment": "Set any version related attributes that were provided  @param [VagrantCloud::Box::Version] version Vagrant Cloud box version @param [Hash] options @option options [String] :version_description Description for this version @return [VagrantCloud::Box::Version]",
    "label": "",
    "id": "1048"
  },
  {
    "raw_code": "def set_provider_info(provider, options={})\n          provider.url = options[:url] if options.key?(:url)\n          provider.checksum_type = options[:checksum_type] if options.key?(:checksum_type)\n          provider.checksum = options[:checksum] if options.key?(:checksum)\n          provider.architecture = options[:architecture] if options.key?(:architecture)\n          provider.default_architecture = options[:default_architecture] if options.key?(:default_architecture)\n          provider\n        end",
    "comment": "Set any provider related attributes that were provided  @param [VagrantCloud::Box::Provider] provider Vagrant Cloud box version provider @param [Hash] options @option options [String] architecture Guest architecture of box @option options [String] :url Remote URL for self hosted @option options [String] :checksum_type Type of checksum value provided @option options [String] :checksum Checksum of the box asset @option options [Boolean] :default_architecture Default architecture for named provider @return [VagrantCloud::Box::Provider]",
    "label": "",
    "id": "1049"
  },
  {
    "raw_code": "def load_version_provider(version, provider_name, architecture)\n          provider = version.providers.detect { |pv|\n            pv.name == provider_name &&\n              pv.architecture == architecture\n          }\n          return provider if provider\n          version.add_provider(provider_name, architecture)\n        end",
    "comment": "Load the requested version provider  @param [VagrantCloud::Box::Version] version The version of the Vagrant Cloud box @param [String] provider_name Name of the provider @return [VagrantCloud::Box::Provider]",
    "label": "",
    "id": "1050"
  },
  {
    "raw_code": "def load_box_version(box, version)\n          v = box.versions.detect { |v| v.version == version }\n          return v if v\n          box.add_version(version)\n        end",
    "comment": "Load the requested box version  @param [VagrantCloud::Box] box The Vagrant Cloud box @param [String] version Version of the box @return [VagrantCloud::Box::Version]",
    "label": "",
    "id": "1051"
  },
  {
    "raw_code": "def load_box(org, box_name, access_token)\n          account = VagrantCloud::Account.new(\n            custom_server: api_server_url,\n            access_token: access_token\n          )\n          box = account.organization(name: org).boxes.detect { |b| b.name == box_name }\n          return box if box\n          account.organization(name: org).add_box(box_name)\n        end",
    "comment": "Load the requested box  @param [String] org Organization name for box @param [String] box_name Name of the box @param [String] access_token User access token @return [VagrantCloud::Box]",
    "label": "",
    "id": "1052"
  },
  {
    "raw_code": "def display_preamble(org, box_name, version, provider_name, options={})\n          @env.ui.warn(I18n.t(\"cloud_command.publish.confirm.warn\"))\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.box\", org: org,\n            box_name: box_name, version: version, provider_name: provider_name))\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.private\")) if options[:private]\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.release\")) if options[:release]\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.architecture\",\n            architecture: options[:architecture]))\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.default_architecture\")) if options[:default_architecture]\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.box_url\",\n            url: options[:url])) if options[:url]\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.box_description\",\n            description: options[:description])) if options[:description]\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.box_short_desc\",\n            short_description: options[:short_description])) if options[:short_description]\n          @env.ui.info(I18n.t(\"cloud_command.publish.confirm.version_desc\",\n            version_description: options[:version_description])) if options[:version_description]\n          nil\n        end",
    "comment": "Display publishing information to user before starting process  @param [String] org Organization name @param [String] box_name Name of the box to publish @param [String] version Version of the box to publish @param [String] provider_name Name of the provider being published @param [Hash] options @option options [String] :architecture Name of architecture of provider being published# @option options [Boolean] :private Box is private @option options [Boolean] :release Box should be released @option options [String] :url Remote URL for self-hosted boxes @option options [Boolean] :default_architecture Architecture is default for provider name @option options [String] :description Description of the box @option options [String] :short_description Short description of the box @option options [String] :version_description Description of the box version @return [nil]",
    "label": "",
    "id": "1053"
  },
  {
    "raw_code": "def help\n            opts = OptionParser.new do |opts|\n              opts.banner = \"Usage: vagrant cloud auth <subcommand> [<args>]\"\n              opts.separator \"\"\n              opts.separator \"Authorization with Vagrant Cloud\"\n              opts.separator \"\"\n              opts.separator \"Available subcommands:\"\n\n              # Add the available subcommands as separators in order to print them\n              # out as well.\n              keys = []\n              @subcommands.each { |key, value| keys << key.to_s }\n\n              keys.sort.each do |key|\n                opts.separator \"     #{key}\"\n              end",
    "comment": "Prints the help out for this command",
    "label": "",
    "id": "1054"
  },
  {
    "raw_code": "def delete_version(org, box_name, box_version, access_token, options={})\n            account = VagrantCloud::Account.new(\n              custom_server: api_server_url,\n              access_token: access_token\n            )\n            with_version(account: account, org: org, box: box_name, version: box_version) do |version|\n              version.delete\n              @env.ui.success(I18n.t(\"cloud_command.version.delete_success\",\n                version: box_version, org: org, box_name: box_name))\n              0\n            end",
    "comment": "Delete the requested box version  @param [String] org Box organization name @param [String] box_name Name of the box @param [String] box_version Version of the box @param [String] access_token User Vagrant Cloud access token @param [Hash] options Current unsued",
    "label": "",
    "id": "1055"
  },
  {
    "raw_code": "def help\n            opts = OptionParser.new do |opts|\n              opts.banner = \"Usage: vagrant cloud version <subcommand> [<args>]\"\n              opts.separator \"\"\n              opts.separator \"For taking various actions against a Vagrant box's version attribute on Vagrant Cloud\"\n              opts.separator \"\"\n              opts.separator \"Available subcommands:\"\n\n              # Add the available subcommands as separators in order to print them\n              # out as well.\n              keys = []\n              @subcommands.each { |key, value| keys << key.to_s }\n\n              keys.sort.each do |key|\n                opts.separator \"     #{key}\"\n              end",
    "comment": "Prints the help out for this command",
    "label": "",
    "id": "1056"
  },
  {
    "raw_code": "def revoke_version(org, box_name, box_version, access_token, options={})\n            account = VagrantCloud::Account.new(\n              custom_server: api_server_url,\n              access_token: access_token\n            )\n            with_version(account: account, org: org, box: box_name, version: box_version) do |version|\n              version.revoke\n              @env.ui.success(I18n.t(\"cloud_command.version.revoke_success\",\n                version: box_version, org: org, box_name: box_name))\n              format_box_results(version, @env)\n              0\n            end",
    "comment": "Revoke release of box version  @param [String] org Organization name @param [String] box_name Box name @param [String] version Version of the box @param [String] access_token User Vagrant Cloud access token @param [Hash] options Currently unused @return [Integer]",
    "label": "",
    "id": "1057"
  },
  {
    "raw_code": "def create_version(org, box_name, box_version, access_token, options={})\n            account = VagrantCloud::Account.new(\n              custom_server: api_server_url,\n              access_token: access_token\n            )\n            with_box(account: account, org: org, box: box_name) do |box|\n              version = box.add_version(box_version)\n              version.description = options[:description] if options.key?(:description)\n              version.save\n              @env.ui.success(I18n.t(\"cloud_command.version.create_success\",\n                version: box_version, org: org, box_name: box_name))\n              format_box_results(version, @env)\n              0\n            end",
    "comment": "Create a new version of the box  @param [String] org Organization box is within @param [String] box_name Name of box @param [String] box_version Version of box to create @param [String] access_token User Vagrant Cloud access token @param [Hash] options @option options [String] :description Description of box version @return [Integer]",
    "label": "",
    "id": "1058"
  },
  {
    "raw_code": "def update_version(org, box_name, box_version, access_token, options)\n            account = VagrantCloud::Account.new(\n              custom_server: api_server_url,\n              access_token: access_token\n            )\n            with_version(account: account, org: org, box: box_name, version: box_version) do |version|\n              version.description = options[:description] if options.key?(:description)\n              version.save\n\n              @env.ui.success(I18n.t(\"cloud_command.version.update_success\",\n                version: box_version, org: org, box_name: box_name))\n              format_box_results(version, @env)\n              0\n            end",
    "comment": "Update the version of the box @param [String] org Organization name @param [String] box_name Box name @param [String] version Version of the box @param [String] access_token User Vagrant Cloud access token @param [Hash] options @options options [String] :description Description of box version @return [Integer]",
    "label": "",
    "id": "1059"
  },
  {
    "raw_code": "def release_version(org, box_name, version, access_token, options={})\n            account = VagrantCloud::Account.new(\n              custom_server: api_server_url,\n              access_token: access_token\n            )\n            with_version(account: account, org: org, box: box_name, version: version) do |v|\n              v.release\n              @env.ui.success(I18n.t(\"cloud_command.version.release_success\",\n                version: version, org: org, box_name: box_name))\n              0\n            end",
    "comment": "Release the box version  @param [String] org Organization name @param [String] box_name Box name @param [String] version Version of the box @param [String] access_token User Vagrant Cloud access token @param [Hash] options Currently unused @return [Integer]",
    "label": "",
    "id": "1060"
  },
  {
    "raw_code": "def self.reset!\n        class_variables.each(&method(:remove_class_variable))\n      end",
    "comment": "@private Reset the cached values for scrubber. This is not considered a public API and should only be used for testing.",
    "label": "",
    "id": "1061"
  },
  {
    "raw_code": "def initialize(env)\n        @logger = Log4r::Logger.new(\"vagrant::cloud::client\")\n        @env    = env\n        if !defined?(@@client)\n          @@client = VagrantCloud::Client.new(\n            access_token: token,\n            url_base: api_server_url\n          )\n        end",
    "comment": "Initializes a login client with the given Vagrant::Environment.  @param [Vagrant::Environment] env",
    "label": "",
    "id": "1062"
  },
  {
    "raw_code": "def clear_token\n        @logger.info(\"Clearing token\")\n        token_path.delete if token_path.file?\n      end",
    "comment": "Removes the token, effectively logging the user out.",
    "label": "",
    "id": "1063"
  },
  {
    "raw_code": "def logged_in?\n        return false if !client&.access_token\n\n        Vagrant::Util::CredentialScrubber.sensitive(client.access_token)\n\n        with_error_handling do\n          client.authentication_token_validate\n          true\n        end",
    "comment": "Checks if the user is logged in by verifying their authentication token.  @return [Boolean]",
    "label": "",
    "id": "1064"
  },
  {
    "raw_code": "def login(description: nil, code: nil)\n        @logger.info(\"Logging in '#{username_or_email}'\")\n\n        Vagrant::Util::CredentialScrubber.sensitive(password)\n        with_error_handling do\n          r = client.authentication_token_create(username: username_or_email,\n            password: password, description: description, code: code)\n\n          Vagrant::Util::CredentialScrubber.sensitive(r[:token])\n          @client = VagrantCloud::Client.new(\n            access_token: r[:token],\n            url_base: api_server_url\n          )\n          r[:token]\n        end",
    "comment": "Login logs a user in and returns the token for that user. The token is _not_ stored unless {#store_token} is called.  @param [String] description @param [String] code @return [String] token The access token, or nil if auth failed.",
    "label": "",
    "id": "1065"
  },
  {
    "raw_code": "def request_code(delivery_method)\n        @env.ui.warn(\"Requesting 2FA code via #{delivery_method.upcase}...\")\n\n        Vagrant::Util::CredentialScrubber.sensitive(password)\n        with_error_handling do\n          r = client.authentication_request_2fa_code(\n            username: username_or_email, password: password, delivery_method: delivery_method)\n\n          two_factor = r[:two_factor]\n          obfuscated_destination = two_factor[:obfuscated_destination]\n\n          @env.ui.success(\"2FA code sent to #{obfuscated_destination}.\")\n        end",
    "comment": "Requests a 2FA code @param [String] delivery_method",
    "label": "",
    "id": "1066"
  },
  {
    "raw_code": "def store_token(token)\n        Vagrant::Util::CredentialScrubber.sensitive(token)\n        @logger.info(\"Storing token in #{token_path}\")\n\n        token_path.open(\"w\") do |f|\n          f.write(token)\n        end",
    "comment": "Stores the given token locally, removing any previous tokens.  @param [String] token",
    "label": "",
    "id": "1067"
  },
  {
    "raw_code": "def token\n        # If the client is defined, use the client for the access token\n        # to allow proper token generation if required\n        return client.access_token if client && !client.access_token.nil?\n\n        if present?(ENV[\"VAGRANT_CLOUD_TOKEN\"]) && token_path.exist?\n          # Only show warning if it has not been previously shown\n          if !defined?(@@double_token_warning)\n            @env.ui.warn <<-EOH.strip\nVagrant detected both the VAGRANT_CLOUD_TOKEN environment variable and a Vagrant login\ntoken are present on this system. The VAGRANT_CLOUD_TOKEN environment variable takes\nprecedence over the locally stored token. To remove this error, either unset\nthe VAGRANT_CLOUD_TOKEN environment variable or remove the login token stored on disk:\n\n    ~/.vagrant.d/data/vagrant_login_token\n\nEOH\n            @@double_token_warning = true\n          end",
    "comment": "Reads the access token if there is one. This will first read the `VAGRANT_CLOUD_TOKEN` environment variable and then fallback to the stored access token on disk.  @return [String]",
    "label": "",
    "id": "1068"
  },
  {
    "raw_code": "def delete_provider(org, box, version, provider, architecture, account, options={})\n            with_provider(account: account, org: org, box: box, version: version, provider: provider, architecture: architecture) do |p|\n              p.delete\n              @env.ui.error(I18n.t(\"cloud_command.provider.delete_success\",\n                architecture: architecture, provider: provider, org: org, box_name: box, version: version))\n              0\n            end",
    "comment": "Delete a provider for the box version  @param [String] org Organization name @param [String] box Box name @param [String] version Box version @param [String] provider Provider name @param [String] architecture Architecture of guest @param [VagrantCloud::Account] account VagrantCloud account @param [Hash] options Currently unused @return [Integer]",
    "label": "",
    "id": "1069"
  },
  {
    "raw_code": "def help\n            opts = OptionParser.new do |opts|\n              opts.banner = \"Usage: vagrant cloud provider <subcommand> [<args>]\"\n              opts.separator \"\"\n              opts.separator \"For various provider actions with Vagrant Cloud\"\n              opts.separator \"\"\n              opts.separator \"Available subcommands:\"\n\n              # Add the available subcommands as separators in order to print them\n              # out as well.\n              keys = []\n              @subcommands.each { |key, value| keys << key.to_s }\n\n              keys.sort.each do |key|\n                opts.separator \"     #{key}\"\n              end",
    "comment": "Prints the help out for this command",
    "label": "",
    "id": "1070"
  },
  {
    "raw_code": "def upload_provider(org, box, version, provider, architecture, file, access_token, options)\n            account = VagrantCloud::Account.new(\n              custom_server: api_server_url,\n              access_token: access_token\n            )\n\n            # Include size check on file and disable direct if over 5G\n            if options[:direct]\n              fsize = File.stat(file).size\n              if fsize > (5 * Vagrant::Util::Numeric::GIGABYTE)\n                box_size = Vagrant::Util::Numeric.bytes_to_string(fsize)\n                @env.ui.warn(I18n.t(\"cloud_command.provider.direct_disable\", size: box_size))\n                options[:direct] = false\n              end",
    "comment": "Upload an asset for a box version provider  @param [String] org Organization name @param [String] box Box name @param [String] version Box version @param [String] provider Provider name @param [String] architecture Architecture name @param [String] file Path to asset @param [String] access_token User Vagrant Cloud access token @param [Hash] options @option options [Boolean] :direct Upload directly to backend storage @return [Integer]",
    "label": "",
    "id": "1071"
  },
  {
    "raw_code": "def create_provider(org, box, version, provider, url, access_token, options={})\n            if !url\n              @env.ui.warn(I18n.t(\"cloud_command.upload.no_url\"))\n            end",
    "comment": "Create a provider for the box version  @param [String] org Organization name @param [String] box Box name @param [String] version Box version @param [String] provider Provider name @param [String] url Provider asset URL @param [String] access_token User Vagrant Cloud access token @param [Hash] options @option options [String] :architecture Architecture of guest box @option options [String] :checksum Checksum of the box asset @option options [String] :checksum_type Type of the checksum @option options [Boolean] :default_architecture Default architecture for named provider @return [Integer]",
    "label": "",
    "id": "1072"
  },
  {
    "raw_code": "def update_provider(org, box, version, provider, architecture, url, access_token, options)\n            if !url\n              @env.ui.warn(I18n.t(\"cloud_command.upload.no_url\"))\n            end",
    "comment": "Update a provider for the box version  @param [String] org Organization name @param [String] box Box name @param [String] version Box version @param [String] provider Provider name @param [String] architecture Architecture of guest @param [String] access_token User Vagrant Cloud access token @param [Hash] options @option options [String] :checksum Checksum of the box asset @option options [String] :checksum_type Type of the checksum @return [Integer]",
    "label": "",
    "id": "1073"
  },
  {
    "raw_code": "def delete_box(org, box_name, access_token)\n            account = VagrantCloud::Account.new(\n              custom_server: api_server_url,\n              access_token: access_token\n            )\n            with_box(account: account, org: org, box: box_name) do |box|\n              box.delete\n              @env.ui.success(I18n.t(\"cloud_command.box.delete_success\", org: org, box_name: box_name))\n              0\n            end",
    "comment": "Delete the requested box  @param [String] org Organization name of box @param [String] box_name Name of box @param [String] access_token User access token @return [Integer]",
    "label": "",
    "id": "1074"
  },
  {
    "raw_code": "def help\n            opts = OptionParser.new do |opts|\n              opts.banner = \"Usage: vagrant cloud box <subcommand> [<args>]\"\n              opts.separator \"\"\n              opts.separator \"Commands to manage boxes on Vagrant Cloud\"\n              opts.separator \"\"\n              opts.separator \"Available subcommands:\"\n\n              # Add the available subcommands as separators in order to print them\n              # out as well.\n              keys = []\n              @subcommands.each { |key, value| keys << key.to_s }\n\n              keys.sort.each do |key|\n                opts.separator \"     #{key}\"\n              end",
    "comment": "Prints the help out for this command",
    "label": "",
    "id": "1075"
  },
  {
    "raw_code": "def create_box(org, box_name, access_token, options={})\n            account = VagrantCloud::Account.new(\n              custom_server: api_server_url,\n              access_token: access_token\n            )\n            box = account.organization(name: org).add_box(box_name)\n            box.short_description = options[:short] if options.key?(:short)\n            box.description = options[:description] if options.key?(:description)\n            box.private = options[:private] if options.key?(:private)\n            box.save\n\n            @env.ui.success(I18n.t(\"cloud_command.box.create_success\", org: org, box_name: box_name))\n            format_box_results(box, @env)\n            0\n          rescue VagrantCloud::Error => e\n            @env.ui.error(I18n.t(\"cloud_command.errors.box.create_fail\", org: org, box_name: box_name))\n            @env.ui.error(e.message)\n            1\n          end",
    "comment": "Create a new box  @param [String] org Organization name of box @param [String] box_name Name of box @param [String] access_token User access token @param [Hash] options Options for box filtering @option options [String] :short Short description of box @option options [String] :description Full description of box @option options [Boolean] :private Set box visibility as private @return [Integer]",
    "label": "",
    "id": "1076"
  },
  {
    "raw_code": "def update_box(org, box_name, access_token, options={})\n            account = VagrantCloud::Account.new(\n              custom_server: api_server_url,\n              access_token: access_token\n            )\n            with_box(account: account, org: org, box: box_name) do |box|\n              box.short_description = options[:short] if options.key?(:short)\n              box.description = options[:description] if options.key?(:description)\n              box.private = options[:private] if options.key?(:private)\n              box.save\n              @env.ui.success(I18n.t(\"cloud_command.box.update_success\", org: org, box_name: box_name))\n              format_box_results(box, @env)\n              0\n            end",
    "comment": "Update an existing box  @param [String] org Organization name of box @param [String] box_name Name of box @param [String] access_token User access token @param [Hash] options Options for box filtering @option options [String] :short Short description of box @option options [String] :description Full description of box @option options [Boolean] :private Set box visibility as private @return [Integer]",
    "label": "",
    "id": "1077"
  },
  {
    "raw_code": "def show_box(org, box_name, access_token, options={})\n            account = VagrantCloud::Account.new(\n              custom_server: api_server_url,\n              access_token: access_token\n            )\n            with_box(account: account, org: org, box: box_name) do |box|\n              list = [box]\n\n              # If specific version(s) provided, filter out the version\n              list = list.first.versions.find_all { |v|\n                options[:versions].include?(v.version)\n              } if !Array(options[:versions]).empty?\n\n              # If specific provider(s) provided, filter out the provider(s)\n              list = list.find_all { |item|\n                if item.is_a?(VagrantCloud::Box)\n                  item.versions.any? { |v|\n                    v.providers.any? { |p|\n                      options[:providers].include?(p.name)\n                    }\n                  }\n                else\n                  item.providers.any? { |p|\n                    options[:providers].include?(p.name)\n                  }\n                end",
    "comment": "Display the requested box to the user  @param [String] org Organization name of box @param [String] box_name Name of box @param [String] access_token User access token @param [Hash] options Options for box filtering @option options [String] :versions Specific verisons of box @return [Integer]",
    "label": "",
    "id": "1078"
  },
  {
    "raw_code": "def get_rdp_info(machine)\n        rdp_info = {}\n        if machine.provider.capability?(:rdp_info)\n          rdp_info = machine.provider.capability(:rdp_info)\n          rdp_info ||= {}\n        end",
    "comment": "Generate RDP information for machine  @param [Vagrant::Machine] machine Guest machine @return [Hash, nil]",
    "label": "",
    "id": "1079"
  },
  {
    "raw_code": "def build_start_options(parser, options)\n        # Setup the defaults\n        options[:provision_types] = nil\n\n        # Add the options\n        parser.on(\"--[no-]provision\", \"Enable or disable provisioning\") do |p|\n          options[:provision_enabled] = p\n          options[:provision_ignore_sentinel] = true\n        end",
    "comment": "This adds the standard `start` command line flags to the given OptionParser, storing the result in the `options` dictionary.  @param [OptionParser] parser @param [Hash] options",
    "label": "",
    "id": "1080"
  },
  {
    "raw_code": "def validate_provisioner_flags!(options, argv)\n        if options[:provision_types].nil?\n          return\n        end",
    "comment": "This validates the provisioner flags and raises an exception if there are invalid ones.",
    "label": "",
    "id": "1081"
  },
  {
    "raw_code": "def with_environment\n        old_gem_home = ENV[\"GEM_HOME\"]\n        old_gem_path = ENV[\"GEM_PATH\"]\n        ENV[\"GEM_HOME\"] = @gem_home\n        ENV[\"GEM_PATH\"] = @gem_home\n        @logger.debug(\"Set GEM_* to: #{ENV[\"GEM_HOME\"]}\")\n\n        # Clear paths so that it reads the new GEM_HOME setting\n        Gem.paths = ENV\n\n        # Set a custom configuration to avoid loading ~/.gemrc loads and\n        # /etc/gemrc and so on.\n        old_config = nil\n        begin\n          old_config = Gem.configuration\n        rescue Psych::SyntaxError\n          # Just ignore this. This means that the \".gemrc\" file has\n          # an invalid syntax and can't be loaded. We don't care, because\n          # when we set Gem.configuration to nil later, it'll force a reload\n          # if it is needed.\n        end",
    "comment": "This will yield the given block with the proper ENV setup so that RubyGems only sees the gems in the Vagrant-managed gem path.",
    "label": "",
    "id": "1082"
  },
  {
    "raw_code": "def self.action_expunge\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use ExpungePlugins\n        end",
    "comment": "This middleware sequence will remove all plugins.",
    "label": "",
    "id": "1083"
  },
  {
    "raw_code": "def self.action_install\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use InstallGem\n        end",
    "comment": "This middleware sequence will install a plugin.",
    "label": "",
    "id": "1084"
  },
  {
    "raw_code": "def self.action_license\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use PluginExistsCheck\n          b.use LicensePlugin\n        end",
    "comment": "This middleware sequence licenses paid addons.",
    "label": "",
    "id": "1085"
  },
  {
    "raw_code": "def self.action_list\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use ListPlugins\n        end",
    "comment": "This middleware sequence will list all installed plugins.",
    "label": "",
    "id": "1086"
  },
  {
    "raw_code": "def self.action_repair\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use RepairPlugins\n        end",
    "comment": "This middleware sequence will repair installed plugins.",
    "label": "",
    "id": "1087"
  },
  {
    "raw_code": "def self.action_repair_local\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use RepairPluginsLocal\n        end",
    "comment": "This middleware sequence will repair installed local plugins.",
    "label": "",
    "id": "1088"
  },
  {
    "raw_code": "def self.action_uninstall\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use PluginExistsCheck\n          b.use UninstallPlugin\n        end",
    "comment": "This middleware sequence will uninstall a plugin.",
    "label": "",
    "id": "1089"
  },
  {
    "raw_code": "def self.action_update\n        Vagrant::Action::Builder.new.tap do |b|\n          b.use UpdateGems\n        end",
    "comment": "This middleware sequence will update a plugin.",
    "label": "",
    "id": "1090"
  },
  {
    "raw_code": "def help\n          opts = OptionParser.new do |o|\n            o.banner = \"Usage: vagrant plugin <command> [<args>]\"\n            o.separator \"\"\n            o.separator \"Available subcommands:\"\n\n            # Add the available subcommands as separators in order to print them\n            # out as well.\n            keys = []\n            @subcommands.each { |key, value| keys << key.to_s }\n\n            keys.sort.each do |key|\n              o.separator \"     #{key}\"\n            end",
    "comment": "Prints the help out for this command",
    "label": "",
    "id": "1091"
  },
  {
    "raw_code": "def action(callable, env=nil)\n          @env.action_runner.run(callable, env)\n        end",
    "comment": "This is a helper for executing an action sequence with the proper environment hash setup so that the plugin specific helpers are in.  @param [Object] callable the Middleware callable @param [Hash] env Extra environment hash that is merged in.",
    "label": "",
    "id": "1092"
  },
  {
    "raw_code": "def compression_setup!(machine, options)\n        if !options[:compression_type]\n          if machine.guest.capability_host_chain.first[0] == :windows\n            options[:compression_type] = :zip\n          else\n            options[:compression_type] = :tgz\n          end",
    "comment": "Setup compression options and validate host and guest have capability to handle compression  @param [Vagrant::Machine] machine Vagrant guest machine @param [Hash] options Command options",
    "label": "",
    "id": "1093"
  },
  {
    "raw_code": "def compress_source_zip(path)\n        require \"zip\"\n        zipfile = Tempfile.create([\"vagrant\", \".zip\"])\n        zipfile.close\n        if File.file?(path)\n          source_items = [path]\n        else\n          source_items = Dir.glob(File.join(path, \"**\", \"**\", \"*\"))\n        end",
    "comment": "Compress path using zip into temporary file  @param [String] path Path to compress @return [String] path to compressed file",
    "label": "",
    "id": "1094"
  },
  {
    "raw_code": "def compress_source_tgz(path)\n        tarfile = Tempfile.create([\"vagrant\", \".tar\"])\n        tarfile.close\n        tarfile = File.open(tarfile.path, \"wb+\")\n        tgzfile = Tempfile.create([\"vagrant\", \".tgz\"])\n        tgzfile.close\n        tgzfile = File.open(tgzfile.path, \"wb\")\n        tar = Gem::Package::TarWriter.new(tarfile)\n        tgz = Zlib::GzipWriter.new(tgzfile)\n        if File.file?(path)\n          tar.add_file(File.basename(path), File.stat(path).mode) do |io|\n            File.open(path, \"rb\") do |file|\n              while bytes = file.read(4096)\n                io.write(bytes)\n              end",
    "comment": "Compress path using tar and gzip into temporary file  @param [String] path Path to compress @return [String] path to compressed file",
    "label": "",
    "id": "1095"
  },
  {
    "raw_code": "def help\n          opts = OptionParser.new do |opts|\n            opts.banner = \"Usage: vagrant snapshot <subcommand> [<args>]\"\n            opts.separator \"\"\n            opts.separator \"Available subcommands:\"\n\n            # Add the available subcommands as separators in order to print them\n            # out as well.\n            keys = []\n            @subcommands.each { |key, value| keys << key.to_s }\n\n            keys.sort.each do |key|\n              opts.separator \"     #{key}\"\n            end",
    "comment": "Prints the help out for this command",
    "label": "",
    "id": "1096"
  },
  {
    "raw_code": "def print_all(vm, ports)\n        @env.ui.info(I18n.t(\"port_command.details\"))\n        @env.ui.info(\"\")\n        ports.each do |host, guest|\n          @env.ui.info(\"#{guest.to_s.rjust(6)} (guest) => #{host} (host)\")\n          @env.ui.machine(\"forwarded_port\", guest, host, target: vm.name.to_s)\n        end",
    "comment": "Print all the guest <=> host port mappings. @return [0] the exit code",
    "label": "",
    "id": "1097"
  },
  {
    "raw_code": "def print_single(vm, ports, target)\n        map = ports.find { |_, guest| \"#{guest}\" == \"#{target}\" }\n        if !present?(map)\n          @env.ui.error(I18n.t(\"port_command.no_matching_port\",\n            port: target,\n          ))\n          return 1\n        end",
    "comment": "Print the host mapping that matches the given guest target. @return [0,1] the exit code",
    "label": "",
    "id": "1098"
  },
  {
    "raw_code": "def execute\n        opts = OptionParser.new do |o|\n          o.banner = \"Usage: vagrant push [strategy] [options]\"\n        end",
    "comment": "@todo support multiple strategies if requested by the community",
    "label": "",
    "id": "1099"
  },
  {
    "raw_code": "def validate_pushes!(pushes, name = nil)\n        if pushes.nil? || pushes.empty?\n          raise Vagrant::Errors::PushesNotDefined\n        end",
    "comment": "Validate that the given list of names corresponds to valid pushes.  @raise Vagrant::Errors::PushesNotDefined if there are no pushes defined @raise Vagrant::Errors::PushStrategyNotProvided if there are multiple push strategies defined and none were specified @raise Vagrant::Errors::PushStrategyNotDefined if the given push name do not correspond to a push strategy  @param [Array<Symbol>] pushes the list of pushes defined by the environment @param [String] name the name provided by the user on the command line  @return [Symbol] the compiled list of pushes ",
    "label": "",
    "id": "1100"
  },
  {
    "raw_code": "def mockup_providers!\n        require 'log4r'\n        logger = Log4r::Logger.new(\"vagrant::validate\")\n        logger.debug(\"Overriding all registered provider classes for validate\")\n\n        # Without setting up a tmp Environment, Vagrant will completely\n        # erase the local data dotfile and you can lose state after the\n        # validate command completes.\n        tmp_data_dir = Dir.mktmpdir(\"vagrant-validate-\")\n        @env = Vagrant::Environment.new(\n          cwd: @env.cwd,\n          home_path: @env.home_path,\n          ui_class: @env.ui_class,\n          vagrantfile_name: @env.vagrantfile_name,\n          local_data_path: tmp_data_dir,\n          data_dir: tmp_data_dir\n        )\n\n        Vagrant.plugin(\"2\").manager.providers.each do |key, data|\n          data[0].class_eval do\n            def initialize(machine)\n            end\n\n            def machine_id_changed\n            end\n\n            def self.installed?\n              true\n            end\n\n            def self.usable?(raise_error=false)\n              true\n            end\n\n            def state\n              state_id = Vagrant::MachineState::NOT_CREATED_ID\n              short = :not_created\n              long = :not_created\n              Vagrant::MachineState.new(state_id, short, long)\n            end\n          end",
    "comment": "This method is required to bypass some of the provider checks that would otherwise raise exceptions before Vagrant could load and validate a config. It essentially ignores that there are no installed or usable prodivers so that Vagrant can go along and validate the rest of the Vagrantfile and ignore any provider blocks.  return [String] tmp_data_dir - Temporary dir used to store guest metadata during validation",
    "label": "",
    "id": "1101"
  },
  {
    "raw_code": "def build_download_options(parser, options)\n        # Add the options\n        parser.on(\"--insecure\", \"Do not validate SSL certificates\") do |i|\n          options[:insecure] = i\n        end",
    "comment": "This adds common download command line flags to the given OptionParser, storing the result in the `options` dictionary.  @param [OptionParser] parser @param [Hash] options",
    "label": "",
    "id": "1102"
  },
  {
    "raw_code": "def help\n          opts = OptionParser.new do |opts|\n            opts.banner = \"Usage: vagrant box <subcommand> [<args>]\"\n            opts.separator \"\"\n            opts.separator \"Available subcommands:\"\n\n            # Add the available subcommands as separators in order to print them\n            # out as well.\n            keys = []\n            @subcommands.each { |key, value| keys << key.to_s }\n\n            keys.sort.each do |key|\n              opts.separator \"     #{key}\"\n            end",
    "comment": "Prints the help out for this command",
    "label": "",
    "id": "1103"
  },
  {
    "raw_code": "def self.mount_virtualbox_shared_folder(machine, name, guestpath, options)\n          guest_path = Shellwords.escape(guestpath)\n          mount_type = options[:plugin].capability(:mount_type)\n\n          @@logger.debug(\"Mounting #{name} (#{options[:hostpath]} to #{guestpath})\")\n\n          builtin_mount_type = \"-cit #{mount_type}\"\n          addon_mount_type = \"-t #{mount_type}\"\n\n          mount_options, mount_uid, mount_gid = options[:plugin].capability(:mount_options, name, guest_path, options)\n          mount_command = \"mount #{addon_mount_type} -o #{mount_options} #{name} #{guest_path}\"\n\n          # Create the guest path if it doesn't exist\n          machine.communicate.sudo(\"mkdir -p #{guest_path}\")\n\n          stderr = \"\"\n          result = machine.communicate.sudo(mount_command, error_check: false) do |type, data|\n            stderr << data if type == :stderr\n          end",
    "comment": "Mounts and virtualbox folder on linux guest  @param [Machine] machine @param [String] name of mount @param [String] path of mount on guest @param [Hash] hash of mount options",
    "label": "",
    "id": "1104"
  },
  {
    "raw_code": "def self.mount_smb_shared_folder(machine, name, guestpath, options)\n          expanded_guest_path = machine.guest.capability(\n            :shell_expand_guest_path, guestpath)\n          options[:smb_id] ||= name\n\n          mount_device = options[:plugin].capability(:mount_name, name, options)\n          mount_options, _, _ = options[:plugin].capability(\n            :mount_options, name, expanded_guest_path, options)\n          mount_type = options[:plugin].capability(:mount_type)\n          # If a domain is provided in the username, separate it\n          username, domain = (options[:smb_username] || '').split('@', 2)\n          smb_password = options[:smb_password]\n          # Ensure password is scrubbed\n          Vagrant::Util::CredentialScrubber.sensitive(smb_password)\n        \n          if mount_options.include?(\"mfsymlinks\")\n            display_mfsymlinks_warning(machine.env)\n          end",
    "comment": "Mounts and SMB folder on linux guest  @param [Machine] machine @param [String] name of mount @param [String] path of mount on guest @param [Hash] hash of mount options",
    "label": "",
    "id": "1105"
  },
  {
    "raw_code": "def self.persist_mount_shared_folder(machine, folders)\n          if folders.nil?\n            @@logger.info(\"clearing /etc/fstab\")\n            self.remove_vagrant_managed_fstab(machine)\n            return\n          end",
    "comment": "Inserts fstab entry for a set of synced folders. Will fully replace the currently managed group of Vagrant managed entries. Note, passing empty list of folders will just remove entries  @param [Machine] machine The machine to run the action on @param [Map<String, Map>] A map of folders to add to fstab",
    "label": "",
    "id": "1106"
  },
  {
    "raw_code": "def self.create_tmp_path(machine, opts)\n          template = \"vagrant-XXXXXX\"\n          if opts[:extension]\n            template << opts[:extension].to_s\n          end",
    "comment": "Create a temporary file or directory on the guest  @param [Vagrant::Machine] machine Vagrant guest machine @param [Hash] opts Path options @return [String] path to temporary file or directory",
    "label": "",
    "id": "1107"
  },
  {
    "raw_code": "def self.decompress_tgz(machine, compressed_file, destination, opts={})\n          comm = machine.communicate\n          extract_dir = create_tmp_path(machine, type: :directory)\n          cmds = []\n          if opts[:type] == :directory\n            cmds << \"mkdir -p '#{destination}'\"\n          else\n            cmds << \"mkdir -p '#{File.dirname(destination)}'\"\n          end",
    "comment": "Decompress tgz file on guest to given location  @param [Vagrant::Machine] machine Vagrant guest machine @param [String] compressed_file Path to compressed file on guest @param [String] destination Path for decompressed files on guest",
    "label": "",
    "id": "1108"
  },
  {
    "raw_code": "def self.decompress_zip(machine, compressed_file, destination, opts={})\n          comm = machine.communicate\n          extract_dir = create_tmp_path(machine, type: :directory)\n          cmds = []\n          if opts[:type] == :directory\n            cmds << \"mkdir -p '#{destination}'\"\n          else\n            cmds << \"mkdir -p '#{File.dirname(destination)}'\"\n          end",
    "comment": "Decompress zip file on guest to given location  @param [Vagrant::Machine] machine Vagrant guest machine @param [String] compressed_file Path to compressed file on guest @param [String] destination Path for decompressed files on guest",
    "label": "",
    "id": "1109"
  },
  {
    "raw_code": "def self.network_interfaces(machine, path = \"/sbin/ip\")\n          s = \"\"\n          machine.communicate.sudo(\"#{path} -o -0 addr | grep -v LOOPBACK | awk '{print $2}' | sed 's/://'\") do |type, data|\n            s << data if type == :stdout\n          end",
    "comment": "Get network interfaces as a list. The result will be something like:  eth0\\nenp0s8\\nenp0s9  @return [Array<String>]",
    "label": "",
    "id": "1110"
  },
  {
    "raw_code": "def self.create_tmp_path(machine, opts)\n          template = \"vagrant-XXXXXX\"\n          cmd = [\"mktemp\"]\n          if opts[:type] == :directory\n            cmd << \"-d\"\n          end",
    "comment": "Create a temporary file or directory on the guest  @param [Vagrant::Machine] machine Vagrant guest machine @param [Hash] opts Path options @return [String] path to temporary file or directory",
    "label": "",
    "id": "1111"
  },
  {
    "raw_code": "def self.decompress_tgz(machine, compressed_file, destination, opts={})\n          comm = machine.communicate\n          extract_dir = create_tmp_path(machine, type: :directory)\n          cmds = []\n          if opts[:type] == :directory\n            cmds << \"mkdir -p '#{destination}'\"\n          else\n            cmds << \"mkdir -p '#{File.dirname(destination)}'\"\n          end",
    "comment": "Decompress tgz file on guest to given location  @param [Vagrant::Machine] machine Vagrant guest machine @param [String] compressed_file Path to compressed file on guest @param [String] destination Path for decompressed files on guest",
    "label": "",
    "id": "1112"
  },
  {
    "raw_code": "def self.decompress_zip(machine, compressed_file, destination, opts={})\n          comm = machine.communicate\n          extract_dir = create_tmp_path(machine, type: :directory)\n          cmds = []\n          if opts[:type] == :directory\n            cmds << \"mkdir -p '#{destination}'\"\n          else\n            cmds << \"mkdir -p '#{File.dirname(destination)}'\"\n          end",
    "comment": "Decompress zip file on guest to given location  @param [Vagrant::Machine] machine Vagrant guest machine @param [String] compressed_file Path to compressed file on guest @param [String] destination Path for decompressed files on guest",
    "label": "",
    "id": "1113"
  },
  {
    "raw_code": "def self.mount_virtualbox_shared_folder(machine, name, guestpath, options)\n          raise Vagrant::Errors::VirtualBoxMountNotSupportedBSD\n        end",
    "comment": "BSD-based guests do not currently support VirtualBox synced folders. Instead of raising an error about a missing capability, this defines the capability and then provides a more detailed error message, linking to sources on the Internet where the problem is better-described.",
    "label": "",
    "id": "1114"
  },
  {
    "raw_code": "def self.create_tmp_path(machine, opts)\n          template = \"vagrant\"\n          cmd = [\"mktemp\"]\n          if opts[:type] == :directory\n            cmd << \"-d\"\n          end",
    "comment": "Create a temporary file or directory on the guest  @param [Vagrant::Machine] machine Vagrant guest machine @param [Hash] opts Path options @return [String] path to temporary file or directory",
    "label": "",
    "id": "1115"
  },
  {
    "raw_code": "def self.decompress_tgz(machine, compressed_file, destination, opts={})\n          comm = machine.communicate\n          extract_dir = create_tmp_path(machine, type: :directory)\n          cmds = []\n          if opts[:type] == :directory\n            cmds << \"mkdir -p '#{destination}'\"\n          else\n            cmds << \"mkdir -p '#{File.dirname(destination)}'\"\n          end",
    "comment": "Decompress tgz file on guest to given location  @param [Vagrant::Machine] machine Vagrant guest machine @param [String] compressed_file Path to compressed file on guest @param [String] destination Path for decompressed files on guest",
    "label": "",
    "id": "1116"
  },
  {
    "raw_code": "def self.decompress_zip(machine, compressed_file, destination, opts={})\n          comm = machine.communicate\n          extract_dir = create_tmp_path(machine, type: :directory)\n          cmds = []\n          if opts[:type] == :directory\n            cmds << \"mkdir -p '#{destination}'\"\n          else\n            cmds << \"mkdir -p '#{File.dirname(destination)}'\"\n          end",
    "comment": "Decompress zip file on guest to given location  @param [Vagrant::Machine] machine Vagrant guest machine @param [String] compressed_file Path to compressed file on guest @param [String] destination Path for decompressed files on guest",
    "label": "",
    "id": "1117"
  },
  {
    "raw_code": "def self.mount_nfs_folder(machine, ip, folders)\n          comm = machine.communicate\n\n          # Mount each folder separately so we can retry.\n          folders.each do |name, opts|\n            # Shellescape the paths in case they do not have special characters.\n            guest_path = Shellwords.escape(opts[:guestpath])\n            host_path  = Shellwords.escape(opts[:hostpath])\n\n            # Build the list of mount options.\n            mount_opts =  []\n            mount_opts << \"nfsv#{opts[:nfs_version]}\" if opts[:nfs_version]\n            mount_opts << \"mntudp\" if opts[:nfs_udp]\n            if opts[:mount_options]\n              mount_opts = mount_opts + opts[:mount_options].dup\n            end",
    "comment": "Mount the given NFS folder.",
    "label": "",
    "id": "1118"
  },
  {
    "raw_code": "def self.create_mac_service_map(machine)\n          tmp_ints = File.join(Dir.tmpdir, File.basename(\"#{machine.id}.interfaces\"))\n          tmp_hw = File.join(Dir.tmpdir, File.basename(\"#{machine.id}.hardware\"))\n\n          machine.communicate.tap do |comm|\n            comm.sudo(\"networksetup -detectnewhardware\")\n            comm.sudo(\"networksetup -listnetworkserviceorder > /tmp/vagrant.interfaces\")\n            comm.sudo(\"networksetup -listallhardwareports > /tmp/vagrant.hardware\")\n            comm.download(\"/tmp/vagrant.interfaces\", tmp_ints)\n            comm.download(\"/tmp/vagrant.hardware\", tmp_hw)\n          end",
    "comment": "Creates a hash mapping MAC addresses to network service name Example: { \"00C100A1B2C3\" => \"Thunderbolt Ethernet\" }",
    "label": "",
    "id": "1119"
  },
  {
    "raw_code": "def self.darwin_version(machine)\n          output = \"\"\n          machine.communicate.sudo(\"sysctl kern.osrelease\") do |_, data|\n            output = data\n          end",
    "comment": "Get the darwin version  @param [Machine] @return [String] version of drawin",
    "label": "",
    "id": "1120"
  },
  {
    "raw_code": "def self.darwin_major_version(machine)\n          output = \"\"\n          machine.communicate.sudo(\"sysctl kern.osrelease\") do |_, data|\n            output = data\n          end",
    "comment": "Get the darwin major version  @param [Machine] @return [int] major version of drawin (nil if version is not detected)",
    "label": "",
    "id": "1121"
  },
  {
    "raw_code": "def self.write_apfs_firmlinks(env)\n          if env && env[:machine] && delayed = apfs_firmlinks_delayed.delete(env[:machine].id)\n            delayed.call\n          end",
    "comment": "Entry point for hook to called delayed actions which finalizing the synced folders setup on the guest",
    "label": "",
    "id": "1122"
  },
  {
    "raw_code": "def self.apfs_firmlinks_delayed\n          if !@_apfs_firmlinks\n            @_apfs_firmlinks = {}\n          end",
    "comment": "@return [Hash] storage location for delayed actions",
    "label": "",
    "id": "1123"
  },
  {
    "raw_code": "def self.mount_vmware_shared_folder(machine, name, guestpath, options)\n          # Use this variable to determine which machines\n          # have been registered with after hook\n          @apply_firmlinks ||= Hash.new{ |h, k| h[k] = {bootstrap: false, content: []} }\n\n          machine.communicate.tap do |comm|\n            # check if we are dealing with an APFS root container\n            if comm.test(\"test -d /System/Volumes/Data\")\n              parts = Pathname.new(guestpath).descend.to_a\n              firmlink = parts[1].to_s\n              firmlink.slice!(0, 1) if firmlink.start_with?(\"/\")\n              if parts.size > 2\n                guestpath = File.join(\"/System/Volumes/Data\", guestpath)\n              else\n                guestpath = nil\n              end",
    "comment": "we seem to be unable to ask 'mount -t vmhgfs' to mount the roots of specific shares, so instead we symlink from what is already mounted by the guest tools (ie. the behaviour of the VMware_fusion provider prior to 0.8.x)",
    "label": "",
    "id": "1124"
  },
  {
    "raw_code": "def self.system_firmlink?(firmlink)\n          if !@_firmlinks\n            if File.exist?(\"/usr/share/firmlinks\")\n              @_firmlinks = File.readlines(\"/usr/share/firmlinks\").map do |line|\n                line.split.first\n              end",
    "comment": "Check if firmlink is provided by the system  @param [String] firmlink Firmlink path @return [Boolean]",
    "label": "",
    "id": "1125"
  },
  {
    "raw_code": "def self.reset!\n          instance_variables.each(&method(:remove_instance_variable))\n        end",
    "comment": "@private Reset the cached values for capability. This is not considered a public API and should only be used for testing.",
    "label": "",
    "id": "1126"
  },
  {
    "raw_code": "def self.configure_netplan(machine, interfaces, comm, networks)\n          ethernets = {}.tap do |e_nets|\n            networks.each do |network|\n              e_config = {}.tap do |entry|\n                if network[:type].to_s == \"dhcp\"\n                  entry[\"dhcp4\"] = true\n                else\n                  mask = network[:netmask]\n                  if mask && IPAddr.new(network[:ip]).ipv4?\n                    begin\n                      mask = IPAddr.new(mask).to_i.to_s(2).count(\"1\")\n                    rescue IPAddr::Error\n                      # ignore and use given value\n                    end",
    "comment": "Configure networking using netplan",
    "label": "",
    "id": "1127"
  },
  {
    "raw_code": "def self.configure_networkd(machine, interfaces, comm, networks)\n          networks.each do |network|\n            dev_name = interfaces[network[:interface]]\n            net_conf = []\n            net_conf << \"[Match]\"\n            net_conf << \"Name=#{dev_name}\"\n            net_conf << \"[Network]\"\n            if network[:type].to_s == \"dhcp\"\n              net_conf << \"DHCP=yes\"\n            else\n              mask = network[:netmask]\n              if mask && IPAddr.new(network[:ip]).ipv4?\n                begin\n                  mask = IPAddr.new(mask).to_i.to_s(2).count(\"1\")\n                rescue IPAddr::Error\n                  # ignore and use given value\n                end",
    "comment": "Configure guest networking using networkd",
    "label": "",
    "id": "1128"
  },
  {
    "raw_code": "def self.configure_nettools(machine, interfaces, comm, networks)\n          commands = []\n          entries = []\n          root_device = interfaces.first\n          networks.each do |network|\n            network[:device] = interfaces[network[:interface]]\n\n            entry = TemplateRenderer.render(\"guests/debian/network_#{network[:type]}\",\n              options: network.merge(:root_device => root_device),\n            )\n            entries << entry\n          end",
    "comment": "Configure guest networking using net-tools",
    "label": "",
    "id": "1129"
  },
  {
    "raw_code": "def self.upload_tmp_file(comm, content, remote_path=nil)\n          if remote_path.nil?\n            remote_path = \"/tmp/vagrant-network-entry-#{Time.now.to_i}\"\n          end",
    "comment": "Simple helper to upload content to guest temporary file  @param [Vagrant::Plugin::Communicator] comm @param [String] content @return [String] remote path",
    "label": "",
    "id": "1130"
  },
  {
    "raw_code": "def self.restart_each_interface(machine, logger)\n          comm = machine.communicate\n          interfaces = VagrantPlugins::GuestLinux::Cap::NetworkInterfaces.network_interfaces(machine)\n          nettools = true\n          if systemd?(comm)\n            logger.debug(\"Attempting to restart networking with systemctl\")\n            nettools = false\n          else\n            logger.debug(\"Attempting to restart networking with ifup/down nettools\")\n          end",
    "comment": "Due to how most Debian systems and older Ubuntu systems handle restarting networking, we cannot simply run the networking init script or use the ifup/down tools to restart all interfaces to renew the machines DHCP lease when setting its hostname. This method is a workaround for those older systems that cannoy reliably restart networking. It restarts each individual interface on its own instead.  @param [Vagrant::Machine] machine @param [Log4r::Logger] logger",
    "label": "",
    "id": "1131"
  },
  {
    "raw_code": "def network_adapters\n        wsman_version == 2? network_adapters_v2_winrm : network_adapters_v3_winrm\n      end",
    "comment": "Returns an array of all NICs on the guest. Each array entry is a Hash of the NICs properties.  @return [Array]",
    "label": "",
    "id": "1132"
  },
  {
    "raw_code": "def is_dhcp_enabled(nic_index)\n        cmd = <<-EOH\n          if (Get-WmiObject -Class Win32_NetworkAdapterConfiguration -Filter \"Index=#{nic_index} and DHCPEnabled=True\") {\n            exit 0\n          }\n          exit 1\n        EOH\n        @communicator.test(cmd)\n      end",
    "comment": "Checks to see if the specified NIC is currently configured for DHCP.  @return [Boolean]",
    "label": "",
    "id": "1133"
  },
  {
    "raw_code": "def configure_dhcp_interface(nic_index, net_connection_id)\n        @logger.info(\"Configuring NIC #{net_connection_id} for DHCP\")\n        if !is_dhcp_enabled(nic_index)\n          netsh = \"netsh interface ip set address \\\"#{net_connection_id}\\\" dhcp\"\n          @communicator.execute(netsh)\n        end",
    "comment": "Configures the specified interface for DHCP  @param [Integer] The interface index. @param [String] The unique name of the NIC, such as 'Local Area Connection'.",
    "label": "",
    "id": "1134"
  },
  {
    "raw_code": "def configure_static_interface(nic_index, net_connection_id, ip, netmask)\n        @logger.info(\"Configuring NIC #{net_connection_id} using static ip #{ip}\")\n        #netsh interface ip set address \"Local Area Connection 2\" static 192.168.33.10 255.255.255.0\n        netsh = \"netsh interface ip set address \\\"#{net_connection_id}\\\" static #{ip} #{netmask}\"\n        @communicator.execute(netsh)\n      end",
    "comment": "Configures the specified interface using a static address  @param [Integer] The interface index. @param [String] The unique name of the NIC, such as 'Local Area Connection'. @param [String] The static IP address to assign to the specified NIC. @param [String] The network mask to use with the static IP.",
    "label": "",
    "id": "1135"
  },
  {
    "raw_code": "def set_all_networks_to_work\n        @logger.info(\"Setting all networks to 'Work Network'\")\n        command = File.read(File.expand_path(\"../scripts/set_work_network.ps1\", __FILE__))\n        @communicator.execute(command, { shell: :powershell })\n      end",
    "comment": "Sets all networks on the guest to 'Work Network' mode. This is to allow guest access from the host via a private IP on Win7 https://github.com/WinRb/vagrant-windows/issues/63",
    "label": "",
    "id": "1136"
  },
  {
    "raw_code": "def wsman_version\n        @logger.debug(\"querying WSMan version\")\n        version = ''\n        @communicator.execute(PS_GET_WSMAN_VER, { shell: :powershell }) do |type, line|\n          version = version + \"#{line}\" if type == :stdout && !line.nil?\n        end",
    "comment": "Checks the WinRS version on the guest. Usually 2 on Windows 7/2008 and 3 on Windows 8/2012.  @return [Integer]",
    "label": "",
    "id": "1137"
  },
  {
    "raw_code": "def network_adapters_v2_winrm\n        @logger.debug(\"querying network adapters\")\n\n        # Get all NICs that have a MAC address\n        # https://msdn.microsoft.com/en-us/library/windows/desktop/aa394216(v=vs.85).aspx\n        adapters = @communicator.execute(WQL_NET_ADAPTERS_V2, { shell: :wql } )[:win32_network_adapter]\n        @logger.debug(\"#{adapters.inspect}\")\n        return adapters\n      end",
    "comment": "Returns an array of all NICs on the guest. Each array entry is a Hash of the NICs properties. This method should only be used on guests that have WinRS version 2.  @return [Array]",
    "label": "",
    "id": "1138"
  },
  {
    "raw_code": "def network_adapters_v3_winrm\n        command = File.read(File.expand_path(\"../scripts/winrs_v3_get_adapters.ps1\", __FILE__))\n        output = \"\"\n        @communicator.execute(command, { shell: :powershell }) do |type, line|\n          output = output + \"#{line}\" if type == :stdout && !line.nil?\n        end",
    "comment": "Returns an array of all NICs on the guest. Each array entry is a Hash of the NICs properties. This method should only be used on guests that have WinRS version 3.  This method is a workaround until the WinRM gem supports WinRS version 3.  @return [Array]",
    "label": "",
    "id": "1139"
  },
  {
    "raw_code": "def self.fetch_guest_paths(communicator)\n          output = \"\"\n          communicator.execute(\"Write-Output $env:TEMP\\nWrite-Output $env:USERPROFILE\", shell: \"powershell\") do |type, data|\n            if type == :stdout\n              output << data\n            end",
    "comment": "Fetch user's temporary and home directory paths from the Windows guest  @param [Communicator] @return [Hash] {:temp, :home}",
    "label": "",
    "id": "1140"
  },
  {
    "raw_code": "def self.create_tmp_path(machine, opts)\n          comm = machine.communicate\n          path = \"\"\n          cmd = \"Write-Output ([System.IO.Path]::Combine([System.IO.Path]::GetTempPath(), \" \\\n            \"[System.IO.Path]::GetRandomFileName())) | Out-String -Width 2048\"\n          comm.execute(cmd, shell: :powershell) do |type, data|\n            if type == :stdout\n              path << data\n            end",
    "comment": "Create a temporary file or directory on the guest  @param [Vagrant::Machine] machine Vagrant guest machine @param [Hash] opts Path options @return [String] path to temporary file or directory",
    "label": "",
    "id": "1141"
  },
  {
    "raw_code": "def self.decompress_zip(machine, compressed_file, destination, opts={})\n          comm = machine.communicate\n          extract_dir = create_tmp_path(machine, type: :directory)\n          cmds = []\n          destination = destination.tr(\"/\", \"\\\\\")\n          if opts[:type] == :directory\n            cmds << \"New-Item -ItemType Directory -Force -Path \\\"#{destination}\\\"\"\n          else\n            d_parts = destination.split(\"\\\\\")\n            d_parts.pop\n            parent_dir = d_parts.join(\"\\\\\") + \"\\\\\"\n            cmds << \"New-Item -ItemType Directory -Force -Path \\\"#{parent_dir}\\\"\"\n          end",
    "comment": "Decompress zip file on guest to given location  @param [Vagrant::Machine] machine Vagrant guest machine @param [String] compressed_file Path to compressed file on guest @param [String] destination Path for decompressed files on guest",
    "label": "",
    "id": "1142"
  },
  {
    "raw_code": "def self.assign_device_names(machine, networks)\n          if machine.communicate.test(\"command -v biosdevname\")\n            # use biosdevname to get info about the interfaces\n            interfaces = get_interfaces(machine)\n            if machine.provider.capability?(:nic_mac_addresses)\n              # find device name by MAC lookup.\n              mac_addresses = machine.provider.capability(:nic_mac_addresses)\n              networks.each do |network|\n                mac_address = mac_addresses[network[:interface]+1]\n                interface = interfaces.detect {|nic| nic[:mac_address].gsub(\":\",\"\") == mac_address} if mac_address\n                network[:device] = interface[:kernel] if interface\n              end",
    "comment": "Set :device on each network. Attempts to use biosdevname when available to detect interface names, and falls back to ifconfig otherwise.",
    "label": "",
    "id": "1143"
  },
  {
    "raw_code": "def self.upload(machine, content, remote_path)\n          remote_temp = mktemp(machine)\n\n          Tempfile.open(\"vagrant-nixos-configure-networks\") do |f|\n            f.binmode\n            f.write(content)\n            f.fsync\n            f.close\n            machine.communicate.upload(f.path, \"#{remote_temp}\")\n          end",
    "comment": "Upload a file.",
    "label": "",
    "id": "1144"
  },
  {
    "raw_code": "def self.mktemp(machine)\n          path = nil\n\n          machine.communicate.execute(\"mktemp --suffix -vagrant-upload\") do |type, result|\n            path = result.chomp if type == :stdout\n          end",
    "comment": "Create a temp file.",
    "label": "",
    "id": "1145"
  },
  {
    "raw_code": "def self.get_interfaces(machine)\n          interfaces = []\n\n          # get all adapters, as named by the kernel\n          output = nil\n          machine.communicate.sudo(\"biosdevname -d\") do |type, result|\n            output = result if type == :stdout\n          end",
    "comment": "using biosdevname, get all interfaces as a list of hashes, where: :kernel      - the kernel's name for the device, :ethn        - the calculated ethN-style name converted to integer. :mac_address - the permanent mac address. ethN-style name converted to integer.",
    "label": "",
    "id": "1146"
  },
  {
    "raw_code": "def self.upload(machine, content, remote_path)\n          remote_temp = mktemp(machine)\n\n          Tempfile.open(\"vagrant-nixos-change-host-name\") do |f|\n            f.binmode\n            f.write(content)\n            f.fsync\n            f.close\n            machine.communicate.upload(f.path, \"#{remote_temp}\")\n          end",
    "comment": "Upload a file.",
    "label": "",
    "id": "1147"
  },
  {
    "raw_code": "def self.mktemp(machine)\n          path = nil\n\n          machine.communicate.execute(\"mktemp --suffix -vagrant-upload\") do |type, result|\n            path = result.chomp if type == :stdout\n          end",
    "comment": "Create a temp file.",
    "label": "",
    "id": "1148"
  },
  {
    "raw_code": "def update_etc_hosts\n          comm = machine.communicate\n          network_with_hostname = machine.config.vm.networks.map {|_, c| c if c[:hostname] }.compact[0]\n          if network_with_hostname\n            replace_host(comm, new_hostname, network_with_hostname[:ip])\n          else\n            add_hostname_to_loopback_interface(comm, new_hostname)\n          end",
    "comment": "/etc/hosts should resemble: 127.0.0.1   localhost 127.0.1.1   host.fqdn.com host.fqdn host",
    "label": "",
    "id": "1149"
  },
  {
    "raw_code": "def ensure_installed\n        if !@machine.guest.capability?(:docker_installed)\n          @machine.ui.warn(I18n.t(\"vagrant.docker_cant_detect\"))\n          return false\n        end",
    "comment": "This handles verifying the Docker installation, installing it if it was requested, and so on. This method will raise exceptions if things are wrong. @return [Boolean] - false if docker cannot be detected on machine, else true if docker installs correctly or is installed",
    "label": "",
    "id": "1150"
  },
  {
    "raw_code": "def handle_comm(type, data)\n        if [:stderr, :stdout].include?(type)\n          # Output the line with the proper color based on the stream.\n          color = type == :stdout ? :green : :red\n\n          options = {}\n          options[:color] = color if !config.keep_color\n\n          @machine.ui.detail(data.chomp, **options)\n        end",
    "comment": "This handles outputting the communication line back to the UI",
    "label": "",
    "id": "1151"
  },
  {
    "raw_code": "def provision_ssh(args)\n        env = config.env.map { |k,v| \"#{k}=#{quote_and_escape(v.to_s)}\" }\n        env = env.join(\" \")\n\n        command =  \"chmod +x '#{upload_path}'\"\n        command << \" &&\"\n        command << \" #{env}\" if !env.empty?\n        command << \" #{upload_path}#{args}\"\n\n        with_script_file do |path|\n          # Upload the script to the machine\n          @machine.communicate.tap do |comm|\n            # Reset upload path permissions for the current ssh user\n            info = nil\n            retryable(on: Vagrant::Errors::SSHNotReady, tries: 3, sleep: 2) do\n              info = @machine.ssh_info\n              raise Vagrant::Errors::SSHNotReady if info.nil?\n            end",
    "comment": "This is the provision method called if SSH is what is running on the remote end, which assumes a POSIX-style host.",
    "label": "",
    "id": "1152"
  },
  {
    "raw_code": "def provision_winssh(args)\n        with_script_file do |path|\n          # Upload the script to the machine\n          @machine.communicate.tap do |comm|\n            env = config.env.map{|k,v| comm.generate_environment_export(k, v)}.join(';')\n\n            remote_ext = get_windows_ext(path)\n            remote_path = add_extension(upload_path, remote_ext)\n\n            if remote_ext == \".bat\"\n              command = \"#{env}\\n cmd.exe /c \\\"#{remote_path}\\\" #{args}\"\n            else\n              # Copy powershell_args from configuration\n              shell_args = config.powershell_args\n              # For PowerShell scripts bypass the execution policy unless already specified\n              shell_args += \" -ExecutionPolicy Bypass\" if config.powershell_args !~ /[-\\/]ExecutionPolicy/i\n              # CLIXML output is kinda useless, especially on non-windows hosts\n              shell_args += \" -OutputFormat Text\" if config.powershell_args !~ /[-\\/]OutputFormat/i\n              command = \"#{env}\\npowershell #{shell_args} -file \\\"#{remote_path}\\\"#{args}\"\n            end",
    "comment": "This is the provision method called if Windows OpenSSH is what is running on the remote end, which assumes a non-POSIX-style host.",
    "label": "",
    "id": "1153"
  },
  {
    "raw_code": "def provision_winrm(args)\n        if @machine.guest.capability?(:wait_for_reboot)\n          @machine.guest.capability(:wait_for_reboot)\n        end",
    "comment": "This provisions using WinRM, which assumes a PowerShell console on the other side.",
    "label": "",
    "id": "1154"
  },
  {
    "raw_code": "def quote_and_escape(text, quote = '\"')\n        \"#{quote}#{text.gsub(/#{quote}/) { |m| \"#{m}\\\\#{m}#{m}\" }}#{quote}\"\n      end",
    "comment": "Quote and escape strings for shell execution, thanks to Capistrano.",
    "label": "",
    "id": "1155"
  },
  {
    "raw_code": "def with_script_file\n        ext    = nil\n        script = nil\n\n        if config.remote?\n          download_path = @machine.env.tmp_path.join(\n            \"#{@machine.id}-remote-script\")\n          download_path.delete if download_path.file?\n\n          begin\n            Vagrant::Util::Downloader.new(\n              config.path,\n              download_path,\n              md5: config.md5,\n              sha1: config.sha1,\n              sha256: config.sha256,\n              sha384: config.sha384,\n              sha512: config.sha512\n            ).download!\n            ext    = File.extname(config.path)\n            script = download_path.read\n          ensure\n            download_path.delete if download_path.file?\n          end",
    "comment": "This method yields the path to a script to upload and execute on the remote server. This method will properly clean up the script file if needed.",
    "label": "",
    "id": "1156"
  },
  {
    "raw_code": "def args_valid?\n        return true if !args\n        return true if args.is_a?(String)\n        return true if args.is_a?(Integer)\n        if args.is_a?(Array)\n          args.each do |a|\n            return false if !a.kind_of?(String) && !a.kind_of?(Integer)\n          end",
    "comment": "Args are optional, but if they're provided we only support them as a string or as an array.",
    "label": "",
    "id": "1157"
  },
  {
    "raw_code": "def expanded_module_paths(root_path)\n          return [] if !module_path\n\n          # Get all the paths and expand them relative to the root path, returning\n          # the array of expanded paths\n          paths = module_path\n          paths = [paths] if !paths.is_a?(Array)\n          paths.map do |path|\n            Pathname.new(path).expand_path(root_path)\n          end",
    "comment": "Returns the module paths as an array of paths expanded relative to the root path.",
    "label": "",
    "id": "1158"
  },
  {
    "raw_code": "def keys(group='minions')\n        out = @machine.communicate.sudo(\"salt-key --out json\") do |type, output|\n          begin\n            if type == :stdout\n              out = JSON::load(output)\n              break out[group]\n            end",
    "comment": "Return a list of accepted keys",
    "label": "",
    "id": "1159"
  },
  {
    "raw_code": "def expanded_path(rel_path)\n        Pathname.new(rel_path).expand_path(@machine.env.root_path)\n      end",
    "comment": "Utilities",
    "label": "",
    "id": "1160"
  },
  {
    "raw_code": "def bootstrap_options(install, configure, config_dir)\n        # Any extra options passed to bootstrap\n        if @config.bootstrap_options\n          options = @config.bootstrap_options\n        else\n          options = \"\"\n        end",
    "comment": "Generates option string for bootstrap script",
    "label": "",
    "id": "1161"
  },
  {
    "raw_code": "def get_pillar\n        if !@config.pillar_data.empty?\n          if @machine.config.vm.communicator == :winrm\n            # ' doesn't have any special behavior on the command prompt,\n            # so '{\"x\":\"y\"}' becomes '{x:y}' with literal single quotes.\n            # However, \"\"\" will become \" , and \\\\\"\"\" will become \\\" .\n            # Use \\\\\"\" instead of \\\\\"\"\" for literal inner-value quotes\n            # to avoid issue with odd number of quotes.\n            # --% disables special PowerShell parsing on the rest of the line.\n            \" --% pillar=#{@config.pillar_data.to_json.gsub(/(?<!\\\\)\\\"/, '\"\"\"').gsub(/\\\\\\\"/, %q(\\\\\\\\\\\"\"))}\"\n          else\n            \" pillar='#{@config.pillar_data.to_json}'\"\n          end",
    "comment": "Actions Get pillar string to pass with the salt command",
    "label": "",
    "id": "1162"
  },
  {
    "raw_code": "def get_colorize\n        @config.colorize ? \" --force-color\" : \" --no-color\"\n      end",
    "comment": "Get colorization option string to pass with the salt command",
    "label": "",
    "id": "1163"
  },
  {
    "raw_code": "def get_loglevel\n        log_levels = [\"all\", \"garbage\", \"trace\", \"debug\", \"info\", \"warning\", \"error\", \"quiet\"]\n        if log_levels.include? @config.log_level\n          \" --log-level=#{@config.log_level}\"\n        else\n          \" --log-level=debug\"\n        end",
    "comment": "Get log output level option string to pass with the salt command",
    "label": "",
    "id": "1164"
  },
  {
    "raw_code": "def get_masterless\n        options = \"\"\n\n        if @config.masterless\n          options = \" --local\"\n          if @config.minion_id\n            options += \" --id #{@config.minion_id}\"\n          end",
    "comment": "Get command-line options for masterless provisioning",
    "label": "",
    "id": "1165"
  },
  {
    "raw_code": "def get_salt_args\n        \" \" + Array(@config.salt_args).join(\" \")\n      end",
    "comment": "Append additional arguments to the salt command",
    "label": "",
    "id": "1166"
  },
  {
    "raw_code": "def get_call_args\n        \" \" + Array(@config.salt_call_args).join(\" \")\n      end",
    "comment": "Append additional arguments to the salt-call command",
    "label": "",
    "id": "1167"
  },
  {
    "raw_code": "def upload_configs\n        if @config.minion_config\n          @machine.env.ui.info \"Copying salt minion config to vm.\"\n          @machine.communicate.upload(expanded_path(@config.minion_config).to_s, temp_config_dir + \"/minion\")\n        end",
    "comment": "Copy master and minion configs to VM",
    "label": "",
    "id": "1168"
  },
  {
    "raw_code": "def upload_keys\n        if @config.minion_key and @config.minion_pub\n          @machine.env.ui.info \"Uploading minion keys.\"\n          @machine.communicate.upload(expanded_path(@config.minion_key).to_s, temp_config_dir + \"/minion.pem\")\n          @machine.communicate.sudo(\"chmod u+w #{temp_config_dir}/minion.pem\")\n          @machine.communicate.upload(expanded_path(@config.minion_pub).to_s, temp_config_dir + \"/minion.pub\")\n        end",
    "comment": "Copy master and minion keys to VM",
    "label": "",
    "id": "1169"
  },
  {
    "raw_code": "def get_bootstrap\n        if @config.bootstrap_script\n          bootstrap_abs_path = expanded_path(@config.bootstrap_script)\n        else\n          bootstrap_downloader = BootstrapDownloader.new(@machine.config.vm.guest)\n          bootstrap_script = bootstrap_downloader.get_bootstrap_script\n          bootstrap_abs_path = expanded_path(bootstrap_script.path)\n        end",
    "comment": "Get bootstrap file location, bundled or custom",
    "label": "",
    "id": "1170"
  },
  {
    "raw_code": "def run_bootstrap_script\n        install = need_install()\n        configure = need_configure()\n        config_dir = temp_config_dir()\n        options = bootstrap_options(install, configure, config_dir)\n\n        if configure or install\n          if configure and !install\n            @machine.env.ui.info \"Salt binaries found. Configuring only.\"\n          else\n            @machine.env.ui.info \"Bootstrapping Salt... (this may take a while)\"\n          end",
    "comment": "Determine if we are configure and/or installing, then do either",
    "label": "",
    "id": "1171"
  },
  {
    "raw_code": "def set_default_configs\n        OPTIMISTIC_PATH_DEFAULTS.each do |config_key, config_default|\n          if config.send(config_key) == Config::UNSET_VALUE\n            config_value = File.exist?(expanded_path(config_default)) ? config_default : nil\n            config.send(\"#{config_key}=\", config_value)\n          end",
    "comment": "Sets optimistic default values into config",
    "label": "",
    "id": "1172"
  },
  {
    "raw_code": "def expand_guest_path(destination)\n        if machine.guest.capability?(:shell_expand_guest_path)\n          machine.guest.capability(:shell_expand_guest_path, destination)\n        else\n          destination\n        end",
    "comment": "Expand the guest path if the guest has the capability",
    "label": "",
    "id": "1173"
  },
  {
    "raw_code": "def inventory_path\n          if config.inventory_path\n            config.inventory_path\n          else\n            @inventory_path ||= generate_inventory\n          end",
    "comment": "Auto-generate \"safe\" inventory file based on Vagrantfile, unless inventory_path is explicitly provided",
    "label": "",
    "id": "1174"
  },
  {
    "raw_code": "def generate_inventory_groups\n          groups_of_groups = {}\n          defined_groups = []\n          group_vars = {}\n          inventory_groups = \"\"\n\n          # Verify if host range patterns exist and warn\n          if config.groups.any? { |gm| gm.to_s[RANGE_PATTERN] }\n            @machine.ui.warn(I18n.t(\"vagrant.provisioners.ansible.ansible_host_pattern_detected\"))\n          end",
    "comment": "Write out groups information. All defined groups will be included, but only supported machines and defined child groups will be included.",
    "label": "",
    "id": "1175"
  },
  {
    "raw_code": "def check_and_install_ansible\n          @logger.info(\"Checking for Ansible installation...\")\n\n          # If the guest cannot check if Ansible is installed,\n          # print a warning and try to continue without any installation attempt...\n          if !@machine.guest.capability?(:ansible_installed)\n            @machine.ui.warn(I18n.t(\"vagrant.provisioners.ansible.cannot_detect\"))\n            return\n          end",
    "comment": " This handles verifying the Ansible installation, installing it if it was requested, and so on. This method will raise exceptions if things are wrong. The compatibility mode checks are also performed here in order to fetch the Ansible version information only once.  Current limitations: - The installation of a specific Ansible version is only supported by the \"pip\" install_mode. Note that \"pip\" installation also takes place via a default command. If pip needs to be installed differently then the command can be overwritten by supplying \"pip_install_cmd\" in the config settings. - There is no absolute guarantee that the automated installation will replace a previous Ansible installation (although it works fine in many cases) ",
    "label": "",
    "id": "1176"
  },
  {
    "raw_code": "def self.ansible_installed(machine, version)\n              command = 'test -x \"$(command -v ansible)\"'\n\n              unless version.empty?\n                command << \"&& [[ $(python3 -c \\\"import importlib.metadata; print(importlib.metadata.version('ansible'))\\\") == \\\"#{version}\\\" ]]\"\n              end",
    "comment": "Check if Ansible is installed (at the given version). @return [true, false]",
    "label": "",
    "id": "1177"
  },
  {
    "raw_code": "def validate(machine)\n          @errors = _detected_errors\n\n          # Validate that a compatibility mode was provided\n          if !compatibility_mode\n            @errors << I18n.t(\"vagrant.provisioners.ansible.errors.no_compatibility_mode\",\n              valid_modes: Ansible::COMPATIBILITY_MODES.map { |s| \"'#{s}'\" }.join(', '))\n          end",
    "comment": "Just like the normal configuration \"validate\" method except that it returns an array of errors that should be merged into some other error accumulator.",
    "label": "",
    "id": "1178"
  },
  {
    "raw_code": "def ensure_installed(kubic)\n        if !@machine.guest.capability?(:podman_installed)\n          @machine.ui.warn(\"Podman can not be installed\")\n          return false\n        end",
    "comment": "This handles verifying the Podman installation, installing it if it was requested, and so on. This method will raise exceptions if things are wrong. @params [Boolean] - if true install should use kubic project (this will) add a yum repo. if false install comes from default yum @return [Boolean] - false if podman cannot be detected on machine, else true if podman installs correctly or is installed",
    "label": "",
    "id": "1179"
  },
  {
    "raw_code": "def ensure_installed\n        # If the guest cannot check if Chef is installed, just exit printing a\n        # warning...\n        if !@machine.guest.capability?(:chef_installed)\n          @machine.ui.warn(I18n.t(\"vagrant.chef_cant_detect\"))\n          return\n        end",
    "comment": "This handles verifying the Chef installation, installing it if it was requested, and so on. This method will raise exceptions if things are wrong.",
    "label": "",
    "id": "1180"
  },
  {
    "raw_code": "def should_install_chef?\n        @force || !@machine.guest.capability(:chef_installed, @product, @version)\n      end",
    "comment": "Determine if Chef should be installed. Chef is installed if the \"force\" option is given or if the guest does not have Chef installed at the proper version.",
    "label": "",
    "id": "1181"
  },
  {
    "raw_code": "def chef_binary_path(binary)\n          return binary if !@config.binary_path\n          return File.join(@config.binary_path, binary)\n        end",
    "comment": "Returns the path to the Chef binary, taking into account the `binary_path` configuration option.",
    "label": "",
    "id": "1182"
  },
  {
    "raw_code": "def expanded_folders(paths, appended_folder=nil)\n          # Convert the path to an array if it is a string or just a single\n          # path element which contains the folder location (:host or :vm)\n          paths = [paths] if paths.is_a?(String) || paths.first.is_a?(Symbol)\n\n          results = []\n          paths.each do |type, path|\n            # Create the local/remote path based on whether this is a host\n            # or VM path.\n            local_path = nil\n            remote_path = nil\n            if type == :host\n              # Get the expanded path that the host path points to\n              local_path = File.expand_path(path, @machine.env.root_path)\n\n              if File.exist?(local_path)\n                # Path exists on the host, setup the remote path. We use\n                # the MD5 of the local path so that it is predictable.\n                key         = Digest::MD5.hexdigest(local_path)\n                remote_path = \"#{guest_provisioning_path}/#{key}\"\n              else\n                appended_folder = \"cookbooks\" if appended_folder.nil?\n                @machine.ui.warn(I18n.t(\"vagrant.provisioners.chef.#{appended_folder}_folder_not_found_warning\",\n                                       path: local_path.to_s))\n                next\n              end",
    "comment": "Converts paths to a list of properly expanded paths with types.",
    "label": "",
    "id": "1183"
  },
  {
    "raw_code": "def share_folders(root_config, prefix, folders, existing=nil)\n          existing_set = Set.new\n          (existing || []).each do |_, fs|\n            fs.each do |id, data|\n              existing_set.add(data[:guestpath])\n            end",
    "comment": "Shares the given folders with the given prefix. The folders should be of the structure resulting from the `expanded_folders` function.",
    "label": "",
    "id": "1184"
  },
  {
    "raw_code": "def guest_paths(folders)\n          folders.map { |parts| parts[2] }\n        end",
    "comment": "Extracts only the remote paths from a list of folders",
    "label": "",
    "id": "1185"
  },
  {
    "raw_code": "def guest_paths(folders)\n          folders.map { |parts| parts[2] }\n        end",
    "comment": "Extracts only the remote paths from a list of folders",
    "label": "",
    "id": "1186"
  },
  {
    "raw_code": "def target_recipe_path\n          key = Digest::MD5.hexdigest(config.recipe)\n          File.join(config.upload_path, \"recipe-#{key}.rb\")\n        end",
    "comment": "The destination (on the guest) where the recipe will live @return [String]",
    "label": "",
    "id": "1187"
  },
  {
    "raw_code": "def upload_recipe\n          # Write the raw recipe contents to a tempfile and upload\n          Tempfile.open([\"vagrant-chef-apply\", \".rb\"]) do |f|\n            f.binmode\n            f.write(config.recipe)\n            f.fsync\n            f.close\n\n            # Upload the tempfile to the guest\n            @machine.communicate.upload(f.path, target_recipe_path)\n          end",
    "comment": "Write the raw recipe contents to a tempfile and upload that to the machine.",
    "label": "",
    "id": "1188"
  },
  {
    "raw_code": "def self.chef_installed(machine, product, version)\n            product_name = product == 'chef-workstation' ? 'chef-workstation' : 'chef'\n            verify_bin = product_name == 'chef-workstation' ? 'chef' : 'chef-client'\n            verify_path = \"/opt/#{product_name}/bin/#{verify_bin}\"\n            command = \"test -x #{verify_path}\"\n\n            if version != :latest\n              command << \"&& #{verify_path} --version | grep '#{version}'\"\n            end",
    "comment": "Check if Chef is installed at the given version. @return [true, false]",
    "label": "",
    "id": "1189"
  },
  {
    "raw_code": "def self.chef_installed(machine, product, version)\n            product_name = product == 'chef-workstation' ? 'chef-workstation' : 'chef'\n            verify_bin = product_name == 'chef-workstation' ? 'chef' : 'chef-client'\n            verify_path = \"/opt/#{product_name}/bin/#{verify_bin}\"\n            command = \"test -x #{verify_path}\"\n\n            if version != :latest\n              command << \"&& #{verify_path} --version | grep '#{version}'\"\n            end",
    "comment": "Check if Chef is installed at the given version. @return [true, false]",
    "label": "",
    "id": "1190"
  },
  {
    "raw_code": "def self.chef_installed(machine, product, version)\n            product_name = product == 'chef-workstation' ? 'chef-workstation' : 'chef'\n            verify_bin = product_name == 'chef-workstation' ? 'chef' : 'chef-client'\n            verify_path = \"/opt/#{product_name}/bin/#{verify_bin}\"\n            command = \"test -x #{verify_path}\"\n\n            if version != :latest\n              command << \"&& #{verify_path} --version | grep '#{version}'\"\n            end",
    "comment": "TODO: this is the same code as cap/linux/chef_installed, consider merging Check if Chef is installed at the given version. @return [true, false]",
    "label": "",
    "id": "1191"
  },
  {
    "raw_code": "def self.chef_installed(machine, product, version)\n            verify_bin = product == 'chef-workstation' ? 'chef' : 'chef-client'\n            if version != :latest\n              command = 'if ((&' + verify_bin + ' --version) -Match \"' + version.to_s + '\"){ exit 0 } else { exit 1 }'\n            else\n              command = 'if ((&' + verify_bin + ' --version) -Match \"Chef*\"){ exit 0 } else { exit 1 }'\n            end",
    "comment": "Check if Chef is installed at the given version. @return [true, false]",
    "label": "",
    "id": "1192"
  },
  {
    "raw_code": "def validate_base(machine)\n          errors = super\n\n          if @custom_config_path\n            expanded = File.expand_path(@custom_config_path, machine.env.root_path)\n            if !File.file?(expanded)\n              errors << I18n.t(\"vagrant.config.chef.custom_config_path_missing\")\n            end",
    "comment": "Just like the normal configuration \"validate\" method except that it returns an array of errors that should be merged into some other error accumulator.",
    "label": "",
    "id": "1193"
  },
  {
    "raw_code": "def add_recipe(name)\n          name = \"recipe[#{name}]\" unless name =~ /^recipe\\[(.+?)\\]$/\n            run_list << name\n        end",
    "comment": "Adds a recipe to the run list",
    "label": "",
    "id": "1194"
  },
  {
    "raw_code": "def add_role(name)\n          name = \"role[#{name}]\" unless name =~ /^role\\[(.+?)\\]$/\n            run_list << name\n        end",
    "comment": "Adds a role to the run list",
    "label": "",
    "id": "1195"
  },
  {
    "raw_code": "def validate_base(machine)\n          errors = _detected_errors\n\n          if !present?(log_level)\n            errors << I18n.t(\"vagrant.provisioners.chef.log_level_empty\")\n          end",
    "comment": "Like validate, but returns a list of errors to append.  @return [Array<String>]",
    "label": "",
    "id": "1196"
  },
  {
    "raw_code": "def finalize!\n          super\n\n          @recipe_url = nil if @recipe_url == UNSET_VALUE\n          @synced_folder_type = nil if @synced_folder_type == UNSET_VALUE\n          @legacy_mode = false if @legacy_mode == UNSET_VALUE\n\n          if @cookbooks_path == UNSET_VALUE\n            @cookbooks_path = []\n            @cookbooks_path << [:host, \"cookbooks\"] if !@recipe_url\n            @cookbooks_path << [:vm, \"cookbooks\"]\n          end",
    "comment": "------------------------------------------------------------ Internal methods ------------------------------------------------------------",
    "label": "",
    "id": "1197"
  },
  {
    "raw_code": "def prepare_folders_config(config)\n          # Make sure the path is an array\n          config = [config] if !config.is_a?(Array) || config.first.is_a?(Symbol)\n\n          return [] if config.flatten.compact.empty?\n\n          # Make sure all the paths are in the proper format\n          config.map do |path|\n            path = [:host, path] if !path.is_a?(Array)\n            path\n          end",
    "comment": "This takes any of the configurations that take a path or array of paths and turns it into the proper format.  @return [Array]",
    "label": "",
    "id": "1198"
  },
  {
    "raw_code": "def prepare_folders_config(config)\n          # Make sure the path is an array\n          config = [config] if !config.is_a?(Array) || config.first.is_a?(Symbol)\n\n          return [] if config.flatten.compact.empty?\n\n          # Make sure all the paths are in the proper format\n          config.map do |path|\n            path = [:host, File.expand_path(path)] if !path.is_a?(Array)\n            path\n          end",
    "comment": "This takes any of the configurations that take a path or array of paths and turns it into the proper format.  @return [Array]",
    "label": "",
    "id": "1199"
  },
  {
    "raw_code": "def cfagent(args, options=nil)\n        options ||= {}\n        command = \"/var/cfengine/bin/cf-agent #{args}\"\n\n        @machine.communicate.sudo(command, error_check: options[:error_check]) do |type, data|\n          if [:stderr, :stdout].include?(type)\n            # Output the data with the proper color based on the stream.\n            color = type == :stdout ? :green : :red\n            @machine.ui.info(\n              data,\n              color: color, new_line: false, prefix: false)\n          end",
    "comment": "This runs cf-agent with the given arguments.",
    "label": "",
    "id": "1200"
  },
  {
    "raw_code": "def cfagent_classes_args\n        return \"\" if !@config.classes\n\n        args = @config.classes.map { |c| \"-D#{c}\" }.join(\" \")\n        return \" #{args}\"\n      end",
    "comment": "Returns the arguments for the classes configuration if they are set.  @return [String]",
    "label": "",
    "id": "1201"
  },
  {
    "raw_code": "def cfagent_extra_args\n        return \"\" if !@config.extra_agent_args\n        return \" #{@config.extra_agent_args}\"\n      end",
    "comment": "Extra arguments for calles to cf-agent.  @return [String]",
    "label": "",
    "id": "1202"
  },
  {
    "raw_code": "def handle_cfengine_bootstrap\n        @logger.info(\"Bootstrapping CFEngine...\")\n        if !@machine.guest.capability(:cfengine_needs_bootstrap, @config)\n          @machine.ui.info(I18n.t(\"vagrant.cfengine_no_bootstrap\"))\n          return\n        end",
    "comment": "This handles checking if the CFEngine installation needs to be bootstrapped, and bootstraps if it does.",
    "label": "",
    "id": "1203"
  },
  {
    "raw_code": "def handle_cfengine_installation\n        if !@machine.guest.capability?(:cfengine_installed)\n          @machine.ui.warn(I18n.t(\"vagrant.cfengine_cant_detect\"))\n          return\n        end",
    "comment": "This handles verifying the CFEngine installation, installing it if it was requested, and so on. This method will raise exceptions if things are wrong.",
    "label": "",
    "id": "1204"
  },
  {
    "raw_code": "def install_files(local_path)\n        @logger.debug(\"Copying local files to CFEngine: #{local_path}\")\n        @machine.communicate.sudo(\"rm -rf /tmp/cfengine-files\")\n        @machine.communicate.upload(local_path.to_s, \"/tmp/cfengine-files\")\n        @machine.communicate.sudo(\"cp -R /tmp/cfengine-files/* /var/cfengine\")\n      end",
    "comment": "This installs a set of files into the CFEngine folder within the machine.  @param [Pathname] local_path",
    "label": "",
    "id": "1205"
  },
  {
    "raw_code": "def build_images(images)\n        @machine.communicate.tap do |comm|\n          images.each do |path, opts|\n            @machine.ui.info(I18n.t(\"vagrant.container_building_single\", path: path))\n            comm.sudo(\"#{@container_command} build #{opts[:args]} #{path}\") do |type, data|\n              handle_comm(type, data)\n            end",
    "comment": "Build an image given a path to a Dockerfile  @param [Array<Array<String, Hash>>] - Path and options to the Dockerfile to pass to container build command",
    "label": "",
    "id": "1206"
  },
  {
    "raw_code": "def pull_images(*images)\n        @machine.communicate.tap do |comm|\n          images.each do |image|\n            @machine.ui.info(I18n.t(\"vagrant.container_pulling_single\", name: image))\n            comm.sudo(\"#{@container_command} pull #{image}\") do |type, data|\n              handle_comm(type, data)\n            end",
    "comment": "Pull image given a list of images  @param [String] - Image name",
    "label": "",
    "id": "1207"
  },
  {
    "raw_code": "def run_container(config)\n        raise \"Container's cidfile was not provided!\" if !config[:cidfile]\n\n        id = \"$(cat #{config[:cidfile]})\"\n\n        if container_exists?(id)\n          if container_args_changed?(config)\n            @machine.ui.info(I18n.t(\"vagrant.container_restarting_container_args\",\n              name: config[:name],\n            ))\n            stop_container(id)\n            create_container(config)\n          elsif container_image_changed?(config)\n            @machine.ui.info(I18n.t(\"vagrant.container_restarting_container_image\",\n              name: config[:name],\n            ))\n            stop_container(id)\n            create_container(config)\n          else\n            start_container(id)\n          end",
    "comment": "Run a OCI container. If the container does not exist it will be created. If the image is stale it will be recreated and restarted",
    "label": "",
    "id": "1208"
  },
  {
    "raw_code": "def start_container(id)\n        if !container_running?(id)\n          @machine.communicate.sudo(\"#{@container_command} start #{id}\")\n        end",
    "comment": "Start container  @param String - Image id",
    "label": "",
    "id": "1209"
  },
  {
    "raw_code": "def stop_container(id)\n        @machine.communicate.sudo %[\n          #{@container_command} stop #{id}\n          #{@container_command} rm #{id}\n        ]\n      end",
    "comment": "Stop and remove container  @param String - Image id",
    "label": "",
    "id": "1210"
  },
  {
    "raw_code": "def lookup_container(id, list_all = false)\n        container_ps = \"sudo #{@container_command} ps -q\"\n        container_ps << \" -a\" if list_all\n        @machine.communicate.tap do |comm|\n          return comm.test(\"#{container_ps} --no-trunc | grep -wFq #{id}\")\n        end",
    "comment": "Looks up if a container with a given id exists using the `ps` command. Returns Boolean  @param String - Image id",
    "label": "",
    "id": "1211"
  },
  {
    "raw_code": "def container_run_args(config)\n        name = container_name(config)\n\n        args = \"--cidfile=#{config[:cidfile]} \"\n        args << \"-d \" if config[:daemonize]\n        args << \"--name #{name} \" if name && config[:auto_assign_name]\n        args << \"--restart=#{config[:restart]}\" if config[:restart]\n        args << \" #{config[:args]}\" if config[:args]\n\n        \"#{args} #{config[:image]} #{config[:cmd]}\".strip\n      end",
    "comment": "Compiles run arguments to be appended to command string. Returns String",
    "label": "",
    "id": "1212"
  },
  {
    "raw_code": "def handle_comm(type, data)\n        if [:stderr, :stdout].include?(type)\n          # Clear out the newline since we add one\n          data = data.chomp\n          return if data.empty?\n\n          options = {}\n          #options[:color] = color if !config.keep_color\n\n          @machine.ui.info(data.chomp, **options)\n        end",
    "comment": "This handles outputting the communication data back to the UI",
    "label": "",
    "id": "1213"
  },
  {
    "raw_code": "def build_images\n        @__build_images\n      end",
    "comment": "Accessor for internal state.",
    "label": "",
    "id": "1214"
  },
  {
    "raw_code": "def containers\n        @__containers\n      end",
    "comment": "Accessor for the internal state.",
    "label": "",
    "id": "1215"
  },
  {
    "raw_code": "def build_image(path, **opts)\n        @__build_images << [path, opts]\n      end",
    "comment": "Defines an image to build using `<cmd> build` within the machine.  @param [String] path Path to the Dockerfile to pass to container build command",
    "label": "",
    "id": "1216"
  },
  {
    "raw_code": "def new_entry(name, box_name, box_provider, version)\n    entry_klass.new.tap do |e|\n      e.name = name\n      e.vagrantfile_path = \"/bar\"\n      e.extra_data[\"box\"] = {\n          \"name\" => box_name,\n          \"provider\" => box_provider,\n          \"version\" => version,\n      }\n    end",
    "comment": "Seems this way of providing a box version triggers box in use.",
    "label": "",
    "id": "1217"
  },
  {
    "raw_code": "def find_last_argument_after(ref_index, ansible_playbook_args, arg_pattern)\n  subset = ansible_playbook_args[(ref_index + 1)..(ansible_playbook_args.length-2)].reverse\n  subset.each do |i|\n    return true if i =~ arg_pattern\n  end",
    "comment": " Helper Functions ",
    "label": "",
    "id": "1218"
  },
  {
    "raw_code": "def self.it_should_check_ansible_version\n    it \"execute 'Python ansible version check before executing 'ansible-playbook'\" do\n      expect(Vagrant::Util::Subprocess).to receive(:execute)\n        .once.with('python3', '-c', \"import importlib.metadata; print('ansible ' + importlib.metadata.version('ansible'))\", { notify: %i[\n                     stdout stderr\n                   ] })\n      expect(Vagrant::Util::Subprocess).to receive(:execute)\n        .once.with('ansible-playbook', any_args)\n    end",
    "comment": " Class methods for code reuse across examples ",
    "label": "",
    "id": "1219"
  },
  {
    "raw_code": "def get_provisioner_option_names(provisioner_class)\n  config_options = provisioner_class.instance_methods(true).find_all { |i| i.to_s.end_with?('=') }\n  config_options.map! { |i| i.to_s.sub('=', '') }\n  (config_options - [\"!\", \"=\", \"==\"]).sort\nend",
    "comment": "Copyright (c) HashiCorp, Inc. SPDX-License-Identifier: BUSL-1.1",
    "label": "",
    "id": "1220"
  },
  {
    "raw_code": "def register_provider(name, config_class=nil, options=nil)\n      provider_cls = Class.new(VagrantTests::DummyProvider)\n\n      register_plugin(\"2\") do |p|\n        p.provider(name, options) { provider_cls }\n\n        if config_class\n          p.config(name, :provider) { config_class }\n        end",
    "comment": "A helper to register a provider for use in tests.",
    "label": "",
    "id": "1221"
  },
  {
    "raw_code": "def new_instance\n    described_class.new(name, provider_name, provider_cls, provider_config,\n                        provider_options, config, data_dir, box,\n                        env, env.vagrantfile, base)\n  end",
    "comment": "Returns a new instance with the test data",
    "label": "",
    "id": "1222"
  },
  {
    "raw_code": "def provider_init_test(instance=nil)\n        received_machine = nil\n\n        if !instance\n          instance = new_provider_mock\n        end",
    "comment": "This is a helper that generates a test for provider initialization. This is a separate helper method because it takes a block that can be used to have additional tests on the received machine.  @yield [machine] Yields the machine that the provider initialization method received so you can run additional tests on it.",
    "label": "",
    "id": "1223"
  },
  {
    "raw_code": "def register_provider(name, config_class=nil, options=nil)\n    provider_cls = Class.new(VagrantTests::DummyProvider) do\n      if options && options[:unusable]\n        def self.usable?(raise_error=false)\n          raise Vagrant::Errors::VagrantError if raise_error\n          false\n        end\n      end",
    "comment": "A helper to register a provider for use in tests.",
    "label": "",
    "id": "1224"
  },
  {
    "raw_code": "def test_loader.finalize(obj)\n        obj[:finalized] = true\n        obj\n      end",
    "comment": "Create the finalize method on our loader",
    "label": "",
    "id": "1225"
  },
  {
    "raw_code": "def appender_proc(data)\n    result = Proc.new { |env| env[:data] << data }\n\n    # Define a to_s on it for helpful output\n    result.define_singleton_method(:to_s) do\n      \"<Appender: #{data}>\"\n    end",
    "comment": "This returns a proc that can be used with the builder that simply appends data to an array in the env.",
    "label": "",
    "id": "1226"
  },
  {
    "raw_code": "def appender_proc(data)\n    Proc.new { |env| env[:data] << data }\n  end",
    "comment": "This returns a proc that can be used with the builder that simply appends data to an array in the env.",
    "label": "",
    "id": "1227"
  },
  {
    "raw_code": "def checksum(path)\n    FileChecksum.new(path, Digest::SHA1).checksum\n  end",
    "comment": "Helper to quickly SHA1 checksum a path",
    "label": "",
    "id": "1228"
  },
  {
    "raw_code": "def file(name, contents)\n      @workdir.join(name).open(\"w+\") do |f|\n        f.write(contents)\n      end",
    "comment": "This creates a file in the isolated environment. By default this file will be created in the working directory of the isolated environment.",
    "label": "",
    "id": "1229"
  },
  {
    "raw_code": "def box2(name, provider, options=nil)\n      # Default options\n      options = {\n        vagrantfile: \"\"\n      }.merge(options || {})\n\n      # Make the box directory\n      box_dir = boxes_dir.join(name, provider.to_s)\n      box_dir.mkpath\n\n      # Create a metadata.json file\n      box_metadata_file = box_dir.join(\"metadata.json\")\n      box_metadata_file.open(\"w\") do |f|\n        f.write(JSON.generate({\n          provider: provider.to_s\n        }))\n      end",
    "comment": "Creates a fake box to exist in this environment.  @param [String] name Name of the box @param [Symbol] provider Provider the box was built for. @return [Pathname] Path to the box directory.",
    "label": "",
    "id": "1230"
  },
  {
    "raw_code": "def box3(name, version, provider, **opts)\n      args = [name, version]\n      args << opts[:architecture].to_s if opts[:architecture]\n      args << provider.to_s\n\n      # Create the directory for the box\n      box_dir = boxes_dir.join(*args)\n      box_dir.mkpath\n\n      # Create the metadata.json for it\n      box_metadata_file = box_dir.join(\"metadata.json\")\n      box_metadata_file.open(\"w\") do |f|\n        f.write(JSON.generate({\n          provider: provider.to_s\n        }))\n      end",
    "comment": "Creates a fake box to exist in this environment according to the \"gen-3\" box format.  @param [String] name @param [String] version @param [String] provider @return [Pathname]",
    "label": "",
    "id": "1231"
  },
  {
    "raw_code": "def box1_file\n      # Create a temporary directory to store our data we will tar up\n      td_source = Dir.mktmpdir(\"vagrant-box1-source\")\n      td_dest   = Dir.mktmpdir(\"vagrant-box-1-dest\")\n\n      # Store the temporary directory so it is not deleted until\n      # this instance is garbage collected.\n      @_box2_file_temp ||= []\n      @_box2_file_temp << td_dest\n\n      # The source as a Pathname, which is easier to work with\n      source = Pathname.new(td_source)\n\n      # The destination file\n      result = Pathname.new(td_dest).join(\"temporary.box\")\n\n      # Put a \"box.ovf\" in there.\n      source.join(\"box.ovf\").open(\"w\") do |f|\n        f.write(\"FOO!\")\n      end",
    "comment": "This creates a \"box\" file that is a valid V1 box.  @return [Pathname] Path to the newly created box.",
    "label": "",
    "id": "1232"
  },
  {
    "raw_code": "def box2_file(provider, options=nil)\n      options ||= {}\n\n      # This is the metadata we want to store in our file\n      metadata = {\n        \"type\"     => \"v2_box\",\n        \"provider\" => provider\n      }.merge(options[:metadata] || {})\n\n      # Create a temporary directory to store our data we will tar up\n      td_source = Dir.mktmpdir(\"vagrant-box-2-source\")\n      td_dest   = Dir.mktmpdir(\"vagrant-box-2-dest\")\n\n      # Store the temporary directory so it is not deleted until\n      # this instance is garbage collected.\n      @_box2_file_temp ||= []\n      @_box2_file_temp << td_dest\n\n      # The source as a Pathname, which is easier to work with\n      source = Pathname.new(td_source)\n\n      # The destination file\n      result = Pathname.new(td_dest).join(\"temporary.box\")\n\n      # Put the metadata.json in here.\n      source.join(\"metadata.json\").open(\"w\") do |f|\n        f.write(JSON.generate(metadata))\n      end",
    "comment": "This creates a \"box\" file with the given provider.  @param [Symbol] provider Provider for the box. @return [Pathname] Path to the newly created box.",
    "label": "",
    "id": "1233"
  },
  {
    "raw_code": "def impl(usable, name)\n    Class.new(Vagrant.plugin(\"2\", :synced_folder)) do\n      define_method(:name) do\n        name\n      end",
    "comment": "This creates a synced folder implementation.",
    "label": "",
    "id": "1234"
  },
  {
    "raw_code": "def isolated_environment\n    env = Unit::IsolatedEnvironment.new\n    yield env if block_given?\n    env\n  end",
    "comment": "This creates an isolated environment so that Vagrant doesn't muck around with your real system during unit tests.  The returned isolated environment has a variety of helper methods on it to easily create files, Vagrantfiles, boxes, etc.",
    "label": "",
    "id": "1235"
  },
  {
    "raw_code": "def register_plugin(version=nil)\n    version ||= Vagrant::Config::CURRENT_VERSION\n    plugin = Class.new(Vagrant.plugin(version))\n    plugin.name(\"Test Plugin #{plugin.inspect}\")\n    yield plugin if block_given?\n    @_plugins << plugin\n    plugin\n  end",
    "comment": "This registers a Vagrant plugin for the duration of a single test. This will yield a new plugin class that you can then call the public plugin methods on.  @yield [plugin] Yields the plugin class for you to call the public API that you need to.",
    "label": "",
    "id": "1236"
  },
  {
    "raw_code": "def temporary_file(contents=nil)\n    dir = temporary_dir\n    f = dir.join(\"tempfile\")\n\n    contents ||= \"\"\n    f.open(\"w\") do |f|\n      f.write(contents)\n      f.flush\n    end",
    "comment": "This helper creates a temporary file and returns a Pathname object pointed to it.  @return [Pathname]",
    "label": "",
    "id": "1237"
  },
  {
    "raw_code": "def temporary_dir\n    # Create a temporary directory and append it to the instance\n    # variable so that it isn't garbage collected and deleted\n    d = Dir.mktmpdir(\"vagrant-temporary-dir\")\n    @_temp_files ||= []\n    @_temp_files << d\n\n    # Return the pathname\n    result = Pathname.new(Vagrant::Util::Platform.fs_real_path(d))\n    if block_given?\n      begin\n        yield result\n      ensure\n        FileUtils.rm_rf(result)\n      end",
    "comment": "This creates a temporary directory and returns a {Pathname} pointing to it. If a block is given, the pathname is yielded and the temporary directory is removed at the end of the block.  @return [Pathname]",
    "label": "",
    "id": "1238"
  },
  {
    "raw_code": "def stub_env(hash)\n    allow(ENV).to receive(:[]).and_call_original\n\n    hash.each do |key, value|\n      v = value.nil? ? nil : value.to_s\n      allow(ENV).to receive(:[])\n        .with(key.to_s)\n        .and_return(v)\n    end",
    "comment": "Stub the given environment in ENV, without actually touching ENV. Keys and values are converted to strings because that's how the real ENV works.",
    "label": "",
    "id": "1239"
  },
  {
    "raw_code": "def with_temp_env(environment)\n    # Build up the new environment, preserving the old values so we\n    # can replace them back in later.\n    old_env = {}\n    environment.each do |key, value|\n      key          = key.to_s\n      old_env[key] = ENV[key]\n      ENV[key]     = value\n    end",
    "comment": "This helper provides temporary environmental variable changes.",
    "label": "",
    "id": "1240"
  },
  {
    "raw_code": "def with_random_port(&block)\n    ports = []\n\n    block.arity.times do\n      server = TCPServer.new('127.0.0.1', 0)\n      ports << server.addr[1]\n      server.close\n    end",
    "comment": "This helper provides a randomly available port(s) for each argument to the block.",
    "label": "",
    "id": "1241"
  },
  {
    "raw_code": "def subprocess_result(options={})\n    defaults = {exit_code: 0, stdout: \"\", stderr: \"\"}\n    double(\"subprocess_result\", defaults.merge(options))\n  end",
    "comment": "this is a helper that returns a duck type suitable from a system command execution; allows setting exit_code, stdout, and stderr in stubs.",
    "label": "",
    "id": "1242"
  },
  {
    "raw_code": "def initialize\n    @logger = Log4r::Logger.new(\"test::isolated_environment\")\n\n    # Create a temporary directory for our work\n    @tempdir = Vagrant::Util::Platform.fs_real_path(Dir.mktmpdir(\"vagrant-iso-env\"))\n    @logger.info(\"Initialize isolated environment: #{@tempdir}\")\n\n    # Setup the home and working directories\n    @homedir = Pathname.new(File.join(@tempdir, \"home\"))\n    @workdir = Pathname.new(File.join(@tempdir, \"work\"))\n\n    @homedir.mkdir\n    @workdir.mkdir\n  end",
    "comment": "Initializes an isolated environment. You can pass in some options here to configure running custom applications in place of others as well as specifying environmental variables.  @param [Hash] apps A mapping of application name (such as \"vagrant\") to an alternate full path to the binary to run. @param [Hash] env Additional environmental variables to inject into the execution environments.",
    "label": "",
    "id": "1243"
  },
  {
    "raw_code": "def close\n    @logger.info(\"Removing isolated environment: #{@tempdir}\")\n    FileUtils.rm_rf(@tempdir)\n  end",
    "comment": "This closes the environment by cleaning it up.",
    "label": "",
    "id": "1244"
  }
]