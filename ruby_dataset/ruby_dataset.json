[
  {
    "raw_code": "def notify_review_rubric_change(defn)\n    @body = defn[:body]\n    @answers = defn[:body][:answers]\n    @name = defn[:body][:name]\n    @assignment_name = defn[:body][:assignment_name]\n    if Rails.env.development? || Rails.env.test?\n      defn[:to] = 'expertiza.mailer@gmail.com'\n    end",
    "comment": "Email about a review rubric being changed. If this is successful, then the answers are deleted for a user's response",
    "label": "what",
    "id": "1"
  },
  {
    "raw_code": "def edit(_count)\n    html = '<tr>'\n    html += '<td align=\"center\"><a rel=\"nofollow\" data-method=\"delete\" href=\"/questions/' + id.to_s + '\">Remove</a></td>'\n    html += '<td><input size=\"6\" value=\"' + seq.to_s + '\" name=\"question[' + id.to_s + '][seq]\" id=\"question_' + id.to_s\n    html += '_seq\" type=\"text\"></td><td><textarea cols=\"50\" rows=\"1\" name=\"question[' + id.to_s + '][txt]\" id=\"question_' + id.to_s\n    html += '_txt\" placeholder=\"Edit question content here\">' + txt + '</textarea></td>'\n    html += '<td><input size=\"10\" disabled=\"disabled\" value=\"' + type + '\" name=\"question[' + id.to_s\n    html += '][type]\" id=\"question_' + id.to_s + '_type\" type=\"text\"></td>'\n    html += '<td><input size=\"2\" value=\"' + weight.to_s + '\" name=\"question[' + id.to_s\n    html += '][weight]\" id=\"question_' + id.to_s + '_weight\" type=\"text\"></td>'\n    html += '<td> max_label <input size=\"10\" value=\"' + max_label.to_s + '\" name=\"question[' + id.to_s + '][max_label]\" id=\"question_' + id.to_s\n    html += '_max_label\" type=\"text\">  min_label <input size=\"12\" value=\"' + min_label.to_s + '\" name=\"question[' + id.to_s\n    html += '][min_label]\" id=\"question_' + id.to_s + '_min_label\" type=\"text\"></td>'\n    html += '</tr>'\n\n    html.html_safe\n  end",
    "comment": "This method returns what to display if an instructor (etc.) is creating or editing a questionnaire (questionnaires_controller.rb)",
    "label": "what",
    "id": "2"
  },
  {
    "raw_code": "def view_question_text\n    html = '<TR><TD align=\"left\"> ' + txt + ' </TD>'\n    html += '<TD align=\"left\">' + type + '</TD>'\n    html += '<td align=\"center\">' + weight.to_s + '</TD>'\n    questionnaire = self.questionnaire\n    if max_label.nil? || min_label.nil?\n      html += '<TD align=\"center\">' + questionnaire.min_question_score.to_s + ' to ' + questionnaire.max_question_score.to_s + '</TD>'\n    else\n      html += '<TD align=\"center\"> (' + min_label + ') ' + questionnaire.min_question_score.to_s + ' to '\n      html += questionnaire.max_question_score.to_s + ' (' + max_label + ')</TD>'\n    end",
    "comment": "This method returns what to display if an instructor (etc.) is viewing a questionnaire",
    "label": "what",
    "id": "3"
  },
  {
    "raw_code": "def candidate_topics_to_review(reviewer)\n    return nil if sign_up_topics.empty? # This is not a topic assignment\n\n    # Initialize contributor set with all teams participating in this assignment\n    contributor_set = Array.new(contributors)\n\n    # Reject contributors that have not selected a topic, or have no submissions\n    contributor_set = reject_by_no_topic_selection_or_no_submission(contributor_set)\n\n    # Reject contributions of topics whose deadline has passed, or which are not reviewable in the current stage\n    contributor_set = reject_by_deadline(contributor_set)\n\n    # Filter submissions already reviewed by reviewer\n    contributor_set = reject_previously_reviewed_submissions(contributor_set, reviewer)\n\n    # Filter submission by reviewer him/her self\n    contributor_set = reject_own_submission(contributor_set, reviewer)\n\n    # Filter the contributors with the least number of reviews\n    # (using the fact that each contributor is associated with a topic)\n    contributor_set = reject_by_least_reviewed(contributor_set)\n\n    contributor_set = reject_by_max_reviews_per_submission(contributor_set)\n\n    # if this assignment does not allow reviewer to review other artifacts on the same topic,\n    # remove those teams from candidate list.\n    contributor_set = reject_by_same_topic(contributor_set, reviewer) unless can_review_same_topic?\n\n    # Add topics for all remaining submissions to a list of available topics for review\n    candidate_topics = Set.new\n    contributor_set.each do |contributor|\n      candidate_topics.add(signed_up_topic(contributor))\n    end",
    "comment": "Returns a set of topics that can be reviewed. We choose the topics if one of its submissions has received the fewest reviews so far reviewer, the parameter, is an object of Participant",
    "label": "what",
    "id": "4"
  },
  {
    "raw_code": "def candidate_assignment_teams_to_review(reviewer)\n    # the contributors are AssignmentTeam objects\n    contributor_set = Array.new(contributors)\n\n    # Reject contributors that have no submissions\n    contributor_set.select!(&:has_submissions?)\n\n    # Filter submissions already reviewed by reviewer\n    contributor_set = reject_previously_reviewed_submissions(contributor_set, reviewer)\n\n    # Filter submission by reviewer him/her self\n    contributor_set = reject_own_submission(contributor_set, reviewer)\n\n    # Filter the contributors with the least number of reviews\n    contributor_set = reject_by_least_reviewed(contributor_set)\n\n    contributor_set = reject_by_max_reviews_per_submission(contributor_set)\n\n    contributor_set\n  end",
    "comment": "This method is only for the assignments without topics",
    "label": "what",
    "id": "5"
  },
  {
    "raw_code": "def assign_reviewer_dynamically_no_topic(reviewer, assignment_team)\n    raise 'There are no more submissions available for that review right now. Try again later.' if assignment_team.nil?\n\n    assignment_team.assign_reviewer(reviewer)\n  end",
    "comment": "assign the reviewer to review the assignment_team's submission. Only used in the assignments that do not have any topic Parameter assignment_team is the candidate assignment team, it cannot be a team w/o submission, or have reviewed by reviewer, or reviewer's own team. (guaranteed by candidate_assignment_teams_to_review method)",
    "label": "what",
    "id": "6"
  },
  {
    "raw_code": "def contributor_to_review(reviewer, topic)\n    raise 'Please select a topic' if topics? && topic.nil?\n    raise 'This assignment does not have topics' if !topics? && topic\n    # This condition might happen if the reviewer waited too much time in the\n    # select topic page and other students have already selected this topic.\n    # Another scenario is someone that deliberately modifies the view.\n    raise 'This topic has too many reviews; please select another one.' if topic && !candidate_topics_to_review(reviewer).include?(topic)\n\n    contributor_set = Array.new(contributors)\n    work = topic.nil? ? 'assignment' : 'topic'\n\n    # 1) Only consider contributors that worked on this topic; 2) remove reviewer as contributor\n    # 3) remove contributors that have not submitted work yet\n    contributor_set.reject! do |contributor|\n      signed_up_topic(contributor) != topic || # both will be nil for assignments with no signup sheet\n        contributor.includes?(reviewer) ||\n        !contributor.has_submissions?\n    end",
    "comment": "Returns a contributor to review if available, otherwise will raise an error",
    "label": "what",
    "id": "7"
  },
  {
    "raw_code": "def self.select_mentor(assignment_id)\n    mentor_user_id, = zip_mentors_with_team_count(assignment_id).first\n    User.where(id: mentor_user_id).first\n  end",
    "comment": "Select a mentor using the following algorithm  1) Find all assignment participants for the assignment with id [assignment_id] whose duty is the same as [Particpant#DUTY_MENTOR]. 2) Count the number of teams those participants are a part of, acting as a proxy for the number of teams they mentor. 3) Return the mentor with the fewest number of teams they're currently mentoring.  This method's runtime is O(n lg n) due to the call to Hash#sort_by. This assertion assumes that the database management system is capable of fetching the required rows at least as quickly.  Implementation detail: Any tie between the top 2 mentors is decided by the Hash#sort_by algorithm.  @return The id of the mentor with the fewest teams they are assigned to. Returns `nil` if there are no participants with mentor duty for [assignment_id].",
    "label": "what",
    "id": "8"
  },
  {
    "raw_code": "def self.assign_mentor(assignment_id, team_id)\n    assignment = Assignment.find(assignment_id)\n    team = Team.find(team_id)\n\n    # RuboCop 'use guard clause instead of nested conditionals'\n    # return if assignments can't accept mentors\n    return unless assignment.auto_assign_mentor\n\n    # RuboCop 'use guard clause instead of nested conditionals'\n    # return if the assignment or team already have a topic\n    return if assignment.topics? || !team.topic.nil?\n\n    curr_team_size = Team.size(team_id)\n    max_team_members = Assignment.find(assignment_id).max_team_size\n\n    # RuboCop 'use guard clause instead of nested conditionals'\n    # return if the team size hasn't reached > 50% of capacity\n    return if curr_team_size * 2 <= max_team_members\n\n    # RuboCop 'use guard clause instead of nested conditionals'\n    # return if there's already a mentor in place\n    return if team.participants.any? { |participant| participant.can_mentor == true }\n\n    mentor_user = select_mentor(assignment_id)\n\n    # Add the mentor using team model class.\n    team_member_added = mentor_user.nil? ? false : team.add_member(mentor_user, assignment_id)\n\n    return unless team_member_added\n\n    notify_team_of_mentor_assignment(mentor_user, team)\n    notify_mentor_of_assignment(mentor_user, team)\n  end",
    "comment": "= Mentor Management E2115: Handles calls when an assignment has the auto_assign_mentor flag enabled and triggered by the event when a new member joins an assignment team.  This event happens when: 1.) An invited student user accepts and successfully added to a team from app/models/invitation.rb 2.) A student user is successfully added to the team manually from app/controllers/teams_users_controller.rb.  This method will determine if a mentor needs to be assigned, if so, selects one, and adds the mentor to the team if: 1.) The assignment does not have a topic. 2.) If the team has reached >50% full capacity. 3.) If the team does not have a mentor.",
    "label": "what",
    "id": "9"
  },
  {
    "raw_code": "def self.user_a_mentor?(user)\n    Participant.exists?(user_id: user.id, can_mentor: true)\n  end",
    "comment": "Returns true if [user] is a mentor, and false if not.  [user] must be a User object.  Checks the Participant relation to see if a row exists with user_id == user.id that also has 'mentor' in the duty attribute.",
    "label": "what",
    "id": "10"
  },
  {
    "raw_code": "def self.mentors_for_assignment(assignment_id)\n    Participant.where(parent_id: assignment_id, can_mentor: true)\n  end",
    "comment": "Select all the participants who's duty in the participant table is [DUTY_MENTOR], and who are a participant of [assignment_id].  @see participant.rb for the value of DUTY_MENTOR",
    "label": "what",
    "id": "11"
  },
  {
    "raw_code": "def self.zip_mentors_with_team_count(assignment_id)\n    mentor_ids = mentors_for_assignment(assignment_id).pluck(:user_id)\n    return [] if mentor_ids.empty?\n    team_counts = {}\n    mentor_ids.each { |id| team_counts[id] = 0 }\n    #E2351 removed (:team_id) after .count to fix balancing algorithm\n    team_counts.update(TeamsUser\n    .joins(:team)\n    .where(teams: { parent_id: assignment_id })\n    .where(user_id: mentor_ids)\n    .group(:user_id)\n    .count)\n    team_counts.sort_by { |_, v| v }\n  end",
    "comment": "Produces a hash mapping mentor's user_ids to the aggregated number of teams they're part of, which acts as a proxy for the number of teams they're mentoring.",
    "label": "what",
    "id": "12"
  },
  {
    "raw_code": "def award_badge(participant_id, badge_name)\n    badge_id = Badge.get_id_from_name(badge_name: badge_name)\n    AwardedBadge.where(participant_id: participant_id, badge_id: badge_id, approval_status: 0).first_or_create\n  end",
    "comment": "E2218: This method is called when a badge is awarded to a participant This method is called from response controller",
    "label": "what",
    "id": "13"
  },
  {
    "raw_code": "def edit(count)\n    html = edit_remove_button(count) + edit_seq(count) + edit_question(count)\n    html += edit_type(count) + edit_weight(count)\n    safe_join(['<tr>'.html_safe, '</tr>'.html_safe], html.html_safe)\n  end",
    "comment": "This method returns what to display if an instructor (etc.) is creating or editing a questionnaire (questionnaires_controller.rb)",
    "label": "what",
    "id": "14"
  },
  {
    "raw_code": "def view_question_text\n    html = '<TR><TD align=\"left\"> ' + txt + ' </TD>'\n    html += '<TD align=\"left\">' + type + '</TD>'\n    html += '<td align=\"center\">' + weight.to_s + '</TD>'\n    html += '<TD align=\"center\">Checked/Unchecked</TD>'\n    html += '</TR>'\n    safe_join([''.html_safe, ''.html_safe], html.html_safe)\n  end",
    "comment": "This method returns what to display if an instructor (etc.) is viewing a questionnaire",
    "label": "what",
    "id": "15"
  },
  {
    "raw_code": "def view_completed_question(count, answer)\n    html = check_previous_question\n    html += view_completed_question_answer(count, answer)\n    html += view_completed_question_if_column_header\n    safe_join([''.html_safe, ''.html_safe], html.html_safe)\n  end",
    "comment": "This method returns what to display if a student is viewing a filled-out questionnaire",
    "label": "what",
    "id": "16"
  },
  {
    "raw_code": "def self.assign_review_topics(assignment_id, reviewer_ids, matched_topics, _min_num_reviews = 2)\n    # if review response map already created, delete it\n    if ReviewResponseMap.where(reviewed_object_id: assignment_id)\n      ReviewResponseMap.where(reviewed_object_id: assignment_id).destroy_all\n    end",
    "comment": "assigns topics to reviews as matched by the webservice algorithm",
    "label": "what",
    "id": "17"
  },
  {
    "raw_code": "def self.assign_topic_to_reviewer(assignment_id, reviewer_id, topic)\n    team_to_review = SignedUpTeam.where(topic_id: topic).pluck(:team_id).first\n    team_to_review.nil? ? [] : ReviewResponseMap.create(reviewed_object_id: assignment_id, reviewer_id: reviewer_id, reviewee_id: team_to_review, type: 'ReviewResponseMap')\n  end",
    "comment": "method to assign a single topic to a reviewer",
    "label": "what",
    "id": "18"
  },
  {
    "raw_code": "def self.reviewer_bidding_data(reviewer_id, assignment_id)\n    reviewer_user_id = AssignmentParticipant.find(reviewer_id).user_id\n    self_topic = SignedUpTeam.topic_id(assignment_id, reviewer_user_id)\n    bidding_data = { 'tid' => [], 'otid' => self_topic, 'priority' => [], 'time' => [] }\n    bids = ReviewBid.where(participant_id: reviewer_id)\n\n    # loop through each bid for a topic to get specific data\n    bids.each do |bid|\n      bidding_data['tid'] << bid.signuptopic_id\n      bidding_data['priority'] << bid.priority\n      bidding_data['time'] << bid.updated_at\n    end",
    "comment": "method for getting individual reviewer_ids bidding data returns user's bidding data hash",
    "label": "what",
    "id": "19"
  },
  {
    "raw_code": "def self.get(_sortvar = nil, _sortorder = nil, _user_id = nil, _show = nil, _parent_id = nil, _search = nil); end\n\n  # Retrieves the children of this node\n  def get_children(sortvar = nil, sortorder = nil, user_id = nil, show = nil, parent_id = nil, search = nil); end\n\n  # Retrieves the action partial for this node\n  def get_partial_name\n    self.class.table + '_actions'\n  end\n\n  # Most objects are not leaves\n  # Currently only assignment and questionnaire are a leaf\n  # type node\n  def is_leaf\n    false\n  end\n\n  # Retrieves the corresponding model for the\n  # node's object type\n  def self.table; end\n\n  # Retrieves the node's object name\n  def get_name; end\n\n  # Retrieves the node's object directory\n  def get_directory; end\n\n  # Retrieves the node's object create_at\n  def get_creation_date; end\n\n  # Retrieves the node's object create_at\n  def get_modified_date; end\n\n  # Retrieves the type of children this node has\n  def get_child_type; end\nend",
    "comment": "Retrieves the nodes of this type",
    "label": "what",
    "id": "20"
  },
  {
    "raw_code": "def can_be_assigned?(team)\n    max_members_for_duty > team.participants.select { |team_member| team_member.duty_id == id }.count\n  end",
    "comment": "E2147 : check if the duty selected is available for selection in that particular team. Checks whether current duty count in the team is less than the max_members_for_duty set for that particular duty",
    "label": "what",
    "id": "21"
  },
  {
    "raw_code": "def system_pages(pageid)\n    pages = []\n\n    pages << 'Site default page' if site_default_page_id == pageid\n    pages << 'Not found page' if not_found_page_id == pageid\n    pages << 'Permission denied page' if permission_denied_page_id == pageid\n    pages << 'Session expired page' if session_expired_page_id == pageid\n    pages unless pages.empty?\n  end",
    "comment": "Returns an array of system page settings for a given page, or nil if the page is not a system page.",
    "label": "what",
    "id": "22"
  },
  {
    "raw_code": "def self.remove_users_sent_invites_for_assignment(user_id, assignment_id)\n    invites = Invitation.where('from_id = ? and assignment_id = ?', user_id, assignment_id)\n    invites.each(&:destroy)\n  end",
    "comment": "Remove all invites sent by a user for an assignment.",
    "label": "what",
    "id": "23"
  },
  {
    "raw_code": "def self.update_users_topic_after_invite_accept(invitee_user_id, invited_user_id, assignment_id)\n    new_team_id = TeamsUser.team_id(assignment_id, invitee_user_id)\n    # check the invited_user_id have ever join other team in this assignment before\n    # if so, update the original record; else create a new record\n    original_team_id = TeamsUser.team_id(assignment_id, invited_user_id)\n    if original_team_id\n      # team_user_mapping = TeamsUser.where(team_id: original_team_id, user_id: invited_user_id).first\n      team_user_mapping = TeamsUser.find_by(team_id: original_team_id, user_id: invited_user_id)\n      TeamsUser.update(team_user_mapping.id, team_id: new_team_id)\n    else\n      TeamsUser.create(team_id: new_team_id, user_id: invited_user_id)\n    end",
    "comment": "After a users accepts an invite, the teams_users table needs to be updated.",
    "label": "what",
    "id": "24"
  },
  {
    "raw_code": "def self.accept_invitation(team_id, inviter_user_id, invited_user_id, assignment_id)\n    # if you are on a team and you accept another invitation and if your old team does not have any members, delete the entry for the team\n    if TeamsUser.team_empty?(team_id) && (team_id != '0')\n      assignment_id = AssignmentTeam.find(team_id).assignment.id\n      # Release topics for the team has selected by the invited users empty team\n      SignedUpTeam.release_topics_selected_by_team_for_assignment(team_id, assignment_id)\n      AssignmentTeam.remove_team_by_id(team_id)\n    end",
    "comment": "This method handles all that needs to be done upon a user accepting an invitation. First the users previous team is deleted if they were the only member of that team and topics that the old team signed up for will be deleted. Then invites the user that accepted the invite sent will be removed. Last the users team entry will be added to the TeamsUser table and their assigned topic is updated",
    "label": "what",
    "id": "25"
  },
  {
    "raw_code": "def self.export_fields(_options)\n    fields = []\n    QuestionAdvice.columns.each do |column|\n      fields.push(column.name)\n    end",
    "comment": "This method returns an array of fields present in question advice model",
    "label": "what",
    "id": "26"
  },
  {
    "raw_code": "def self.export(csv, parent_id, _options)\n    questionnaire = Questionnaire.find(parent_id)\n    questions = questionnaire.questions\n    questions.each do |question|\n      question_advices = QuestionAdvice.where('question_id = ?', question.id)\n      question_advices.each do |advice|\n        tcsv = []\n        advice.attributes.each_pair do |_name, value|\n          tcsv.push(value)\n        end",
    "comment": "This method adds the question advice data to CSV for the respective questionnaire",
    "label": "what",
    "id": "27"
  },
  {
    "raw_code": "def self.get_my_instructor(user_id)\n    course_id = TaMapping.get_course_id(user_id)\n    Course.find(course_id).instructor_id\n  end",
    "comment": "This method is potentially problematic: it assumes one TA only help teach one course. This method only returns the instructor_id for the 1st course that this user help teach.  -Yang Oct. 05 2015",
    "label": "what",
    "id": "28"
  },
  {
    "raw_code": "def self.get_my_instructors(user_id)\n    ta_mappings = TaMapping.where(ta_id: user_id)\n    if ta_mappings.empty?\n      []\n    else\n      instructor_ids = []\n      ta_mappings.each do |ta_mapping|\n        course_id = ta_mapping.course_id\n        instructor_ids << Course.find(course_id).instructor_id\n      end",
    "comment": "This method should be used to replace the \"get_my_instructor\" method",
    "label": "what",
    "id": "29"
  },
  {
    "raw_code": "def edit(_count)\n    html = '<td align=\"center\"><a rel=\"nofollow\" data-method=\"delete\" href=\"/questions/' + id.to_s + '\">Remove</a></td>'\n\n    html += '<td><input size=\"6\" value=\"' + seq.to_s + '\" name=\"question[' + id.to_s + '][seq]\"'\n    html += ' id=\"question_' + id.to_s + '_seq\" type=\"text\"></td>'\n\n    html += '<td><textarea cols=\"50\" rows=\"1\" name=\"question[' + id.to_s + '][txt]\"'\n    html += ' id=\"question_' + id.to_s + '_txt\" placeholder=\"Edit question content here\">' + txt + '</textarea></td>'\n\n    html += '<td><input size=\"10\" disabled=\"disabled\" value=\"' + type + '\" name=\"question[' + id.to_s + '][type]\"'\n    html += ' id=\"question_' + id.to_s + '_type\" type=\"text\"></td>'\n\n    html += '<td><input size=\"2\" value=\"' + weight.to_s\n    html += '\" name=\"question[' + id.to_s + '][weight]\" id=\"question_' + id.to_s + '_weight\" type=\"text\"></td>'\n\n    html += '<td>text area size <input size=\"3\" value=\"' + size.to_s\n    html += '\" name=\"question[' + id.to_s + '][size]\" id=\"question_' + id.to_s + '_size\" type=\"text\"></td>'\n\n    html += '<td> min_label <input size=\"12\" value=\"' + min_label.to_s\n    html += '\" name=\"question[' + id.to_s + '][min_label]\" id=\"question_' + id.to_s + '_min_label\" type=\"text\">  max_label <input size=\"10\" value=\"' + max_label.to_s + '\" name=\"question[' + id.to_s\n    html += '][max_label]\" id=\"question_' + id.to_s + '_max_label\" type=\"text\"></td>'\n\n    safe_join(['<tr>'.html_safe, '</tr>'.html_safe], html.html_safe)\n  end",
    "comment": "This method returns what to display if an instructor (etc.) is creating or editing a questionnaire (questionnaires_controller.rb)",
    "label": "what",
    "id": "30"
  },
  {
    "raw_code": "def view_question_text\n    html = '<TD align=\"left\"> ' + txt + ' </TD>'\n    html += '<TD align=\"left\">' + type + '</TD>'\n    html += '<td align=\"center\">' + weight.to_s + '</TD>'\n    questionnaire = self.questionnaire\n    if !max_label.nil? && !min_label.nil?\n      html += '<TD align=\"center\"> (' + min_label + ') ' + questionnaire.min_question_score.to_s\n      html += ' to ' + questionnaire.max_question_score.to_s + ' (' + max_label + ')</TD>'\n    else\n      html += '<TD align=\"center\">' + questionnaire.min_question_score.to_s + ' to ' + questionnaire.max_question_score.to_s + '</TD>'\n    end",
    "comment": "This method returns what to display if an instructor (etc.) is viewing a questionnaire",
    "label": "what",
    "id": "31"
  },
  {
    "raw_code": "def complete(count, answer = nil, questionnaire_min, questionnaire_max, dropdown_or_scale)\n    html = '<div><label for=\"responses_' + count.to_s + '\">' + txt + '</label></div>'\n    question_advices = QuestionAdvice.where(question_id: id).sort_by(&:id)\n    advice_total_length = 0\n    question_advices.each do |question_advice|\n      advice_total_length += question_advice.advice.length if question_advice.advice && question_advice.advice != ''\n    end",
    "comment": "Reduced the number of lines. Removed some redundant if-else statements, and combined some HTML concatenations. Display for the students when they are filling the questionnaire",
    "label": "what",
    "id": "32"
  },
  {
    "raw_code": "def advices_criterion_question(count, question_advices)\n    html = '<a id=\"showAdvice_' + id.to_s + '\" onclick=\"showAdvice(' + id.to_s + ')\">Show advice</a><script>'\n    html += 'function showAdvice(i){var element = document.getElementById(\"showAdvice_\" + i.toString());'\n    html += 'var show = element.innerHTML == \"Hide advice\";'\n    html += 'if (show){element.innerHTML=\"Show advice\";} else{element.innerHTML=\"Hide advice\";}toggleAdvice(i);}'\n    html += 'function toggleAdvice(i) {var elem = document.getElementById(i.toString() + \"_myDiv\");'\n    html += 'if (elem.style.display == \"none\") {elem.style.display = \"\";} else {elem.style.display = \"none\";}}</script>'\n    html += '<div id=\"' + id.to_s + '_myDiv\" style=\"display: none;\">'\n    # [2015-10-26] Zhewei:\n    # best to order advices high to low, e.g., 5 to 1\n    # each level used to be a link;\n    # clicking on the link caused the dropbox to be filled in with the corresponding number\n    question_advices.reverse.each_with_index do |question_advice, index|\n      html += '<a id=\"changeScore_>' + id.to_s + '\" onclick=\"changeScore(' + count.to_s + ',' + index.to_s + ')\">'\n      html += (questionnaire.max_question_score - index).to_s + ' - ' + question_advice.advice + '</a><br/><script>'\n      html += 'function changeScore(i, j) {var elem = jQuery(\"#responses_\" + i.toString() + \"_score\");'\n      html += 'var opts = elem.children(\"option\").length;'\n      html += 'elem.val((' + questionnaire.max_question_score.to_s + ' - j).toString());}</script>'\n    end",
    "comment": "show advice for each criterion question",
    "label": "what",
    "id": "33"
  },
  {
    "raw_code": "def dropdown_criterion_question(count, answer = nil, questionnaire_min, questionnaire_max)\n    current_value = ''\n    current_value += 'data-current-rating =' + answer.answer.to_s unless answer.nil?\n    html = '<div><select id=\"responses_' + count.to_s + '_score\" name=\"responses[' + count.to_s + '][score]\" class=\"review-rating\" ' + current_value + '>'\n    html += \"<option value = ''>--</option>\"\n    questionnaire_min.upto(questionnaire_max).each do |j|\n      html += '<option value=' + j.to_s\n      html += ' selected=\"selected\"' if !answer.nil? && j == answer.answer\n      html += '>' + j.to_s\n      html += '-' + min_label if min_label.present? && j == questionnaire_min\n      html += '-' + max_label if max_label.present? && j == questionnaire_max\n      html += '</option>'\n    end",
    "comment": "dropdown options to rate a project based on the question",
    "label": "what",
    "id": "34"
  },
  {
    "raw_code": "def scale_criterion_question(count, answer = nil, questionnaire_min, questionnaire_max)\n    if size.nil? || size.blank?\n      cols = '70'\n      rows = '1'\n    else\n      cols = size.split(',')[0]\n      rows = size.split(',')[1]\n    end",
    "comment": "scale options to rate a project based on the question",
    "label": "what",
    "id": "35"
  },
  {
    "raw_code": "def view_completed_question(count, answer, questionnaire_max, tag_prompt_deployments = nil, current_user = nil)\n    html = '<b>' + count.to_s + '. ' + txt + ' [Max points: ' + questionnaire_max.to_s + ']</b>'\n    score = answer && !answer.answer.nil? ? answer.answer.to_s : '-'\n    score_percent = score != '-' ? answer.answer * 1.0 / questionnaire_max : 0\n    score_color = if score_percent > 0.8\n                    'c5'\n                  elsif score_percent > 0.6\n                    'c4'\n                  elsif score_percent > 0.4\n                    'c3'\n                  elsif score_percent > 0.2\n                    'c2'\n                  else\n                    'c1'\n                  end",
    "comment": "This method returns what to display if a student is viewing a filled-out questionnaire",
    "label": "what",
    "id": "36"
  },
  {
    "raw_code": "def get_instructor_id\n    Questionnaire.find_by(id: node_object_id).try(:instructor_id)\n  end",
    "comment": "this method return instructor id associated with a questionnaire expects no arguments returns int",
    "label": "what",
    "id": "37"
  },
  {
    "raw_code": "def valid_url?(url)\n      /^#{URI::DEFAULT_PARSER.make_regexp}$/.match(url)\n    end",
    "comment": "IP addresses and local URLs will not match, must include http(s)",
    "label": "what",
    "id": "38"
  },
  {
    "raw_code": "def self.check_policy_with_same_name(late_policy_name, instructor_id)\n    @policy = LatePolicy.where(policy_name: late_policy_name)\n    if @policy.present?\n      @policy.each do |p|\n        return true if p.instructor_id == instructor_id\n      end",
    "comment": "method to check whether the policy name given as a parameter already exists under the current instructor id it return true if there's another policy with the same name under current instructor else false",
    "label": "what",
    "id": "39"
  },
  {
    "raw_code": "def self.update_calculated_penalty_objects(late_policy)\n    @penalty_objs = CalculatedPenalty.all\n    @penalty_objs.each do |pen|\n      @participant = AssignmentParticipant.find(pen.participant_id)\n      @assignment = @participant.assignment\n      next unless @assignment.late_policy_id == late_policy.id\n\n      @penalties = calculate_penalty(pen.participant_id)\n      @total_penalty = (@penalties[:submission] + @penalties[:review] + @penalties[:meta_review])\n      if pen.deadline_type_id.to_i == 1\n        # pen.update_attribute(:penalty_points, @penalties[:submission])\n        pen.update(penalty_points: @penalties[:submission])\n      elsif pen.deadline_type_id.to_i == 2\n        # pen.update_attribute(:penalty_points, @penalties[:review])\n        pen.update(penalty_points: @penalties[:review])\n      elsif pen.deadline_type_id.to_i == 5\n        # pen.update_attribute(:penalty_points, @penalties[:meta_review])\n        pen.update(penalty_points: @penalties[:meta_review])\n      end",
    "comment": "this method updates all the penalty objects which uses the late policy which is passed as a parameter whenever a policy is updated, all the existing penalty objects needs to be updated according to new policy",
    "label": "what",
    "id": "40"
  },
  {
    "raw_code": "def edit(_count)\n    html = '<tr>'\n    html += '<td align=\"center\"><a rel=\"nofollow\" data-method=\"delete\" href=\"/questions/' + id.to_s + '\">Remove</a></td>'\n    html += '<td><input size=\"6\" value=\"' + seq.to_s + '\" name=\"question[' + id.to_s + '][seq]\" id=\"question_' + id.to_s + '_seq\" type=\"text\"></td>'\n    html += '<td><textarea cols=\"50\" rows=\"1\" name=\"question[' + id.to_s + '][txt]\" id=\"question_' + id.to_s + '_txt\" placeholder=\"Edit question content here\">' + txt + '</textarea></td>'\n    html += '<td><input size=\"10\" disabled=\"disabled\" value=\"' + type + '\" name=\"question[' + id.to_s + '][type]\" id=\"question_' + id.to_s + '_type\" type=\"text\"></td>'\n    html += '<td><!--placeholder (UploadFile does not need weight)--></td>'\n    html += '</tr>'\n\n    html.html_safe\n  end",
    "comment": "This method returns what to display if an instructor (etc.) is creating or editing a questionnaire (questionnaires_controller.rb)",
    "label": "what",
    "id": "41"
  },
  {
    "raw_code": "def view_question_text\n    html = '<TR><TD align=\"left\"> ' + txt + ' </TD>'\n    html += '<TD align=\"left\">' + type + '</TD>'\n    html += '<td align=\"center\">' + weight.to_s + '</TD>'\n    html += '<TD align=\"center\">&mdash;</TD>'\n    html += '</TR>'\n    html.html_safe\n  end",
    "comment": "This method returns what to display if an instructor (etc.) is viewing a questionnaire",
    "label": "what",
    "id": "42"
  },
  {
    "raw_code": "def self.get_lock(lockable, user, timeout)\n    return nil if lockable.nil? || user.nil?\n\n    lock = find_by(lockable: lockable)\n    return create_lock(lockable, user, timeout) if lock.nil?\n\n    # We need to put an actual database lock on this object to prevent concurrent acquisition of this object\n    # If two users were to request a lock at the same time, they might otherwise be able to acquire this lock simultaneously\n    lock.with_lock do\n      # If the timeout period is up, the lock is fair game\n      if lock.created_at + lock.timeout_period.minutes <= DateTime.now\n        lock.destroy\n        return create_lock(lockable, user, timeout)\n      end",
    "comment": "Requests a lock on the given resource for the given user Since resources can be of any class, the class name for the resource must be provided Return the resource if it's available or nil if it is not Automatically handles creating/destroying locks and timeout periods However, once a user is done with a lock, it is their responsibility to destroy it by using Lock.unlock",
    "label": "what",
    "id": "43"
  },
  {
    "raw_code": "def self.lock_between?(lockable, user)\n    lock = find_by(lockable_id: lockable.id, user_id: user.id)\n    if lock.nil?\n      return false\n    else\n      lock.destroy\n      create_lock(lockable, user, lock.timeout_period)\n      return true\n    end",
    "comment": "Checks to see if there exists a lock between the given resource and user If I am a user who uses a resource for so long that the timeout period has passed AND another user has locked, modified, and unlocked the resource, I do NOT want to modify the resource even though it may be unlocked. This method should always be checked before any database changes are made. It should be noted that this will return true even after the timeout period has passed. Since this method is for doing safety checks, if no one else has acquired the lock, it's okay to make edits. This method will also renew the timeout period on the lock to avoid race conditions",
    "label": "what",
    "id": "44"
  },
  {
    "raw_code": "def self.release_lock(lockable)\n    return if lockable.nil?\n\n    lock = find_by(lockable: lockable)\n    Lock.where(lockable: lockable).destroy_all unless lock.nil?\n  end",
    "comment": "Destroys the lock on the given resource by the given user (if it exists)",
    "label": "what",
    "id": "45"
  },
  {
    "raw_code": "def self.create_lock(lockable, user, timeout)\n    # This method is still a potential location for a race condition.\n    # Unfortunately, database locks can't be created for nonexistent entries.\n    # This was the way I found online avoid the race condition but I'm not sure exactly how it works\n    transaction do\n      lock = Lock.new(lockable: lockable, user: user, timeout_period: timeout)\n      lock.save!\n      return lockable\n    end",
    "comment": "Just a little helper method to help keep this code DRY If for some reason, the lock had trouble being created, returns nil because there is no lock on the object",
    "label": "what",
    "id": "46"
  },
  {
    "raw_code": "def self.create_course_node(course)\n    parent_id = CourseNode.get_parent_id\n    @course_node = CourseNode.new\n    @course_node.node_object_id = course.id\n    @course_node.parent_id = parent_id if parent_id\n    @course_node.save\n  end",
    "comment": "Creates a new courese node from the given course",
    "label": "what",
    "id": "47"
  },
  {
    "raw_code": "def self.table\n    'courses'\n  end",
    "comment": "Returns the table in which to locate Courses",
    "label": "what",
    "id": "48"
  },
  {
    "raw_code": "def self.get(_sortvar = 'name', _sortorder = 'desc', user_id = nil, show = nil, _parent_id = nil, _search = nil)\n    sortvar = 'created_at'\n    if Course.column_names.include? sortvar\n      includes(:course).where([get_course_query_conditions(show, user_id), get_courses_managed_by_user(user_id)])\n                       .order(\"courses.#{sortvar} desc\")\n    end",
    "comment": "returns: list of CourseNodes based on query the get method will return all courses meeting the criteria, but the method name is necessary due to polymorphism",
    "label": "what",
    "id": "49"
  },
  {
    "raw_code": "def self.get_course_query_conditions(show = nil, user_id = nil)\n    current_user = User.find_by(id: user_id)\n    conditions = if show && current_user\n                   if current_user.teaching_assistant? == false\n                     \"courses.instructor_id = #{user_id}\"\n                   else\n                     'courses.id in (?)'\n                   end",
    "comment": "get the query conditions for a public course",
    "label": "what",
    "id": "50"
  },
  {
    "raw_code": "def self.get_courses_managed_by_user(user_id = nil)\n    current_user = User.find(user_id)\n    values = if current_user.teaching_assistant? == false\n               user_id\n             else\n               Ta.get_mapped_courses(user_id)\n             end",
    "comment": "get the courses managed by the user",
    "label": "what",
    "id": "51"
  },
  {
    "raw_code": "def self.get_parent_id\n    folder = TreeFolder.find_by(name: 'Courses')\n    parent = FolderNode.find_by(node_object_id: folder.id)\n    parent.id if parent\n  end",
    "comment": "get parent id",
    "label": "what",
    "id": "52"
  },
  {
    "raw_code": "def get_children(sortvar = nil, sortorder = nil, user_id = nil, show = nil, _parent_id = nil, search = nil)\n    AssignmentNode.get(sortvar, sortorder, user_id, show, node_object_id, search)\n  end",
    "comment": "Gets any children associated with this object the get_children method will return assignments belonging to a course, but the method name is necessary due to polymorphism",
    "label": "what",
    "id": "53"
  },
  {
    "raw_code": "def self.all_comparisons\n    full_url = @@base_uri + '/comparisons'\n    RestClient::Request.execute(method: :get,\n                                url: full_url,\n                                headers: { simicheck_api_key: @@api_key },\n                                verify_ssl: false)\n  end",
    "comment": " Comparison Operations  Lists all comparisons for the SimiCheck account Parameters: <none> Returns: response = RestClient::Response",
    "label": "what",
    "id": "54"
  },
  {
    "raw_code": "def self.new_comparison(comparison_name = '')\n    full_url = @@base_uri + '/comparison'\n    json_body = { comparison_name: comparison_name }.to_json\n    RestClient::Request.execute(method: :put,\n                                url: full_url,\n                                payload: json_body,\n                                headers:\n                                    {\n                                      simicheck_api_key: @@api_key,\n                                      content_type: :json,\n                                      accept: :json\n                                    },\n                                verify_ssl: false)\n  end",
    "comment": "Creates a new comparison Parameters: comparison_name (optional) - string containing the name for the new comparison (name will be date and time if not provided) Returns: response = RestClient::Response",
    "label": "what",
    "id": "55"
  },
  {
    "raw_code": "def self.delete_comparison(comparison_id)\n    full_url = @@base_uri + '/comparison/' + comparison_id\n    RestClient::Request.execute(method: :delete,\n                                url: full_url,\n                                headers: { simicheck_api_key: @@api_key },\n                                verify_ssl: false)\n  end",
    "comment": "Deletes a comparison Parameters: comparison_id - string id of the comparison to delete Returns: response = RestClient::Response (NO BODY)",
    "label": "what",
    "id": "56"
  },
  {
    "raw_code": "def self.get_comparison_details(comparison_id)\n    full_url = @@base_uri + '/comparison/' + comparison_id\n    RestClient::Request.execute(method: :get,\n                                url: full_url,\n                                headers: { simicheck_api_key: @@api_key },\n                                verify_ssl: false)\n  end",
    "comment": "Gets the details about a comparison Parameters: comparison_id - string id of the comparison to look up Returns: response = RestClient::Response",
    "label": "what",
    "id": "57"
  },
  {
    "raw_code": "def self.update_comparison(comparison_id, new_comparison_name)\n    full_url = @@base_uri + '/comparison/' + comparison_id\n    json_body = { comparison_name: new_comparison_name }.to_json\n    RestClient::Request.execute(method: :post,\n                                url: full_url,\n                                payload: json_body,\n                                headers:\n                                    {\n                                      simicheck_api_key: @@api_key,\n                                      content_type: :json,\n                                      accept: :json\n                                    },\n                                verify_ssl: false)\n  end",
    "comment": "Updates a comparison (currently only the name) Parameters: comparison_id - string id of the comparison to update new_comparison_name - string containing the new name for the comparison Returns: response = RestClient::Response (NO BODY)",
    "label": "what",
    "id": "58"
  },
  {
    "raw_code": "def self.upload_file(comparison_id, path_to_file)\n    full_url = @@base_uri + '/upload_file/' + comparison_id\n    file_to_upload = File.new(path_to_file, 'rb')\n    json_body = { 'file' => file_to_upload } # don't use .to_json!\n    RestClient::Request.execute(method: :put,\n                                url: full_url,\n                                payload: json_body,\n                                headers:\n                                    {\n                                      simicheck_api_key: @@api_key,\n                                      content_type: 'multipart/form-data',\n                                      accept: :json\n                                    },\n                                verify_ssl: false)\n  end",
    "comment": "Uploads a file Parameters: comparison_id - string id of the comparison to update path_to_file - string containing the path to the file being uploaded Returns: response = RestClient::Response",
    "label": "what",
    "id": "59"
  },
  {
    "raw_code": "def self.delete_files(comparison_id, filenames_to_delete)\n    full_url = @@base_uri + '/delete_files/' + comparison_id\n    json_body = { 'filenames' => filenames_to_delete }.to_json\n    RestClient::Request.execute(method: :post,\n                                url: full_url,\n                                payload: json_body,\n                                headers:\n                                    {\n                                      simicheck_api_key: @@api_key,\n                                      content_type: :json,\n                                      accept: :json\n                                    },\n                                verify_ssl: false)\n  end",
    "comment": "Deletes files from a comparison Parameters: comparison_id - string id of the comparison to update filenames_to_delete - array of strings containing filenames to be deleted Returns: response = RestClient::Response (NO BODY)",
    "label": "what",
    "id": "60"
  },
  {
    "raw_code": "def self.get_similarity_nxn(comparison_id)\n    full_url = @@base_uri + '/similarity_nxn/' + comparison_id\n    RestClient::Request.execute(method: :get,\n                                url: full_url,\n                                headers: { simicheck_api_key: @@api_key },\n                                verify_ssl: false)\n  end",
    "comment": "Gets the results of the similarity comparison Parameters: comparison_id - string id of the comparison to update Returns: response = RestClient::Response",
    "label": "what",
    "id": "61"
  },
  {
    "raw_code": "def self.post_similarity_nxn(comparison_id, callback_url = '')\n    full_url = @@base_uri + '/similarity_nxn/' + comparison_id\n    json_body = callback_url.empty? ? {}.to_json : { 'callback_url' => callback_url }.to_json\n    RestClient::Request.execute(method: :post,\n                                url: full_url,\n                                payload: json_body,\n                                headers:\n                                    {\n                                      simicheck_api_key: @@api_key,\n                                      content_type: :json,\n                                      accept: :json\n                                    },\n                                verify_ssl: false)\n  end",
    "comment": "Starts the computation of file similarity for a comparison Parameters: comparison_id - string id of the comparison to update Returns: response = RestClient::Response",
    "label": "what",
    "id": "62"
  },
  {
    "raw_code": "def self.get_similarity_1xn(comparison_id, filename)\n    full_url = @@base_uri + '/similarity_1xn/' + comparison_id\n    json_body = { 'filename' => filename }.to_json\n    RestClient::Request.execute(method: :get,\n                                url: full_url,\n                                payload: json_body,\n                                headers:\n                                    {\n                                      simicheck_api_key: @@api_key,\n                                      content_type: :json,\n                                      accept: :json\n                                    },\n                                verify_ssl: false)\n  end",
    "comment": "Gets the latest results for the similarity of one file wrt. all other files in a comparison",
    "label": "what",
    "id": "63"
  },
  {
    "raw_code": "def self.post_similarity_1xn(comparison_id, filename, callback_url = '')\n    full_url = @@base_uri + '/similarity_1xn/' + comparison_id\n    json_body = callback_url.empty? ? { 'filename' => filename }.to_json : { 'filename' => filename, 'callback_url' => callback_url }.to_json\n    RestClient::Request.execute(method: :post,\n                                url: full_url,\n                                payload: json_body,\n                                headers:\n                                    {\n                                      simicheck_api_key: @@api_key,\n                                      content_type: :json,\n                                      accept: :json\n                                    },\n                                verify_ssl: false)\n  end",
    "comment": "Finds the files in a comparison that are most similar to a given file",
    "label": "what",
    "id": "64"
  },
  {
    "raw_code": "def self.visualize_similarity(comparison_id)\n    full_url = @@base_uri + '/visualize_similarity/' + comparison_id\n    RestClient::Request.execute(method: :get,\n                                url: full_url,\n                                headers: { simicheck_api_key: @@api_key },\n                                verify_ssl: false)\n  end",
    "comment": "Gets the results of the similarity comparison",
    "label": "what",
    "id": "65"
  },
  {
    "raw_code": "def self.visualize_comparison(comparison_id, file_id1, file_id2)\n    full_url = @@base_uri + '/visualize_comparison/' + comparison_id + '/' + file_id1 + '/' + file_id2\n    RestClient::Request.execute(method: :get,\n                                url: full_url,\n                                headers: { simicheck_api_key: @@api_key },\n                                verify_ssl: false)\n  end",
    "comment": "Gets the results of similarity comparison",
    "label": "what",
    "id": "66"
  },
  {
    "raw_code": "def initialize(code_name, display_name, database_encoding)\n    @code_name = code_name\n    @display_name = display_name\n    @database_encoding = database_encoding\n  end",
    "comment": "Initializes a new locale == Example Locale.new(:en_US, 'English', 1) ",
    "label": "what",
    "id": "67"
  },
  {
    "raw_code": "def ==(other)\n    code_name == other.code_name && display_name == other.display_name && database_encoding == other.database_encoding\n  end",
    "comment": "Returns +true+ or +false+ depending on whether the given locale is equivalent to this one",
    "label": "what",
    "id": "68"
  },
  {
    "raw_code": "def available_locales\n      @registry ||= I18n.config.available_locales.map(&method(:from_i18n_locale))\n    end",
    "comment": "Returns the list of all locales for which there is a registered I18n locale. I18n locales are typically registered in application.rb to match YML files defined in config/locales == Example Locale.available_locales # return a array of Locale: Locale[]",
    "label": "what",
    "id": "69"
  },
  {
    "raw_code": "def available_locale_preferences\n      [@no_preference] + available_locales\n    end",
    "comment": "Similar to +Locale.available_locales+, except it includes the no_preference locale",
    "label": "what",
    "id": "70"
  },
  {
    "raw_code": "def code_name_to_db_encoding(locales = Locale.available_locales)\n      tabulate(locales, %i[code_name database_encoding]).to_h\n    end",
    "comment": "Return a hash that maps the locale +code_name+ to the +database_encoding+ for each item of the provided enumerable Defaults to +Locale.available_locales+ if no enumerable is provided == Example Locale.code_name_to_db_encoding([Locale.new(:no_pref, 'No Preference', 0)])) # {no_pref: 1}",
    "label": "what",
    "id": "71"
  },
  {
    "raw_code": "def from_i18n_locale(locale)\n      I18n.with_locale(locale) { Locale.new(locale, I18n.t('.display_name'), I18n.t('.database_encoding')) }\n    end",
    "comment": "Initializes a new +Locale+ for the given i18m code_name by looking up the required details in the corresponding I18n YAML file, or null if not found == Example Locale.find_by_code(:en_US) == Locale.new(:en_US, 'English', 1) # Where 'English' is defined in en_US.yml under and the key display_name, and '1' under database_encoding",
    "label": "what",
    "id": "72"
  },
  {
    "raw_code": "def self.signup_team(assignment_id, user_id, topic_id = nil)\n    # Find the team ID for the given assignment and user\n    team_id = Team.find_team_users(assignment_id, user_id)&.first&.t_id\n    # If the team doesn't exist, create a new team and assign the team ID\n    if team_id.nil?\n      team = AssignmentTeam.create_team_with_users(assignment_id, [user_id])\n      team_id = team.id\n    end",
    "comment": "Team lazy initialization method [zhewei, 06/27/2015]",
    "label": "what",
    "id": "73"
  },
  {
    "raw_code": "def remove_assignment_from_course\n    oldpath = begin\n                path\n              rescue StandardError\n                nil\n              end",
    "comment": "removes an assignment from course",
    "label": "what",
    "id": "74"
  },
  {
    "raw_code": "def remove_empty_teams\n    empty_teams = teams.reload.select { |team| team.teams_users.empty? }\n    teams.delete(empty_teams)\n  end",
    "comment": "remove empty teams (teams with no users) from assignment",
    "label": "what",
    "id": "75"
  },
  {
    "raw_code": "def valid_num_review\n    self.num_reviews = num_reviews_allowed\n    if num_reviews_greater?(num_reviews_required, num_reviews_allowed)\n      errors.add(:message, 'Num of reviews required cannot be greater than number of reviews allowed')\n    elsif num_reviews_greater?(num_metareviews_required, num_metareviews_allowed)\n      errors.add(:message, 'Number of Meta-Reviews required cannot be greater than number of meta-reviews allowed')\n    end",
    "comment": "checks whether the assignment is getting a valid number of reviews (less than number of reviews allowed)",
    "label": "what",
    "id": "76"
  },
  {
    "raw_code": "def assign_metareviewer_dynamically(meta_reviewer)\n    # The following method raises an exception if not successful which\n    # has to be captured by the caller (in review_mapping_controller)\n    response_map = response_map_to_metareview(meta_reviewer)\n    response_map.assign_metareviewer(meta_reviewer)\n  end",
    "comment": "--------------------metareview assignment begin",
    "label": "what",
    "id": "77"
  },
  {
    "raw_code": "def response_map_to_metareview(metareviewer)\n    response_map_set = Array.new(review_mappings)\n    # Reject response maps without responses\n    response_map_set.reject! { |response_map| response_map.response.empty? }\n    raise 'There are no reviews to metareview at this time for this assignment.' if response_map_set.empty?\n\n    # Reject reviews where the meta_reviewer was the reviewer or the contributor\n    response_map_set.reject! do |response_map|\n      (response_map.reviewee == metareviewer) || (response_map.reviewer == metareviewer)\n    end",
    "comment": "Returns a review (response) to metareview if available, otherwise will raise an error",
    "label": "what",
    "id": "78"
  },
  {
    "raw_code": "def check_condition(column, topic_id = nil)\n    next_due_date = DueDate.get_next_due_date(id, topic_id)\n    return false if next_due_date.nil?\n\n    right_id = next_due_date.send column\n    right = DeadlineRight.find(right_id)\n    right && (right.name == 'OK' || right.name == 'Late')\n  end",
    "comment": "Check whether review, metareview, etc.. is allowed The permissions of TopicDueDate is the same as AssignmentDueDate. Here, column is usually something like 'review_allowed_id'",
    "label": "what",
    "id": "79"
  },
  {
    "raw_code": "def submission_allowed(topic_id = nil)\n    check_condition('submission_allowed_id', topic_id)\n  end",
    "comment": "Determine if the next due date from now allows for submissions",
    "label": "what",
    "id": "80"
  },
  {
    "raw_code": "def quiz_allowed(topic_id = nil)\n    check_condition('quiz_allowed_id', topic_id)\n  end",
    "comment": "Determine if the next due date from now allows to take the quizzes",
    "label": "what",
    "id": "81"
  },
  {
    "raw_code": "def can_review(topic_id = nil)\n    check_condition('review_allowed_id', topic_id)\n  end",
    "comment": "Determine if the next due date from now allows for reviews",
    "label": "what",
    "id": "82"
  },
  {
    "raw_code": "def metareview_allowed(topic_id = nil)\n    check_condition('review_of_review_allowed_id', topic_id)\n  end",
    "comment": "Determine if the next due date from now allows for metareviews",
    "label": "what",
    "id": "83"
  },
  {
    "raw_code": "def delete(force = nil)\n    begin\n      maps = ReviewResponseMap.where(reviewed_object_id: id)\n      maps.each { |map| map.delete(force) }\n    rescue StandardError\n      raise \"There is at least one review response that exists for #{name}.\"\n    end",
    "comment": "Deletes all instances created as part of assignment and finally destroys itself.",
    "label": "what",
    "id": "84"
  },
  {
    "raw_code": "def microtask?\n    microtask.nil? ? false : microtask\n  end",
    "comment": "Check to see if assignment is a microtask",
    "label": "what",
    "id": "85"
  },
  {
    "raw_code": "def badge?\n    has_badge.nil? ? false : has_badge\n  end",
    "comment": "Check to see if assignment has badge",
    "label": "what",
    "id": "86"
  },
  {
    "raw_code": "def add_participant(user_name, can_submit, can_review, can_take_quiz, can_mentor)\n    user = User.find_by(name: user_name)\n    if user.nil?\n      raise \"The user account with the name #{user_name} does not exist. Please <a href='\" +\n            url_for(controller: 'users', action: 'new') + \"'>create</a> the user first.\"\n    end",
    "comment": "add a new participant to this assignment manual addition user_name - the user account name of the participant to add",
    "label": "what",
    "id": "87"
  },
  {
    "raw_code": "def number_of_current_round(topic_id)\n    next_due_date = DueDate.get_next_due_date(id, topic_id)\n    return 0 if next_due_date.nil?\n\n    next_due_date.round ||= 0\n  end",
    "comment": "if current  stage is submission or review, find the round number otherwise, return 0",
    "label": "what",
    "id": "88"
  },
  {
    "raw_code": "def current_stage_name(topic_id = nil)\n    if staggered_deadline?\n      return (topic_id.nil? ? 'Unknown' : current_stage(topic_id))\n    end",
    "comment": "For varying rubric feature",
    "label": "what",
    "id": "89"
  },
  {
    "raw_code": "def varying_rubrics_by_round?\n    # E-2084 corrected '>=' to '>' to fix logic\n    #This is a hack, we should actually check if we have more than one rubric of a given type eg, review\n    AssignmentQuestionnaire.where(assignment_id: id, used_in_round: 2).size >= 1\n  end",
    "comment": "check if this assignment has multiple review phases with different review rubrics",
    "label": "what",
    "id": "90"
  },
  {
    "raw_code": "def current_stage(topic_id = nil)\n    return 'Unknown' if staggered_and_no_topic?(topic_id)\n\n    due_date = find_current_stage(topic_id)\n    due_date.nil? || due_date == 'Finished' ? 'Finished' : DeadlineType.find(due_date.deadline_type_id).name\n  end",
    "comment": "Zhewei: this method is almost the same as 'stage_deadline'",
    "label": "what",
    "id": "91"
  },
  {
    "raw_code": "def review_questionnaire_id(round_number = nil, topic_id = nil)\n    # If round is not given, try to retrieve current round from the next due date\n    if round_number.nil?\n      next_due_date = DueDate.get_next_due_date(id)\n      round_number = next_due_date.try(:round)\n    end",
    "comment": "Find the ID of a review questionnaire for this assignment",
    "label": "what",
    "id": "92"
  },
  {
    "raw_code": "def self.csv_row(detail_options, answer)\n    teams_csv = []\n    @response = Response.find(answer.response_id)\n    map = ResponseMap.find(@response.map_id)\n    @reviewee = Team.find_by id: map.reviewee_id\n    @reviewee = Participant.find(map.reviewee_id).user if @reviewee.nil?\n    reviewer = Participant.find(map.reviewer_id).user\n    teams_csv << handle_nil(@reviewee.id) if detail_options['team_id'] == 'true'\n    teams_csv << handle_nil(@reviewee.name) if detail_options['team_name'] == 'true'\n    teams_csv << handle_nil(reviewer.name) if detail_options['reviewer'] == 'true'\n    teams_csv << handle_nil(answer.question.txt) if detail_options['question'] == 'true'\n    teams_csv << handle_nil(answer.question.id) if detail_options['question_id'] == 'true'\n    teams_csv << handle_nil(answer.id) if detail_options['comment_id'] == 'true'\n    teams_csv << handle_nil(answer.comments) if detail_options['comments'] == 'true'\n    teams_csv << handle_nil(answer.answer) if detail_options['score'] == 'true'\n    teams_csv\n  end",
    "comment": "Generates a single row based on the detail_options selected",
    "label": "what",
    "id": "93"
  },
  {
    "raw_code": "def self.generate_answer(answers, assignment)\n    # get all response maps for this assignment\n    @response_maps_for_assignment = ResponseMap.find_by_sql([\"SELECT * FROM response_maps WHERE reviewed_object_id = #{assignment.id}\"])\n    # for each map, get the response & answer associated with it\n    @response_maps_for_assignment.each do |map|\n      @response_for_this_map = Response.find_by_sql([\"SELECT * FROM responses WHERE map_id = #{map.id}\"])\n      # for this response, get the answer associated with it\n      @response_for_this_map.each do |resp|\n        @associated_answers = Answer.find_by_sql([\"SELECT * FROM answers WHERE response_id = #{resp.id}\"])\n        @associated_answers.each do |answer|\n          answers[resp.round][map.type].push(answer)\n        end",
    "comment": "Populate answers will review information",
    "label": "what",
    "id": "94"
  },
  {
    "raw_code": "def self.check_empty_rounds(answers, round_num, res_type)\n    if answers[round_num][res_type].any?\n      round_num.nil? ? 'Round Nil - ' + res_type : 'Round ' + round_num.to_s + ' - ' + res_type.to_s\n    end",
    "comment": "Checks if there are rounds with no reviews",
    "label": "what",
    "id": "95"
  },
  {
    "raw_code": "def self.export_headers(parent_id)\n    @assignment = Assignment.find(parent_id)\n    fields = []\n    fields << 'Assignment Name: ' + @assignment.name.to_s\n    fields << 'Assignment Instructor: ' + User.find(@assignment.instructor_id).name.to_s\n    fields\n  end",
    "comment": "This method is used to set the headers for the csv like Assignment Name and Assignment Instructor",
    "label": "what",
    "id": "96"
  },
  {
    "raw_code": "def self.export(csv, parent_id, options)\n    @assignment = Assignment.find(parent_id)\n    @questions = {}\n    questionnaires = @assignment.questionnaires\n    questionnaires.each do |questionnaire|\n      if @assignment.varying_rubrics_by_round?\n        round = AssignmentQuestionnaire.find_by(assignment_id: @assignment.id, questionnaire_id: @questionnaire.id).used_in_round\n        questionnaire_symbol = round.nil? ? questionnaire.symbol : (questionnaire.symbol.to_s + round.to_s).to_sym\n      else\n        questionnaire_symbol = questionnaire.symbol\n      end",
    "comment": "This method is used for export contents of grade#view.  -Zhewei",
    "label": "what",
    "id": "97"
  },
  {
    "raw_code": "def find_review_period(round)\n    # If round is nil, it means the same questionnaire is used for every round. Thus, we return all periods.\n    # If round is not nil, we return only the period of that round.\n\n    submission_type = DeadlineType.find_by(name: 'submission').id\n    review_type = DeadlineType.find_by(name: 'review').id\n\n    due_dates = []\n    due_dates += find_due_dates('submission')\n    due_dates += find_due_dates('review')\n    due_dates.sort_by!(&:id)\n\n    start_dates = []\n    end_dates = []\n\n    if round.nil?\n      round = 1\n      while self.due_dates.exists?(round: round)\n        start_dates << due_dates.select { |due_date| due_date.deadline_type_id == submission_type && due_date.round == round }.last\n        end_dates << due_dates.select { |due_date| due_date.deadline_type_id == review_type && due_date.round == round }.last\n        round += 1\n      end",
    "comment": "Method find_review_period is used in answer_helper.rb to get the start and end dates of a round",
    "label": "what",
    "id": "98"
  },
  {
    "raw_code": "def questionnaire_ids(round)\n    questionnaire_ids = if round.nil?\n                          AssignmentQuestionnaire.where(assignment_id: id)\n                        else\n                          AssignmentQuestionnaire.where(assignment_id: id, used_in_round: round)\n                        end",
    "comment": "for program 1 like assignment, if same rubric is used in both rounds, the 'used_in_round' field in 'assignment_questionnaires' will be null, since one field can only store one integer if questionnaire_ids is empty, Expertiza will try to find questionnaire whose type is 'ReviewQuestionnaire'.",
    "label": "what",
    "id": "99"
  },
  {
    "raw_code": "def staggered_and_no_topic?(topic_id)\n    staggered_deadline? && topic_id.nil?\n  end",
    "comment": "returns true if assignment has staggered deadline and topic_id is nil",
    "label": "what",
    "id": "100"
  },
  {
    "raw_code": "def num_reviews_greater?(reviews_required, reviews_allowed)\n    reviews_allowed && reviews_allowed != -1 && reviews_required > reviews_allowed\n  end",
    "comment": "returns true if reviews required is greater than reviews allowed",
    "label": "what",
    "id": "101"
  },
  {
    "raw_code": "def reviewer_metareviews_map(response_map_set)\n    reviewers = {}\n    response_map_set.each do |response_map|\n      reviewer = response_map.reviewer\n      reviewers.member?(reviewer) ? reviewers[reviewer] += 1 : reviewers[reviewer] = 1\n    end",
    "comment": "returns a map of reviewer to meta_reviews",
    "label": "what",
    "id": "102"
  },
  {
    "raw_code": "def drop_waitlisted_teams\n    # Find all the topics (sign_up_topics) under the current assignment (self).\n    topics = SignUpTopic.where(assignment_id: self.id)\n  \n    # Iterate through each topic to find and drop waitlisted teams.\n    topics.each do |topic|\n      signed_up_teams = SignedUpTeam.where(topic_id: topic.id, is_waitlisted: true)\n      # Remove all of the waitlisted SignedUpTeam entries for this topic.\n      signed_up_teams.destroy_all\n    end",
    "comment": "Method to drop all the SignedUpRecords of all topics for that assignment once the drop_topic deadline passes",
    "label": "what",
    "id": "103"
  },
  {
    "raw_code": "def get_menu(level)\n    @vector[level].try(:children)\n  end",
    "comment": "Returns the array of items at the given level.",
    "label": "what",
    "id": "104"
  },
  {
    "raw_code": "def selected\n    @vector.last.try(:name)\n  end",
    "comment": "Returns the name of the currently-selected item or nil if no item is selected. rubocop:disable Lint/DuplicateMethods",
    "label": "what",
    "id": "105"
  },
  {
    "raw_code": "def selected?(menu_id)\n    @selected.key?(menu_id)\n  end",
    "comment": "Returns true if the specified item is selected; false if otherwise.",
    "label": "what",
    "id": "106"
  },
  {
    "raw_code": "def parent_name; end\n\n  # implemented in both AssignmentSurveyDeployment and CourseSurveyDeployment models\n  def response_maps; end\nend",
    "comment": "implemented in both AssignmentSurveyDeployment and CourseSurveyDeployment models",
    "label": "what",
    "id": "107"
  },
  {
    "raw_code": "def edit(_count)\n    html = '<tr>'\n    html += '<td align=\"center\"><a rel=\"nofollow\" data-method=\"delete\" href=\"/questions/' + id.to_s + '\">Remove</a></td>'\n    html += '<td><input size=\"6\" value=\"' + seq.to_s + '\" name=\"question[' + id.to_s\n    html += '][seq]\" id=\"question_' + id.to_s + '_seq\" type=\"text\"></td>'\n    html += '<td><textarea cols=\"50\" rows=\"1\" name=\"question[' + id.to_s + '][txt]\" id=\"question_' + id.to_s\n    html += '_txt\" placeholder=\"Edit question content here\">' + txt + '</textarea></td>'\n    html += '<td><input size=\"10\" disabled=\"disabled\" value=\"' + type + '\" name=\"question[' + id.to_s\n    html += '][type]\" id=\"question_' + id.to_s + '_type\" type=\"text\"></td>'\n    html += '<td><!--placeholder (QuestionnaireHeader does not need weight)--></td>'\n    html += '</tr>'\n\n    html.html_safe\n  end",
    "comment": "This method returns what to display if an instructor (etc.) is creating or editing a questionnaire (questionnaires_controller.rb)",
    "label": "what",
    "id": "108"
  },
  {
    "raw_code": "def view_question_text\n    html = '<TR><TD align=\"left\"> ' + txt + ' </TD>'\n    html += '<TD align=\"left\">' + type + '</TD>'\n    html += '<td align=\"center\">' + weight.to_s + '</TD>'\n    html += '<TD align=\"center\">&mdash;</TD>'\n    html += '</TR>'\n    html.html_safe\n  end",
    "comment": "This method returns what to display if an instructor (etc.) is viewing a questionnaire",
    "label": "what",
    "id": "109"
  },
  {
    "raw_code": "def self.assessments_for(team)\n    responses = []\n    # stime = Time.now\n    if team\n      @array_sort = []\n      @sort_to = []\n      maps = where(reviewee_id: team.id)\n      maps.each do |map|\n        next if map.response.empty?\n\n        @all_resp = Response.where(map_id: map.map_id).last\n        if map.type.eql?('ReviewResponseMap')\n          # If its ReviewResponseMap then only consider those response which are submitted.\n          @array_sort << @all_resp if @all_resp.is_submitted\n        else\n          @array_sort << @all_resp\n        end",
    "comment": "return latest versions of the responses",
    "label": "what",
    "id": "110"
  },
  {
    "raw_code": "def self.reviewer_assessments_for(team, reviewer)\n    # get_reviewer may return an AssignmentParticipant or an AssignmentTeam\n    # map = where(reviewee_id: team.id, reviewer_id: reviewer.get_reviewer.id)\n    map = where(reviewee_id: team.id, reviewer_id: reviewer.id)\n    Response.where(map_id: map.first.id).sort { |m1, m2| comparator(m1, m2) }.first\n  end",
    "comment": "return latest versions of the response given by reviewer",
    "label": "what",
    "id": "111"
  },
  {
    "raw_code": "def get_all_versions\n    []\n  end",
    "comment": "Placeholder method, override in derived classes if required.",
    "label": "what",
    "id": "112"
  },
  {
    "raw_code": "def metareviewed_by?(metareviewer)\n    MetareviewResponseMap.where(reviewee_id: reviewer.id, reviewer_id: metareviewer.id, reviewed_object_id: id).count > 0\n  end",
    "comment": "Evaluates whether this response_map was metareviewed by metareviewer @param[in] metareviewer AssignmentParticipant object",
    "label": "what",
    "id": "113"
  },
  {
    "raw_code": "def assign_metareviewer(metareviewer)\n    MetareviewResponseMap.create(reviewed_object_id: id,\n                                 reviewer_id: metareviewer.id, reviewee_id: reviewer.id)\n  end",
    "comment": "Assigns a metareviewer to this review (response) @param[in] metareviewer AssignmentParticipant object",
    "label": "what",
    "id": "114"
  },
  {
    "raw_code": "def add_member(user, _assignment_id = nil)\n        raise \"The user #{user.name} is already a member of the team #{name}\" if user?(user)\n    \n        can_add_member = false\n        unless full?\n          can_add_member = true\n          t_user = TeamsUser.create(user_id: user.id, team_id: id)\n          parent = TeamNode.find_by(node_object_id: id)\n          TeamUserNode.create(parent_id: parent.id, node_object_id: t_user.id)\n          add_participant(parent_id, user)\n          ExpertizaLogger.info LoggerMessage.new('Model:Team', user.name, \"Added member to the team #{id}\")\n        end",
    "comment": "Class created during refactoring of E2351 Overridden method to include the MentorManagement workflow",
    "label": "what",
    "id": "115"
  },
  {
    "raw_code": "def email(defn, _participant, assignment)\n    defn[:body][:type] = 'Author Feedback'\n    # reviewee is a response, reviewer is a participant\n    # we need to track back to find the original reviewer on whose work the author comments\n    response_id_for_original_feedback = reviewed_object_id\n    response_for_original_feedback = Response.find response_id_for_original_feedback\n    response_map_for_original_feedback = ResponseMap.find response_for_original_feedback.map_id\n    original_reviewer_participant_id = response_map_for_original_feedback.reviewer_id\n\n    participant = AssignmentParticipant.find(original_reviewer_participant_id)\n\n    defn[:body][:obj_name] = assignment.name\n\n    user = User.find(participant.user_id)\n\n    defn[:to] = user.email\n    defn[:body][:first_name] = user.fullname\n    Mailer.sync_message(defn).deliver\n  end",
    "comment": "Send emails for author feedback Refactored from email method in response.rb",
    "label": "what",
    "id": "116"
  },
  {
    "raw_code": "def call(s, ts, pg, msg)\n    if msg.is_a?(LoggerMessage)\n      \"TST=[#{ts}] SVT=[#{s}] PNM=[#{pg}] OIP=[#{msg.oip}] RID=[#{msg.req_id}] CTR=[#{msg.generator}] UID=[#{msg.unity_id}] MSG=[#{filter(msg.message)}]\\n\"\n    else\n      \"TST=[#{ts}] SVT=[#{s}] PNM=[#{pg}] OIP=[] RID=[] CTR=[] UID=[] MSG=[#{filter(msg)}]\\n\"\n    end",
    "comment": "This method is invoked when a log event occurs",
    "label": "what",
    "id": "117"
  },
  {
    "raw_code": "def self.new_topic_from_suggestion(suggestion)\n    signuptopic = SignUpTopic.new\n    signuptopic.topic_identifier = 'S' + Suggestion.where('assignment_id = ? and id <= ?', suggestion.assignment_id, suggestion.id).size.to_s\n    signuptopic.topic_name = suggestion.title\n    signuptopic.assignment_id = suggestion.assignment_id\n    signuptopic.max_choosers = 1\n    # return this model based on these checks\n    if signuptopic.save && suggestion.update_attribute('status', 'Approved')\n      return signuptopic\n    else\n      return 'failed'\n    end",
    "comment": "E2121 Line 160: Refactor approve_suggestion to indicate that notification is being sent",
    "label": "what",
    "id": "118"
  },
  {
    "raw_code": "def sign_team_up(team_id)\n    topic_id = self.id\n    team = Team.find(team_id)\n    # Fetch all topics for the user within the team for the assignment\n    user_signup = SignedUpTeam.find_user_signup_topics(team.parent_id, team_id)\n    # Check if the user is already signed up and waitlisted for the topic\n    if !user_signup.empty?\n      return false unless user_signup.first&.is_waitlisted == true\n    end",
    "comment": "Method to handle the process when a user signs up",
    "label": "what",
    "id": "119"
  },
  {
    "raw_code": "def self.assign_topic_to_team(signup, topic_id)\n    # Set the team's waitlist status to false as they are assigned a topic\n    signup.update(is_waitlisted: false)\n    # Update the topic_id in the signed_up_teams table for the user\n    signed_up_team = SignedUpTeam.find_by(topic_id: topic_id)\n    signed_up_team.update(topic_id: topic_id) if signed_up_team\n  end",
    "comment": "Method to assign a topic to the team and update the waitlist status",
    "label": "what",
    "id": "120"
  },
  {
    "raw_code": "def self.save_waitlist_entry(signup, team_id)\n    signup.is_waitlisted = true\n    # Save the user's waitlist status\n    result = signup.save\n    # Log the creation of the sign-up sheet for the waitlisted user\n    ExpertizaLogger.info(LoggerMessage.new('SignUpSheet', '', \"Sign up sheet created for waitlisted with teamId #{team_id}\"))\n    result\n  end",
    "comment": "Method to save the user as waitlisted if no slots are available",
    "label": "what",
    "id": "121"
  },
  {
    "raw_code": "def mail_assigned_reviewers\n    # Find review mappings for the work done by this participant's team\n    mappings = ResponseMap.where(reviewed_object_id: self.assignment.id,\n                                 reviewee_id: self.team.id,\n                                 type: 'ReviewResponseMap')\n    unless mappings.nil?\n      mappings.each do |mapping|\n        reviewer = mapping.reviewer.user\n        prepared_mail = MailerHelper.send_mail_to_assigned_reviewers(reviewer, self, mapping)\n        prepared_mail.deliver_now\n      end",
    "comment": "send email to team's reviewers in case a new submission is made",
    "label": "what",
    "id": "122"
  },
  {
    "raw_code": "def authorization\n    authorization = 'participant'\n    #E2351 - need to change authorization to reflect mentor when importing\n    #otherwise all imported Assignment Participants would be 'participant' even if designated as mentor in import file\n    authorization = 'mentor' if can_mentor\n    authorization = 'reader' if !can_submit && can_review && can_take_quiz\n    authorization = 'submitter' if can_submit && !can_review && !can_take_quiz\n    authorization = 'reviewer' if !can_submit && can_review && !can_take_quiz\n    authorization\n  end",
    "comment": "Get authorization from permissions.",
    "label": "what",
    "id": "123"
  },
  {
    "raw_code": "def self.sort_by_name(participants)\n    users = []\n    participants.each { |p| users << p.user }\n    users.sort! { |a, b| a.name.downcase <=> b.name.downcase } # Sort the users based on the name\n    participants.sort_by { |p| users.map(&:id).index(p.user_id) }\n  end",
    "comment": "Sort a set of participants based on their user names. Please make sure there is no duplicated participant in this input array. There should be a more beautiful way to handle this, though.  -Yang",
    "label": "what",
    "id": "124"
  },
  {
    "raw_code": "def self.export(csv, parent_id, options)\n    where(parent_id: parent_id).find_each do |part|\n      tcsv = []\n      user = part.user\n      tcsv.push(user.name, user.fullname, user.email) if options['personal_details'] == 'true'\n      tcsv.push(user.role.name) if options['role'] == 'true'\n      tcsv.push(user.parent.name) if options['parent'] == 'true'\n      tcsv.push(user.email_on_submission, user.email_on_review, user.email_on_review_of_review) if options['email_options'] == 'true'\n      tcsv.push(part.handle) if options['handle'] == 'true'\n      csv << tcsv\n    end",
    "comment": "provide export functionality for Assignment Participants and Course Participants",
    "label": "what",
    "id": "125"
  },
  {
    "raw_code": "def user_id\n    @current_user.id if !@current_user.nil? && users.include?(@current_user)\n    users.first.id\n  end",
    "comment": "Added for E1973, Team reviews. Some methods prompt a reviewer for a user id. This method just returns the user id of the first user in the team This is a very hacky way to deal with very complex functionality but the reasoning is this: The reason this is being added is to give ReviewAssignment#reject_own_submission a way to reject the submission Of the reviewer. If there are team reviews, there must be team submissions, so any team member's user id will do. Hopefully, this logic applies if there are other situations where reviewer.user_id was called EDIT: A situation was found which differs slightly. If the current user is on the team, we want to return that instead for instances where the code uses the current user.",
    "label": "what",
    "id": "126"
  },
  {
    "raw_code": "def set_current_user(current_user)\n    @current_user = current_user\n  end",
    "comment": "E1973 stores the current user so that we can check them when returning the user_id",
    "label": "what",
    "id": "127"
  },
  {
    "raw_code": "def includes?(participant)\n    participants.include?(participant)\n  end",
    "comment": "Whether this team includes a given participant or not",
    "label": "what",
    "id": "128"
  },
  {
    "raw_code": "def parent_model\n    'Assignment'\n  end",
    "comment": "Get the parent of this class=>Assignment",
    "label": "what",
    "id": "129"
  },
  {
    "raw_code": "def fullname\n    name\n  end",
    "comment": "Get the name of the class",
    "label": "what",
    "id": "130"
  },
  {
    "raw_code": "def review_map_type\n    'ReviewResponseMap'\n  end",
    "comment": "Get the review response map",
    "label": "what",
    "id": "131"
  },
  {
    "raw_code": "def self.prototype\n    AssignmentTeam.new\n  end",
    "comment": "Prototype method to implement prototype pattern",
    "label": "what",
    "id": "132"
  },
  {
    "raw_code": "def assign_reviewer(reviewer)\n    assignment = Assignment.find(parent_id)\n    raise 'The assignment cannot be found.' if assignment.nil?\n\n    ReviewResponseMap.create(reviewee_id: id, reviewer_id: reviewer.get_reviewer.id, reviewed_object_id: assignment.id, team_reviewing_enabled: assignment.team_reviewing_enabled)\n  end",
    "comment": "Use current object (AssignmentTeam) as reviewee and create the ReviewResponseMap record",
    "label": "what",
    "id": "133"
  },
  {
    "raw_code": "def get_reviewer\n    self\n  end",
    "comment": "E-1973 If a team is being treated as a reviewer of an assignment, then they are the reviewer",
    "label": "what",
    "id": "134"
  },
  {
    "raw_code": "def reviewed_by?(reviewer)\n    ReviewResponseMap.where('reviewee_id = ? && reviewer_id = ? && reviewed_object_id = ?', id, reviewer.get_reviewer.id, assignment.id).count > 0\n  end",
    "comment": "Evaluates whether any contribution by this team was reviewed by reviewer @param[in] reviewer AssignmentParticipant object",
    "label": "what",
    "id": "135"
  },
  {
    "raw_code": "def topic\n    SignedUpTeam.find_by(team_id: id, is_waitlisted: 0).try(:topic_id)\n  end",
    "comment": "Topic picked by the team for the assignment This method needs refactoring: it sounds like it returns a topic object but in fact it returns an id",
    "label": "what",
    "id": "136"
  },
  {
    "raw_code": "def has_submissions?\n    submitted_files.any? || submitted_hyperlinks.present?\n  end",
    "comment": "Whether the team has submitted work or not",
    "label": "what",
    "id": "137"
  },
  {
    "raw_code": "def participants\n    users = self.users\n    participants = []\n    users.each do |user|\n      participant = AssignmentParticipant.find_by(user_id: user.id, parent_id: parent_id)\n      participants << participant unless participant.nil?\n    end",
    "comment": "Get Participants of the team",
    "label": "what",
    "id": "138"
  },
  {
    "raw_code": "def delete\n    if self[:type] == 'AssignmentTeam'\n      sign_up = SignedUpTeam.find_team_participants(parent_id.to_s).select { |p| p.team_id == id }\n      sign_up.each(&:destroy)\n    end",
    "comment": "Delete the team",
    "label": "what",
    "id": "139"
  },
  {
    "raw_code": "def destroy\n    review_response_maps.each(&:destroy)\n    super\n  end",
    "comment": "Delete Review response map",
    "label": "what",
    "id": "140"
  },
  {
    "raw_code": "def self.first_member(team_id)\n    find_by(id: team_id).try(:participants).try(:first)\n  end",
    "comment": "Get the first member of the team",
    "label": "what",
    "id": "141"
  },
  {
    "raw_code": "def submitted_files(path = self.path)\n    files = []\n    files = files(path) if directory_num\n    files\n  end",
    "comment": "Return the files residing in the directory of team submissions Main calling method to return the files residing in the directory of team submissions",
    "label": "what",
    "id": "142"
  },
  {
    "raw_code": "def self.import(row, assignment_id, options)\n    unless Assignment.find_by(id: assignment_id)\n      raise ImportError, 'The assignment with the id \"' + assignment_id.to_s + \"\\\" was not found. <a href='/assignment/new'>Create</a> this assignment?\"\n    end",
    "comment": "REFACTOR BEGIN:: functionality of import,export, handle_duplicate shifted to team.rb Import csv file to form teams directly",
    "label": "what",
    "id": "143"
  },
  {
    "raw_code": "def self.export(csv, parent_id, options)\n    @assignment_team = prototype\n    Team.export(csv, parent_id, options, @assignment_team)\n  end",
    "comment": "Export the existing teams in a csv file",
    "label": "what",
    "id": "144"
  },
  {
    "raw_code": "def copy(course_id)\n    new_team = CourseTeam.create_team_and_node(course_id)\n    new_team.name = name\n    new_team.save\n    copy_members(new_team)\n  end",
    "comment": "Copy the current Assignment team to the CourseTeam",
    "label": "what",
    "id": "145"
  },
  {
    "raw_code": "def add_participant(assignment_id, user)\n    return if AssignmentParticipant.find_by(parent_id: assignment_id, user_id: user.id)\n\n    AssignmentParticipant.create(parent_id: assignment_id, user_id: user.id, permission_granted: user.master_permission_granted)\n  end",
    "comment": "Add Participants to the current Assignment Team",
    "label": "what",
    "id": "146"
  },
  {
    "raw_code": "def self.team(participant)\n    return nil if participant.nil?\n\n    team = nil\n    teams_users = TeamsUser.where(user_id: participant.user_id)\n    return nil unless teams_users\n\n    teams_users.each do |teams_user|\n      if teams_user.team_id == nil\n        next\n      end",
    "comment": "return the team given the participant",
    "label": "what",
    "id": "147"
  },
  {
    "raw_code": "def self.export_fields(options)\n    fields = []\n    fields.push('Team Name')\n    fields.push('Team members') if options[:team_name] == 'false'\n    fields.push('Assignment Name')\n  end",
    "comment": "Export the fields",
    "label": "what",
    "id": "148"
  },
  {
    "raw_code": "def self.remove_team_by_id(id)\n    old_team = AssignmentTeam.find(id)\n    old_team.destroy unless old_team.nil?\n  end",
    "comment": "Remove a team given the team id",
    "label": "what",
    "id": "149"
  },
  {
    "raw_code": "def path\n    assignment.path + '/' + directory_num.to_s\n  end",
    "comment": "Get the path of the team directory",
    "label": "what",
    "id": "150"
  },
  {
    "raw_code": "def set_student_directory_num\n    return if directory_num && (directory_num >= 0)\n\n    max_num = AssignmentTeam.where(parent_id: parent_id).order('directory_num desc').first.directory_num\n    dir_num = max_num ? max_num + 1 : 0\n    update_attributes(directory_num: dir_num)\n  end",
    "comment": "Set the directory num for this team",
    "label": "what",
    "id": "151"
  },
  {
    "raw_code": "def most_recent_submission\n    assignment = Assignment.find(parent_id)\n    SubmissionRecord.where(team_id: id, assignment_id: assignment.id).order(updated_at: :desc).first\n  end",
    "comment": "Returns the most recent submission of the team",
    "label": "what",
    "id": "152"
  },
  {
    "raw_code": "def get_logged_in_reviewer_id(current_user_id)\n    participants.each do |participant|\n      return participant.id if participant.user.id == current_user_id\n    end",
    "comment": "E-1973 gets the participant id of the currently logged in user, given their user id this method assumes that the team is the reviewer since it would be called on AssignmentParticipant otherwise",
    "label": "what",
    "id": "153"
  },
  {
    "raw_code": "def current_user_is_reviewer?(current_user_id)\n    get_logged_in_reviewer_id(current_user_id) != nil\n  end",
    "comment": "determines if the team contains a participant who is currently logged in",
    "label": "what",
    "id": "154"
  },
  {
    "raw_code": "def create_new_team(user_id, signuptopic)\n    t_user = TeamsUser.create(team_id: id, user_id: user_id)\n    SignedUpTeam.create(topic_id: signuptopic.id, team_id: id, is_waitlisted: 0)\n    parent = TeamNode.create(parent_id: signuptopic.assignment_id, node_object_id: id)\n    TeamUserNode.create(parent_id: parent.id, node_object_id: t_user.id)\n  end",
    "comment": "E2121 Refractor create_new_team",
    "label": "what",
    "id": "155"
  },
  {
    "raw_code": "def aggregate_questionnaire_score\n    # only count the scorable questions, only when the answer is not nil\n    # we accept nil as answer for scorable questions, and they will not be counted towards the total score\n    sum = 0\n    scores.each do |s|\n      question = Question.find(s.question_id)\n      # For quiz responses, the weights will be 1 or 0, depending on if correct\n      sum += s.answer * question.weight unless s.answer.nil? || !question.is_a?(ScoredQuestion)\n    end",
    "comment": "Computes the total score awarded for a review",
    "label": "what",
    "id": "156"
  },
  {
    "raw_code": "def average_score\n    if maximum_score.zero?\n      'N/A'\n    else\n      ((aggregate_questionnaire_score.to_f / maximum_score.to_f) * 100).round\n    end",
    "comment": "bug fixed Returns the average score for this response as an integer (0-100)",
    "label": "what",
    "id": "157"
  },
  {
    "raw_code": "def maximum_score\n    # only count the scorable questions, only when the answer is not nil (we accept nil as\n    # answer for scorable questions, and they will not be counted towards the total score)\n    total_weight = 0\n    scores.each do |s|\n      question = Question.find(s.question_id)\n      total_weight += question.weight unless s.answer.nil? || !question.is_a?(ScoredQuestion)\n    end",
    "comment": "Returns the maximum possible score for this response",
    "label": "what",
    "id": "158"
  },
  {
    "raw_code": "def email(partial = 'new_submission')\n    defn = {}\n    defn[:body] = {}\n    defn[:body][:partial_name] = partial\n    response_map = ResponseMap.find map_id\n    participant = Participant.find(response_map.reviewer_id)\n    # parent is used as a common variable name for either an assignment or course depending on what the questionnaire is associated with\n    parent = if response_map.survey?\n               response_map.survey_parent\n             else\n               Assignment.find(participant.parent_id)\n             end",
    "comment": "only two types of responses more should be added",
    "label": "what",
    "id": "159"
  },
  {
    "raw_code": "def create_or_get_response(response_map, current_round)\n    response = Response.where(map_id: response_map.id, round: current_round.to_i).order(updated_at: :desc).first\n    reviewee_team = AssignmentTeam.find_by(id: response_map.reviewee_id)\n\n    most_recent_submission_by_reviewee = reviewee_team.most_recent_submission if reviewee_team\n\n    if response.nil? || (most_recent_submission_by_reviewee && most_recent_submission_by_reviewee.updated_at > response.updated_at)\n      response = Response.create(map_id: response_map.id, additional_comment: '', round: current_round.to_i, is_submitted: 0)\n    end",
    "comment": "This create_or_get_response method returns a Response object used to populate the @response instance object with the correct response according to the rubric review round or with a new Response object that the controller can use this method is called within the new method in response_controller",
    "label": "what",
    "id": "160"
  },
  {
    "raw_code": "def significant_difference?\n    map_class = map.class\n    existing_responses = map_class.assessments_for(map.reviewee)\n    average_score_on_same_artifact_from_others, count = Response.avg_scores_and_count_for_prev_reviews(existing_responses, self)\n    # if this response is the first on this artifact, there's no grade conflict\n    return false if count.zero?\n\n    # This score has already skipped the unfilled scorable question(s)\n    score = aggregate_questionnaire_score.to_f / maximum_score\n    questionnaire = questionnaire_by_answer(scores.first)\n    assignment = map.assignment\n    assignment_questionnaire = AssignmentQuestionnaire.find_by(assignment_id: assignment.id, questionnaire_id: questionnaire.id)\n    # notification_limit can be specified on 'Rubrics' tab on assignment edit page.\n    allowed_difference_percentage = assignment_questionnaire.notification_limit.to_f\n    # the range of average_score_on_same_artifact_from_others and score is [0,1]\n    # the range of allowed_difference_percentage is [0, 100]\n    (average_score_on_same_artifact_from_others - score).abs * 100 > allowed_difference_percentage\n  end",
    "comment": "compare the current response score with other scores on the same artifact, and test if the difference is significant enough to notify instructor. Precondition: the response object is associated with a ReviewResponseMap \"map_class.assessments_for\" method need to be refactored",
    "label": "what",
    "id": "161"
  },
  {
    "raw_code": "def done_by_staff_participant?\n    role = Role.find(User.find(Participant.find(ResponseMap.find(Response.find(id).map_id).reviewer_id).user_id).role_id).name\n    (role == 'Instructor') || (role == 'Teaching Assistant')\n  end",
    "comment": "Check if this review was done by TA/instructor return True or False",
    "label": "what",
    "id": "162"
  },
  {
    "raw_code": "def get_formatted_question_type\n    type = self.type\n    statement = ''\n    if type == 'TrueFalse'\n      statement = 'True/False'\n    elsif type == 'MultipleChoiceCheckbox'\n      statement = 'Multiple Choice - Checked'\n    elsif type == 'MultipleChoiceRadio'\n      statement = 'Multiple Choice - Radio'\n    end",
    "comment": "for quiz questions, we store 'TrueFalse', 'MultipleChoiceCheckbox', 'MultipleChoiceRadio' in the DB, and the full names are returned below",
    "label": "what",
    "id": "163"
  },
  {
    "raw_code": "def edit\n    nil\n  end",
    "comment": "Placeholder methods, override in derived classes if required. this method decide what to display if an instructor (etc.) is creating or editing a questionnaire",
    "label": "what",
    "id": "164"
  },
  {
    "raw_code": "def view_question_text\n    nil\n  end",
    "comment": "this method decide what to display if an instructor (etc.) is viewing a questionnaire",
    "label": "what",
    "id": "165"
  },
  {
    "raw_code": "def view_completed_question\n    nil\n  end",
    "comment": "this method decide what to display if a student is filling out a questionnaire",
    "label": "what",
    "id": "166"
  },
  {
    "raw_code": "def complete\n    nil\n  end",
    "comment": "this method decide what to display if a student is viewing a filled-out questionnaire",
    "label": "what",
    "id": "167"
  },
  {
    "raw_code": "def self.get_all_questions_with_comments_available(assignment_id)\n    question_ids = []\n    questionnaires = Assignment.find(assignment_id).questionnaires.select { |questionnaire| questionnaire.type == 'ReviewQuestionnaire' }\n    questionnaires.each do |questionnaire|\n      questions = questionnaire.questions.select { |question| question.is_a?(ScoredQuestion) || question.instance_of?(TextArea) }\n      questions.each { |question| question_ids << question.id }\n    end",
    "comment": "this method return questions (question_ids) in one assignment whose comments field are meaningful (ScoredQuestion and TextArea)",
    "label": "what",
    "id": "168"
  },
  {
    "raw_code": "def self.create_form_object(assignment_id)\n    assignment_form = AssignmentForm.new\n    assignment_form.assignment = Assignment.find(assignment_id)\n    assignment_form.assignment_questionnaires = AssignmentQuestionnaire.where(assignment_id: assignment_id)\n    assignment_form.due_dates = AssignmentDueDate.where(parent_id: assignment_id)\n    assignment_form.set_up_assignment_review\n    assignment_form.tag_prompt_deployments = TagPromptDeployment.where(assignment_id: assignment_id)\n    assignment_form\n  end",
    "comment": "create a form object for this assignment_id",
    "label": "what",
    "id": "169"
  },
  {
    "raw_code": "def update_assignment(attributes)\n    unless @assignment.update_attributes(attributes)\n      @errors = @assignment.errors.to_s\n      @has_errors = true\n    end",
    "comment": "Code to update values of assignment",
    "label": "what",
    "id": "170"
  },
  {
    "raw_code": "def update_assignment_questionnaires(attributes)\n    return if attributes.nil? || attributes.empty?\n\n    if attributes[0].key?(:questionnaire_weight)\n      validate_assignment_questionnaires_weights(attributes)\n      @errors = @assignment.errors.to_s\n      topic_id = nil\n    end",
    "comment": "code to save assignment questionnaires updated in the Rubrics and Topics tabs",
    "label": "what",
    "id": "171"
  },
  {
    "raw_code": "def validate_assignment_questionnaires_weights(attributes)\n    total_weight = 0\n    attributes.each do |assignment_questionnaire|\n      total_weight += assignment_questionnaire[:questionnaire_weight].to_i\n    end",
    "comment": "checks to see if the sum of weights of all rubrics add up to either 0 or 100%",
    "label": "what",
    "id": "172"
  },
  {
    "raw_code": "def update_tag_prompt_deployments(attributes)\n    unless attributes.nil?\n      attributes.each do |key, value|\n        if @assignment.vary_by_topic?\n          @assignment.questionnaires.uniq.each do |questionnaire|\n            # We need to use destroy_all to delete all the dependents also.\n            TagPromptDeployment.where(assignment_id: @assignment.id,questionnaire_id: questionnaire.id).destroy_all if value.key?('deleted')\n            next unless questionnaire.type == 'ReviewQuestionnaire' && value.key?('tag_prompt')\n            create_or_update_tag_prompt_deployments(questionnaire.id,value)\n          end",
    "comment": "s required by answer tagging",
    "label": "what",
    "id": "173"
  },
  {
    "raw_code": "def update_due_dates(attributes, user)\n    return false unless attributes\n\n    attributes.each do |due_date|\n      next if due_date[:due_at].blank?\n\n      # parse the dd and convert it to utc before saving it to db\n      # eg. 2015-06-22 12:05:00 -0400\n      current_local_time = Time.parse(due_date[:due_at][0..15])\n      tz = ActiveSupport::TimeZone[user.timezonepref].tzinfo\n      utc_time = tz.local_to_utc(Time.local(current_local_time.year,\n                                            current_local_time.month,\n                                            current_local_time.day,\n                                            current_local_time.strftime('%H').to_i,\n                                            current_local_time.strftime('%M').to_i,\n                                            current_local_time.strftime('%S').to_i))\n      due_date[:due_at] = utc_time\n      if due_date[:id].nil? || due_date[:id].blank?\n        dd = AssignmentDueDate.new(due_date)\n        @has_errors = true unless dd.save\n      else\n        dd = AssignmentDueDate.find(due_date[:id])\n        # get deadline for review\n        @has_errors = true unless dd.update_attributes(due_date)\n      end",
    "comment": "code to save due dates",
    "label": "what",
    "id": "174"
  },
  {
    "raw_code": "def update_assigned_badges(badge, assignment)\n    if assignment && badge\n      AssignmentBadge.where(assignment_id: assignment[:id]).map(&:id).each do |assigned_badge_id|\n        AssignmentBadge.delete(assigned_badge_id) unless badge[:id].include?(assigned_badge_id)\n      end",
    "comment": "Adds badges to assignment badges table as part of E1822",
    "label": "what",
    "id": "175"
  },
  {
    "raw_code": "def add_to_delayed_queue\n    duedates = AssignmentDueDate.where(parent_id: @assignment.id)\n    duedates.each do |due_date|\n      deadline_type = DeadlineType.find(due_date.deadline_type_id).name\n      diff_btw_time_left_and_threshold, min_left = get_time_diff_btw_due_date_and_now(due_date)\n      next unless diff_btw_time_left_and_threshold > 0\n\n      delayed_job_id = add_delayed_job(@assignment, deadline_type, due_date, diff_btw_time_left_and_threshold)\n      due_date.update_attribute(:delayed_job_id, delayed_job_id)\n      # If the deadline type is review, add a delayed job to drop outstanding review\n      add_delayed_job(@assignment, 'drop_outstanding_reviews', due_date, min_left) if deadline_type == 'review'\n      # If the deadline type is team_formation, add a delayed job to drop one member team\n      next unless (deadline_type == 'team_formation') && @assignment.team_assignment?\n\n      add_delayed_job(@assignment, 'drop_one_member_topics', due_date, min_left)\n    end",
    "comment": "Adds items to delayed_jobs queue for this assignment",
    "label": "what",
    "id": "176"
  },
  {
    "raw_code": "def assignment_questionnaire(questionnaire_type, round_number, topic_id, duty_id = nil)\n    round_number = nil if round_number.blank?\n    topic_id = nil if topic_id.blank?\n\n    # Default value of duty_id is nil, and when duty_id is not nil, then it means that the function call\n    # is made to access assignment_questionnaire of that particular duty. If questionnaires varies by duty,\n    # then find the relevant questionnaire and return.\n    if duty_id && @assignment.questionnaire_varies_by_duty\n      # Get all AQs for the assignment and specified duty_id\n      assignment_questionnaires = AssignmentQuestionnaire.where(assignment_id: @assignment.id, duty_id: duty_id)\n      assignment_questionnaires.each do |aq|\n        # If the AQ questionnaire matches the type of the questionnaire that needs to be updated, return it\n        return aq if aq.questionnaire_id && Questionnaire.find(aq.questionnaire_id).type == questionnaire_type\n      end",
    "comment": "Find an AQ based on the given values",
    "label": "what",
    "id": "177"
  },
  {
    "raw_code": "def questionnaire(assignment_questionnaire, questionnaire_type)\n    return Object.const_get(questionnaire_type).new if assignment_questionnaire.nil?\n\n    questionnaire = Questionnaire.find_by(id: assignment_questionnaire.questionnaire_id)\n    return questionnaire unless questionnaire.nil?\n\n    Object.const_get(questionnaire_type).new\n  end",
    "comment": "Find a questionnaire for the given AQ and questionnaire type",
    "label": "what",
    "id": "178"
  },
  {
    "raw_code": "def add_delayed_job(_assignment, deadline_type, due_date, min_left)\n    MailWorker.perform_in(min_left * 60, due_date.parent_id, deadline_type, due_date.due_at)\n  end",
    "comment": "add DelayedJob into queue and return it",
    "label": "what",
    "id": "179"
  },
  {
    "raw_code": "def delete_from_delayed_queue\n    queue = Sidekiq::Queue.new('mailers')\n    queue.each do |job|\n      assignmentId = job.args.first\n      job.delete if @assignment.id == assignmentId\n    end",
    "comment": "Deletes the job with id equal to \"delayed_job_id\" from the delayed_jobs queue",
    "label": "what",
    "id": "180"
  },
  {
    "raw_code": "def find_min_from_now(due_at)\n    curr_time = DateTime.now.in_time_zone('UTC').to_s(:db)\n    curr_time = Time.parse(curr_time)\n    ((due_at - curr_time).to_i / 60)\n  end",
    "comment": "This functions finds the epoch time in seconds of the due_at parameter and finds the difference of it from the current time and returns this difference in minutes",
    "label": "what",
    "id": "181"
  },
  {
    "raw_code": "def save\n    @assignment.save\n  end",
    "comment": "Save the assignment",
    "label": "what",
    "id": "182"
  },
  {
    "raw_code": "def create_assignment_node\n    @assignment.create_node unless @assignment.nil?\n  end",
    "comment": "create a node for the assignment",
    "label": "what",
    "id": "183"
  },
  {
    "raw_code": "def set_up_assignment_review\n    set_up_defaults\n    @assignment.directory_path = nil if @assignment.directory_path.empty?\n  end",
    "comment": "NOTE: many of these functions actually belongs to other models ====setup methods for new and edit method=====#",
    "label": "what",
    "id": "184"
  },
  {
    "raw_code": "def set_up_defaults\n    staggered_deadline\n    availability_flag\n    micro_task\n    reviews_visible_to_all\n    review_assignment_strategy\n    require_quiz\n  end",
    "comment": "NOTE: unfortunately this method is needed due to bad data in db @_@",
    "label": "what",
    "id": "185"
  },
  {
    "raw_code": "def self.copy(assignment_id, user)\n    Assignment.record_timestamps = false\n    old_assign = Assignment.find(assignment_id)\n    new_assign = old_assign.dup\n    user.set_instructor(new_assign)\n    new_assign.update_attribute('name', 'Copy of ' + new_assign.name)\n    new_assign.update_attribute('created_at', Time.now)\n    new_assign.update_attribute('updated_at', Time.now)\n    new_assign.update_attribute('directory_path', new_assign.directory_path + '_copy') if new_assign.directory_path.present?\n    new_assign.copy_flag = true\n    if new_assign.save\n      Assignment.record_timestamps = true\n      copy_assignment_questionnaire(old_assign, new_assign, user)\n      AssignmentDueDate.copy(old_assign.id, new_assign.id)\n      new_assign.create_node\n      new_assign_id = new_assign.id\n      # also copy topics from old assignment\n      topics = SignUpTopic.where(assignment_id: old_assign.id)\n      topics.each do |topic|\n        SignUpTopic.create(topic_name: topic.topic_name, assignment_id: new_assign_id, max_choosers: topic.max_choosers, category: topic.category, topic_identifier: topic.topic_identifier, micropayment: topic.micropayment)\n      end",
    "comment": "Copies the inputted assignment into new one and returns the new assignment id",
    "label": "what",
    "id": "186"
  },
  {
    "raw_code": "def self.allowed_types\n    # non-interpolated array of single-quoted strings\n    %w[Assignment Course]\n  end",
    "comment": "Allowed types of teams -- ASSIGNMENT teams or COURSE teams",
    "label": "what",
    "id": "187"
  },
  {
    "raw_code": "def participants\n    users.where(parent_id: parent_id || current_user_id).flat_map(&:participants)\n  end",
    "comment": "Get the participants of the given team",
    "label": "what",
    "id": "188"
  },
  {
    "raw_code": "def self.copy_content(source, destination)\n    source.each do |each_element|\n      each_element.copy(destination.id)\n    end",
    "comment": "copies content of one object to the another",
    "label": "what",
    "id": "189"
  },
  {
    "raw_code": "def self.team_operation\n    { inherit: 'inherit', bequeath: 'bequeath' }.freeze\n  end",
    "comment": "enum method for team clone operations",
    "label": "what",
    "id": "190"
  },
  {
    "raw_code": "def responses\n    participants.flat_map(&:responses)\n  end",
    "comment": "Get the response review map",
    "label": "what",
    "id": "191"
  },
  {
    "raw_code": "def delete\n    TeamsUser.where(team_id: id).find_each(&:destroy)\n    node = TeamNode.find_by(node_object_id: id)\n    node.destroy if node\n    destroy\n  end",
    "comment": "Delete the given team",
    "label": "what",
    "id": "192"
  },
  {
    "raw_code": "def node_type\n    'TeamNode'\n  end",
    "comment": "Get the node type of the tree structure",
    "label": "what",
    "id": "193"
  },
  {
    "raw_code": "def author_names\n    names = []\n    users.each do |user|\n      names << user.fullname\n    end",
    "comment": "Get the names of the users",
    "label": "what",
    "id": "194"
  },
  {
    "raw_code": "def user?(user)\n    users.include? user\n  end",
    "comment": "Check if the user exist",
    "label": "what",
    "id": "195"
  },
  {
    "raw_code": "def full?\n    return false if parent_id.nil? # course team, does not max_team_size\n\n    max_team_members = Assignment.find(parent_id).max_team_size\n    curr_team_size = Team.size(id)\n    curr_team_size >= max_team_members\n  end",
    "comment": "Check if the current team is full?",
    "label": "what",
    "id": "196"
  },
  {
    "raw_code": "def add_member(user, _assignment_id = nil)\n    raise \"The user #{user.name} is already a member of the team #{name}\" if user?(user)\n\n    can_add_member = false\n    unless full?\n      can_add_member = true\n      t_user = TeamsUser.create(user_id: user.id, team_id: id)\n      parent = TeamNode.find_by(node_object_id: id)\n      TeamUserNode.create(parent_id: parent.id, node_object_id: t_user.id)\n      add_participant(parent_id, user)\n      ExpertizaLogger.info LoggerMessage.new('Model:Team', user.name, \"Added member to the team #{id}\")\n    end",
    "comment": "Add member to the team, changed to hash by E1776",
    "label": "what",
    "id": "197"
  },
  {
    "raw_code": "def self.size(team_id)\n    #TeamsUser.where(team_id: team_id).count\n    count = 0\n    members = TeamsUser.where(team_id: team_id)\n    members.each do |member|\n      member_name = member.name\n      unless member_name.include?(' (Mentor)') \n        count = count + 1\n      end",
    "comment": "Define the size of the team",
    "label": "what",
    "id": "198"
  },
  {
    "raw_code": "def copy_members(new_team)\n    members = TeamsUser.where(team_id: id)\n    members.each do |member|\n      t_user = TeamsUser.create(team_id: new_team.id, user_id: member.user_id)\n      parent = Object.const_get(parent_model).find(parent_id)\n      TeamUserNode.create(parent_id: parent.id, node_object_id: t_user.id)\n    end",
    "comment": "Copy method to copy this team",
    "label": "what",
    "id": "199"
  },
  {
    "raw_code": "def self.check_for_existing(parent, name, team_type)\n    list = Object.const_get(team_type + 'Team').where(parent_id: parent.id, name: name)\n    raise TeamExistsError, \"The team name #{name} is already in use.\" unless list.empty?\n  end",
    "comment": "Check if the team exists",
    "label": "what",
    "id": "200"
  },
  {
    "raw_code": "def self.randomize_all_by_parent(parent, team_type, min_team_size)\n    participants = Participant.where(parent_id: parent.id, type: parent.class.to_s + 'Participant', can_mentor: [false, nil])\n    participants = participants.sort { rand(-1..1) }\n    users = participants.map { |p| User.find(p.user_id) }.to_a\n    # find teams still need team members and users who are not in any team\n    teams = Team.where(parent_id: parent.id, type: parent.class.to_s + 'Team').to_a\n    teams.each do |team|\n      TeamsUser.where(team_id: team.id).each do |teams_user|\n        users.delete(User.find(teams_user.user_id))\n      end",
    "comment": "Algorithm Start by adding single members to teams that are one member too small. Add two-member teams to teams that two members too small. etc.",
    "label": "what",
    "id": "201"
  },
  {
    "raw_code": "def self.create_team_from_single_users(min_team_size, parent, team_type, users)\n    num_of_teams = users.length.fdiv(min_team_size).ceil\n    next_team_member_index = 0\n    (1..num_of_teams).to_a.each do |i|\n      team = Object.const_get(team_type + 'Team').create(name: 'Team_' + i.to_s, parent_id: parent.id)\n      TeamNode.create(parent_id: parent.id, node_object_id: team.id)\n      min_team_size.times do\n        break if next_team_member_index >= users.length\n\n        user = users[next_team_member_index]\n        team.add_member(user, parent.id)\n        next_team_member_index += 1\n      end",
    "comment": "Creates teams from a list of users based on minimum team size Then assigns the created team to the parent object",
    "label": "what",
    "id": "202"
  },
  {
    "raw_code": "def self.assign_single_users_to_teams(min_team_size, parent, teams, users)\n    teams.each do |team|\n      curr_team_size = Team.size(team.id)\n      member_num_difference = min_team_size - curr_team_size\n      while member_num_difference > 0\n        team.add_member(users.first, parent.id)\n        users.delete(users.first)\n        member_num_difference -= 1\n        break if users.empty?\n      end",
    "comment": "Assigns list of users to list of teams based on minimum team size",
    "label": "what",
    "id": "203"
  },
  {
    "raw_code": "def self.generate_team_name(_team_name_prefix = '')\n    last_team = Team.where('name LIKE ?', \"#{_team_name_prefix} Team_%\")\n                  .order(\"CAST(SUBSTRING(name, LENGTH('#{_team_name_prefix} Team_') + 1) AS UNSIGNED) DESC\")\n                  .first\n    counter = last_team ? last_team.name.scan(/\\d+/).first.to_i + 1 : 1\n    team_name = \"#{_team_name_prefix} Team_#{counter}\"\n    team_name\n  end",
    "comment": "Generate the team name",
    "label": "what",
    "id": "204"
  },
  {
    "raw_code": "def import_team_members(row_hash)\n    row_hash[:teammembers].each_with_index do |teammate, _index|\n      user = User.find_by(name: teammate.to_s)\n      if user.nil?\n        raise ImportError, \"The user '#{teammate}' was not found. <a href='/users/new'>Create</a> this user?\"\n      else\n        add_member(user) if TeamsUser.find_by(team_id: id, user_id: user.id).nil?\n      end",
    "comment": "Extract team members from the csv and push to DB,  changed to hash by E1776",
    "label": "what",
    "id": "205"
  },
  {
    "raw_code": "def self.import(row_hash, id, options, teamtype)\n    raise ArgumentError, 'Not enough fields on this line.' if row_hash.empty? || (row_hash[:teammembers].empty? && (options[:has_teamname] == 'true_first' || options[:has_teamname] == 'true_last')) || (row_hash[:teammembers].empty? && (options[:has_teamname] == 'true_first' || options[:has_teamname] == 'true_last'))\n    if options[:has_teamname] == 'true_first' || options[:has_teamname] == 'true_last'\n      name = row_hash[:teamname].to_s\n      team = where(['name =? && parent_id =?', name, id]).first\n      team_exists = !team.nil?\n      name = handle_duplicate(team, name, id, options[:handle_dups], teamtype)\n    else\n      if (teamtype == CourseTeam)\n        name = generate_team_name(Course.find(id).name)\n      elsif (teamtype == AssignmentTeam || teamtype == MentoredTeam)\n        name = generate_team_name(Assignment.find(id).name)\n      end",
    "comment": "changed to hash by E1776",
    "label": "what",
    "id": "206"
  },
  {
    "raw_code": "def self.handle_duplicate(team, name, id, handle_dups, teamtype)\n    return name if team.nil? # no duplicate\n    return nil if handle_dups == 'ignore' # ignore: do not create the new team\n\n    if handle_dups == 'rename' # rename: rename new team\n      if teamtype.is_a?(CourseTeam)\n        return generate_team_name(Course.find(id).name)\n      elsif  teamtype.is_a?(AssignmentTeam)\n        return generate_team_name(Assignment.find(id).name)\n      end",
    "comment": "Handle existence of the duplicate team",
    "label": "what",
    "id": "207"
  },
  {
    "raw_code": "def self.export(csv, parent_id, options, teamtype)\n    if teamtype.is_a?(CourseTeam)\n      teams = CourseTeam.where(parent_id: parent_id)\n    elsif teamtype.is_a?(AssignmentTeam)\n      teams = AssignmentTeam.where(parent_id: parent_id)\n    end",
    "comment": "Export the teams to csv",
    "label": "what",
    "id": "208"
  },
  {
    "raw_code": "def self.create_team_and_node(id)\n    parent = parent_model id # current_task will be either a course object or an assignment object.\n    team_name = Team.generate_team_name(parent.name)\n    team = create(name: team_name, parent_id: id)\n    # new teamnode will have current_task.id as parent_id and team_id as node_object_id.\n    TeamNode.create(parent_id: id, node_object_id: team.id)\n    ExpertizaLogger.info LoggerMessage.new('Model:Team', '', \"New TeamNode created with teamname #{team_name}\")\n    team\n  end",
    "comment": "Create the team with corresponding tree node",
    "label": "what",
    "id": "209"
  },
  {
    "raw_code": "def name(ip_address = nil)\n    if User.anonymized_view?(ip_address)\n      return \"Anonymized_Team_#{self[:id]}\"\n    else\n      return self[:name]\n    end",
    "comment": "E1991 : This method allows us to generate team names based on whether anonymized view is set or not. The logic is similar to existing logic of User model.",
    "label": "what",
    "id": "210"
  },
  {
    "raw_code": "def self.create_team_with_users(parent_id, user_ids)\n    team = create_team_and_node(parent_id)\n\n    user_ids.each do |user_id|\n      remove_user_from_previous_team(parent_id, user_id)\n\n      # Create new team_user and team_user node\n      team.add_member(User.find(user_id))\n    end",
    "comment": "Create the team with corresponding tree node and given users",
    "label": "what",
    "id": "211"
  },
  {
    "raw_code": "def self.remove_user_from_previous_team(parent_id, user_id)\n    team_user = TeamsUser.where(user_id: user_id).find { |team_user_obj| team_user_obj.team.parent_id == parent_id }\n    begin\n      team_user.destroy\n    rescue StandardError\n      nil\n    end",
    "comment": "Removes the specified user from any team of the specified assignment",
    "label": "what",
    "id": "212"
  },
  {
    "raw_code": "def question_max_score\n    question = Question.find(question_id)\n    if question.type == 'Checkbox'\n      1\n    elsif question.is_a? ScoredQuestion\n      @question_max_score\n    else\n      'N/A'\n    end",
    "comment": "the question max score is the max score of the questionnaire, except if the question is a true/false, in which case the max score is one.",
    "label": "what",
    "id": "213"
  },
  {
    "raw_code": "def reviewers\n    reviewers = []\n    rmaps = ReviewResponseMap.where('reviewee_id = ?', team.id)\n    rmaps.each do |rm|\n      reviewers.push(AssignmentParticipant.find(rm.reviewer_id))\n    end",
    "comment": "all the participants in this assignment who have reviewed the team where this participant belongs",
    "label": "what",
    "id": "214"
  },
  {
    "raw_code": "def set_current_user(current_user); end\n\n  # Copy this participant to a course\n  def copy_to_course(course_id)\n    CourseParticipant.find_or_create_by(user_id: user_id, parent_id: course_id)\n  end\n\n  def feedback\n    FeedbackResponseMap.assessments_for(self)\n  end\n\n  def reviews\n    # ACS Always get assessments for a team\n    # removed check to see if it is a team assignment\n    ReviewResponseMap.assessments_for(team)\n  end\n\n  # returns the reviewer of the assignment. Checks the team_reviewing_enabled flag to\n  # determine whether this AssignmentParticipant or their team is the reviewer\n  def get_reviewer\n    return team if assignment.team_reviewing_enabled\n\n    self\n  end\n\n  # polymorphic twin of method in AssignmentTeam\n  # this method is called to check if the current user is this one\n  def get_logged_in_reviewer_id(_current_user_id)\n    id\n  end\n\n  # checks if this assignment participant is the currently logged on user, given their user id\n  def current_user_is_reviewer?(current_user_id)\n    user_id == current_user_id\n  end\n\n  def quizzes_taken\n    QuizResponseMap.assessments_for(self)\n  end\n\n  def metareviews\n    MetareviewResponseMap.assessments_for(self)\n  end\n\n  def teammate_reviews\n    TeammateReviewResponseMap.assessments_for(self)\n  end\n\n  def bookmark_reviews\n    BookmarkRatingResponseMap.assessments_for(self)\n  end\n\n  def files(directory)\n    files_list = Dir[directory + '/*']\n    files = []\n\n    files_list.each do |file|\n      if File.directory?(file)\n        dir_files = files(file)\n        dir_files.each { |f| files << f }\n      end\n      files << file\n    end",
    "comment": "E1973, dummy method to match the functionality of AssignmentTeam",
    "label": "what",
    "id": "215"
  },
  {
    "raw_code": "def assign_copyright(private_key)\n    # now, check to make sure the digital signature is valid, if not raise error\n    self.permission_granted = verify_digital_signature(private_key)\n    save\n    raise 'Invalid key' unless permission_granted\n  end",
    "comment": "grant publishing rights to one or more assignments. Using the supplied private key, digital signatures are generated. reference: http://stuff-things.net/2008/02/05/encrypting-lots-of-sensitive-data-with-ruby-on-rails/",
    "label": "what",
    "id": "216"
  },
  {
    "raw_code": "def verify_digital_signature(private_key)\n    user.public_key == OpenSSL::PKey::RSA.new(private_key).public_key.to_pem\n  end",
    "comment": "verify the digital signature is valid",
    "label": "what",
    "id": "217"
  },
  {
    "raw_code": "def set_handle\n    self.handle = if user.handle.nil? || (user.handle == '')\n                    user.name\n                  elsif AssignmentParticipant.exists?(parent_id: assignment.id, handle: user.handle)\n                    user.name\n                  else\n                    user.handle\n                  end",
    "comment": "define a handle for a new participant",
    "label": "what",
    "id": "218"
  },
  {
    "raw_code": "def review_file_path(response_map_id = nil, participant = nil)\n    if response_map_id.nil?\n      return if participant.nil?\n\n      no_team_path = assignment.path + '/' + participant.name.parameterize(separator: '_') + '_review'\n      return no_team_path if participant.team.nil?\n    end",
    "comment": "zhewei: this is the file path for reviewer to upload files during peer review",
    "label": "what",
    "id": "219"
  },
  {
    "raw_code": "def duty_id\n    participant = team_user\n    return participant.duty_id if participant\n  end",
    "comment": "E2147 : Gets duty id of the assignment participant by mapping teams user with help of user_id. Will no longer be needed once teams_user is converted into participant_teams",
    "label": "what",
    "id": "220"
  },
  {
    "raw_code": "def edit(_count)\n    html = '<tr>'\n    html += '<td align=\"center\"><a rel=\"nofollow\" data-method=\"delete\" href=\"/questions/' + id.to_s + '\">Remove</a></td>'\n    html += '<td><input size=\"6\" value=\"' + seq.to_s + '\" name=\"question[' + id.to_s + '][seq]\" id=\"question_' + id.to_s + '_seq\" type=\"text\"></td>'\n    html += '<td><textarea cols=\"50\" rows=\"1\" name=\"question[' + id.to_s + '][txt]\" id=\"question_' + id.to_s + '_txt\" placeholder=\"Edit question content here\">' + txt + '</textarea></td>'\n    html += '<td><input size=\"10\" disabled=\"disabled\" value=\"' + type.to_s + '\" name=\"question[' + id.to_s + '][type]\" id=\"question_' + id.to_s + '_type\" type=\"text\"></td>'\n    html += '<td><!--placeholder (TextResponse does not need weight)--></td>'\n    html += '<td>text area size <input size=\"6\" value=\"' + size.to_s + '\" name=\"question[' + id.to_s + '][size]\" id=\"question_' + id.to_s + '_size\" type=\"text\"></td>'\n    html += '</tr>'\n\n    html.html_safe\n  end",
    "comment": "This method returns what to display if an instructor (etc.) is creating or editing a questionnaire (questionnaires_controller.rb)",
    "label": "what",
    "id": "221"
  },
  {
    "raw_code": "def view_question_text\n    html = '<TR><TD align=\"left\"> ' + txt + ' </TD>'\n    html += '<TD align=\"left\">' + type + '</TD>'\n    html += '<td align=\"center\">' + weight.to_s + '</TD>'\n    html += '<TD align=\"center\">&mdash;</TD>'\n    html += '</TR>'\n    html.html_safe\n  end",
    "comment": "This method returns what to display if an instructor (etc.) is viewing a questionnaire",
    "label": "what",
    "id": "222"
  },
  {
    "raw_code": "def get_available_roles\n    ids = []\n\n    current = parent_id\n    while current\n      role = Role.find(current)\n      next unless role\n\n      unless ids.index(role.id)\n        ids << role.id\n        current = role.parent_id\n      end",
    "comment": "return ids of roles that are below this role",
    "label": "what",
    "id": "223"
  },
  {
    "raw_code": "def get_parents\n    parents = []\n    seen = {}\n\n    current = id\n\n    while current\n      role = Role.find(current)\n      if role\n        if seen.key?(role.id)\n          current = nil\n        else\n          parents << role\n          seen[role.id] = true\n          current = role.parent_id\n        end",
    "comment": "\"parents\" are lesser roles. This returns a list including this role and all lesser roles.",
    "label": "what",
    "id": "224"
  },
  {
    "raw_code": "def readonly?\n    false\n  end",
    "comment": "setting this to false so that factories can be created to test the grading of weighted quiz questionnaires",
    "label": "what",
    "id": "225"
  },
  {
    "raw_code": "def true_false_questions?\n    questions.each { |question| return true if question.type == 'Checkbox' }\n    false\n  end",
    "comment": "Does this questionnaire contain true/false questions?",
    "label": "what",
    "id": "226"
  },
  {
    "raw_code": "def self.copy_questionnaire_details(params, instructor_id)\n    orig_questionnaire = Questionnaire.find(params[:id])\n    questions = Question.where(questionnaire_id: params[:id])\n    questionnaire = orig_questionnaire.dup\n    questionnaire.instructor_id = instructor_id\n    questionnaire.name = 'Copy of ' + orig_questionnaire.name\n    questionnaire.created_at = Time.zone.now\n    questionnaire.save!\n    questions.each do |question|\n      new_question = question.dup\n      new_question.questionnaire_id = questionnaire.id\n      new_question.size = '50,3' if (new_question.is_a?(Criterion) || new_question.is_a?(TextResponse)) && new_question.size.nil?\n      new_question.save!\n      advices = QuestionAdvice.where(question_id: question.id)\n      next if advices.empty?\n\n      advices.each do |advice|\n        new_advice = advice.dup\n        new_advice.question_id = new_question.id\n        new_advice.save!\n      end",
    "comment": "clones the contents of a questionnaire, including the questions and associated advice",
    "label": "what",
    "id": "227"
  },
  {
    "raw_code": "def validate_questionnaire\n    errors.add(:max_question_score, 'The maximum question score must be a positive integer.') if max_question_score < 1\n    errors.add(:min_question_score, 'The minimum question score must be a positive integer.') if min_question_score < 0\n    errors.add(:min_question_score, 'The minimum question score must be less than the maximum.') if min_question_score >= max_question_score\n\n    results = Questionnaire.where('id <> ? and name = ? and instructor_id = ?', id, name, instructor_id)\n    errors.add(:name, 'Questionnaire names must be unique.') if results.present?\n  end",
    "comment": "validate the entries for this questionnaire",
    "label": "what",
    "id": "228"
  },
  {
    "raw_code": "def candidate_topics_for_quiz\n    return nil if sign_up_topics.empty? # This is not a topic assignment\n\n    contributor_set = Array.new(contributors)\n    # Reject contributors that have not selected a topic, or have no submissions\n    contributor_set.reject! { |contributor| signed_up_topic(contributor).nil? }\n\n    # Reject contributions of topics whose deadline has passed\n    contributor_set.reject! do |contributor|\n      (contributor.assignment.current_stage(signed_up_topic(contributor).id) == 'Complete') ||\n        (contributor.assignment.current_stage(signed_up_topic(contributor).id) == 'submission')\n    end",
    "comment": "Returns a set of topics that can be used for taking the quiz. We choose the topics if one of its quiz submissions has been attempted the fewest times so far",
    "label": "what",
    "id": "229"
  },
  {
    "raw_code": "def contributor_for_quiz(reviewer, topic)\n    raise 'Please select a topic.' if topics? && topic.nil?\n    raise 'This assignment does not have topics.' unless topics? || !topic\n\n    # This condition might happen if the reviewer/quiz taker waited too much time in the\n    # select topic page and other students have already selected this topic.\n    # Another scenario is someone that deliberately modifies the view.\n    if topic\n      raise 'Too many quizzes have been taken for this topic; please select another one.' unless candidate_topics_for_quiz.include?(topic)\n    end",
    "comment": "Returns a contributor whose quiz is to be taken if available, otherwise will raise an error",
    "label": "what",
    "id": "230"
  },
  {
    "raw_code": "def cycle_similarity_score(cycle)\n    similarity_score = 0.0\n    count = 0.0\n    (0...cycle.size - 1).each do |pivot|\n      pivot_score = cycle[pivot][1]\n      (pivot + 1...cycle.size).each do |other|\n        similarity_score += (pivot_score - cycle[other][1]).abs\n        count += 1.0\n      end",
    "comment": "Per cycle",
    "label": "what",
    "id": "231"
  },
  {
    "raw_code": "def cycle_deviation_score(cycle)\n    deviation_score = 0.0\n    count = 0.0\n    (0...cycle.size).each do |member|\n      participant = AssignmentParticipant.find(cycle[member][0].id)\n      total_score = participant.review_score\n      deviation_score += (total_score - cycle[member][1]).abs\n      count += 1.0\n    end",
    "comment": "Per cycle",
    "label": "what",
    "id": "232"
  },
  {
    "raw_code": "def self.table\n    'teams'\n  end",
    "comment": "attr_accessible :parent_id, :node_object_id  # unnecessary protected attributes",
    "label": "what",
    "id": "233"
  },
  {
    "raw_code": "def edit(_count)\n    html = '<td align=\"center\"><a rel=\"nofollow\" data-method=\"delete\" href=\"/questions/' + id.to_s + '\">Remove</a></td>'\n    html += '<td><input size=\"6\" value=\"' + seq.to_s + '\" name=\"question[' + id.to_s + '][seq]\"'\n    html += ' id=\"question_' + id.to_s + '_seq\" type=\"text\"></td>'\n    html += '<td><textarea cols=\"50\" rows=\"1\" name=\"question[' + id.to_s + '][txt]\"'\n    html += ' id=\"question_' + id.to_s + '_txt\" placeholder=\"Edit question content here\">' + txt + '</textarea></td>'\n    html += '<td><input size=\"10\" disabled=\"disabled\" value=\"' + type + '\" name=\"question[' + id.to_s + '][type]\"'\n    html += ' id=\"question_' + id.to_s + '_type\" type=\"text\"></td>'\n    html += '<td><input size=\"2\" value=\"' + weight.to_s\n    html += '\" name=\"question[' + id.to_s + '][weight]\" id=\"question_' + id.to_s + '_weight\" type=\"text\"></td>'\n    html += '<td>text area size <input size=\"3\" value=\"' + size.to_s\n    html += '\" name=\"question[' + id.to_s + '][size]\" id=\"question_' + id.to_s + '_size\" type=\"text\"></td>'\n    safe_join(['<tr>'.html_safe, '</tr>'.html_safe], html.html_safe)\n  end",
    "comment": "method is called during creation of questionnaire --> when cake type is added to the questionnaire.",
    "label": "what",
    "id": "234"
  },
  {
    "raw_code": "def view_question_text\n    html = '<TD align=\"left\"> ' + txt + ' </TD>'\n    html += '<TD align=\"left\">' + type + '</TD>'\n    html += '<td align=\"center\">' + weight.to_s + '</TD>'\n    questionnaire = self.questionnaire\n    html += '<TD align=\"center\">' + questionnaire.min_question_score.to_s + ' to ' + questionnaire.max_question_score.to_s + '</TD>'\n    safe_join(['<TR>'.html_safe, '</TR>'.html_safe], html.html_safe)\n  end",
    "comment": "Method called after clicking on View Questionnaire option",
    "label": "what",
    "id": "235"
  },
  {
    "raw_code": "def complete(count, answer = nil, total_score)\n    if size.nil?\n      cols = '70'\n      rows = '1'\n    else\n      cols = size.split(',')[0]\n      rows = size.split(',')[1]\n    end",
    "comment": "Method is called when completing the percentage contribution text box for a cake question in a review",
    "label": "what",
    "id": "236"
  },
  {
    "raw_code": "def view_completed_question(count, answer)\n    score = answer && !answer.answer.nil? ? answer.answer.to_s : '-'\n    html = '<b>' + count.to_s + '. ' + txt + '</b>'\n    html += '<div class=\"c5\" style=\"width:30px; height:30px;' \\\n      ' border-radius:50%; font-size:15px; color:black; line-height:30px; text-align:center;\">'\n    html += score\n    html += '</div>'\n    html += '<b>Comments:</b>' + answer.comments.to_s\n    safe_join([''.html_safe, ''.html_safe], html.html_safe)\n  end",
    "comment": "This method returns what to display if a student is viewing a filled-out questionnaire",
    "label": "what",
    "id": "237"
  },
  {
    "raw_code": "def self.get_total_score_for_questions(review_type, questions, participant_id, assignment_id, reviewee_id)\n    total_scores = {}\n    questions.each do |question|\n      next unless question.instance_of? Cake\n\n      total_score = question.get_total_score_for_question(review_type, question.id, participant_id, assignment_id, reviewee_id).to_s\n      total_score = 0 if total_score.nil?\n      total_scores[question.id] = total_score\n    end",
    "comment": "E2218: This Method returns the total cake score for each question. Its called from the model new method in response controller. @param review_type  [String] @param questions [Array] @param participant_id [Integer] @param assignment_id [Integer] @param reviewee_id [Integer] @return total_scores - a hash with key as question_id and values as total score for each cake question",
    "label": "what",
    "id": "238"
  },
  {
    "raw_code": "def get_total_score_for_question(review_type, question_id, participant_id, assignment_id, reviewee_id)\n    # get the reviewer's team id for the currently answered question\n    team_id = Team.joins([:teams_users, teams_users: [{ user: :participants }]]).where('participants.id = ? and teams.parent_id in (?)', participant_id, assignment_id).first\n    team_id = team_id.id if team_id\n    if review_type == 'TeammateReviewResponseMap'\n      answers_for_team_members = get_answers_for_teammatereview(team_id, question_id, participant_id, assignment_id, reviewee_id)\n    end",
    "comment": "Finds all teammates and calculates the total contribution of all members for the question",
    "label": "what",
    "id": "239"
  },
  {
    "raw_code": "def get_answers_for_teammatereview(team_id, question_id, participant_id, assignment_id, reviewee_id)\n    # get the reviewer's team members for the currently answered question\n    team_members = Participant.joins(user: :teams_users).where('teams_users.team_id in (?) and participants.parent_id in (?)', team_id, assignment_id).ids\n    # get the reviewer's ratings for his team members\n    Answer.joins([{ response: :response_map }, :question]).where(\"response_maps.reviewee_id in (?) and response_maps.reviewed_object_id = (?)\n      and answer is not null and response_maps.reviewer_id in (?) and answers.question_id in (?) and response_maps.reviewee_id not in (?)\", team_members, assignment_id, participant_id, question_id, reviewee_id).to_a\n  end",
    "comment": "Finds the scores for all teammates for this question",
    "label": "what",
    "id": "240"
  },
  {
    "raw_code": "def calculate_total_score(question_answers)\n    question_score = 0.0\n    question_answers.each do |question_answer|\n      # calculate score per question\n      unless question_answer.answer.nil?\n        question_score += question_answer.answer\n      end",
    "comment": "Sums up the scores given by all teammates that should be less than or equal to 100",
    "label": "what",
    "id": "241"
  },
  {
    "raw_code": "def self.save_token(user, token)\n    password_reset = PasswordReset.find_by(user_email: user.email)\n    if password_reset\n      password_reset.token = Digest::SHA1.hexdigest(token)\n      password_reset.save!\n    else\n      PasswordReset.create(user_email: user.email, token: Digest::SHA1.hexdigest(token))\n    end",
    "comment": "attr_accessible :user_email, :token",
    "label": "what",
    "id": "242"
  },
  {
    "raw_code": "def self.team_id(assignment_id, user_id)\n    # team_id variable represents the team_id for this user in this assignment\n    team_id = nil\n    teams_users = TeamsUser.where(user_id: user_id)\n    teams_users.each do |teams_user|\n      if teams_user.team_id == nil\n        next\n      end",
    "comment": "2015-5-27 [zhewei]: We just remove the topic_id field from the participants table.",
    "label": "what",
    "id": "243"
  },
  {
    "raw_code": "def self.merge_bids_from_different_users(team_id, sign_up_topics, users_bidding_info)\n    # Select data from `users_bidding_info` variable and transpose it.\n    # For example, if users_bidding_infos is [[1, 0, 2, 2], [2, 1, 3, 0], [3, 2, 1, 1]]\n    # transformation's result will be matrix with 4 topics (key) and corresponding priorities\n    # given by 3 team members (value).\n    # {\n    #   1: [1, 2, 3],\n    #   2: [0, 1, 2],\n    #   3: [2, 3, 1],\n    #   4: [2, 0, 1]\n    # }\n    bidding_matrix = Hash.new { |hash, key| hash[key] = [] }\n    users_bidding_info.each do |bids|\n      sign_up_topics.each_with_index do |topic, index|\n        bidding_matrix[topic.id] << bids[index]\n      end",
    "comment": "Create new bids for team based on `ranks` variable for each team member Structure of users_bidding_info variable: [[topic_1_priority, topic_2_priority, ...], [topic_1_priority, topic_2_priority, ...], ...] Currently, it is possible (already proved by db records) that some teams have multiple 1st priority, multiply 2nd priority. these multiple identical priorities come from different previous teams [Future work]: we need to find a better way to merge bids that came from different previous teams",
    "label": "what",
    "id": "244"
  },
  {
    "raw_code": "def self.get_latest_assignment(questionnaire_id)\n    record = includes(:assignment).where(questionnaire_id: questionnaire_id).order('assignments.created_at').last\n    return record.assignment, record.used_in_round unless record.nil?\n  end",
    "comment": "Method to find the most recent created_at record and return that record's assignment and round #",
    "label": "what",
    "id": "245"
  },
  {
    "raw_code": "def self.get_questions_by_assignment_id(assignment_id)\n    AssignmentQuestionnaire.find_by(['assignment_id = ? and questionnaire_id IN (?)',\n                                     Assignment.find(assignment_id).id, ReviewQuestionnaire.select('id')])\n                           .questionnaire.questions.reject { |q| q.is_a?(QuestionnaireHeader) }\n  end",
    "comment": "E2218 @param assignment_id [Integer] @return questions corresponding to the assignment_id and review questionnaire questions that are not headers",
    "label": "what",
    "id": "246"
  },
  {
    "raw_code": "def questionnaire(round_number = nil, topic_id = nil)\n    Questionnaire.find(assignment.review_questionnaire_id(round_number, topic_id))\n  end",
    "comment": "Find a review questionnaire associated with this self-review response map's assignment",
    "label": "what",
    "id": "247"
  },
  {
    "raw_code": "def contributor\n    Team.find_by(id: reviewee_id)\n  end",
    "comment": "This method helps to find contributor - here Team ID",
    "label": "what",
    "id": "248"
  },
  {
    "raw_code": "def get_title\n    'Self Review'\n  end",
    "comment": "This method returns 'Title' of type of review (used to manipulate headings accordingly)",
    "label": "what",
    "id": "249"
  },
  {
    "raw_code": "def email(defn, participant, assignment); end\nend",
    "comment": "do not send any reminder for self review received.",
    "label": "what",
    "id": "250"
  },
  {
    "raw_code": "def self.table\n    'assignments'\n  end",
    "comment": "Returns the table in which to locate Assignments",
    "label": "what",
    "id": "251"
  },
  {
    "raw_code": "def self.get(sortvar = nil, sortorder = nil, user_id = nil, show = nil, parent_id = nil, _search = nil)\n    if show\n      conditions = if User.find(user_id).role.name != 'Teaching Assistant'\n                     'assignments.instructor_id = ?'\n                   else\n                     'assignments.course_id in (?)'\n                   end",
    "comment": "returns: list of AssignmentNodes based on query",
    "label": "what",
    "id": "252"
  },
  {
    "raw_code": "def is_leaf\n    true\n  end",
    "comment": "Indicates that this object is always a leaf",
    "label": "what",
    "id": "253"
  },
  {
    "raw_code": "def get_teams\n    TeamNode.get(node_object_id)\n  end",
    "comment": "Gets any TeamNodes associated with this object",
    "label": "what",
    "id": "254"
  },
  {
    "raw_code": "def content_html\n    if content_cache.present?\n      content_cache.html_safe\n    else\n      markup_content.html_safe\n    end",
    "comment": "rubocop:disable Lint/DuplicateMethods",
    "label": "what",
    "id": "255"
  },
  {
    "raw_code": "def initialize(role_id)\n    @role_id = role_id\n\n    role = Role.find(@role_id)\n    @updated_at = role.updated_at\n\n    @role_ids = role.get_parents.map(&:id)\n  end",
    "comment": "Create a new credentials object for the given role",
    "label": "what",
    "id": "256"
  },
  {
    "raw_code": "def questionnaire_by_duty(duty_id)\n    duty_questionnaire = AssignmentQuestionnaire.where(assignment_id: assignment.id, duty_id: duty_id).first\n    if duty_questionnaire.nil?\n      questionnaire\n    else\n      Questionnaire.find(duty_questionnaire.questionnaire_id)\n    end",
    "comment": "E2147 : gets questionnaire for a particular duty. If no questionnaire is found for the given duty, returns the default questionnaire set for TeammateReviewQuestionnaire type.",
    "label": "what",
    "id": "257"
  },
  {
    "raw_code": "def email(defn, _participant, assignment)\n    defn[:body][:type] = 'Teammate Review'\n    participant = AssignmentParticipant.find(reviewee_id)\n    defn[:body][:obj_name] = assignment.name\n    user = User.find(participant.user_id)\n    defn[:body][:first_name] = user.fullname\n    defn[:to] = user.email\n    Mailer.sync_message(defn).deliver\n  end",
    "comment": "Send Teammate Review Emails Refactored from email method in response.rb",
    "label": "what",
    "id": "258"
  },
  {
    "raw_code": "def after_initialize\n    # If an assignment supports team reviews, it is marked in each mapping\n    assignment.team_reviewing_enabled\n  end",
    "comment": "Added for E1973: http://wiki.expertiza.ncsu.edu/index.php/CSC/ECE_517_Fall_2019_-_Project_E1973._Team_Based_Reviewing ReviewResponseMap was created in so many places, I thought it best to add this here as a catch-all",
    "label": "what",
    "id": "259"
  },
  {
    "raw_code": "def questionnaire(round_number = nil, topic_id = nil)\n    Questionnaire.find(assignment.review_questionnaire_id(round_number, topic_id))\n  end",
    "comment": "Find a review questionnaire associated with this review response map's assignment",
    "label": "what",
    "id": "260"
  },
  {
    "raw_code": "def self.get_responses_for_team_round(team, round)\n    responses = []\n    if team.id\n      maps = ResponseMap.where(reviewee_id: team.id, type: 'ReviewResponseMap')\n      maps.each do |map|\n        if map.response.any? && map.response.reject { |r| (r.round != round || !r.is_submitted) }.any?\n          responses << map.response.reject { |r| (r.round != round || !r.is_submitted) }.last\n        end",
    "comment": "return the responses for specified round, for varying rubric feature -Yang",
    "label": "what",
    "id": "261"
  },
  {
    "raw_code": "def get_reviewer\n    ReviewResponseMap.get_reviewer_with_id(assignment.id, reviewer_id)\n  end",
    "comment": "E-1973 - returns the reviewer of the response, either a participant or a team",
    "label": "what",
    "id": "262"
  },
  {
    "raw_code": "def self.get_reviewer_with_id(assignment_id, reviewer_id)\n    assignment = Assignment.find(assignment_id)\n    if assignment.team_reviewing_enabled\n      return AssignmentTeam.find(reviewer_id)\n    else\n      return AssignmentParticipant.find(reviewer_id)\n    end",
    "comment": "E-1973 - gets the reviewer of the response, given the assignment and the reviewer id the assignment is used to determine if the reviewer is a participant or a team",
    "label": "what",
    "id": "263"
  },
  {
    "raw_code": "def self.final_versions_from_reviewer(assignment_id, reviewer_id)\n    reviewer = ReviewResponseMap.get_reviewer_with_id(assignment_id, reviewer_id)\n    maps = ReviewResponseMap.where(reviewer_id: reviewer_id)\n    assignment = Assignment.find(reviewer.parent_id)\n    prepare_final_review_versions(assignment, maps)\n  end",
    "comment": "wrap latest version of responses in each response map, together with the questionnaire_id will be used to display the reviewer summary",
    "label": "what",
    "id": "264"
  },
  {
    "raw_code": "def get_teams\n    CourseTeam.where(parent_id: id)\n  end",
    "comment": "Return any predefined teams associated with this course Author: ajbudlon Date: 7/21/2008",
    "label": "what",
    "id": "265"
  },
  {
    "raw_code": "def path\n    raise 'Path can not be created. The course must be associated with an instructor.' if instructor_id.nil?\n\n    Rails.root + '/pg_data/' + FileHelper.clean_path(User.find(instructor_id).name) + '/' + FileHelper.clean_path(directory_path) + '/'\n  end",
    "comment": "Returns this object's submission directory",
    "label": "what",
    "id": "266"
  },
  {
    "raw_code": "def get_assessments_round_for(participant, round)\n    team = AssignmentTeam.team(participant)\n    return nil unless team\n\n    team_id = team.id\n    responses = []\n    if participant\n      maps = ResponseMap.where(reviewee_id: team_id, type: 'ReviewResponseMap')\n      maps.each do |map|\n        next if map.response.empty?\n\n        map.response.each do |response|\n          responses << response if response.round == round && response.is_submitted\n        end",
    "comment": "return  the responses for specified round, for varying rubric feature -Yang",
    "label": "what",
    "id": "267"
  },
  {
    "raw_code": "def calculate_metrics\n    number_of_comments_greater_than_10_words\n    number_of_comments_greater_than_20_words\n  end",
    "comment": "This method calls all the methods that are responsible for calculating different metrics.If any new metric is introduced, please call the method that calculates the metric values from this method.",
    "label": "what",
    "id": "268"
  },
  {
    "raw_code": "def number_of_comments_greater_than_10_words\n    @list_of_reviews.each do |review|\n      answers = Answer.where(response_id: review.response_id)\n      answers.each do |answer|\n        @list_of_rows.each do |row|\n          row.metric_hash[\"> 10 Word Comments\"] = 0 if row.metric_hash[\"> 10 Word Comments\"].nil?\n          row.metric_hash[\"> 10 Word Comments\"] = row.metric_hash[\"> 10 Word Comments\"] + 1 if row.question_id == answer.question_id && answer.comments && answer.comments.split.size > 10\n        end",
    "comment": "This method is responsible for checking whether a review comment contains more than 10 words.",
    "label": "what",
    "id": "269"
  },
  {
    "raw_code": "def number_of_comments_greater_than_20_words\n    @list_of_reviews.each do |review|\n      answers = Answer.where(response_id: review.response_id)\n      answers.each do |answer|\n        @list_of_rows.each do |row|\n          row.metric_hash[\"> 20 Word Comments\"] = 0 if row.metric_hash[\"> 20 Word Comments\"].nil?\n          row.metric_hash[\"> 20 Word Comments\"] = row.metric_hash[\"> 20 Word Comments\"] + 1 if row.question_id == answer.question_id && answer.comments && answer.comments.split.size > 20\n        end",
    "comment": "In case if new metirc is added. This is a dummy metric added for manual testing and will be removed.",
    "label": "what",
    "id": "270"
  },
  {
    "raw_code": "def copy(assignment_id)\n    part = AssignmentParticipant.where(user_id: user_id, parent_id: assignment_id).first\n    if part.nil?\n      part = AssignmentParticipant.create(user_id: user_id, parent_id: assignment_id)\n      part.set_handle\n      part\n    end",
    "comment": "Copy this participant to an assignment",
    "label": "what",
    "id": "271"
  },
  {
    "raw_code": "def self.import(row_hash, _row_header = nil, session, id)\n    raise ArgumentError, 'No user id has been specified.' if row_hash.empty?\n\n    user = User.find_by(name: row_hash[:username])\n    if user.nil?\n      raise ArgumentError, \"The record containing #{row_hash[:username]} does not have enough items.\" if row_hash.length < 4\n\n      attributes = ImportFileHelper.define_attributes(row_hash)\n      user = ImportFileHelper.create_new_user(attributes, session)\n    end",
    "comment": "provide import functionality for Course Participants if user does not exist, it will be created and added to this assignment",
    "label": "what",
    "id": "272"
  },
  {
    "raw_code": "def self.release_topics_selected_by_team_for_assignment(team_id, assignment_id)\n    old_teams_signups = SignedUpTeam.where(team_id: team_id)\n\n    # If the team has signed up for the topic and they are on the waitlist then remove that team from the waitlist.\n    unless old_teams_signups.nil?\n      old_teams_signups.each do |old_teams_signup|\n        if old_teams_signup.is_waitlisted == false # i.e., if the old team was occupying a slot, & thus is releasing a slot ...\n          first_waitlisted_signup = SignedUpTeam.find_by(topic_id: old_teams_signup.topic_id, is_waitlisted: true)\n          Invitation.remove_waitlists_for_team(old_teams_signup.topic_id, assignment_id) unless first_waitlisted_signup.nil?\n        end",
    "comment": "If a signup sheet exists then release topics that the given team has selected for the given assignment.",
    "label": "what",
    "id": "273"
  },
  {
    "raw_code": "def self.drop_signup_record(topic_id,team_id)\n    # Fetching record for a given topic and team.\n    signup_record = SignedUpTeam.find_by(topic_id: topic_id, team_id: team_id)\n    # If the signup_record in not nil destroy it.\n    signup_record.destroy unless signup_record.nil?\n  end",
    "comment": "Remove a specific signed_up_teams record for a given topic and team.",
    "label": "what",
    "id": "274"
  },
  {
    "raw_code": "def self.drop_off_waitlists(team_id)\n    # Fetch all records that matches the given team_id with is_waitlisted as true\n    # and destroy all the records.\n    SignedUpTeam.where(team_id: team_id, is_waitlisted: true).destroy_all\n  end",
    "comment": "Remove all waitlisted records in signed_up_teams associated with a specific team.",
    "label": "what",
    "id": "275"
  },
  {
    "raw_code": "def parent_model\n    'Course'\n  end",
    "comment": "Get parent course",
    "label": "what",
    "id": "276"
  },
  {
    "raw_code": "def assignment_id\n    nil\n  end",
    "comment": "since this team is not an assignment team, the assignment_id is nil.",
    "label": "what",
    "id": "277"
  },
  {
    "raw_code": "def self.prototype\n    CourseTeam.new\n  end",
    "comment": "Prototype method to implement prototype pattern",
    "label": "what",
    "id": "278"
  },
  {
    "raw_code": "def copy(assignment_id)\n    assignment = Assignment.find_by(id: assignment_id)\n    if assignment.auto_assign_mentor\n      new_team = MentoredTeam.create_team_and_node(assignment_id)\n    else\n      new_team = AssignmentTeam.create_team_and_node(assignment_id)\n    end",
    "comment": "Copy this course team to the assignment team",
    "label": "what",
    "id": "279"
  },
  {
    "raw_code": "def add_participant(course_id, user)\n    if CourseParticipant.find_by(parent_id: course_id, user_id: user.id).nil?\n      CourseParticipant.create(parent_id: course_id, user_id: user.id, permission_granted: user.master_permission_granted)\n    end",
    "comment": "deprecated: the functionality belongs to course",
    "label": "what",
    "id": "280"
  },
  {
    "raw_code": "def self.import(row, course_id, options)\n    raise ImportError, 'The course with the id \"' + course_id.to_s + \"\\\" was not found. <a href='/courses/new'>Create</a> this course?\" if Course.find(course_id).nil?\n\n    @course_team = prototype\n    Team.import(row, course_id, options, @course_team)\n  end",
    "comment": "Import from csv",
    "label": "what",
    "id": "281"
  },
  {
    "raw_code": "def self.export(csv, parent_id, options)\n    @course_team = prototype\n    Team.export(csv, parent_id, options, @course_team)\n  end",
    "comment": "Export to csv",
    "label": "what",
    "id": "282"
  },
  {
    "raw_code": "def self.export_fields(options)\n    fields = []\n    fields.push('Team Name')\n    fields.push('Team members') if options[:team_name] == 'false'\n    fields.push('Course Name')\n  end",
    "comment": "Export the fields of the csv column",
    "label": "what",
    "id": "283"
  },
  {
    "raw_code": "def add_member(user, _id = nil)\n    raise \"The user \\\"#{user.name}\\\" is already a member of the team, \\\"#{name}\\\"\" if user?(user)\n\n    t_user = TeamsUser.create(user_id: user.id, team_id: id)\n    parent = TeamNode.find_by(node_object_id: id)\n    TeamUserNode.create(parent_id: parent.id, node_object_id: t_user.id)\n    add_participant(parent_id, user)\n  end",
    "comment": "Add member to the course team",
    "label": "what",
    "id": "284"
  },
  {
    "raw_code": "def self.anonymized_view?(ip_address = nil)\n    anonymized_view_starter_ips = $redis.get('anonymized_view_starter_ips') || ''\n    return true if ip_address && anonymized_view_starter_ips.include?(ip_address)\n\n    false\n  end",
    "comment": "Zhewei: anonymized view for demo purposes - 1/3/2018",
    "label": "what",
    "id": "285"
  },
  {
    "raw_code": "def self.real_user_from_anonymized_name(anonymized_name)\n    user = User.find_by(name: anonymized_name)\n    user\n  end",
    "comment": "E1991 : This function returns original name of the user from their anonymized names. The process of obtaining real name is exactly opposite of what we'd do to get anonymized name from their real name.",
    "label": "what",
    "id": "286"
  },
  {
    "raw_code": "def email_welcome\n    # this will send an account creation notification to user via email.\n    MailerHelper.send_mail_to_user(self, 'Your Expertiza account and password has been created', 'user_welcome', password).deliver_now\n  end",
    "comment": "Function which has a MailerHelper which sends the mail welcome email to the user after signing up",
    "label": "what",
    "id": "287"
  },
  {
    "raw_code": "def reset_password\n    randomize_password\n    save\n    password\n  end",
    "comment": "Resets the password to be mailed to the user",
    "label": "what",
    "id": "288"
  },
  {
    "raw_code": "def self.find_by_login(login)\n    user = User.find_by(email: login)\n    if user.nil?\n      items = login.split('@')\n      short_name = items[0]\n      user_list = User.where('name = ?', short_name)\n      user = user_list.first if user_list.any? && user_list.length == 1\n    end",
    "comment": "locate User based on provided login. If user supplies e-mail or name, the helper will try to find that User account.",
    "label": "what",
    "id": "289"
  },
  {
    "raw_code": "def generate_keys\n    # check if we are replacing a digital certificate already generated\n    replacing_key = true unless digital_certificate.nil?\n\n    # generate the new key pair\n    new_key = OpenSSL::PKey::RSA.generate(1024)\n    self.public_key = new_key.public_key.to_pem\n\n    save\n\n    # when replacing an existing key, update any digital signatures made previously with the new key\n    if replacing_key\n      participants = AssignmentParticipant.where(user_id: id)\n      participants.each do |participant|\n        participant.assign_copyright(new_key.to_pem) if participant.permission_granted\n      end",
    "comment": "generate a new RSA public/private key pair and create our own X509 digital certificate which we save in the database. The private key is returned by the method but not saved.",
    "label": "what",
    "id": "290"
  },
  {
    "raw_code": "def get_all_versions\n    if review_mapping.response\n      @sorted_array = []\n      @prev = Response.all\n      @prev.each do |element|\n        @sorted_array << element if element.map_id == review_mapping.map_id\n      end",
    "comment": "return all the versions available for a response map. a person who is doing meta review has to be able to see all the versions of review.",
    "label": "what",
    "id": "291"
  },
  {
    "raw_code": "def contributor\n    team_review_map = ReviewResponseMap.find(reviewed_object_id)\n    AssignmentTeam.find(team_review_map.reviewee_id)\n  end",
    "comment": "First, find the \"ReviewResponseMap\" to be metareviewed; Second, find the team in the \"ReviewResponseMap\" record.",
    "label": "what",
    "id": "292"
  },
  {
    "raw_code": "def self.get_timeline_data(assignment, participant, _team)\n    timeline_list = []\n    get_due_date_data(assignment, timeline_list)\n    # get_submission_data(assignment.try(:id), team.try(:id), timeline_list)\n    get_peer_review_data(participant.get_reviewer.try(:id), timeline_list)\n    get_author_feedback_data(participant.try(:id), timeline_list)\n    timeline_list.sort_by { |f| Time.zone.parse f[:updated_at] }\n  end",
    "comment": "static method for the building timeline data",
    "label": "what",
    "id": "293"
  },
  {
    "raw_code": "def types\n    type_list = []\n    questions.each do |question|\n      type_list << question.type unless type_list.include?(question.type)\n    end",
    "comment": "return all possible question types",
    "label": "what",
    "id": "294"
  },
  {
    "raw_code": "def num_participants\n    participants.count\n  end",
    "comment": "====== general statistics ======#",
    "label": "what",
    "id": "295"
  },
  {
    "raw_code": "def total_num_assignment_teams\n    assignment_team_counts.inject(:+)\n  end",
    "comment": "===== number of assignment teams ====#",
    "label": "what",
    "id": "296"
  },
  {
    "raw_code": "def average_assignment_score\n    return assignment_average_scores.inject(:+).to_f / num_assignments unless num_assignments == 0\n\n    0\n  end",
    "comment": "===== assignment score =====#",
    "label": "what",
    "id": "297"
  },
  {
    "raw_code": "def assignment_review_counts\n    list = []\n    assignments.each do |assignment|\n      list << assignment.total_num_team_reviews\n    end",
    "comment": "======= reviews =======#",
    "label": "what",
    "id": "298"
  },
  {
    "raw_code": "def num_participants\n    participants.count\n  end",
    "comment": "======= general ==========#",
    "label": "what",
    "id": "299"
  },
  {
    "raw_code": "def average_review_score\n    if num_reviews == 0\n      0\n    else\n      review_scores.inject(:+).to_f / num_reviews\n    end",
    "comment": "========== score ========#",
    "label": "what",
    "id": "300"
  },
  {
    "raw_code": "def total_review_word_count\n    review_word_counts.inject(:+)\n  end",
    "comment": "======= word count =======#",
    "label": "what",
    "id": "301"
  },
  {
    "raw_code": "def total_review_character_count\n    review_character_counts.inject(:+)\n  end",
    "comment": "===== character count ====#",
    "label": "what",
    "id": "302"
  },
  {
    "raw_code": "def review_scores\n    list = []\n    responses.each do |response|\n      list << response.average_score\n    end",
    "comment": "return an array containing the score of all the reviews",
    "label": "what",
    "id": "303"
  },
  {
    "raw_code": "def average_score\n    return question_score_list.inject(:+) / num_questions unless num_questions == 0\n\n    0\n  end",
    "comment": "====== score =======#",
    "label": "what",
    "id": "304"
  },
  {
    "raw_code": "def total_word_count\n    word_count_list.inject(:+)\n  end",
    "comment": "====== word count ======#",
    "label": "what",
    "id": "305"
  },
  {
    "raw_code": "def total_character_count\n    character_count_list.inject(:+)\n  end",
    "comment": "====== character count ====#",
    "label": "what",
    "id": "306"
  },
  {
    "raw_code": "def word_count_list\n    list = []\n    scores.each do |score|\n      list << score.word_count\n    end",
    "comment": "return an array of strings containing the word count of al the comments",
    "label": "what",
    "id": "307"
  },
  {
    "raw_code": "def question_score_list\n    list = []\n    scores.each do |score|\n      list << score.score\n    end",
    "comment": "return score for all of the questions in an array",
    "label": "what",
    "id": "308"
  },
  {
    "raw_code": "def comments_text_list\n    comments_list = []\n    scores.each do |score|\n      comments_list << score.comments\n    end",
    "comment": "return an array of strings containing all of the comments",
    "label": "what",
    "id": "309"
  },
  {
    "raw_code": "def num_participants\n    participants.count\n  end",
    "comment": "====== general statistics ======#",
    "label": "what",
    "id": "310"
  },
  {
    "raw_code": "def total_num_team_reviews\n    team_review_counts.inject(:+)\n  end",
    "comment": "==== number of team reviews ====#",
    "label": "what",
    "id": "311"
  },
  {
    "raw_code": "def average_team_score\n    if num_teams == 0\n      0\n    else\n      team_scores.inject(:+).to_f / num_teams\n    end",
    "comment": "=========== score ==============#",
    "label": "what",
    "id": "312"
  },
  {
    "raw_code": "def questionnaire_types\n    questionnaire_type_list = []\n    questionnaires.each do |questionnaire|\n      questionnaire_type_list << questionnaire.type unless questionnaires.include?(questionnaire.type)\n    end",
    "comment": "return all questionnaire types associated this assignment",
    "label": "what",
    "id": "313"
  },
  {
    "raw_code": "def questionnaire_of_type(type_name_in_string)\n    questionnaires.each do |questionnaire|\n      return questionnaire if questionnaire.type == type_name_in_string\n    end",
    "comment": "return questionnaire of a type related to the assignment assumptions: only 1 questionnaire of each type exist which should be the case",
    "label": "what",
    "id": "314"
  },
  {
    "raw_code": "def self.questionnaire_unique?\n    find_each do |assignment|\n      assignment.questionnaire_types.each do |questionnaire_type|\n        questionnaire_list = []\n        assignment.questionnaires.each do |questionnaire|\n          questionnaire_list << questionnaire if questionnaire.type == questionnaire_type\n          return false if questionnaire_list.count > 1\n        end",
    "comment": "helper function do to verify the assumption made above",
    "label": "what",
    "id": "315"
  },
  {
    "raw_code": "def index\n    json = UserPastebin.get_current_user_pastebin_json current_user\n    render json: json\n  rescue StandardError => e\n    flash[:error] = e.message\n  end",
    "comment": "GET /user_pastebins",
    "label": "what",
    "id": "316"
  },
  {
    "raw_code": "def show; end\n\n  # GET /user_pastebins/new\n  def new\n    @user_pastebin = UserPastebin.new\n  end\n\n  # GET /user_pastebins/1/edit\n  def edit; end\n\n  # POST /user_pastebins\n  def create\n    @user_pastebin = UserPastebin.new(user_pastebin_params)\n    @user_pastebin.user_id = current_user.id\n    if @user_pastebin.save\n      data = UserPastebin.get_current_user_pastebin_json current_user\n      render json: data, status: 200\n    else\n      data = { message: 'Short Form or Long Form in the Text Macro is not valid' }\n      render json: data, status: 422\n    end\n  end\n\n  # PATCH/PUT /user_pastebins/1\n  def update\n    if @user_pastebin.update(user_pastebin_params)\n      redirect_to @user_pastebin, notice: 'User pastebin was successfully updated.'\n    else\n      render :edit\n    end\n  end",
    "comment": "GET /user_pastebins/1",
    "label": "what",
    "id": "317"
  },
  {
    "raw_code": "def destroy\n    @user_pastebin.destroy\n    redirect_to user_pastebins_url, notice: 'User pastebin was successfully destroyed.'\n  end",
    "comment": "DELETE /user_pastebins/1",
    "label": "what",
    "id": "318"
  },
  {
    "raw_code": "def set_user_pastebin\n    @user_pastebin = UserPastebin.find(params[:id])\n  end",
    "comment": "Use callbacks to share common setup or constraints between actions.",
    "label": "what",
    "id": "319"
  },
  {
    "raw_code": "def user_pastebin_params\n    params.permit(:short_form, :long_form)\n  end",
    "comment": "Only allow a trusted parameter \"white list\" through.",
    "label": "what",
    "id": "320"
  },
  {
    "raw_code": "def grant\n    id = params[:id]\n    @participant = AssignmentParticipant.find(id) unless id.nil?\n    @user = User.find(session[:user].id)\n  end",
    "comment": "Put up the page where the user can supply their private key and grant publishing rights",
    "label": "what",
    "id": "321"
  },
  {
    "raw_code": "def grant_with_private_key\n    id = params[:id]\n    participants = if id\n                     [AssignmentParticipant.find(id)]\n                   else\n                     AssignmentParticipant.where(user_id: session[:user].id)\n                   end",
    "comment": "Grant publishing rights using the private key supplied by the student",
    "label": "what",
    "id": "322"
  },
  {
    "raw_code": "def check_reset_url\n    if params[:token].nil?\n      flash[:error] = 'Password reset page can only be accessed with a generated link, sent to your email'\n      render template: 'password_retrieval/forgotten'\n    else\n      @token = Digest::SHA1.hexdigest(params[:token])\n      password_reset = PasswordReset.find_by(token: @token)\n      if password_reset\n        # URL expires after 1 day\n        expired_url = password_reset.updated_at + 1.day\n        if Time.now < expired_url\n          # redirect_to action: 'reset_password', email: password_reset.user_email\n          @email = password_reset.user_email\n          render template: 'password_retrieval/reset_password'\n        else\n          ExpertizaLogger.error LoggerMessage.new(controller_name, '', 'User tried to access expired link!', request)\n          flash[:error] = 'Link expired . Please request to reset password again'\n          render template: 'password_retrieval/forgotten'\n        end",
    "comment": "The token obtained from the reset url is first checked if it is valid ( if actually generated by the application), then checks if the token is active.",
    "label": "what",
    "id": "323"
  },
  {
    "raw_code": "def reset_password\n    flash[:error] = 'Password reset page can only be accessed with a generated link, sent to your email'\n    render template: 'password_retrieval/forgotten'\n  end",
    "comment": "avoid users to access this page without a valid token",
    "label": "what",
    "id": "324"
  },
  {
    "raw_code": "def update_password\n    if params[:reset][:password] == params[:reset][:repassword]\n      user = User.find_by(email: params[:reset][:email])\n      user.password = params[:reset][:password]\n      user.password_confirmation = params[:reset][:repassword]\n      if user.save\n        PasswordReset.where(user_email: user.email).delete_all\n        ExpertizaLogger.info LoggerMessage.new(controller_name, user.name, 'Password was reset for the user', request)\n        flash[:success] = 'Password was successfully reset'\n      else\n        ExpertizaLogger.error LoggerMessage.new(controller_name, user.name, 'Password reset operation failed for the user while saving record', request)\n        flash[:error] = 'Password cannot be updated. Please try again'\n      end",
    "comment": "called after entering password and repassword, checks for validation and updates the password of the email",
    "label": "what",
    "id": "325"
  },
  {
    "raw_code": "def current_user_id?(user_id)\n    current_user.try(:id) == user_id\n  end",
    "comment": "Use this method to validate the current user in order to avoid allowing users to see unauthorized data. Ex: return unless current_user_id?(params[:user_id])",
    "label": "what",
    "id": "326"
  },
  {
    "raw_code": "def show\n    @popup = false\n    if params.key?(:popup) && params[:popup].to_s.casecmp('true').zero?\n      @popup = true\n      render layout: false\n    end",
    "comment": "GET /tag_prompts/view",
    "label": "what",
    "id": "327"
  },
  {
    "raw_code": "def action_allowed?\n    if %w[edit update list_submissions].include? params[:action]\n      current_user_has_admin_privileges? || current_user_teaching_staff_of_assignment?(params[:id])\n    else\n      current_user_has_ta_privileges?\n    end",
    "comment": "determines if an action is allowed for a user",
    "label": "what",
    "id": "328"
  },
  {
    "raw_code": "def new\n    @assignment_form = AssignmentForm.new\n    @assignment_form.assignment.instructor ||= current_user\n    @num_submissions_round = 0\n    @num_reviews_round = 0\n    @default_num_metareviews_required = 3\n  end",
    "comment": "creates and renders a new assignment form",
    "label": "what",
    "id": "329"
  },
  {
    "raw_code": "def create\n    @assignment_form = AssignmentForm.new(assignment_form_params)\n    if params[:button]\n      # E2138 issue #3\n      find_existing_assignment = Assignment.find_by(name: @assignment_form.assignment.name, course_id: @assignment_form.assignment.course_id)\n      dir_path = assignment_form_params[:assignment][:directory_path]\n      find_existing_directory = Assignment.find_by(directory_path: dir_path, course_id: @assignment_form.assignment.course_id)\n      if !find_existing_assignment && !find_existing_directory && @assignment_form.save # No existing names/directories\n        @assignment_form.create_assignment_node\n        exist_assignment = Assignment.find(@assignment_form.assignment.id)\n        assignment_form_params[:assignment][:id] = exist_assignment.id.to_s\n        if assignment_form_params[:assignment][:directory_path].blank?\n          assignment_form_params[:assignment][:directory_path] = \"assignment_#{assignment_form_params[:assignment][:id]}\"\n        end",
    "comment": "creates a new assignment via the assignment form",
    "label": "what",
    "id": "330"
  },
  {
    "raw_code": "def edit\n    user_timezone_specified\n    edit_params_setting\n    assignment_staggered_deadline?\n    update_due_date\n    check_questionnaires_usage\n    @due_date_all = update_nil_dd_deadline_name(@due_date_all)\n    @due_date_all = update_nil_dd_description_url(@due_date_all)\n    unassigned_rubrics_warning\n    path_warning_and_answer_tag\n    update_assignment_badges\n    @assigned_badges = @assignment_form.assignment.badges\n    @badges = Badge.all\n    @use_bookmark = @assignment.use_bookmark\n    @duties = Duty.where(assignment_id: @assignment_form.assignment.id)\n  end",
    "comment": "edits an assignment's deadlines and assigned rubrics",
    "label": "what",
    "id": "331"
  },
  {
    "raw_code": "def update\n    unless params.key?(:assignment_form)\n      key_nonexistent_handler\n      return\n    end",
    "comment": "updates an assignment via an assignment form",
    "label": "what",
    "id": "332"
  },
  {
    "raw_code": "def show\n    @assignment = Assignment.find(params[:id])\n  end",
    "comment": "displays an assignment via ID",
    "label": "what",
    "id": "333"
  },
  {
    "raw_code": "def path\n    begin\n      file_path = @assignment.path\n    rescue StandardError\n      file_path = nil\n    end",
    "comment": "gets an assignment's path/url",
    "label": "what",
    "id": "334"
  },
  {
    "raw_code": "def copy\n    update_copy_session\n    # check new assignment submission directory and old assignment submission directory\n    new_assign_id = AssignmentForm.copy(params[:id], @user)\n    if new_assign_id\n      if check_same_directory?(params[:id], new_assign_id)\n        flash[:note] = 'Warning: The submission directory for the copy of this assignment will be the same as the submission directory '\\\n          'for the existing assignment. This will allow student submissions to one assignment to overwrite submissions to the other assignment. '\\\n          'If you do not want this to happen, change the submission directory in the new copy of the assignment.'\n      end",
    "comment": "makes a copy of an assignment",
    "label": "what",
    "id": "335"
  },
  {
    "raw_code": "def delete\n    begin\n      assignment_form = AssignmentForm.create_form_object(params[:id])\n      user = session[:user]\n      # Issue 1017 - allow instructor to delete assignment created by TA.\n      # FixA : TA can only delete assignment created by itself.\n      # FixB : Instrucor will be able to delete any assignment belonging to his/her courses.\n      if (user.role.name == 'Instructor') || ((user.role.name == 'Teaching Assistant') && (user.id == assignment_form.assignment.instructor_id))\n        assignment_form.delete(params[:force])\n        ExpertizaLogger.info LoggerMessage.new(controller_name, session[:user].name, \"Assignment #{assignment_form.assignment.id} was deleted.\", request)\n        flash[:success] = 'The assignment was successfully deleted.'\n      else\n        ExpertizaLogger.info LoggerMessage.new(controller_name, session[:user].name, 'You are not authorized to delete this assignment.', request)\n        flash[:error] = 'You are not authorized to delete this assignment.'\n      end",
    "comment": "deletes an assignment",
    "label": "what",
    "id": "336"
  },
  {
    "raw_code": "def delayed_mailer\n    @suggestions = Suggestion.where(assignment_id: params[:id])\n    @assignment = Assignment.find(params[:id])\n  end",
    "comment": "sets the current assignment and suggestions for the assignment",
    "label": "what",
    "id": "337"
  },
  {
    "raw_code": "def place_assignment_in_course\n    @assignment = Assignment.find(params[:id])\n    @courses = Assignment.assign_courses_to_assignment(current_user)\n  end",
    "comment": "place an assignment in a course",
    "label": "what",
    "id": "338"
  },
  {
    "raw_code": "def list_submissions\n    @assignment = Assignment.find(params[:id])\n    @teams = Team.where(parent_id: params[:id])\n  end",
    "comment": "list team assignment submissions",
    "label": "what",
    "id": "339"
  },
  {
    "raw_code": "def remove_assignment_from_course\n    assignment = Assignment.find(params[:id])\n    assignment.remove_assignment_from_course\n    redirect_to list_tree_display_index_path\n  end",
    "comment": "remove an assignment from a course. Doesn't delete assignment",
    "label": "what",
    "id": "340"
  },
  {
    "raw_code": "def instant_flash\n    render partial: 'shared/flash_messages'\n  end",
    "comment": "Provide a means for a rendering of all flash messages to be requested This is useful because the assignments page has tabs and switching tabs acts like a \"save\" but does NOT cause a new page load so if we want to see via flash messages when something goes wrong, we need to ask about it Doing it this way has a few advantages doesn't matter what kind of flash item is set (error, note, notice, etc.) doesn't matter what tab we are on (anybody can request this render) doesn't matter where the flash item originated, anything can get seen this way",
    "label": "what",
    "id": "341"
  },
  {
    "raw_code": "def list_unassigned_rubrics\n    rubrics_list = %w[ReviewQuestionnaire\n                      MetareviewQuestionnaire AuthorFeedbackQuestionnaire\n                      TeammateReviewQuestionnaire BookmarkRatingQuestionnaire]\n    @assignment_questionnaires.each do |aq|\n      remove_existing_questionnaire(rubrics_list, aq)\n    end",
    "comment": "check whether rubrics are set before save assignment",
    "label": "what",
    "id": "342"
  },
  {
    "raw_code": "def remove_existing_questionnaire(rubrics_list, aq)\n    return if aq.questionnaire_id.nil?\n\n    rubrics_list.reject! do |rubric|\n      rubric == Questionnaire.where(id: aq.questionnaire_id).first.type.to_s\n    end",
    "comment": "Removes questionnaire types from the rubric list that are already on the assignment",
    "label": "what",
    "id": "343"
  },
  {
    "raw_code": "def remove_invalid_questionnaires(rubrics_list)\n    rubrics_list.delete('TeammateReviewQuestionnaire') if @assignment_form.assignment.max_team_size == 1\n    rubrics_list.delete('MetareviewQuestionnaire') unless @metareview_allowed\n    rubrics_list.delete('BookmarkRatingQuestionnaire') unless @assignment_form.assignment.use_bookmark\n  end",
    "comment": "Removes questionnaire types from the rubric list that shouldn't be there e.g. remove teammate review questionnaire if the maximum team size is one person (there are no teammates)",
    "label": "what",
    "id": "344"
  },
  {
    "raw_code": "def needed_rubrics(empty_rubrics_list)\n    needed_rub = '<b>['\n    empty_rubrics_list.each do |item|\n      needed_rub += item[0...-13] + ', '\n    end",
    "comment": "lists parts of the assignment that need a rubric assigned",
    "label": "what",
    "id": "345"
  },
  {
    "raw_code": "def due_date_nameurl_not_empty?(dd)\n    dd.deadline_name.present? || dd.description_url.present?\n  end",
    "comment": "checks an assignment's due date has a name or description",
    "label": "what",
    "id": "346"
  },
  {
    "raw_code": "def meta_review_allowed?(dd)\n    dd.deadline_type_id == DeadlineHelper::DEADLINE_TYPE_METAREVIEW\n  end",
    "comment": "checks if an assignment allows meta reviews",
    "label": "what",
    "id": "347"
  },
  {
    "raw_code": "def drop_topic_allowed?(dd)\n    dd.deadline_type_id == DeadlineHelper::DEADLINE_TYPE_DROP_TOPIC\n  end",
    "comment": "checks if an assignment allows topic drops",
    "label": "what",
    "id": "348"
  },
  {
    "raw_code": "def signup_allowed?(dd)\n    dd.deadline_type_id == DeadlineHelper::DEADLINE_TYPE_SIGN_UP\n  end",
    "comment": "checks if an assignment allows for topic sign ups",
    "label": "what",
    "id": "349"
  },
  {
    "raw_code": "def team_formation_allowed?(dd)\n    dd.deadline_type_id == DeadlineHelper::DEADLINE_TYPE_TEAM_FORMATION\n  end",
    "comment": "checks if an assignment allows teams to be formed",
    "label": "what",
    "id": "350"
  },
  {
    "raw_code": "def update_nil_dd_deadline_name(due_date_all)\n    due_date_all.each do |dd|\n      dd.deadline_name ||= ''\n    end",
    "comment": "sets an assignment's deadline name",
    "label": "what",
    "id": "351"
  },
  {
    "raw_code": "def update_nil_dd_description_url(due_date_all)\n    due_date_all.each do |dd|\n      dd.description_url ||= ''\n    end",
    "comment": "sets an assignment's due date description",
    "label": "what",
    "id": "352"
  },
  {
    "raw_code": "def assignment_form_save_handler\n    exist_assignment = Assignment.find_by(name: @assignment_form.assignment.name)\n    assignment_form_params[:assignment][:id] = exist_assignment.id.to_s\n    fix_assignment_missing_path\n    update_assignment_form(exist_assignment)\n    aid = Assignment.find_by(name: @assignment_form.assignment.name).id\n    ExpertizaLogger.info \"Assignment created: #{@assignment_form.as_json}\"\n    redirect_to edit_assignment_path aid\n    undo_link(\"Assignment \\\"#{@assignment_form.assignment.name}\\\" has been created successfully. \")\n  end",
    "comment": "handle assignment form saved condition",
    "label": "what",
    "id": "353"
  },
  {
    "raw_code": "def fix_assignment_missing_path\n    assignment_form_params[:assignment][:directory_path] = \"assignment_#{assignment_form_params[:assignment][:id]}\" \\\n    if assignment_form_params[:assignment][:directory_path].blank?\n  end",
    "comment": "update_assignment_form_params to handle non existent directory path",
    "label": "what",
    "id": "354"
  },
  {
    "raw_code": "def update_assignment_form(exist_assignment)\n    questionnaire_array = assignment_form_params[:assignment_questionnaire]\n    questionnaire_array.each { |cur_questionnaire| cur_questionnaire[:assignment_id] = exist_assignment.id.to_s }\n    assignment_form_params[:assignment_questionnaire]\n    due_array = assignment_form_params[:due_date]\n    due_array.each { |cur_due| cur_due[:parent_id] = exist_assignment.id.to_s }\n    assignment_form_params[:due_date]\n    @assignment_form.update(assignment_form_params, current_user)\n  end",
    "comment": "update assignment_form with assignment_questionnaire and due_date",
    "label": "what",
    "id": "355"
  },
  {
    "raw_code": "def check_same_directory?(old_id, new_id)\n    Assignment.find(old_id).directory_path == Assignment.find(new_id).directory_path\n  end",
    "comment": "helper methods for copy checks if two assignments are in the same directory",
    "label": "what",
    "id": "356"
  },
  {
    "raw_code": "def update_copy_session\n    @user = current_user\n    session[:copy_flag] = true\n  end",
    "comment": "sets the user for the copy method to the current user and indicates the session is for copying",
    "label": "what",
    "id": "357"
  },
  {
    "raw_code": "def edit_params_setting\n    @assignment = Assignment.find(params[:id])\n    @num_submissions_round = @assignment.find_due_dates('submission').nil? ? 0 : @assignment.find_due_dates('submission').count\n    @num_reviews_round = @assignment.find_due_dates('review').nil? ? 0 : @assignment.find_due_dates('review').count\n\n    @topics = SignUpTopic.where(assignment_id: params[:id])\n    @assignment_form = AssignmentForm.create_form_object(params[:id])\n    @user = current_user\n\n    @assignment_questionnaires = AssignmentQuestionnaire.where(assignment_id: params[:id])\n    @due_date_all = AssignmentDueDate.where(parent_id: params[:id])\n    @due_date_nameurl_not_empty = false\n    @due_date_nameurl_not_empty_checkbox = false\n    @metareview_allowed = false\n    @metareview_allowed_checkbox = false\n    @signup_allowed = false\n    @signup_allowed_checkbox = false\n    @drop_topic_allowed = false\n    @drop_topic_allowed_checkbox = false\n    @team_formation_allowed = false\n    @team_formation_allowed_checkbox = false\n    @participants_count = @assignment_form.assignment.participants.size\n    @teams_count = @assignment_form.assignment.teams.size\n  end",
    "comment": "populates values and settings of the assignment for editing",
    "label": "what",
    "id": "358"
  },
  {
    "raw_code": "def assignment_staggered_deadline?\n    if @assignment_form.assignment.staggered_deadline == true\n      @review_rounds = @assignment_form.assignment.num_review_rounds\n      @due_date_all ||= AssignmentDueDate.where(parent_id: @assignment_form.assignment.id)\n      @assignment_submission_due_dates = @due_date_all.select { |due_date| due_date.deadline_type_id == DeadlineHelper::DEADLINE_TYPE_SUBMISSION }\n      @assignment_review_due_dates = @due_date_all.select { |due_date| due_date.deadline_type_id == DeadlineHelper::DEADLINE_TYPE_REVIEW }\n    end",
    "comment": "populates assignment deadlines in the form if they are staggered",
    "label": "what",
    "id": "359"
  },
  {
    "raw_code": "def update_due_date_nameurl(dd)\n    @due_date_nameurl_not_empty = due_date_nameurl_not_empty?(dd)\n    @due_date_nameurl_not_empty_checkbox = @due_date_nameurl_not_empty\n    @metareview_allowed = meta_review_allowed?(dd)\n    @drop_topic_allowed = drop_topic_allowed?(dd)\n    @signup_allowed = signup_allowed?(dd)\n    @team_formation_allowed = team_formation_allowed?(dd)\n  end",
    "comment": "gets the current settings of the current assignment",
    "label": "what",
    "id": "360"
  },
  {
    "raw_code": "def adjust_due_date_for_timezone(dd)\n    dd.due_at = dd.due_at.to_s.in_time_zone(current_user.timezonepref) if dd.due_at.present?\n  end",
    "comment": "adjusts the time zone for a due date",
    "label": "what",
    "id": "361"
  },
  {
    "raw_code": "def validate_due_date\n    @due_date_nameurl_not_empty && @due_date_nameurl_not_empty_checkbox &&\n      (@metareview_allowed || @drop_topic_allowed || @signup_allowed || @team_formation_allowed)\n  end",
    "comment": "ensures due dates ahave a name, description and at least either meta reviews, topic drops, signups, or team formations",
    "label": "what",
    "id": "362"
  },
  {
    "raw_code": "def check_questionnaires_usage\n    @assignment_questionnaires.each do |aq|\n      unless aq.used_in_round.nil?\n        @reviewvarycheck = 1\n        break\n      end",
    "comment": "checks if each questionnaire in an assignment is used",
    "label": "what",
    "id": "363"
  },
  {
    "raw_code": "def unassigned_rubrics_warning\n    if !list_unassigned_rubrics.empty? && request.original_fullpath == \"/assignments/#{@assignment_form.assignment.id}/edit\"\n      rubrics_needed = needed_rubrics(list_unassigned_rubrics)\n      ExpertizaLogger.error LoggerMessage.new(controller_name, session[:user].name, \"Rubrics missing for #{@assignment_form.assignment.name}.\", request)\n      if flash.now[:error] != 'Failed to save the assignment: [\"Total weight of rubrics should add up to either 0 or 100%\"]'\n        flash.now[:error] = 'You did not specify all the necessary rubrics. You need ' + rubrics_needed +\n                            \" of assignment <b>#{@assignment_form.assignment.name}</b> before saving the assignment. You can assign rubrics\" \\\n                            \" <a id='go_to_tabs2' style='color: blue;'>here</a>.\"\n      end",
    "comment": "determines what aspecs of an assignment need a rubric and provides a notice",
    "label": "what",
    "id": "364"
  },
  {
    "raw_code": "def path_warning_and_answer_tag\n    if @assignment_form.assignment.directory_path.blank?\n      flash.now[:error] = 'You did not specify your submission directory.'\n      ExpertizaLogger.error LoggerMessage.new(controller_name, '', 'Submission directory not specified', request)\n    end",
    "comment": "flashes an error if an assignment has no directory and sets tag prompting",
    "label": "what",
    "id": "365"
  },
  {
    "raw_code": "def update_due_date\n    @due_date_all.each do |dd|\n      update_due_date_nameurl(dd)\n      adjust_due_date_for_timezone(dd)\n      break if validate_due_date\n    end",
    "comment": "update values for an assignment's due date when editing",
    "label": "what",
    "id": "366"
  },
  {
    "raw_code": "def update_assignment_badges\n    @assigned_badges = @assignment_form.assignment.badges\n    @badges = Badge.all\n  end",
    "comment": "update the current assignment's badges when editing",
    "label": "what",
    "id": "367"
  },
  {
    "raw_code": "def user_timezone_specified\n    ExpertizaLogger.error LoggerMessage.new(controller_name, session[:user].name, 'Timezone not specified', request) if current_user.timezonepref.nil?\n    flash.now[:error] = 'You have not specified your preferred timezone yet. Please do this before you set up the deadlines.' if current_user.timezonepref.nil?\n  end",
    "comment": "flash notice if the time zone is not specified for an assignment's due date",
    "label": "what",
    "id": "368"
  },
  {
    "raw_code": "def key_nonexistent_handler\n    @assignment = Assignment.find(params[:id])\n    @assignment.course_id = params[:course_id]\n\n    if @assignment.save\n      ExpertizaLogger.info LoggerMessage.new(controller_name, session[:user].name, \"The assignment was successfully saved: #{@assignment.as_json}\", request)\n      flash[:note] = 'The assignment was successfully saved.'\n      redirect_to list_tree_display_index_path\n    else\n      ExpertizaLogger.error LoggerMessage.new(controller_name, session[:user].name, \"Failed assignment: #{@assignment.errors.full_messages.join(' ')}\", request)\n      flash[:error] = \"Failed to save the assignment: #{@assignment.errors.full_messages.join(' ')}\"\n      redirect_to edit_assignment_path @assignment.id\n    end",
    "comment": "flashes notice if corresponding to an assignment's save status",
    "label": "what",
    "id": "369"
  },
  {
    "raw_code": "def nil_timezone_update\n    if current_user.timezonepref.nil?\n      parent_id = current_user.parent_id\n      parent_timezone = User.find(parent_id).timezonepref\n      flash[:error] = 'We strongly suggest that instructors specify their preferred timezone to'\\\n          ' guarantee the correct display time. For now we assume you are in ' + parent_timezone\n      current_user.timezonepref = parent_timezone\n    end",
    "comment": "sets assignment time zone if not specified and flashes a warning",
    "label": "what",
    "id": "370"
  },
  {
    "raw_code": "def update_feedback_attributes\n    if params[:set_pressed][:bool] == 'false'\n      flash[:error] = \"There has been some submissions for the rounds of reviews that you're trying to reduce. You can only increase the round of review.\"\n    elsif @assignment_form.update_attributes(assignment_form_params, current_user)\n      flash[:note] = 'The assignment was successfully saved....'\n      if @assignment_form.rubric_weight_error(assignment_form_params)\n        flash[:error] = 'A rubric has no ScoredQuestions, but still has a weight. Please change the weight to 0.'\n      end",
    "comment": "updates an assignment's attributes and flashes a notice on the status of the save",
    "label": "what",
    "id": "371"
  },
  {
    "raw_code": "def assignment_form_params\n    params.require(:assignment_form).permit!\n  end",
    "comment": "sets values allowed for the assignment form",
    "label": "what",
    "id": "372"
  },
  {
    "raw_code": "def action_allowed?\n    current_user_has_ta_privileges?\n  end",
    "comment": "Check if the current user has TA privileges",
    "label": "what",
    "id": "373"
  },
  {
    "raw_code": "def init_team_type(type)\n    return unless type && Team.allowed_types.include?(type)\n    session[:team_type] = type\n    #E2351 - the current method for creating a team does not expand well for creating a subclass of either Assignment or Course Team so this is added logic to help allow for MentoredTeams to be created.\n    #Team type is using for various purposes including creating nodes, but a MentoredTeam is an AssignmentTeam and still has a parent assignment, not a parent mentored so an additional variable needed to be created\n    #to be able to separate object creation and the other things that :team_type was also used for. :create_team has been inserted into #create_teams and #create where needed\n    session[:create_type] = type\n    if type == 'Assignment'\n      parent = parent_by_id(params[:id])\n      if parent.auto_assign_mentor\n        session[:create_type] = 'Mentored'\n      end",
    "comment": "attempt to initialize team type in session",
    "label": "what",
    "id": "374"
  },
  {
    "raw_code": "def parent_by_id(id)\n    Object.const_get(session[:team_type]).find(id)\n  end",
    "comment": "retrieve an object's parent by its ID",
    "label": "what",
    "id": "375"
  },
  {
    "raw_code": "def parent_from_child(child)\n    Object.const_get(session[:team_type]).find(child.parent_id)\n  end",
    "comment": "retrieve an object's parent from the object's parent ID",
    "label": "what",
    "id": "376"
  },
  {
    "raw_code": "def create_teams\n    #init_team_type(params[:type])\n    parent = parent_by_id(params[:id])\n    init_team_type(parent.class.name.demodulize)\n    Team.randomize_all_by_parent(parent, session[:create_type], params[:team_size].to_i)\n    undo_link('Random teams have been successfully created.')\n    ExpertizaLogger.info LoggerMessage.new(controller_name, '', 'Random teams have been successfully created', request)\n    redirect_to action: 'list', id: parent.id\n  end",
    "comment": "This function is used to create teams with random names. Instructors can call by clicking \"Create teams\" icon and then click \"Create teams\" at the bottom.",
    "label": "what",
    "id": "377"
  },
  {
    "raw_code": "def list\n    init_team_type(params[:type])\n    @assignment = Assignment.find_by(id: params[:id]) if session[:team_type] == Team.allowed_types[0]\n    unless @assignment.nil?\n      if @assignment.auto_assign_mentor\n        @model = MentoredTeam\n      else\n        @model = AssignmentTeam\n      end",
    "comment": "Displays list of teams for a parent object(either assignment/course)",
    "label": "what",
    "id": "378"
  },
  {
    "raw_code": "def new\n    init_team_type(Team.allowed_types[0]) unless session[:team_type]\n    @parent = Object.const_get(session[:team_type]).find(params[:id])\n  end",
    "comment": "Create an empty team manually",
    "label": "what",
    "id": "379"
  },
  {
    "raw_code": "def create\n    #init_team_type(params[:type])\n    parent = parent_by_id(params[:id])\n    init_team_type(parent.class.name.demodulize)\n    begin\n      Team.check_for_existing(parent, params[:team][:name], session[:team_type])\n      @team = Object.const_get(session[:create_type] + 'Team').create(name: params[:team][:name], parent_id: parent.id)\n      TeamNode.create(parent_id: parent.id, node_object_id: @team.id)\n      undo_link(\"The team \\\"#{@team.name}\\\" has been successfully created.\")\n      redirect_to action: 'list', id: parent.id\n    rescue TeamExistsError\n      flash[:error] = $ERROR_INFO\n      redirect_to action: 'new', id: parent.id\n    end",
    "comment": "Called when a instructor tries to create an empty team manually",
    "label": "what",
    "id": "380"
  },
  {
    "raw_code": "def update\n    @team = Team.find(params[:id])\n    parent = parent_from_child(@team)\n    begin\n      Team.check_for_existing(parent, params[:team][:name], session[:team_type])\n      @team.name = params[:team][:name]\n      @team.save\n      flash[:success] = \"The team \\\"#{@team.name}\\\" has been successfully updated.\"\n      undo_link('')\n      redirect_to action: 'list', id: parent.id\n    rescue TeamExistsError\n      flash[:error] = $ERROR_INFO\n      redirect_to action: 'edit', id: @team.id\n    end",
    "comment": "Update the team",
    "label": "what",
    "id": "381"
  },
  {
    "raw_code": "def edit\n    @team = Team.find(params[:id])\n  end",
    "comment": "Edit the team",
    "label": "what",
    "id": "382"
  },
  {
    "raw_code": "def delete_all\n    root_node = Object.const_get(session[:team_type] + 'Node').find_by(node_object_id: params[:id])\n    child_nodes = root_node.get_teams.map(&:node_object_id)\n    Team.destroy_all if child_nodes\n    redirect_to action: 'list', id: params[:id]\n  end",
    "comment": "Deleting all teams associated with a given parent object",
    "label": "what",
    "id": "383"
  },
  {
    "raw_code": "def delete\n    # delete records in team, teams_users, signed_up_teams table\n    @team = Team.find_by(id: params[:id])\n    unless @team.nil?\n      # Find all SignedUpTeam records associated with the found team.\n      @signed_up_team = SignedUpTeam.where(team_id: @team.id)\n      # Find all TeamsUser records associated with the found team.\n      @teams_users = TeamsUser.where(team_id: @team.id)\n      # Check if there are SignedUpTeam records associated with the found team.\n      unless @signed_up_team.nil?\n        # If a topic is assigned to this team and there is only one signed up team record, and it's not waitlisted.\n        if @signed_up_team.count == 1 && !@signed_up_team.first.is_waitlisted  # if a topic is assigned to this team\n            # Fetch the SignUpTopic object associated with the single signed up team.\n            @signed_topic = SignUpTopic.find_by(id: @signed_up_team.first.topic_id)\n            unless @signed_topic.nil?\n              # Call the instance method `reassign_topic` of SignUpTopic to reassign the topic.\n              @signed_topic.reassign_topic(@signed_up_team.first.team_id)\n            end",
    "comment": "Deleting a specific team associated with a given parent object",
    "label": "what",
    "id": "384"
  },
  {
    "raw_code": "def inherit\n    copy_teams(Team.team_operation[:inherit])\n  end",
    "comment": "Copies existing teams from a course down to an assignment The team and team members are all copied.",
    "label": "what",
    "id": "385"
  },
  {
    "raw_code": "def bequeath_all\n    if session[:team_type] == Team.allowed_types[1]\n      flash[:error] = 'Invalid team type for bequeath all'\n      redirect_to controller: 'teams', action: 'list', id: params[:id]\n    else\n      copy_teams(Team.team_operation[:bequeath])\n    end",
    "comment": "Handovers all teams to the course that contains the corresponding assignment The team and team members are all copied.",
    "label": "what",
    "id": "386"
  },
  {
    "raw_code": "def copy_teams(operation)\n    assignment = Assignment.find(params[:id])\n    if assignment.course_id\n      choose_copy_type(assignment, operation)\n    else\n      flash[:error] = 'No course was found for this assignment.'\n    end",
    "comment": "Method to abstract the functionality to copy teams.",
    "label": "what",
    "id": "387"
  },
  {
    "raw_code": "def choose_copy_type(assignment, operation)\n    course = Course.find(assignment.course_id)\n    if operation == Team.team_operation[:bequeath]\n      bequeath_copy(assignment, course)\n    else\n      inherit_copy(assignment, course)\n    end",
    "comment": "Abstraction over different methods",
    "label": "what",
    "id": "388"
  },
  {
    "raw_code": "def bequeath_copy(assignment, course)\n    teams = assignment.teams\n    if course.course_teams.any?\n      flash[:error] = 'The course already has associated teams'\n    else\n      Team.copy_content(teams, course)\n      flash[:note] = teams.length.to_s + ' teams were successfully copied to \"' + course.name + '\"'\n    end",
    "comment": "Method to perform a copy of assignment teams to course",
    "label": "what",
    "id": "389"
  },
  {
    "raw_code": "def inherit_copy(assignment, course)\n    teams = course.course_teams\n    if teams.empty?\n      flash[:error] = 'No teams were found when trying to inherit.'\n    else\n      Team.copy_content(teams, assignment)\n      flash[:note] = teams.length.to_s + ' teams were successfully copied to \"' + assignment.name + '\"'\n    end",
    "comment": "Method to inherit teams from course by copying",
    "label": "what",
    "id": "390"
  },
  {
    "raw_code": "def valid_user_domain?(domain)\n    domain == \"ncsu.edu\"\n  end",
    "comment": "Checks if user domain is \"ncsu.edu\" for authentication purposes",
    "label": "what",
    "id": "391"
  },
  {
    "raw_code": "def valid_request_url?(url)\n    url == ENV['LTI_TOOL_URL']\n  end",
    "comment": "Checks that the website requesting the authentication is approved",
    "label": "what",
    "id": "392"
  },
  {
    "raw_code": "def authenticate_and_login_user(username)\n    begin\n      # Gets the user if they exist in Expertiza, else null\n      user = User.find_by(name: username)\n      if user\n        # Log the user in\n        session[:user] = user  # Store the entire user object, not just the username\n        AuthController.set_current_role(user.role_id, session)\n        ExpertizaLogger.info LoggerMessage.new('', user.name, 'Login successful via LTI')\n        redirect_to \"#{ENV['EXPERTIZA_BASE_URL']}/student_task/list\", notice: 'Logged in successfully via LTI'\n      else\n        redirect_to root_path, alert: 'User not found in Expertiza. Please register first.'\n      end",
    "comment": "Logs user in if they exist in Expertiza",
    "label": "what",
    "id": "393"
  },
  {
    "raw_code": "def action_allowed?\n    current_user_has_ta_privileges?\n  end",
    "comment": "If current user is TA then only current user can edit and update the advice",
    "label": "what",
    "id": "394"
  },
  {
    "raw_code": "def invalid_advice?(sorted_advice, num_advices, question)\n    return ((question.question_advices.length != num_advices) ||\n    sorted_advice.empty? ||\n    (sorted_advice[0].score != @questionnaire.max_question_score) ||\n    (sorted_advice[sorted_advice.length - 1].score != @questionnaire.min_question_score))\n  end",
    "comment": "checks whether the advices for a question in questionnaire have valid attributes return true if the number of advices and their scores are invalid, else returns false",
    "label": "what",
    "id": "395"
  },
  {
    "raw_code": "def edit_advice\n    # Stores the questionnaire with given id in URL\n    @questionnaire = Questionnaire.find(params[:id])\n\n    # For each question in a quentionnaire, this method adjusts the advice size if the advice size is <,> number of advices or\n    # the max or min score of the advices does not correspond to the max or min score of questionnaire respectively.\n    @questionnaire.questions.each do |question|\n      # if the question is a scored question, store the number of advices corresponding to that question (max_score - min_score), else 0\n      num_advices = if question.is_a?(ScoredQuestion)\n                      @questionnaire.max_question_score - @questionnaire.min_question_score + 1\n                    else\n                      0\n                    end",
    "comment": "Modify the advice associated with a questionnaire",
    "label": "what",
    "id": "396"
  },
  {
    "raw_code": "def save_advice\n    # Stores the questionnaire with given id in URL\n    @questionnaire = Questionnaire.find(params[:id])\n    begin\n      # checks if advice is present or not\n      unless params[:advice].nil?\n        params[:advice].keys.each do |advice_key|\n          # Updates the advice corresponding to the key\n          QuestionAdvice.update(advice_key, advice: params[:advice][advice_key.to_sym][:advice])\n        end",
    "comment": "save the advice for a questionnaire",
    "label": "what",
    "id": "397"
  },
  {
    "raw_code": "def edit\n    @participant = AssignmentParticipant.find(params[:id])\n    return unless current_user_id?(@participant.user_id)\n\n    @assignment = @participant.assignment\n    # ACS We have to check if this participant has team or not\n    # hence use team count for the check\n    SignUpSheet.signup_team(@assignment.id, @participant.user_id, nil) if @participant.team.nil?\n    # @can_submit is the flag indicating if the user can submit or not in current stage\n    @can_submit = !params.key?(:view)\n    @stage = @assignment.current_stage(SignedUpTeam.topic_id(@participant.parent_id, @participant.user_id))\n  end",
    "comment": "The view have already tested that @assignment.submission_allowed(topic_id) is true, so @can_submit should be true",
    "label": "what",
    "id": "398"
  },
  {
    "raw_code": "def view\n    @participant = AssignmentParticipant.find(params[:id])\n    return unless current_user_id?(@participant.user_id)\n\n    @assignment = @participant.assignment\n    # @can_submit is the flag indicating if the user can submit or not in current stage\n    @can_submit = false\n    @stage = @assignment.current_stage(SignedUpTeam.topic_id(@participant.parent_id, @participant.user_id))\n    redirect_to action: 'edit', id: params[:id], view: true\n  end",
    "comment": "view is called when @assignment.submission_allowed(topic_id) is false so @can_submit should be false",
    "label": "what",
    "id": "399"
  },
  {
    "raw_code": "def remove_hyperlink\n    @participant = AssignmentParticipant.find(params[:hyperlinks][:participant_id])\n    return unless current_user_id?(@participant.user_id)\n\n    team = @participant.team\n    hyperlink_to_delete = team.hyperlinks[params['chk_links'].to_i]\n    team.remove_hyperlink(hyperlink_to_delete)\n    ExpertizaLogger.info LoggerMessage.new(controller_name, @participant.name, 'The link has been successfully removed.', request)\n    undo_link('The link has been successfully removed.')\n    # determine if the user should be redirected to \"edit\" or  \"view\" based on the current deadline right\n    topic_id = SignedUpTeam.topic_id(@participant.parent_id, @participant.user_id)\n    assignment = Assignment.find(@participant.parent_id)\n    SubmissionRecord.create(team_id: team.id,\n                            content: hyperlink_to_delete,\n                            user: @participant.name,\n                            assignment_id: assignment.id,\n                            operation: 'Remove Hyperlink')\n    action = (assignment.submission_allowed(topic_id) ? 'edit' : 'view')\n    redirect_to action: action, id: @participant.id\n  end",
    "comment": "Note: This is not used yet in the view until we all decide to do so",
    "label": "what",
    "id": "400"
  },
  {
    "raw_code": "def check_extension_integrity(original_filename)\n    \n  allowed_extensions = ['pdf', 'png', 'jpeg', 'zip', 'tar', 'gz', '7z', 'odt', 'docx','md','rb','mp4','txt']\n  file_extension = original_filename&.split('.')&.last&.downcase\n  allowed_extensions.include?(file_extension)\nend",
    "comment": "Verify the extension name of uploaded files. @param filename [String] the name of uploaded file @return [Boolean] the result of verification",
    "label": "what",
    "id": "401"
  },
  {
    "raw_code": "def check_content_size(file, size)\n    file.size <= size * 1024 * 1024\n  end",
    "comment": "Verify the size of uploaded file is under specific value. @param file [Object] uploaded file @param size [Integer] maximum size(MB) @return [Boolean] the result of verification",
    "label": "what",
    "id": "402"
  },
  {
    "raw_code": "def one_team_can_submit_work?\n    @participant = if params[:id].nil?\n                     AssignmentParticipant.find(params[:hyperlinks][:participant_id])\n                   else\n                     AssignmentParticipant.find(params[:id])\n                   end",
    "comment": "if one team do not hold a topic (still in waitlist), they cannot submit their work.",
    "label": "what",
    "id": "403"
  },
  {
    "raw_code": "def send_email\n    proposer = User.find_by(id: @user_id)\n    if proposer\n      teams_users = TeamsUser.where(team_id: @team_id)\n      cc_mail_list = []\n      teams_users.each do |teams_user|\n        cc_mail_list << User.find(teams_user.user_id).email if teams_user.user_id != proposer.id\n      end",
    "comment": "If the user submits a suggestion and gets it approved -> Send email If user submits a suggestion anonymously and it gets approved -> DOES NOT get an email",
    "label": "what",
    "id": "404"
  },
  {
    "raw_code": "def index\n    @tag_prompts = []\n\n    tag_deployments = TagPromptDeployment.all\n    tag_deployments = tag_deployments.where(assignment_id: params[:assignment_id]) if params.key?(:assignment_id)\n    tag_deployments = tag_deployments.where(questionnaire_id: params[:questionnaire_id]) if params.key?(:questionnaire_id)\n\n    tag_deployments.each do |tag_dep|\n      stored_tags_records = AnswerTag.where(tag_prompt_deployment_id: tag_dep.id)\n      stored_tags_records = stored_tags_records.where(user_id: params[:user_id]) if params.key?(:user_id)\n      stored_tags_records.each do |stored_tag|\n        @tag_prompts.append stored_tag\n      end",
    "comment": "GET /answer_tags?assignment_id=xx&user_id=xx&questionnaire_id=xx",
    "label": "what",
    "id": "405"
  },
  {
    "raw_code": "def create_edit\n    @tag = AnswerTag.where(user_id: current_user,\n                           answer_id: params[:answer_id],\n                           tag_prompt_deployment_id: params[:tag_prompt_deployment_id]).first_or_create\n                    .update_attributes!(value: params[:value])\n\n    render json: @tag\n  end",
    "comment": "POST /answer_tags/create_edit",
    "label": "what",
    "id": "406"
  },
  {
    "raw_code": "def destroy; end\nend",
    "comment": "DELETE /answer_tags/1",
    "label": "what",
    "id": "407"
  },
  {
    "raw_code": "def start\n    @model = params[:model]\n    titles = { 'Assignment' => 'Grades', 'CourseParticipant' => 'Course Participants', 'AssignmentTeam' => 'Teams',\n               'CourseTeam' => 'Teams', 'User' => 'Users', 'Question' => 'Questions' }\n    @title = titles[@model]\n    @id = params[:id]\n  end",
    "comment": "Assign titles to model for display",
    "label": "what",
    "id": "408"
  },
  {
    "raw_code": "def find_delim_filename(delim_type, other_char, suffix = '')\n    if delim_type == 'comma'\n      filename = params[:model] + params[:id] + suffix + '.csv'\n      delimiter = ','\n    elsif delim_type == 'space'\n      filename = params[:model] + params[:id] + suffix + '.csv'\n      delimiter = ' '\n    elsif delim_type == 'tab'\n      filename = params[:model] + params[:id] + suffix + '.csv'\n      delimiter = \"\\t\"\n    elsif delim_type == 'other'\n      filename = params[:model] + params[:id] + suffix + '.csv'\n      delimiter = other_char\n    end",
    "comment": "Find the filename and delimiter",
    "label": "what",
    "id": "409"
  },
  {
    "raw_code": "def export_advices\n    @delim_type = params[:delim_type]\n    filename, delimiter = find_delim_filename(@delim_type, params[:other_char])\n\n    allowed_models = ['Question']\n    advice_model = 'QuestionAdvice'\n\n    csv_data = CSV.generate(col_sep: delimiter) do |csv|\n      if allowed_models.include? params[:model]\n        csv << Object.const_get(advice_model).export_fields(params[:options])\n        Object.const_get(advice_model).export(csv, params[:id], params[:options])\n      end",
    "comment": "Export question advice data to CSV file",
    "label": "what",
    "id": "410"
  },
  {
    "raw_code": "def action_allowed?\n    current_user_has_ta_privileges?\n  end",
    "comment": "duties can be created/modified by Teaching Assistants, Instructor, Admin, Super Admin",
    "label": "what",
    "id": "411"
  },
  {
    "raw_code": "def index\n    @duties = Duty.all\n  end",
    "comment": "GET /duties",
    "label": "what",
    "id": "412"
  },
  {
    "raw_code": "def show; end\n\n  # GET /duties/new\n  def new\n    @duty = Duty.new\n    @id = params[:id]\n  end\n\n  # GET /duties/1/edit\n  def edit; end\n\n  # POST /duties\n  def create\n    @duty = Duty.new(duty_params)\n\n    if @duty.save\n      # When the duty (role) is created successfully we return back to the assignment edit page\n      redirect_to edit_assignment_path(params[:duty][:assignment_id]), notice: 'Role was successfully created.'\n    else\n      redirect_to_create_page_and_show_error\n    end\n  end\n\n  # PATCH/PUT /duties/1\n  def update\n    @duty = Duty.find(params[:id])\n\n    if @duty.update_attributes(duty_params)\n      redirect_to edit_assignment_path(params[:duty][:assignment_id]), notice: 'Role was successfully updated.'\n    else\n      redirect_to_create_page_and_show_error\n    end\n  end",
    "comment": "GET /duties/1",
    "label": "what",
    "id": "413"
  },
  {
    "raw_code": "def set_duty\n    @duty = Duty.find(params[:id])\n  end",
    "comment": "Use callbacks to share common setup or constraints between actions.",
    "label": "what",
    "id": "414"
  },
  {
    "raw_code": "def action_allowed?\n    current_user_has_ta_privileges?\n  end",
    "comment": "Give permission to manage notifications to appropriate roles",
    "label": "what",
    "id": "415"
  },
  {
    "raw_code": "def list\n    @notifications = Notification.all\n  end",
    "comment": "GET /notifications",
    "label": "what",
    "id": "416"
  },
  {
    "raw_code": "def index\n    @notifications = Notification.all\n  end",
    "comment": "GET /notifications",
    "label": "what",
    "id": "417"
  },
  {
    "raw_code": "def show; end\n\n  # GET /notifications/new\n  def new\n    @notification = Notification.new\n  end\n\n  # GET /notifications/1/edit\n  def edit; end\n\n  # POST /notifications\n  def create\n    if params[:notification]\n      redirect_back fallback_location: root_path\n      return\n    end\n    @notification = Notification.new(notification_params)\n\n    if @notification.save\n      redirect_to @notification\n      flash[:success] = 'Notification was successfully created.'\n    else\n      render :new\n    end\n  end",
    "comment": "GET /notifications/1",
    "label": "what",
    "id": "418"
  },
  {
    "raw_code": "def update\n    if @notification.update(notification_params)\n      redirect_to @notification\n      flash[:success] = 'Notification was successfully updated.'\n    else\n      render :edit\n    end",
    "comment": "PATCH/PUT /notifications/1",
    "label": "what",
    "id": "419"
  },
  {
    "raw_code": "def destroy\n    # Remove any hidden notifications\n    @individual_notification = TrackNotification.all\n    @individual_notification.each do |notification|\n      notification.destroy if notification.notification_id == @notification.id\n    end",
    "comment": "DELETE /notifications/1",
    "label": "what",
    "id": "420"
  },
  {
    "raw_code": "def set_notification\n    @notification = Notification.find(params[:id])\n  end",
    "comment": "Use callbacks to share common setup or constraints between actions.",
    "label": "what",
    "id": "421"
  },
  {
    "raw_code": "def notification_params\n    params.require(:notification).permit(:course_id, :subject, :description, :expiration_date, :active_flag)\n  end",
    "comment": "Only allow a trusted parameter \"white list\" through.",
    "label": "what",
    "id": "422"
  },
  {
    "raw_code": "def action_allowed?\n    case params[:action]\n    # If the action is creating a new late policy then verifies the current user has the prvilages to perform the action or not.\n    when 'new', 'create', 'index'\n      current_user_has_ta_privileges?\n    # If the action is to edit/update or destroy a late policy then verifies if the current user has the prvilages to perform the action or not.\n    when 'edit', 'update', 'destroy'\n      current_user_has_ta_privileges? &&\n        current_user.instructor_id == instructor_id\n    end",
    "comment": "This method checks the privileges of the current user to perform a certain action.",
    "label": "what",
    "id": "423"
  },
  {
    "raw_code": "def index\n    @penalty_policies = LatePolicy.where(['instructor_id = ? OR private = 0', instructor_id])\n    respond_to do |format|\n      format.html # index.html.erb\n      format.xml  { render xml: @penalty_policies }\n    end",
    "comment": "This method lists all the late policies records from late_policies table in database.",
    "label": "what",
    "id": "424"
  },
  {
    "raw_code": "def show\n    @penalty_policy = LatePolicy.find(params[:id])\n    respond_to do |format|\n      format.html # show.html.erb\n      format.xml  { render xml: @penalty_policy }\n    end",
    "comment": "This method displays a certain record in late_policies table in the database.",
    "label": "what",
    "id": "425"
  },
  {
    "raw_code": "def new\n    @penalty_policy = LatePolicy.new\n    respond_to do |format|\n      format.html # new.html.erb\n      format.xml  { render xml: @penalty_policy }\n    end",
    "comment": "New method creates instance of a late policy in the late_policies's table but does not saves in the database.",
    "label": "what",
    "id": "426"
  },
  {
    "raw_code": "def edit\n    @penalty_policy = LatePolicy.find(params[:id])\n  end",
    "comment": "This method just fetch a particular record in LatePolicy table.",
    "label": "what",
    "id": "427"
  },
  {
    "raw_code": "def create\n    # First this function validates the input then save if the input is valid.\n    valid_penalty, error_message = validate_input\n    if error_message\n      flash[:error] = error_message\n    end",
    "comment": "Create method can create a new late policy. There are few check points before creating a late policy which are written in the if/else statements.",
    "label": "what",
    "id": "428"
  },
  {
    "raw_code": "def update\n    penalty_policy = LatePolicy.find(params[:id])\n\n    # First this function validates the input then save if the input is valid.\n    _valid_penalty, error_message = validate_input(true)\n    if error_message\n      flash[:error] = error_message\n      redirect_to action: 'edit', id: params[:id]\n    # If there are no errors, then save the record.\n    else\n      begin\n        penalty_policy.update_attributes(late_policy_params)\n        penalty_policy.save!\n        LatePolicy.update_calculated_penalty_objects(penalty_policy)\n        flash[:notice] = 'The late policy was successfully updated.'\n        redirect_to action: 'index'\n      # If something unexpected happens while updating, then redirect to the edit page of that policy again.\n      rescue StandardError\n        flash[:error] = 'The following error occurred while updating the late policy: '\n        redirect_to action: 'edit', id: params[:id]\n      end",
    "comment": "Update method can update late policy. There are few check points before updating a late policy which are written in the if/else statements.",
    "label": "what",
    "id": "429"
  },
  {
    "raw_code": "def destroy\n    @penalty_policy = LatePolicy.find(params[:id])\n    begin\n      @penalty_policy.destroy\n    rescue StandardError\n      flash[:error] = 'This policy is in use and hence cannot be deleted.'\n    end",
    "comment": "This method fetches a particular record in the late_policy table and try to destroy's it.",
    "label": "what",
    "id": "430"
  },
  {
    "raw_code": "def late_policy_params\n    params.require(:late_policy).permit(:policy_name, :penalty_per_unit, :penalty_unit, :max_penalty)\n  end",
    "comment": "This function ensures that a specific parameter is present.If not then throws and error.",
    "label": "what",
    "id": "431"
  },
  {
    "raw_code": "def instructor_id\n    late_policy.try(:instructor_id) ||\n      current_user.instructor_id\n  end",
    "comment": "This function check's if the current user is instructor or not.If not then throws and error.",
    "label": "what",
    "id": "432"
  },
  {
    "raw_code": "def duplicate_name_check(is_update = false)\n    should_check = true\n    prefix = is_update ? \"Cannot edit the policy. \" : \"\"\n    valid_penalty, error_message = true, nil\n\n    if is_update\n      existing_late_policy = LatePolicy.find(params[:id])\n      if existing_late_policy.policy_name == params[:late_policy][:policy_name]\n        should_check = false\n      end",
    "comment": "This function checks if the policy name already exists or not and returns boolean value for penalty and the error message.",
    "label": "what",
    "id": "433"
  },
  {
    "raw_code": "def validate_input(is_update = false)\n    # Validates input for create and update forms\n    max_penalty = params[:late_policy][:max_penalty].to_i\n    penalty_per_unit = params[:late_policy][:penalty_per_unit].to_i\n\n    valid_penalty, error_message = duplicate_name_check(is_update)\n    prefix = is_update ? \"Cannot edit the policy. \" : \"\"\n\n    # This check validates the maximum penalty.\n    if max_penalty < penalty_per_unit\n      error_message = prefix + 'The maximum penalty cannot be less than penalty per unit.'\n      valid_penalty = false\n    end",
    "comment": "This function validates the input.",
    "label": "what",
    "id": "434"
  },
  {
    "raw_code": "def specific_average_score(bookmark)\n    if bookmark.nil?\n      '-'\n    else\n      assessment = SignUpTopic.find(bookmark.topic_id).assignment\n      questions = assessment.questionnaires.where(type: 'BookmarkRatingQuestionnaire').flat_map(&:questions)\n      responses = BookmarkRatingResponseMap.where(\n        reviewed_object_id: assessment.id,\n        reviewee_id: bookmark.id,\n        reviewer_id: AssignmentParticipant.find_by(user_id: current_user.id).id\n      ).flat_map { |r| Response.where(map_id: r.id) }\n      score = assessment_score(response: responses, questions: questions)\n      if score.nil?\n        return '-'\n      else\n        (score * 5.0 / 100.0).round(2)\n      end",
    "comment": "calculate average questionnaire score for 'Your rating' for specific bookmark",
    "label": "what",
    "id": "435"
  },
  {
    "raw_code": "def total_average_score(bookmark)\n    if bookmark.nil?\n      '-'\n    else\n      assessment = SignUpTopic.find(bookmark.topic_id).assignment\n      questions = assessment.questionnaires.where(type: 'BookmarkRatingQuestionnaire').flat_map(&:questions)\n      responses = BookmarkRatingResponseMap.where(\n        reviewed_object_id: assessment.id,\n        reviewee_id: bookmark.id\n      ).flat_map { |r| Response.where(map_id: r.id) }\n      totalScore = aggregate_assessment_scores(responses, questions)\n      if totalScore[:avg].nil?\n        return '-'\n      else\n        (totalScore[:avg] * 5.0 / 100.0).round(2)\n      end",
    "comment": "calculate average questionnaire score for 'Avg. rating' for specific bookmark",
    "label": "what",
    "id": "436"
  },
  {
    "raw_code": "def create_bookmark_params\n    params.permit(:url, :title, :description, :topic_id, :rating, :id)\n  end",
    "comment": "TODO: Create a common definition for both create and update to reduce it to single params method Change create method to take bookmark param as required.",
    "label": "what",
    "id": "437"
  },
  {
    "raw_code": "def self.take_quiz(assignment_id, reviewer_id)\n    quizzes = []\n    reviewer = Participant.where(user_id: reviewer_id, parent_id: assignment_id).first\n    reviewed_team_response_maps = ReviewResponseMap.where(reviewer_id: reviewer.id)\n    reviewed_team_response_maps.each do |team_response_map_record|\n      reviewee_id = team_response_map_record.reviewee_id\n      reviewee_team = Team.find(reviewee_id) # reviewees should always be teams\n      next unless reviewee_team.parent_id == assignment_id\n\n      quiz_questionnaire = QuizQuestionnaire.where(instructor_id: reviewee_team.id).first\n\n      # if the reviewee team has created quiz\n      if quiz_questionnaire\n        quizzes << quiz_questionnaire unless quiz_questionnaire.taken_by? reviewer\n      end",
    "comment": "Create an array of candidate quizzes for current reviewer",
    "label": "what",
    "id": "438"
  },
  {
    "raw_code": "def calculate_score(map, response)\n    questionnaire = Questionnaire.find(map.reviewed_object_id)\n    scores = []\n    valid = true\n    questions = Question.where(questionnaire_id: questionnaire.id)\n    questions.each do |question|\n      score = 0\n      correct_answers = QuizQuestionChoice.where(question_id: question.id, iscorrect: true)\n      ques_type = question.type\n      if ques_type.eql? 'MultipleChoiceCheckbox'\n        if params[question.id.to_s].nil?\n          valid = false\n        else\n          params[question.id.to_s].each do |choice|\n            # loop the quiz taker's choices and see if 1)all the correct choice are checked and 2) # of quiz taker's choice matches the # of the correct choices\n            correct_answers.each do |correct|\n              score += 1 if choice.eql? correct.txt\n            end",
    "comment": "the way 'answers' table store the results of quiz",
    "label": "what",
    "id": "439"
  },
  {
    "raw_code": "def review_questions\n    @assignment_id = params[:id]\n    @quiz_questionnaires = []\n    Team.where(parent_id: params[:id]).each do |quiz_creator|\n      Questionnaire.where(instructor_id: quiz_creator.id).each do |questionnaire|\n        @quiz_questionnaires.push questionnaire\n      end",
    "comment": "This method is only for quiz questionnaires, it is called when instructors click \"view quiz questions\" on the pop-up panel.",
    "label": "what",
    "id": "440"
  },
  {
    "raw_code": "def index\n    list\n    render action: 'list'\n  end",
    "comment": "Default action, same as list",
    "label": "what",
    "id": "441"
  },
  {
    "raw_code": "def list\n    @questions = Question.paginate(page: params[:page], per_page: 10)\n  end",
    "comment": "List all questions in paginated view",
    "label": "what",
    "id": "442"
  },
  {
    "raw_code": "def show\n    @question = Question.find(params[:id])\n  end",
    "comment": "Display a given question",
    "label": "what",
    "id": "443"
  },
  {
    "raw_code": "def new\n    @question = Question.new\n  end",
    "comment": "Provide the user with the ability to define a new question",
    "label": "what",
    "id": "444"
  },
  {
    "raw_code": "def create\n    @question = Question.new(question_params[:question])\n    if @question.save\n      flash[:notice] = 'The question was successfully created.'\n      redirect_to action: 'list'\n    else\n      render action: 'new'\n    end",
    "comment": "Save a question created by the user follows from new",
    "label": "what",
    "id": "445"
  },
  {
    "raw_code": "def edit\n    @question = Question.find(params[:id])\n  end",
    "comment": "edit an existing question",
    "label": "what",
    "id": "446"
  },
  {
    "raw_code": "def update\n    @question = Question.find(question_params[:id])\n    if @question.update_attributes(question_params[:question])\n      flash[:notice] = 'The question was successfully updated.'\n      redirect_to action: 'show', id: @question\n    else\n      render action: 'edit'\n    end",
    "comment": "save the update to an existing question follows from edit",
    "label": "what",
    "id": "447"
  },
  {
    "raw_code": "def destroy\n    question = Question.find(params[:id])\n    questionnaire_id = question.questionnaire_id\n\n    if AnswerHelper.check_and_delete_responses(questionnaire_id)\n      flash[:success] = 'You have successfully deleted the question. Any existing reviews for the questionnaire have been deleted!'\n    else\n      flash[:success] = 'You have successfully deleted the question!'\n    end",
    "comment": "Remove question from database and return to list",
    "label": "what",
    "id": "448"
  },
  {
    "raw_code": "def types\n    types = Question.distinct.pluck(:type)\n    render json: types.to_a\n  end",
    "comment": "required for answer tagging",
    "label": "what",
    "id": "449"
  },
  {
    "raw_code": "def save_new_questions(questionnaire_id, questionnaire_type)\n    if params[:new_question]\n      # The new_question array contains all the new questions\n      # that should be saved to the database\n      params[:new_question].keys.each_with_index do |question_key, index|\n        q = Question.new\n        q.txt = params[:new_question][question_key]\n        q.questionnaire_id = questionnaire_id\n        q.type = params[:question_type][question_key][:type]\n        q.seq = question_key.to_i\n        if questionnaire_type == 'QuizQuestionnaire'\n          weight_key = \"question_#{index + 1}\"\n          q.weight = params[:question_weights][weight_key.to_sym]\n        end",
    "comment": "save all questions that have been added to a questionnaire uses the params new_question if the questionnaire is a quizquestionnaire then use weights given",
    "label": "what",
    "id": "450"
  },
  {
    "raw_code": "def delete_questions(questionnaire_id)\n    # Deletes any questions that, as a result of the edit, are no longer in the questionnaire\n    questions = Question.where('questionnaire_id = ?', questionnaire_id)\n    @deleted_questions = []\n    questions.each do |question|\n      should_delete = true\n      unless question_params.nil?\n        params[:question].each_key do |question_key|\n          should_delete = false if question_key.to_s == question.id.to_s\n        end",
    "comment": "delete questions from a questionnaire uses params questionnaire_id checks if the questions passed in params belongs to this questionnaire or not if yes then it is deleted",
    "label": "what",
    "id": "451"
  },
  {
    "raw_code": "def save_questions\n    questionnaire_id = params[:questionnaire_id]\n    questionnaire_type = params[:questionnaire_type]\n    delete_questions questionnaire_id\n    save_new_questions(questionnaire_id, questionnaire_type)\n    if params[:question]\n      params[:question].keys.each do |question_key|\n        if params[:question][question_key][:txt].strip.empty?\n          Question.delete(question_key)\n        else\n          question = Question.find(question_key)\n          Rails.logger.info(question.errors.messages.inspect) unless question.update_attributes(params[:question][question_key])\n        end",
    "comment": "Handles questions whose wording changed as a result of the edit uses params questionnaire_id uses params questionnaire_type if the question text is empty then it is deleted else it is updated",
    "label": "what",
    "id": "452"
  },
  {
    "raw_code": "def mentor\n     return unless current_user_id? student.user_id\n     # Default return to views/student_team/mentor utilized\n  end",
    "comment": "E2351 Adding a new view for mentors to be able to see all teams that they are mentoring for the selected assignment This replaces the typical student view where the team they are on would be displayed This was necessary because a mentor could be assigned to multiple teams and the view file for that would not have been easily adapted to accommodate this.",
    "label": "what",
    "id": "453"
  },
  {
    "raw_code": "def review\n    @assignment = Assignment.find params[:assignment_id]\n    redirect_to view_questionnaires_path id: @assignment.questionnaires.find_by(type: 'AuthorFeedbackQuestionnaire').id\n  end",
    "comment": "This method is used to show the Author Feedback Questionnaire of current assignment",
    "label": "what",
    "id": "454"
  },
  {
    "raw_code": "def student_team_requirements_met?\n    # checks if the student has a team\n    return false if @student.team.nil?\n    # checks that the student's team has a topic\n    return false if @student.team.topic.nil?\n\n    # checks that the student has selected some topics\n    @student.assignment.topics?\n  end",
    "comment": "used to check student team requirements",
    "label": "what",
    "id": "455"
  },
  {
    "raw_code": "def new\n    @private = params[:private]\n  end",
    "comment": "Creates a new course if private is set to 1, then the course will only be available to the instructor who created it.",
    "label": "what",
    "id": "456"
  },
  {
    "raw_code": "def edit\n    @course = Course.find(params[:id])\n  end",
    "comment": "GET /courses/1/edit",
    "label": "what",
    "id": "457"
  },
  {
    "raw_code": "def update\n    @course = Course.find(params[:id])\n    unless params[:course][:directory_path].nil? || @course.directory_path == params[:course][:directory_path]\n      begin\n        FileHelper.delete_directory(@course)\n      rescue StandardError\n        flash[:error] = $ERROR_INFO\n      end",
    "comment": "POST /courses",
    "label": "what",
    "id": "458"
  },
  {
    "raw_code": "def copy\n    orig_course = Course.find(params[:id])\n    new_course = orig_course.dup\n    new_course.instructor_id = session[:user].id\n    new_course.name = 'Copy of ' + orig_course.name\n    new_course.directory_path = new_course.directory_path + '_copy'\n    begin\n      new_course.save!\n      parent_id = CourseNode.get_parent_id\n      if parent_id\n        CourseNode.create(node_object_id: new_course.id, parent_id: parent_id)\n      else\n        CourseNode.create(node_object_id: new_course.id)\n      end",
    "comment": "Create a copy of a course with a new submission directory",
    "label": "what",
    "id": "459"
  },
  {
    "raw_code": "def create\n    @course = Course.new\n    set_course_fields(@course)\n    @course.instructor_id = session[:user].id\n    begin\n      @course.save!\n      CourseNode.create_course_node(@course)\n      FileHelper.create_directory(@course)\n      undo_link(\"The course \\\"#{@course.name}\\\" has been successfully created.\")\n      redirect_to controller: 'tree_display', action: 'list'\n    rescue StandardError\n      flash[:error] = $ERROR_INFO # \"The following error occurred while saving the course: #\"+\n      redirect_to action: 'new'\n    end",
    "comment": "create a course",
    "label": "what",
    "id": "460"
  },
  {
    "raw_code": "def delete\n    @course = Course.find(params[:id])\n    begin\n      FileHelper.delete_directory(@course)\n    rescue StandardError\n      flash[:error] = $ERROR_INFO\n    end",
    "comment": "delete the course",
    "label": "what",
    "id": "461"
  },
  {
    "raw_code": "def view_teaching_assistants\n    @course = Course.find(params[:id])\n    @ta_mappings = @course.ta_mappings\n  end",
    "comment": "Displays all the teaching assistants for a course",
    "label": "what",
    "id": "462"
  },
  {
    "raw_code": "def add_ta\n    @course = Course.find(params[:course_id])\n    @user = User.find_by(name: params[:user][:name])\n    if @user.nil?\n      flash.now[:error] = 'The user inputted \"' + params[:user][:name] + '\" does not exist.'\n    elsif !TaMapping.where(ta_id: @user.id, course_id: @course.id).empty?\n      flash.now[:error] = 'The user inputted \"' + params[:user][:name] + '\" is already a TA for this course.'\n    else\n      @ta_mapping = TaMapping.create(ta_id: @user.id, course_id: @course.id)\n      @user.role = Role.find_by name: 'Teaching Assistant'\n      @user.save\n\n      @course = @ta_mapping\n      undo_link(\"The TA \\\"#{@user.name}\\\" has been successfully added.\")\n    end",
    "comment": "Adds a teaching assistant to a course",
    "label": "what",
    "id": "463"
  },
  {
    "raw_code": "def remove_ta\n    @ta_mapping = TaMapping.find(params[:id])\n    @ta = User.find(@ta_mapping.ta_id)\n\n    # if the user does not have any other TA mappings, then the role should be changed to student\n    other_ta_mappings_num = TaMapping.where(ta_id: @ta_mapping.ta_id).size - 1\n    if other_ta_mappings_num.zero?\n      @ta.role = Role.find_by name: 'Student'\n      @ta.save\n    end",
    "comment": "Remove a teaching assistant from a course",
    "label": "what",
    "id": "464"
  },
  {
    "raw_code": "def set_course_fields(_course)\n    @course.name = params[:course][:name]\n    @course.institutions_id = params[:course][:institutions_id]\n    @course.directory_path = params[:course][:directory_path]\n    @course.info = params[:course][:info]\n    @course.private = params[:course][:private].nil? ? 0 : params[:course][:private]\n    @course.locale = params[:course][:locale]\n  end",
    "comment": "This method is called in the update and create methods to set the fields of a course",
    "label": "what",
    "id": "465"
  },
  {
    "raw_code": "def author_feedback_popup\n    @response_id = params[:response_id]\n    @reviewee_id = params[:reviewee_id]\n    first_question_in_questionnaire = Answer.where(response_id: @response_id).first\n    unless @response_id.nil? || first_question_in_questionnaire.nil?\n      questionnaire_id = Question.find(first_question_in_questionnaire.question_id).questionnaire_id\n      questionnaire = Questionnaire.find(questionnaire_id)\n      @maxscore = questionnaire.max_question_score\n      @scores = Answer.where(response_id: @response_id)\n      @response = Response.find(@response_id)\n      @total_percentage = @response.average_score\n      @sum = @response.aggregate_questionnaire_score\n      @total_possible = @response.maximum_score\n    end",
    "comment": "this can be called from \"response_report\" by clicking student names from instructor end.",
    "label": "what",
    "id": "466"
  },
  {
    "raw_code": "def team_users_popup\n    @ip = session[:ip]\n    @sum = 0\n    @team = Team.find(params[:id])\n    @assignment = Assignment.find(@team.parent_id)\n    @team_users = TeamsUser.where(team_id: params[:id])\n\n    # id2 is a response_map id\n    unless params[:id2].nil?\n      # E1973 - we set the reviewer id either to the student's user id or the current reviewer id\n      # This results from reviewers being either assignment participants or assignment teams.\n      # If the reviewer is a participant, the id is currently the id of the assignment participant.\n      # However, we want their user_id. This is not possible for teams, so we just return the current id\n      reviewer_id = ResponseMap.find(params[:id2]).reviewer_id\n      # E2060 - we had to change this if/else clause in order to properly view reports page\n      @reviewer_id = if @assignment.team_reviewing_enabled\n                       reviewer_id\n                     else\n                       Participant.find(reviewer_id).user_id\n                     end",
    "comment": "this can be called from \"response_report\" by clicking team names from instructor end.",
    "label": "what",
    "id": "467"
  },
  {
    "raw_code": "def view_review_scores_popup\n    @ip = session[:ip]\n    @reviewer_id = params[:reviewer_id]\n    @assignment_id = params[:assignment_id]\n    @review_final_versions = ReviewResponseMap.final_versions_from_reviewer(@assignment_id, @reviewer_id)\n    @reviews = []\n  end",
    "comment": "Views tone analysis report and heatmap",
    "label": "what",
    "id": "468"
  },
  {
    "raw_code": "def reviewer_details_popup\n    @userid = Participant.find(params[:id]).user_id\n    @user = User.find(@userid)\n    @id = params[:assignment_id]\n  end",
    "comment": "this can be called from \"response_report\" by clicking reviewer names from instructor end.",
    "label": "what",
    "id": "469"
  },
  {
    "raw_code": "def self_review_popup\n    @response_id = params[:response_id]\n    @user_fullname = params[:user_fullname]\n    unless @response_id.nil?\n      first_question_in_questionnaire = Answer.where(response_id: @response_id).first.question_id\n      questionnaire_id = Question.find(first_question_in_questionnaire).questionnaire_id\n      questionnaire = Questionnaire.find(questionnaire_id)\n      @maxscore = questionnaire.max_question_score\n      @scores = Answer.where(response_id: @response_id)\n      @response = Response.find(@response_id)\n      @total_percentage = @response.average_score\n      @sum = @response.aggregate_questionnaire_score\n      @total_possible = @response.maximum_score\n    end",
    "comment": "this can be called from \"response_report\" by clicking reviewer names from instructor end.",
    "label": "what",
    "id": "470"
  },
  {
    "raw_code": "def action_allowed?\n    if params[:action] == 'edit'\n      @questionnaire = Questionnaire.find(params[:id])\n      current_user_has_admin_privileges? || current_user_is_a?('Student')\n    else\n      current_user_has_student_privileges?\n    end",
    "comment": "Quiz questionnaire edit option to be allowed for student",
    "label": "what",
    "id": "471"
  },
  {
    "raw_code": "def view\n    @questionnaire = Questionnaire.find(params[:id])\n    @participant = Participant.find(params[:pid]) # creating an instance variable since it needs to be sent to submitted_content/edit\n    render :view\n  end",
    "comment": "View a quiz questionnaire",
    "label": "what",
    "id": "472"
  },
  {
    "raw_code": "def create\n    valid = validate_quiz\n    if valid.eql?('valid') # The value of valid could either be \"valid\" or a string indicating why the quiz cannot be created\n      @questionnaire = QuizQuestionnaire.new(questionnaire_params)\n      participant_id = params[:pid] # Gets the participant id to be used when finding team and editing submitted content\n      @questionnaire.min_question_score = params[:questionnaire][:min_question_score] # 0\n      @questionnaire.max_question_score = params[:questionnaire][:max_question_score] # 1\n\n      author_team = AssignmentTeam.team(Participant.find(participant_id)) # Gets the participant's team for the assignment\n\n      @questionnaire.instructor_id = author_team.id # for a team assignment, set the instructor id to the team_id\n\n      if @questionnaire.min_question_score < 0 || @questionnaire.max_question_score < 0\n        flash[:error] = 'Minimum and/or maximum question score cannot be less than 0.'\n        redirect_back fallback_location: root_path\n      elsif @questionnaire.max_question_score < @questionnaire.min_question_score\n        flash[:error] = 'Maximum question score cannot be less than minimum question score.'\n        redirect_back fallback_location: root_path\n      else\n        @successful_create = true\n        save\n        save_choices @questionnaire.id\n        flash[:note] = 'The quiz was successfully created.' if @successful_create\n        redirect_to controller: 'submitted_content', action: 'edit', id: participant_id\n      end",
    "comment": "create quiz questionnaire",
    "label": "what",
    "id": "473"
  },
  {
    "raw_code": "def edit\n    @questionnaire = Questionnaire.find(params[:id])\n    if @questionnaire.taken_by_anyone?\n      flash[:error] = 'Your quiz has been taken by one or more students; you cannot edit it anymore.'\n      redirect_to controller: 'submitted_content', action: 'view', id: params[:pid]\n    else # quiz can be edited only if its not taken by anyone\n      render :'questionnaires/edit'\n    end",
    "comment": "edit a quiz questionnaire",
    "label": "what",
    "id": "474"
  },
  {
    "raw_code": "def update\n    @questionnaire = Questionnaire.find(params[:id])\n    if @questionnaire.nil?\n      redirect_to controller: 'submitted_content', action: 'view', id: params[:pid]\n      return\n    end",
    "comment": "save an updated quiz questionnaire to the database",
    "label": "what",
    "id": "475"
  },
  {
    "raw_code": "def validate_quiz\n    num_questions = Assignment.find(params[:aid]).num_quiz_questions\n    valid = 'valid'\n    if params[:questionnaire][:name] == '' # questionnaire name is not specified\n      valid = 'Please specify quiz name (please do not use your name or id).'\n    end",
    "comment": "validate quiz name, questions, answers Returns \"valid\" if there are no issues, or a string indicating why the quiz is invalid",
    "label": "what",
    "id": "476"
  },
  {
    "raw_code": "def validate_question(i)\n    if params.key?(:question_type) && params[:question_type].key?(i.to_s) && params[:question_type][i.to_s][:type]\n      # The question type is dynamic, so const_get is necessary\n      type = params[:question_type][i.to_s][:type]\n      @new_question = Object.const_get(type).create(txt: '', type: type, break_before: true)\n      @new_question.update_attributes(txt: params[:new_question][i.to_s])\n      choice_info = params[:new_choices][i.to_s][type] # choice info for one question of its type\n      valid = if choice_info.nil?\n                'Please select a correct answer for all questions'\n              else\n                @new_question.isvalid(choice_info)\n              end",
    "comment": "A question is valid if it has a valid type ('TrueFalse', 'MultipleChoiceCheckbox', 'MultipleChoiceRadio') and a correct answer selected",
    "label": "what",
    "id": "477"
  },
  {
    "raw_code": "def create_multchoice(question, choice_key, q_answer_choices)\n    # this method combines the functionality of create_radio and create_checkbox, so that all mult choice items are create by 1 func\n    question_choice = if q_answer_choices[choice_key][:iscorrect] == 1.to_s\n                        QuizQuestionChoice.new(txt: q_answer_choices[choice_key][:txt], iscorrect: 'true', question_id: question.id)\n                      else\n                        QuizQuestionChoice.new(txt: q_answer_choices[choice_key][:txt], iscorrect: 'false', question_id: question.id)\n                      end",
    "comment": "create multiple choice (radio or checkbox) item(s)",
    "label": "what",
    "id": "478"
  },
  {
    "raw_code": "def create_truefalse(question, choice_key, q_answer_choices)\n    if q_answer_choices[1.to_s][:iscorrect] == choice_key\n      question_choice = QuizQuestionChoice.new(txt: 'True', iscorrect: 'true', question_id: question.id)\n      question_choice.save\n      question_choice = QuizQuestionChoice.new(txt: 'False', iscorrect: 'false', question_id: question.id)\n      question_choice.save\n    else\n      question_choice = QuizQuestionChoice.new(txt: 'True', iscorrect: 'false', question_id: question.id)\n      question_choice.save\n      question_choice = QuizQuestionChoice.new(txt: 'False', iscorrect: 'true', question_id: question.id)\n      question_choice.save\n    end",
    "comment": "create true/false item",
    "label": "what",
    "id": "479"
  },
  {
    "raw_code": "def update_checkbox(question_choice, question_index)\n    if params[:quiz_question_choices][@question.id.to_s][@question.type][question_index.to_s]\n      question_choice.update_attributes(\n        iscorrect: params[:quiz_question_choices][@question.id.to_s][@question.type][question_index.to_s][:iscorrect],\n        txt: params[:quiz_question_choices][@question.id.to_s][@question.type][question_index.to_s][:txt]\n      )\n    else\n      question_choice.update_attributes(\n        iscorrect: '0',\n        txt: params[:quiz_question_choices][question_choice.id.to_s][:txt]\n      )\n    end",
    "comment": "update checkbox item",
    "label": "what",
    "id": "480"
  },
  {
    "raw_code": "def update_radio(question_choice, question_index)\n    if params[:quiz_question_choices][@question.id.to_s][@question.type][:correctindex] == question_index.to_s\n      question_choice.update_attributes(\n        iscorrect: '1',\n        txt: params[:quiz_question_choices][@question.id.to_s][@question.type][question_index.to_s][:txt]\n      )\n    else\n      question_choice.update_attributes(\n        iscorrect: '0',\n        txt: params[:quiz_question_choices][@question.id.to_s][@question.type][question_index.to_s][:txt]\n      )\n    end",
    "comment": "update radio item",
    "label": "what",
    "id": "481"
  },
  {
    "raw_code": "def update_truefalse(question_choice)\n    if params[:quiz_question_choices][@question.id.to_s][@question.type][1.to_s][:iscorrect] == 'True' # the statement is correct\n      question_choice.txt == 'True' ? question_choice.update_attributes(iscorrect: '1') : question_choice.update_attributes(iscorrect: '0')\n      # the statement is correct so \"True\" is the right answer\n    else # the statement is not correct\n      question_choice.txt == 'True' ? question_choice.update_attributes(iscorrect: '0') : question_choice.update_attributes(iscorrect: '1')\n      # the statement is not correct so \"False\" is the right answer\n    end",
    "comment": "update true/false item",
    "label": "what",
    "id": "482"
  },
  {
    "raw_code": "def save\n    @questionnaire.save!\n    undo_link(\"Questionnaire \\\"#{@questionnaire.name}\\\" has been updated successfully. \")\n  end",
    "comment": "save questionnaire",
    "label": "what",
    "id": "483"
  },
  {
    "raw_code": "def save_questions(questionnaire_id)\n    redirect_to controller: 'questions', action: 'delete_questions', questionnaire_id: @questionnaire.id and return\n    redirect_to controller: 'question', action: 'save_new_questions', questionnaire_id: @questionnaire.id, questionnaire_type: @questionnaire.type\n    if params[:question]\n      params[:question].each_key do |question_key|\n        if params[:question][question_key][:txt].strip.empty?\n          # question text is empty, delete the question\n          Question.delete(question_key)\n        else\n          # Update existing question.\n          question = Question.find(question_key)\n          Rails.logger.info(question.errors.messages.inspect) unless question.update_attributes(params[:question][question_key])\n        end",
    "comment": "save questions",
    "label": "what",
    "id": "484"
  },
  {
    "raw_code": "def save_choices(questionnaire_id)\n    return unless params[:new_question] || params[:new_choices]\n\n    questions = Question.where(questionnaire_id: questionnaire_id)\n    question_num = 1\n\n    questions.each do |question|\n      q_type = params[:question_type][question_num.to_s][:type]\n      q_answer_choices = params[:new_choices][question_num.to_s][q_type]\n      q_answer_choices.each_pair do |choice_key, _| # _ is dummy variable\n        question_factory(q_type, question, choice_key, q_answer_choices) # allow factory method to create appropriate question\n      end",
    "comment": "Saves either True/False or Multiple Choice questions to a quiz questionnaire Only scorable questions can be added to a quiz, but future projects could consider relaxing this constraint",
    "label": "what",
    "id": "485"
  },
  {
    "raw_code": "def question_factory(q_type, question, choice_key, q_answer_choices)\n    if q_type == 'TrueFalse'\n      create_truefalse(question, choice_key, q_answer_choices)\n    else # create MultipleChoice of either type, rather than creating them separately based on q_type\n      create_multchoice(question, choice_key, q_answer_choices)\n    end",
    "comment": "factory method to create the appropriate question based on the question type (true/false or multiple choice)",
    "label": "what",
    "id": "486"
  },
  {
    "raw_code": "def paginate_list\n    versions = Version.page(params[:page]).order('id').per_page(25)\n    versions = versions.where(id: params[:id]) if params[:id].to_i > 0\n    if current_user_has_super_admin_privileges?\n      versions = versions.where(whodunnit: params[:post][:user_id]) if params[:post][:user_id].to_i > 0\n    end",
    "comment": "For filtering the versions list with proper search and pagination.",
    "label": "what",
    "id": "487"
  },
  {
    "raw_code": "def action_allowed?\n    response = user_id = nil\n    action = params[:action]\n    # Initialize response and user id if action is edit or delete or update or view.\n    if %w[edit delete update view].include?(action)\n      response = Response.find(params[:id])\n      user_id = response.map.reviewer.user_id if response.map.reviewer\n    end",
    "comment": "E2218: Method to check if that action is allowed for the user.",
    "label": "what",
    "id": "488"
  },
  {
    "raw_code": "def authorize_show_calibration_results\n    response_map = ResponseMap.find(params[:review_response_map_id])\n    user_id = response_map.reviewer.user_id if response_map.reviewer\n    # Deny access to the calibration result page if the current user is not a reviewer.\n    unless current_user_is_reviewer?(response_map, user_id)\n      flash[:error] = 'You are not allowed to view this calibration result'\n      redirect_to controller: 'student_review', action: 'list', id: user_id\n    end",
    "comment": "E2218: Method to authorize if the reviewer can view the calibration results When user manipulates the URL, the user should be authorized",
    "label": "what",
    "id": "489"
  },
  {
    "raw_code": "def json\n    response_id = params[:response_id] if params.key?(:response_id)\n    response = Response.find(response_id)\n    render json: response\n  end",
    "comment": "GET /response/json?response_id=xx",
    "label": "what",
    "id": "490"
  },
  {
    "raw_code": "def delete\n    # The locking was added for E1973, team-based reviewing. See lock.rb for details\n    if @map.team_reviewing_enabled\n      @response = Lock.get_lock(@response, current_user, Lock::DEFAULT_TIMEOUT)\n      if @response.nil?\n        response_lock_action\n        return\n      end",
    "comment": "E2218: Method to delete a response.",
    "label": "what",
    "id": "491"
  },
  {
    "raw_code": "def edit\n    assign_action_parameters\n    @prev = Response.where(map_id: @map.id)\n    @review_scores = @prev.to_a\n    if @prev.present?\n      @sorted = @review_scores.sort do |m1, m2|\n        if m1.version_num.to_i && m2.version_num.to_i\n          m2.version_num.to_i <=> m1.version_num.to_i\n        else\n          m1.version_num ? -1 : 1\n        end",
    "comment": "Prepare the parameters when student clicks \"Edit\" response questions with answers and scores are rendered in the edit page based on the version number",
    "label": "what",
    "id": "492"
  },
  {
    "raw_code": "def update\n    render nothing: true unless action_allowed?\n    msg = ''\n    begin\n      # the response to be updated\n      # Locking functionality added for E1973, team-based reviewing\n      if @map.team_reviewing_enabled && !Lock.lock_between?(@response, current_user)\n        response_lock_action\n        return\n      end",
    "comment": "Update the response and answers when student \"edit\" existing response",
    "label": "what",
    "id": "493"
  },
  {
    "raw_code": "def view\n    set_content\n  end",
    "comment": "view response",
    "label": "what",
    "id": "494"
  },
  {
    "raw_code": "def show_calibration_results_for_student\n    @assignment = Assignment.find(params[:assignment_id])\n    @calibration_response = ReviewResponseMap.find(params[:calibration_response_map_id]).response[0]\n    @review_response = ReviewResponseMap.find(params[:review_response_map_id]).response[0]\n    @review_questions = AssignmentQuestionnaire.get_questions_by_assignment_id(params[:assignment_id])\n  end",
    "comment": "This method set the appropriate values to the instance variables used in the 'show_calibration_results_for_student' page Responses are fetched using calibration_response_map_id and review_response_map_id params passed in the URL Questions are fetched by querying AssignmentQuestionnaire table to get the valid questions",
    "label": "what",
    "id": "495"
  },
  {
    "raw_code": "def set_response\n    @response = Response.find(params[:id])\n    @map = @response.map\n  end",
    "comment": "E2218: Method to initialize response and response map for update, delete and view methods",
    "label": "what",
    "id": "496"
  },
  {
    "raw_code": "def response_lock_action\n    redirect_to action: 'redirect', id: @map.map_id, return: 'locked', error_msg: 'Another user is modifying this response or has modified this response. Try again later.'\n  end",
    "comment": "Added for E1973, team-based reviewing: http://wiki.expertiza.ncsu.edu/index.php/CSC/ECE_517_Fall_2019_-_Project_E1973._Team_Based_Reviewing Taken if the response is locked and cannot be edited right now",
    "label": "what",
    "id": "497"
  },
  {
    "raw_code": "def assign_action_parameters\n    case params[:action]\n    when 'edit'\n      @header = 'Edit'\n      @next_action = 'update'\n      @response = Response.find(params[:id])\n      @map = @response.map\n      @contributor = @map.contributor\n    when 'new'\n      @header = 'New'\n      @next_action = 'create'\n      @feedback = params[:feedback]\n      @map = ResponseMap.find(params[:id])\n      @modified_object = @map.id\n    end",
    "comment": "This method is called within the Edit or New actions It will create references to the objects that the controller will need when a user creates a new response or edits an existing one.",
    "label": "what",
    "id": "498"
  },
  {
    "raw_code": "def questionnaire_from_response_map\n    case @map.type\n    when 'ReviewResponseMap', 'SelfReviewResponseMap'\n      reviewees_topic = SignedUpTeam.topic_id_by_team_id(@contributor.id)\n      @current_round = @assignment.number_of_current_round(reviewees_topic)\n      @questionnaire = @map.questionnaire(@current_round, reviewees_topic)\n    when\n      'MetareviewResponseMap',\n      'TeammateReviewResponseMap',\n      'FeedbackResponseMap',\n      'CourseSurveyResponseMap',\n      'AssignmentSurveyResponseMap',\n      'GlobalSurveyResponseMap',\n      'BookmarkRatingResponseMap'\n      if @assignment.duty_based_assignment?\n        # E2147 : gets questionnaire of a particular duty in that assignment rather than generic questionnaire\n        @questionnaire = @map.questionnaire_by_duty(@map.reviewee.duty_id)\n      else\n        @questionnaire = @map.questionnaire\n      end",
    "comment": "This method is called within set_content and when the new_response flag is set to true Depending on what type of response map corresponds to this response, the method gets the reference to the proper questionnaire This is called after assign_instance_vars in the new method",
    "label": "what",
    "id": "499"
  },
  {
    "raw_code": "def questionnaire_from_response\n    # if user is not filling a new rubric, the @response object should be available.\n    # we can find the questionnaire from the question_id in answers\n    answer = @response.scores.first\n    @questionnaire = @response.questionnaire_by_answer(answer)\n  end",
    "comment": "This method is called within set_content when the new_response flag is set to False This method gets the questionnaire directly from the response object since it is available.",
    "label": "what",
    "id": "500"
  },
  {
    "raw_code": "def set_dropdown_or_scale\n    use_dropdown = AssignmentQuestionnaire.where(assignment_id: @assignment.try(:id),\n                                                 questionnaire_id: @questionnaire.try(:id))\n                                          .first.try(:dropdown)\n    @dropdown_or_scale = (use_dropdown ? 'dropdown' : 'scale')\n  end",
    "comment": "checks if the questionnaire is nil and opens drop down or rating accordingly",
    "label": "what",
    "id": "501"
  },
  {
    "raw_code": "def create_answers(params, questions)\n    params[:responses].each_pair do |k, v|\n      score = Answer.where(response_id: @response.id, question_id: questions[k.to_i].id).first\n      score ||= Answer.create(response_id: @response.id, question_id: questions[k.to_i].id, answer: v[:score], comments: v[:comment])\n      score.update_attribute('answer', v[:score])\n      score.update_attribute('comments', v[:comment])\n    end",
    "comment": "For each question in the list, starting with the first one, you update the comment and score",
    "label": "what",
    "id": "502"
  },
  {
    "raw_code": "def init_answers(questions)\n    questions.each do |q|\n      # it's unlikely that these answers exist, but in case the user refresh the browser some might have been inserted.\n      answer = Answer.where(response_id: @response.id, question_id: q.id).first\n      if answer.nil?\n        Answer.create(response_id: @response.id, question_id: q.id, answer: nil, comments: '')\n      end",
    "comment": "This method initialize answers for the questions in the response Iterates over each questions and create corresponding answer for that",
    "label": "what",
    "id": "503"
  },
  {
    "raw_code": "def action_allowed?\n    case params[:action]\n    when 'add_dynamic_reviewer',\n          'show_available_submissions',\n          'assign_reviewer_dynamically',\n          'assign_metareviewer_dynamically',\n          'assign_quiz_dynamically',\n          'start_self_review'\n      true\n    else ['Instructor', 'Teaching Assistant', 'Administrator'].include? current_role_name\n    end",
    "comment": "E1600 start_self_review is a method that is invoked by a student user so it should be allowed accordingly",
    "label": "what",
    "id": "504"
  },
  {
    "raw_code": "def assign_reviewer_dynamically\n    assignment = Assignment.find(params[:assignment_id])\n    participant = AssignmentParticipant.where(user_id: params[:reviewer_id], parent_id: assignment.id).first\n    reviewer = participant.get_reviewer\n    if params[:i_dont_care].nil? && params[:topic_id].nil? && assignment.topics? && assignment.can_choose_topic_to_review?\n      flash[:error] = 'No topic is selected.  Please go back and select a topic.'\n    else\n      if review_allowed?(assignment, reviewer)\n        if check_outstanding_reviews?(assignment, reviewer)\n          # begin\n          if assignment.topics? # assignment with topics\n            topic = if params[:topic_id]\n                      SignUpTopic.find(params[:topic_id])\n                    else\n                      begin\n                        assignment.candidate_topics_to_review(reviewer).to_a.sample\n                      rescue StandardError\n                        nil\n                      end",
    "comment": "7/12/2015 -zhewei This method is used for assign submissions to students for peer review. This method is different from 'assignment_reviewer_automatically', which is in 'review_mapping_controller' and is used for instructor assigning reviewers in instructor-selected assignment.",
    "label": "what",
    "id": "505"
  },
  {
    "raw_code": "def review_allowed?(assignment, reviewer)\n    @review_mappings = ReviewResponseMap.where(reviewer_id: reviewer.id, reviewed_object_id: assignment.id)\n    assignment.num_reviews_allowed > @review_mappings.size\n  end",
    "comment": "This method checks if the user is allowed to do any more reviews. First we find the number of reviews done by that reviewer for that assignment and we compare it with assignment policy if number of reviews are less than allowed than a user is allowed to request.",
    "label": "what",
    "id": "506"
  },
  {
    "raw_code": "def check_outstanding_reviews?(assignment, reviewer)\n    @review_mappings = ReviewResponseMap.where(reviewer_id: reviewer.id, reviewed_object_id: assignment.id)\n    @num_reviews_total = @review_mappings.size\n    if @num_reviews_total.zero?\n      true\n    else\n      @num_reviews_completed = 0\n      @review_mappings.each do |map|\n        @num_reviews_completed += 1 if !map.response.empty? && map.response.last.is_submitted\n      end",
    "comment": "This method checks if the user that is requesting a review has any outstanding reviews, if a user has more than 2 outstanding reviews, he is not allowed to ask for more reviews. First we find the reviews done by that student, if he hasn't done any review till now, true is returned else we compute total reviews completed by adding each response we then check of the reviews in progress are less than assignment's policy",
    "label": "what",
    "id": "507"
  },
  {
    "raw_code": "def assign_quiz_dynamically\n    begin\n      assignment = Assignment.find(params[:assignment_id])\n      reviewer = AssignmentParticipant.where(user_id: params[:reviewer_id], parent_id: assignment.id).first\n      if ResponseMap.where(reviewed_object_id: params[:questionnaire_id], reviewer_id: params[:participant_id]).first\n        flash[:error] = 'You have already taken that quiz.'\n      else\n        @map = QuizResponseMap.new\n        @map.reviewee_id = Questionnaire.find(params[:questionnaire_id]).instructor_id\n        @map.reviewer_id = params[:participant_id]\n        @map.reviewed_object_id = Questionnaire.find_by(instructor_id: @map.reviewee_id).id\n        @map.save\n      end",
    "comment": "assigns the quiz dynamically to the participant",
    "label": "what",
    "id": "508"
  },
  {
    "raw_code": "def unsubmit_review\n    @response = Response.where(map_id: params[:id]).last\n    review_response_map = ReviewResponseMap.find_by(id: params[:id])\n    reviewer = review_response_map.reviewer.get_reviewer.name\n    reviewee = review_response_map.reviewee.name\n    if @response.update_attribute('is_submitted', false)\n      flash.now[:success] = 'The review by \"' + reviewer + '\" for \"' + reviewee + '\" has been unsubmitted.'\n    else\n      flash.now[:error] = 'The review by \"' + reviewer + '\" for \"' + reviewee + '\" could not be unsubmitted.'\n    end",
    "comment": "E1721: Unsubmit reviews using AJAX",
    "label": "what",
    "id": "509"
  },
  {
    "raw_code": "def automatic_review_mapping_staggered\n    assignment = Assignment.find(params[:id])\n    message = assignment.assign_reviewers_staggered(params[:assignment][:num_reviews], params[:assignment][:num_metareviews])\n    flash[:note] = message\n    redirect_to action: 'list_mappings', id: assignment.id\n  end",
    "comment": "This is for staggered deadline assignment",
    "label": "what",
    "id": "510"
  },
  {
    "raw_code": "def start_self_review\n    user_id = params[:reviewer_userid]\n    assignment = Assignment.find(params[:assignment_id])\n    team = Team.find_team_for_assignment_and_user(assignment.id, user_id).first\n    begin\n      # ACS Removed the if condition(and corresponding else) which differentiate assignments as team and individual assignments\n      # to treat all assignments as team assignments\n      if SelfReviewResponseMap.where(reviewee_id: team.id, reviewer_id: params[:reviewer_id]).first.nil?\n        SelfReviewResponseMap.create(reviewee_id: team.id,\n                                     reviewer_id: params[:reviewer_id],\n                                     reviewed_object_id: assignment.id)\n      else\n        raise 'Self review already assigned!'\n      end",
    "comment": "E1600 Start self review if not started yet - Creates a self-review mapping when user requests a self-review",
    "label": "what",
    "id": "511"
  },
  {
    "raw_code": "def action_allowed?\n    current_user_has_ta_privileges?\n  end",
    "comment": "Added the @instructor to display the instructor name in the home page of the 360 degree assessment",
    "label": "what",
    "id": "512"
  },
  {
    "raw_code": "def all_students_all_reviews\n    course = Course.find(params[:course_id])\n    @assignments = course.assignments.reject(&:is_calibrated).reject { |a| a.participants.empty? }\n    @course_participants = course.get_participants\n    insure_existence_of(@course_participants, course)\n    # hashes for view\n    @meta_review = {}\n    @teammate_review = {}\n    @teamed_count = {}\n    # for course\n    # eg. @overall_teammate_review_grades = {assgt_id1: 100, assgt_id2: 178, ...}\n    # @overall_teammate_review_count = {assgt_id1: 1, assgt_id2: 2, ...}\n    %w[teammate meta].each do |type|\n      instance_variable_set(\"@overall_#{type}_review_grades\", {})\n      instance_variable_set(\"@overall_#{type}_review_count\", {})\n    end",
    "comment": "Find the list of all students and assignments pertaining to the course. This data is used to compute the metareview and teammate review scores.",
    "label": "what",
    "id": "513"
  },
  {
    "raw_code": "def overall_review_count(assignments, overall_teammate_review_count, overall_meta_review_count)\n    assignments.each do |assignment|\n      temp_count = overall_teammate_review_count[assignment.id]\n      overall_teammate_review_count[assignment.id] = 1 if temp_count.nil? || temp_count.zero?\n      temp_count = overall_meta_review_count[assignment.id]\n      overall_meta_review_count[assignment.id] = 1 if temp_count.nil? || temp_count.zero?\n    end",
    "comment": "to avoid divide by zero error",
    "label": "what",
    "id": "514"
  },
  {
    "raw_code": "def avg_review_calc_per_student(cp, review_info_per_stu, review)\n    # check to see if the student has been given a review\n    if review_info_per_stu[1] > 0\n      temp_avg_grade = review_info_per_stu[0] * 1.0 / review_info_per_stu[1]\n      review[cp.id][:avg_grade_for_assgt] = temp_avg_grade.round.to_s + '%'\n    end",
    "comment": "Calculate the overall average review grade that a student has gotten from their teammate(s) and instructor(s)",
    "label": "what",
    "id": "515"
  },
  {
    "raw_code": "def course_student_grade_summary\n    @topics = {}\n    @assignment_grades = {}\n    @peer_review_scores = {}\n    @final_grades = {}\n    course = Course.find(params[:course_id])\n    @assignments = course.assignments.reject(&:is_calibrated).reject { |a| a.participants.empty? }\n    @course_participants = course.get_participants\n    insure_existence_of(@course_participants, course)\n    @course_participants.each do |cp|\n      @topics[cp.id] = {}\n      @assignment_grades[cp.id] = {}\n      @peer_review_scores[cp.id] = {}\n      @final_grades[cp.id] = 0\n      @assignments.each do |assignment|\n        user_id = cp.user_id\n        assignment_id = assignment.id\n        # break out of the loop if there are no participants in the assignment\n        next if assignment.participants.find_by(user_id: user_id).nil?\n        # break out of the loop if the participant has no team\n        next if TeamsUser.team_id(assignment_id, user_id).nil?\n\n        assignment_participant = Participant.find_by(user_id: user_id, parent_id: assignment_id)\n        penalties = calculate_penalty(assignment_participant.id)\n\n        # pull information about the student's grades for particular assignment\n        assignment_grade_summary(cp, assignment_id, penalties)\n        peer_review_score = find_peer_review_score(user_id, assignment_id)\n\n        next if peer_review_score.nil? # Skip if there are no peers\n        # Skip if there are no reviews done by peer\n        next if peer_review_score[:review].nil?\n        # Skip if there are no reviews scores assigned by peer\n        next if peer_review_score[:review][:scores].nil?\n        # Skip if there are is no peer review average score\n        next if peer_review_score[:review][:scores][:avg].nil?\n\n        @peer_review_scores[cp.id][assignment_id] = peer_review_score[:review][:scores][:avg].round(2)\n      end",
    "comment": "Find the list of all students and assignments pertaining to the course. This data is used to compute the instructor assigned grade and peer review scores. There are many nuances about how to collect these scores. See our design document for more deails http://wiki.expertiza.ncsu.edu/index.php/CSC/ECE_517_Fall_2018_E1871_Grade_Summary_By_Student",
    "label": "what",
    "id": "516"
  },
  {
    "raw_code": "def calc_overall_review_info(assignment,\n                               course_participant,\n                               reviews,\n                               hash_per_stu,\n                               overall_review_grade_hash,\n                               overall_review_count_hash,\n                               review_info_per_stu)\n    # If a student has not taken an assignment or if they have not received any grade for the same,\n    # assign it as 0 instead of leaving it blank. This helps in easier calculation of overall grade\n    overall_review_grade_hash[assignment.id] = 0 unless overall_review_grade_hash.key?(assignment.id)\n    overall_review_count_hash[assignment.id] = 0 unless overall_review_count_hash.key?(assignment.id)\n    # Do not consider reviews that have not been filled out by teammates when calculating averages.\n    reviews = reviews.reject { |review| review.average_score == 'N/A' }\n    grades = 0\n    # Check if they person has gotten any review for the assignment\n    if reviews.count > 0\n      reviews.each { |review| grades += review.average_score.to_i }\n      avg_grades = (grades * 1.0 / reviews.count).round\n      hash_per_stu[course_participant.id][assignment.id] = avg_grades.to_s + '%'\n    end",
    "comment": "The function populates the hash value for all students for all the reviews that they have gotten. I.e., Teammate and Meta for each of the assignments that they have taken This value is then used to display the overall teammate_review and meta_review grade in the view",
    "label": "what",
    "id": "517"
  },
  {
    "raw_code": "def find_peer_review_score(user_id, assignment_id)\n    participant = AssignmentParticipant.find_by(user_id: user_id, parent_id: assignment_id)\n    assignment = participant.assignment\n    questions = retrieve_questions assignment.questionnaires, assignment_id\n    participant_scores(participant, questions)\n  end",
    "comment": "The peer review score is taken from the questions for the assignment",
    "label": "what",
    "id": "518"
  },
  {
    "raw_code": "def set_anonymized_view\n    anonymized_view_starter_ips = $redis.get('anonymized_view_starter_ips') || ''\n    session[:ip] = request.remote_ip\n    if anonymized_view_starter_ips.include? session[:ip]\n      anonymized_view_starter_ips.delete!(\" #{session[:ip]}\")\n    else\n      anonymized_view_starter_ips += \" #{session[:ip]}\"\n    end",
    "comment": "for anonymized view for demo purposes",
    "label": "what",
    "id": "519"
  },
  {
    "raw_code": "def list\n    letter = params[:letter]\n    search_by = params[:search_by]\n    # If search parameters present\n    if letter.present? && search_by.present?\n      case search_by.to_i\n      when 1 # Search by username\n        @paginated_users = paginate_list.where('name LIKE ?', \"%#{letter}%\")\n      when 2 # Search by fullname\n        @paginated_users = paginate_list.where('fullname LIKE ?', \"%#{letter}%\")\n      when 3 # Search by email\n        @paginated_users = paginate_list.where('email LIKE ?', \"%#{letter}%\")\n      else\n        @paginated_users = paginate_list\n      end",
    "comment": "for displaying the list of users",
    "label": "what",
    "id": "520"
  },
  {
    "raw_code": "def show_if_authorized\n    @user = User.find_by(name: params[:user][:name])\n    if @user.nil?\n      flash[:note] = params[:user][:name] + ' does not exist.'\n      redirect_to action: 'list'\n    else\n      role\n      # check whether current user is authorized to edit the user being searched, call show if true\n\n      if @role.parent_id.nil? || @role.parent_id < session[:user].role_id || @user.id == session[:user].id\n        @total_user_num = User.count\n        @assignment_participant_num = AssignmentParticipant.where(user_id: @user.id).count\n        render action: 'show'\n      else\n        flash[:note] = 'The specified user is not available for editing.'\n        redirect_to action: 'list'\n      end",
    "comment": "for displaying users which are being searched for editing purposes after checking whether current user is authorized to do so",
    "label": "what",
    "id": "521"
  },
  {
    "raw_code": "def user_params\n    params.require(:user).permit(:name,\n                                 :crypted_password,\n                                 :role_id,\n                                 :password_salt,\n                                 :fullname,\n                                 :email,\n                                 :parent_id,\n                                 :private_by_default,\n                                 :mru_directory_path,\n                                 :email_on_review,\n                                 :email_on_submission,\n                                 :email_on_review_of_review,\n                                 :is_new_user,\n                                 :master_permission_granted,\n                                 :handle,\n                                 :digital_certificate,\n                                 :persistence_token,\n                                 :timezonepref,\n                                 :public_key,\n                                 :copy_of_emails,\n                                 :institution_id,\n                                 :etc_icons_on_homepage)\n  end",
    "comment": "add user etc_icons_on_homepage",
    "label": "what",
    "id": "522"
  },
  {
    "raw_code": "def role\n    if @user && @user.role_id\n      @role = Role.find(@user.role_id)\n    elsif @user\n      @role = Role.new(id: nil, name: '(none)')\n    end",
    "comment": "to find the role of a given user object and set the @role accordingly",
    "label": "what",
    "id": "523"
  },
  {
    "raw_code": "def paginate_list\n    paginate_options = { '1' => 25, '2' => 50, '3' => 100 }\n\n    # If the above hash does not have a value for the key,\n    # it means that we need to show all the users on the page\n    #\n    # Just a point to remember, when we use pagination, the\n    # 'users' variable should be an object, not an array\n\n    # The type of condition for the search depends on what the user has selected from the search_by dropdown\n    @search_by = params[:search_by]\n    @per_page = 3\n    # search for corresponding users\n    # users = User.search_users(role, user_id, letter, @search_by)\n\n    # paginate\n    users = if paginate_options[@per_page.to_s].nil? # displaying all - no pagination\n              User.paginate(page: params[:page], per_page: User.count)\n            else # some pagination is active - use the per_page\n              User.paginate(page: params[:page], per_page: paginate_options[@per_page.to_s])\n            end",
    "comment": "For filtering the users list with proper search and pagination.",
    "label": "what",
    "id": "524"
  },
  {
    "raw_code": "def action_allowed?\n    current_user_has_ta_privileges?\n  end",
    "comment": "reports are allowed to be viewed by  only by TA, instructor and administrator",
    "label": "what",
    "id": "525"
  },
  {
    "raw_code": "def self.export_details_fields(detail_options)\n    fields = []\n    fields << 'Name' if detail_options['name'] == 'true'\n    fields << 'UnityID' if detail_options['unity_id'] == 'true'\n    fields << 'EmailID' if detail_options['email'] == 'true'\n    fields << 'Grade' if detail_options['grade'] == 'true'\n    fields << 'Comment' if detail_options['comment'] == 'true'\n    fields\n  end",
    "comment": "function to export specific headers to the csv",
    "label": "what",
    "id": "526"
  },
  {
    "raw_code": "def self.export_details(csv, _parent_id, detail_options)\n    return csv unless detail_options\n  end",
    "comment": "function to check for detail_options and return the correct csv",
    "label": "what",
    "id": "527"
  },
  {
    "raw_code": "def create_approved_user\n    # If a user isn't selected before approving or denying, they are given an error message\n    if params[:selection].nil?\n      flash[:error] = 'Please select at least one user before approving or rejecting'\n      redirect_to action: 'list_pending_requested'\n      return\n    end",
    "comment": "TODO create_approved_user name is misleading. The tests are also wrong for this. Decides whether a new user should be created or not",
    "label": "what",
    "id": "528"
  },
  {
    "raw_code": "def user_new(requested_user)\n    new_user = User.new\n    new_user.name = requested_user.name\n    new_user.role_id = requested_user.role_id\n    new_user.institution_id = requested_user.institution_id\n    new_user.fullname = requested_user.fullname\n    new_user.email = requested_user.email\n    new_user.parent_id = session[:user].id\n    new_user.timezonepref = User.find_by(id: new_user.parent_id).timezonepref\n    # If the user is created, it sends the requested user an email with password instructions\n    if new_user.save\n      password = new_user.reset_password\n      # Mail is sent to the user with a new password\n      prepared_mail = MailerHelper.send_mail_to_user(new_user, 'Your Expertiza account and password have been created.', 'user_welcome', password)\n      prepared_mail.deliver_now\n      flash[:success] = \"A new password has been sent to new user's e-mail address.\"\n      undo_link(\"The user \\\"#{requested_user.name}\\\" has been successfully created. \")\n    else\n      foreign\n    end",
    "comment": "Creates a new user if their request is approved",
    "label": "what",
    "id": "529"
  },
  {
    "raw_code": "def foreign\n    role = Role.find(session[:user].role_id)\n    @all_roles = Role.where('id in (?) or id = ?', role.get_available_roles, role.id)\n  end",
    "comment": "If the registered user status is Approved and if the new_user couldn't be saved, foreign function saves the role id in @all_roles variable",
    "label": "what",
    "id": "530"
  },
  {
    "raw_code": "def create_requested_user_record\n    requested_user = AccountRequest.new(requested_user_params)\n    # An object is created with respect to AccountRequest model inorder to populate the users information when account is requested\n    (user_exists = User.find_by(name: requested_user.name)) || User.find_by(name: requested_user.email)\n    requested_user_saved = save_requested_user(requested_user, params)\n    # Stores a boolean value with respect to whether the user data is saved or not\n    if !user_exists && requested_user_saved\n      notify_supers_new_request(requested_user)\n      redirect_to '/instructions/home'\n      return\n    elsif user_exists\n      flash[:error] = 'The account you are requesting already exists in Expertiza.'\n      # If the user account already exists, log error to the user\n    else\n      flash[:error] = requested_user.errors.full_messages.to_sentence\n      # If saving in the AccountRequests model has failed\n    end",
    "comment": "Creates an account request for the user if it is not a duplicate",
    "label": "what",
    "id": "531"
  },
  {
    "raw_code": "def save_requested_user(requested_user, params)\n    if params[:user][:institution_id].empty?\n      institution = Institution.find_or_create_by(name: params[:institution][:name])\n      requested_user.institution_id = institution.id\n    end",
    "comment": "Verifies the requested user account has the institution, status, and role filled out then saves the object to the database",
    "label": "what",
    "id": "532"
  },
  {
    "raw_code": "def notify_supers_new_request(requested_user)\n    super_users = User.joins(:role).where('roles.name = ?', 'Super-Administrator')\n    super_users.each do |super_user|\n      prepared_mail = MailerHelper.send_mail_to_all_super_users(super_user, requested_user, 'New Account Request: ' + requested_user.fullname)\n      prepared_mail.deliver\n    end",
    "comment": "Notifies all the super admins by email that request for a new account has been created",
    "label": "what",
    "id": "533"
  },
  {
    "raw_code": "def action_allowed?\n    assignment = Assignment.find(params[:assignment_id])\n\n    if assignment\n      current_user_teaching_staff_of_assignment?(assignment.id) ||\n        current_user_ancestor_of?(assignment.instructor)\n    else\n      false\n    end",
    "comment": "According to Dr. Gehringer, only the instructor, an ancestor of the instructor, or the TA for the course should be allowed to execute a method of this controller",
    "label": "what",
    "id": "534"
  },
  {
    "raw_code": "def delete_all\n    assignment = Assignment.find(params[:assignment_id])\n\n    if assignment.nil?\n      flash[:error] = 'Assignment #' + params[:assignment_id].to_s + ' does not currently exist.'\n      return\n    end",
    "comment": "delete all AssignmentQuestionnaire entry that's associated with an assignment",
    "label": "what",
    "id": "535"
  },
  {
    "raw_code": "def action_allowed?\n    case params[:action]\n    when 'edit'\n      @questionnaire = Questionnaire.find(params[:id])\n      current_user_has_admin_privileges? ||\n      (current_user_is_a?('Teaching Assistant') && Ta.find(session[:user].id).is_instructor_or_co_ta?(@questionnaire)) ||\n      (current_user_is_a?('Instructor') && current_user_id?(@questionnaire.try(:instructor_id))) ||\n      (current_user_is_a?('Instructor') && Ta.get_my_instructors(@questionnaire.try(:instructor_id)).include?(session[:user].id))\n    else\n      current_user_has_student_privileges?\n    end",
    "comment": "Check role access for edit questionnaire",
    "label": "what",
    "id": "536"
  },
  {
    "raw_code": "def copy\n    instructor_id = session[:user].instructor_id\n    @questionnaire = Questionnaire.copy_questionnaire_details(params, instructor_id)\n    p_folder = TreeFolder.find_by(name: @questionnaire.display_type)\n    parent = FolderNode.find_by(node_object_id: p_folder.id)\n    QuestionnaireNode.find_or_create_by(parent_id: parent.id, node_object_id: @questionnaire.id)\n    undo_link(\"Copy of questionnaire #{@questionnaire.name} has been created successfully.\")\n    redirect_to controller: 'questionnaires', action: 'view', id: @questionnaire.id\n  rescue StandardError\n    flash[:error] = 'The questionnaire was not able to be copied. Please check the original course for missing information.' + $ERROR_INFO.to_s\n    redirect_to action: 'list', controller: 'tree_display'\n  end",
    "comment": "Create a clone of the given questionnaire, copying all associated questions. The name and creator are updated.",
    "label": "what",
    "id": "537"
  },
  {
    "raw_code": "def set_questionnaire_parameters(private_flag, display)\n    @questionnaire.private = private_flag\n    @questionnaire.name = params[:questionnaire][:name]\n    @questionnaire.instructor_id = session[:user].id\n    @questionnaire.min_question_score = params[:questionnaire][:min_question_score]\n    @questionnaire.max_question_score = params[:questionnaire][:max_question_score]\n    @questionnaire.type = params[:questionnaire][:type]\n    @questionnaire.display_type = display\n    @questionnaire.instruction_loc = Questionnaire::DEFAULT_QUESTIONNAIRE_URL\n    @questionnaire.save\n  end",
    "comment": "Assigns corresponding variables to questionnaire object.",
    "label": "what",
    "id": "538"
  },
  {
    "raw_code": "def create_tree_node\n    tree_folder = TreeFolder.where(['name like ?', @questionnaire.display_type]).first\n    parent = FolderNode.find_by(node_object_id: tree_folder.id)\n    QuestionnaireNode.create(parent_id: parent.id, node_object_id: @questionnaire.id, type: 'QuestionnaireNode')\n    flash[:success] = 'You have successfully created a questionnaire!'\n  end",
    "comment": "Creates tree node",
    "label": "what",
    "id": "539"
  },
  {
    "raw_code": "def edit\n    @questionnaire = Questionnaire.find(params[:id])\n    redirect_to Questionnaire if @questionnaire.nil?\n    session[:return_to] = request.original_url\n  end",
    "comment": "Edit a questionnaire",
    "label": "what",
    "id": "540"
  },
  {
    "raw_code": "def update\n    # If 'Add' or 'Edit/View advice' is clicked, redirect appropriately\n    if params[:add_new_questions]\n      permitted_params = params.permit(:id, new_question: params[:new_question].keys)\n      redirect_to action: 'add_new_questions', id: permitted_params[:id], question: permitted_params[:new_question]\n    elsif params[:view_advice]\n      redirect_to controller: 'advice', action: 'edit_advice', id: params[:id]\n    else\n      @questionnaire = Questionnaire.find(params[:id])\n      if @questionnaire.update_attributes(questionnaire_params)\n        update_questionnaire_questions\n        flash[:success] = 'The questionnaire has been successfully updated!'\n      else\n        flash[:error] = @questionnaire.errors.full_messages.join(', ')\n      end",
    "comment": "Updates a questionnaire's attributes and questions based on form data and redirects to the edit page, displaying a flash message if the update is successful or not.",
    "label": "what",
    "id": "541"
  },
  {
    "raw_code": "def delete\n    @questionnaire = Questionnaire.find(params[:id])\n    if @questionnaire\n      begin\n        name = @questionnaire.name\n        # if this rubric is used by some assignment, flash error\n        unless @questionnaire.assignments.empty?\n          raise \"The assignment <b>#{@questionnaire.assignments.first.try(:name)}</b> uses this questionnaire. Are sure you want to delete the assignment?\"\n        end",
    "comment": "Remove a given questionnaire checks if any assignment uses the current questionnaire or not checks if there are any answers to the questions in the questionnaire for each of the question, it deletes the advice first and then deletes the question. Only then the questionnaire node is deleted",
    "label": "what",
    "id": "542"
  },
  {
    "raw_code": "def toggle_access\n    @questionnaire = Questionnaire.find(params[:id])\n    @questionnaire.private = !@questionnaire.private\n    @questionnaire.save\n    @access = @questionnaire.private == true ? 'private' : 'public'\n    undo_link(\"The questionnaire \\\"#{@questionnaire.name}\\\" has been successfully made #{@access}. \")\n    redirect_to controller: 'tree_display', action: 'list'\n  end",
    "comment": "Toggle the access permission for this assignment from public to private, or vice versa",
    "label": "what",
    "id": "543"
  },
  {
    "raw_code": "def add_new_questions\n    questionnaire_id = params[:id]\n    # If the questionnaire is being used in the active period of an assignment, delete existing responses before adding new questions\n    if AnswerHelper.check_and_delete_responses(questionnaire_id)\n      flash[:success] = 'You have successfully added a new question. Any existing reviews for the questionnaire have been deleted!'\n    else\n      flash[:success] = 'You have successfully added a new question.'\n    end",
    "comment": "Zhewei: This method is used to add new questions when editing questionnaire.",
    "label": "what",
    "id": "544"
  },
  {
    "raw_code": "def save_all_questions\n    questionnaire_id = params[:id]\n    begin\n      if params[:save]\n        update_questionnaire_questions\n        flash[:success] = 'All questions have been successfully saved!'\n      end",
    "comment": "Zhewei: This method is used to save all questions in current questionnaire. this calls update_questions on all the questions in present questionnaire",
    "label": "what",
    "id": "545"
  },
  {
    "raw_code": "def save\n    @questionnaire.save!\n    redirect_to controller: 'questions', action: 'save_questions', questionnaire_id: @questionnaire.id, questionnaire_type: @questionnaire.type and return unless @questionnaire.id.nil? || @questionnaire.id <= 0\n    undo_link(\"Questionnaire \\\"#{@questionnaire.name}\\\" has been updated successfully. \")\n  end",
    "comment": "save questionnaire object after create or edit this is a basid CRUD function and is called after every create or edit",
    "label": "what",
    "id": "546"
  },
  {
    "raw_code": "def new\n    @id = params[:id]\n    @sign_up_topic = SignUpTopic.new\n    @sign_up_topic.assignment = Assignment.find(params[:id])\n    @topic = @sign_up_topic\n  end",
    "comment": "Prepares the form for adding a new topic. Used in conjunction with create",
    "label": "what",
    "id": "547"
  },
  {
    "raw_code": "def create\n    topic = SignUpTopic.where(topic_name: params[:topic][:topic_name], assignment_id: params[:id]).first\n    if topic.nil?\n      setup_new_topic\n    else\n      update_existing_topic topic\n    end",
    "comment": "This method is used to create signup topics In this code params[:id] is the assignment id and not topic id. The intuition is that assignment id will virtually be the signup sheet id as well as we have assumed that every assignment will have only one signup sheet",
    "label": "what",
    "id": "548"
  },
  {
    "raw_code": "def destroy\n    @topic = SignUpTopic.find(params[:id])\n    assignment = Assignment.find(params[:assignment_id])\n    if @topic\n      @topic.destroy\n      undo_link(\"The topic: \\\"#{@topic.topic_name}\\\" has been successfully deleted. \")\n    else\n      flash[:error] = 'The topic could not be deleted.'\n    end",
    "comment": "This method is used to delete signup topics Renaming delete method to destroy for rails 4 compatible",
    "label": "what",
    "id": "549"
  },
  {
    "raw_code": "def edit\n    @topic = SignUpTopic.find(params[:id])\n  end",
    "comment": "prepares the page. shows the form which can be used to enter new values for the different properties of an assignment",
    "label": "what",
    "id": "550"
  },
  {
    "raw_code": "def update\n    @topic = SignUpTopic.find(params[:id])\n    if @topic\n      @topic.topic_identifier = params[:topic][:topic_identifier]\n      update_max_choosers @topic\n      @topic.category = params[:topic][:category]\n      @topic.topic_name = params[:topic][:topic_name]\n      @topic.micropayment = params[:topic][:micropayment]\n      @topic.description = params[:topic][:description]\n      @topic.link = params[:topic][:link]\n      @topic.save\n      undo_link(\"The topic: \\\"#{@topic.topic_name}\\\" has been successfully updated. \")\n    else\n      flash[:error] = 'The topic could not be updated.'\n    end",
    "comment": "updates the database tables to reflect the new values for the assignment. Used in conjunction with edit",
    "label": "what",
    "id": "551"
  },
  {
    "raw_code": "def delete_all_topics_for_assignment\n    topics = SignUpTopic.where(assignment_id: params[:assignment_id])\n    topics.each(&:destroy)\n    flash[:success] = 'All topics have been deleted successfully.'\n    respond_to do |format|\n      format.html { redirect_to edit_assignment_path(params[:assignment_id]) }\n      format.js {}\n    end",
    "comment": "This deletes all topics for the given assignment",
    "label": "what",
    "id": "552"
  },
  {
    "raw_code": "def delete_all_selected_topics\n    load_all_selected_topics\n    @stopics.each(&:destroy)\n    flash[:success] = 'All selected topics have been deleted successfully.'\n    respond_to do |format|\n      format.html { redirect_to edit_assignment_path(params[:assignment_id]) + '#tabs-2' }\n      format.js {}\n    end",
    "comment": "This deletes all selected topics for the given assignment",
    "label": "what",
    "id": "553"
  },
  {
    "raw_code": "def load_all_selected_topics\n    @stopics = SignUpTopic.where(assignment_id: params[:assignment_id], topic_identifier: params[:topic_ids])\n  end",
    "comment": "This loads all selected topics based on all the topic identifiers selected for that assignment into stopics variable",
    "label": "what",
    "id": "554"
  },
  {
    "raw_code": "def add_signup_topics\n    load_add_signup_topics(params[:id])\n    SignUpSheet.add_signup_topic(params[:id])\n  end",
    "comment": "This displays a page that lists all the available topics for an assignment. Contains links that let an admin or Instructor edit, delete, view enrolled/waitlisted members for each topic Also contains links to delete topics and modify the deadlines for individual topics. Staggered means that different topics can have different deadlines.",
    "label": "what",
    "id": "555"
  },
  {
    "raw_code": "def load_add_signup_topics(assignment_id)\n    @id = assignment_id\n    @sign_up_topics = SignUpTopic.where('assignment_id = ?', assignment_id)\n    @slots_filled = SignUpTopic.find_slots_filled(assignment_id)\n    @slots_waitlisted = SignUpTopic.find_slots_waitlisted(assignment_id)\n\n    @assignment = Assignment.find(assignment_id)\n    # ACS Removed the if condition (and corresponding else) which differentiate assignments as team and individual assignments\n    # to treat all assignments as team assignments\n    # Though called participants, @participants are actually records in signed_up_teams table, which\n    # is a mapping table between teams and topics (waitlisted recorded are also counted)\n    @participants = SignedUpTeam.find_team_participants(assignment_id, session[:ip])\n  end",
    "comment": "retrieves all the data associated with the given assignment. Includes all topics,",
    "label": "what",
    "id": "556"
  },
  {
    "raw_code": "def redirect_to_sign_up(assignment_id)\n    assignment = Assignment.find(assignment_id)\n    assignment.staggered_deadline == true ? (redirect_to action: 'add_signup_topics_staggered', id: assignment_id) : (redirect_to action: 'add_signup_topics', id: assignment_id)\n  end",
    "comment": "simple function that redirects ti the /add_signup_topics or the /add_signup_topics_staggered page depending on assignment type staggered means that different topics can have different deadlines.",
    "label": "what",
    "id": "557"
  },
  {
    "raw_code": "def redirect_to_assignment_edit(assignment_id)\n    redirect_to controller: 'assignments', action: 'edit', id: assignment_id\n  end",
    "comment": "simple function that redirects to assignment->edit->topic panel to display /add_signup_topics or the /add_signup_topics_staggered page staggered means that different topics can have different deadlines.",
    "label": "what",
    "id": "558"
  },
  {
    "raw_code": "def signup_as_instructor; end\n\n  def signup_as_instructor_action\n    user = User.find_by(name: params[:username])\n    if user.nil? # validate invalid user\n      flash[:error] = 'That student does not exist!'\n    else\n      if AssignmentParticipant.exists? user_id: user.id, parent_id: params[:assignment_id]\n        if SignUpSheet.signup_team(params[:assignment_id], user.id, params[:topic_id])\n          flash[:success] = 'You have successfully signed up the student for the topic!'\n          ExpertizaLogger.info LoggerMessage.new(controller_name, '', 'Instructor signed up student for topic: ' + params[:topic_id].to_s)\n        else\n          flash[:error] = 'The student has already signed up for a topic!'\n          ExpertizaLogger.info LoggerMessage.new(controller_name, '', 'Instructor is signing up a student who already has a topic')\n        end\n      else\n        flash[:error] = 'The student is not registered for the assignment!'\n        ExpertizaLogger.info LoggerMessage.new(controller_name, '', 'The student is not registered for the assignment: ' << user.id)\n      end",
    "comment": "routes to new page to specify student",
    "label": "what",
    "id": "559"
  },
  {
    "raw_code": "def delete_signup\n    participant = AssignmentParticipant.find(params[:id])\n    assignment = participant.assignment\n    drop_topic_deadline = assignment.due_dates.find_by(deadline_type_id: 6)\n    # A student who has already submitted work should not be allowed to drop his/her topic!\n    # (A student/team has submitted if participant directory_num is non-null or submitted_hyperlinks is non-null.)\n    # If there is no drop topic deadline, student can drop topic at any time (if all the submissions are deleted)\n    # If there is a drop topic deadline, student cannot drop topic after this deadline.\n    if !participant.team.submitted_files.empty? || !participant.team.hyperlinks.empty?\n      flash[:error] = 'You have already submitted your work, so you are not allowed to drop your topic.'\n      ExpertizaLogger.error LoggerMessage.new(controller_name, session[:user].id, 'Dropping topic for already submitted a work: ' + params[:topic_id].to_s)\n    elsif !drop_topic_deadline.nil? && (Time.now > drop_topic_deadline.due_at)\n      flash[:error] = 'You cannot drop your topic after the drop topic deadline!'\n      ExpertizaLogger.error LoggerMessage.new(controller_name, session[:user].id, 'Dropping topic for ended work: ' + params[:topic_id].to_s)\n    else\n      users_team = Team.find_team_users(assignment.id, session[:user].id)\n      delete_signup_for_topic(params[:topic_id], users_team[0].t_id)\n      flash[:success] = 'You have successfully dropped your topic!'\n      ExpertizaLogger.info LoggerMessage.new(controller_name, session[:user].id, 'Student has dropped the topic: ' + params[:topic_id].to_s)\n    end",
    "comment": "this function is used to delete a previous signup",
    "label": "what",
    "id": "560"
  },
  {
    "raw_code": "def save_topic_deadlines\n    assignment = Assignment.find(params[:assignment_id])\n    @assignment_submission_due_dates = assignment.due_dates.select { |due_date| due_date.deadline_type_id == 1 }\n    @assignment_review_due_dates = assignment.due_dates.select { |due_date| due_date.deadline_type_id == 2 }\n    due_dates = params[:due_date]\n    topics = SignUpTopic.where(assignment_id: params[:assignment_id])\n    review_rounds = assignment.num_review_rounds\n    topics.each_with_index do |topic, index|\n      (1..review_rounds).each do |i|\n        @topic_submission_due_date = due_dates[topics[index].id.to_s + '_submission_' + i.to_s + '_due_date']\n        @topic_review_due_date = due_dates[topics[index].id.to_s + '_review_' + i.to_s + '_due_date']\n        @assignment_submission_due_date = DateTime.parse(@assignment_submission_due_dates[i - 1].due_at.to_s).strftime('%Y-%m-%d %H:%M')\n        @assignment_review_due_date = DateTime.parse(@assignment_review_due_dates[i - 1].due_at.to_s).strftime('%Y-%m-%d %H:%M')\n        %w[submission review].each do |deadline_type|\n          deadline_type_id = DeadlineType.find_by_name(deadline_type).id\n          next if instance_variable_get('@topic_' + deadline_type + '_due_date') == instance_variable_get('@assignment_' + deadline_type + '_due_date')\n\n          topic_due_date = begin\n                             TopicDueDate.where(parent_id: topic.id, deadline_type_id: deadline_type_id, round: i).first\n                           rescue StandardError\n                             nil\n                           end",
    "comment": "If the instructor needs to explicitly change the start/due dates of the topics This is true in case of a staggered deadline type assignment. Individual deadlines can be set on a per topic and per round basis",
    "label": "what",
    "id": "561"
  },
  {
    "raw_code": "def show_team\n    assignment = Assignment.find(params[:assignment_id])\n    topic = SignUpTopic.find(params[:id])\n    if assignment && topic\n      @results = ad_info(assignment.id, topic.id)\n      @results.each do |result|\n        result.keys.each do |key|\n          @current_team_name = result[key] if key.equal? :name\n        end",
    "comment": "This method is called when a student click on the trumpet icon. So this is a bad method name. --Yang",
    "label": "what",
    "id": "562"
  },
  {
    "raw_code": "def ad_info(_assignment_id, topic_id)\n    @ad_information = []\n    @signed_up_teams = SignedUpTeam.where(topic_id: topic_id)\n    # Iterate through the results of the query and get the required attributes\n    @signed_up_teams.each do |signed_up_team|\n      team = signed_up_team.team\n      topic = signed_up_team.topic\n      ad_map = {}\n      ad_map[:team_id] = team.id\n      ad_map[:comments_for_advertisement] = team.comments_for_advertisement\n      ad_map[:name] = team.name\n      ad_map[:assignment_id] = topic.assignment_id\n      ad_map[:advertise_for_partner] = team.advertise_for_partner\n\n      # Append to the list\n      @ad_information.append(ad_map)\n    end",
    "comment": "get info related to the ad for partners so that it can be displayed when an assignment_participant clicks to see ads related to a topic",
    "label": "what",
    "id": "563"
  },
  {
    "raw_code": "def update\n    respond_to do |format|\n      if @join_team_request.update(join_team_request_params)\n        format.html { redirect_to(@join_team_request, notice: 'JoinTeamRequest was successfully updated.') }\n        format.xml  { head :ok }\n      else\n        format.html { render action: 'edit' }\n        format.xml  { render xml: @join_team_request.errors, status: :unprocessable_entity }\n      end",
    "comment": "update join team request entry for join_team_request table and add it to the table",
    "label": "what",
    "id": "564"
  },
  {
    "raw_code": "def decline\n    @join_team_request.status = 'D'\n    @join_team_request.save\n    redirect_to view_student_teams_path student_id: params[:teams_user_id]\n  end",
    "comment": "decline request to join the team...",
    "label": "what",
    "id": "565"
  },
  {
    "raw_code": "def action_allowed?\n    case params[:action]\n    when 'show', 'set_priority', 'index'\n      ['Instructor',\n       'Teaching Assistant',\n       'Administrator',\n       'Super-Administrator',\n       'Student'].include?(current_role_name) &&\n        ((%w[list].include? action_name) ? are_needed_authorizations_present?(params[:id], 'participant', 'reader', 'submitter', 'reviewer') : true)\n    else\n      ['Instructor',\n       'Teaching Assistant',\n       'Administrator',\n       'Super-Administrator'].include? current_role_name\n    end",
    "comment": "action allowed function checks the action allowed based on the user working",
    "label": "what",
    "id": "566"
  },
  {
    "raw_code": "def index\n    @participant = AssignmentParticipant.find(params[:id])\n    return unless current_user_id?(@participant.user_id)\n\n    @assignment = @participant.assignment\n    @review_mappings = ReviewResponseMap.where(reviewer_id: @participant.id)\n\n    # Finding how many reviews have been completed\n    @num_reviews_completed = 0\n    @review_mappings.each do |map|\n      @num_reviews_completed += 1 if !map.response.empty? && map.response.last.is_submitted\n    end",
    "comment": "provides variables for reviewing page located at views/review_bids/others_work.html.erb",
    "label": "what",
    "id": "567"
  },
  {
    "raw_code": "def show\n    @participant = AssignmentParticipant.find(params[:id].to_i)\n    @assignment = @participant.assignment\n    @sign_up_topics = SignUpTopic.where(assignment_id: @assignment.id, private_to: nil)\n    my_topic = SignedUpTeam.topic_id(@participant.parent_id, @participant.user_id)\n    @sign_up_topics -= SignUpTopic.where(assignment_id: @assignment.id, id: my_topic)\n    @num_participants = AssignmentParticipant.where(parent_id: @assignment.id).count\n    @selected_topics = nil # this is used to list the topics assigned to review. (ie select == assigned i believe)\n    @bids = ReviewBid.where(participant_id: @participant, assignment_id: @assignment.id)\n    signed_up_topics = []\n    @bids.each do |bid|\n      sign_up_topic = SignUpTopic.find_by(id: bid.signuptopic_id)\n      signed_up_topics << sign_up_topic if sign_up_topic\n    end",
    "comment": "provides variables for review bidding page",
    "label": "what",
    "id": "568"
  },
  {
    "raw_code": "def set_priority\n    if params[:topic].nil?\n      ReviewBid.where(participant_id: params[:id]).destroy_all\n    else\n      assignment_id = SignUpTopic.find(params[:topic].first).assignment.id\n      @bids = ReviewBid.where(participant_id: params[:id])\n      signed_up_topics = ReviewBid.where(participant_id: params[:id]).map(&:signuptopic_id)\n      signed_up_topics -= params[:topic].map(&:to_i)\n      signed_up_topics.each do |topic|\n        ReviewBid.where(signuptopic_id: topic, participant_id: params[:id]).destroy_all\n      end",
    "comment": "function that assigns and updates priorities for review bids",
    "label": "what",
    "id": "569"
  },
  {
    "raw_code": "def assign_bidding\n    # sets parameters used for running bidding algorithm\n    assignment_id = params[:assignment_id].to_i\n    # list of reviewer id's from a specific assignment\n    reviewer_ids = AssignmentParticipant.where(parent_id: assignment_id).ids\n    bidding_data = ReviewBid.bidding_data(assignment_id, reviewer_ids)\n    matched_topics = run_bidding_algorithm(bidding_data)\n    ReviewBid.assign_review_topics(assignment_id, reviewer_ids, matched_topics)\n    Assignment.find(assignment_id).update(can_choose_topic_to_review: false) # turns off bidding for students\n    redirect_back fallback_location: root_path\n  end",
    "comment": "assign bidding topics to reviewers",
    "label": "what",
    "id": "570"
  },
  {
    "raw_code": "def run_bidding_algorithm(bidding_data)\n    # begin\n    url = 'http://app-csc517.herokuapp.com/match_topics' # hard coding for the time being\n    response = RestClient.post url, bidding_data.to_json, content_type: 'application/json', accept: :json\n    JSON.parse(response.body)\n  rescue StandardError\n    false\n    # end\n  end",
    "comment": "call webserver for running assigning algorithm passing webserver: student_ids, topic_ids, student_preferences, time_stamps webserver returns: returns matched assignments as json body",
    "label": "what",
    "id": "571"
  },
  {
    "raw_code": "def update_duties\n    team_user = TeamsUser.find(params[:teams_user_id])\n    team_user.update_attribute(:duty_id, params[:teams_user]['duty_id'])\n    redirect_to controller: 'student_teams', action: 'view', student_id: params[:participant_id]\n  end",
    "comment": "Example of duties: manager, designer, programmer, tester. Finds TeamsUser and save preferred Duty",
    "label": "what",
    "id": "572"
  },
  {
    "raw_code": "def action_allowed?\n    current_user_has_student_privileges?\n  end",
    "comment": "Give permission to manage notifications to appropriate roles",
    "label": "what",
    "id": "573"
  },
  {
    "raw_code": "def index\n    # Add tuple to hide notifications from users\n    track_notification = TrackNotification.new(track_notification_params)\n    track_notification.user_id = current_user.id\n    track_notification.notification_id = params[:id]\n    track_notification.save\n    redirect_back fallback_location: root_path\n  end",
    "comment": "GET /track_notifications *** Only used to add an individual exemption to showing notifications",
    "label": "what",
    "id": "574"
  },
  {
    "raw_code": "def update_authorizations\n    participant = Participant.find(params[:id])\n    permissions = participant_permissions(params[:authorization])\n    can_submit = permissions[:can_submit]\n    can_review = permissions[:can_review]\n    can_take_quiz = permissions[:can_take_quiz]\n    can_mentor = permissions[:can_mentor]\n    parent_id = participant.parent_id\n    # Upon successfully updating the attributes based on user role, a flash message is displayed to the user after the\n    # change in the database. This also gives the user the error message if the update fails.\n    begin\n      participant.update_attributes(can_submit: can_submit, can_review: can_review, can_take_quiz: can_take_quiz, can_mentor: can_mentor)\n      flash[:success] = 'The role of the selected participants has been successfully updated.'\n    rescue StandardError\n      flash[:error] = 'The update action failed.'\n    end",
    "comment": "when you change the duties, changes the permissions based on the new duty you go to",
    "label": "what",
    "id": "575"
  },
  {
    "raw_code": "def inherit\n    assignment = Assignment.find(params[:id])\n    course = assignment.course\n    @copied_participants = []\n    if course\n      participants = course.participants\n      if !participants.empty?\n        participants.each do |participant|\n          new_participant = participant.copy(params[:id])\n          @copied_participants.push new_participant if new_participant\n        end",
    "comment": "Copies existing participants from a course down to an assignment",
    "label": "what",
    "id": "576"
  },
  {
    "raw_code": "def bequeath_all\n    @copied_participants = []\n    assignment = Assignment.find(params[:id])\n    if assignment.course\n      course = assignment.course\n      assignment.participants.each do |participant|\n        new_participant = participant.copy_to_course(course.id)\n        @copied_participants.push new_participant if new_participant\n      end",
    "comment": "Take all participants from an assignment and \"bequeath\" them to course as course_participants.",
    "label": "what",
    "id": "577"
  },
  {
    "raw_code": "def change_handle\n    @participant = AssignmentParticipant.find(params[:id])\n    return unless current_user_id?(@participant.user_id)\n\n    unless params[:participant].nil?\n      if !AssignmentParticipant.where(parent_id: @participant.parent_id, handle: params[:participant][:handle]).empty?\n        ExpertizaLogger.error LoggerMessage.new(controller_name, @participant.name, \"Handle #{params[:participant][:handle]} already in use\", request)\n        flash[:error] = \"<b>The handle #{params[:participant][:handle]}</b> is already in use for this assignment. Please select a different one.\"\n        redirect_to controller: 'participants', action: 'change_handle', id: @participant\n      else\n        @participant.update_attributes(participant_params)\n        ExpertizaLogger.info LoggerMessage.new(controller_name, @participant.name, 'The change handle is saved successfully', request)\n        redirect_to controller: 'student_task', action: 'view', id: @participant\n      end",
    "comment": "Allow participant to change handle for this assignment If the participant parameters are available, update the participant and redirect to the view_actions page",
    "label": "what",
    "id": "578"
  },
  {
    "raw_code": "def delete\n    contributor = AssignmentParticipant.find(params[:id])\n    name = contributor.name\n    assignment_id = contributor.assignment\n    begin\n        contributor.destroy\n        flash[:note] = \"\\\"#{name}\\\" is no longer a participant in this assignment.\"\n    rescue StandardError\n      flash[:error] = \"\\\"#{name}\\\" was not removed from this assignment. Please ensure that \\\"#{name}\\\" is not a reviewer or metareviewer and try again.\"\n      end",
    "comment": "Deletes participants from an assignment",
    "label": "what",
    "id": "579"
  },
  {
    "raw_code": "def view_copyright_grants\n    assignment_id = params[:id]\n    assignment = Assignment.find(assignment_id)\n    @assignment_name = assignment.name\n    @has_topics = false\n    @teams_info = []\n    teams = Team.where(parent_id: assignment_id)\n    teams.each do |team|\n      team_info = {}\n      team_info[:name] = team.name(session[:ip])\n      users = []\n      team.users { |team_user| users.append(get_user_info(team_user, assignment)) }\n      team_info[:users] = users\n      @has_topics = get_signup_topics_for_assignment(assignment_id, team_info, team.id)\n      team_without_topic = SignedUpTeam.where('team_id = ?', team.id).none?\n      next if @has_topics && team_without_topic\n\n      @teams_info.append(team_info)\n    end",
    "comment": "A copyright grant means the author has given permission to the instructor to use the work outside the course. This is incompletely implemented, but the values in the last column in http://expertiza.ncsu.edu/student_task/list are sourced from here.",
    "label": "what",
    "id": "580"
  },
  {
    "raw_code": "def get_user_info(team_user, assignment)\n    user = {}\n    user[:name] = team_user.name\n    user[:fullname] = team_user.fullname\n    # set by default\n    permission_granted = false\n    assignment.participants.each do |participant|\n      permission_granted = participant.permission_granted? if team_user.id == participant.user.id\n    end",
    "comment": "Get the user info from the team user",
    "label": "what",
    "id": "581"
  },
  {
    "raw_code": "def get_signup_topics_for_assignment(assignment_id, team_info, team_id)\n    signup_topics = SignUpTopic.where('assignment_id = ?', assignment_id)\n    if signup_topics.any?\n      has_topics = true\n      signup_topics.each do |signup_topic|\n        signup_topic.signed_up_teams.each do |signed_up_team|\n          if signed_up_team.team_id == team_id\n            team_info[:topic_name] = signup_topic.topic_name\n            team_info[:topic_id] = signup_topic.topic_identifier.to_i\n          end",
    "comment": "Get the signup topics for the assignment",
    "label": "what",
    "id": "582"
  },
  {
    "raw_code": "def view\n    @assignment = Assignment.find(params[:id])\n    questionnaires = @assignment.questionnaires\n    if @assignment.varying_rubrics_by_round?\n      @questions = retrieve_questions questionnaires, @assignment.id\n    else\n      @questions = {}\n      questionnaires.each do |questionnaire|\n        @questions[questionnaire.symbol] = questionnaire.questions\n      end",
    "comment": "the view grading report provides the instructor with an overall view of all the grades for an assignment. It lists all participants of an assignment and all the reviews they received. It also gives a final score, which is an average of all the reviews and greatest difference in the scores of all the reviews.",
    "label": "what",
    "id": "583"
  },
  {
    "raw_code": "def view_team\n    @participant = AssignmentParticipant.find(params[:id])\n    @assignment = @participant.assignment\n    @team = @participant.team\n    @team_id = @team.id\n    questionnaires = AssignmentQuestionnaire.where(assignment_id: @assignment.id, topic_id: nil).map(&:questionnaire)\n    @questions = retrieve_questions(questionnaires, @assignment.id)\n    @pscore = participant_scores(@participant, @questions)\n    @penalties = calculate_penalty(@participant.id)\n    @vmlist = []\n\n    counter_for_same_rubric = 0\n    if @assignment.vary_by_topic?\n      topic_id = SignedUpTeam.topic_id_by_team_id(@team_id)\n      topic_specific_questionnaire = AssignmentQuestionnaire.where(assignment_id: @assignment.id, topic_id: topic_id).first.questionnaire\n      @vmlist << populate_view_model(topic_specific_questionnaire)\n    end",
    "comment": "method for alternative view",
    "label": "what",
    "id": "584"
  },
  {
    "raw_code": "def list_questions(assignment)\n    questions = {}\n    questionnaires = assignment.questionnaires\n    questionnaires.each do |questionnaire|\n      questions[questionnaire.symbol] = questionnaire.questions\n    end",
    "comment": "This method is used from edit methods",
    "label": "what",
    "id": "585"
  },
  {
    "raw_code": "def action_allowed?\n    current_user_has_ta_privileges?\n  end",
    "comment": "Method: action_allowed This method checks if the currently authenticated user has the authorization to perform certain actions Params  Returns true if the user has privileges to perform the action else returns false",
    "label": "what",
    "id": "586"
  },
  {
    "raw_code": "def get_max_question_score(answers)\n    begin\n      answers.first.question.questionnaire.max_question_score\n    rescue StandardError\n      1\n    end",
    "comment": "Method: get_max_question_score This method receives a set of answers and gets the maximum question score Params answers: set of answers Returns if no error returns max_question_score of first question else 1",
    "label": "what",
    "id": "587"
  },
  {
    "raw_code": "def get_valid_answers_for_response(response)\n    answers = Answer.where(response_id: response.id)\n    valid_answer = answers.select { |answer| (answer.question.type == 'Criterion') && !answer.answer.nil? }\n    valid_answer.empty? ? nil : valid_answer\n  end",
    "comment": "Method: get_valid_answers_for_response This method receives response and filters the valid answers list of the response ID Params response Returns set of valid answers (returns nil if empty)",
    "label": "what",
    "id": "588"
  },
  {
    "raw_code": "def calculate_peer_review_grade(valid_answer, max_question_score)\n    weighted_score_sum = valid_answer.map { |answer| answer.answer * answer.question.weight }.inject(:+)\n    question_weight_sum = valid_answer.sum { |answer| answer.question.weight }\n    peer_review_grade = 100.0 * weighted_score_sum / (question_weight_sum * max_question_score)\n    peer_review_grade.round(4)\n  end",
    "comment": "Method: calculate_peer_review_grade This method calculates a cumulative review grade with respect to the set of valid answers Params valid_answer: valid answer to get weight of the answer's question max_question_score: used to calculate maximum score for peer review grade Returns peer_review_grade",
    "label": "what",
    "id": "589"
  },
  {
    "raw_code": "def get_peer_reviews_for_responses(reviewer_id, team_id, valid_response)\n    peer_review_grades_list = []\n    valid_response.each do |response|\n      valid_answer = get_valid_answers_for_response(response)\n      next if valid_answer.nil?\n\n      review_grade = calculate_peer_review_grade(valid_answer, get_max_question_score(valid_answer))\n      peer_review_grades_list << [reviewer_id, team_id, review_grade]\n    end",
    "comment": "Method: get_peer_reviews_for_responses This method calculates the peer review grade for each valid response Params reviewer_id: used to create respective element in the peer_review_grades_list team_id: used to create respective element in the peer_review_grades_list valid_response: to get the valid answer for each valid response Returns peer_review_grades_list",
    "label": "what",
    "id": "590"
  },
  {
    "raw_code": "def get_peer_reviews(assignment_id_list, round_num, has_topic)\n    raw_data_array = []\n    ReviewResponseMap.where('reviewed_object_id in (?) and calibrate_to = ?', assignment_id_list, false).each do |response_map|\n      reviewer = response_map.reviewer.user\n      team = AssignmentTeam.find(response_map.reviewee_id)\n      topic_condition = ((has_topic && (SignedUpTeam.where(team_id: team.id).first.is_waitlisted == false)) || !has_topic)\n      last_valid_response = response_map.response.select { |r| r.round == round_num }.max\n      valid_response = [last_valid_response] unless last_valid_response.nil?\n      if (topic_condition == true) && !valid_response.nil? && !valid_response.empty?\n        raw_data_array += get_peer_reviews_for_responses(reviewer.id, team.id, valid_response)\n      end",
    "comment": "Method: get_peer_reviews This method retrieves all the reviews for the submissions Params assignment_id_list: used to retrieve response map round_num: used to retrieve round_num for the valid response has_topic: to get the topic condition Returns raw_data_array: which corresponds to the return of get_peer_reviews_for_responses method and appended to the raw_data_array",
    "label": "what",
    "id": "591"
  },
  {
    "raw_code": "def get_ids_list(tables)\n    tables.map(&:id)\n  end",
    "comment": "Method: get_ids_list This method maps each object to the corresponding object's ID Params tables: any table Returns id in the tables",
    "label": "what",
    "id": "592"
  },
  {
    "raw_code": "def get_scores(team_ids)\n    quiz_questionnnaires = QuizQuestionnaire.where('instructor_id in (?)', team_ids)\n    quiz_questionnnaire_ids = get_ids_list(quiz_questionnnaires)\n    raw_data_array = []\n    QuizResponseMap.where('reviewed_object_id in (?)', quiz_questionnnaire_ids).each do |response_map|\n      quiz_score = response_map.quiz_score\n      participant = Participant.find(response_map.reviewer_id)\n      raw_data_array << [participant.user_id, response_map.reviewee_id, quiz_score]\n    end",
    "comment": "Method: get_scores This method gets the quiz score of each participant for respective reviewee Params team_ids: list of team IDs Returns raw_data_array: which is a list of participant, reviewee and the participant's quiz score",
    "label": "what",
    "id": "593"
  },
  {
    "raw_code": "def get_quiz_score(assignment_id_list)\n    teams = AssignmentTeam.where('parent_id in (?)', assignment_id_list)\n    team_ids = get_ids_list(teams)\n    get_scores(team_ids)\n  end",
    "comment": "Method: get_quiz_score This method gets the quiz score of assignments Params assignment_id_list: list of assignment IDs Returns raw_data_array: returned by get_scores method, which is a list of participant, reviewee and the participant's quiz score",
    "label": "what",
    "id": "594"
  },
  {
    "raw_code": "def generate_json_body(results)\n    request_body = {}\n    results.each_with_index do |record, _index|\n      request_body['submission' + record[1].to_s] = {} unless request_body.key?('submission' + record[1].to_s)\n      request_body['submission' + record[1].to_s]['stu' + record[0].to_s] = record[2]\n    end",
    "comment": "Method: generate_json_body This method generates json body for the peer reviews and quiz scores Params results: list of grades with corresponding team/participant ID, reviewee ID and their score Returns request_body: returns the formatted body after sorting the hash",
    "label": "what",
    "id": "595"
  },
  {
    "raw_code": "def generate_json_for_peer_reviews(assignment_id_list, round_num = 2)\n    has_topic = !SignUpTopic.where(assignment_id: assignment_id_list[0]).empty?\n\n    peer_reviews_list = get_peer_reviews(assignment_id_list, round_num, has_topic)\n    request_body = generate_json_body(peer_reviews_list)\n    request_body\n  end",
    "comment": "Method: generate_json_for_peer_reviews This method retrieves all the peer reviews associated with the assignment id list by calling the get_peer_reviews method. It then formats the peer-review list in JSON. Params assignment_id_list: list of assignment ids to get quiz scores for round_num: round number of the review Returns request_body: request body populated with the formatted peer review data.",
    "label": "what",
    "id": "596"
  },
  {
    "raw_code": "def generate_json_for_quiz_scores(assignment_id_list)\n    participant_reviewee_map = get_quiz_score(assignment_id_list)\n    request_body = generate_json_body(participant_reviewee_map)\n    request_body\n  end",
    "comment": "Method: generate_json_for_quiz_scores This method accepts a list of assignment ids as an argument. It then calls the get_quiz_score method on the list to get maps of teams and scores for the given assignments. The map is then formatted into JSON. Params assignment_id_list: list of assignment ids to get quiz scores for Returns request_body: request body populated with quiz scores",
    "label": "what",
    "id": "597"
  },
  {
    "raw_code": "def client\n    @max_assignment_id = Assignment.last.id\n    @assignment = Assignment.find(flash[:assignment_id]) rescue nil\n    @another_assignment = Assignment.find(flash[:another_assignment_id]) rescue nil\n  end",
    "comment": "Method: client This method is called when the url reputation_web_service/client is hit using GET method. This renders the client.html.erb It also populates the instance variables to be used in the views Params  Returns nil",
    "label": "what",
    "id": "598"
  },
  {
    "raw_code": "def update_participants_reputation(reputation_response)\n    JSON.parse(reputation_response.body.to_s).each do |reputation_algorithm, user_resputation_list|\n      next unless %w[Hamer Lauw].include?(reputation_algorithm)\n\n      user_resputation_list.each do |user_id, reputation|\n        Participant.find_by(user_id: user_id).update(reputation_algorithm.to_sym => reputation) unless /leniency/ =~ user_id.to_s\n      end",
    "comment": "Method: update_participants_reputation This method accepts the response body in the JSON format. It then parses the JSON and updates the reputation scores of the participants in the list. If the alg variable is not  Hamer/ Lauv, the updation step is skipped. Params reputation_response: The response from the reputation web service Returns nil",
    "label": "what",
    "id": "599"
  },
  {
    "raw_code": "def process_response_body(reputation_response)\n    flash[:response] = reputation_response\n    flash[:response_body] = reputation_response.body\n    update_participants_reputation(reputation_response)\n  end",
    "comment": "Method: process_response_body This method gets the control after receiving a response from the server. It receives the response body as an argument It updates the instance variables related to the response. It then calls the update_participants_reputation to update the reputation scores received in the response body. Params reputation_response: The response from the reputation web service Returns nil",
    "label": "what",
    "id": "600"
  },
  {
    "raw_code": "def add_expert_grades(body)\n    flash[:additional_info] = 'add expert grades'\n    case params[:assignment_id]\n    when '754' # expert grades of Wiki contribution (754)\n      body.prepend('\"expert_grades\": {\"submission25030\":95,\"submission25031\":92,\"submission25033\":88,\"submission25034\":98,\"submission25035\":100,\"submission25037\":95,\"submission25038\":95,\"submission25039\":93,\"submission25040\":96,\"submission25041\":90,\"submission25042\":100,\"submission25046\":95,\"submission25049\":90,\"submission25050\":88,\"submission25053\":91,\"submission25054\":96,\"submission25055\":94,\"submission25059\":96,\"submission25071\":85,\"submission25082\":100,\"submission25086\":95,\"submission25097\":90,\"submission25098\":85,\"submission25102\":97,\"submission25103\":94,\"submission25105\":98,\"submission25114\":95,\"submission25115\":94},')\n    end",
    "comment": "Method: add_expert_grades It prepends the request body with the expert grades pertaining to the default wiki contribution case of 754. It receives the request body as an argument and prepends it Params body: The request body to add the expert grades to Returns body prepended with the expert grades",
    "label": "what",
    "id": "601"
  },
  {
    "raw_code": "def add_quiz_scores(body)\n    flash[:additional_info] = 'add quiz scores'\n    assignment_id_list_quiz = get_assignment_id_list(params[:assignment_id].to_i, params[:another_assignment_id].to_i)\n    quiz_str =  generate_json_for_quiz_scores(assignment_id_list_quiz).to_json\n    quiz_str[0] = '' # remove first {\n    quiz_str.prepend('\"quiz_scores\":{') # add quiz_scores tag\n    quiz_str += ','\n    quiz_str = quiz_str.gsub('\"N/A\"', '20.0') # replace N/A values with 20\n    body.prepend(quiz_str)\n  end",
    "comment": "Method: add_quiz_scores It gets the assignment id list and generates the json on quiz scores of those assignments. Finally processes quiz string is prepended to the request body, received as an argument, and returns the body to prepare_request_body. Params body: The request body to add the expert grades to Returns body prepended with the expert grades",
    "label": "what",
    "id": "602"
  },
  {
    "raw_code": "def add_hamer_reputation_values\n    flash[:additional_info] = 'add initial hamer reputation values'\n  end",
    "comment": "Method: add_lauw_reputation_values This method sets the instance variable @additional_info. This method is called by the prepare_request_body method when params receive instruction through the corresponding view's checkbox. THIS METHOD IS NOT IMPLETEMENTED Params  Returns nil",
    "label": "what",
    "id": "603"
  },
  {
    "raw_code": "def add_lauw_reputation_values\n    flash[:additional_info] = 'add initial lauw reputation values'\n  end",
    "comment": "Method: add_lauw_reputation_values This method sets the instance variable @additional_info. This method is called by the prepare_request_body method when params receive instruction through the corresponding view's checkbox. THIS METHOD IS NOT IMPLETEMENTED Params  Returns nil",
    "label": "what",
    "id": "604"
  },
  {
    "raw_code": "def get_assignment_id_list(assignment_id_one, assignment_id_two = 0)\n    assignment_id_list = []\n    assignment_id_list << assignment_id_one\n    assignment_id_list << assignment_id_two unless assignment_id_two.zero?\n    assignment_id_list\n  end",
    "comment": "Method: get_assignment_id_list This method on receipt of individual assignment IDs returns a list with all the assignment IDs appended into a data structure This function accepts 2 arguments, with the second argument being optional, and returns the list assignment_id_list If the second argument is 0, it is not appended to the list. Params assignment_id_one: first assignment id (required) assignment_id_two: second assignment id (optional) Returns assignment_id_list: list containing two assignment ids",
    "label": "what",
    "id": "605"
  },
  {
    "raw_code": "def add_flash_messages(post_req)\n    flash[:assignment_id] = params[:assignment_id]\n    flash[:round_num] = params[:round_num]\n    flash[:algorithm] = params[:algorithm]\n    flash[:another_assignment_id] = params[:another_assignment_id]\n    flash[:request_body] = post_req.body\n  end",
    "comment": "Method: add_flash_messages This method sets the flash messages to pass on to the next request i.e the request redirected to the client Params post_req: This contains the entire post_req that needs to be sent to the reputation webservice Returns nil",
    "label": "what",
    "id": "606"
  },
  {
    "raw_code": "def add_additional_info_details(post_req)\n    if params[:checkbox][:expert_grade] == 'Add expert grades'\n      add_expert_grades(post_req.body)\n    elsif params[:checkbox][:hamer] == 'Add initial Hamer reputation values'\n      add_hamer_reputation_values\n    elsif params[:checkbox][:lauw] == 'Add initial Lauw reputation values'\n      add_lauw_reputation_values\n    elsif params[:checkbox][:quiz] == 'Add quiz scores'\n      add_quiz_scores(post_req.body)\n    else\n      flash[:additional_info] = ''\n    end",
    "comment": "Method: add_additional_info_details This method sets the additional info details based on the options selected in the additional information section. We populate the request based on the selections Params post_req: This contains the entire post_req that needs to be sent to the reputation webservice Returns nil",
    "label": "what",
    "id": "607"
  },
  {
    "raw_code": "def prepare_request_body\n    reputation_web_service_path = URI.parse(WEBSERVICE_CONFIG['reputation_web_service_url']).path\n    post_req = Net::HTTP::Post.new(reputation_web_service_path, { 'Content-Type' => 'application/json', 'charset' => 'utf-8' })\n    curr_assignment_id = (params[:assignment_id].empty? ? '754' : params[:assignment_id])\n    assignment_id_list_peers = get_assignment_id_list(curr_assignment_id, params[:another_assignment_id].to_i)\n\n    post_req.body = generate_json_for_peer_reviews(assignment_id_list_peers, params[:round_num].to_i).to_json\n\n    post_req.body[0] = '' # remove the first '{'\n    add_additional_info_details post_req\n    post_req.body.prepend('{')\n    add_flash_messages post_req\n    post_req\n  end",
    "comment": "Method: prepare_request_body This method is responsible for preparing the request body in a proper format to send to the server. It populates the assignment scores and peer review scores. It also populates the flash messages to send to the next request It finally sends the prepared request body back to the send_post_request method. Params  Returns nil",
    "label": "what",
    "id": "608"
  },
  {
    "raw_code": "def send_post_request\n    post_req = prepare_request_body\n    reputation_web_service_hostname = URI.parse(WEBSERVICE_CONFIG['reputation_web_service_url']).host\n    reputation_response = Net::HTTP.new(reputation_web_service_hostname).start { |http| http.request(post_req) }\n    if %w[400 500].include?(reputation_response.code)\n      flash[:error] = 'Post Request Failed'\n    else\n      process_response_body(reputation_response)\n    end",
    "comment": "Method: send_post_request This method calls the prepare_request_body function to get a prepared request body in proper format to send to the server. It populates the assignment scores and peer review scores. It also populates the flash messages to send to the next request We redirect to the client url to display the results. Params  Returns nil",
    "label": "what",
    "id": "609"
  },
  {
    "raw_code": "def review_mappings(assignment_id, team_id)\n    ResponseMap.where(reviewed_object_id: assignment_id,\n                      reviewee_id: team_id,\n                      type: 'ReviewResponseMap')\n  end",
    "comment": "retrieves review mappings for an assignment from ResponseMap table.",
    "label": "what",
    "id": "610"
  },
  {
    "raw_code": "def index\n    @submission_records = SubmissionRecord.where(team_id: params[:team_id])\n  end",
    "comment": "Show submission records. expects to get team_id from params",
    "label": "what",
    "id": "611"
  },
  {
    "raw_code": "def release_lock\n    # Find the id in the table with the given type\n    lockable = Object.const_get(params[:type]).find(params[:id])\n    Lock.release_lock(lockable)\n    # Avoid a big error because of no redirect\n    redirect_back fallback_location: root_path\n  end",
    "comment": "Release the lock on the resource passed in in the parameters Since lockable objects are polymorphic, the type needs to be passed in as a parameter",
    "label": "what",
    "id": "612"
  },
  {
    "raw_code": "def action_allowed?\n    true\n  end",
    "comment": "Checks controller permissions",
    "label": "what",
    "id": "613"
  },
  {
    "raw_code": "def goto_controller(name_parameter, prev_tab)\n    node_object = TreeFolder.find_by(name: name_parameter)\n    session[:root] = FolderNode.find_by(node_object_id: node_object.id).id\n    # if we have to highlight a tab, we store this arg. to the last_open_tab elements of session\n    session[:last_open_tab] = prev_tab unless prev_tab.nil?\n    redirect_to controller: 'tree_display', action: 'list', currCtlr: name_parameter\n  end",
    "comment": "refactored method to provide direct access to parameters added an argument prevTab for sending the respective tab to be highlighted on homepage",
    "label": "what",
    "id": "614"
  },
  {
    "raw_code": "def list\n    @currCtlr = params[:currCtlr]\n    redirect_to controller: :content_pages, action: :view unless user_logged_in?\n\n    redirect_to controller: :student_task, action: :list if current_user.try(:student?)\n  end",
    "comment": "Redirects to proper page if user is not an instructor or TA.",
    "label": "what",
    "id": "615"
  },
  {
    "raw_code": "def get_folder_contents\n    # Get all child nodes associated with a top level folder that the logged in user is authorized\n    # to view. Top level folders include Questionnaires, Courses, and Assignments.\n    folders = {}\n    FolderNode.includes(:folder).get.each do |folder_node|\n      child_nodes = folder_node.get_children(nil, nil, session[:user].id, nil, nil)\n      # Serialize the contents of each node so it can be displayed on the UI\n      contents = []\n      child_nodes.each do |node|\n        contents.push(serialize_folder_to_json(folder_node.get_name, node))\n      end",
    "comment": "Returns the contents of each top level folder as a json object.",
    "label": "what",
    "id": "616"
  },
  {
    "raw_code": "def get_specific_folder_contents\n    # Get all child nodes associated with a top level folder that the logged in user is authorized\n    # to view. Top level folders include Questionnaires, Courses, and Assignments.\n    folders = {}\n    FolderNode.includes(:folder).get.each do |folder_node|\n      child_nodes = folder_node.get_children(nil, nil, session[:user].id, nil, nil)\n      # Serialize the contents of each node so it can be displayed on the UI\n      contents = []\n      child_nodes.each do |node|\n        contents.push(serialize_folder_to_json(folder_node.get_name, node))\n      end",
    "comment": "Returns the contents of only the specified folder",
    "label": "what",
    "id": "617"
  },
  {
    "raw_code": "def children_node_ng\n    flash[:error] = 'Invalid JSON in the TreeList' unless json_valid? params[:reactParams][:child_nodes]\n    child_nodes = child_nodes_from_params(params[:reactParams][:child_nodes])\n    tmp_res = {}\n    begin\n      child_nodes.each do |node|\n        initialize_fnode_update_children(params, node, tmp_res)\n      end",
    "comment": "for child nodes",
    "label": "what",
    "id": "618"
  },
  {
    "raw_code": "def get_sub_folder_contents\n    # Convert the object received in parameters to a FolderNode object.\n    folder_node = (params[:reactParams2][:nodeType]).constantize.new\n    params[:reactParams2][:child_nodes].each do |key, value|\n      folder_node[key] = value\n    end",
    "comment": "Returns the contents of the Courses and Questionnaire subfolders",
    "label": "what",
    "id": "619"
  },
  {
    "raw_code": "def course_node_for_current_ta?(ta_mappings, node)\n    ta_mappings.each { |ta_mapping| return true if ta_mapping.course_id == node.node_object_id }\n    false\n  end",
    "comment": "check if nodetype is coursenode",
    "label": "what",
    "id": "620"
  },
  {
    "raw_code": "def assignment_node_for_current_ta?(ta_mappings, node)\n    course_id = Assignment.find(node.node_object_id).course_id\n    ta_mappings.each { |ta_mapping| return true if ta_mapping.course_id == course_id }\n    false\n  end",
    "comment": "check if nodetype is assignmentnode",
    "label": "what",
    "id": "621"
  },
  {
    "raw_code": "def ta_for_current_course?(node)\n    ta_mappings = TaMapping.where(ta_id: session[:user].id)\n    return course_node_for_current_ta?(ta_mappings, node) if node.is_a? CourseNode\n    return assignment_node_for_current_ta?(ta_mappings, node) if node.is_a? AssignmentNode\n\n    false\n  end",
    "comment": "check if user is ta for current course",
    "label": "what",
    "id": "622"
  },
  {
    "raw_code": "def is_user_ta?(instructor_id, child)\n    # instructor created the course, current user is the ta of this course.\n    (session[:user].role_id == 6) &&\n      Ta.get_my_instructors(session[:user].id).include?(instructor_id) && ta_for_current_course?(child)\n  end",
    "comment": "check if current user is ta for instructor",
    "label": "what",
    "id": "623"
  },
  {
    "raw_code": "def is_user_instructor?(instructor_id)\n    # ta created the course, current user is the instructor of this ta.\n    instructor_ids = []\n    TaMapping.where(ta_id: instructor_id).each { |mapping| instructor_ids << Course.find(mapping.course_id).instructor_id }\n    (session[:user].role_id == 2) && instructor_ids.include?(session[:user].id)\n  end",
    "comment": "check if current user is instructor",
    "label": "what",
    "id": "624"
  },
  {
    "raw_code": "def coursenode_assignmentnode(res2, child)\n    res2['directory'] = child.get_directory\n    instructor_id = child.get_instructor_id\n    update_instructor(res2, instructor_id)\n    update_is_available_2(res2, instructor_id, child)\n    assignments_method(child, res2) if child.type == 'AssignmentNode'\n  end",
    "comment": "attaches assignment nodes to course node of instructor",
    "label": "what",
    "id": "625"
  },
  {
    "raw_code": "def res_node_for_child_2(ch_nodes)\n    res = []\n\n    if ch_nodes\n      ch_nodes.each do |child|\n        node_type = child.type\n        res2 = {\n          'nodeinfo' => child,\n          'name' => child.get_name,\n          'instructor_id' => child.get_instructor_id, # add instructor id to the payload to make it available in the frontend\n          'key' => params[:reactParams2][:key],\n          'type' => node_type,\n          'private' => child.get_private,\n          'creation_date' => child.get_creation_date,\n          'updated_date' => child.get_modified_date\n        }\n        coursenode_assignmentnode(res2, child) if %w[CourseNode AssignmentNode].include? node_type\n        res << res2\n      end",
    "comment": "getting result nodes for child2. res[] contains all the resultant nodes.",
    "label": "what",
    "id": "626"
  },
  {
    "raw_code": "def initialize_fnode_2(fnode, child_nodes)\n    child_nodes.each do |key, value|\n      fnode[key] = value\n    end",
    "comment": "initialising folder node 2",
    "label": "what",
    "id": "627"
  },
  {
    "raw_code": "def session_last_open_tab\n    res = session[:last_open_tab]\n    respond_to do |format|\n      format.html { render json: res }\n    end",
    "comment": "Gets and renders last open tab from session",
    "label": "what",
    "id": "628"
  },
  {
    "raw_code": "def set_session_last_open_tab\n    session[:last_open_tab] = params[:tab]\n    res = session[:last_open_tab]\n    respond_to do |format|\n      format.html { render json: res }\n    end",
    "comment": "Sets the last open tab from params",
    "label": "what",
    "id": "629"
  },
  {
    "raw_code": "def drill\n    session[:root] = params[:root]\n    redirect_to controller: 'tree_display', action: 'list'\n  end",
    "comment": "Gets root 'level' of tree and redirects to the list action",
    "label": "what",
    "id": "630"
  },
  {
    "raw_code": "def serialize_assignment_to_json(node, json)\n    json.merge!(\n      'course_id' => node.get_course_id,\n      'max_team_size' => node.get_max_team_size,\n      'is_intelligent' => node.get_is_intelligent,\n      'require_quiz' => node.get_require_quiz,\n      'allow_suggestions' => node.get_allow_suggestions,\n      'has_topic' => SignUpTopic.where(['assignment_id = ?', node.node_object_id]).first ? true : false\n    )\n  end",
    "comment": "Add assignment attributes to json",
    "label": "what",
    "id": "631"
  },
  {
    "raw_code": "def serialize_folder_to_json(folder_type, node)\n    json = {\n      'nodeinfo' => node,\n      'name' => node.get_name,\n      'type' => node.type\n    }\n\n    if folder_type == 'Courses' || folder_type == 'Assignments'\n      json.merge!(\n        'directory' => node.get_directory,\n        'creation_date' => node.get_creation_date,\n        'updated_date' => node.get_modified_date,\n        'institution' => Institution.where(id: node.retrieve_institution_id),\n        'private' => course_is_available?(node)\n      )\n      json['instructor_id'] = node.get_instructor_id\n      json['instructor'] = node.get_instructor_id ? User.find(node.get_instructor_id).name(session[:ip]) : nil\n      json['is_available'] = course_is_available?(node)\n      serialize_assignment_to_json(node, json) if folder_type == 'Assignments'\n    end",
    "comment": "Creates a json object that can be displayed by the UI",
    "label": "what",
    "id": "632"
  },
  {
    "raw_code": "def serialize_sub_folder_to_json(node)\n    json = {\n      'nodeinfo' => node,\n      'name' => node.get_name,\n      'type' => node.type,\n      'key' => params[:reactParams2][:key],\n      'private' => node.get_private,\n      'creation_date' => node.get_creation_date,\n      'updated_date' => node.get_modified_date\n    }\n    if (node.type == 'CourseNode') || (node.type == 'AssignmentNode')\n      json['directory'] = node.get_directory\n      json['instructor_id'] = node.get_instructor_id\n      json['instructor'] = node.get_instructor_id ? User.find(node.get_instructor_id).name(session[:ip]) : nil\n      json['is_available'] = course_is_available?(node)\n      serialize_assignment_to_json(node, json) if node.type == 'AssignmentNode'\n    end",
    "comment": "Creates a json object that can be displayed by the UI",
    "label": "what",
    "id": "633"
  },
  {
    "raw_code": "def instructor_for_course?(node)\n    available?(session[:user], node.get_instructor_id)\n  end",
    "comment": "Checks if the user is the instructor for the course or assignment node provided. Note: Admin and super admin users are considered instructors for all courses.",
    "label": "what",
    "id": "634"
  },
  {
    "raw_code": "def ta_for_course?(node)\n    ta_mappings = TaMapping.where(ta_id: session[:user].id)\n    course_id = node.is_a?(CourseNode) ? node.node_object_id : Assignment.find(node.node_object_id).course_id\n    ta_mappings.any? { |ta_mapping| ta_mapping.course_id == course_id }\n  end",
    "comment": "Checks if the user is a TA for the course or assignment node provided.",
    "label": "what",
    "id": "635"
  },
  {
    "raw_code": "def course_is_available?(node)\n    instructor_for_course?(node) || ta_for_course?(node)\n  end",
    "comment": "Check if the provided course or assignment node is available to the logged in user. Instructors and TA's have access to courses, not individual assignments. It doesn't matter which node is passed in, we only about course access.",
    "label": "what",
    "id": "636"
  },
  {
    "raw_code": "def action_allowed?\n    current_user_has_ta_privileges?\n  end",
    "comment": "Give permission to run the bid to appropriate roles",
    "label": "what",
    "id": "637"
  },
  {
    "raw_code": "def run_intelligent_assignment\n    assignment = Assignment.find(params[:id])\n    teams = assignment.teams\n\n    users_bidding_info = construct_users_bidding_info(assignment.sign_up_topics, teams)\n    bidding_data = { users: users_bidding_info, max_team_size: assignment.max_team_size }\n    ExpertizaLogger.info LoggerMessage.new(controller_name, session[:user].name, \"Bidding data for assignment #{assignment.name}: #{bidding_data}\", request)\n\n    begin\n      url = WEBSERVICE_CONFIG['topic_bidding_webservice_url']\n      response = RestClient.post url, bidding_data.to_json, content_type: :json, accept: :json\n      # Structure of teams variable: [[user_id1, user_id2], [user_id3, user_id4]]\n      teams = JSON.parse(response)['teams']\n      ExpertizaLogger.info LoggerMessage.new(controller_name, session[:user].name, \"Team formation info for assignment #{assignment.name}: #{teams}\", request)\n      create_new_teams_for_bidding_response(teams, assignment, users_bidding_info)\n      assignment.remove_empty_teams\n      match_new_teams_to_topics(assignment)\n    rescue StandardError => e\n      flash[:error] = e.message\n    end",
    "comment": "This method sends a request to a web service that uses k-means and students' bidding data to build teams automatically. The webservice tries to create teams with sizes close to the max team size allowed by the assignment by potentially combining existing smaller teams that have similar bidding info/priorities associated with the assignment's sign-up topics.  rubocop:disable Metrics/AbcSize",
    "label": "what",
    "id": "638"
  },
  {
    "raw_code": "def construct_users_bidding_info(sign_up_topics, teams)\n    users_bidding_info = []\n    # Exclude any teams already signed up\n    teams_not_signed_up = teams.reject { |team| SignedUpTeam.where(team_id: team.id, is_waitlisted: 0).any? }\n    teams_not_signed_up.each do |team|\n      # Grab student id and list of bids\n      bids = []\n      sign_up_topics.each do |topic|\n        bid_record = Bid.find_by(team_id: team.id, topic_id: topic.id)\n        bids << (bid_record.try(:priority) || 0)\n      end",
    "comment": "Generate user bidding information hash based on students who haven't signed up yet This associates a list of bids corresponding to sign_up_topics to a user Structure of users_bidding_info variable: [{user_id1, bids_1}, {user_id2, bids_2}]",
    "label": "what",
    "id": "639"
  },
  {
    "raw_code": "def construct_teams_bidding_info(unassigned_teams, sign_up_topics)\n    teams_bidding_info = []\n    unassigned_teams.each do |team|\n      topic_bids = []\n      sign_up_topics.each do |topic|\n        bid = Bid.find_by(team_id: team.id, topic_id: topic.id)\n        topic_bids << { topic_id: topic.id, priority: bid.priority } if bid\n      end",
    "comment": "Generate team bidding information hash based on newly-created teams Structure of team_bidding_info variable: [{team_id1, bids_1}, {team_id2, bids_2}]",
    "label": "what",
    "id": "640"
  },
  {
    "raw_code": "def create_new_teams_for_bidding_response(teams, assignment, users_bidding_info)\n    teams.each do |user_ids|\n      if assignment.auto_assign_mentor\n        new_team = MentoredTeam.create_team_with_users(assignment.id, user_ids)\n      else\n        new_team = AssignmentTeam.create_team_with_users(assignment.id, user_ids)\n      end",
    "comment": "This method creates new AssignmentTeam objects based on the list of teams received from the webservice It also creates the corresponding TeamNode and TeamsUsers and TeamUserNode for each user in the new team while removing the users from any previous old teams",
    "label": "what",
    "id": "641"
  },
  {
    "raw_code": "def assign_available_slots(teams_bidding_info)\n    teams_bidding_info.each do |tb|\n      tb[:bids].each do |bid|\n        topic_id = bid[:topic_id]\n        num_of_signed_up_teams = SignedUpTeam.where(topic_id: topic_id).count\n        max_choosers = SignUpTopic.find(bid[:topic_id]).try(:max_choosers)\n        if num_of_signed_up_teams < max_choosers\n          SignedUpTeam.create(team_id: tb[:team_id], topic_id: bid[:topic_id])\n          break\n        end",
    "comment": "If certain topic has available slot(s), the team with biggest size and most bids get its first-priority topic then break the loop to next team",
    "label": "what",
    "id": "642"
  },
  {
    "raw_code": "def match_new_teams_to_topics(assignment)\n    unless assignment.is_intelligent\n      flash[:error] = \"This action is not allowed. The assignment #{assignment.name} does not enable intelligent assignments.\"\n      return\n    end",
    "comment": "This method is called for assignments which have their is_intelligent property set to 1. It runs a stable match algorithm and assigns topics to strongest contenders (team strength, priority of bids)",
    "label": "what",
    "id": "643"
  },
  {
    "raw_code": "def after_login(user)\n    session[:user] = user\n    session[:impersonate] = false\n    ExpertizaLogger.info LoggerMessage.new('', user.name, 'Login successful')\n    AuthController.set_current_role(user.role_id, session)\n    redirect_to controller: AuthHelper.get_home_controller(session[:user]),\n                action: AuthHelper.get_home_action(session[:user])\n  end",
    "comment": "function to handle common functionality for conventional user login and google login",
    "label": "what",
    "id": "644"
  },
  {
    "raw_code": "def self.clear_user_info(session, assignment_id)\n    session[:user_id] = nil\n    session[:user] = '' # sets user to an empty string instead of nil, to show that the user was logged in\n    role = Role.student\n    if role\n      Role.rebuild_cache if !role.cache || !role.cache.key?(:credentials)\n      session[:credentials] = role.cache[:credentials]\n      session[:menu] = role.cache[:menu]\n    end",
    "comment": "clears any identifying info from session",
    "label": "what",
    "id": "645"
  },
  {
    "raw_code": "def hash_rows_with_headers(header, body)\n    new_body = []\n    if (params[:model] == 'User') || (params[:model] == 'AssignmentParticipant') || (params[:model] == 'CourseParticipant') || (params[:model] == 'SignUpTopic')\n      header.map! { |str| str.strip.downcase.gsub(/\\s+/, \"\").to_sym }\n      body.each do |row|\n        new_body << header.zip(row).to_h\n      end",
    "comment": "Produces an array, where each entry in the array is a hash. The hash keys are the column titles, and the hash values are the associated values.  E.G. [ { :name => 'jsmith', :fullname => 'John Smith' , :email => 'jsmith@gmail.com' }, { :name => 'jdoe', :fullname => 'Jane Doe', :email => 'jdoe@gmail.com' } ] ",
    "label": "what",
    "id": "646"
  },
  {
    "raw_code": "def parse_to_hash(import_grid, has_header)\n    file_hash = {}\n    if has_header == 'true'\n      file_hash[:header] = import_grid.shift\n      file_hash[:body] = import_grid\n    else\n      file_hash[:header] = nil\n      file_hash[:body] = import_grid\n    end",
    "comment": "Produces a hash where :header refers to the header (may be nil) and :body refers to the contents of the file except the header. :header is an array, and :body is a two-dimensional array.  E.G. { :header => ['name', 'fullname', 'email'], :body => [ ['jsmith', 'John Smith', 'jsmith@gmail.com'], ['jdoe', 'Jane Doe', 'jdoe@gmail.com' ] ] } ",
    "label": "what",
    "id": "647"
  },
  {
    "raw_code": "def parse_to_grid(contents, delimiter)\n    contents_grid = []\n    contents.each_line do |line|\n      contents_grid << parse_line(line, delimiter) unless line.strip == ''\n    end",
    "comment": "Produces a two-dimensional array. The outer array contains \"rows\". The inner arrays contain \"elements of rows\" or \"columns\".  E.G. [ [ 'name', 'fullname', 'email' ], [ 'jsmith', 'John Smith', 'jsmith@gmail.com' ], [ 'jdoe', 'Jane Doe', 'jdoe@gmail.com' ] ] ",
    "label": "what",
    "id": "648"
  },
  {
    "raw_code": "def classify_controllers\n    from_classes = SiteController.classes\n\n    from_db = SiteController.order(:name)\n    known = {}\n    @missing = []\n    from_db.each do |dbc|\n      if from_classes.key? dbc.name\n        known[dbc.name] = dbc\n      else\n        @missing << dbc\n      end",
    "comment": "@unknown contains ApplicationController class objects hashed by name, while @app, @builtin and @missing are arrays of SiteController ActiveRecord objects.",
    "label": "what",
    "id": "649"
  },
  {
    "raw_code": "def get_data_for_review_report(reviewed_object_id, reviewer_id, type)\n    rspan = 0\n    (1..@assignment.num_review_rounds).each { |round| instance_variable_set('@review_in_round_' + round.to_s, 0) }\n\n    response_maps = ResponseMap.where(['reviewed_object_id = ? AND reviewer_id = ? AND type = ?', reviewed_object_id, reviewer_id, type])\n    response_maps.each do |ri|\n      rspan += 1 if Team.exists?(id: ri.reviewee_id)\n      responses = ri.response\n      (1..@assignment.num_review_rounds).each do |round|\n        instance_variable_set('@review_in_round_' + round.to_s, instance_variable_get('@review_in_round_' + round.to_s) + 1) if responses.exists?(round: round)\n      end",
    "comment": " gets the response map data such as reviewer id, reviewed object id and type for the review report ",
    "label": "what",
    "id": "650"
  },
  {
    "raw_code": "def get_team_color(response_map)\n    # Storing redundantly computed value in a variable\n    assignment_created = @assignment.created_at\n    # Storing redundantly computed value in a variable\n    assignment_due_dates = DueDate.where(parent_id: response_map.reviewed_object_id)\n    # Returning colour based on conditions\n    if Response.exists?(map_id: response_map.id)\n      if !response_map.try(:reviewer).try(:review_grade).nil?\n        'brown'\n      elsif response_for_each_round?(response_map)\n        'blue'\n      else\n        obtain_team_color(response_map, assignment_created, assignment_due_dates)\n      end",
    "comment": " gets the team name's color according to review and assignment submission status ",
    "label": "what",
    "id": "651"
  },
  {
    "raw_code": "def obtain_team_color(response_map, assignment_created, assignment_due_dates)\n    color = []\n    (1..@assignment.num_review_rounds).each do |round|\n      check_submission_state(response_map, assignment_created, assignment_due_dates, round, color)\n    end",
    "comment": "loops through the number of assignment review rounds and obtains the team colour",
    "label": "what",
    "id": "652"
  },
  {
    "raw_code": "def check_submission_state(response_map, assignment_created, assignment_due_dates, round, color)\n    if submitted_within_round?(round, response_map, assignment_created, assignment_due_dates)\n      color.push 'purple'\n    else\n      link = submitted_hyperlink(round, response_map, assignment_created, assignment_due_dates)\n      if link.nil? || (link !~ %r{https*:\\/\\/wiki(.*)}) # can be extended for github links in future\n        color.push 'green'\n      else\n        link_updated_at = get_link_updated_at(link)\n        color.push link_updated_since_last?(round, assignment_due_dates, link_updated_at) ? 'purple' : 'green'\n      end",
    "comment": "checks the submission state within each round and assigns team colour",
    "label": "what",
    "id": "653"
  },
  {
    "raw_code": "def response_for_each_round?(response_map)\n    num_responses = 0\n    total_num_rounds = @assignment.num_review_rounds\n    (1..total_num_rounds).each do |round|\n      num_responses += 1 if Response.exists?(map_id: response_map.id, round: round)\n    end",
    "comment": "checks if a review was submitted in every round and gives the total responses count",
    "label": "what",
    "id": "654"
  },
  {
    "raw_code": "def submitted_within_round?(round, response_map, assignment_created, assignment_due_dates)\n    submission_due_date = assignment_due_dates.where(round: round, deadline_type_id: 1).try(:first).try(:due_at)\n    submission = SubmissionRecord.where(team_id: response_map.reviewee_id, operation: ['Submit File', 'Submit Hyperlink'])\n    subm_created_at = submission.where(created_at: assignment_created..submission_due_date)\n    if round > 1\n      submission_due_last_round = assignment_due_dates.where(round: round - 1, deadline_type_id: 1).try(:first).try(:due_at)\n      subm_created_at = submission.where(created_at: submission_due_last_round..submission_due_date)\n    end",
    "comment": "checks if a work was submitted within a given round",
    "label": "what",
    "id": "655"
  },
  {
    "raw_code": "def submitted_hyperlink(round, response_map, assignment_created, assignment_due_dates)\n    submission_due_date = assignment_due_dates.where(round: round, deadline_type_id: 1).try(:first).try(:due_at)\n    subm_hyperlink = SubmissionRecord.where(team_id: response_map.reviewee_id, operation: 'Submit Hyperlink')\n    submitted_h = subm_hyperlink.where(created_at: assignment_created..submission_due_date)\n    submitted_h.try(:last).try(:content)\n  end",
    "comment": "returns hyperlink of the assignment that has been submitted on the due date",
    "label": "what",
    "id": "656"
  },
  {
    "raw_code": "def get_link_updated_at(link)\n    uri = URI(link)\n    res = Net::HTTP.get_response(uri)['last-modified']\n    res.to_time\n  end",
    "comment": "returns last modified header date only checks certain links (wiki)",
    "label": "what",
    "id": "657"
  },
  {
    "raw_code": "def link_updated_since_last?(round, due_dates, link_updated_at)\n    submission_due_date = due_dates.where(round: round, deadline_type_id: 1).try(:first).try(:due_at)\n    submission_due_last_round = due_dates.where(round: round - 1, deadline_type_id: 1).try(:first).try(:due_at)\n    (link_updated_at < submission_due_date) && (link_updated_at > submission_due_last_round)\n  end",
    "comment": "checks if a link was updated since last round submission",
    "label": "what",
    "id": "658"
  },
  {
    "raw_code": "def get_team_reviewed_link_name(max_team_size, _response, reviewee_id, ip_address)\n    team_reviewed_link_name = if max_team_size == 1\n                                TeamsUser.where(team_id: reviewee_id).first.user.fullname(ip_address)\n                              else\n                                # E1991 : check anonymized view here\n                                Team.find(reviewee_id).name\n                              end",
    "comment": "For assignments with 1 team member, the following method returns user's fullname else it returns \"team name\" that a particular reviewee belongs to.",
    "label": "what",
    "id": "659"
  },
  {
    "raw_code": "def review_metrics(round, team_id)\n    %i[max min avg].each { |metric| instance_variable_set('@' + metric.to_s, '-----') }\n    if @avg_and_ranges[team_id] && @avg_and_ranges[team_id][round] && %i[max min avg].all? { |k| @avg_and_ranges[team_id][round].key? k }\n      %i[max min avg].each do |metric|\n        metric_value = @avg_and_ranges[team_id][round][metric].nil? ? '-----' : @avg_and_ranges[team_id][round][metric].round(0).to_s + '%'\n        instance_variable_set('@' + metric.to_s, metric_value)\n      end",
    "comment": "gets minimum, maximum and average grade value for all the reviews present",
    "label": "what",
    "id": "660"
  },
  {
    "raw_code": "def sort_reviewer_by_review_volume_desc\n    @reviewers.each do |r|\n      # get the volume of review comments\n      review_volumes = Response.volume_of_review_comments(@assignment.id, r.id)\n      r.avg_vol_per_round = []\n      review_volumes.each_index do |i|\n        if i.zero?\n          r.overall_avg_vol = review_volumes[0]\n        else\n          r.avg_vol_per_round.push(review_volumes[i])\n        end",
    "comment": "sorts the reviewers by the average volume of reviews in each round, in descending order",
    "label": "what",
    "id": "661"
  },
  {
    "raw_code": "def initialize_chart_elements(reviewer)\n    round = 0\n    labels = []\n    reviewer_data = []\n    all_reviewers_data = []\n\n    # display avg volume for all reviewers per round\n    @num_rounds.times do |rnd|\n      next unless @all_reviewers_avg_vol_per_round[rnd] > 0\n\n      round += 1\n      labels.push round\n      reviewer_data.push reviewer.avg_vol_per_round[rnd]\n      all_reviewers_data.push @all_reviewers_avg_vol_per_round[rnd]\n    end",
    "comment": "moves data of reviews in each round from a current round",
    "label": "what",
    "id": "662"
  },
  {
    "raw_code": "def display_volume_metric_chart(reviewer)\n    labels, reviewer_data, all_reviewers_data = initialize_chart_elements(reviewer)\n    data = {\n      labels: labels,\n      datasets: [\n        {\n          label: 'vol.',\n          backgroundColor: 'rgba(255,99,132,0.8)',\n          borderWidth: 1,\n          data: reviewer_data,\n          yAxisID: 'bar-y-axis1'\n        },\n        {\n          label: 'avg. vol.',\n          backgroundColor: 'rgba(255,206,86,0.8)',\n          borderWidth: 1,\n          data: all_reviewers_data,\n          yAxisID: 'bar-y-axis2'\n        }\n      ]\n    }\n    options = {\n      legend: {\n        position: 'top',\n        labels: {\n          usePointStyle: true\n        }\n      },\n      width: '200',\n      height: '225',\n      scales: {\n        yAxes: [{\n          stacked: true,\n          id: 'bar-y-axis1',\n          barThickness: 10\n        }, {\n          display: false,\n          stacked: true,\n          id: 'bar-y-axis2',\n          barThickness: 15,\n          type: 'category',\n          categoryPercentage: 0.8,\n          barPercentage: 0.9,\n          gridLines: {\n            offsetGridLines: true\n          }\n        }],\n        xAxes: [{\n          stacked: false,\n          ticks: {\n            beginAtZero: true,\n            stepSize: 50,\n            max: 400\n          }\n        }]\n      }\n    }\n    bar_chart data, options\n  end",
    "comment": "The data of all the reviews is displayed in the form of a bar chart",
    "label": "what",
    "id": "663"
  },
  {
    "raw_code": "def display_tagging_interval_chart(intervals)\n    # if someone did not do any tagging in 30 seconds, then ignore this interval\n    threshold = 30\n    intervals = intervals.select { |v| v < threshold }\n    unless intervals.empty?\n      interval_mean = intervals.reduce(:+) / intervals.size.to_f\n    end",
    "comment": "E2082 Generate chart for review tagging time intervals",
    "label": "what",
    "id": "664"
  },
  {
    "raw_code": "def calculate_key_chart_information(intervals)\n    # if someone did not do any tagging in 30 seconds, then ignore this interval\n    threshold = 30\n    interval_precision = 2 # Round to 2 Decimal Places\n    intervals = intervals.select { |v| v < threshold }\n\n    # Get Metrics once tagging intervals are available\n    unless intervals.empty?\n      metrics = {}\n      metrics[:mean] = (intervals.reduce(:+) / intervals.size.to_f).round(interval_precision)\n      metrics[:min] = intervals.min\n      metrics[:max] = intervals.max\n      sum = intervals.inject(0) { |accum, i| accum + (i - metrics[:mean])**2 }\n      metrics[:variance] = (sum / intervals.size.to_f).round(interval_precision)\n      metrics[:stand_dev] = Math.sqrt(metrics[:variance]).round(interval_precision)\n      metrics\n    end",
    "comment": "Calculate mean, min, max, variance, and stand deviation for tagging intervals",
    "label": "what",
    "id": "665"
  },
  {
    "raw_code": "def list_hyperlink_submission(response_map_id, question_id)\n    assignment = Assignment.find(@id)\n    curr_round = assignment.try(:num_review_rounds)\n    curr_response = Response.where(map_id: response_map_id, round: curr_round).first\n    answer_with_link = Answer.where(response_id: curr_response.id, question_id: question_id).first if curr_response\n    comments = answer_with_link.try(:comments)\n    html = ''\n    html += display_hyperlink_in_peer_review_question(comments) if comments.present? && comments.start_with?('http')\n    html.html_safe\n  end",
    "comment": "Zhewei - 2016-10-20 This is for Dr.Kidd's assignment (806) She wanted to quickly see if students pasted in a link (in the text field at the end of the rubric) without opening each review Since we do not have hyperlink question type, we hacked this requirement Maybe later we can create a hyperlink question type to deal with this situation.",
    "label": "what",
    "id": "666"
  },
  {
    "raw_code": "def get_each_review_and_feedback_response_map(author)\n    @team_id = TeamsUser.team_id(@id.to_i, author.user_id)\n    # Calculate how many responses one team received from each round\n    # It is the feedback number each team member should make\n    @review_response_map_ids = ReviewResponseMap.where(['reviewed_object_id = ? and reviewee_id = ?', @id, @team_id]).pluck('id')\n    feedback_response_map_record(author)\n    # rspan means the all peer reviews one student received, including unfinished one\n    @rspan_round_one = @review_responses_round_one.length\n    @rspan_round_two = @review_responses_round_two.length\n    @rspan_round_three = @review_responses_round_three.nil? ? 0 : @review_responses_round_three.length\n  end",
    "comment": "gets review and feedback responses for all rounds for the feedback report",
    "label": "what",
    "id": "667"
  },
  {
    "raw_code": "def feedback_response_map_record(author)\n    { 1 => 'one', 2 => 'two', 3 => 'three' }.each do |key, round_num|\n      instance_variable_set('@review_responses_round_' + round_num,\n                            Response.where(['map_id IN (?) and round = ?', @review_response_map_ids, key]))\n      # Calculate feedback response map records\n      instance_variable_set('@feedback_response_maps_round_' + round_num,\n                            FeedbackResponseMap.where(['reviewed_object_id IN (?) and reviewer_id = ?',\n                                                       instance_variable_get('@all_review_response_ids_round_' + round_num), author.id]))\n    end",
    "comment": "This function sets the values of instance variable",
    "label": "what",
    "id": "668"
  },
  {
    "raw_code": "def get_certain_review_and_feedback_response_map(author)\n    # Setting values of instance variables\n    @feedback_response_maps = FeedbackResponseMap.where(['reviewed_object_id IN (?) and reviewer_id = ?', @all_review_response_ids, author.id])\n    @team_id = TeamsUser.team_id(@id.to_i, author.user_id)\n    @review_response_map_ids = ReviewResponseMap.where(['reviewed_object_id = ? and reviewee_id = ?', @id, @team_id]).pluck('id')\n    @review_responses = Response.where(['map_id IN (?)', @review_response_map_ids])\n    @rspan = @review_responses.length\n  end",
    "comment": "gets review and feedback responses for a certain round for the feedback report",
    "label": "what",
    "id": "669"
  },
  {
    "raw_code": "def get_css_style_for_calibration_report(diff)\n    # diff - difference between stu's answer and instructor's answer\n    dict = { 0 => 'c5', 1 => 'c4', 2 => 'c3', 3 => 'c2' }\n    css_class = if dict.key?(diff.abs)\n                  dict[diff.abs]\n                else\n                  'c1'\n                end",
    "comment": " for calibration report ",
    "label": "what",
    "id": "670"
  },
  {
    "raw_code": "def create_topic_deadline(due_date, offset, topic_id)\n    topic_deadline = TopicDueDate.new\n    topic_deadline.parent_id = topic_id\n    topic_deadline.due_at = Time.zone.parse(due_date.due_at.to_s) + offset.to_i\n    topic_deadline.deadline_type_id = due_date.deadline_type_id\n    # select count(*) from topic_deadlines where late_policy_id IS NULL;\n    # all 'late_policy_id' in 'topic_deadlines' table is NULL\n    # topic_deadline.late_policy_id = nil\n    topic_deadline.submission_allowed_id = due_date.submission_allowed_id\n    topic_deadline.review_allowed_id = due_date.review_allowed_id\n    topic_deadline.review_of_review_allowed_id = due_date.review_of_review_allowed_id\n    topic_deadline.round = due_date.round\n    topic_deadline.save\n  end",
    "comment": "Creates a new topic deadline for topic specified by topic_id. The deadline itself is specified by due_date object which contains several values which specify type { submission deadline, metareview deadline, etc.} a set of other parameters that specify whether submission, review, metareview, etc. are allowed for the particular deadline",
    "label": "what",
    "id": "671"
  },
  {
    "raw_code": "def self.get_pie_chart_url(labels, values)\n    return  '' if labels.length != values.length\n\n    address = 'http://chart.apis.google.com/chart?cht=p3&chs=300x125'\n    max = 100.0\n    values.each do |value|\n      max = value if value.to_f > max\n    end",
    "comment": "labels: array of labels values: array of values",
    "label": "what",
    "id": "672"
  },
  {
    "raw_code": "def self.get_bar_chart_url(labels, values, max)\n    return  '' if labels.length != values.length\n\n    address = 'http://chart.apis.google.com/chart?cht=bhs&chxt=x,y&chf=bg,s,dddddd&chtt=Average+response+score+by+question&chs=600x' + (labels.length * 25 + 60).to_s\n\n    value_string = '&chd=t:'\n    label_string = '&chxl=0:|'\n    color_string = '&chco='\n\n    (0..max).each do |j|\n      label_string += j.to_s + '|'\n    end",
    "comment": "labels: array of labels values: array of values max:    maximum possible value",
    "label": "what",
    "id": "673"
  },
  {
    "raw_code": "def current_user_has_super_admin_privileges?\n    current_user_has_privileges_of?('Super-Administrator')\n  end",
    "comment": "Determine if the currently logged-in user has the privileges of a Super-Admin",
    "label": "what",
    "id": "674"
  },
  {
    "raw_code": "def current_user_has_admin_privileges?\n    current_user_has_privileges_of?('Administrator')\n  end",
    "comment": "Determine if the currently logged-in user has the privileges of an Admin (or higher)",
    "label": "what",
    "id": "675"
  },
  {
    "raw_code": "def current_user_has_instructor_privileges?\n    current_user_has_privileges_of?('Instructor')\n  end",
    "comment": "Determine if the currently logged-in user has the privileges of an Instructor (or higher)",
    "label": "what",
    "id": "676"
  },
  {
    "raw_code": "def current_user_has_ta_privileges?\n    current_user_has_privileges_of?('Teaching Assistant')\n  end",
    "comment": "Determine if the currently logged-in user has the privileges of a TA (or higher)",
    "label": "what",
    "id": "677"
  },
  {
    "raw_code": "def current_user_has_student_privileges?\n    current_user_has_privileges_of?('Student')\n  end",
    "comment": "Determine if the currently logged-in user has the privileges of a Student (or higher)",
    "label": "what",
    "id": "678"
  },
  {
    "raw_code": "def current_user_is_assignment_participant?(assignment_id)\n    if user_logged_in?\n      return AssignmentParticipant.exists?(parent_id: assignment_id, user_id: session[:user].id)\n    end",
    "comment": "Determine if the currently logged-in user is participating in an Assignment based on the assignment_id argument",
    "label": "what",
    "id": "679"
  },
  {
    "raw_code": "def current_user_is_a?(role_name)\n    current_user_and_role_exist? && session[:user].role.name == role_name\n  end",
    "comment": "Determine if the currently logged-in user IS of the given role name If there is no currently logged-in user simply return false parameter role_name should be one of: 'Student', 'Teaching Assistant', 'Instructor', 'Administrator', 'Super-Administrator'",
    "label": "what",
    "id": "680"
  },
  {
    "raw_code": "def current_user_has_id?(id)\n    user_logged_in? && session[:user].id.eql?(id.to_i)\n  end",
    "comment": "Determine if the current user has the passed in id value parameter id can be integer or string",
    "label": "what",
    "id": "681"
  },
  {
    "raw_code": "def current_user_created_bookmark_id?(bookmark_id)\n    user_logged_in? && !bookmark_id.nil? && Bookmark.find(bookmark_id.to_i).user_id == session[:user].id\n  rescue ActiveRecord::RecordNotFound\n    false\n  end",
    "comment": "Determine if the currently logged-in user created the bookmark with the given ID If there is no currently logged-in user (or that user has no ID) simply return false Bookmark ID can be passed as string or number If the bookmark is not found, simply return false",
    "label": "what",
    "id": "682"
  },
  {
    "raw_code": "def given_user_can_submit?(user_id)\n    given_user_can?(user_id, 'submit')\n  end",
    "comment": "Determine if the given user can submit work",
    "label": "what",
    "id": "683"
  },
  {
    "raw_code": "def given_user_can_review?(user_id)\n    given_user_can?(user_id, 'review')\n  end",
    "comment": "Determine if the given user can review work",
    "label": "what",
    "id": "684"
  },
  {
    "raw_code": "def given_user_can_take_quiz?(user_id)\n    given_user_can?(user_id, 'take_quiz')\n  end",
    "comment": "Determine if the given user can take quizzes",
    "label": "what",
    "id": "685"
  },
  {
    "raw_code": "def given_user_can_read?(user_id)\n    # Note that the ability to read is in the model as can_take_quiz\n    # Per Dr. Gehringer, \"I believe that 'can_take_quiz' means that the participant is a reader,\n    # but please check the code to verify\".\n    # This was verified in the Participant model\n    given_user_can_take_quiz?(user_id)\n  end",
    "comment": "Determine if the given user can read work",
    "label": "what",
    "id": "686"
  },
  {
    "raw_code": "def user_logged_in?\n    !session[:user].nil?\n  end",
    "comment": "Determine if there is a current user The application controller method session[:user] will return a user even if session[:user] has been explicitly cleared out because it is \"sticky\" in that it uses \"@session[:user] ||= session[:user]\" So, this method can be used to answer a controller's question \"is anyone CURRENTLY logged in\"",
    "label": "what",
    "id": "687"
  },
  {
    "raw_code": "def current_user_ancestor_of?(user)\n    return session[:user].recursively_parent_of(user) if user_logged_in? && user\n\n    false\n  end",
    "comment": "Determine if the currently logged-in user is an ancestor of the passed in user",
    "label": "what",
    "id": "688"
  },
  {
    "raw_code": "def current_user_instructs_assignment?(assignment)\n    user_logged_in? && !assignment.nil? && (\n      assignment.instructor_id == session[:user].id ||\n      (assignment.course_id && Course.find(assignment.course_id).instructor_id == session[:user].id)\n    )\n  end",
    "comment": "Recursively find an assignment for a given Response id. Because a ResponseMap Determine if the current user is an instructor for the given assignment",
    "label": "what",
    "id": "689"
  },
  {
    "raw_code": "def current_user_has_ta_mapping_for_assignment?(assignment)\n    user_logged_in? && !assignment.nil? && TaMapping.exists?(ta_id: session[:user].id, course_id: assignment.course.id)\n  end",
    "comment": "Determine if the current user and the given assignment are associated by a TA mapping",
    "label": "what",
    "id": "690"
  },
  {
    "raw_code": "def find_assignment_from_response_id(response_id)\n    response = Response.find(response_id.to_i)\n    response_map = response.response_map\n    response_map.assignment || find_assignment_from_response_id(response_map.reviewed_object_id)\n  end",
    "comment": "Recursively find an assignment given the passed in Response id. Because a ResponseMap can either point to an Assignment or another Response, recursively search until the ResponseMap object's reviewed_object_id points to an Assignment.",
    "label": "what",
    "id": "691"
  },
  {
    "raw_code": "def find_assignment_instructor(assignment)\n    if assignment.course\n      Course.find_by(id: assignment.course.id).instructor\n    else\n      assignment.instructor\n    end",
    "comment": "Finds the assignment_instructor for a given assignment. If the assignment is associated with a course, the instructor for the course is returned. If not, the instructor associated with the assignment is return.",
    "label": "what",
    "id": "692"
  },
  {
    "raw_code": "def current_user_has_privileges_of?(role_name)\n    current_user_and_role_exist? && session[:user].role.has_all_privileges_of?(Role.find_by(name: role_name))\n  end",
    "comment": "Determine if the currently logged-in user has the privileges of the given role name (or higher privileges) Let the Role model define this logic for the sake of DRY If there is no currently logged-in user simply return false",
    "label": "what",
    "id": "693"
  },
  {
    "raw_code": "def given_user_can?(user_id, action)\n    participant = Participant.find_by(id: user_id)\n    return false if participant.nil?\n\n    case action\n    when 'submit'\n      participant.can_submit\n    when 'review'\n      participant.can_review\n    when 'take_quiz'\n      participant.can_take_quiz\n    else\n      raise \"Did not recognize user action '\" + action + \"'\"\n    end",
    "comment": "Determine if the given user is a participant of some kind who is allowed to perform the given action (\"submit\", \"review\", \"take_quiz\")",
    "label": "what",
    "id": "694"
  },
  {
    "raw_code": "def add_participant_coauthor\n    # Check if Assignment Participant already exists\n    @participant = AssignmentParticipant.where('user_id = ? and parent_id = ?', @user.id, @assignment.id).first\n    if @participant.nil?\n      new_participant = AssignmentParticipant.create(parent_id: @assignment.id,\n                                                     user_id: @user.id,\n                                                     permission_granted: @user.master_permission_granted,\n                                                     can_submit: true,\n                                                     can_review: false,\n                                                     can_take_quiz: true)\n      new_participant.set_handle\n    end",
    "comment": "Function to add Author/co-author as participant in conference type assignment",
    "label": "what",
    "id": "695"
  },
  {
    "raw_code": "def get_responses_for_question_in_a_survey_deployment(q_id, sd_id)\n    question = Question.find(q_id)\n    responses = []\n    type_of_response_map = %w[AssignmentSurveyResponseMap CourseSurveyResponseMap GlobalSurveyResponseMap]\n    response_map_list = ResponseMap.find_by_sql(['SELECT * FROM response_maps WHERE ' \\\n      'reviewee_id = ? AND (type = ? OR type = ? OR type = ?)', sd_id, type_of_response_map[0], type_of_response_map[1], type_of_response_map[2]])\n    @range_of_scores.each do |i|\n      count = 0\n      response_map_list.each do |response_map|\n        response_list = Response.where(map_id: response_map.id)\n        response_list.each do |response|\n          count += Answer.where(question_id: question.id, answer: i, response_id: response.id).count\n        end",
    "comment": "Returns an array containing the number of responses for a question in a survey deployment",
    "label": "what",
    "id": "696"
  },
  {
    "raw_code": "def allowed_question_type?(question)\n    question.type == 'Criterion' || question.type == 'Checkbox'\n  end",
    "comment": "Statistics are displayed only for Criterion and Checkbox type questions",
    "label": "what",
    "id": "697"
  },
  {
    "raw_code": "def current_user_is_reviewer?(map, _reviewer_id)\n    map.reviewer.current_user_is_reviewer? current_user.try(:id)\n  end",
    "comment": "E-1973 - helper method to check if the current user is the reviewer if the reviewer is an assignment team, we have to check if the current user is on the team",
    "label": "what",
    "id": "698"
  },
  {
    "raw_code": "def sort_questions(questions)\n    questions.sort_by(&:seq)\n  end",
    "comment": "sorts the questions passed by sequence number in ascending order",
    "label": "what",
    "id": "699"
  },
  {
    "raw_code": "def store_total_cake_score\n    reviewee = ResponseMap.select(:reviewee_id, :type).where(id: @response.map_id.to_s).first\n    @total_score = Cake.get_total_score_for_questions(reviewee.type,\n                                                      @review_questions,\n                                                      @participant.id,\n                                                      @assignment.id,\n                                                      reviewee.reviewee_id)\n  end",
    "comment": "Assigns total contribution for cake question across all reviewers to a hash map Key : question_id, Value : total score for cake question",
    "label": "what",
    "id": "700"
  },
  {
    "raw_code": "def set_content(new_response = false)\n    @title = @map.get_title\n    if @map.survey?\n      @survey_parent = @map.survey_parent\n    else\n      @assignment = @map.assignment\n    end",
    "comment": "new_response if a flag parameter indicating that if user is requesting a new rubric to fill if true: we figure out which questionnaire to use based on current time and records in assignment_questionnaires table e.g. student click \"Begin\" or \"Update\" to start filling out a rubric for others' work if false: we figure out which questionnaire to display base on @response object e.g. student click \"Edit\" or \"View\"",
    "label": "what",
    "id": "701"
  },
  {
    "raw_code": "def create_team_users(user, team_id)\n    # if user does not exist flash message\n    unless user\n      urlCreate = url_for controller: 'users', action: 'new'\n      ExpertizaLogger.error LoggerMessage.new('ManageTeamHelper', '', 'User being added to the team does not exist!', request)\n      flash[:error] = \"\\\"#{params[:user][:name].strip}\\\" is not defined. Please <a href=\\\"#{urlCreate}\\\">create</a> this user before continuing.\"\n    end",
    "comment": "Adds a user specified by 'user' object to a team specified by 'team_id'",
    "label": "what",
    "id": "702"
  },
  {
    "raw_code": "def user?(user, team_id)\n    if TeamsUser.where(team_id: team_id, user_id: user.id).first\n      true\n    else\n      false\n    end",
    "comment": "check if the user specified by 'user' already belongs to team specified by 'team_id'",
    "label": "what",
    "id": "703"
  },
  {
    "raw_code": "def check_topic_due_date_value(assignment_due_dates, topic_id, deadline_type_id = 1, review_round = 1)\n    due_date = get_topic_deadline(assignment_due_dates, topic_id, deadline_type_id, review_round)\n    due_date ? DateTime.parse(due_date.to_s).strftime('%Y-%m-%d %H:%M:%S') : nil\n  end",
    "comment": "if the instructor does not specific the topic due date, it should be the same as assignment due date; otherwise, it should display the topic due date.",
    "label": "what",
    "id": "704"
  },
  {
    "raw_code": "def get_suggested_topics(assignment_id)\n    team_id = TeamsUser.team_id(assignment_id, session[:user].id)\n    teams_users = TeamsUser.where(team_id: team_id)\n    teams_users_array = []\n    teams_users.each do |teams_user|\n      teams_users_array << teams_user.user_id\n    end",
    "comment": "Retrieve topics suggested by signed in user for the assignment.",
    "label": "what",
    "id": "705"
  },
  {
    "raw_code": "def get_intelligent_topic_row(topic, selected_topics, max_team_size = 3)\n    row_html = ''\n    if selected_topics.present?\n      selected_topics.each do |selected_topic|\n        row_html = if (selected_topic.topic_id == topic.id) && !selected_topic.is_waitlisted\n                     '<tr bgcolor=\"yellow\">'\n                   elsif (selected_topic.topic_id == topic.id) && selected_topic.is_waitlisted\n                     '<tr bgcolor=\"lightgray\">'\n                   else\n                     '<tr id=\"topic_' + topic.id.to_s + '\">'\n                   end",
    "comment": "Render topic row for intelligent topic selection.",
    "label": "what",
    "id": "706"
  },
  {
    "raw_code": "def get_topic_bg_color(topic, max_team_size)\n    red = (400 * (1 - (Math.tanh(2 * [max_team_size.to_f / Bid.where(topic_id: topic.id).count, 1].min - 1) + 1) / 2)).to_i.to_s\n    green = (400 * (Math.tanh(2 * [max_team_size.to_f / Bid.where(topic_id: topic.id).count, 1].min - 1) + 1) / 2).to_i.to_s\n    'rgb(' + red + ',' + green + ',0)'\n  end",
    "comment": "Compute background colour for a topic with respect to maximum team size.",
    "label": "what",
    "id": "707"
  },
  {
    "raw_code": "def render_participant_info(topic, assignment, participants)\n    html = ''\n    if participants.present?\n      chooser_present = false\n      participants.each do |participant|\n        next unless topic.id == participant.topic_id\n        if participant.team.teams_users.size == 0\n          participant.team.destroy\n          participant.destroy\n          next\n        end",
    "comment": "Render the participant info for a topic and assignment.",
    "label": "what",
    "id": "708"
  },
  {
    "raw_code": "def team_bids(topic, participants)\n    if participants.present? && current_user_has_instructor_privileges?\n      team_id = nil\n      participants.each do |participant|\n        next unless topic.id == participant.topic_id\n\n        team_id = participant.team.try(:id)\n      end",
    "comment": "renders the team's chosen bids in a list sorted by priority",
    "label": "what",
    "id": "709"
  },
  {
    "raw_code": "def self.clean_path(file_name)\n    newstr = file_name.gsub(%r{[^\\w\\.\\_/]}, '_')\n    newstr.tr(\"'\", '_')\n  end",
    "comment": "replace invalid characters with underscore valid: period underscore forward slash alphanumeric characters",
    "label": "what",
    "id": "710"
  },
  {
    "raw_code": "def bookmark_rating_response_map(params, _session = nil)\n    assign_basics(params)\n    @reviewers = BookmarkRatingResponseMap.bookmark_response_report(@id)\n    @topics = @assignment.sign_up_topics\n  end",
    "comment": "Get reviewers for bookmark ratings and topics for assignment",
    "label": "what",
    "id": "711"
  },
  {
    "raw_code": "def get_intelligent_topic_row_review_bids(topic, selected_topics, num_participants)\n    row_html = ''\n    if selected_topics.present?\n      selected_topics.each do |selected_topic|\n        row_html = if (selected_topic.topic_id == topic.id) && !selected_topic.is_waitlisted\n                     '<tr bgcolor=\"yellow\">'\n                   elsif (selected_topic.topic_id == topic.id) && selected_topic.is_waitlisted\n                     '<tr bgcolor=\"lightgray\">'\n                   else\n                     '<tr id=\"topic_' + topic.id.to_s + '\">'\n                   end",
    "comment": "renders the topic row for the topics table in review_bids/show.html.erb",
    "label": "what",
    "id": "712"
  },
  {
    "raw_code": "def get_topic_bg_color_review_bids(topic, num_participants)\n    num_bids = ReviewBid.where(signuptopic_id: topic.id).count.to_f\n    green = (400 * (1 - (Math.tanh(2 * (num_bids / num_participants.to_f) - 1) + 1) / 2)).to_i.to_s\n    red = (400 * (Math.tanh(2 * (num_bids / num_participants.to_f) - 1) + 1) / 2).to_i.to_s\n    'rgb(' + red + ',' + green + ',0)'\n  end",
    "comment": "gets the background color with respect to number of participants and bid size in review_bids/show.html.erb",
    "label": "what",
    "id": "713"
  },
  {
    "raw_code": "def self.upload_users(filename, session, params, home_page)\n    users = []\n    File.open(filename, 'r') do |infile|\n      while (rline = infile.gets)\n        config = get_config\n        attributes = define_attributes(rline.split(config['dlm']), config)\n        users << define_user(attributes, session, params, home_page)\n      end",
    "comment": "separates the file into the necessary elements to create a new user",
    "label": "what",
    "id": "714"
  },
  {
    "raw_code": "def participant_permissions(authorization)\n    can_submit = true\n    can_review = true\n    can_take_quiz = true\n  #E2351 pass duty field to match implementation\n    can_mentor = false\n    case authorization\n    when 'reader'\n      can_submit = false\n      can_review = true\n      can_take_quiz = true\n    when 'reviewer'\n      can_submit = false\n      can_review = true\n      can_take_quiz = false\n    when 'submitter'\n      can_submit = true\n      can_review = false\n      can_take_quiz = false\n  #E2351 - adding a 4th option for mentor, permissions are same as participant but has additional permission 'can_mentor'\n  #maintained as a boolean like other permissions\n    when 'mentor'\n      can_submit = true\n      can_review = true\n      can_take_quiz = true\n      can_mentor = true\n  #end 2351 changes\n    else\n      can_submit = true\n      can_review = true\n      can_take_quiz = true\n      can_mentor = false\n    end",
    "comment": "Authorizations are participant, reader, reviewer, submitter (They are not store in Participant table.) Permissions are can_submit, can_review, can_take_quiz. Get permissions form authorizations.",
    "label": "what",
    "id": "715"
  },
  {
    "raw_code": "def summarize_reviews_by_reviewee_question(assignment, reviewee_id, question, round)\n      question_answers = Answer.answers_by_question_for_reviewee(assignment.id, reviewee_id, question.id)\n\n      avg_scores_by_criterion[round.to_s][question.txt] = calculate_avg_score_by_criterion(question_answers, get_max_score_for_question(question))\n\n      summary[round.to_s][question.txt] = summarize_sentences(break_up_comments_to_sentences(question_answers), summary_ws_url)\n    end",
    "comment": "get average scores and summary for each question in a review by a reviewer",
    "label": "what",
    "id": "716"
  },
  {
    "raw_code": "def get_sentences(answer)\n      sentences = answer.comments.gsub!(/[.?!]/, '\\1|').try(:split, '|') || nil unless answer.nil? || answer.comments.nil?\n      sentences.map!(&:strip) unless sentences.nil?\n      sentences\n    end",
    "comment": "convert answers to each question to sentences",
    "label": "what",
    "id": "717"
  },
  {
    "raw_code": "def accordion_title(last_topic, new_topic)\n    if last_topic.nil?\n      # this is the first accordion\n      render partial: 'response/accordion', locals: { title: new_topic, is_first: true }\n    elsif !new_topic.eql? last_topic\n      # render new accordion\n      render partial: 'response/accordion', locals: { title: new_topic, is_first: false }\n    end",
    "comment": "Render the title",
    "label": "what",
    "id": "718"
  },
  {
    "raw_code": "def charts(symbol)\n    if @participant_score && @participant_score[symbol]\n      scores = score_vector @participant_score[symbol][:assessments], symbol.to_s\n      scores.select! { |score| score > 0 }\n      @grades_bar_charts[symbol] = GradesController.bar_chart(scores)\n    end",
    "comment": "This function removes negative scores and build charts",
    "label": "what",
    "id": "719"
  },
  {
    "raw_code": "def vector(scores)\n    scores[:teams].reject! { |_k, v| v[:scores][:avg].nil? }\n    scores[:teams].map { |_k, v| v[:scores][:avg].to_i }\n  end",
    "comment": "Filters all non nil values and converts them to integer Returns a vector",
    "label": "what",
    "id": "720"
  },
  {
    "raw_code": "def mean(array)\n    array.inject(0) { |sum, x| sum + x } / array.size.to_f\n  end",
    "comment": "This function returns the average",
    "label": "what",
    "id": "721"
  },
  {
    "raw_code": "def attributes(_participant)\n    deadline_type_id = [1, 2, 5]\n    penalties_symbols = %i[submission review meta_review]\n    deadline_type_id.zip(penalties_symbols).each do |id, symbol|\n      CalculatedPenalty.create(deadline_type_id: id, participant_id: @participant.id, penalty_points: penalties[symbol])\n    end",
    "comment": "This function returns the penalty attributes",
    "label": "what",
    "id": "722"
  },
  {
    "raw_code": "def penalties(assignment_id)\n    @all_penalties = {}\n    @assignment = Assignment.find(assignment_id)\n    calculate_for_participants = true unless @assignment.is_penalty_calculated\n    Participant.where(parent_id: assignment_id).each do |participant|\n      penalties = calculate_penalty(participant.id)\n      @total_penalty = 0\n\n      unless penalties[:submission].zero? || penalties[:review].zero? || penalties[:meta_review].zero?\n\n        @total_penalty = (penalties[:submission] + penalties[:review] + penalties[:meta_review])\n        l_policy = LatePolicy.find(@assignment.late_policy_id)\n        @total_penalty = l_policy.max_penalty if @total_penalty > l_policy.max_penalty\n        attributes(@participant) if calculate_for_participants\n      end",
    "comment": "This function calculates all the penalties",
    "label": "what",
    "id": "723"
  },
  {
    "raw_code": "def question_factory(type, questionnaire_id, seq)\n    question_class = QUESTION_MAP[type]\n\n    if question_class.nil?\n      flash[:error] = 'Error: Undefined Question'\n    else\n      question_class.create(txt: '', questionnaire_id: questionnaire_id, seq: seq, type: type, break_before: true)\n    end",
    "comment": "factory method to create the appropriate question based on the type",
    "label": "what",
    "id": "724"
  },
  {
    "raw_code": "def self.create_new_assignment_submission(submission_name = '')\n    # Start by creating a new assignment submission\n    response = SimiCheckWebService.new_comparison(submission_name)\n    json_response = JSON.parse(response.body)\n    as_name = json_response['name']\n    as_id = json_response['id']\n    assignment_submission = PlagiarismCheckerAssignmentSubmission.new(name: as_name, simicheck_id: as_id)\n    assignment_submission.save!\n    as_id\n  end",
    "comment": "Create a new PlagiarismCheckerAssignmentSubmission",
    "label": "what",
    "id": "725"
  },
  {
    "raw_code": "def self.upload_file(assignment_submission_simicheck_id, team_id, parsed_text, file_number)\n    # Set up filename structure: \"teamID_000N.txt\"\n    filename = 'team' + team_id.to_s + format('_%04d.txt', file_number)\n    # Set up full filepath (in tmp dir)\n    filepath = 'tmp/' + filename\n    # Create new file using parsed text\n    File.open(filepath, 'w') { |file| file.write(parsed_text) }\n    # Upload file to simicheck\n    SimiCheckWebService.upload_file(assignment_submission_simicheck_id, filepath)\n    # Delete temporary file\n    File.delete(filepath) if File.exist?(filepath)\n  end",
    "comment": "Upload file",
    "label": "what",
    "id": "726"
  },
  {
    "raw_code": "def self.delete_existing_responses(question_ids, questionnaire_id)\n    # For each of the question's answers, log the response_id if in active period\n    response_ids = log_answer_responses(question_ids, questionnaire_id)\n\n    # For each of the response_ids, log info to be used in answer deletion\n    user_id_to_answers = log_response_info(response_ids)\n\n    # For each pair of response_id and answers, delete the answers if the mailer successfully sends mail\n    begin\n      user_id_to_answers.each do |response_id, answers| # The dictionary has key [response_id] and info as \"answers\"\n        # Feeds review_mailer (email, answers, name, assignment_name) info. Emails and then deletes answers\n        delete_answers(response_id) if review_mailer(answers[:email], answers[:answers], answers[:name], answers[:assignment_name])\n      end",
    "comment": "Delete responses for given questionnaire",
    "label": "what",
    "id": "727"
  },
  {
    "raw_code": "def self.log_answer_responses(question_ids, questionnaire_id)\n    response_ids = []\n    question_ids.each do |question|\n      Answer.where(question_id: question).each do |answer| # For each of the question's answers, log the response_id if in active period\n        response_ids << answer.response_id if in_active_period(questionnaire_id, answer)\n      end",
    "comment": "Log the response_id if in active period for each of the question's answers",
    "label": "what",
    "id": "728"
  },
  {
    "raw_code": "def self.log_response_info(response_ids)\n    user_id_to_answers = {}\n    response_ids.uniq.each do |response_id| # For each response id in the array, gather map and info about reviewer\n      response_map = Response.find(response_id).response_map\n      reviewer_id = response_map.reviewer_id\n      reviewed_object_id = response_map.reviewed_object_id\n      assignment_name = Assignment.find(reviewed_object_id).name\n      user = Participant.find(reviewer_id).user\n      answers_per_user = Answer.find_by(response_id: response_id).comments\n      # For each response_id, add its info to the dictionary\n      user_id_to_answers[response_id] = { email: user.email, answers: answers_per_user, name: user.name, assignment_name: assignment_name } unless user.nil?\n    end",
    "comment": "Log info from each response_id to be used in answer deletion",
    "label": "what",
    "id": "729"
  },
  {
    "raw_code": "def self.review_mailer(email, answers, name, assignment_name)\n    # Call the notify_review_rubric_change method in mailer.rb to send an email with given user info\n    Mailer.notify_review_rubric_change(\n      to: email,\n      subject: 'Expertiza Notification: The review rubric has been changed, please re-attempt the review',\n      body: {\n        name: name,\n        assignment_name: assignment_name,\n        answers: answers\n      }\n    ).deliver_now\n    true\n  rescue StandardError\n    raise $ERROR_INFO\n  end",
    "comment": "Mail the existing response in the database to the reviewer",
    "label": "what",
    "id": "730"
  },
  {
    "raw_code": "def self.delete_answers(response_id)\n    response = Response.find(response_id)\n    response.is_submitted = false\n    response.save! # Unsubmit the response before destroying it\n    Response.find(response_id).destroy\n  end",
    "comment": "Delete the users response to the modified questionnaire",
    "label": "what",
    "id": "731"
  },
  {
    "raw_code": "def self.in_active_period(questionnaire_id, answer = nil)\n    assignment, round_number = AssignmentQuestionnaire.get_latest_assignment(questionnaire_id)\n    unless assignment.nil? # If the assignment doesn't exist, return false\n      start_dates, end_dates = assignment.find_review_period(round_number)\n      time_now = Time.zone.now\n      time_now = answer.response.created_at unless answer.nil?\n      # There can be multiple possible review periods: If round_number is nil, all rounds of reviews use the same questionnaire.\n      # If it is in any of the possible review period now, return true.\n      start_dates.zip(end_dates).each do |start_date, end_date|\n        return true if start_date.due_at < time_now && end_date.due_at > time_now\n      end",
    "comment": "The in_active_period method returns true if the start & end range includes the current time",
    "label": "what",
    "id": "732"
  },
  {
    "raw_code": "def self.check_and_delete_responses(questionnaire_id)\n    question_ids = Questionnaire.find(questionnaire_id).questions.ids\n    if AnswerHelper.in_active_period(questionnaire_id) # confirm current period accepts reviews\n      AnswerHelper.delete_existing_responses(question_ids, questionnaire_id) # delete all responses for current questionnaire\n      true\n    else\n      false\n    end",
    "comment": "Given a questionnaire id, delete all responses to that questionnaire if the current period accepts reviews and return true/false of success",
    "label": "what",
    "id": "733"
  },
  {
    "raw_code": "def questionnaire_options(type)\n    questionnaires = Questionnaire.where(['private = 0 or instructor_id = ?', session[:user].id]).order('name')\n    options = []\n    questionnaires.select { |x| x.type == type }.each do |questionnaire|\n      options << [questionnaire.name, questionnaire.id]\n    end",
    "comment": "round=0 added by E1450",
    "label": "what",
    "id": "734"
  },
  {
    "raw_code": "def due_date(assignment, type, round = 0)\n    due_dates = assignment.find_due_dates(type)\n\n    due_dates.delete_if { |due_date| due_date.due_at.nil? }\n    due_dates.sort! { |x, y| x.due_at <=> y.due_at }\n\n    if due_dates[round].nil? || round < 0\n      due_date = AssignmentDueDate.new\n      due_date.deadline_type_id = DeadlineType.find_by(name: type).id\n      # creating new round\n      due_date.submission_allowed_id = AssignmentDueDate.default_permission(type, 'submission_allowed')\n      due_date.review_allowed_id = AssignmentDueDate.default_permission(type, 'can_review')\n      due_date.review_of_review_allowed_id = AssignmentDueDate.default_permission(type, 'review_of_review_allowed')\n      due_date\n    else\n      due_dates[round]\n    end",
    "comment": "retrieve or create a due_date use in views/assignment/edit.html.erb Be careful it is a tricky method, for types other than \"submission\" and \"review\", the parameter \"round\" should always be 0; for \"submission\" and \"review\" if you want to get the due date for round n, the parameter \"round\" should be n-1.",
    "label": "what",
    "id": "735"
  },
  {
    "raw_code": "def display_review_files_directory_tree(participant, files)\n    participant = @participant if @participant\n    html = ''\n\n    files.each do |file|\n      begin\n        if File.exist?(file)\n          html += link_to image_tag('/assets/tree_view/List-submisstions-24.png'),\n                          :controller => 'submitted_content',\n                          :action => 'download',\n                          :id => participant.id,\n                          :download => File.basename(file),\n                          'current_folder[name]' => File.dirname(file)\n        end",
    "comment": "Zhewei: this method is used to display reviewer uploaded files during peer review.",
    "label": "what",
    "id": "736"
  },
  {
    "raw_code": "def self.unzip_file(file_name, unzip_dir, should_delete)\n    # begin\n    Zip::File.open(file_name) do |zf|\n      zf.each do |e|\n        safename = FileHelper.sanitize_filename(e.name)\n        fpath = File.join(unzip_dir, safename)\n        FileUtils.mkdir_p(File.dirname(fpath))\n        zf.extract(e, fpath)\n      end",
    "comment": "Installing RubyZip run the command,  gem install rubyzip restart the server",
    "label": "what",
    "id": "737"
  },
  {
    "raw_code": "def self.get_user_role(l_user)\n    eval \"#{l_user.role.name.delete('-')}.new\"\n  end",
    "comment": "Make a new user of the same class",
    "label": "what",
    "id": "738"
  },
  {
    "raw_code": "def update_questionnaire_questions\n    return if params[:question].nil?\n\n    params[:question].each_pair do |k, v|\n      question = Question.find(k)\n      v.each_pair do |key, value|\n        question.send(key + '=', value) unless question.send(key) == value\n      end",
    "comment": "Updates the attributes of questionnaire questions based on form data, without modifying unchanged attributes.",
    "label": "what",
    "id": "739"
  },
  {
    "raw_code": "def questionnaire_factory(type)\n    questionnaire = QUESTIONNAIRE_MAP[type]\n    if questionnaire.nil?\n      flash[:error] = 'Error: Undefined Questionnaire'\n    else\n      questionnaire.new\n    end",
    "comment": "factory method to create the appropriate questionnaire based on the type",
    "label": "what",
    "id": "740"
  },
  {
    "raw_code": "def http_setup_get_request_mock_success\n    class << HttpRequest\n      define_method(:get) do |_url|\n        res = http_status_factory(200)\n        def res.body\n          http_mock_success_text(true)\n        end\n        res\n      end",
    "comment": "Attempts to parameterize this function failed",
    "label": "what",
    "id": "741"
  },
  {
    "raw_code": "def http_setup_get_request_mock_error\n    class << HttpRequest\n      define_method(:get) do |_url|\n        res = http_status_factory(500)\n        def res.body\n          http_mock_error_text(false)\n        end\n        res\n      end",
    "comment": "Attempts to parameterize this function failed",
    "label": "what",
    "id": "742"
  },
  {
    "raw_code": "def setup_weighted_questionnaire\n  @questionnaire = create :quiz_questionnaire, instructor_id: @team1.id\n  choices_one = create_choices_for_weighted_questionnaire('1', 'TrueFalse')\n  @question1 = create :quiz_question, questionnaire: @questionnaire, txt: 'Sample True/False Question 1?', weight: 4, quiz_question_choices: choices_one, type: 'TrueFalse'\n  choices_two = create_choices_for_weighted_questionnaire('2', 'TrueFalse')\n  @question2 = create :quiz_question, questionnaire: @questionnaire, txt: 'Sample True/False Question 2', weight: 2, quiz_question_choices: choices_two, type: 'TrueFalse'\n  choices_three = create_choices_for_weighted_questionnaire('3', 'MultipleChoiceRadio')\n  @question3 = create :quiz_question, questionnaire: @questionnaire, txt: 'Sample MultipleChoiceRadio Question 3', weight: 6, quiz_question_choices: choices_three, type: 'MultipleChoiceRadio'\n  choices_four = create_choices_for_weighted_questionnaire('4', 'MultipleChoiceCheckbox')\n  @question4 = create :quiz_question, questionnaire: @questionnaire, txt: 'Sample MultipleChoiceCheckbox Question 3', weight: 8, quiz_question_choices: choices_four, type: 'MultipleChoiceCheckbox'\nend",
    "comment": "creates quiz questionnaire and assigns weights to questions",
    "label": "what",
    "id": "743"
  },
  {
    "raw_code": "def setup_answers\n  create :answer, question: @question1, response_id: @response.id, answer: 1, comments: 'True_1'\n  create :answer, question: @question2, response_id: @response.id, answer: 0, comments: 'False_2'\n  create :answer, question: @question3, response_id: @response.id, answer: 0, comments: 'Answer2_3'\n  create :answer, question: @question4, response_id: @response.id, answer: 1, comments: 'Answer1_4'\n  create :answer, question: @question4, response_id: @response.id, answer: 1, comments: 'Answer3_4'\nend",
    "comment": "this creates answers using factories so that grading of quizzes can be tested",
    "label": "what",
    "id": "744"
  },
  {
    "raw_code": "def setup_score_views\n  create :score_view, q1_id: @questionnaire.id, s_question_id: @question1.id, question_weight: 4, s_score: 1, s_response_id: @response.id, s_comments: 'True_1'\n  create :score_view, q1_id: @questionnaire.id, s_question_id: @question2.id, question_weight: 2, s_score: 0, s_response_id: @response.id, s_comments: 'False_2'\n  create :score_view, q1_id: @questionnaire.id, s_question_id: @question3.id, question_weight: 6, s_score: 0, s_response_id: @response.id, s_comments: 'Answer2_3'\n  create :score_view, q1_id: @questionnaire.id, s_question_id: @question4.id, question_weight: 8, s_score: 1, s_response_id: @response.id, s_comments: 'Answer1_4'\n  create :score_view, q1_id: @questionnaire.id, s_question_id: @question4.id, question_weight: 8, s_score: 1, s_response_id: @response.id, s_comments: 'Answer3_4'\nend",
    "comment": "this creates score views using factories so that weighted score for quiz can be calculated",
    "label": "what",
    "id": "745"
  },
  {
    "raw_code": "def setup_graded_responses\n  @response = create :quiz_response, response_map: @response_map\n  setup_answers\n  setup_score_views\nend",
    "comment": "this creates the set up for grading of a weighted quiz questionnaire",
    "label": "what",
    "id": "746"
  },
  {
    "raw_code": "def generated_csv(t_assignment, t_options)\n    delimiter = ','\n    CSV.generate(col_sep: delimiter) do |csv|\n      csv << ReportsController.export_details_fields(t_options)\n      ReportsController.export_details(csv, t_assignment, false)\n    end",
    "comment": "function to generate a simple CSV with headers.",
    "label": "what",
    "id": "747"
  },
  {
    "raw_code": "def load_your_scores\n    login_as(User.where(role_id: 1).third.name)\n    expect(page).to have_content 'User: ' + User.where(role_id: 1).third.name\n\n    click_link 'Assignments'\n    expect(page).to have_content 'TestAssignment'\n\n    click_link 'TestAssignment'\n    expect(page).to have_content 'Submit or Review work for TestAssignment'\n    expect(page).to have_content 'Your scores'\n    expect(page).to have_content 'Alternate View'\n\n    click_link 'Your scores'\n    expect(page).to have_content 'Summary Report for assignment: TestAssignment'\n  end",
    "comment": "User 3 navigates to the Your scores page",
    "label": "what",
    "id": "748"
  },
  {
    "raw_code": "def add_review\n    login_as(User.where(role_id: 1).first.name)\n    expect(page).to have_content 'User: ' + User.where(role_id: 1).first.name\n\n    expect(page).to have_content 'TestAssignment'\n\n    click_link 'TestAssignment'\n    expect(page).to have_content 'Submit or Review work for TestAssignment'\n    expect(page).to have_content \"Others' work\"\n\n    click_link \"Others' work\"\n    expect(page).to have_content 'Reviews for \"TestAssignment\"'\n\n    choose 'topic_id'\n    click_button 'Request a new submission to review'\n\n    click_link 'Begin'\n\n    fill_in 'responses[0][comment]', with: 'HelloWorld'\n    select 3, from: 'responses[0][score]'\n    click_button 'Submit Review'\n    expect(page).to have_content 'Your response was successfully saved.'\n    click_link 'Logout'\n  end",
    "comment": "User 1 adds a review to Team 2",
    "label": "what",
    "id": "749"
  },
  {
    "raw_code": "def assignment_due(type, time, round, review_allowed_id = 3)\n    create(:assignment_due_date,\n           deadline_type: DeadlineType.where(name: type).first,\n           due_at: time,\n           round: round,\n           review_allowed_id: review_allowed_id)\n  end",
    "comment": "create assignment deadline by default the review_allow_id is 3 (OK), however, for submission the review_allowed_id should be 1 (No).",
    "label": "what",
    "id": "750"
  },
  {
    "raw_code": "def topic_due(type, time, topic_id, round, review_allowed_id = 3)\n    create(:topic_due_date,\n           due_at: time,\n           deadline_type: DeadlineType.where(name: type).first,\n           topic: SignUpTopic.where(id: topic_id).first,\n           round: round,\n           review_allowed_id: review_allowed_id)\n  end",
    "comment": "create topic deadline",
    "label": "what",
    "id": "751"
  },
  {
    "raw_code": "def submit_topic(name, topic, work)\n    user = User.find_by(name: name)\n    login_as(user.name)\n    visit '/student_task/list'\n    visit topic # signup topic\n    visit '/student_task/list'\n    click_link 'Assignment1665'\n    click_link 'Your work'\n    fill_in 'submission', with: work\n    click_on 'Upload link'\n    expect(page).to have_content work\n  end",
    "comment": "impersonate student to submit work",
    "label": "what",
    "id": "752"
  },
  {
    "raw_code": "def change_due(topic, type, round, time)\n    topic_due = TopicDueDate.where(parent_id: topic, deadline_type_id: type, round: round, type: 'TopicDueDate').first\n    topic_due.due_at = time\n    topic_due.save\n  end",
    "comment": "change topic staggered deadline",
    "label": "what",
    "id": "753"
  },
  {
    "raw_code": "def self.converged?(a, b, options = { precision: 2 })\n    raise 'a and b must be the same size' unless a.size == b.size\n\n    a.flatten!\n    b.flatten!\n\n    p = options[:precision]\n    a.each_with_index do |num, i|\n      return false unless num.to_f.round(p) == b[i].to_f.round(p)\n    end",
    "comment": "Ensure all numbers in lists a and b are equal Options: :precision => Number of digits to round to",
    "label": "what",
    "id": "754"
  },
  {
    "raw_code": "def aggregate_assessment_scores(assessments, questions)\n    scores = {}\n    if assessments.present?\n      scores[:max] = -999_999_999\n      scores[:min] = 999_999_999\n      total_score = 0\n      length_of_assessments = assessments.length.to_f\n      assessments.each do |assessment|\n        curr_score = assessment_score(response: [assessment], questions: questions)\n\n        scores[:max] = curr_score if curr_score > scores[:max]\n        scores[:min] = curr_score unless curr_score >= scores[:min] || curr_score == -1\n\n        # Check if the review is invalid. If is not valid do not include in score calculation\n        if curr_score == -1\n          length_of_assessments -= 1\n          curr_score = 0\n        end",
    "comment": "Computes the total score for a *list of assessments* parameters assessments - a list of assessments of some type (e.g., author feedback, teammate review) questions - the list of questions that was filled out in the process of doing those assessments Called in: bookmarks_controller.rb (total_average_score), scoring.rb",
    "label": "what",
    "id": "755"
  },
  {
    "raw_code": "def assessment_score(params)\n    @response = params[:response].last\n    return -1.0 if @response.nil?\n\n    if @response\n      questions = params[:questions]\n      return -1.0 if questions.nil?\n\n      weighted_score = 0\n      sum_of_weights = 0\n      @questionnaire = Questionnaire.find(questions.first.questionnaire_id)\n\n      # Retrieve data for questionnaire (max score, sum of scores, weighted scores, etc.)\n      questionnaire_data = ScoreView.questionnaire_data(questions[0].questionnaire_id, @response.id)\n      weighted_score = questionnaire_data.weighted_score.to_f unless questionnaire_data.weighted_score.nil?\n      sum_of_weights = questionnaire_data.sum_of_weights.to_f\n      answers = Answer.where(response_id: @response.id)\n      answers.each do |answer|\n        question = Question.find(answer.question_id)\n        if answer.answer.nil? && question.is_a?(ScoredQuestion)\n          sum_of_weights -= Question.find(answer.question_id).weight\n        end",
    "comment": "Computes the total score for an assessment params assessment - specifies the assessment for which the total score is being calculated questions  - specifies the list of questions being evaluated in the assessment Called in: bookmarks_controller.rb (specific_average_score), grades_helper.rb (score_vector), response.rb (self.score), scoring.rb",
    "label": "what",
    "id": "756"
  },
  {
    "raw_code": "def compute_total_score(assignment, scores)\n    total = 0\n    assignment.questionnaires.each { |questionnaire| total += questionnaire.get_weighted_score(assignment, scores) }\n    total\n  end",
    "comment": "Compute total score for this assignment by summing the scores given on all questionnaires. Only scores passed in are included in this sum. Called in: scoring.rb",
    "label": "what",
    "id": "757"
  },
  {
    "raw_code": "def review_grades(assignment, questions)\n    scores = { participants: {}, teams: {} }\n    assignment.participants.each do |participant|\n      scores[:participants][participant.id.to_s.to_sym] = participant_scores(participant, questions)\n    end",
    "comment": "Computes and returns the scores of assignment for participants and teams Returns data in the format of { :particpant => { :<participant_id> => participant_scores(participant, questions), :<participant_id> => participant_scores(participant, questions) }, :teams => { :0 => {:team => team, :scores => assignment.vary_by_round? ? merge_grades_by_rounds(assignment, grades_by_rounds, total_num_of_assessments, total_score) : aggregate_assessment_scores(assessments, questions[:review]) } , :1 => {:team => team, :scores => assignment.vary_by_round? ? merge_grades_by_rounds(assignment, grades_by_rounds, total_num_of_assessments, total_score) : aggregate_assessment_scores(assessments, questions[:review]) } , } } Called in: grades_controller.rb (view), assignment.rb (self.export)",
    "label": "what",
    "id": "758"
  },
  {
    "raw_code": "def participant_scores(participant, questions)\n    assignment = participant.assignment\n    scores = {}\n    scores[:participant] = participant\n    compute_assignment_score(participant, questions, scores)\n    # Compute the Total Score (with question weights factored in)\n    scores[:total_score] = compute_total_score(assignment, scores)\n\n    # merge scores[review#] (for each round) to score[review]\n    merge_scores(participant, scores) if assignment.varying_rubrics_by_round?\n    # In the event that this is a microtask, we need to scale the score accordingly and record the total possible points\n    if assignment.microtask?\n      topic = SignUpTopic.find_by(assignment_id: assignment.id)\n      return if topic.nil?\n\n      scores[:total_score] *= (topic.micropayment.to_f / 100.to_f)\n      scores[:max_pts_available] = topic.micropayment\n    end",
    "comment": "Return scores that this participant has been given Returns data in the format of { :total_score => participant.grade ? particpant.grade : compute_total_score(assignment, scores) :max_pts_available => topic.micropayment if assignment.topics? :participant => participant, :questionnaire_symbol1 => { :assessments => {review1, review2}, :scores => aggregate_assessment_scores(scores[questionnaire_symbol][:assessments], questions[questionnaire_symbol]) }, :questionnaire_symbol2 => { :assessments => {review3, review4}, :scores => aggregate_assessment_scores(scores[questionnaire_symbol][:assessments], questions[questionnaire_symbol]) }, :review => { :assessments => [review1, review2, review3, review4], :scores => {:max => max_score, :min => min_score, :avg => average_score} } } Called in: assessment360_controller.rb (find_peer_review_score), grades_controller.rb (view_my_scores, view_team, edit), scoring.rb",
    "label": "what",
    "id": "759"
  },
  {
    "raw_code": "def compute_assignment_score(participant, questions, scores)\n    participant.assignment.questionnaires.each do |questionnaire|\n      round = AssignmentQuestionnaire.find_by(assignment_id: participant.assignment.id, questionnaire_id: questionnaire.id).used_in_round\n      # create symbol for \"varying rubrics\" feature -Yang\n      questionnaire_symbol = if round.nil?\n                               questionnaire.symbol\n                             else\n                               (questionnaire.symbol.to_s + round.to_s).to_sym\n                             end",
    "comment": "this function modifies the scores object passed to it from participant_grades this function should not be called in other contexts, since it is highly dependent on a specific scores structure, described above retrieves the symbol of eeach questionnaire associated with a participant on a given assignment returns all the associated reviews with a participant, indexed under :assessments returns the score assigned for the TOTAL body of responses associated with the user Called in: scoring.rb",
    "label": "what",
    "id": "760"
  },
  {
    "raw_code": "def merge_scores(participant, scores)\n    review_sym = 'review'.to_sym\n    scores[review_sym] = {}\n    scores[review_sym][:assessments] = []\n    scores[review_sym][:scores] = { max: -999_999_999, min: 999_999_999, avg: 0 }\n    total_score = 0\n    (1..participant.assignment.num_review_rounds).each do |i|\n      round_sym = ('review' + i.to_s).to_sym\n      # check if that assignment round is empty\n      next if scores[round_sym].nil? || scores[round_sym][:assessments].nil? || scores[round_sym][:assessments].empty?\n\n      length_of_assessments = scores[round_sym][:assessments].length.to_f\n      scores[review_sym][:assessments] += scores[round_sym][:assessments]\n\n      # update the max value if that rounds max exists and is higher than the current max\n      update_max_or_min(scores, round_sym, review_sym, :max)\n      # update the min value if that rounds min exists and is lower than the current min\n      update_max_or_min(scores, round_sym, review_sym, :min)\n      # Compute average score for current round, and sets overall total score to be average_from_round * length of assignment (# of questions)\n      total_score += scores[round_sym][:scores][:avg] * length_of_assessments unless scores[round_sym][:scores][:avg].nil?\n    end",
    "comment": "for each assignment review all scores and determine a max, min and average value this will be called when the assignment has various rounds, so we need to aggregate the scores across rounds achieves this by returning all the reviews, no longer delineated by round, and by returning the max, min and average Called in: scoring.rb",
    "label": "what",
    "id": "761"
  },
  {
    "raw_code": "def update_max_or_min(scores, round_sym, review_sym, symbol)\n    op = :< if symbol == :max\n    op = :> if symbol == :min\n    # check if there is a max/min score for this particular round\n    unless scores[round_sym][:scores][symbol].nil?\n      # if scores[review_sym][:scores][symbol] (< or >) scores[round_sym][:scores][symbol]\n      if scores[review_sym][:scores][symbol].send(op, scores[round_sym][:scores][symbol])\n        scores[review_sym][:scores][symbol] = scores[round_sym][:scores][symbol]\n      end",
    "comment": "Called in: scoring.rb",
    "label": "what",
    "id": "762"
  },
  {
    "raw_code": "def compute_reviews_hash(assignment)\n    review_scores = {}\n    response_type = 'ReviewResponseMap'\n    response_maps = ResponseMap.where(reviewed_object_id: assignment.id, type: response_type)\n    if assignment.varying_rubrics_by_round?\n      review_scores = scores_varying_rubrics(assignment, review_scores, response_maps)\n    else\n      review_scores = scores_non_varying_rubrics(assignment, review_scores, response_maps)\n    end",
    "comment": "Called in: report_formatter_helper.rb (review_response_map)",
    "label": "what",
    "id": "763"
  },
  {
    "raw_code": "def compute_avg_and_ranges_hash(assignment)\n    scores = {}\n    contributors = assignment.contributors # assignment_teams\n    if assignment.varying_rubrics_by_round?\n      rounds = assignment.rounds_of_reviews\n      (1..rounds).each do |round|\n        contributors.each do |contributor|\n          questions = peer_review_questions_for_team(assignment, contributor, round)\n          assessments = ReviewResponseMap.assessments_for(contributor)\n          assessments.select! { |assessment| assessment.round == round }\n          scores[contributor.id] = {} if round == 1\n          scores[contributor.id][round] = {}\n          scores[contributor.id][round] = aggregate_assessment_scores(assessments, questions)\n        end",
    "comment": "calculate the avg score and score range for each reviewee(team), only for peer-review Called in: report_formatter_helper.rb (review_response_map)",
    "label": "what",
    "id": "764"
  },
  {
    "raw_code": "def peer_review_questions_for_team(assignment, team, round_number = nil)\n  return nil if team.nil?\n\n  signed_up_team = SignedUpTeam.find_by(team_id: team.id)\n  topic_id = signed_up_team.topic_id unless signed_up_team.nil?\n  review_questionnaire_id = assignment.review_questionnaire_id(round_number, topic_id) unless team.nil?\n  Question.where(questionnaire_id: review_questionnaire_id).to_a unless team.nil?\nend",
    "comment": "Get all of the questions asked during peer review for the given team's work",
    "label": "what",
    "id": "765"
  },
  {
    "raw_code": "def compute_grades_by_rounds(assignment, questions, team)\n  grades_by_rounds = {}\n  total_score = 0\n  total_num_of_assessments = 0 # calculate grades for each rounds\n  (1..assignment.num_review_rounds).each do |i|\n    assessments = ReviewResponseMap.get_responses_for_team_round(team, i)\n    round_sym = ('review' + i.to_s).to_sym\n    grades_by_rounds[round_sym] = aggregate_assessment_scores(assessments, questions[round_sym])\n    total_num_of_assessments += assessments.size\n    total_score += grades_by_rounds[round_sym][:avg] * assessments.size.to_f unless grades_by_rounds[round_sym][:avg].nil?\n  end",
    "comment": "Below private methods are extracted and added as part of refactoring project E2009 - Spring 2020 This method computes and returns grades by rounds, total_num_of_assessments and total_score when the assignment has varying rubrics by round",
    "label": "what",
    "id": "766"
  },
  {
    "raw_code": "def merge_grades_by_rounds(assignment, grades_by_rounds, num_of_assessments, total_score)\n  team_scores = { max: 0, min: 0, avg: nil }\n  return team_scores if num_of_assessments.zero?\n\n  team_scores[:max] = -999_999_999\n  team_scores[:min] = 999_999_999\n  team_scores[:avg] = total_score / num_of_assessments\n  (1..assignment.num_review_rounds).each do |i|\n    round_sym = ('review' + i.to_s).to_sym\n    unless grades_by_rounds[round_sym][:max].nil? || team_scores[:max] >= grades_by_rounds[round_sym][:max]\n      team_scores[:max] = grades_by_rounds[round_sym][:max]\n    end",
    "comment": "merge the grades from multiple rounds",
    "label": "what",
    "id": "767"
  },
  {
    "raw_code": "def self.up\n    create_table :review_of_review_mappings do |t|\n      t.column :review_mapping_id, :integer # the review that is being reviewed.  Note that the review_mapping_id allows us to retrieve reviews done by a particular reviewer of *all* versions of an author's submission.\n      t.column :reviewer_id, :integer # the id of the user reviewing this review.\n      t.column :review_id, :integer # REVIEW: that is being reviewed\n    end",
    "comment": "This table should have essentially the same format as review_mappings",
    "label": "what",
    "id": "768"
  },
  {
    "raw_code": "def self.up\n    create_table :roles do |t|\n      # t.column :name, :string\n      t.column :name, :string, limit: 32\n    end",
    "comment": "This table need not be created in migration, as it is already created by Goldberg",
    "label": "what",
    "id": "769"
  },
  {
    "raw_code": "def self.up\n    create_table :reviews do |t|\n      t.column :reviewed_at, :datetime # time that the review was saved\n      t.column :review_mapping_id, :integer # the entry in the review_mappings table identifies reviewer and reviewee\n      t.column :review_num_for_author, :integer # on author's review page, the review is listed as having this number\n      t.column :review_num_for_reviewer, :integer # on reviewer's review page, the review is listed as having this number\n      # Understand that, in dynamically mapped reviews, reviewer A may review authors B and C, and may be the first\n      # person to review both B and C.  So (s)he will be B's reviewer number 1 and C's reviewer number 1.  However, B\n      # and C can't both be his review #1.\n      # Ditto for team review, where teams get more reviews than each individual writes.\n    end",
    "comment": "This table should have essentially the same format as review_of_reviews",
    "label": "what",
    "id": "770"
  },
  {
    "raw_code": "def self.up\n    create_table :review_mappings do |t|\n      t.column :author_id, :integer # if an individual is being reviewed, this field is non-null, otherwise is null\n      t.column :team_id, :integer   # if a team is being reviewed, this field is non-null, otherwise is null\n      t.column :reviewer_id, :integer\n      t.column :assignment_id, :integer # assignment that is being reviewed\n    end",
    "comment": "This table should have essentially the same format as review_of_review_mappings",
    "label": "what",
    "id": "771"
  },
  {
    "raw_code": "def self.up\n    create_table :review_of_reviews do |t|\n      t.column :reviewed_at, :datetime # time that the review of review was saved\n      t.column :review_of_review_mapping_id, :integer # the entry in the review_of_review_mappings table that identifies reviewer and review\n      t.column :review_num_for_author, :integer # on reviewee's review page, the review is listed as having this number\n      t.column :review_num_for_reviewer, :integer # on reviewer's review page, the review is listed as having this number\n      # Understand that, in dynamically mapped reviews, reviewer A may review reviewees B and C, and may be the first\n      # entity to review both B and C.  So (s)he will be B's reviewer number 1 and C's reviewer number 1.  However, B\n      # and C can't both be his review #1.\n      # This logic caters for the situation where the entity doing the reviews of reviews is different than the entity\n      # doing reviews (e.g., teams are doing the reviews (of other teams), whereas individuals are doing the reviews\n      # of the reviews (that were done by teams)).\n    end",
    "comment": "This table should have essentially the same format as (the table) reviews",
    "label": "what",
    "id": "772"
  },
  {
    "raw_code": "def self.up\n    entries = ActiveRecord::Base.connection.select_all('SELECT * FROM review_feedbacks f1 WHERE review_id IN (SELECT review_id FROM `review_feedbacks` GROUP BY review_id HAVING count(*) > 1)')\n\n    max_update = nil\n    max_id = nil\n    current_review = nil\n    entries.each do |entry|\n      if entry['review_id'].to_i != current_review\n        current_review = entry['review_id'].to_i\n        max_update = entry['updated_at'] if entry['updated_at']\n\n      elsif (entry['updated_at'] && (entry['updated_at'] > max_update) && (max_id > 0)) ||\n            ((entry.id > max_id) && (max_id > 0))\n        execute \"delete from review_feedbacks where id = #{max_id}\"\n      end",
    "comment": "delete any duplicate feedback objects. Keep only the most current",
    "label": "what",
    "id": "773"
  },
  {
    "raw_code": "def self.make_participant(user_id, assignment_id)\n    participant = nil\n    if user_id.to_i > 0\n      user = User.find(user_id)\n      if user\n        participant = AssignmentParticipant.where(user_id: user_id, parent_id: assignment_id).first\n\n        if participant.nil?\n          participant = AssignmentParticipant.create(user_id: user_id, parent_id: assignment_id)\n          participant.set_handle\n        end",
    "comment": "create a participant based on a user and assignment",
    "label": "what",
    "id": "774"
  },
  {
    "raw_code": "def self.up\n    change_column :assignments, :course_id, :integer, null: true\n    change_column :assignments, :instructor_id, :integer, null: true\n    change_column :assignments, :review_strategy_id, :integer, null: true\n    change_column :assignments, :mapping_strategy_id, :integer, null: true\n\n    Assignment.find_each do |assignment|\n      if assignment.course_id.nil? || (assignment.course_id == 0) || Course.find(assignment.course_id).nil?\n        assignment.update_attribute('course_id', nil)\n      end",
    "comment": "add/remove indices and foreign keys when appropriate",
    "label": "what",
    "id": "775"
  },
  {
    "raw_code": "def self.get_participant_reviewer(mapping)\n    make_participant(mapping['old_reviewer_id'], mapping['reviewed_object_id'])\n  end",
    "comment": "return the participant acting as reviewer for this mapping",
    "label": "what",
    "id": "776"
  },
  {
    "raw_code": "def self.get_participant_reviewee(mapping)\n    make_participant(mapping['author_id'], mapping['reviewed_object_id'])\n  end",
    "comment": "return the participant acting as reviewee for this mapping",
    "label": "what",
    "id": "777"
  },
  {
    "raw_code": "def self.get_team_reviewee(mapping)\n    if !mapping['team_id'].nil?\n      begin\n        reviewee = AssignmentTeam.find(mapping['team_id'])\n      rescue StandardError\n      end",
    "comment": "return the team acting as reviewee for this mapping",
    "label": "what",
    "id": "778"
  },
  {
    "raw_code": "def self.make_participant(user_id, assignment_id)\n    participant = nil\n    if user_id.to_i > 0\n      user = User.find(user_id)\n      if user\n        participant = AssignmentParticipant.where(user_id: user_id, parent_id: assignment_id).first\n\n        if participant.nil?\n          participant = AssignmentParticipant.create(user_id: user_id, parent_id: assignment_id)\n          participant.set_handle\n        end",
    "comment": "create a participant based on a user and assignment",
    "label": "what",
    "id": "779"
  },
  {
    "raw_code": "def self.create_team(mapping)\n    # if the author is not available, no team can be made\n    return nil if (mapping['author_id'] == 0) || mapping['author_id'].nil?\n\n    # create a participant for this user, all users have to be a participant in order to interact with an assignment\n    user = User.find(mapping['author_id'])\n    if AssignmentParticipant.where(user_id: mapping['author_id'], parent_id: mapping['reviewed_object_id']).first.nil?\n      make_participant(mapping['author_id'], mapping['reviewed_object_id'])\n    end",
    "comment": "if a team does not already exist to act as a reviewee, create it based on the author id provided",
    "label": "what",
    "id": "780"
  },
  {
    "raw_code": "def self.down\n    Participant.find_each do |p|\n      unless p.submitted_hyperlinks.nil?\n        multiple_hyperlinks = YAML.safe_load(p.submitted_hyperlinks).join(' ')\n        p.update_attribute :submitted_hyperlinks, multiple_hyperlinks\n      end",
    "comment": "Becareful when downgrading the database, because at this point there might be many multiple links values that are going to be converted to a space sparated string",
    "label": "what",
    "id": "781"
  },
  {
    "raw_code": "def test_this_plugin\n    flunk\n  end",
    "comment": "Replace this with your real tests.",
    "label": "what",
    "id": "782"
  },
  {
    "raw_code": "def verify(options={})\n        before_filter :only => options[:only], :except => options[:except] do\n          verify_action options\n        end",
    "comment": "Verify the given actions so that if certain prerequisites are not met, the user is redirected to a different action. The +options+ parameter is a hash consisting of the following key/value pairs:  <tt>:params</tt>:: a single key or an array of keys that must be in the <tt>params</tt> hash in order for the action(s) to be safely called. <tt>:session</tt>:: a single key or an array of keys that must be in the <tt>session</tt> in order for the action(s) to be safely called. <tt>:flash</tt>:: a single key or an array of keys that must be in the flash in order for the action(s) to be safely called. <tt>:method</tt>:: a single key or an array of keys--any one of which must match the current request method in order for the action(s) to be safely called. (The key should be a symbol: <tt>:get</tt> or <tt>:post</tt>, for example.) <tt>:xhr</tt>:: true/false option to ensure that the request is coming from an Ajax call or not. <tt>:add_flash</tt>:: a hash of name/value pairs that should be merged into the session's flash if the prerequisites cannot be satisfied. <tt>:add_headers</tt>:: a hash of name/value pairs that should be merged into the response's headers hash if the prerequisites cannot be satisfied. <tt>:redirect_to</tt>:: the redirection parameters to be used when redirecting if the prerequisites cannot be satisfied. You can redirect either to named route or to the action in some controller. <tt>:render</tt>:: the render parameters to be used when the prerequisites cannot be satisfied. <tt>:only</tt>:: only apply this verification to the actions specified in the associated array (may also be a single value). <tt>:except</tt>:: do not apply this verification to the actions specified in the associated array (may also be a single value).",
    "label": "what",
    "id": "783"
  },
  {
    "raw_code": "def input(record_name, method, options = {})\n        InstanceTag.new(record_name, method, self).to_tag(options)\n      end",
    "comment": "Returns a default input tag for the type of object returned by the method. For example, if <tt>@post</tt> has an attribute +title+ mapped to a +VARCHAR+ column that holds \"Hello World\":  input(\"post\", \"title\") # => <input id=\"post_title\" name=\"post[title]\" size=\"30\" type=\"text\" value=\"Hello World\" />",
    "label": "what",
    "id": "784"
  },
  {
    "raw_code": "def form(record_name, options = {})\n        record = instance_variable_get(\"@#{record_name}\")\n        record = convert_to_model(record)\n\n        options = options.symbolize_keys\n        options[:action] ||= record.persisted? ? \"update\" : \"create\"\n        action = url_for(:action => options[:action], :id => record)\n\n        submit_value = options[:submit_value] || options[:action].gsub(/[^\\w]/, '').capitalize\n\n        contents = form_tag({:action => action}, :method =>(options[:method] || 'post'), :enctype => options[:multipart] ? 'multipart/form-data': nil)\n        contents.safe_concat hidden_field(record_name, :id) if record.persisted?\n        contents.safe_concat all_input_tags(record, record_name, options)\n        yield contents if block_given?\n        contents.safe_concat submit_tag(submit_value)\n        contents.safe_concat('</form>')\n      end",
    "comment": "Returns an entire form with all needed input tags for a specified Active Record object. For example, if <tt>@post</tt> has attributes named +title+ of type +VARCHAR+ and +body+ of type +TEXT+ then  form(\"post\")  would yield a form like the following (modulus formatting):  <form action='/posts/create' method='post'> <p> <label for=\"post_title\">Title</label><br /> <input id=\"post_title\" name=\"post[title]\" size=\"30\" type=\"text\" value=\"Hello World\" /> </p> <p> <label for=\"post_body\">Body</label><br /> <textarea cols=\"40\" id=\"post_body\" name=\"post[body]\" rows=\"20\"></textarea> </p> <input name=\"commit\" type=\"submit\" value=\"Create\" /> </form>  It's possible to specialize the form builder by using a different action name and by supplying another block renderer. For example, if <tt>@entry</tt> has an attribute +message+ of type +VARCHAR+ then  form(\"entry\", :action => \"sign\", :input_block => Proc.new { |record, column| \"#{column.human_name}: #{input(record, column.name)}<br />\" })  would yield a form like the following (modulus formatting):  <form action=\"/entries/sign\" method=\"post\"> Message: <input id=\"entry_message\" name=\"entry[message]\" size=\"30\" type=\"text\" /><br /> <input name=\"commit\" type=\"submit\" value=\"Sign\" /> </form>  It's also possible to add additional content to the form by giving it a block, such as:  form(\"entry\", :action => \"sign\") do |form| form << content_tag(\"b\", \"Department\") form << collection_select(\"department\", \"id\", @departments, \"id\", \"name\") end  The following options are available:  * <tt>:action</tt> - The action used when submitting the form (default: +create+ if a new record, otherwise +update+). * <tt>:input_block</tt> - Specialize the output using a different block, see above. * <tt>:method</tt> - The method used when submitting the form (default: +post+). * <tt>:multipart</tt> - Whether to change the enctype of the form to \"multipart/form-data\", used when uploading a file (default: +false+). * <tt>:submit_value</tt> - The text of the submit button (default: \"Create\" if a new record, otherwise \"Update\").",
    "label": "what",
    "id": "785"
  },
  {
    "raw_code": "def error_message_on(object, method, *args)\n        options = args.extract_options!\n        unless args.empty?\n          ActiveSupport::Deprecation.warn('error_message_on takes an option hash instead of separate ' +\n            'prepend_text, append_text, html_tag, and css_class arguments', caller)\n\n          options[:prepend_text] = args[0] || ''\n          options[:append_text] = args[1] || ''\n          options[:html_tag] = args[2] || 'div'\n          options[:css_class] = args[3] || 'formError'\n        end",
    "comment": "Returns a string containing the error message attached to the +method+ on the +object+ if one exists. This error message is wrapped in a <tt>DIV</tt> tag by default or with <tt>:html_tag</tt> if specified, which can be extended to include a <tt>:prepend_text</tt> and/or <tt>:append_text</tt> (to properly explain the error), and a <tt>:css_class</tt> to style it accordingly. +object+ should either be the name of an instance variable or the actual object. The method can be passed in either as a string or a symbol. As an example, let's say you have a model <tt>@post</tt> that has an error message on the +title+ attribute:  <%= error_message_on \"post\", \"title\" %> # => <div class=\"formError\">can't be empty</div>  <%= error_message_on @post, :title %> # => <div class=\"formError\">can't be empty</div>  <%= error_message_on \"post\", \"title\", :prepend_text => \"Title simply \", :append_text => \" (or it won't work).\", :html_tag => \"span\", :css_class => \"inputError\" %> # => <span class=\"inputError\">Title simply can't be empty (or it won't work).</span>",
    "label": "what",
    "id": "786"
  },
  {
    "raw_code": "def error_messages_for(*params)\n        options = params.extract_options!.symbolize_keys\n\n        objects = Array.wrap(options.delete(:object) || params).map do |object|\n          object = instance_variable_get(\"@#{object}\") unless object.respond_to?(:to_model)\n          object = convert_to_model(object)\n\n          if object.class.respond_to?(:model_name)\n            options[:object_name] ||= object.class.model_name.human.downcase\n          end",
    "comment": "Returns a string with a <tt>DIV</tt> containing all of the error messages for the objects located as instance variables by the names given.  If more than one object is specified, the errors for the objects are displayed in the order that the object names are provided.  This <tt>DIV</tt> can be tailored by the following options:  * <tt>:header_tag</tt> - Used for the header of the error div (default: \"h2\"). * <tt>:id</tt> - The id of the error div (default: \"errorExplanation\"). * <tt>:class</tt> - The class of the error div (default: \"errorExplanation\"). * <tt>:object</tt> - The object (or array of objects) for which to display errors, if you need to escape the instance variable convention. * <tt>:object_name</tt> - The object name to use in the header, or any text that you prefer. If <tt>:object_name</tt> is not set, the name of the first object will be used. * <tt>:header_message</tt> - The message in the header of the error div.  Pass +nil+ or an empty string to avoid the header message altogether. (Default: \"X errors prohibited this object from being saved\"). * <tt>:message</tt> - The explanation message after the header message and before the error list.  Pass +nil+ or an empty string to avoid the explanation message altogether. (Default: \"There were problems with the following fields:\").  To specify the display for one object, you simply provide its name as a parameter. For example, for the <tt>@user</tt> model:  error_messages_for 'user'  You can also supply an object:  error_messages_for @user  This will use the last part of the model name in the presentation. For instance, if this is a MyKlass::User object, this will use \"user\" as the name in the String. This is taken from MyKlass::User.model_name.human, which can be overridden.  To specify more than one object, you simply list them; optionally, you can add an extra <tt>:object_name</tt> parameter, which will be the name used in the header message:  error_messages_for 'user_common', 'user', :object_name => 'user'  You can also use a number of objects, which will have the same naming semantics as a single object.  error_messages_for @user, @post  If the objects cannot be located as instance variables, you can add an extra <tt>:object</tt> parameter which gives the actual object (or array of objects to use):  error_messages_for 'user', :object => @question.user  NOTE: This is a pre-packaged presentation of the errors with embedded strings and a certain HTML structure. If what you need is significantly different from the default presentation, it makes plenty of sense to access the <tt>object.errors</tt> instance yourself and set it up. View the source of this method to see how easy it is.",
    "label": "what",
    "id": "787"
  }
]