id,category,raw_code_preview,gold_comment,Set 1 (Llama-3),Set 2 (Phi-2),Set 3 (Phi-3-mini)
101,property,"def num_reviews_greater?(reviews_required, reviews_allowed) reviews_allowed && reviews_allowed != -1 && reviews_required > reviews_allowed …",returns true if reviews required is greater than reviews allowed,"# Returns true if the number of required reviews exceeds the allowed reviews, false otherwise # Assumptions: reviews_required and reviews_allowed are positive integers # Guarantees: returns a boolean value indicating whether the condition holds true.","# Returns true if the number of allowed reviews exceeds the required ones
# Assumes reviews_required and reviews_allowed are non-negative integers",# Checks whether there's at least one review allowed but fewer than required; both conditions should not be negative numbers
170,property,def update_assignment(attributes) unless @assignment.update_attributes(attributes) @errors = @assignment.errors.to_s @has_errors = true end,Code to update values of assignment,# Updates the assignment with new attributes; sets @has_errors and @errors if validation fails.,"# Updates the assignment object's attributes using the given array of attributes
# If there are any errors during the update process, they will be stored in the @errors attribute
# The @has_errors flag will be set to true if there were any errors",
62,property,"def self.post_similarity_nxn(comparison_id, callback_url = '') full_url = @@base_uri + '/similarity_nxn/' + comparison_id json_body = …",Starts the computation of file similarity for a comparison Parameters: comparison_id - string id of the comparison to update Returns: response = RestClient::Response,,"# Calls the REST API endpoint /similarity_nxn/<comparison_id> to calculate similarity between two nodes in the network.
# The response contains a JSON object with the following fields:
#   -'similarity': A float representing the similarity score between the two nodes.",# Posts similarity data in nxn format using REST client; requires `comparison_id` and optional customizable `callback_url`; uses API key stored in `@@api_key`.
659,property,"def get_team_reviewed_link_name(max_team_size, _response, reviewee_id, ip_address) team_reviewed_link_name = if max_team_size == 1 …","For assignments with 1 team member, the following method returns user's fullname else it returns ""team name"" that a particular reviewee belongs to.","# Returns the name of the reviewed team link based on the maximum team size and the reviewee's ID;
# assumes valid input values for max_team_size, reviewee_id, and ip_address.","# Returns the name of the team member that has reviewed the given reviewee's work,
# based on the maximum number of members allowed in the team (max_team_size),
# the response object returned by the API call, the reviewee's ID, and their IP address.","`# Generates link name based on whether there's only one member in the reviewer's team; uses fullname when single, falls back to default `Team` name.`"
785,property,"def form(record_name, options = {}) record = instance_variable_get(""@#{record_name}"") record = convert_to_model(record) options = …","Returns an entire form with all needed input tags for a specified Active Record object. For example, if <tt>@post</tt> has attributes named +title+ of type +VARCHAR+ and +body+ of type +TEXT+ then  form(""post"")  would yield a form like the following (modulus formatting):  <form action='/posts/create' method='post'> <p> <label for=""post_title"">Title</label><br /> <input id=""post_title"" name=""post[title]"" size=""30"" type=""text"" value=""Hello World"" /> </p> <p> <label for=""post_body"">Body</label><br /> <textarea cols=""40"" id=""post_body"" name=""post[body]"" rows=""20""></textarea> </p> <input name=""commit"" type=""submit"" value=""Create"" /> </form>  It's possible to specialize the form builder by using a different action name and by supplying another block renderer. For example, if <tt>@entry</tt> has an attribute +message+ of type +VARCHAR+ then  form(""entry"", :action => ""sign"", :input_block => Proc.new { |record, column| ""#{column.human_name}: #{input(record, column.name)}<br />"" })  would yield a form like the following (modulus formatting):  <form action=""/entries/sign"" method=""post""> Message: <input id=""entry_message"" name=""entry[message]"" size=""30"" type=""text"" /><br /> <input name=""commit"" type=""submit"" value=""Sign"" /> </form>  It's also possible to add additional content to the form by giving it a block, such as:  form(""entry"", :action => ""sign"") do |form| form << content_tag(""b"", ""Department"") form << collection_select(""department"", ""id"", @departments, ""id"", ""name"") end  The following options are available:  * <tt>:action</tt> - The action used when submitting the form (default: +create+ if a new record, otherwise +update+). * <tt>:input_block</tt> - Specialize the output using a different block, see above. * <tt>:method</tt> - The method used when submitting the form (default: +post+). * <tt>:multipart</tt> - Whether to change the enctype of the form to ""multipart/form-data"", used when uploading a file (default: +false+). * <tt>:submit_value</tt> - The text of the submit button (default: ""Create"" if a new record, otherwise ""Update"").",,"# Form method that creates or updates a model instance based on its name and optional options
# Uses the @record variable as a reference to the model object
# Accepts a POST request with a JSON payload containing the form data","# Generates HTML form code based on model attributes; optionally updates existing records (if persisted), creates new ones by default; customizable submission button text via `submit_value`; supports additional input fields through blocks"
